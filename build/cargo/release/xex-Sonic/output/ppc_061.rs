pub fn sub_8265BF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265BF30 size=424
    let mut pc: u32 = 0x8265BF30;
    'dispatch: loop {
        match pc {
            0x8265BF30 => {
    //   block [0x8265BF30..0x8265C0D8)
	// 8265BF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265BF34: 48B4C239  bl 0x831a816c
	ctx.lr = 0x8265BF38;
	sub_831A8130(ctx, base);
	// 8265BF38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265BF3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265BF40: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8265BF44: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8265BF48: 4BEB5A91  bl 0x825119d8
	ctx.lr = 0x8265BF4C;
	sub_825119D8(ctx, base);
	// 8265BF4C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8265BF50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265BF54: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8265BF58: 48797AB1  bl 0x82df3a08
	ctx.lr = 0x8265BF5C;
	sub_82DF3A08(ctx, base);
	// 8265BF5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265BF60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265BF64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265BF68: 4BEAC819  bl 0x82508780
	ctx.lr = 0x8265BF6C;
	sub_82508780(ctx, base);
	// 8265BF6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265BF70: 487974B9  bl 0x82df3428
	ctx.lr = 0x8265BF74;
	sub_82DF3428(ctx, base);
	// 8265BF74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265BF78: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8265BF7C: 409A0008  bne cr6, 0x8265bf84
	if !ctx.cr[6].eq {
	pc = 0x8265BF84; continue 'dispatch;
	}
	// 8265BF80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265BF84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265BF88: 4BEAC819  bl 0x825087a0
	ctx.lr = 0x8265BF8C;
	sub_825087A0(ctx, base);
	// 8265BF8C: 397F00FC  addi r11, r31, 0xfc
	ctx.r[11].s64 = ctx.r[31].s64 + 252;
	// 8265BF90: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 8265BF94: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8265BF98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265BF9C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 8265BFA0: 4BC684C1  bl 0x822c4460
	ctx.lr = 0x8265BFA4;
	sub_822C4460(ctx, base);
	// 8265BFA4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265BFA8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265BFAC: 487CEB3D  bl 0x82e2aae8
	ctx.lr = 0x8265BFB0;
	sub_82E2AAE8(ctx, base);
	// 8265BFB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265BFB4: 4BFFFE4D  bl 0x8265be00
	ctx.lr = 0x8265BFB8;
	sub_8265BE00(ctx, base);
	// 8265BFB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265BFBC: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 8265BFC0: 4BC8B249  bl 0x822e7208
	ctx.lr = 0x8265BFC4;
	sub_822E7208(ctx, base);
	// 8265BFC4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265BFC8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8265BFCC: 3BCB5E54  addi r30, r11, 0x5e54
	ctx.r[30].s64 = ctx.r[11].s64 + 24148;
	// 8265BFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265BFD4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8265BFD8: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8265BFDC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8265BFE0: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8265BFE4: 48797A25  bl 0x82df3a08
	ctx.lr = 0x8265BFE8;
	sub_82DF3A08(ctx, base);
	// 8265BFE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265BFEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265BFF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265BFF4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8265BFF8: 4BC8B399  bl 0x822e7390
	ctx.lr = 0x8265BFFC;
	sub_822E7390(ctx, base);
	// 8265BFFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265C000: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265C004: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8265C008: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C00C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8265C010: 4BC68451  bl 0x822c4460
	ctx.lr = 0x8265C014;
	sub_822C4460(ctx, base);
	// 8265C014: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8265C018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265C01C: 419A0008  beq cr6, 0x8265c024
	if ctx.cr[6].eq {
	pc = 0x8265C024; continue 'dispatch;
	}
	// 8265C020: 4BC64871  bl 0x822c0890
	ctx.lr = 0x8265C024;
	sub_822C0890(ctx, base);
	// 8265C024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C028: 48797401  bl 0x82df3428
	ctx.lr = 0x8265C02C;
	sub_82DF3428(ctx, base);
	// 8265C02C: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8265C030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C034: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8265C038: 7C8BF02E  lwzx r4, r11, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8265C03C: 487979CD  bl 0x82df3a08
	ctx.lr = 0x8265C040;
	sub_82DF3A08(ctx, base);
	// 8265C040: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 8265C044: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8265C048: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265C04C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265C050: 4BC92689  bl 0x822ee6d8
	ctx.lr = 0x8265C054;
	sub_822EE6D8(ctx, base);
	// 8265C054: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265C058: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 8265C05C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8265C060: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8265C064: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C068: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8265C06C: 4BC683F5  bl 0x822c4460
	ctx.lr = 0x8265C070;
	sub_822C4460(ctx, base);
	// 8265C070: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8265C074: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265C078: 419A0008  beq cr6, 0x8265c080
	if ctx.cr[6].eq {
	pc = 0x8265C080; continue 'dispatch;
	}
	// 8265C07C: 4BC64815  bl 0x822c0890
	ctx.lr = 0x8265C080;
	sub_822C0890(ctx, base);
	// 8265C080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C084: 487973A5  bl 0x82df3428
	ctx.lr = 0x8265C088;
	sub_82DF3428(ctx, base);
	// 8265C088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C08C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C090: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C094: 4BEB6085  bl 0x82512118
	ctx.lr = 0x8265C098;
	sub_82512118(ctx, base);
	// 8265C098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8265C09C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265C0A0: 4BC91EC1  bl 0x822edf60
	ctx.lr = 0x8265C0A4;
	sub_822EDF60(ctx, base);
	// 8265C0A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265C0A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C0AC: 4BEB4C95  bl 0x82510d40
	ctx.lr = 0x8265C0B0;
	sub_82510D40(ctx, base);
	// 8265C0B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265C0B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265C0B8: 419A0008  beq cr6, 0x8265c0c0
	if ctx.cr[6].eq {
	pc = 0x8265C0C0; continue 'dispatch;
	}
	// 8265C0BC: 4BC647D5  bl 0x822c0890
	ctx.lr = 0x8265C0C0;
	sub_822C0890(ctx, base);
	// 8265C0C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265C0C4: 4BC8B15D  bl 0x822e7220
	ctx.lr = 0x8265C0C8;
	sub_822E7220(ctx, base);
	// 8265C0C8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265C0CC: 487CEA35  bl 0x82e2ab00
	ctx.lr = 0x8265C0D0;
	sub_82E2AB00(ctx, base);
	// 8265C0D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8265C0D4: 48B4C0E8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C0D8 size=68
    let mut pc: u32 = 0x8265C0D8;
    'dispatch: loop {
        match pc {
            0x8265C0D8 => {
    //   block [0x8265C0D8..0x8265C11C)
	// 8265C0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C0E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C0E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C0E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8265C0EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C0F0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8265C0F4: 38BF00E8  addi r5, r31, 0xe8
	ctx.r[5].s64 = ctx.r[31].s64 + 232;
	// 8265C0F8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8265C0FC: 4BEB40F5  bl 0x825101f0
	ctx.lr = 0x8265C100;
	sub_825101F0(ctx, base);
	// 8265C100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C104: 4BFFFCFD  bl 0x8265be00
	ctx.lr = 0x8265C108;
	sub_8265BE00(ctx, base);
	// 8265C108: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265C10C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C110: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C114: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C118: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C120 size=128
    let mut pc: u32 = 0x8265C120;
    'dispatch: loop {
        match pc {
            0x8265C120 => {
    //   block [0x8265C120..0x8265C1A0)
	// 8265C120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C124: 48B4C049  bl 0x831a816c
	ctx.lr = 0x8265C128;
	sub_831A8130(ctx, base);
	// 8265C128: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C12C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8265C130: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8265C134: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C138: 3BEB80AC  addi r31, r11, -0x7f54
	ctx.r[31].s64 = ctx.r[11].s64 + -32596;
	// 8265C13C: 816A80B4  lwz r11, -0x7f4c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32588 as u32) ) } as u64;
	// 8265C140: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8265C144: 40820024  bne 0x8265c168
	if !ctx.cr[0].eq {
	pc = 0x8265C168; continue 'dispatch;
	}
	// 8265C148: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8265C14C: 3D008266  lis r8, -0x7d9a
	ctx.r[8].s64 = -2107244544;
	// 8265C150: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8265C154: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 8265C158: 3908BBF8  addi r8, r8, -0x4408
	ctx.r[8].s64 = ctx.r[8].s64 + -17416;
	// 8265C15C: 916A80B4  stw r11, -0x7f4c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32588 as u32), ctx.r[11].u32 ) };
	// 8265C160: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8265C164: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8265C168: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265C16C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8265C170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C174: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8265C178: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8265C17C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265C180: 4BFF8441  bl 0x826545c0
	ctx.lr = 0x8265C184;
	sub_826545C0(ctx, base);
	// 8265C184: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265C188: 4182000C  beq 0x8265c194
	if ctx.cr[0].eq {
	pc = 0x8265C194; continue 'dispatch;
	}
	// 8265C18C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265C190: 48000008  b 0x8265c198
	pc = 0x8265C198; continue 'dispatch;
	// 8265C194: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8265C198: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265C19C: 48B4C020  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265C1A0 size=440
    let mut pc: u32 = 0x8265C1A0;
    'dispatch: loop {
        match pc {
            0x8265C1A0 => {
    //   block [0x8265C1A0..0x8265C358)
	// 8265C1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C1A4: 48B4BFC5  bl 0x831a8168
	ctx.lr = 0x8265C1A8;
	sub_831A8130(ctx, base);
	// 8265C1A8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C1AC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265C1B0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8265C1B4: 3BCB9AF8  addi r30, r11, -0x6508
	ctx.r[30].s64 = ctx.r[11].s64 + -25864;
	// 8265C1B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265C1BC: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 8265C1C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265C1C4: 38600104  li r3, 0x104
	ctx.r[3].s64 = 260;
	// 8265C1C8: 48796221  bl 0x82df23e8
	ctx.lr = 0x8265C1CC;
	sub_82DF23E8(ctx, base);
	// 8265C1CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265C1D0: 41820010  beq 0x8265c1e0
	if ctx.cr[0].eq {
	pc = 0x8265C1E0; continue 'dispatch;
	}
	// 8265C1D4: 4BFFFAB5  bl 0x8265bc88
	ctx.lr = 0x8265C1D8;
	sub_8265BC88(ctx, base);
	// 8265C1D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C1DC: 48000008  b 0x8265c1e4
	pc = 0x8265C1E4; continue 'dispatch;
	// 8265C1E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265C1E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8265C1E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C1EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265C1F0: 4BFFF941  bl 0x8265bb30
	ctx.lr = 0x8265C1F4;
	sub_8265BB30(ctx, base);
	// 8265C1F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265C1F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C1FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265C200: 4BC63E01  bl 0x822c0000
	ctx.lr = 0x8265C204;
	sub_822C0000(ctx, base);
	// 8265C204: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265C208: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8265C20C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8265C210: 409A0008  bne cr6, 0x8265c218
	if !ctx.cr[6].eq {
	pc = 0x8265C218; continue 'dispatch;
	}
	// 8265C214: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C218: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8265C21C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8265C220: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265C224: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8265C228: 419A0024  beq cr6, 0x8265c24c
	if ctx.cr[6].eq {
	pc = 0x8265C24C; continue 'dispatch;
	}
	// 8265C22C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265C230: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8265C234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265C238: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8265C23C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8265C240: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265C244: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265C248: 4082FFE8  bne 0x8265c230
	if !ctx.cr[0].eq {
	pc = 0x8265C230; continue 'dispatch;
	}
	// 8265C24C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8265C250: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265C254: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8265C258: 419A0024  beq cr6, 0x8265c27c
	if ctx.cr[6].eq {
	pc = 0x8265C27C; continue 'dispatch;
	}
	// 8265C25C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265C260: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265C264: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265C268: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265C26C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265C270: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265C274: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265C278: 4082FFE8  bne 0x8265c260
	if !ctx.cr[0].eq {
	pc = 0x8265C260; continue 'dispatch;
	}
	// 8265C27C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265C280: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8265C284: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8265C288: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8265C28C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265C290: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8265C294: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265C298: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265C29C: 4813CC95  bl 0x82798f30
	ctx.lr = 0x8265C2A0;
	sub_82798F30(ctx, base);
	// 8265C2A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265C2A4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265C2A8: C1810090  lfs f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265C2AC: C1610094  lfs f11, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8265C2B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265C2B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265C2B8: 38A00026  li r5, 0x26
	ctx.r[5].s64 = 38;
	// 8265C2BC: C00B95F4  lfs f0, -0x6a0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265C2C0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8265C2C4: C1AA9B50  lfs f13, -0x64b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265C2C8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265C2CC: EDAB0372  fmuls f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8265C2D0: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8265C2D4: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8265C2D8: 4BC64101  bl 0x822c03d8
	ctx.lr = 0x8265C2DC;
	sub_822C03D8(ctx, base);
	// 8265C2DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265C2E0: 41820014  beq 0x8265c2f4
	if ctx.cr[0].eq {
	pc = 0x8265C2F4; continue 'dispatch;
	}
	// 8265C2E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265C2E8: 4813F381  bl 0x8279b668
	ctx.lr = 0x8265C2EC;
	sub_8279B668(ctx, base);
	// 8265C2EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C2F0: 48000008  b 0x8265c2f8
	pc = 0x8265C2F8; continue 'dispatch;
	// 8265C2F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265C2F8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265C2FC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 8265C300: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C304: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265C308: 4BF3B949  bl 0x82597c50
	ctx.lr = 0x8265C30C;
	sub_82597C50(ctx, base);
	// 8265C30C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265C310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C314: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265C318: 4BC63CE9  bl 0x822c0000
	ctx.lr = 0x8265C31C;
	sub_822C0000(ctx, base);
	// 8265C31C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8265C320: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265C324: 419A0008  beq cr6, 0x8265c32c
	if ctx.cr[6].eq {
	pc = 0x8265C32C; continue 'dispatch;
	}
	// 8265C328: 4BC64569  bl 0x822c0890
	ctx.lr = 0x8265C32C;
	sub_822C0890(ctx, base);
	// 8265C32C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8265C330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265C334: 419A0008  beq cr6, 0x8265c33c
	if ctx.cr[6].eq {
	pc = 0x8265C33C; continue 'dispatch;
	}
	// 8265C338: 4BC64559  bl 0x822c0890
	ctx.lr = 0x8265C33C;
	sub_822C0890(ctx, base);
	// 8265C33C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265C340: 419A000C  beq cr6, 0x8265c34c
	if ctx.cr[6].eq {
	pc = 0x8265C34C; continue 'dispatch;
	}
	// 8265C344: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265C348: 4BC64549  bl 0x822c0890
	ctx.lr = 0x8265C34C;
	sub_822C0890(ctx, base);
	// 8265C34C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8265C350: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8265C354: 48B4BE64  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C358 size=128
    let mut pc: u32 = 0x8265C358;
    'dispatch: loop {
        match pc {
            0x8265C358 => {
    //   block [0x8265C358..0x8265C3D8)
	// 8265C358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C35C: 48B4BE11  bl 0x831a816c
	ctx.lr = 0x8265C360;
	sub_831A8130(ctx, base);
	// 8265C360: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C364: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8265C368: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8265C36C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C370: 3BEB80B8  addi r31, r11, -0x7f48
	ctx.r[31].s64 = ctx.r[11].s64 + -32584;
	// 8265C374: 816A80C0  lwz r11, -0x7f40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32576 as u32) ) } as u64;
	// 8265C378: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8265C37C: 40820024  bne 0x8265c3a0
	if !ctx.cr[0].eq {
	pc = 0x8265C3A0; continue 'dispatch;
	}
	// 8265C380: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 8265C384: 3D008266  lis r8, -0x7d9a
	ctx.r[8].s64 = -2107244544;
	// 8265C388: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8265C38C: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 8265C390: 3908BC40  addi r8, r8, -0x43c0
	ctx.r[8].s64 = ctx.r[8].s64 + -17344;
	// 8265C394: 916A80C0  stw r11, -0x7f40(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32576 as u32), ctx.r[11].u32 ) };
	// 8265C398: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8265C39C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8265C3A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265C3A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8265C3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C3AC: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8265C3B0: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8265C3B4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265C3B8: 4BFF8209  bl 0x826545c0
	ctx.lr = 0x8265C3BC;
	sub_826545C0(ctx, base);
	// 8265C3BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265C3C0: 4182000C  beq 0x8265c3cc
	if ctx.cr[0].eq {
	pc = 0x8265C3CC; continue 'dispatch;
	}
	// 8265C3C4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265C3C8: 48000008  b 0x8265c3d0
	pc = 0x8265C3D0; continue 'dispatch;
	// 8265C3CC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8265C3D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265C3D4: 48B4BDE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C3D8 size=496
    let mut pc: u32 = 0x8265C3D8;
    'dispatch: loop {
        match pc {
            0x8265C3D8 => {
    //   block [0x8265C3D8..0x8265C5C8)
	// 8265C3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C3DC: 48B4BD85  bl 0x831a8160
	ctx.lr = 0x8265C3E0;
	sub_831A8130(ctx, base);
	// 8265C3E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C3E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C3E8: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265C3EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265C3F0: 396BC0D8  addi r11, r11, -0x3f28
	ctx.r[11].s64 = ctx.r[11].s64 + -16168;
	// 8265C3F4: 3BBEFF1C  addi r29, r30, -0xe4
	ctx.r[29].s64 = ctx.r[30].s64 + -228;
	// 8265C3F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8265C3FC: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 8265C400: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8265C404: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8265C408: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265C40C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8265C410: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8265C414: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8265C418: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 8265C41C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 8265C420: 4BFFFD01  bl 0x8265c120
	ctx.lr = 0x8265C424;
	sub_8265C120(ctx, base);
	// 8265C424: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265C428: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265C42C: 388B9AF8  addi r4, r11, -0x6508
	ctx.r[4].s64 = ctx.r[11].s64 + -25864;
	// 8265C430: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 8265C434: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8265C438: 4BC63FA1  bl 0x822c03d8
	ctx.lr = 0x8265C43C;
	sub_822C03D8(ctx, base);
	// 8265C43C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8265C440: 41820060  beq 0x8265c4a0
	if ctx.cr[0].eq {
	pc = 0x8265C4A0; continue 'dispatch;
	}
	// 8265C444: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265C448: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8265C44C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265C450: 396BC0D8  addi r11, r11, -0x3f28
	ctx.r[11].s64 = ctx.r[11].s64 + -16168;
	// 8265C454: 388A9B60  addi r4, r10, -0x64a0
	ctx.r[4].s64 = ctx.r[10].s64 + -25760;
	// 8265C458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C45C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8265C460: 487975A9  bl 0x82df3a08
	ctx.lr = 0x8265C464;
	sub_82DF3A08(ctx, base);
	// 8265C464: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265C468: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 8265C46C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 8265C470: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265C474: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8265C478: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265C47C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 8265C480: 4BFFFED9  bl 0x8265c358
	ctx.lr = 0x8265C484;
	sub_8265C358(ctx, base);
	// 8265C484: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8265C488: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 8265C48C: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 8265C490: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265C494: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8265C498: 4BF4FCF9  bl 0x825ac190
	ctx.lr = 0x8265C49C;
	sub_825AC190(ctx, base);
	// 8265C49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C4A0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8265C4A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C4A8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265C4AC: 4BE96F0D  bl 0x824f33b8
	ctx.lr = 0x8265C4B0;
	sub_824F33B8(ctx, base);
	// 8265C4B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265C4B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265C4B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265C4BC: 4BC63B45  bl 0x822c0000
	ctx.lr = 0x8265C4C0;
	sub_822C0000(ctx, base);
	// 8265C4C0: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265C4C4: 4182000C  beq 0x8265c4d0
	if ctx.cr[0].eq {
	pc = 0x8265C4D0; continue 'dispatch;
	}
	// 8265C4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C4CC: 48796F5D  bl 0x82df3428
	ctx.lr = 0x8265C4D0;
	sub_82DF3428(ctx, base);
	// 8265C4D0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265C4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C4D8: 388B9B5C  addi r4, r11, -0x64a4
	ctx.r[4].s64 = ctx.r[11].s64 + -25764;
	// 8265C4DC: 4879752D  bl 0x82df3a08
	ctx.lr = 0x8265C4E0;
	sub_82DF3A08(ctx, base);
	// 8265C4E0: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8265C4E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265C4E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265C4EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C4F0: 4BF4F8D1  bl 0x825abdc0
	ctx.lr = 0x8265C4F4;
	sub_825ABDC0(ctx, base);
	// 8265C4F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C4F8: 48796F31  bl 0x82df3428
	ctx.lr = 0x8265C4FC;
	sub_82DF3428(ctx, base);
	// 8265C4FC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265C500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C504: 388B9B58  addi r4, r11, -0x64a8
	ctx.r[4].s64 = ctx.r[11].s64 + -25768;
	// 8265C508: 48797501  bl 0x82df3a08
	ctx.lr = 0x8265C50C;
	sub_82DF3A08(ctx, base);
	// 8265C50C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265C510: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8265C514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C518: 4BF4F8A9  bl 0x825abdc0
	ctx.lr = 0x8265C51C;
	sub_825ABDC0(ctx, base);
	// 8265C51C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C520: 48796F09  bl 0x82df3428
	ctx.lr = 0x8265C524;
	sub_82DF3428(ctx, base);
	// 8265C524: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265C528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C52C: 388B9B54  addi r4, r11, -0x64ac
	ctx.r[4].s64 = ctx.r[11].s64 + -25772;
	// 8265C530: 487974D9  bl 0x82df3a08
	ctx.lr = 0x8265C534;
	sub_82DF3A08(ctx, base);
	// 8265C534: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265C538: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8265C53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C540: 4BF4F881  bl 0x825abdc0
	ctx.lr = 0x8265C544;
	sub_825ABDC0(ctx, base);
	// 8265C544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C548: 48796EE1  bl 0x82df3428
	ctx.lr = 0x8265C54C;
	sub_82DF3428(ctx, base);
	// 8265C54C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8265C550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C554: 388B1614  addi r4, r11, 0x1614
	ctx.r[4].s64 = ctx.r[11].s64 + 5652;
	// 8265C558: 487974B1  bl 0x82df3a08
	ctx.lr = 0x8265C55C;
	sub_82DF3A08(ctx, base);
	// 8265C55C: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265C560: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 8265C564: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8265C568: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8265C56C: 419A0024  beq cr6, 0x8265c590
	if ctx.cr[6].eq {
	pc = 0x8265C590; continue 'dispatch;
	}
	// 8265C570: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 8265C574: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265C578: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265C57C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265C580: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265C584: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265C588: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265C58C: 4082FFE8  bne 0x8265c574
	if !ctx.cr[0].eq {
	pc = 0x8265C574; continue 'dispatch;
	}
	// 8265C590: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8265C594: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265C598: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8265C59C: 4BF45B75  bl 0x825a2110
	ctx.lr = 0x8265C5A0;
	sub_825A2110(ctx, base);
	// 8265C5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C5A4: 48796E85  bl 0x82df3428
	ctx.lr = 0x8265C5A8;
	sub_82DF3428(ctx, base);
	// 8265C5A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8265C5AC: 419A000C  beq cr6, 0x8265c5b8
	if ctx.cr[6].eq {
	pc = 0x8265C5B8; continue 'dispatch;
	}
	// 8265C5B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265C5B4: 4BC642DD  bl 0x822c0890
	ctx.lr = 0x8265C5B8;
	sub_822C0890(ctx, base);
	// 8265C5B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8265C5BC: 4BC6C6FD  bl 0x822c8cb8
	ctx.lr = 0x8265C5C0;
	sub_822C8CB8(ctx, base);
	// 8265C5C0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8265C5C4: 48B4BBEC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C5C8 size=60
    let mut pc: u32 = 0x8265C5C8;
    'dispatch: loop {
        match pc {
            0x8265C5C8 => {
    //   block [0x8265C5C8..0x8265C604)
	// 8265C5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C5CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C5D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C5D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C5D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C5DC: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 8265C5E0: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 8265C5E4: 4BEB40C5  bl 0x825106a8
	ctx.lr = 0x8265C5E8;
	sub_825106A8(ctx, base);
	// 8265C5E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8265C5EC: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 8265C5F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265C5F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C5F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C5FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C608 size=60
    let mut pc: u32 = 0x8265C608;
    'dispatch: loop {
        match pc {
            0x8265C608 => {
    //   block [0x8265C608..0x8265C644)
	// 8265C608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C60C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C61C: 389F003C  addi r4, r31, 0x3c
	ctx.r[4].s64 = ctx.r[31].s64 + 60;
	// 8265C620: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 8265C624: 4BEB471D  bl 0x82510d40
	ctx.lr = 0x8265C628;
	sub_82510D40(ctx, base);
	// 8265C628: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C62C: 997F0039  stb r11, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[11].u8 ) };
	// 8265C630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265C634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C63C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8265C648 size=12
    let mut pc: u32 = 0x8265C648;
    'dispatch: loop {
        match pc {
            0x8265C648 => {
    //   block [0x8265C648..0x8265C654)
	// 8265C648: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265C64C: C02B0F68  lfs f1, 0xf68(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3944 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265C650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C658 size=136
    let mut pc: u32 = 0x8265C658;
    'dispatch: loop {
        match pc {
            0x8265C658 => {
    //   block [0x8265C658..0x8265C6E0)
	// 8265C658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C65C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265C664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C66C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C670: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265C674: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8265C678: 409A0020  bne cr6, 0x8265c698
	if !ctx.cr[6].eq {
	pc = 0x8265C698; continue 'dispatch;
	}
	// 8265C67C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265C680: 419A0048  beq cr6, 0x8265c6c8
	if ctx.cr[6].eq {
	pc = 0x8265C6C8; continue 'dispatch;
	}
	// 8265C684: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8265C688: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8265C68C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8265C690: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8265C694: 48000034  b 0x8265c6c8
	pc = 0x8265C6C8; continue 'dispatch;
	// 8265C698: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8265C69C: 419A002C  beq cr6, 0x8265c6c8
	if ctx.cr[6].eq {
	pc = 0x8265C6C8; continue 'dispatch;
	}
	// 8265C6A0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265C6A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C6A8: 388B6068  addi r4, r11, 0x6068
	ctx.r[4].s64 = ctx.r[11].s64 + 24680;
	// 8265C6AC: 48B4BA4D  bl 0x831a80f8
	ctx.lr = 0x8265C6B0;
	sub_831A80F8(ctx, base);
	// 8265C6B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265C6B4: 4182000C  beq 0x8265c6c0
	if ctx.cr[0].eq {
	pc = 0x8265C6C0; continue 'dispatch;
	}
	// 8265C6B8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8265C6BC: 4800000C  b 0x8265c6c8
	pc = 0x8265C6C8; continue 'dispatch;
	// 8265C6C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C6C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265C6C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265C6CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C6D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C6D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265C6D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C6DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C6E0 size=136
    let mut pc: u32 = 0x8265C6E0;
    'dispatch: loop {
        match pc {
            0x8265C6E0 => {
    //   block [0x8265C6E0..0x8265C768)
	// 8265C6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C6E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C6E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265C6EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C6F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C6F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C6F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265C6FC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8265C700: 409A0020  bne cr6, 0x8265c720
	if !ctx.cr[6].eq {
	pc = 0x8265C720; continue 'dispatch;
	}
	// 8265C704: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265C708: 419A0048  beq cr6, 0x8265c750
	if ctx.cr[6].eq {
	pc = 0x8265C750; continue 'dispatch;
	}
	// 8265C70C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8265C710: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8265C714: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8265C718: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8265C71C: 48000034  b 0x8265c750
	pc = 0x8265C750; continue 'dispatch;
	// 8265C720: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8265C724: 419A002C  beq cr6, 0x8265c750
	if ctx.cr[6].eq {
	pc = 0x8265C750; continue 'dispatch;
	}
	// 8265C728: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265C72C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C730: 388B6100  addi r4, r11, 0x6100
	ctx.r[4].s64 = ctx.r[11].s64 + 24832;
	// 8265C734: 48B4B9C5  bl 0x831a80f8
	ctx.lr = 0x8265C738;
	sub_831A80F8(ctx, base);
	// 8265C738: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265C73C: 4182000C  beq 0x8265c748
	if ctx.cr[0].eq {
	pc = 0x8265C748; continue 'dispatch;
	}
	// 8265C740: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8265C744: 4800000C  b 0x8265c750
	pc = 0x8265C750; continue 'dispatch;
	// 8265C748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C74C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265C750: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265C754: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C758: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C75C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265C760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C768 size=136
    let mut pc: u32 = 0x8265C768;
    'dispatch: loop {
        match pc {
            0x8265C768 => {
    //   block [0x8265C768..0x8265C7F0)
	// 8265C768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265C774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C77C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C780: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265C784: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8265C788: 409A0020  bne cr6, 0x8265c7a8
	if !ctx.cr[6].eq {
	pc = 0x8265C7A8; continue 'dispatch;
	}
	// 8265C78C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265C790: 419A0048  beq cr6, 0x8265c7d8
	if ctx.cr[6].eq {
	pc = 0x8265C7D8; continue 'dispatch;
	}
	// 8265C794: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8265C798: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8265C79C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8265C7A0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8265C7A4: 48000034  b 0x8265c7d8
	pc = 0x8265C7D8; continue 'dispatch;
	// 8265C7A8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8265C7AC: 419A002C  beq cr6, 0x8265c7d8
	if ctx.cr[6].eq {
	pc = 0x8265C7D8; continue 'dispatch;
	}
	// 8265C7B0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265C7B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C7B8: 388B6198  addi r4, r11, 0x6198
	ctx.r[4].s64 = ctx.r[11].s64 + 24984;
	// 8265C7BC: 48B4B93D  bl 0x831a80f8
	ctx.lr = 0x8265C7C0;
	sub_831A80F8(ctx, base);
	// 8265C7C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265C7C4: 4182000C  beq 0x8265c7d0
	if ctx.cr[0].eq {
	pc = 0x8265C7D0; continue 'dispatch;
	}
	// 8265C7C8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8265C7CC: 4800000C  b 0x8265c7d8
	pc = 0x8265C7D8; continue 'dispatch;
	// 8265C7D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C7D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265C7D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265C7DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C7E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C7E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265C7E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C7EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265C7F0 size=196
    let mut pc: u32 = 0x8265C7F0;
    'dispatch: loop {
        match pc {
            0x8265C7F0 => {
    //   block [0x8265C7F0..0x8265C8B4)
	// 8265C7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C7F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C7F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265C7FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C804: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C80C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8265C810: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265C814: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265C818: 4BC64121  bl 0x822c0938
	ctx.lr = 0x8265C81C;
	sub_822C0938(ctx, base);
	// 8265C81C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265C820: 41820028  beq 0x8265c848
	if ctx.cr[0].eq {
	pc = 0x8265C848; continue 'dispatch;
	}
	// 8265C824: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265C828: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8265C82C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8265C830: 392B9B70  addi r9, r11, -0x6490
	ctx.r[9].s64 = ctx.r[11].s64 + -25744;
	// 8265C834: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8265C838: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265C83C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8265C840: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8265C844: 48000008  b 0x8265c84c
	pc = 0x8265C84C; continue 'dispatch;
	// 8265C848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265C84C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265C850: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265C854: 409A0044  bne cr6, 0x8265c898
	if !ctx.cr[6].eq {
	pc = 0x8265C898; continue 'dispatch;
	}
	// 8265C858: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265C85C: 419A001C  beq cr6, 0x8265c878
	if ctx.cr[6].eq {
	pc = 0x8265C878; continue 'dispatch;
	}
	// 8265C860: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C864: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8265C868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265C86C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265C870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8265C874: 4E800421  bctrl
	ctx.lr = 0x8265C878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8265C878: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265C87C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265C880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265C884: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8265C888: 816B601C  lwz r11, 0x601c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24604 as u32) ) } as u64;
	// 8265C88C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8265C890: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8265C894: 4BC6376D  bl 0x822c0000
	ctx.lr = 0x8265C898;
	sub_822C0000(ctx, base);
	// 8265C898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265C89C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265C8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265C8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265C8A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265C8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265C8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265C8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265C8B8 size=368
    let mut pc: u32 = 0x8265C8B8;
    'dispatch: loop {
        match pc {
            0x8265C8B8 => {
    //   block [0x8265C8B8..0x8265CA28)
	// 8265C8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265C8BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265C8C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265C8C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265C8C8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265C8CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265C8D0: 897E011D  lbz r11, 0x11d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(285 as u32) ) } as u64;
	// 8265C8D4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265C8D8: 418200C4  beq 0x8265c99c
	if ctx.cr[0].eq {
	pc = 0x8265C99C; continue 'dispatch;
	}
	// 8265C8DC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265C8E0: 4BEB54B9  bl 0x82511d98
	ctx.lr = 0x8265C8E4;
	sub_82511D98(ctx, base);
	// 8265C8E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265C8E8: C1BE00FC  lfs f13, 0xfc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265C8EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8265C8F0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8265C8F4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265C8F8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8265C8FC: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265C900: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8265C904: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8265C908: C01E00F8  lfs f0, 0xf8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265C90C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8265C910: 4881F439  bl 0x82e7bd48
	ctx.lr = 0x8265C914;
	sub_82E7BD48(ctx, base);
	// 8265C914: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265C918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265C91C: 4BEB51CD  bl 0x82511ae8
	ctx.lr = 0x8265C920;
	sub_82511AE8(ctx, base);
	// 8265C920: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265C924: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265C928: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 8265C92C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265C930: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8265C934: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265CA28 size=420
    let mut pc: u32 = 0x8265CA28;
    'dispatch: loop {
        match pc {
            0x8265CA28 => {
    //   block [0x8265CA28..0x8265CBCC)
	// 8265CA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CA2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265CA30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265CA34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265CA38: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8265CA3C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8265CA40: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CA44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8265CA48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265CA4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265CA50: C01E0104  lfs f0, 0x104(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265CA54: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8265CA58: C1AB964C  lfs f13, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265CA5C: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8265CA60: 40990128  ble cr6, 0x8265cb88
	if !ctx.cr[6].gt {
	pc = 0x8265CB88; continue 'dispatch;
	}
	// 8265CA64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265CA68: C1BE00F0  lfs f13, 0xf0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265CA6C: C19E0100  lfs f12, 0x100(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265CA70: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8265CA74: C3CBCEE4  lfs f30, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8265CA78: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265CA7C: EC2C07B2  fmuls f1, f12, f30
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265CA80: EFED0024  fdivs f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8265CA84: 4881FFC5  bl 0x82e7ca48
	ctx.lr = 0x8265CA88;
	sub_82E7CA48(ctx, base);
	// 8265CA88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265CA8C: D3E10094  stfs f31, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8265CA90: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8265CA94: C01E00F8  lfs f0, 0xf8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265CA98: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 8265CA9C: C1BE00FC  lfs f13, 0xfc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265CAA0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8265CAA4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8265CAA8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8265CAAC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8265CAB0: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8265CAB4: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8265CAB8: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8265CABC: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8265CAC0: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8265CAC4: 4881F285  bl 0x82e7bd48
	ctx.lr = 0x8265CAC8;
	sub_82E7BD48(ctx, base);
	// 8265CAC8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8265CACC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265CAD0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265CAD4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8265CAD8: D3E10074  stfs f31, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265CADC: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265CAE0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8265CAE4: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8265CAE8: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 8265CAEC: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265CAF0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CBD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265CBD0 size=72
    let mut pc: u32 = 0x8265CBD0;
    'dispatch: loop {
        match pc {
            0x8265CBD0 => {
    //   block [0x8265CBD0..0x8265CC18)
	// 8265CBD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CBD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265CBD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CBDC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8265CBE0: 419A001C  beq cr6, 0x8265cbfc
	if ctx.cr[6].eq {
	pc = 0x8265CBFC; continue 'dispatch;
	}
	// 8265CBE4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265CBE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8265CBEC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8265CBF0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265CBF4: 4BFFFA65  bl 0x8265c658
	ctx.lr = 0x8265CBF8;
	sub_8265C658(ctx, base);
	// 8265CBF8: 48000010  b 0x8265cc08
	pc = 0x8265CC08; continue 'dispatch;
	// 8265CBFC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265CC00: 396B6068  addi r11, r11, 0x6068
	ctx.r[11].s64 = ctx.r[11].s64 + 24680;
	// 8265CC04: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265CC08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265CC0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265CC10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265CC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265CC18 size=72
    let mut pc: u32 = 0x8265CC18;
    'dispatch: loop {
        match pc {
            0x8265CC18 => {
    //   block [0x8265CC18..0x8265CC60)
	// 8265CC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265CC20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CC24: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8265CC28: 419A001C  beq cr6, 0x8265cc44
	if ctx.cr[6].eq {
	pc = 0x8265CC44; continue 'dispatch;
	}
	// 8265CC2C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265CC30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8265CC34: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8265CC38: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265CC3C: 4BFFFAA5  bl 0x8265c6e0
	ctx.lr = 0x8265CC40;
	sub_8265C6E0(ctx, base);
	// 8265CC40: 48000010  b 0x8265cc50
	pc = 0x8265CC50; continue 'dispatch;
	// 8265CC44: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265CC48: 396B6100  addi r11, r11, 0x6100
	ctx.r[11].s64 = ctx.r[11].s64 + 24832;
	// 8265CC4C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265CC50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265CC54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265CC58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265CC5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265CC60 size=72
    let mut pc: u32 = 0x8265CC60;
    'dispatch: loop {
        match pc {
            0x8265CC60 => {
    //   block [0x8265CC60..0x8265CCA8)
	// 8265CC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265CC68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CC6C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8265CC70: 419A001C  beq cr6, 0x8265cc8c
	if ctx.cr[6].eq {
	pc = 0x8265CC8C; continue 'dispatch;
	}
	// 8265CC74: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265CC78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8265CC7C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8265CC80: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265CC84: 4BFFFAE5  bl 0x8265c768
	ctx.lr = 0x8265CC88;
	sub_8265C768(ctx, base);
	// 8265CC88: 48000010  b 0x8265cc98
	pc = 0x8265CC98; continue 'dispatch;
	// 8265CC8C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265CC90: 396B6198  addi r11, r11, 0x6198
	ctx.r[11].s64 = ctx.r[11].s64 + 24984;
	// 8265CC94: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265CC98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265CC9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265CCA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265CCA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265CCA8 size=344
    let mut pc: u32 = 0x8265CCA8;
    'dispatch: loop {
        match pc {
            0x8265CCA8 => {
    //   block [0x8265CCA8..0x8265CE00)
	// 8265CCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CCAC: 48B4B4C1  bl 0x831a816c
	ctx.lr = 0x8265CCB0;
	sub_831A8130(ctx, base);
	// 8265CCB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CCB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265CCB8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8265CCBC: 4BEB5675  bl 0x82512330
	ctx.lr = 0x8265CCC0;
	sub_82512330(ctx, base);
	// 8265CCC0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8265CCC4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8265CCC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8265CCCC: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 8265CCD0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 8265CCD4: C18AD7BC  lfs f12, -0x2844(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265CCD8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8265CCDC: C1699450  lfs f11, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8265CCE0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265CCE4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 8265CCE8: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8265CCEC: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8265CCF0: C14889AC  lfs f10, -0x7654(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8265CCF4: 3CA08205  lis r5, -0x7dfb
	ctx.r[5].s64 = -2113601536;
	// 8265CCF8: C00708A4  lfs f0, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265CCFC: 396A9C60  addi r11, r10, -0x63a0
	ctx.r[11].s64 = ctx.r[10].s64 + -25504;
	// 8265CD00: D19F00E8  stfs f12, 0xe8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8265CD04: 39499C14  addi r10, r9, -0x63ec
	ctx.r[10].s64 = ctx.r[9].s64 + -25580;
	// 8265CD08: D17F00EC  stfs f11, 0xec(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 8265CD0C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8265CD10: C1A608A8  lfs f13, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265CD14: 39059BCC  addi r8, r5, -0x6434
	ctx.r[8].s64 = ctx.r[5].s64 + -25652;
	// 8265CD18: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8265CD1C: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 8265CD20: D15F00F0  stfs f10, 0xf0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8265CD24: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8265CD28: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8265CD2C: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 8265CD30: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8265CD34: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8265CD38: 915F00E4  stw r10, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 8265CD3C: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 8265CD40: 913F0108  stw r9, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[9].u32 ) };
	// 8265CD44: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8265CD48: 9BDF010C  stb r30, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u8 ) };
	// 8265CD4C: D1BF0114  stfs f13, 0x114(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 8265CD50: 9BDF010D  stb r30, 0x10d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(269 as u32), ctx.r[30].u8 ) };
	// 8265CD54: D1BF0118  stfs f13, 0x118(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 8265CD58: 98FF010E  stb r7, 0x10e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(270 as u32), ctx.r[7].u8 ) };
	// 8265CD5C: 9BDF010F  stb r30, 0x10f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(271 as u32), ctx.r[30].u8 ) };
	// 8265CD60: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265CD64: 93BF0110  stw r29, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[29].u32 ) };
	// 8265CD68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265CD6C: 9BDF011C  stb r30, 0x11c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u8 ) };
	// 8265CD70: 388B9B80  addi r4, r11, -0x6480
	ctx.r[4].s64 = ctx.r[11].s64 + -25728;
	// 8265CD74: 9BDF011D  stb r30, 0x11d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(285 as u32), ctx.r[30].u8 ) };
	// 8265CD78: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 8265CD7C: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 8265CD80: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8265CD84: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 8265CD88: 93DF0128  stw r30, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u32 ) };
	// 8265CD8C: 93DF012C  stw r30, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u32 ) };
	// 8265CD90: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 8265CD94: 93DF0134  stw r30, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[30].u32 ) };
	// 8265CD98: 48795651  bl 0x82df23e8
	ctx.lr = 0x8265CD9C;
	sub_82DF23E8(ctx, base);
	// 8265CD9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265CDA0: 4182000C  beq 0x8265cdac
	if ctx.cr[0].eq {
	pc = 0x8265CDAC; continue 'dispatch;
	}
	// 8265CDA4: 487B6265  bl 0x82e13008
	ctx.lr = 0x8265CDA8;
	sub_82E13008(ctx, base);
	// 8265CDA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265CDAC: 93DF0138  stw r30, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[30].u32 ) };
	// 8265CDB0: 397F0138  addi r11, r31, 0x138
	ctx.r[11].s64 = ctx.r[31].s64 + 312;
	// 8265CDB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265CDB8: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 8265CDBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265CDC0: 4BC84259  bl 0x822e1018
	ctx.lr = 0x8265CDC4;
	sub_822E1018(ctx, base);
	// 8265CDC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8265CDC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265CDCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265CDD0: 4BC63231  bl 0x822c0000
	ctx.lr = 0x8265CDD4;
	sub_822C0000(ctx, base);
	// 8265CDD4: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 8265CDD8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265CDDC: 40990018  ble cr6, 0x8265cdf4
	if !ctx.cr[6].gt {
	pc = 0x8265CDF4; continue 'dispatch;
	}
	// 8265CDE0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8265CDE4: 41990010  bgt cr6, 0x8265cdf4
	if ctx.cr[6].gt {
	pc = 0x8265CDF4; continue 'dispatch;
	}
	// 8265CDE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265CDEC: C00B95A0  lfs f0, -0x6a60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265CDF0: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8265CDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265CDF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265CDFC: 48B4B3C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8265CE00 size=8
    let mut pc: u32 = 0x8265CE00;
    'dispatch: loop {
        match pc {
            0x8265CE00 => {
    //   block [0x8265CE00..0x8265CE08)
	// 8265CE00: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8265CE04: 4800020C  b 0x8265d010
	sub_8265D010(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8265CE08 size=8
    let mut pc: u32 = 0x8265CE08;
    'dispatch: loop {
        match pc {
            0x8265CE08 => {
    //   block [0x8265CE08..0x8265CE10)
	// 8265CE08: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8265CE0C: 48000204  b 0x8265d010
	sub_8265D010(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265CE10 size=168
    let mut pc: u32 = 0x8265CE10;
    'dispatch: loop {
        match pc {
            0x8265CE10 => {
    //   block [0x8265CE10..0x8265CEB8)
	// 8265CE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CE14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265CE18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265CE1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265CE20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CE24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265CE28: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265CE2C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265CE30: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8265CE34: 396B9BCC  addi r11, r11, -0x6434
	ctx.r[11].s64 = ctx.r[11].s64 + -25652;
	// 8265CE38: 394A9C60  addi r10, r10, -0x63a0
	ctx.r[10].s64 = ctx.r[10].s64 + -25504;
	// 8265CE3C: 39299C14  addi r9, r9, -0x63ec
	ctx.r[9].s64 = ctx.r[9].s64 + -25580;
	// 8265CE40: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265CE44: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8265CE48: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 8265CE4C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8265CE50: 807F013C  lwz r3, 0x13c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 8265CE54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265CE58: 419A0008  beq cr6, 0x8265ce60
	if ctx.cr[6].eq {
	pc = 0x8265CE60; continue 'dispatch;
	}
	// 8265CE5C: 4BC63A35  bl 0x822c0890
	ctx.lr = 0x8265CE60;
	sub_822C0890(ctx, base);
	// 8265CE60: 807F0134  lwz r3, 0x134(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 8265CE64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265CE68: 419A0008  beq cr6, 0x8265ce70
	if ctx.cr[6].eq {
	pc = 0x8265CE70; continue 'dispatch;
	}
	// 8265CE6C: 4BC63A25  bl 0x822c0890
	ctx.lr = 0x8265CE70;
	sub_822C0890(ctx, base);
	// 8265CE70: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8265CE74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265CE78: 419A0008  beq cr6, 0x8265ce80
	if ctx.cr[6].eq {
	pc = 0x8265CE80; continue 'dispatch;
	}
	// 8265CE7C: 4BC63A15  bl 0x822c0890
	ctx.lr = 0x8265CE80;
	sub_822C0890(ctx, base);
	// 8265CE80: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 8265CE84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265CE88: 419A0008  beq cr6, 0x8265ce90
	if ctx.cr[6].eq {
	pc = 0x8265CE90; continue 'dispatch;
	}
	// 8265CE8C: 4BC63A05  bl 0x822c0890
	ctx.lr = 0x8265CE90;
	sub_822C0890(ctx, base);
	// 8265CE90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265CE94: 4814A7C5  bl 0x827a7658
	ctx.lr = 0x8265CE98;
	sub_827A7658(ctx, base);
	// 8265CE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265CE9C: 4BCF24B5  bl 0x8234f350
	ctx.lr = 0x8265CEA0;
	sub_8234F350(ctx, base);
	// 8265CEA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265CEA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265CEA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265CEAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265CEB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265CEB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265CEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265CEB8 size=344
    let mut pc: u32 = 0x8265CEB8;
    'dispatch: loop {
        match pc {
            0x8265CEB8 => {
    //   block [0x8265CEB8..0x8265D010)
	// 8265CEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265CEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265CEC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265CEC4: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265CEC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265CECC: 897F010D  lbz r11, 0x10d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(269 as u32) ) } as u64;
	// 8265CED0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265CED4: 41820090  beq 0x8265cf64
	if ctx.cr[0].eq {
	pc = 0x8265CF64; continue 'dispatch;
	}
	// 8265CED8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265CEDC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8265CEE0: 4BFFFB49  bl 0x8265ca28
	ctx.lr = 0x8265CEE4;
	sub_8265CA28(ctx, base);
	// 8265CEE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265CEE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265CEEC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8265CEF0: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265CEF4: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265CEF8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265CEFC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265CF00: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265CF04: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8265CF08: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265CF0C: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265CF10: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8265CF14: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8265CF18: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8265CF1C: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8265CF20: 4881F0B9  bl 0x82e7bfd8
	ctx.lr = 0x8265CF24;
	sub_82E7BFD8(ctx, base);
	// 8265CF24: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 8265CF28: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8265CF2C: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265CF30: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 8265CF34: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8265CF38: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 8265CF3C: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265CF40: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8265CF44: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8265CF48: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265CF4C: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265D010 size=76
    let mut pc: u32 = 0x8265D010;
    'dispatch: loop {
        match pc {
            0x8265D010 => {
    //   block [0x8265D010..0x8265D05C)
	// 8265D010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265D018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265D01C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265D020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D028: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8265D02C: 4BFFFDE5  bl 0x8265ce10
	ctx.lr = 0x8265D030;
	sub_8265CE10(ctx, base);
	// 8265D030: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265D034: 4182000C  beq 0x8265d040
	if ctx.cr[0].eq {
	pc = 0x8265D040; continue 'dispatch;
	}
	// 8265D038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D03C: 4879539D  bl 0x82df23d8
	ctx.lr = 0x8265D040;
	sub_82DF23D8(ctx, base);
	// 8265D040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D044: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265D048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265D04C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265D050: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265D054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265D058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265D060 size=500
    let mut pc: u32 = 0x8265D060;
    'dispatch: loop {
        match pc {
            0x8265D060 => {
    //   block [0x8265D060..0x8265D254)
	// 8265D060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265D068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265D06C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265D070: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D078: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8265D07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D080: 4BEB2449  bl 0x8250f4c8
	ctx.lr = 0x8265D084;
	sub_8250F4C8(ctx, base);
	// 8265D084: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265D088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265D08C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 8265D090: 409A0008  bne cr6, 0x8265d098
	if !ctx.cr[6].eq {
	pc = 0x8265D098; continue 'dispatch;
	}
	// 8265D094: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8265D098: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8265D09C: 48794BF5  bl 0x82df1c90
	ctx.lr = 0x8265D0A0;
	sub_82DF1C90(ctx, base);
	// 8265D0A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8265D0A4: 419A0198  beq cr6, 0x8265d23c
	if ctx.cr[6].eq {
	pc = 0x8265D23C; continue 'dispatch;
	}
	// 8265D0A8: 897F011C  lbz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 8265D0AC: 895F010D  lbz r10, 0x10d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(269 as u32) ) } as u64;
	// 8265D0B0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8265D0B4: 419A0188  beq cr6, 0x8265d23c
	if ctx.cr[6].eq {
	pc = 0x8265D23C; continue 'dispatch;
	}
	// 8265D0B8: 897F011D  lbz r11, 0x11d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(285 as u32) ) } as u64;
	// 8265D0BC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D0C0: 418200A8  beq 0x8265d168
	if ctx.cr[0].eq {
	pc = 0x8265D168; continue 'dispatch;
	}
	// 8265D0C4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265D0C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D0CC: 4BEB4CCD  bl 0x82511d98
	ctx.lr = 0x8265D0D0;
	sub_82511D98(ctx, base);
	// 8265D0D0: 897F010D  lbz r11, 0x10d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(269 as u32) ) } as u64;
	// 8265D0D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D0D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D0DC: 41820044  beq 0x8265d120
	if ctx.cr[0].eq {
	pc = 0x8265D120; continue 'dispatch;
	}
	// 8265D0E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8265D0E4: 4BFFF945  bl 0x8265ca28
	ctx.lr = 0x8265D0E8;
	sub_8265CA28(ctx, base);
	// 8265D0E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265D0EC: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265D0F0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8265D0F4: 4881EC55  bl 0x82e7bd48
	ctx.lr = 0x8265D0F8;
	sub_82E7BD48(ctx, base);
	// 8265D0F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265D0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D100: 4BEB49E9  bl 0x82511ae8
	ctx.lr = 0x8265D104;
	sub_82511AE8(ctx, base);
	// 8265D104: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265D108: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265D10C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8265D110: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265D114: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265D258 size=488
    let mut pc: u32 = 0x8265D258;
    'dispatch: loop {
        match pc {
            0x8265D258 => {
    //   block [0x8265D258..0x8265D440)
	// 8265D258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D25C: 48B4AF0D  bl 0x831a8168
	ctx.lr = 0x8265D260;
	sub_831A8130(ctx, base);
	// 8265D260: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D264: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265D268: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8265D26C: 3BCB9B80  addi r30, r11, -0x6480
	ctx.r[30].s64 = ctx.r[11].s64 + -25728;
	// 8265D270: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D274: 38A00025  li r5, 0x25
	ctx.r[5].s64 = 37;
	// 8265D278: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D27C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8265D280: 48795169  bl 0x82df23e8
	ctx.lr = 0x8265D284;
	sub_82DF23E8(ctx, base);
	// 8265D284: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D288: 41820014  beq 0x8265d29c
	if ctx.cr[0].eq {
	pc = 0x8265D29C; continue 'dispatch;
	}
	// 8265D28C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265D290: 4BFFFA19  bl 0x8265cca8
	ctx.lr = 0x8265D294;
	sub_8265CCA8(ctx, base);
	// 8265D294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D298: 48000008  b 0x8265d2a0
	pc = 0x8265D2A0; continue 'dispatch;
	// 8265D29C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D2A0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8265D2A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D2A8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265D2AC: 4BFFF545  bl 0x8265c7f0
	ctx.lr = 0x8265D2B0;
	sub_8265C7F0(ctx, base);
	// 8265D2B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D2B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D2B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265D2BC: 4BC62D45  bl 0x822c0000
	ctx.lr = 0x8265D2C0;
	sub_822C0000(ctx, base);
	// 8265D2C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D2C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D2C8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8265D2CC: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8265D2D0: 4BC63109  bl 0x822c03d8
	ctx.lr = 0x8265D2D4;
	sub_822C03D8(ctx, base);
	// 8265D2D4: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265D2D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D2DC: 418200A0  beq 0x8265d37c
	if ctx.cr[0].eq {
	pc = 0x8265D37C; continue 'dispatch;
	}
	// 8265D2E0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8265D2E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8265D2E8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8265D2EC: 409A0008  bne cr6, 0x8265d2f4
	if !ctx.cr[6].eq {
	pc = 0x8265D2F4; continue 'dispatch;
	}
	// 8265D2F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265D2F4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265D2F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D2FC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265D300: 419A0024  beq cr6, 0x8265d324
	if ctx.cr[6].eq {
	pc = 0x8265D324; continue 'dispatch;
	}
	// 8265D304: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265D308: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8265D30C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D310: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8265D314: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8265D318: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265D31C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D320: 4082FFE8  bne 0x8265d308
	if !ctx.cr[0].eq {
	pc = 0x8265D308; continue 'dispatch;
	}
	// 8265D324: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 8265D328: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D32C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265D330: 419A0024  beq cr6, 0x8265d354
	if ctx.cr[6].eq {
	pc = 0x8265D354; continue 'dispatch;
	}
	// 8265D334: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265D338: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265D33C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D340: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265D344: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265D348: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265D34C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D350: 4082FFE8  bne 0x8265d338
	if !ctx.cr[0].eq {
	pc = 0x8265D338; continue 'dispatch;
	}
	// 8265D354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265D358: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8265D35C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8265D360: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8265D364: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8265D368: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8265D36C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265D370: 4813BBC1  bl 0x82798f30
	ctx.lr = 0x8265D374;
	sub_82798F30(ctx, base);
	// 8265D374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D378: 48000008  b 0x8265d380
	pc = 0x8265D380; continue 'dispatch;
	// 8265D37C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D380: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8265D384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D388: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265D38C: 4BF85ABD  bl 0x825e2e48
	ctx.lr = 0x8265D390;
	sub_825E2E48(ctx, base);
	// 8265D390: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D398: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265D39C: 4BC62C65  bl 0x822c0000
	ctx.lr = 0x8265D3A0;
	sub_822C0000(ctx, base);
	// 8265D3A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265D3A4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265D3A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D3AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D3B0: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 8265D3B4: C00B95F4  lfs f0, -0x6a0c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265D3B8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8265D3BC: C1AA9B50  lfs f13, -0x64b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265D3C0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D3C4: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8265D3C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D3CC: D1AB0034  stfs f13, 0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8265D3D0: 4BC63009  bl 0x822c03d8
	ctx.lr = 0x8265D3D4;
	sub_822C03D8(ctx, base);
	// 8265D3D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D3D8: 41820014  beq 0x8265d3ec
	if ctx.cr[0].eq {
	pc = 0x8265D3EC; continue 'dispatch;
	}
	// 8265D3DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265D3E0: 4813BDA9  bl 0x82799188
	ctx.lr = 0x8265D3E4;
	sub_82799188(ctx, base);
	// 8265D3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D3E8: 48000008  b 0x8265d3f0
	pc = 0x8265D3F0; continue 'dispatch;
	// 8265D3EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D3F0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265D3F4: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 8265D3F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D3FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265D400: 4BF3A851  bl 0x82597c50
	ctx.lr = 0x8265D404;
	sub_82597C50(ctx, base);
	// 8265D404: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D40C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265D410: 4BC62BF1  bl 0x822c0000
	ctx.lr = 0x8265D414;
	sub_822C0000(ctx, base);
	// 8265D414: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8265D418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265D41C: 419A0008  beq cr6, 0x8265d424
	if ctx.cr[6].eq {
	pc = 0x8265D424; continue 'dispatch;
	}
	// 8265D420: 4BC63471  bl 0x822c0890
	ctx.lr = 0x8265D424;
	sub_822C0890(ctx, base);
	// 8265D424: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D428: 419A000C  beq cr6, 0x8265d434
	if ctx.cr[6].eq {
	pc = 0x8265D434; continue 'dispatch;
	}
	// 8265D42C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265D430: 4BC63461  bl 0x822c0890
	ctx.lr = 0x8265D434;
	sub_822C0890(ctx, base);
	// 8265D434: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8265D438: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8265D43C: 48B4AD7C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265D440 size=488
    let mut pc: u32 = 0x8265D440;
    'dispatch: loop {
        match pc {
            0x8265D440 => {
    //   block [0x8265D440..0x8265D628)
	// 8265D440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D444: 48B4AD25  bl 0x831a8168
	ctx.lr = 0x8265D448;
	sub_831A8130(ctx, base);
	// 8265D448: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D44C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265D450: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8265D454: 3BCB9B80  addi r30, r11, -0x6480
	ctx.r[30].s64 = ctx.r[11].s64 + -25728;
	// 8265D458: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D45C: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 8265D460: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D464: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8265D468: 48794F81  bl 0x82df23e8
	ctx.lr = 0x8265D46C;
	sub_82DF23E8(ctx, base);
	// 8265D46C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D470: 41820014  beq 0x8265d484
	if ctx.cr[0].eq {
	pc = 0x8265D484; continue 'dispatch;
	}
	// 8265D474: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8265D478: 4BFFF831  bl 0x8265cca8
	ctx.lr = 0x8265D47C;
	sub_8265CCA8(ctx, base);
	// 8265D47C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D480: 48000008  b 0x8265d488
	pc = 0x8265D488; continue 'dispatch;
	// 8265D484: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D488: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8265D48C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D490: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265D494: 4BFFF35D  bl 0x8265c7f0
	ctx.lr = 0x8265D498;
	sub_8265C7F0(ctx, base);
	// 8265D498: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D49C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D4A0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265D4A4: 4BC62B5D  bl 0x822c0000
	ctx.lr = 0x8265D4A8;
	sub_822C0000(ctx, base);
	// 8265D4A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D4AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D4B0: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 8265D4B4: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8265D4B8: 4BC62F21  bl 0x822c03d8
	ctx.lr = 0x8265D4BC;
	sub_822C03D8(ctx, base);
	// 8265D4BC: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265D4C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D4C4: 418200A0  beq 0x8265d564
	if ctx.cr[0].eq {
	pc = 0x8265D564; continue 'dispatch;
	}
	// 8265D4C8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8265D4CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8265D4D0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8265D4D4: 409A0008  bne cr6, 0x8265d4dc
	if !ctx.cr[6].eq {
	pc = 0x8265D4DC; continue 'dispatch;
	}
	// 8265D4D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265D4DC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265D4E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D4E4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265D4E8: 419A0024  beq cr6, 0x8265d50c
	if ctx.cr[6].eq {
	pc = 0x8265D50C; continue 'dispatch;
	}
	// 8265D4EC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265D4F0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8265D4F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D4F8: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8265D4FC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8265D500: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265D504: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D508: 4082FFE8  bne 0x8265d4f0
	if !ctx.cr[0].eq {
	pc = 0x8265D4F0; continue 'dispatch;
	}
	// 8265D50C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 8265D510: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D514: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265D518: 419A0024  beq cr6, 0x8265d53c
	if ctx.cr[6].eq {
	pc = 0x8265D53C; continue 'dispatch;
	}
	// 8265D51C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265D520: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265D524: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D528: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265D52C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265D530: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265D534: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D538: 4082FFE8  bne 0x8265d520
	if !ctx.cr[0].eq {
	pc = 0x8265D520; continue 'dispatch;
	}
	// 8265D53C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265D540: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8265D544: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8265D548: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8265D54C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8265D550: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8265D554: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265D558: 4813B9D9  bl 0x82798f30
	ctx.lr = 0x8265D55C;
	sub_82798F30(ctx, base);
	// 8265D55C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D560: 48000008  b 0x8265d568
	pc = 0x8265D568; continue 'dispatch;
	// 8265D564: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D568: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8265D56C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D570: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265D574: 4BF858D5  bl 0x825e2e48
	ctx.lr = 0x8265D578;
	sub_825E2E48(ctx, base);
	// 8265D578: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D57C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D580: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265D584: 4BC62A7D  bl 0x822c0000
	ctx.lr = 0x8265D588;
	sub_822C0000(ctx, base);
	// 8265D588: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265D58C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265D590: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D594: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D598: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 8265D59C: C00B95F4  lfs f0, -0x6a0c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265D5A0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8265D5A4: C1AA9B50  lfs f13, -0x64b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265D5A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D5AC: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8265D5B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D5B4: D1AB0034  stfs f13, 0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8265D5B8: 4BC62E21  bl 0x822c03d8
	ctx.lr = 0x8265D5BC;
	sub_822C03D8(ctx, base);
	// 8265D5BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D5C0: 41820014  beq 0x8265d5d4
	if ctx.cr[0].eq {
	pc = 0x8265D5D4; continue 'dispatch;
	}
	// 8265D5C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265D5C8: 4813BBC1  bl 0x82799188
	ctx.lr = 0x8265D5CC;
	sub_82799188(ctx, base);
	// 8265D5CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D5D0: 48000008  b 0x8265d5d8
	pc = 0x8265D5D8; continue 'dispatch;
	// 8265D5D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D5D8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265D5DC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 8265D5E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D5E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265D5E8: 4BF3A669  bl 0x82597c50
	ctx.lr = 0x8265D5EC;
	sub_82597C50(ctx, base);
	// 8265D5EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D5F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D5F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265D5F8: 4BC62A09  bl 0x822c0000
	ctx.lr = 0x8265D5FC;
	sub_822C0000(ctx, base);
	// 8265D5FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8265D600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265D604: 419A0008  beq cr6, 0x8265d60c
	if ctx.cr[6].eq {
	pc = 0x8265D60C; continue 'dispatch;
	}
	// 8265D608: 4BC63289  bl 0x822c0890
	ctx.lr = 0x8265D60C;
	sub_822C0890(ctx, base);
	// 8265D60C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D610: 419A000C  beq cr6, 0x8265d61c
	if ctx.cr[6].eq {
	pc = 0x8265D61C; continue 'dispatch;
	}
	// 8265D614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265D618: 4BC63279  bl 0x822c0890
	ctx.lr = 0x8265D61C;
	sub_822C0890(ctx, base);
	// 8265D61C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8265D620: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8265D624: 48B4AB94  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265D628 size=488
    let mut pc: u32 = 0x8265D628;
    'dispatch: loop {
        match pc {
            0x8265D628 => {
    //   block [0x8265D628..0x8265D810)
	// 8265D628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D62C: 48B4AB3D  bl 0x831a8168
	ctx.lr = 0x8265D630;
	sub_831A8130(ctx, base);
	// 8265D630: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D634: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265D638: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8265D63C: 3BCB9B80  addi r30, r11, -0x6480
	ctx.r[30].s64 = ctx.r[11].s64 + -25728;
	// 8265D640: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D644: 38A00039  li r5, 0x39
	ctx.r[5].s64 = 57;
	// 8265D648: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D64C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 8265D650: 48794D99  bl 0x82df23e8
	ctx.lr = 0x8265D654;
	sub_82DF23E8(ctx, base);
	// 8265D654: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D658: 41820014  beq 0x8265d66c
	if ctx.cr[0].eq {
	pc = 0x8265D66C; continue 'dispatch;
	}
	// 8265D65C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8265D660: 4BFFF649  bl 0x8265cca8
	ctx.lr = 0x8265D664;
	sub_8265CCA8(ctx, base);
	// 8265D664: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D668: 48000008  b 0x8265d670
	pc = 0x8265D670; continue 'dispatch;
	// 8265D66C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D670: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8265D674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D678: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265D67C: 4BFFF175  bl 0x8265c7f0
	ctx.lr = 0x8265D680;
	sub_8265C7F0(ctx, base);
	// 8265D680: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D688: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8265D68C: 4BC62975  bl 0x822c0000
	ctx.lr = 0x8265D690;
	sub_822C0000(ctx, base);
	// 8265D690: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D694: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D698: 38A0003B  li r5, 0x3b
	ctx.r[5].s64 = 59;
	// 8265D69C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8265D6A0: 4BC62D39  bl 0x822c03d8
	ctx.lr = 0x8265D6A4;
	sub_822C03D8(ctx, base);
	// 8265D6A4: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265D6A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D6AC: 418200A0  beq 0x8265d74c
	if ctx.cr[0].eq {
	pc = 0x8265D74C; continue 'dispatch;
	}
	// 8265D6B0: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8265D6B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8265D6B8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8265D6BC: 409A0008  bne cr6, 0x8265d6c4
	if !ctx.cr[6].eq {
	pc = 0x8265D6C4; continue 'dispatch;
	}
	// 8265D6C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265D6C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265D6C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D6CC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265D6D0: 419A0024  beq cr6, 0x8265d6f4
	if ctx.cr[6].eq {
	pc = 0x8265D6F4; continue 'dispatch;
	}
	// 8265D6D4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265D6D8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8265D6DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D6E0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8265D6E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8265D6E8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265D6EC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D6F0: 4082FFE8  bne 0x8265d6d8
	if !ctx.cr[0].eq {
	pc = 0x8265D6D8; continue 'dispatch;
	}
	// 8265D6F4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 8265D6F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D6FC: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265D700: 419A0024  beq cr6, 0x8265d724
	if ctx.cr[6].eq {
	pc = 0x8265D724; continue 'dispatch;
	}
	// 8265D704: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265D708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265D70C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D710: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265D714: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265D718: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265D71C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265D720: 4082FFE8  bne 0x8265d708
	if !ctx.cr[0].eq {
	pc = 0x8265D708; continue 'dispatch;
	}
	// 8265D724: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265D728: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8265D72C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8265D730: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8265D734: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8265D738: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8265D73C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265D740: 4813B7F1  bl 0x82798f30
	ctx.lr = 0x8265D744;
	sub_82798F30(ctx, base);
	// 8265D744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D748: 48000008  b 0x8265d750
	pc = 0x8265D750; continue 'dispatch;
	// 8265D74C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D750: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8265D754: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D758: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265D75C: 4BF856ED  bl 0x825e2e48
	ctx.lr = 0x8265D760;
	sub_825E2E48(ctx, base);
	// 8265D760: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D768: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265D76C: 4BC62895  bl 0x822c0000
	ctx.lr = 0x8265D770;
	sub_822C0000(ctx, base);
	// 8265D770: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265D774: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265D778: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265D77C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265D780: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 8265D784: C00B95F4  lfs f0, -0x6a0c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265D788: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8265D78C: C1AA9B50  lfs f13, -0x64b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265D790: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D794: D00B0030  stfs f0, 0x30(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8265D798: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D79C: D1AB0034  stfs f13, 0x34(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8265D7A0: 4BC62C39  bl 0x822c03d8
	ctx.lr = 0x8265D7A4;
	sub_822C03D8(ctx, base);
	// 8265D7A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265D7A8: 41820014  beq 0x8265d7bc
	if ctx.cr[0].eq {
	pc = 0x8265D7BC; continue 'dispatch;
	}
	// 8265D7AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265D7B0: 4813B9D9  bl 0x82799188
	ctx.lr = 0x8265D7B4;
	sub_82799188(ctx, base);
	// 8265D7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D7B8: 48000008  b 0x8265d7c0
	pc = 0x8265D7C0; continue 'dispatch;
	// 8265D7BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265D7C0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265D7C4: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 8265D7C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D7CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265D7D0: 4BF3A481  bl 0x82597c50
	ctx.lr = 0x8265D7D4;
	sub_82597C50(ctx, base);
	// 8265D7D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265D7D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D7DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265D7E0: 4BC62821  bl 0x822c0000
	ctx.lr = 0x8265D7E4;
	sub_822C0000(ctx, base);
	// 8265D7E4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8265D7E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265D7EC: 419A0008  beq cr6, 0x8265d7f4
	if ctx.cr[6].eq {
	pc = 0x8265D7F4; continue 'dispatch;
	}
	// 8265D7F0: 4BC630A1  bl 0x822c0890
	ctx.lr = 0x8265D7F4;
	sub_822C0890(ctx, base);
	// 8265D7F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265D7F8: 419A000C  beq cr6, 0x8265d804
	if ctx.cr[6].eq {
	pc = 0x8265D804; continue 'dispatch;
	}
	// 8265D7FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265D800: 4BC63091  bl 0x822c0890
	ctx.lr = 0x8265D804;
	sub_822C0890(ctx, base);
	// 8265D804: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8265D808: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8265D80C: 48B4A9AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265D810 size=128
    let mut pc: u32 = 0x8265D810;
    'dispatch: loop {
        match pc {
            0x8265D810 => {
    //   block [0x8265D810..0x8265D890)
	// 8265D810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D814: 48B4A959  bl 0x831a816c
	ctx.lr = 0x8265D818;
	sub_831A8130(ctx, base);
	// 8265D818: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D81C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8265D820: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8265D824: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265D828: 3BEB80C4  addi r31, r11, -0x7f3c
	ctx.r[31].s64 = ctx.r[11].s64 + -32572;
	// 8265D82C: 816A80CC  lwz r11, -0x7f34(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32564 as u32) ) } as u64;
	// 8265D830: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8265D834: 40820024  bne 0x8265d858
	if !ctx.cr[0].eq {
	pc = 0x8265D858; continue 'dispatch;
	}
	// 8265D838: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8265D83C: 3D008266  lis r8, -0x7d9a
	ctx.r[8].s64 = -2107244544;
	// 8265D840: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8265D844: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 8265D848: 3908CBD0  addi r8, r8, -0x3430
	ctx.r[8].s64 = ctx.r[8].s64 + -13360;
	// 8265D84C: 916A80CC  stw r11, -0x7f34(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32564 as u32), ctx.r[11].u32 ) };
	// 8265D850: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8265D854: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8265D858: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265D85C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8265D860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D864: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8265D868: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8265D86C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D870: 4BFF6D51  bl 0x826545c0
	ctx.lr = 0x8265D874;
	sub_826545C0(ctx, base);
	// 8265D874: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265D878: 4182000C  beq 0x8265d884
	if ctx.cr[0].eq {
	pc = 0x8265D884; continue 'dispatch;
	}
	// 8265D87C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265D880: 48000008  b 0x8265d888
	pc = 0x8265D888; continue 'dispatch;
	// 8265D884: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8265D888: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265D88C: 48B4A930  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265D890 size=128
    let mut pc: u32 = 0x8265D890;
    'dispatch: loop {
        match pc {
            0x8265D890 => {
    //   block [0x8265D890..0x8265D910)
	// 8265D890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D894: 48B4A8D9  bl 0x831a816c
	ctx.lr = 0x8265D898;
	sub_831A8130(ctx, base);
	// 8265D898: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D89C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8265D8A0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8265D8A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265D8A8: 3BEB80D0  addi r31, r11, -0x7f30
	ctx.r[31].s64 = ctx.r[11].s64 + -32560;
	// 8265D8AC: 816A80D8  lwz r11, -0x7f28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32552 as u32) ) } as u64;
	// 8265D8B0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8265D8B4: 40820024  bne 0x8265d8d8
	if !ctx.cr[0].eq {
	pc = 0x8265D8D8; continue 'dispatch;
	}
	// 8265D8B8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8265D8BC: 3D008266  lis r8, -0x7d9a
	ctx.r[8].s64 = -2107244544;
	// 8265D8C0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8265D8C4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 8265D8C8: 3908CC18  addi r8, r8, -0x33e8
	ctx.r[8].s64 = ctx.r[8].s64 + -13288;
	// 8265D8CC: 916A80D8  stw r11, -0x7f28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32552 as u32), ctx.r[11].u32 ) };
	// 8265D8D0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8265D8D4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8265D8D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265D8DC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8265D8E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D8E4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8265D8E8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8265D8EC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D8F0: 4BFF6CD1  bl 0x826545c0
	ctx.lr = 0x8265D8F4;
	sub_826545C0(ctx, base);
	// 8265D8F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265D8F8: 4182000C  beq 0x8265d904
	if ctx.cr[0].eq {
	pc = 0x8265D904; continue 'dispatch;
	}
	// 8265D8FC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265D900: 48000008  b 0x8265d908
	pc = 0x8265D908; continue 'dispatch;
	// 8265D904: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8265D908: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265D90C: 48B4A8B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265D910 size=128
    let mut pc: u32 = 0x8265D910;
    'dispatch: loop {
        match pc {
            0x8265D910 => {
    //   block [0x8265D910..0x8265D990)
	// 8265D910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D914: 48B4A859  bl 0x831a816c
	ctx.lr = 0x8265D918;
	sub_831A8130(ctx, base);
	// 8265D918: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D91C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8265D920: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8265D924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265D928: 3BEB80DC  addi r31, r11, -0x7f24
	ctx.r[31].s64 = ctx.r[11].s64 + -32548;
	// 8265D92C: 816A80E4  lwz r11, -0x7f1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32540 as u32) ) } as u64;
	// 8265D930: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8265D934: 40820024  bne 0x8265d958
	if !ctx.cr[0].eq {
	pc = 0x8265D958; continue 'dispatch;
	}
	// 8265D938: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8265D93C: 3D008266  lis r8, -0x7d9a
	ctx.r[8].s64 = -2107244544;
	// 8265D940: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8265D944: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 8265D948: 3908CC60  addi r8, r8, -0x33a0
	ctx.r[8].s64 = ctx.r[8].s64 + -13216;
	// 8265D94C: 916A80E4  stw r11, -0x7f1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32540 as u32), ctx.r[11].u32 ) };
	// 8265D950: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8265D954: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8265D958: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265D95C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8265D960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265D964: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 8265D968: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8265D96C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265D970: 4BFF6C51  bl 0x826545c0
	ctx.lr = 0x8265D974;
	sub_826545C0(ctx, base);
	// 8265D974: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265D978: 4182000C  beq 0x8265d984
	if ctx.cr[0].eq {
	pc = 0x8265D984; continue 'dispatch;
	}
	// 8265D97C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265D980: 48000008  b 0x8265d988
	pc = 0x8265D988; continue 'dispatch;
	// 8265D984: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8265D988: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265D98C: 48B4A830  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265D990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265D990 size=3716
    let mut pc: u32 = 0x8265D990;
    'dispatch: loop {
        match pc {
            0x8265D990 => {
    //   block [0x8265D990..0x8265E814)
	// 8265D990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265D994: 48B4A7BD  bl 0x831a8150
	ctx.lr = 0x8265D998;
	sub_831A8130(ctx, base);
	// 8265D998: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8265D99C: 48B4B0D5  bl 0x831a8a70
	ctx.lr = 0x8265D9A0;
	sub_831A8A40(ctx, base);
	// 8265D9A0: 9421FC50  stwu r1, -0x3b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-944 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265D9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265D9A8: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 8265D9AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265D9B0: 4BEB1B19  bl 0x8250f4c8
	ctx.lr = 0x8265D9B4;
	sub_8250F4C8(ctx, base);
	// 8265D9B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265D9B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8265D9BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265D9C0: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 8265D9C4: 409A0008  bne cr6, 0x8265d9cc
	if !ctx.cr[6].eq {
	pc = 0x8265D9CC; continue 'dispatch;
	}
	// 8265D9C8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8265D9CC: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 8265D9D0: 487942C1  bl 0x82df1c90
	ctx.lr = 0x8265D9D4;
	sub_82DF1C90(ctx, base);
	// 8265D9D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8265D9D8: 419A0E2C  beq cr6, 0x8265e804
	if ctx.cr[6].eq {
	pc = 0x8265E804; continue 'dispatch;
	}
	// 8265D9DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265D9E0: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 8265D9E4: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8265D9E8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 8265D9EC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 8265D9F0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8265D9F4: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8265D9F8: C389CEE4  lfs f28, -0x311c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8265D9FC: C3689524  lfs f27, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8265DA00: C3C79450  lfs f30, -0x6bb0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8265DA04: 419A004C  beq cr6, 0x8265da50
	if ctx.cr[6].eq {
	pc = 0x8265DA50; continue 'dispatch;
	}
	// 8265DA08: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8265DA0C: 409A007C  bne cr6, 0x8265da88
	if !ctx.cr[6].eq {
	pc = 0x8265DA88; continue 'dispatch;
	}
	// 8265DA10: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DA14: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8265DA18: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DA1C: 48B4B3AD  bl 0x831a8dc8
	ctx.lr = 0x8265DA20;
	sub_831A8DC8(ctx, base);
	// 8265DA20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8265DA24: C1BF0104  lfs f13, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DA28: EDAD0732  fmuls f13, f13, f28
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 8265DA2C: C19F0118  lfs f12, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265DA30: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DA34: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 8265DA38: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 8265DA3C: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8265DA40: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 8265DA44: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DA48: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8265DA4C: 4800003C  b 0x8265da88
	pc = 0x8265DA88; continue 'dispatch;
	// 8265DA50: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DA54: 897F010E  lbz r11, 0x10e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(270 as u32) ) } as u64;
	// 8265DA58: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8265DA5C: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DA60: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265DA64: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8265DA68: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8265DA6C: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8265DA70: 4182000C  beq 0x8265da7c
	if ctx.cr[0].eq {
	pc = 0x8265DA7C; continue 'dispatch;
	}
	// 8265DA74: D3FF00FC  stfs f31, 0xfc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8265DA78: 48000010  b 0x8265da88
	pc = 0x8265DA88; continue 'dispatch;
	// 8265DA7C: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DA80: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DA84: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 8265DA88: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 8265DA8C: 3AFF0130  addi r23, r31, 0x130
	ctx.r[23].s64 = ctx.r[31].s64 + 304;
	// 8265DA90: 3EC08335  lis r22, -0x7ccb
	ctx.r[22].s64 = -2093678592;
	// 8265DA94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265DA98: 419A0018  beq cr6, 0x8265dab0
	if ctx.cr[6].eq {
	pc = 0x8265DAB0; continue 'dispatch;
	}
	// 8265DA9C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8265DAA0: 80967078  lwz r4, 0x7078(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28792 as u32) ) } as u64;
	// 8265DAA4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 8265DAA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265DAAC: 4BEB2615  bl 0x825100c0
	ctx.lr = 0x8265DAB0;
	sub_825100C0(ctx, base);
	// 8265DAB0: 93BF0120  stw r29, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[29].u32 ) };
	// 8265DAB4: 3B3F0120  addi r25, r31, 0x120
	ctx.r[25].s64 = ctx.r[31].s64 + 288;
	// 8265DAB8: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 8265DABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265DAC0: 93BF0124  stw r29, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[29].u32 ) };
	// 8265DAC4: 419A0008  beq cr6, 0x8265dacc
	if ctx.cr[6].eq {
	pc = 0x8265DACC; continue 'dispatch;
	}
	// 8265DAC8: 4BC62DC9  bl 0x822c0890
	ctx.lr = 0x8265DACC;
	sub_822C0890(ctx, base);
	// 8265DACC: 93BF0128  stw r29, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[29].u32 ) };
	// 8265DAD0: 3B1F0128  addi r24, r31, 0x128
	ctx.r[24].s64 = ctx.r[31].s64 + 296;
	// 8265DAD4: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 8265DAD8: 93BF012C  stw r29, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[29].u32 ) };
	// 8265DADC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265DAE0: 419A0008  beq cr6, 0x8265dae8
	if ctx.cr[6].eq {
	pc = 0x8265DAE8; continue 'dispatch;
	}
	// 8265DAE4: 4BC62DAD  bl 0x822c0890
	ctx.lr = 0x8265DAE8;
	sub_822C0890(ctx, base);
	// 8265DAE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265DAEC: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DAF0: 93A100F4  stw r29, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[29].u32 ) };
	// 8265DAF4: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 8265DAF8: 93A100F8  stw r29, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[29].u32 ) };
	// 8265DAFC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8265DB00: 93A100FC  stw r29, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	// 8265DB04: C3AB9530  lfs f29, -0x6ad0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27344 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8265DB08: 4099016C  ble cr6, 0x8265dc74
	if !ctx.cr[6].gt {
	pc = 0x8265DC74; continue 'dispatch;
	}
	// 8265DB0C: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8265DB10: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8265DB14: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8265DB18: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8265DB1C: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265DB20: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 8265DB24: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DB28: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DB2C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265DB30: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8265DB34: C9A10080  lfd f13, 0x80(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8265DB38: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DB3C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8265DB40: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8265DB44: C9810088  lfd f12, 0x88(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265DB48: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8265DB4C: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8265DB50: FF406818  frsp f26, f13
	ctx.f[26].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DB54: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265DB58: FDA06018  frsp f13, f12
	ctx.f[13].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8265DB5C: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265DB60: ED8B07B2  fmuls f12, f11, f30
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DB64: D18100B0  stfs f12, 0xb0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8265DB68: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265DB6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DB70: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DB74: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DB78: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8265DB7C: 4813EFCD  bl 0x8279cb48
	ctx.lr = 0x8265DB80;
	sub_8279CB48(ctx, base);
	// 8265DB80: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DB84: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DB88: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8265DB8C: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265DB90: D1A100C0  stfs f13, 0xc0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8265DB94: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DB98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DB9C: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DBA0: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 8265DBA4: C9A100E0  lfd f13, 0xe0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 8265DBA8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DBAC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DBB0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DBB4: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8265DBB8: 4813EF91  bl 0x8279cb48
	ctx.lr = 0x8265DBBC;
	sub_8279CB48(ctx, base);
	// 8265DBBC: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 8265DBC0: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DBC4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265DBC8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8265DBCC: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265DBD0: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8265DBD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DBD8: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 8265DBDC: C80100D8  lfd f0, 0xd8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 8265DBE0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8265DBE4: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DBE8: FF400018  frsp f26, f0
	ctx.f[26].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8265DBEC: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DBF0: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 8265DBF4: C9A100D0  lfd f13, 0xd0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 8265DBF8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DBFC: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DC00: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DC04: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DC08: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8265DC0C: 4813EF3D  bl 0x8279cb48
	ctx.lr = 0x8265DC10;
	sub_8279CB48(ctx, base);
	// 8265DC10: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DC14: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DC18: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265DC1C: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DC20: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265DC24: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DC28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DC2C: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DC30: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8265DC34: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8265DC38: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DC3C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DC40: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DC44: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265DC48: 4813EF01  bl 0x8279cb48
	ctx.lr = 0x8265DC4C;
	sub_8279CB48(ctx, base);
	// 8265DC4C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265DC50: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265DC54: 4BE391E5  bl 0x82496e38
	ctx.lr = 0x8265DC58;
	sub_82496E38(ctx, base);
	// 8265DC58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DC5C: 4BE0C3A5  bl 0x8246a000
	ctx.lr = 0x8265DC60;
	sub_8246A000(ctx, base);
	// 8265DC60: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8265DC64: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DC68: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8265DC6C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8265DC70: 4198FEB0  blt cr6, 0x8265db20
	if ctx.cr[6].lt {
	pc = 0x8265DB20; continue 'dispatch;
	}
	// 8265DC74: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DC78: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 8265DC7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265DC80: 4099018C  ble cr6, 0x8265de0c
	if !ctx.cr[6].gt {
	pc = 0x8265DE0C; continue 'dispatch;
	}
	// 8265DC84: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8265DC88: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 8265DC8C: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DC90: C01F00F0  lfs f0, 0xf0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DC94: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265DC98: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8265DC9C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8265DCA0: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8265DCA4: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265DCA8: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 8265DCAC: ED6B0772  fmuls f11, f11, f29
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265DCB0: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265DCB4: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265DCB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265DCBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DCC0: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8265DCC4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DCC8: C98100D0  lfd f12, 0xd0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 8265DCCC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8265DCD0: FF406818  frsp f26, f13
	ctx.f[26].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DCD4: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DCD8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DCDC: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265DCE0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8265DCE4: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DCE8: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8265DCEC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265DCF0: 4813EE59  bl 0x8279cb48
	ctx.lr = 0x8265DCF4;
	sub_8279CB48(ctx, base);
	// 8265DCF4: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DCF8: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DCFC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265DD00: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DD04: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8265DD08: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DD0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DD10: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DD14: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265DD18: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 8265DD1C: C9A100D8  lfd f13, 0xd8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 8265DD20: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DD24: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DD28: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DD2C: D18100A4  stfs f12, 0xa4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8265DD30: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DD34: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8265DD38: 4813EE11  bl 0x8279cb48
	ctx.lr = 0x8265DD3C;
	sub_8279CB48(ctx, base);
	// 8265DD3C: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 8265DD40: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DD44: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8265DD48: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8265DD4C: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DD50: D1A100C0  stfs f13, 0xc0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8265DD54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DD58: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 8265DD5C: C9A100E0  lfd f13, 0xe0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 8265DD60: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DD64: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DD68: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DD6C: FF406818  frsp f26, f13
	ctx.f[26].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DD70: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265DD74: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DD78: D18100C4  stfs f12, 0xc4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8265DD7C: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8265DD80: C9610080  lfd f11, 0x80(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8265DD84: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8265DD88: FDA05818  frsp f13, f11
	ctx.f[13].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8265DD8C: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DD90: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DD94: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8265DD98: 4813EDB1  bl 0x8279cb48
	ctx.lr = 0x8265DD9C;
	sub_8279CB48(ctx, base);
	// 8265DD9C: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DDA0: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DDA4: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DDA8: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265DDAC: C19F00F0  lfs f12, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265DDB0: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DDB4: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8265DDB8: ED9A0332  fmuls f12, f26, f12
	ctx.f[12].f64 = (((ctx.f[26].f64 * ctx.f[12].f64) as f32) as f64);
	// 8265DDBC: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8265DDC0: C9610088  lfd f11, 0x88(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265DDC4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8265DDC8: FC005818  frsp f0, f11
	ctx.f[0].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8265DDCC: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8265DDD0: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8265DDD4: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8265DDD8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265DDDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DDE0: 4813ED69  bl 0x8279cb48
	ctx.lr = 0x8265DDE4;
	sub_8279CB48(ctx, base);
	// 8265DDE4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265DDE8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265DDEC: 4BE3904D  bl 0x82496e38
	ctx.lr = 0x8265DDF0;
	sub_82496E38(ctx, base);
	// 8265DDF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DDF4: 4BE0C20D  bl 0x8246a000
	ctx.lr = 0x8265DDF8;
	sub_8246A000(ctx, base);
	// 8265DDF8: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DDFC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8265DE00: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8265DE04: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8265DE08: 4198FE80  blt cr6, 0x8265dc88
	if ctx.cr[6].lt {
	pc = 0x8265DC88; continue 'dispatch;
	}
	// 8265DE0C: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DE10: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 8265DE14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265DE18: 4099017C  ble cr6, 0x8265df94
	if !ctx.cr[6].gt {
	pc = 0x8265DF94; continue 'dispatch;
	}
	// 8265DE1C: D3E100A4  stfs f31, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8265DE20: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8265DE24: D3E100C4  stfs f31, 0xc4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8265DE28: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 8265DE2C: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DE30: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DE34: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265DE38: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8265DE3C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8265DE40: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265DE44: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DE48: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265DE4C: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DE50: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 8265DE54: C98100D0  lfd f12, 0xd0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 8265DE58: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265DE5C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265DE60: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8265DE64: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DE68: FF406818  frsp f26, f13
	ctx.f[26].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DE6C: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DE70: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8265DE74: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265DE78: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265DE7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DE80: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DE84: FDA06018  frsp f13, f12
	ctx.f[13].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8265DE88: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DE8C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265DE90: 4813ECB9  bl 0x8279cb48
	ctx.lr = 0x8265DE94;
	sub_8279CB48(ctx, base);
	// 8265DE94: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DE98: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DE9C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265DEA0: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DEA4: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8265DEA8: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DEAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DEB0: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DEB4: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 8265DEB8: C9A100D8  lfd f13, 0xd8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 8265DEBC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DEC0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DEC4: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DEC8: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8265DECC: 4813EC7D  bl 0x8279cb48
	ctx.lr = 0x8265DED0;
	sub_8279CB48(ctx, base);
	// 8265DED0: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 8265DED4: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DED8: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8265DEDC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8265DEE0: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DEE4: D1A100C0  stfs f13, 0xc0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8265DEE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DEEC: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 8265DEF0: C80100E0  lfd f0, 0xe0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 8265DEF4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8265DEF8: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DEFC: FF400018  frsp f26, f0
	ctx.f[26].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8265DF00: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DF04: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8265DF08: C9A10080  lfd f13, 0x80(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8265DF0C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DF10: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DF14: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DF18: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DF1C: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8265DF20: 4813EC29  bl 0x8279cb48
	ctx.lr = 0x8265DF24;
	sub_8279CB48(ctx, base);
	// 8265DF24: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DF28: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DF2C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265DF30: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265DF34: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8265DF38: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DF3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DF40: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DF44: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265DF48: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8265DF4C: C9A10088  lfd f13, 0x88(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265DF50: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265DF54: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265DF58: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265DF5C: D18100B4  stfs f12, 0xb4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8265DF60: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265DF64: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8265DF68: 4813EBE1  bl 0x8279cb48
	ctx.lr = 0x8265DF6C;
	sub_8279CB48(ctx, base);
	// 8265DF6C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265DF70: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265DF74: 4BE38EC5  bl 0x82496e38
	ctx.lr = 0x8265DF78;
	sub_82496E38(ctx, base);
	// 8265DF78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DF7C: 4BE0C085  bl 0x8246a000
	ctx.lr = 0x8265DF80;
	sub_8246A000(ctx, base);
	// 8265DF80: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DF84: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8265DF88: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8265DF8C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8265DF90: 4198FE98  blt cr6, 0x8265de28
	if ctx.cr[6].lt {
	pc = 0x8265DE28; continue 'dispatch;
	}
	// 8265DF94: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DF98: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 8265DF9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265DFA0: 4099017C  ble cr6, 0x8265e11c
	if !ctx.cr[6].gt {
	pc = 0x8265E11C; continue 'dispatch;
	}
	// 8265DFA4: D3E10074  stfs f31, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265DFA8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 8265DFAC: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8265DFB0: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 8265DFB4: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265DFB8: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265DFBC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265DFC0: F96100D0  std r11, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 8265DFC4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8265DFC8: C96100D0  lfd f11, 0xd0(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	// 8265DFCC: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8265DFD0: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8265DFD4: FF405818  frsp f26, f11
	ctx.f[26].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8265DFD8: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265DFDC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265DFE0: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265DFE4: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265DFE8: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265DFEC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265DFF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265DFF4: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265DFF8: C9810090  lfd f12, 0x90(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8265DFFC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8265E000: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8265E004: EC006024  fdivs f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 8265E008: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E00C: 4813EB3D  bl 0x8279cb48
	ctx.lr = 0x8265E010;
	sub_8279CB48(ctx, base);
	// 8265E010: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265E014: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E018: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265E01C: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E020: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8265E024: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E028: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E02C: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265E030: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265E034: F96100D8  std r11, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[11].u64 ) };
	// 8265E038: C9A100D8  lfd f13, 0xd8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	// 8265E03C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265E040: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265E044: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E048: D18100A4  stfs f12, 0xa4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8265E04C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265E050: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8265E054: 4813EAF5  bl 0x8279cb48
	ctx.lr = 0x8265E058;
	sub_8279CB48(ctx, base);
	// 8265E058: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 8265E05C: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E060: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8265E064: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8265E068: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E06C: D1A100C0  stfs f13, 0xc0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8265E070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E074: F96100E0  std r11, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u64 ) };
	// 8265E078: C80100E0  lfd f0, 0xe0(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	// 8265E07C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8265E080: C19F00EC  lfs f12, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265E084: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265E088: FF400018  frsp f26, f0
	ctx.f[26].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8265E08C: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E090: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E094: D18100C4  stfs f12, 0xc4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8265E098: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8265E09C: C9A10080  lfd f13, 0x80(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8265E0A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265E0A4: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265E0A8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265E0AC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265E0B0: D00100C8  stfs f0, 0xc8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8265E0B4: 4813EA95  bl 0x8279cb48
	ctx.lr = 0x8265E0B8;
	sub_8279CB48(ctx, base);
	// 8265E0B8: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265E0BC: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E0C0: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265E0C4: EDAD0772  fmuls f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E0C8: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8265E0CC: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E0D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E0D4: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265E0D8: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8265E0DC: C9A10088  lfd f13, 0x88(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265E0E0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8265E0E4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8265E0E8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8265E0EC: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8265E0F0: 4813EA59  bl 0x8279cb48
	ctx.lr = 0x8265E0F4;
	sub_8279CB48(ctx, base);
	// 8265E0F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265E0F8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265E0FC: 4BE38D3D  bl 0x82496e38
	ctx.lr = 0x8265E100;
	sub_82496E38(ctx, base);
	// 8265E100: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E104: 4BE0BEFD  bl 0x8246a000
	ctx.lr = 0x8265E108;
	sub_8246A000(ctx, base);
	// 8265E108: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 8265E10C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 8265E110: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8265E114: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8265E118: 4198FE98  blt cr6, 0x8265dfb0
	if ctx.cr[6].lt {
	pc = 0x8265DFB0; continue 'dispatch;
	}
	// 8265E11C: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E120: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265E124: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E128: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E12C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E130: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265E134: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E138: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265E13C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E140: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E144: 4813EA05  bl 0x8279cb48
	ctx.lr = 0x8265E148;
	sub_8279CB48(ctx, base);
	// 8265E148: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E14C: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265E150: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E154: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E158: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E15C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E160: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E164: 4813E9E5  bl 0x8279cb48
	ctx.lr = 0x8265E168;
	sub_8279CB48(ctx, base);
	// 8265E168: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E16C: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E170: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265E174: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E178: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E17C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E180: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E184: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E188: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E18C: 4813E9BD  bl 0x8279cb48
	ctx.lr = 0x8265E190;
	sub_8279CB48(ctx, base);
	// 8265E190: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E194: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E198: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E19C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E1A0: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E1A4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E1A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E1AC: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E1B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E1B4: 4813E995  bl 0x8279cb48
	ctx.lr = 0x8265E1B8;
	sub_8279CB48(ctx, base);
	// 8265E1B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265E1BC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265E1C0: 4BE38C79  bl 0x82496e38
	ctx.lr = 0x8265E1C4;
	sub_82496E38(ctx, base);
	// 8265E1C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E1C8: 4BE0BE39  bl 0x8246a000
	ctx.lr = 0x8265E1CC;
	sub_8246A000(ctx, base);
	// 8265E1CC: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E1D0: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E1D4: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265E1D8: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E1DC: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E1E0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E1E4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265E1E8: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E1EC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 8265E1F0: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8265E1F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E1F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E1FC: 4813E94D  bl 0x8279cb48
	ctx.lr = 0x8265E200;
	sub_8279CB48(ctx, base);
	// 8265E200: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E204: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E208: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E20C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E210: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E214: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E218: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E21C: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E220: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E224: 4813E925  bl 0x8279cb48
	ctx.lr = 0x8265E228;
	sub_8279CB48(ctx, base);
	// 8265E228: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E22C: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E230: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8265E234: C19F00F0  lfs f12, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265E238: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E23C: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E240: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E244: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E248: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E24C: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E254: 4813E8F5  bl 0x8279cb48
	ctx.lr = 0x8265E258;
	sub_8279CB48(ctx, base);
	// 8265E258: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265E25C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E260: C01F00E8  lfs f0, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E264: C1BF00EC  lfs f13, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E268: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8265E26C: C19F00F0  lfs f12, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265E270: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E274: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8265E278: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8265E27C: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8265E280: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8265E284: 4813E8C5  bl 0x8279cb48
	ctx.lr = 0x8265E288;
	sub_8279CB48(ctx, base);
	// 8265E288: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265E28C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265E290: 4BE38BA9  bl 0x82496e38
	ctx.lr = 0x8265E294;
	sub_82496E38(ctx, base);
	// 8265E294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265E298: 4BE0BD69  bl 0x8246a000
	ctx.lr = 0x8265E29C;
	sub_8246A000(ctx, base);
	// 8265E29C: C01F0104  lfs f0, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E2A0: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8265E2A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265E2A8: C1AB964C  lfs f13, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E2AC: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8265E2B0: 4099024C  ble cr6, 0x8265e4fc
	if !ctx.cr[6].gt {
	pc = 0x8265E4FC; continue 'dispatch;
	}
	// 8265E2B4: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8265E2B8: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E2BC: C19F0100  lfs f12, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8265E2C0: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 8265E2C4: EC2C0732  fmuls f1, f12, f28
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 8265E2C8: EFCD0024  fdivs f30, f13, f0
	ctx.f[30].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 8265E2CC: 4881E77D  bl 0x82e7ca48
	ctx.lr = 0x8265E2D0;
	sub_82E7CA48(ctx, base);
	// 8265E2D0: D3E10170  stfs f31, 0x170(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 8265E2D4: 38A10170  addi r5, r1, 0x170
	ctx.r[5].s64 = ctx.r[1].s64 + 368;
	// 8265E2D8: D3C10174  stfs f30, 0x174(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 8265E2DC: 38810220  addi r4, r1, 0x220
	ctx.r[4].s64 = ctx.r[1].s64 + 544;
	// 8265E2E0: D3E10178  stfs f31, 0x178(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 8265E2E4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8265E2E8: D3E1017C  stfs f31, 0x17c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 8265E2EC: C01F00F8  lfs f0, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265E2F0: C1BF00FC  lfs f13, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265E2F4: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8265E2F8: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8265E2FC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8265E300: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8265E304: 4881DA45  bl 0x82e7bd48
	ctx.lr = 0x8265E308;
	sub_82E7BD48(ctx, base);
	// 8265E308: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8265E30C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265E310: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265E314: 39210160  addi r9, r1, 0x160
	ctx.r[9].s64 = ctx.r[1].s64 + 352;
	// 8265E318: D3E10184  stfs f31, 0x184(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 8265E31C: D3E10188  stfs f31, 0x188(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 8265E320: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 8265E324: D3E1018C  stfs f31, 0x18c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 8265E328: 38810220  addi r4, r1, 0x220
	ctx.r[4].s64 = ctx.r[1].s64 + 544;
	// 8265E32C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8265E330: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265E818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8265E818 size=4
    let mut pc: u32 = 0x8265E818;
    'dispatch: loop {
        match pc {
            0x8265E818 => {
    //   block [0x8265E818..0x8265E81C)
	// 8265E818: 4BFFF178  b 0x8265d990
	sub_8265D990(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265E820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265E820 size=196
    let mut pc: u32 = 0x8265E820;
    'dispatch: loop {
        match pc {
            0x8265E820 => {
    //   block [0x8265E820..0x8265E8E4)
	// 8265E820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265E824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265E828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265E82C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265E830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265E834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265E838: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8265E83C: 4BEB319D  bl 0x825119d8
	ctx.lr = 0x8265E840;
	sub_825119D8(ctx, base);
	// 8265E840: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265E844: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8265E848: 409A0008  bne cr6, 0x8265e850
	if !ctx.cr[6].eq {
	pc = 0x8265E850; continue 'dispatch;
	}
	// 8265E84C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265E850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265E854: 4BEA9F4D  bl 0x825087a0
	ctx.lr = 0x8265E858;
	sub_825087A0(ctx, base);
	// 8265E858: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8265E85C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265E860: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 8265E864: 487951A5  bl 0x82df3a08
	ctx.lr = 0x8265E868;
	sub_82DF3A08(ctx, base);
	// 8265E868: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265E86C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265E870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265E874: 4BEA9F0D  bl 0x82508780
	ctx.lr = 0x8265E878;
	sub_82508780(ctx, base);
	// 8265E878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265E87C: 48794BAD  bl 0x82df3428
	ctx.lr = 0x8265E880;
	sub_82DF3428(ctx, base);
	// 8265E880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265E884: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8265E888: 83DF0138  lwz r30, 0x138(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8265E88C: 4BEB388D  bl 0x82512118
	ctx.lr = 0x8265E890;
	sub_82512118(ctx, base);
	// 8265E890: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265E894: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265E898: 487B4599  bl 0x82e12e30
	ctx.lr = 0x8265E89C;
	sub_82E12E30(ctx, base);
	// 8265E89C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265E8A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265E8A4: 419A0008  beq cr6, 0x8265e8ac
	if ctx.cr[6].eq {
	pc = 0x8265E8AC; continue 'dispatch;
	}
	// 8265E8A8: 4BC61FE9  bl 0x822c0890
	ctx.lr = 0x8265E8AC;
	sub_822C0890(ctx, base);
	// 8265E8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265E8B0: 889F010D  lbz r4, 0x10d(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(269 as u32) ) } as u64;
	// 8265E8B4: 4BFFE7AD  bl 0x8265d060
	ctx.lr = 0x8265E8B8;
	sub_8265D060(ctx, base);
	// 8265E8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265E8BC: 4BFFF0D5  bl 0x8265d990
	ctx.lr = 0x8265E8C0;
	sub_8265D990(ctx, base);
	// 8265E8C0: 389F0120  addi r4, r31, 0x120
	ctx.r[4].s64 = ctx.r[31].s64 + 288;
	// 8265E8C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265E8C8: 4BEB2479  bl 0x82510d40
	ctx.lr = 0x8265E8CC;
	sub_82510D40(ctx, base);
	// 8265E8CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265E8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265E8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265E8D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265E8DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265E8E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265E8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265E8E8 size=3004
    let mut pc: u32 = 0x8265E8E8;
    'dispatch: loop {
        match pc {
            0x8265E8E8 => {
    //   block [0x8265E8E8..0x8265F4A4)
	// 8265E8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265E8EC: 48B4987D  bl 0x831a8168
	ctx.lr = 0x8265E8F0;
	sub_831A8130(ctx, base);
	// 8265E8F0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 8265E8F4: 48B4A17D  bl 0x831a8a70
	ctx.lr = 0x8265E8F8;
	sub_831A8A40(ctx, base);
	// 8265E8F8: 9421F880  stwu r1, -0x780(r1)
	ea = ctx.r[1].u32.wrapping_add(-1920 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265E8FC: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265E900: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8265E904: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265E908: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8265E90C: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265E910: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265E914: 388A5688  addi r4, r10, 0x5688
	ctx.r[4].s64 = ctx.r[10].s64 + 22152;
	// 8265E918: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8265E91C: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 8265E920: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 8265E924: 487950E5  bl 0x82df3a08
	ctx.lr = 0x8265E928;
	sub_82DF3A08(ctx, base);
	// 8265E928: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265E92C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265E930: 388B9E10  addi r4, r11, -0x61f0
	ctx.r[4].s64 = ctx.r[11].s64 + -25072;
	// 8265E934: 487950D5  bl 0x82df3a08
	ctx.lr = 0x8265E938;
	sub_82DF3A08(ctx, base);
	// 8265E938: 3B9EFF1C  addi r28, r30, -0xe4
	ctx.r[28].s64 = ctx.r[30].s64 + -228;
	// 8265E93C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8265E940: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8265E944: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 8265E948: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8265E94C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8265E950: 4BFFEEC1  bl 0x8265d810
	ctx.lr = 0x8265E954;
	sub_8265D810(ctx, base);
	// 8265E954: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265E958: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8265E95C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8265E960: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8265E964: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 8265E968: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8265E96C: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 8265E970: C3CA9F64  lfs f30, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8265E974: 386106A0  addi r3, r1, 0x6a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1696;
	// 8265E978: C3A808A4  lfs f29, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8265E97C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265E980: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265E984: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265E988: 4BF4F0C1  bl 0x825ada48
	ctx.lr = 0x8265E98C;
	sub_825ADA48(ctx, base);
	// 8265E98C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265E990: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265E994: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8265E998: 4BF42CB9  bl 0x825a1650
	ctx.lr = 0x8265E99C;
	sub_825A1650(ctx, base);
	// 8265E99C: 386106D8  addi r3, r1, 0x6d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1752;
	// 8265E9A0: 48794A89  bl 0x82df3428
	ctx.lr = 0x8265E9A4;
	sub_82DF3428(ctx, base);
	// 8265E9A4: 386106B8  addi r3, r1, 0x6b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1720;
	// 8265E9A8: 4BC6A311  bl 0x822c8cb8
	ctx.lr = 0x8265E9AC;
	sub_822C8CB8(ctx, base);
	// 8265E9AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265E9B0: 48794A79  bl 0x82df3428
	ctx.lr = 0x8265E9B4;
	sub_82DF3428(ctx, base);
	// 8265E9B4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 8265E9B8: 48794A71  bl 0x82df3428
	ctx.lr = 0x8265E9BC;
	sub_82DF3428(ctx, base);
	// 8265E9BC: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265E9C0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265E9C4: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 8265E9C8: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265E9CC: 388A9E08  addi r4, r10, -0x61f8
	ctx.r[4].s64 = ctx.r[10].s64 + -25080;
	// 8265E9D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265E9D4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8265E9D8: 48795031  bl 0x82df3a08
	ctx.lr = 0x8265E9DC;
	sub_82DF3A08(ctx, base);
	// 8265E9DC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265E9E0: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 8265E9E4: 388B9DFC  addi r4, r11, -0x6204
	ctx.r[4].s64 = ctx.r[11].s64 + -25092;
	// 8265E9E8: 48795021  bl 0x82df3a08
	ctx.lr = 0x8265E9EC;
	sub_82DF3A08(ctx, base);
	// 8265E9EC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8265E9F0: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 8265E9F4: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8265E9F8: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8265E9FC: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8265EA00: 4BFFEE11  bl 0x8265d810
	ctx.lr = 0x8265EA04;
	sub_8265D810(ctx, base);
	// 8265EA04: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8265EA08: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265EA0C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 8265EA10: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265EA14: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8265EA18: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265EA1C: 38610620  addi r3, r1, 0x620
	ctx.r[3].s64 = ctx.r[1].s64 + 1568;
	// 8265EA20: 4BF4F029  bl 0x825ada48
	ctx.lr = 0x8265EA24;
	sub_825ADA48(ctx, base);
	// 8265EA24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EA28: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 8265EA2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EA30: 4BF42C21  bl 0x825a1650
	ctx.lr = 0x8265EA34;
	sub_825A1650(ctx, base);
	// 8265EA34: 38610658  addi r3, r1, 0x658
	ctx.r[3].s64 = ctx.r[1].s64 + 1624;
	// 8265EA38: 487949F1  bl 0x82df3428
	ctx.lr = 0x8265EA3C;
	sub_82DF3428(ctx, base);
	// 8265EA3C: 38610638  addi r3, r1, 0x638
	ctx.r[3].s64 = ctx.r[1].s64 + 1592;
	// 8265EA40: 4BC6A279  bl 0x822c8cb8
	ctx.lr = 0x8265EA44;
	sub_822C8CB8(ctx, base);
	// 8265EA44: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 8265EA48: 487949E1  bl 0x82df3428
	ctx.lr = 0x8265EA4C;
	sub_82DF3428(ctx, base);
	// 8265EA4C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265EA50: 487949D9  bl 0x82df3428
	ctx.lr = 0x8265EA54;
	sub_82DF3428(ctx, base);
	// 8265EA54: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 8265EA58: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8265EA5C: 4198044C  blt cr6, 0x8265eea8
	if ctx.cr[6].lt {
	pc = 0x8265EEA8; continue 'dispatch;
	}
	// 8265EA60: 419A01E4  beq cr6, 0x8265ec44
	if ctx.cr[6].eq {
	pc = 0x8265EC44; continue 'dispatch;
	}
	// 8265EA64: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8265EA68: 409807F0  bge cr6, 0x8265f258
	if !ctx.cr[6].lt {
	pc = 0x8265F258; continue 'dispatch;
	}
	// 8265EA6C: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EA70: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EA74: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EA78: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EA7C: 388A9DF0  addi r4, r10, -0x6210
	ctx.r[4].s64 = ctx.r[10].s64 + -25104;
	// 8265EA80: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265EA84: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EA88: 48794F81  bl 0x82df3a08
	ctx.lr = 0x8265EA8C;
	sub_82DF3A08(ctx, base);
	// 8265EA8C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EA90: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 8265EA94: 388B9DDC  addi r4, r11, -0x6224
	ctx.r[4].s64 = ctx.r[11].s64 + -25124;
	// 8265EA98: 48794F71  bl 0x82df3a08
	ctx.lr = 0x8265EA9C;
	sub_82DF3A08(ctx, base);
	// 8265EA9C: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 8265EAA0: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EAA4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EAA8: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EAAC: 93E10280  stw r31, 0x280(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(640 as u32), ctx.r[31].u32 ) };
	// 8265EAB0: 4BFFED61  bl 0x8265d810
	ctx.lr = 0x8265EAB4;
	sub_8265D810(ctx, base);
	// 8265EAB4: 39210280  addi r9, r1, 0x280
	ctx.r[9].s64 = ctx.r[1].s64 + 640;
	// 8265EAB8: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265EABC: 38BE0034  addi r5, r30, 0x34
	ctx.r[5].s64 = ctx.r[30].s64 + 52;
	// 8265EAC0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265EAC4: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 8265EAC8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265EACC: 38610420  addi r3, r1, 0x420
	ctx.r[3].s64 = ctx.r[1].s64 + 1056;
	// 8265EAD0: 4BF4EF79  bl 0x825ada48
	ctx.lr = 0x8265EAD4;
	sub_825ADA48(ctx, base);
	// 8265EAD4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EAD8: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 8265EADC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EAE0: 4BF42B71  bl 0x825a1650
	ctx.lr = 0x8265EAE4;
	sub_825A1650(ctx, base);
	// 8265EAE4: 38610458  addi r3, r1, 0x458
	ctx.r[3].s64 = ctx.r[1].s64 + 1112;
	// 8265EAE8: 48794941  bl 0x82df3428
	ctx.lr = 0x8265EAEC;
	sub_82DF3428(ctx, base);
	// 8265EAEC: 38610438  addi r3, r1, 0x438
	ctx.r[3].s64 = ctx.r[1].s64 + 1080;
	// 8265EAF0: 4BC6A1C9  bl 0x822c8cb8
	ctx.lr = 0x8265EAF4;
	sub_822C8CB8(ctx, base);
	// 8265EAF4: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 8265EAF8: 48794931  bl 0x82df3428
	ctx.lr = 0x8265EAFC;
	sub_82DF3428(ctx, base);
	// 8265EAFC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265EB00: 48794929  bl 0x82df3428
	ctx.lr = 0x8265EB04;
	sub_82DF3428(ctx, base);
	// 8265EB04: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EB08: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EB0C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EB10: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EB14: 388A9DD0  addi r4, r10, -0x6230
	ctx.r[4].s64 = ctx.r[10].s64 + -25136;
	// 8265EB18: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 8265EB1C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EB20: 48794EE9  bl 0x82df3a08
	ctx.lr = 0x8265EB24;
	sub_82DF3A08(ctx, base);
	// 8265EB24: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EB28: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 8265EB2C: 388B9DC8  addi r4, r11, -0x6238
	ctx.r[4].s64 = ctx.r[11].s64 + -25144;
	// 8265EB30: 48794ED9  bl 0x82df3a08
	ctx.lr = 0x8265EB34;
	sub_82DF3A08(ctx, base);
	// 8265EB34: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8265EB38: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EB3C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EB40: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EB44: 93E10120  stw r31, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[31].u32 ) };
	// 8265EB48: 4BFFECC9  bl 0x8265d810
	ctx.lr = 0x8265EB4C;
	sub_8265D810(ctx, base);
	// 8265EB4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265EB50: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8265EB54: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 8265EB58: 39210120  addi r9, r1, 0x120
	ctx.r[9].s64 = ctx.r[1].s64 + 288;
	// 8265EB5C: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 8265EB60: 388100E4  addi r4, r1, 0xe4
	ctx.r[4].s64 = ctx.r[1].s64 + 228;
	// 8265EB64: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8265EB68: 386105A0  addi r3, r1, 0x5a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1440;
	// 8265EB6C: C04AD200  lfs f2, -0x2e00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8265EB70: C0288E4C  lfs f1, -0x71b4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265EB74: 4BF4EED5  bl 0x825ada48
	ctx.lr = 0x8265EB78;
	sub_825ADA48(ctx, base);
	// 8265EB78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EB7C: 388100DC  addi r4, r1, 0xdc
	ctx.r[4].s64 = ctx.r[1].s64 + 220;
	// 8265EB80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EB84: 4BF42ACD  bl 0x825a1650
	ctx.lr = 0x8265EB88;
	sub_825A1650(ctx, base);
	// 8265EB88: 386105D8  addi r3, r1, 0x5d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1496;
	// 8265EB8C: 4879489D  bl 0x82df3428
	ctx.lr = 0x8265EB90;
	sub_82DF3428(ctx, base);
	// 8265EB90: 386105B8  addi r3, r1, 0x5b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1464;
	// 8265EB94: 4BC6A125  bl 0x822c8cb8
	ctx.lr = 0x8265EB98;
	sub_822C8CB8(ctx, base);
	// 8265EB98: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 8265EB9C: 4879488D  bl 0x82df3428
	ctx.lr = 0x8265EBA0;
	sub_82DF3428(ctx, base);
	// 8265EBA0: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 8265EBA4: 48794885  bl 0x82df3428
	ctx.lr = 0x8265EBA8;
	sub_82DF3428(ctx, base);
	// 8265EBA8: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EBAC: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EBB0: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EBB4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EBB8: 388A9DB8  addi r4, r10, -0x6248
	ctx.r[4].s64 = ctx.r[10].s64 + -25160;
	// 8265EBBC: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 8265EBC0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EBC4: 48794E45  bl 0x82df3a08
	ctx.lr = 0x8265EBC8;
	sub_82DF3A08(ctx, base);
	// 8265EBC8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EBCC: 386100EC  addi r3, r1, 0xec
	ctx.r[3].s64 = ctx.r[1].s64 + 236;
	// 8265EBD0: 388B9DA4  addi r4, r11, -0x625c
	ctx.r[4].s64 = ctx.r[11].s64 + -25180;
	// 8265EBD4: 48794E35  bl 0x82df3a08
	ctx.lr = 0x8265EBD8;
	sub_82DF3A08(ctx, base);
	// 8265EBD8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 8265EBDC: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EBE0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EBE4: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EBE8: 93E10160  stw r31, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[31].u32 ) };
	// 8265EBEC: 4BFFEC25  bl 0x8265d810
	ctx.lr = 0x8265EBF0;
	sub_8265D810(ctx, base);
	// 8265EBF0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8265EBF4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265EBF8: 39210160  addi r9, r1, 0x160
	ctx.r[9].s64 = ctx.r[1].s64 + 352;
	// 8265EBFC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265EC00: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 8265EC04: 388100F4  addi r4, r1, 0xf4
	ctx.r[4].s64 = ctx.r[1].s64 + 244;
	// 8265EC08: 386104A0  addi r3, r1, 0x4a0
	ctx.r[3].s64 = ctx.r[1].s64 + 1184;
	// 8265EC0C: C02B8268  lfs f1, -0x7d98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265EC10: 4BF4EE39  bl 0x825ada48
	ctx.lr = 0x8265EC14;
	sub_825ADA48(ctx, base);
	// 8265EC14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EC18: 388100EC  addi r4, r1, 0xec
	ctx.r[4].s64 = ctx.r[1].s64 + 236;
	// 8265EC1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EC20: 4BF42A31  bl 0x825a1650
	ctx.lr = 0x8265EC24;
	sub_825A1650(ctx, base);
	// 8265EC24: 386104D8  addi r3, r1, 0x4d8
	ctx.r[3].s64 = ctx.r[1].s64 + 1240;
	// 8265EC28: 48794801  bl 0x82df3428
	ctx.lr = 0x8265EC2C;
	sub_82DF3428(ctx, base);
	// 8265EC2C: 386104B8  addi r3, r1, 0x4b8
	ctx.r[3].s64 = ctx.r[1].s64 + 1208;
	// 8265EC30: 4BC6A089  bl 0x822c8cb8
	ctx.lr = 0x8265EC34;
	sub_822C8CB8(ctx, base);
	// 8265EC34: 386100EC  addi r3, r1, 0xec
	ctx.r[3].s64 = ctx.r[1].s64 + 236;
	// 8265EC38: 487947F1  bl 0x82df3428
	ctx.lr = 0x8265EC3C;
	sub_82DF3428(ctx, base);
	// 8265EC3C: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 8265EC40: 48000614  b 0x8265f254
	pc = 0x8265F254; continue 'dispatch;
	// 8265EC44: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EC48: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EC4C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8265EC50: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EC54: 388A7D7C  addi r4, r10, 0x7d7c
	ctx.r[4].s64 = ctx.r[10].s64 + 32124;
	// 8265EC58: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8265EC5C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EC60: 48794DA9  bl 0x82df3a08
	ctx.lr = 0x8265EC64;
	sub_82DF3A08(ctx, base);
	// 8265EC64: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EC68: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8265EC6C: 388B9D98  addi r4, r11, -0x6268
	ctx.r[4].s64 = ctx.r[11].s64 + -25192;
	// 8265EC70: 48794D99  bl 0x82df3a08
	ctx.lr = 0x8265EC74;
	sub_82DF3A08(ctx, base);
	// 8265EC74: 38610260  addi r3, r1, 0x260
	ctx.r[3].s64 = ctx.r[1].s64 + 608;
	// 8265EC78: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EC7C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EC80: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EC84: 93E10260  stw r31, 0x260(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(608 as u32), ctx.r[31].u32 ) };
	// 8265EC88: 4BFFEB89  bl 0x8265d810
	ctx.lr = 0x8265EC8C;
	sub_8265D810(ctx, base);
	// 8265EC8C: 39210260  addi r9, r1, 0x260
	ctx.r[9].s64 = ctx.r[1].s64 + 608;
	// 8265EC90: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265EC94: 38BE0030  addi r5, r30, 0x30
	ctx.r[5].s64 = ctx.r[30].s64 + 48;
	// 8265EC98: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265EC9C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 8265ECA0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265ECA4: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 8265ECA8: 4BF4EDA1  bl 0x825ada48
	ctx.lr = 0x8265ECAC;
	sub_825ADA48(ctx, base);
	// 8265ECAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265ECB0: 388100C8  addi r4, r1, 0xc8
	ctx.r[4].s64 = ctx.r[1].s64 + 200;
	// 8265ECB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265ECB8: 4BF42999  bl 0x825a1650
	ctx.lr = 0x8265ECBC;
	sub_825A1650(ctx, base);
	// 8265ECBC: 38610398  addi r3, r1, 0x398
	ctx.r[3].s64 = ctx.r[1].s64 + 920;
	// 8265ECC0: 48794769  bl 0x82df3428
	ctx.lr = 0x8265ECC4;
	sub_82DF3428(ctx, base);
	// 8265ECC4: 38610378  addi r3, r1, 0x378
	ctx.r[3].s64 = ctx.r[1].s64 + 888;
	// 8265ECC8: 4BC69FF1  bl 0x822c8cb8
	ctx.lr = 0x8265ECCC;
	sub_822C8CB8(ctx, base);
	// 8265ECCC: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8265ECD0: 48794759  bl 0x82df3428
	ctx.lr = 0x8265ECD4;
	sub_82DF3428(ctx, base);
	// 8265ECD4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8265ECD8: 48794751  bl 0x82df3428
	ctx.lr = 0x8265ECDC;
	sub_82DF3428(ctx, base);
	// 8265ECDC: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265ECE0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265ECE4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265ECE8: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265ECEC: 388A9DD0  addi r4, r10, -0x6230
	ctx.r[4].s64 = ctx.r[10].s64 + -25136;
	// 8265ECF0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265ECF4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265ECF8: 48794D11  bl 0x82df3a08
	ctx.lr = 0x8265ECFC;
	sub_82DF3A08(ctx, base);
	// 8265ECFC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265ED00: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 8265ED04: 388B9DC8  addi r4, r11, -0x6238
	ctx.r[4].s64 = ctx.r[11].s64 + -25144;
	// 8265ED08: 48794D01  bl 0x82df3a08
	ctx.lr = 0x8265ED0C;
	sub_82DF3A08(ctx, base);
	// 8265ED0C: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 8265ED10: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265ED14: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265ED18: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265ED1C: 93E101A0  stw r31, 0x1a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[31].u32 ) };
	// 8265ED20: 4BFFEAF1  bl 0x8265d810
	ctx.lr = 0x8265ED24;
	sub_8265D810(ctx, base);
	// 8265ED24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265ED28: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8265ED2C: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 8265ED30: 392101A0  addi r9, r1, 0x1a0
	ctx.r[9].s64 = ctx.r[1].s64 + 416;
	// 8265ED34: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 8265ED38: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 8265ED3C: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8265ED40: 38610520  addi r3, r1, 0x520
	ctx.r[3].s64 = ctx.r[1].s64 + 1312;
	// 8265ED44: C04AD200  lfs f2, -0x2e00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8265ED48: C0288E4C  lfs f1, -0x71b4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265ED4C: 4BF4ECFD  bl 0x825ada48
	ctx.lr = 0x8265ED50;
	sub_825ADA48(ctx, base);
	// 8265ED50: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265ED54: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 8265ED58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265ED5C: 4BF428F5  bl 0x825a1650
	ctx.lr = 0x8265ED60;
	sub_825A1650(ctx, base);
	// 8265ED60: 38610558  addi r3, r1, 0x558
	ctx.r[3].s64 = ctx.r[1].s64 + 1368;
	// 8265ED64: 487946C5  bl 0x82df3428
	ctx.lr = 0x8265ED68;
	sub_82DF3428(ctx, base);
	// 8265ED68: 38610538  addi r3, r1, 0x538
	ctx.r[3].s64 = ctx.r[1].s64 + 1336;
	// 8265ED6C: 4BC69F4D  bl 0x822c8cb8
	ctx.lr = 0x8265ED70;
	sub_822C8CB8(ctx, base);
	// 8265ED70: 386100AC  addi r3, r1, 0xac
	ctx.r[3].s64 = ctx.r[1].s64 + 172;
	// 8265ED74: 487946B5  bl 0x82df3428
	ctx.lr = 0x8265ED78;
	sub_82DF3428(ctx, base);
	// 8265ED78: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8265ED7C: 487946AD  bl 0x82df3428
	ctx.lr = 0x8265ED80;
	sub_82DF3428(ctx, base);
	// 8265ED80: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265ED84: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265ED88: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265ED8C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265ED90: 388A9DB8  addi r4, r10, -0x6248
	ctx.r[4].s64 = ctx.r[10].s64 + -25160;
	// 8265ED94: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8265ED98: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265ED9C: 48794C6D  bl 0x82df3a08
	ctx.lr = 0x8265EDA0;
	sub_82DF3A08(ctx, base);
	// 8265EDA0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EDA4: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 8265EDA8: 388B9DA4  addi r4, r11, -0x625c
	ctx.r[4].s64 = ctx.r[11].s64 + -25180;
	// 8265EDAC: 48794C5D  bl 0x82df3a08
	ctx.lr = 0x8265EDB0;
	sub_82DF3A08(ctx, base);
	// 8265EDB0: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 8265EDB4: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EDB8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EDBC: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EDC0: 93E10220  stw r31, 0x220(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(544 as u32), ctx.r[31].u32 ) };
	// 8265EDC4: 4BFFEA4D  bl 0x8265d810
	ctx.lr = 0x8265EDC8;
	sub_8265D810(ctx, base);
	// 8265EDC8: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8265EDCC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265EDD0: 39210220  addi r9, r1, 0x220
	ctx.r[9].s64 = ctx.r[1].s64 + 544;
	// 8265EDD4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265EDD8: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 8265EDDC: 388100D8  addi r4, r1, 0xd8
	ctx.r[4].s64 = ctx.r[1].s64 + 216;
	// 8265EDE0: 386103A0  addi r3, r1, 0x3a0
	ctx.r[3].s64 = ctx.r[1].s64 + 928;
	// 8265EDE4: C02B8268  lfs f1, -0x7d98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265EDE8: 4BF4EC61  bl 0x825ada48
	ctx.lr = 0x8265EDEC;
	sub_825ADA48(ctx, base);
	// 8265EDEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EDF0: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 8265EDF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EDF8: 4BF42859  bl 0x825a1650
	ctx.lr = 0x8265EDFC;
	sub_825A1650(ctx, base);
	// 8265EDFC: 386103D8  addi r3, r1, 0x3d8
	ctx.r[3].s64 = ctx.r[1].s64 + 984;
	// 8265EE00: 48794629  bl 0x82df3428
	ctx.lr = 0x8265EE04;
	sub_82DF3428(ctx, base);
	// 8265EE04: 386103B8  addi r3, r1, 0x3b8
	ctx.r[3].s64 = ctx.r[1].s64 + 952;
	// 8265EE08: 4BC69EB1  bl 0x822c8cb8
	ctx.lr = 0x8265EE0C;
	sub_822C8CB8(ctx, base);
	// 8265EE0C: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 8265EE10: 48794619  bl 0x82df3428
	ctx.lr = 0x8265EE14;
	sub_82DF3428(ctx, base);
	// 8265EE14: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 8265EE18: 48794611  bl 0x82df3428
	ctx.lr = 0x8265EE1C;
	sub_82DF3428(ctx, base);
	// 8265EE1C: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EE20: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EE24: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EE28: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EE2C: 388A9D7C  addi r4, r10, -0x6284
	ctx.r[4].s64 = ctx.r[10].s64 + -25220;
	// 8265EE30: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 8265EE34: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EE38: 48794BD1  bl 0x82df3a08
	ctx.lr = 0x8265EE3C;
	sub_82DF3A08(ctx, base);
	// 8265EE3C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EE40: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 8265EE44: 388B9D64  addi r4, r11, -0x629c
	ctx.r[4].s64 = ctx.r[11].s64 + -25244;
	// 8265EE48: 48794BC1  bl 0x82df3a08
	ctx.lr = 0x8265EE4C;
	sub_82DF3A08(ctx, base);
	// 8265EE4C: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EE50: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 8265EE54: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EE58: 93E101E0  stw r31, 0x1e0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[31].u32 ) };
	// 8265EE5C: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EE60: 4BFFEA31  bl 0x8265d890
	ctx.lr = 0x8265EE64;
	sub_8265D890(ctx, base);
	// 8265EE64: 38C101E0  addi r6, r1, 0x1e0
	ctx.r[6].s64 = ctx.r[1].s64 + 480;
	// 8265EE68: 38BE002A  addi r5, r30, 0x2a
	ctx.r[5].s64 = ctx.r[30].s64 + 42;
	// 8265EE6C: 388100E8  addi r4, r1, 0xe8
	ctx.r[4].s64 = ctx.r[1].s64 + 232;
	// 8265EE70: 38610330  addi r3, r1, 0x330
	ctx.r[3].s64 = ctx.r[1].s64 + 816;
	// 8265EE74: 4BF44245  bl 0x825a30b8
	ctx.lr = 0x8265EE78;
	sub_825A30B8(ctx, base);
	// 8265EE78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EE7C: 388100BC  addi r4, r1, 0xbc
	ctx.r[4].s64 = ctx.r[1].s64 + 188;
	// 8265EE80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EE84: 4BF43305  bl 0x825a2188
	ctx.lr = 0x8265EE88;
	sub_825A2188(ctx, base);
	// 8265EE88: 38610358  addi r3, r1, 0x358
	ctx.r[3].s64 = ctx.r[1].s64 + 856;
	// 8265EE8C: 4879459D  bl 0x82df3428
	ctx.lr = 0x8265EE90;
	sub_82DF3428(ctx, base);
	// 8265EE90: 38610338  addi r3, r1, 0x338
	ctx.r[3].s64 = ctx.r[1].s64 + 824;
	// 8265EE94: 4BC69E25  bl 0x822c8cb8
	ctx.lr = 0x8265EE98;
	sub_822C8CB8(ctx, base);
	// 8265EE98: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 8265EE9C: 4879458D  bl 0x82df3428
	ctx.lr = 0x8265EEA0;
	sub_82DF3428(ctx, base);
	// 8265EEA0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 8265EEA4: 480003B0  b 0x8265f254
	pc = 0x8265F254; continue 'dispatch;
	// 8265EEA8: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EEAC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EEB0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EEB4: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EEB8: 388A9D5C  addi r4, r10, -0x62a4
	ctx.r[4].s64 = ctx.r[10].s64 + -25252;
	// 8265EEBC: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 8265EEC0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EEC4: 48794B45  bl 0x82df3a08
	ctx.lr = 0x8265EEC8;
	sub_82DF3A08(ctx, base);
	// 8265EEC8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EECC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8265EED0: 388B9D54  addi r4, r11, -0x62ac
	ctx.r[4].s64 = ctx.r[11].s64 + -25260;
	// 8265EED4: 48794B35  bl 0x82df3a08
	ctx.lr = 0x8265EED8;
	sub_82DF3A08(ctx, base);
	// 8265EED8: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 8265EEDC: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EEE0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EEE4: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EEE8: 93E10140  stw r31, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[31].u32 ) };
	// 8265EEEC: 4BFFE925  bl 0x8265d810
	ctx.lr = 0x8265EEF0;
	sub_8265D810(ctx, base);
	// 8265EEF0: 39210140  addi r9, r1, 0x140
	ctx.r[9].s64 = ctx.r[1].s64 + 320;
	// 8265EEF4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265EEF8: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 8265EEFC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265EF00: 388100C4  addi r4, r1, 0xc4
	ctx.r[4].s64 = ctx.r[1].s64 + 196;
	// 8265EF04: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265EF08: 386103E0  addi r3, r1, 0x3e0
	ctx.r[3].s64 = ctx.r[1].s64 + 992;
	// 8265EF0C: 4BF4EB3D  bl 0x825ada48
	ctx.lr = 0x8265EF10;
	sub_825ADA48(ctx, base);
	// 8265EF10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EF14: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8265EF18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EF1C: 4BF42735  bl 0x825a1650
	ctx.lr = 0x8265EF20;
	sub_825A1650(ctx, base);
	// 8265EF20: 38610418  addi r3, r1, 0x418
	ctx.r[3].s64 = ctx.r[1].s64 + 1048;
	// 8265EF24: 48794505  bl 0x82df3428
	ctx.lr = 0x8265EF28;
	sub_82DF3428(ctx, base);
	// 8265EF28: 386103F8  addi r3, r1, 0x3f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1016;
	// 8265EF2C: 4BC69D8D  bl 0x822c8cb8
	ctx.lr = 0x8265EF30;
	sub_822C8CB8(ctx, base);
	// 8265EF30: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8265EF34: 487944F5  bl 0x82df3428
	ctx.lr = 0x8265EF38;
	sub_82DF3428(ctx, base);
	// 8265EF38: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 8265EF3C: 487944ED  bl 0x82df3428
	ctx.lr = 0x8265EF40;
	sub_82DF3428(ctx, base);
	// 8265EF40: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EF44: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EF48: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EF4C: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265EF50: 388A9DD0  addi r4, r10, -0x6230
	ctx.r[4].s64 = ctx.r[10].s64 + -25136;
	// 8265EF54: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 8265EF58: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265EF5C: 48794AAD  bl 0x82df3a08
	ctx.lr = 0x8265EF60;
	sub_82DF3A08(ctx, base);
	// 8265EF60: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265EF64: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8265EF68: 388B9DC8  addi r4, r11, -0x6238
	ctx.r[4].s64 = ctx.r[11].s64 + -25144;
	// 8265EF6C: 48794A9D  bl 0x82df3a08
	ctx.lr = 0x8265EF70;
	sub_82DF3A08(ctx, base);
	// 8265EF70: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265EF74: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 8265EF78: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265EF7C: 93E10180  stw r31, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[31].u32 ) };
	// 8265EF80: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265EF84: 4BFFE88D  bl 0x8265d810
	ctx.lr = 0x8265EF88;
	sub_8265D810(ctx, base);
	// 8265EF88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265EF8C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8265EF90: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 8265EF94: 39210180  addi r9, r1, 0x180
	ctx.r[9].s64 = ctx.r[1].s64 + 384;
	// 8265EF98: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 8265EF9C: C38B08A8  lfs f28, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8265EFA0: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 8265EFA4: C36AD200  lfs f27, -0x2e00(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8265EFA8: 38610460  addi r3, r1, 0x460
	ctx.r[3].s64 = ctx.r[1].s64 + 1120;
	// 8265EFAC: C3488E4C  lfs f26, -0x71b4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-29108 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8265EFB0: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 8265EFB4: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 8265EFB8: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 8265EFBC: 4BF4EA8D  bl 0x825ada48
	ctx.lr = 0x8265EFC0;
	sub_825ADA48(ctx, base);
	// 8265EFC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265EFC4: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8265EFC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265EFCC: 4BF42685  bl 0x825a1650
	ctx.lr = 0x8265EFD0;
	sub_825A1650(ctx, base);
	// 8265EFD0: 38610498  addi r3, r1, 0x498
	ctx.r[3].s64 = ctx.r[1].s64 + 1176;
	// 8265EFD4: 48794455  bl 0x82df3428
	ctx.lr = 0x8265EFD8;
	sub_82DF3428(ctx, base);
	// 8265EFD8: 38610478  addi r3, r1, 0x478
	ctx.r[3].s64 = ctx.r[1].s64 + 1144;
	// 8265EFDC: 4BC69CDD  bl 0x822c8cb8
	ctx.lr = 0x8265EFE0;
	sub_822C8CB8(ctx, base);
	// 8265EFE0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8265EFE4: 48794445  bl 0x82df3428
	ctx.lr = 0x8265EFE8;
	sub_82DF3428(ctx, base);
	// 8265EFE8: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 8265EFEC: 4879443D  bl 0x82df3428
	ctx.lr = 0x8265EFF0;
	sub_82DF3428(ctx, base);
	// 8265EFF0: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265EFF4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265EFF8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265EFFC: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F000: 388A9D44  addi r4, r10, -0x62bc
	ctx.r[4].s64 = ctx.r[10].s64 + -25276;
	// 8265F004: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8265F008: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F00C: 487949FD  bl 0x82df3a08
	ctx.lr = 0x8265F010;
	sub_82DF3A08(ctx, base);
	// 8265F010: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F014: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8265F018: 388B9D34  addi r4, r11, -0x62cc
	ctx.r[4].s64 = ctx.r[11].s64 + -25292;
	// 8265F01C: 487949ED  bl 0x82df3a08
	ctx.lr = 0x8265F020;
	sub_82DF3A08(ctx, base);
	// 8265F020: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F024: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 8265F028: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F02C: 93E101C0  stw r31, 0x1c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[31].u32 ) };
	// 8265F030: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F034: 4BFFE7DD  bl 0x8265d810
	ctx.lr = 0x8265F038;
	sub_8265D810(ctx, base);
	// 8265F038: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8265F03C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265F040: 392101C0  addi r9, r1, 0x1c0
	ctx.r[9].s64 = ctx.r[1].s64 + 448;
	// 8265F044: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265F048: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 8265F04C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8265F050: 386104E0  addi r3, r1, 0x4e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1248;
	// 8265F054: C3AB8268  lfs f29, -0x7d98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32152 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8265F058: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265F05C: 4BF4E9ED  bl 0x825ada48
	ctx.lr = 0x8265F060;
	sub_825ADA48(ctx, base);
	// 8265F060: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F064: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 8265F068: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F06C: 4BF425E5  bl 0x825a1650
	ctx.lr = 0x8265F070;
	sub_825A1650(ctx, base);
	// 8265F070: 38610518  addi r3, r1, 0x518
	ctx.r[3].s64 = ctx.r[1].s64 + 1304;
	// 8265F074: 487943B5  bl 0x82df3428
	ctx.lr = 0x8265F078;
	sub_82DF3428(ctx, base);
	// 8265F078: 386104F8  addi r3, r1, 0x4f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1272;
	// 8265F07C: 4BC69C3D  bl 0x822c8cb8
	ctx.lr = 0x8265F080;
	sub_822C8CB8(ctx, base);
	// 8265F080: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8265F084: 487943A5  bl 0x82df3428
	ctx.lr = 0x8265F088;
	sub_82DF3428(ctx, base);
	// 8265F088: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8265F08C: 4879439D  bl 0x82df3428
	ctx.lr = 0x8265F090;
	sub_82DF3428(ctx, base);
	// 8265F090: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F094: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F098: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F09C: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F0A0: 388A9D24  addi r4, r10, -0x62dc
	ctx.r[4].s64 = ctx.r[10].s64 + -25308;
	// 8265F0A4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8265F0A8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F0AC: 4879495D  bl 0x82df3a08
	ctx.lr = 0x8265F0B0;
	sub_82DF3A08(ctx, base);
	// 8265F0B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F0B4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8265F0B8: 388B9D14  addi r4, r11, -0x62ec
	ctx.r[4].s64 = ctx.r[11].s64 + -25324;
	// 8265F0BC: 4879494D  bl 0x82df3a08
	ctx.lr = 0x8265F0C0;
	sub_82DF3A08(ctx, base);
	// 8265F0C0: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 8265F0C4: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F0C8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F0CC: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F0D0: 93E10200  stw r31, 0x200(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(512 as u32), ctx.r[31].u32 ) };
	// 8265F0D4: 4BFFE73D  bl 0x8265d810
	ctx.lr = 0x8265F0D8;
	sub_8265D810(ctx, base);
	// 8265F0D8: 39210200  addi r9, r1, 0x200
	ctx.r[9].s64 = ctx.r[1].s64 + 512;
	// 8265F0DC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265F0E0: 38BE0018  addi r5, r30, 0x18
	ctx.r[5].s64 = ctx.r[30].s64 + 24;
	// 8265F0E4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265F0E8: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8265F0EC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265F0F0: 38610560  addi r3, r1, 0x560
	ctx.r[3].s64 = ctx.r[1].s64 + 1376;
	// 8265F0F4: 4BF4E955  bl 0x825ada48
	ctx.lr = 0x8265F0F8;
	sub_825ADA48(ctx, base);
	// 8265F0F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F0FC: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 8265F100: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F104: 4BF4254D  bl 0x825a1650
	ctx.lr = 0x8265F108;
	sub_825A1650(ctx, base);
	// 8265F108: 38610598  addi r3, r1, 0x598
	ctx.r[3].s64 = ctx.r[1].s64 + 1432;
	// 8265F10C: 4879431D  bl 0x82df3428
	ctx.lr = 0x8265F110;
	sub_82DF3428(ctx, base);
	// 8265F110: 38610578  addi r3, r1, 0x578
	ctx.r[3].s64 = ctx.r[1].s64 + 1400;
	// 8265F114: 4BC69BA5  bl 0x822c8cb8
	ctx.lr = 0x8265F118;
	sub_822C8CB8(ctx, base);
	// 8265F118: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8265F11C: 4879430D  bl 0x82df3428
	ctx.lr = 0x8265F120;
	sub_82DF3428(ctx, base);
	// 8265F120: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8265F124: 48794305  bl 0x82df3428
	ctx.lr = 0x8265F128;
	sub_82DF3428(ctx, base);
	// 8265F128: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F12C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F130: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F134: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F138: 388A9DB8  addi r4, r10, -0x6248
	ctx.r[4].s64 = ctx.r[10].s64 + -25160;
	// 8265F13C: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 8265F140: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F144: 487948C5  bl 0x82df3a08
	ctx.lr = 0x8265F148;
	sub_82DF3A08(ctx, base);
	// 8265F148: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F14C: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 8265F150: 388B9DA4  addi r4, r11, -0x625c
	ctx.r[4].s64 = ctx.r[11].s64 + -25180;
	// 8265F154: 487948B5  bl 0x82df3a08
	ctx.lr = 0x8265F158;
	sub_82DF3A08(ctx, base);
	// 8265F158: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F15C: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 8265F160: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F164: 93E10240  stw r31, 0x240(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(576 as u32), ctx.r[31].u32 ) };
	// 8265F168: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F16C: 4BFFE6A5  bl 0x8265d810
	ctx.lr = 0x8265F170;
	sub_8265D810(ctx, base);
	// 8265F170: 39210240  addi r9, r1, 0x240
	ctx.r[9].s64 = ctx.r[1].s64 + 576;
	// 8265F174: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8265F178: 38BE0010  addi r5, r30, 0x10
	ctx.r[5].s64 = ctx.r[30].s64 + 16;
	// 8265F17C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8265F180: 388100D4  addi r4, r1, 0xd4
	ctx.r[4].s64 = ctx.r[1].s64 + 212;
	// 8265F184: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8265F188: 386105E0  addi r3, r1, 0x5e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1504;
	// 8265F18C: 4BF4E8BD  bl 0x825ada48
	ctx.lr = 0x8265F190;
	sub_825ADA48(ctx, base);
	// 8265F190: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F194: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 8265F198: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F19C: 4BF424B5  bl 0x825a1650
	ctx.lr = 0x8265F1A0;
	sub_825A1650(ctx, base);
	// 8265F1A0: 38610618  addi r3, r1, 0x618
	ctx.r[3].s64 = ctx.r[1].s64 + 1560;
	// 8265F1A4: 48794285  bl 0x82df3428
	ctx.lr = 0x8265F1A8;
	sub_82DF3428(ctx, base);
	// 8265F1A8: 386105F8  addi r3, r1, 0x5f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1528;
	// 8265F1AC: 4BC69B0D  bl 0x822c8cb8
	ctx.lr = 0x8265F1B0;
	sub_822C8CB8(ctx, base);
	// 8265F1B0: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 8265F1B4: 48794275  bl 0x82df3428
	ctx.lr = 0x8265F1B8;
	sub_82DF3428(ctx, base);
	// 8265F1B8: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 8265F1BC: 4879426D  bl 0x82df3428
	ctx.lr = 0x8265F1C0;
	sub_82DF3428(ctx, base);
	// 8265F1C0: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F1C4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F1C8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F1CC: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F1D0: 388A9D08  addi r4, r10, -0x62f8
	ctx.r[4].s64 = ctx.r[10].s64 + -25336;
	// 8265F1D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F1D8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F1DC: 4879482D  bl 0x82df3a08
	ctx.lr = 0x8265F1E0;
	sub_82DF3A08(ctx, base);
	// 8265F1E0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F1E8: 388B9CFC  addi r4, r11, -0x6304
	ctx.r[4].s64 = ctx.r[11].s64 + -25348;
	// 8265F1EC: 4879481D  bl 0x82df3a08
	ctx.lr = 0x8265F1F0;
	sub_82DF3A08(ctx, base);
	// 8265F1F0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8265F1F4: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F1F8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F1FC: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F200: 93E10100  stw r31, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[31].u32 ) };
	// 8265F204: 4BFFE60D  bl 0x8265d810
	ctx.lr = 0x8265F208;
	sub_8265D810(ctx, base);
	// 8265F208: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 8265F20C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 8265F210: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 8265F214: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 8265F218: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265F21C: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 8265F220: 38610660  addi r3, r1, 0x660
	ctx.r[3].s64 = ctx.r[1].s64 + 1632;
	// 8265F224: 4BF4E825  bl 0x825ada48
	ctx.lr = 0x8265F228;
	sub_825ADA48(ctx, base);
	// 8265F228: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F22C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F230: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F234: 4BF4241D  bl 0x825a1650
	ctx.lr = 0x8265F238;
	sub_825A1650(ctx, base);
	// 8265F238: 38610698  addi r3, r1, 0x698
	ctx.r[3].s64 = ctx.r[1].s64 + 1688;
	// 8265F23C: 487941ED  bl 0x82df3428
	ctx.lr = 0x8265F240;
	sub_82DF3428(ctx, base);
	// 8265F240: 38610678  addi r3, r1, 0x678
	ctx.r[3].s64 = ctx.r[1].s64 + 1656;
	// 8265F244: 4BC69A75  bl 0x822c8cb8
	ctx.lr = 0x8265F248;
	sub_822C8CB8(ctx, base);
	// 8265F248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F24C: 487941DD  bl 0x82df3428
	ctx.lr = 0x8265F250;
	sub_82DF3428(ctx, base);
	// 8265F250: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F254: 487941D5  bl 0x82df3428
	ctx.lr = 0x8265F258;
	sub_82DF3428(ctx, base);
	// 8265F258: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F25C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F260: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F264: 396BD060  addi r11, r11, -0x2fa0
	ctx.r[11].s64 = ctx.r[11].s64 + -12192;
	// 8265F268: 388A9CE8  addi r4, r10, -0x6318
	ctx.r[4].s64 = ctx.r[10].s64 + -25368;
	// 8265F26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F270: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F274: 48794795  bl 0x82df3a08
	ctx.lr = 0x8265F278;
	sub_82DF3A08(ctx, base);
	// 8265F278: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F27C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F280: 388B9CD8  addi r4, r11, -0x6328
	ctx.r[4].s64 = ctx.r[11].s64 + -25384;
	// 8265F284: 48794785  bl 0x82df3a08
	ctx.lr = 0x8265F288;
	sub_82DF3A08(ctx, base);
	// 8265F288: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8265F28C: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F290: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F294: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F298: 93E10100  stw r31, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[31].u32 ) };
	// 8265F29C: 4BFFE5F5  bl 0x8265d890
	ctx.lr = 0x8265F2A0;
	sub_8265D890(ctx, base);
	// 8265F2A0: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 8265F2A4: 38BE0029  addi r5, r30, 0x29
	ctx.r[5].s64 = ctx.r[30].s64 + 41;
	// 8265F2A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F2AC: 38610300  addi r3, r1, 0x300
	ctx.r[3].s64 = ctx.r[1].s64 + 768;
	// 8265F2B0: 4BF43E09  bl 0x825a30b8
	ctx.lr = 0x8265F2B4;
	sub_825A30B8(ctx, base);
	// 8265F2B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F2B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265F2BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F2C0: 4BF42EC9  bl 0x825a2188
	ctx.lr = 0x8265F2C4;
	sub_825A2188(ctx, base);
	// 8265F2C4: 38610328  addi r3, r1, 0x328
	ctx.r[3].s64 = ctx.r[1].s64 + 808;
	// 8265F2C8: 48794161  bl 0x82df3428
	ctx.lr = 0x8265F2CC;
	sub_82DF3428(ctx, base);
	// 8265F2CC: 38610308  addi r3, r1, 0x308
	ctx.r[3].s64 = ctx.r[1].s64 + 776;
	// 8265F2D0: 4BC699E9  bl 0x822c8cb8
	ctx.lr = 0x8265F2D4;
	sub_822C8CB8(ctx, base);
	// 8265F2D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F2D8: 48794151  bl 0x82df3428
	ctx.lr = 0x8265F2DC;
	sub_82DF3428(ctx, base);
	// 8265F2DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F2E0: 48794149  bl 0x82df3428
	ctx.lr = 0x8265F2E4;
	sub_82DF3428(ctx, base);
	// 8265F2E4: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F2E8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F2EC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F2F0: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F2F4: 388A9CC4  addi r4, r10, -0x633c
	ctx.r[4].s64 = ctx.r[10].s64 + -25404;
	// 8265F2F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F2FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F300: 48794709  bl 0x82df3a08
	ctx.lr = 0x8265F304;
	sub_82DF3A08(ctx, base);
	// 8265F304: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F308: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F30C: 388B9CB0  addi r4, r11, -0x6350
	ctx.r[4].s64 = ctx.r[11].s64 + -25424;
	// 8265F310: 487946F9  bl 0x82df3a08
	ctx.lr = 0x8265F314;
	sub_82DF3A08(ctx, base);
	// 8265F314: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8265F318: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F31C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F320: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F324: 93E10100  stw r31, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[31].u32 ) };
	// 8265F328: 4BFFE569  bl 0x8265d890
	ctx.lr = 0x8265F32C;
	sub_8265D890(ctx, base);
	// 8265F32C: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 8265F330: 38BE002B  addi r5, r30, 0x2b
	ctx.r[5].s64 = ctx.r[30].s64 + 43;
	// 8265F334: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F338: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 8265F33C: 4BF43D7D  bl 0x825a30b8
	ctx.lr = 0x8265F340;
	sub_825A30B8(ctx, base);
	// 8265F340: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F344: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265F348: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F34C: 4BF42E3D  bl 0x825a2188
	ctx.lr = 0x8265F350;
	sub_825A2188(ctx, base);
	// 8265F350: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 8265F354: 487940D5  bl 0x82df3428
	ctx.lr = 0x8265F358;
	sub_82DF3428(ctx, base);
	// 8265F358: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 8265F35C: 4BC6995D  bl 0x822c8cb8
	ctx.lr = 0x8265F360;
	sub_822C8CB8(ctx, base);
	// 8265F360: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F364: 487940C5  bl 0x82df3428
	ctx.lr = 0x8265F368;
	sub_82DF3428(ctx, base);
	// 8265F368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F36C: 487940BD  bl 0x82df3428
	ctx.lr = 0x8265F370;
	sub_82DF3428(ctx, base);
	// 8265F370: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F374: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F378: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F37C: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F380: 388A9CA8  addi r4, r10, -0x6358
	ctx.r[4].s64 = ctx.r[10].s64 + -25432;
	// 8265F384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F388: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F38C: 4879467D  bl 0x82df3a08
	ctx.lr = 0x8265F390;
	sub_82DF3A08(ctx, base);
	// 8265F390: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F394: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F398: 388B9C98  addi r4, r11, -0x6368
	ctx.r[4].s64 = ctx.r[11].s64 + -25448;
	// 8265F39C: 4879466D  bl 0x82df3a08
	ctx.lr = 0x8265F3A0;
	sub_82DF3A08(ctx, base);
	// 8265F3A0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8265F3A4: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F3A8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F3AC: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F3B0: 93E10100  stw r31, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[31].u32 ) };
	// 8265F3B4: 4BFFE55D  bl 0x8265d910
	ctx.lr = 0x8265F3B8;
	sub_8265D910(ctx, base);
	// 8265F3B8: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 8265F3BC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8265F3C0: 38E003E8  li r7, 0x3e8
	ctx.r[7].s64 = 1000;
	// 8265F3C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8265F3C8: 38BE0024  addi r5, r30, 0x24
	ctx.r[5].s64 = ctx.r[30].s64 + 36;
	// 8265F3CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F3D0: 386106E0  addi r3, r1, 0x6e0
	ctx.r[3].s64 = ctx.r[1].s64 + 1760;
	// 8265F3D4: 4BF4E74D  bl 0x825adb20
	ctx.lr = 0x8265F3D8;
	sub_825ADB20(ctx, base);
	// 8265F3D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F3DC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265F3E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F3E4: 4BF429D5  bl 0x825a1db8
	ctx.lr = 0x8265F3E8;
	sub_825A1DB8(ctx, base);
	// 8265F3E8: 38610718  addi r3, r1, 0x718
	ctx.r[3].s64 = ctx.r[1].s64 + 1816;
	// 8265F3EC: 4879403D  bl 0x82df3428
	ctx.lr = 0x8265F3F0;
	sub_82DF3428(ctx, base);
	// 8265F3F0: 386106F8  addi r3, r1, 0x6f8
	ctx.r[3].s64 = ctx.r[1].s64 + 1784;
	// 8265F3F4: 4BC698C5  bl 0x822c8cb8
	ctx.lr = 0x8265F3F8;
	sub_822C8CB8(ctx, base);
	// 8265F3F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F3FC: 4879402D  bl 0x82df3428
	ctx.lr = 0x8265F400;
	sub_82DF3428(ctx, base);
	// 8265F400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F404: 48794025  bl 0x82df3428
	ctx.lr = 0x8265F408;
	sub_82DF3428(ctx, base);
	// 8265F408: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8265F40C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F410: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8265F414: 396BE818  addi r11, r11, -0x17e8
	ctx.r[11].s64 = ctx.r[11].s64 + -6120;
	// 8265F418: 388A9C84  addi r4, r10, -0x637c
	ctx.r[4].s64 = ctx.r[10].s64 + -25468;
	// 8265F41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F420: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8265F424: 487945E5  bl 0x82df3a08
	ctx.lr = 0x8265F428;
	sub_82DF3A08(ctx, base);
	// 8265F428: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F42C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F430: 388B9C70  addi r4, r11, -0x6390
	ctx.r[4].s64 = ctx.r[11].s64 + -25488;
	// 8265F434: 487945D5  bl 0x82df3a08
	ctx.lr = 0x8265F438;
	sub_82DF3A08(ctx, base);
	// 8265F438: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8265F43C: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 8265F440: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8265F444: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8265F448: 93E10100  stw r31, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[31].u32 ) };
	// 8265F44C: 4BFFE445  bl 0x8265d890
	ctx.lr = 0x8265F450;
	sub_8265D890(ctx, base);
	// 8265F450: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 8265F454: 38BE0028  addi r5, r30, 0x28
	ctx.r[5].s64 = ctx.r[30].s64 + 40;
	// 8265F458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F45C: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 8265F460: 4BF43C59  bl 0x825a30b8
	ctx.lr = 0x8265F464;
	sub_825A30B8(ctx, base);
	// 8265F464: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8265F468: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8265F46C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F470: 4BF42D19  bl 0x825a2188
	ctx.lr = 0x8265F474;
	sub_825A2188(ctx, base);
	// 8265F474: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 8265F478: 48793FB1  bl 0x82df3428
	ctx.lr = 0x8265F47C;
	sub_82DF3428(ctx, base);
	// 8265F47C: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 8265F480: 4BC69839  bl 0x822c8cb8
	ctx.lr = 0x8265F484;
	sub_822C8CB8(ctx, base);
	// 8265F484: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F488: 48793FA1  bl 0x82df3428
	ctx.lr = 0x8265F48C;
	sub_82DF3428(ctx, base);
	// 8265F48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F490: 48793F99  bl 0x82df3428
	ctx.lr = 0x8265F494;
	sub_82DF3428(ctx, base);
	// 8265F494: 38210780  addi r1, r1, 0x780
	ctx.r[1].s64 = ctx.r[1].s64 + 1920;
	// 8265F498: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 8265F49C: 48B49621  bl 0x831a8abc
	ctx.lr = 0x8265F4A0;
	sub_831A8A8C(ctx, base);
	// 8265F4A0: 48B48D18  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265F4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265F4A8 size=196
    let mut pc: u32 = 0x8265F4A8;
    'dispatch: loop {
        match pc {
            0x8265F4A8 => {
    //   block [0x8265F4A8..0x8265F56C)
	// 8265F4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265F4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265F4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265F4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265F4B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265F4BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265F4C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265F4C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8265F4C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265F4CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265F4D0: 4BC61469  bl 0x822c0938
	ctx.lr = 0x8265F4D4;
	sub_822C0938(ctx, base);
	// 8265F4D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265F4D8: 41820028  beq 0x8265f500
	if ctx.cr[0].eq {
	pc = 0x8265F500; continue 'dispatch;
	}
	// 8265F4DC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F4E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8265F4E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8265F4E8: 392B9E1C  addi r9, r11, -0x61e4
	ctx.r[9].s64 = ctx.r[11].s64 + -25060;
	// 8265F4EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8265F4F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265F4F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8265F4F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8265F4FC: 48000008  b 0x8265f504
	pc = 0x8265F504; continue 'dispatch;
	// 8265F500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265F504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265F508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265F50C: 409A0044  bne cr6, 0x8265f550
	if !ctx.cr[6].eq {
	pc = 0x8265F550; continue 'dispatch;
	}
	// 8265F510: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265F514: 419A001C  beq cr6, 0x8265f530
	if ctx.cr[6].eq {
	pc = 0x8265F530; continue 'dispatch;
	}
	// 8265F518: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265F51C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8265F520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265F524: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265F528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8265F52C: 4E800421  bctrl
	ctx.lr = 0x8265F530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8265F530: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265F534: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265F538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F53C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8265F540: 816B624C  lwz r11, 0x624c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25164 as u32) ) } as u64;
	// 8265F544: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8265F548: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8265F54C: 4BC60AB5  bl 0x822c0000
	ctx.lr = 0x8265F550;
	sub_822C0000(ctx, base);
	// 8265F550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265F554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265F558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265F55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265F560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265F564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265F568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265F570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265F570 size=240
    let mut pc: u32 = 0x8265F570;
    'dispatch: loop {
        match pc {
            0x8265F570 => {
    //   block [0x8265F570..0x8265F660)
	// 8265F570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265F574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265F578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265F57C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265F580: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265F584: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8265F588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265F58C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8265F590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F594: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8265F598: 4BCA9F59  bl 0x823094f0
	ctx.lr = 0x8265F59C;
	sub_823094F0(ctx, base);
	// 8265F59C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265F5A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8265F5A4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8265F5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265F5AC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8265F5B0: 419A0024  beq cr6, 0x8265f5d4
	if ctx.cr[6].eq {
	pc = 0x8265F5D4; continue 'dispatch;
	}
	// 8265F5B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8265F5B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265F5BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F5C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265F5C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265F5C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265F5CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F5D0: 4082FFE8  bne 0x8265f5b8
	if !ctx.cr[0].eq {
	pc = 0x8265F5B8; continue 'dispatch;
	}
	// 8265F5D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265F5D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265F5DC: 4BEAFEED  bl 0x8250f4c8
	ctx.lr = 0x8265F5E0;
	sub_8250F4C8(ctx, base);
	// 8265F5E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265F5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265F5E8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8265F5EC: 409A0008  bne cr6, 0x8265f5f4
	if !ctx.cr[6].eq {
	pc = 0x8265F5F4; continue 'dispatch;
	}
	// 8265F5F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8265F5F4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8265F5F8: 4BEA9489  bl 0x82508a80
	ctx.lr = 0x8265F5FC;
	sub_82508A80(ctx, base);
	// 8265F5FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265F600: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F604: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8265F608: 388A9E30  addi r4, r10, -0x61d0
	ctx.r[4].s64 = ctx.r[10].s64 + -25040;
	// 8265F60C: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 8265F610: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8265F614: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265F618: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8265F61C: 487F9425  bl 0x82e58a40
	ctx.lr = 0x8265F620;
	sub_82E58A40(ctx, base);
	// 8265F620: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265F624: 4879266D  bl 0x82df1c90
	ctx.lr = 0x8265F628;
	sub_82DF1C90(ctx, base);
	// 8265F628: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265F62C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265F630: 419A0008  beq cr6, 0x8265f638
	if ctx.cr[6].eq {
	pc = 0x8265F638; continue 'dispatch;
	}
	// 8265F634: 4BC6125D  bl 0x822c0890
	ctx.lr = 0x8265F638;
	sub_822C0890(ctx, base);
	// 8265F638: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8265F63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265F640: 419A0008  beq cr6, 0x8265f648
	if ctx.cr[6].eq {
	pc = 0x8265F648; continue 'dispatch;
	}
	// 8265F644: 4BC6124D  bl 0x822c0890
	ctx.lr = 0x8265F648;
	sub_822C0890(ctx, base);
	// 8265F648: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8265F64C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265F650: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265F654: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265F658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265F65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265F660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265F660 size=240
    let mut pc: u32 = 0x8265F660;
    'dispatch: loop {
        match pc {
            0x8265F660 => {
    //   block [0x8265F660..0x8265F750)
	// 8265F660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265F664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265F668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265F66C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265F670: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265F674: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8265F678: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265F67C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8265F680: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265F684: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8265F688: 4BCA9E69  bl 0x823094f0
	ctx.lr = 0x8265F68C;
	sub_823094F0(ctx, base);
	// 8265F68C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265F690: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8265F694: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8265F698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265F69C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8265F6A0: 419A0024  beq cr6, 0x8265f6c4
	if ctx.cr[6].eq {
	pc = 0x8265F6C4; continue 'dispatch;
	}
	// 8265F6A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8265F6A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265F6AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F6B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265F6B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265F6B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265F6BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F6C0: 4082FFE8  bne 0x8265f6a8
	if !ctx.cr[0].eq {
	pc = 0x8265F6A8; continue 'dispatch;
	}
	// 8265F6C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265F6C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265F6CC: 4BEAFDFD  bl 0x8250f4c8
	ctx.lr = 0x8265F6D0;
	sub_8250F4C8(ctx, base);
	// 8265F6D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265F6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265F6D8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8265F6DC: 409A0008  bne cr6, 0x8265f6e4
	if !ctx.cr[6].eq {
	pc = 0x8265F6E4; continue 'dispatch;
	}
	// 8265F6E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8265F6E4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 8265F6E8: 4BEA9399  bl 0x82508a80
	ctx.lr = 0x8265F6EC;
	sub_82508A80(ctx, base);
	// 8265F6EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265F6F0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F6F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8265F6F8: 388A9E30  addi r4, r10, -0x61d0
	ctx.r[4].s64 = ctx.r[10].s64 + -25040;
	// 8265F6FC: 38A0004E  li r5, 0x4e
	ctx.r[5].s64 = 78;
	// 8265F700: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8265F704: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265F708: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8265F70C: 487F9335  bl 0x82e58a40
	ctx.lr = 0x8265F710;
	sub_82E58A40(ctx, base);
	// 8265F710: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265F714: 4879257D  bl 0x82df1c90
	ctx.lr = 0x8265F718;
	sub_82DF1C90(ctx, base);
	// 8265F718: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8265F71C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265F720: 419A0008  beq cr6, 0x8265f728
	if ctx.cr[6].eq {
	pc = 0x8265F728; continue 'dispatch;
	}
	// 8265F724: 4BC6116D  bl 0x822c0890
	ctx.lr = 0x8265F728;
	sub_822C0890(ctx, base);
	// 8265F728: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8265F72C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265F730: 419A0008  beq cr6, 0x8265f738
	if ctx.cr[6].eq {
	pc = 0x8265F738; continue 'dispatch;
	}
	// 8265F734: 4BC6115D  bl 0x822c0890
	ctx.lr = 0x8265F738;
	sub_822C0890(ctx, base);
	// 8265F738: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8265F73C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265F740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265F744: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265F748: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265F74C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265F750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265F750 size=248
    let mut pc: u32 = 0x8265F750;
    'dispatch: loop {
        match pc {
            0x8265F750 => {
    //   block [0x8265F750..0x8265F848)
	// 8265F750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265F754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265F758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265F75C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265F760: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265F764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265F768: 48034B59  bl 0x826942c0
	ctx.lr = 0x8265F76C;
	sub_826942C0(ctx, base);
	// 8265F76C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F770: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F774: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8265F778: 396B9F3C  addi r11, r11, -0x60c4
	ctx.r[11].s64 = ctx.r[11].s64 + -24772;
	// 8265F77C: 394A9F28  addi r10, r10, -0x60d8
	ctx.r[10].s64 = ctx.r[10].s64 + -24792;
	// 8265F780: 39299EDC  addi r9, r9, -0x6124
	ctx.r[9].s64 = ctx.r[9].s64 + -24868;
	// 8265F784: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265F788: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8265F78C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8265F790: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 8265F794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265F798: 808B6784  lwz r4, 0x6784(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26500 as u32) ) } as u64;
	// 8265F79C: 4BC85795  bl 0x822e4f30
	ctx.lr = 0x8265F7A0;
	sub_822E4F30(ctx, base);
	// 8265F7A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265F7A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8265F7A8: 4BC85719  bl 0x822e4ec0
	ctx.lr = 0x8265F7AC;
	sub_822E4EC0(ctx, base);
	// 8265F7AC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8265F7B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265F7B4: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8265F7B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8265F7BC: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8265F7C0: 4BE2CAC9  bl 0x8248c288
	ctx.lr = 0x8265F7C4;
	sub_8248C288(ctx, base);
	// 8265F7C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8265F7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265F7CC: 48034595  bl 0x82693d60
	ctx.lr = 0x8265F7D0;
	sub_82693D60(ctx, base);
	// 8265F7D0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8265F7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265F7D8: 3BCB9FC4  addi r30, r11, -0x603c
	ctx.r[30].s64 = ctx.r[11].s64 + -24636;
	// 8265F7DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265F7E0: 48034629  bl 0x82693e08
	ctx.lr = 0x8265F7E4;
	sub_82693E08(ctx, base);
	// 8265F7E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265F7E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265F7EC: 48034645  bl 0x82693e30
	ctx.lr = 0x8265F7F0;
	sub_82693E30(ctx, base);
	// 8265F7F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265F7F4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265F7F8: 997F0100  stb r11, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 8265F7FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265F800: 388A9E9C  addi r4, r10, -0x6164
	ctx.r[4].s64 = ctx.r[10].s64 + -24932;
	// 8265F804: 4BC69AED  bl 0x822c92f0
	ctx.lr = 0x8265F808;
	sub_822C92F0(ctx, base);
	// 8265F808: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 8265F80C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8265F810: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8265F814: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265F818: 4BC69919  bl 0x822c9130
	ctx.lr = 0x8265F81C;
	sub_822C9130(ctx, base);
	// 8265F81C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8265F820: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8265F824: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265F828: 4BC69609  bl 0x822c8e30
	ctx.lr = 0x8265F82C;
	sub_822C8E30(ctx, base);
	// 8265F82C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265F830: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8265F834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265F838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265F83C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265F840: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265F844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265F848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265F848 size=424
    let mut pc: u32 = 0x8265F848;
    'dispatch: loop {
        match pc {
            0x8265F848 => {
    //   block [0x8265F848..0x8265F9F0)
	// 8265F848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265F84C: 48B48919  bl 0x831a8164
	ctx.lr = 0x8265F850;
	sub_831A8130(ctx, base);
	// 8265F850: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265F854: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265F858: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8265F85C: 3BCB9E30  addi r30, r11, -0x61d0
	ctx.r[30].s64 = ctx.r[11].s64 + -25040;
	// 8265F860: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8265F864: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265F868: 38A00021  li r5, 0x21
	ctx.r[5].s64 = 33;
	// 8265F86C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8265F870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265F874: 3860012C  li r3, 0x12c
	ctx.r[3].s64 = 300;
	// 8265F878: 48792B71  bl 0x82df23e8
	ctx.lr = 0x8265F87C;
	sub_82DF23E8(ctx, base);
	// 8265F87C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265F880: 41820010  beq 0x8265f890
	if ctx.cr[0].eq {
	pc = 0x8265F890; continue 'dispatch;
	}
	// 8265F884: 4BFFFECD  bl 0x8265f750
	ctx.lr = 0x8265F888;
	sub_8265F750(ctx, base);
	// 8265F888: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265F88C: 48000008  b 0x8265f894
	pc = 0x8265F894; continue 'dispatch;
	// 8265F890: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265F894: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8265F898: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265F89C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265F8A0: 4BFFFC09  bl 0x8265f4a8
	ctx.lr = 0x8265F8A4;
	sub_8265F4A8(ctx, base);
	// 8265F8A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265F8A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265F8AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8265F8B0: 4BC60751  bl 0x822c0000
	ctx.lr = 0x8265F8B4;
	sub_822C0000(ctx, base);
	// 8265F8B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265F8B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265F8BC: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 8265F8C0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8265F8C4: 4BC60B15  bl 0x822c03d8
	ctx.lr = 0x8265F8C8;
	sub_822C03D8(ctx, base);
	// 8265F8C8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8265F8CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8265F8D0: 418200B4  beq 0x8265f984
	if ctx.cr[0].eq {
	pc = 0x8265F984; continue 'dispatch;
	}
	// 8265F8D4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265F8D8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8265F8DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8265F8E0: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 8265F8E4: 409A0008  bne cr6, 0x8265f8ec
	if !ctx.cr[6].eq {
	pc = 0x8265F8EC; continue 'dispatch;
	}
	// 8265F8E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265F8EC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8265F8F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265F8F4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8265F8F8: 419A0024  beq cr6, 0x8265f91c
	if ctx.cr[6].eq {
	pc = 0x8265F91C; continue 'dispatch;
	}
	// 8265F8FC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265F900: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8265F904: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F908: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8265F90C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8265F910: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265F914: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F918: 4082FFE8  bne 0x8265f900
	if !ctx.cr[0].eq {
	pc = 0x8265F900; continue 'dispatch;
	}
	// 8265F91C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8265F920: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265F924: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 8265F928: 419A0024  beq cr6, 0x8265f94c
	if ctx.cr[6].eq {
	pc = 0x8265F94C; continue 'dispatch;
	}
	// 8265F92C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8265F930: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8265F934: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F938: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8265F93C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8265F940: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8265F944: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8265F948: 4082FFE8  bne 0x8265f930
	if !ctx.cr[0].eq {
	pc = 0x8265F930; continue 'dispatch;
	}
	// 8265F94C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265F950: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8265F954: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8265F958: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8265F95C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8265F960: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265F964: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8265F968: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265F96C: 481395C5  bl 0x82798f30
	ctx.lr = 0x8265F970;
	sub_82798F30(ctx, base);
	// 8265F970: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8265F974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265F978: 4813BCF1  bl 0x8279b668
	ctx.lr = 0x8265F97C;
	sub_8279B668(ctx, base);
	// 8265F97C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265F980: 48000008  b 0x8265f988
	pc = 0x8265F988; continue 'dispatch;
	// 8265F984: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265F988: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8265F98C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8265F990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265F994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265F998: 4BF382B9  bl 0x82597c50
	ctx.lr = 0x8265F99C;
	sub_82597C50(ctx, base);
	// 8265F99C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265F9A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265F9A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265F9A8: 4BC60659  bl 0x822c0000
	ctx.lr = 0x8265F9AC;
	sub_822C0000(ctx, base);
	// 8265F9AC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265F9B0: 41820024  beq 0x8265f9d4
	if ctx.cr[0].eq {
	pc = 0x8265F9D4; continue 'dispatch;
	}
	// 8265F9B4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8265F9B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265F9BC: 419A0008  beq cr6, 0x8265f9c4
	if ctx.cr[6].eq {
	pc = 0x8265F9C4; continue 'dispatch;
	}
	// 8265F9C0: 4BC60ED1  bl 0x822c0890
	ctx.lr = 0x8265F9C4;
	sub_822C0890(ctx, base);
	// 8265F9C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8265F9C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265F9CC: 419A0008  beq cr6, 0x8265f9d4
	if ctx.cr[6].eq {
	pc = 0x8265F9D4; continue 'dispatch;
	}
	// 8265F9D0: 4BC60EC1  bl 0x822c0890
	ctx.lr = 0x8265F9D4;
	sub_822C0890(ctx, base);
	// 8265F9D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8265F9D8: 419A000C  beq cr6, 0x8265f9e4
	if ctx.cr[6].eq {
	pc = 0x8265F9E4; continue 'dispatch;
	}
	// 8265F9DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265F9E0: 4BC60EB1  bl 0x822c0890
	ctx.lr = 0x8265F9E4;
	sub_822C0890(ctx, base);
	// 8265F9E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8265F9E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8265F9EC: 48B487C8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265F9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265F9F0 size=136
    let mut pc: u32 = 0x8265F9F0;
    'dispatch: loop {
        match pc {
            0x8265F9F0 => {
    //   block [0x8265F9F0..0x8265FA78)
	// 8265F9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265F9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265F9F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265F9FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FA00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FA04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265FA08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265FA0C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8265FA10: 409A0020  bne cr6, 0x8265fa30
	if !ctx.cr[6].eq {
	pc = 0x8265FA30; continue 'dispatch;
	}
	// 8265FA14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265FA18: 419A0048  beq cr6, 0x8265fa60
	if ctx.cr[6].eq {
	pc = 0x8265FA60; continue 'dispatch;
	}
	// 8265FA1C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8265FA20: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8265FA24: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8265FA28: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8265FA2C: 48000034  b 0x8265fa60
	pc = 0x8265FA60; continue 'dispatch;
	// 8265FA30: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8265FA34: 419A002C  beq cr6, 0x8265fa60
	if ctx.cr[6].eq {
	pc = 0x8265FA60; continue 'dispatch;
	}
	// 8265FA38: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265FA3C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FA40: 388B62F0  addi r4, r11, 0x62f0
	ctx.r[4].s64 = ctx.r[11].s64 + 25328;
	// 8265FA44: 48B486B5  bl 0x831a80f8
	ctx.lr = 0x8265FA48;
	sub_831A80F8(ctx, base);
	// 8265FA48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265FA4C: 4182000C  beq 0x8265fa58
	if ctx.cr[0].eq {
	pc = 0x8265FA58; continue 'dispatch;
	}
	// 8265FA50: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8265FA54: 4800000C  b 0x8265fa60
	pc = 0x8265FA60; continue 'dispatch;
	// 8265FA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265FA5C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265FA60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265FA64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FA68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FA6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265FA70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FA74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265FA78 size=108
    let mut pc: u32 = 0x8265FA78;
    'dispatch: loop {
        match pc {
            0x8265FA78 => {
    //   block [0x8265FA78..0x8265FAE4)
	// 8265FA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FA7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FA80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FA84: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FA88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8265FA8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265FA90: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8265FA94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FA98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265FA9C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265FAA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265FAA4: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8265FAA8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8265FAAC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8265FAB0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8265FAB4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8265FAB8: C009CEE4  lfs f0, -0x311c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265FABC: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8265FAC0: 4881D181  bl 0x82e7cc40
	ctx.lr = 0x8265FAC4;
	sub_82E7CC40(ctx, base);
	// 8265FAC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8265FAC8: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8265FACC: 4BF2B3E5  bl 0x8258aeb0
	ctx.lr = 0x8265FAD0;
	sub_8258AEB0(ctx, base);
	// 8265FAD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8265FAD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FAD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265FAE8 size=124
    let mut pc: u32 = 0x8265FAE8;
    'dispatch: loop {
        match pc {
            0x8265FAE8 => {
    //   block [0x8265FAE8..0x8265FB64)
	// 8265FAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FAF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FAF4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8265FAF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FB04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265FB08: 4BEAF9C1  bl 0x8250f4c8
	ctx.lr = 0x8265FB0C;
	sub_8250F4C8(ctx, base);
	// 8265FB0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265FB14: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 8265FB18: 409A0008  bne cr6, 0x8265fb20
	if !ctx.cr[6].eq {
	pc = 0x8265FB20; continue 'dispatch;
	}
	// 8265FB1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8265FB20: 4BEA89F9  bl 0x82508518
	ctx.lr = 0x8265FB24;
	sub_82508518(ctx, base);
	// 8265FB24: C01F0104  lfs f0, 0x104(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265FB28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FB2C: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8265FB30: 48792161  bl 0x82df1c90
	ctx.lr = 0x8265FB34;
	sub_82DF1C90(ctx, base);
	// 8265FB34: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265FB38: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265FB3C: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8265FB40: C84BA000  lfd f2, -0x6000(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-24576 as u32) ) };
	// 8265FB44: 48B4ACCD  bl 0x831aa810
	ctx.lr = 0x8265FB48;
	sub_831AA810(ctx, base);
	// 8265FB48: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8265FB4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265FB50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FB54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FB58: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265FB5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FB60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265FB68 size=304
    let mut pc: u32 = 0x8265FB68;
    'dispatch: loop {
        match pc {
            0x8265FB68 => {
    //   block [0x8265FB68..0x8265FC98)
	// 8265FB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FB6C: 48B48601  bl 0x831a816c
	ctx.lr = 0x8265FB70;
	sub_831A8130(ctx, base);
	// 8265FB70: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8265FB74: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FB7C: 4BFFFF6D  bl 0x8265fae8
	ctx.lr = 0x8265FB80;
	sub_8265FAE8(ctx, base);
	// 8265FB80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FB84: 4BFFFEF5  bl 0x8265fa78
	ctx.lr = 0x8265FB88;
	sub_8265FA78(ctx, base);
	// 8265FB88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265FB8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8265FB90: 83BF00F0  lwz r29, 0xf0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8265FB94: 4BEAF935  bl 0x8250f4c8
	ctx.lr = 0x8265FB98;
	sub_8250F4C8(ctx, base);
	// 8265FB98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FB9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265FBA0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8265FBA4: 409A0008  bne cr6, 0x8265fbac
	if !ctx.cr[6].eq {
	pc = 0x8265FBAC; continue 'dispatch;
	}
	// 8265FBA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265FBAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FBB0: 4BEA8E01  bl 0x825089b0
	ctx.lr = 0x8265FBB4;
	sub_825089B0(ctx, base);
	// 8265FBB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FBB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265FBBC: 3BCBFF34  addi r30, r11, -0xcc
	ctx.r[30].s64 = ctx.r[11].s64 + -204;
	// 8265FBC0: 409A0008  bne cr6, 0x8265fbc8
	if !ctx.cr[6].eq {
	pc = 0x8265FBC8; continue 'dispatch;
	}
	// 8265FBC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8265FBC8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8265FBCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8265FBD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265FBD4: 3BAB9FBC  addi r29, r11, -0x6044
	ctx.r[29].s64 = ctx.r[11].s64 + -24644;
	// 8265FBD8: 4BC8D3F1  bl 0x822ecfc8
	ctx.lr = 0x8265FBDC;
	sub_822ECFC8(ctx, base);
	// 8265FBDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8265FBE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8265FBE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265FBE8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8265FBEC: C3EBD5B8  lfs f31, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8265FBF0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8265FBF4: 4BC687C5  bl 0x822c83b8
	ctx.lr = 0x8265FBF8;
	sub_822C83B8(ctx, base);
	// 8265FBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FBFC: 48792095  bl 0x82df1c90
	ctx.lr = 0x8265FC00;
	sub_82DF1C90(ctx, base);
	// 8265FC00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8265FC04: 4879208D  bl 0x82df1c90
	ctx.lr = 0x8265FC08;
	sub_82DF1C90(ctx, base);
	// 8265FC08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265FC0C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8265FC10: 83DF00F0  lwz r30, 0xf0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 8265FC14: 4BEAF8B5  bl 0x8250f4c8
	ctx.lr = 0x8265FC18;
	sub_8250F4C8(ctx, base);
	// 8265FC18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FC1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265FC20: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8265FC24: 409A0008  bne cr6, 0x8265fc2c
	if !ctx.cr[6].eq {
	pc = 0x8265FC2C; continue 'dispatch;
	}
	// 8265FC28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265FC2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265FC30: 4BEA8D81  bl 0x825089b0
	ctx.lr = 0x8265FC34;
	sub_825089B0(ctx, base);
	// 8265FC34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FC38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265FC3C: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 8265FC40: 409A0008  bne cr6, 0x8265fc48
	if !ctx.cr[6].eq {
	pc = 0x8265FC48; continue 'dispatch;
	}
	// 8265FC44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8265FC48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FC4C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8265FC50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265FC54: 3BCA9FA4  addi r30, r10, -0x605c
	ctx.r[30].s64 = ctx.r[10].s64 + -24668;
	// 8265FC58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8265FC5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8265FC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8265FC64: 4E800421  bctrl
	ctx.lr = 0x8265FC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8265FC68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8265FC6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FC70: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8265FC74: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8265FC78: 4BC68741  bl 0x822c83b8
	ctx.lr = 0x8265FC7C;
	sub_822C83B8(ctx, base);
	// 8265FC7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8265FC80: 48792011  bl 0x82df1c90
	ctx.lr = 0x8265FC84;
	sub_82DF1C90(ctx, base);
	// 8265FC84: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8265FC88: 48792009  bl 0x82df1c90
	ctx.lr = 0x8265FC8C;
	sub_82DF1C90(ctx, base);
	// 8265FC8C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8265FC90: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8265FC94: 48B48528  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265FC98 size=196
    let mut pc: u32 = 0x8265FC98;
    'dispatch: loop {
        match pc {
            0x8265FC98 => {
    //   block [0x8265FC98..0x8265FD5C)
	// 8265FC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FCA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265FCA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FCA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FCAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8265FCB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265FCB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8265FCB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8265FCBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265FCC0: 4BC60C79  bl 0x822c0938
	ctx.lr = 0x8265FCC4;
	sub_822C0938(ctx, base);
	// 8265FCC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265FCC8: 41820028  beq 0x8265fcf0
	if ctx.cr[0].eq {
	pc = 0x8265FCF0; continue 'dispatch;
	}
	// 8265FCCC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265FCD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8265FCD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8265FCD8: 392BA00C  addi r9, r11, -0x5ff4
	ctx.r[9].s64 = ctx.r[11].s64 + -24564;
	// 8265FCDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8265FCE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8265FCE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8265FCE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8265FCEC: 48000008  b 0x8265fcf4
	pc = 0x8265FCF4; continue 'dispatch;
	// 8265FCF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265FCF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265FCF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8265FCFC: 409A0044  bne cr6, 0x8265fd40
	if !ctx.cr[6].eq {
	pc = 0x8265FD40; continue 'dispatch;
	}
	// 8265FD00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265FD04: 419A001C  beq cr6, 0x8265fd20
	if ctx.cr[6].eq {
	pc = 0x8265FD20; continue 'dispatch;
	}
	// 8265FD08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FD0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8265FD10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FD14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FD18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8265FD1C: 4E800421  bctrl
	ctx.lr = 0x8265FD20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8265FD20: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265FD24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265FD28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FD2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8265FD30: 816B62EC  lwz r11, 0x62ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25324 as u32) ) } as u64;
	// 8265FD34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8265FD38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8265FD3C: 4BC602C5  bl 0x822c0000
	ctx.lr = 0x8265FD40;
	sub_822C0000(ctx, base);
	// 8265FD40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265FD44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265FD48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FD4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FD50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265FD54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FD58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265FD60 size=72
    let mut pc: u32 = 0x8265FD60;
    'dispatch: loop {
        match pc {
            0x8265FD60 => {
    //   block [0x8265FD60..0x8265FDA8)
	// 8265FD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FD64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FD68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FD6C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8265FD70: 419A001C  beq cr6, 0x8265fd8c
	if ctx.cr[6].eq {
	pc = 0x8265FD8C; continue 'dispatch;
	}
	// 8265FD74: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8265FD78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8265FD7C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8265FD80: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8265FD84: 4BFFFC6D  bl 0x8265f9f0
	ctx.lr = 0x8265FD88;
	sub_8265F9F0(ctx, base);
	// 8265FD88: 48000010  b 0x8265fd98
	pc = 0x8265FD98; continue 'dispatch;
	// 8265FD8C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8265FD90: 396B62F0  addi r11, r11, 0x62f0
	ctx.r[11].s64 = ctx.r[11].s64 + 25328;
	// 8265FD94: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265FD98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265FD9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FDA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FDA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8265FDA8 size=160
    let mut pc: u32 = 0x8265FDA8;
    'dispatch: loop {
        match pc {
            0x8265FDA8 => {
    //   block [0x8265FDA8..0x8265FE48)
	// 8265FDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FDAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FDB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FDB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FDB8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8265FDBC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8265FDC0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 8265FDC4: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 8265FDC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FDCC: 4BEB2495  bl 0x82512260
	ctx.lr = 0x8265FDD0;
	sub_82512260(ctx, base);
	// 8265FDD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8265FDD4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265FDD8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8265FDDC: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8265FDE0: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8265FDE4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 8265FDE8: 394AA084  addi r10, r10, -0x5f7c
	ctx.r[10].s64 = ctx.r[10].s64 + -24444;
	// 8265FDEC: 3929A070  addi r9, r9, -0x5f90
	ctx.r[9].s64 = ctx.r[9].s64 + -24464;
	// 8265FDF0: 3908A024  addi r8, r8, -0x5fdc
	ctx.r[8].s64 = ctx.r[8].s64 + -24540;
	// 8265FDF4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8265FDF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8265FDFC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8265FE00: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 8265FE04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8265FE08: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 8265FE0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FE10: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 8265FE14: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 8265FE18: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 8265FE1C: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 8265FE20: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8265FE24: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 8265FE28: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8265FE2C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 8265FE30: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 8265FE34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8265FE38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FE3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FE40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FE44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8265FE48 size=8
    let mut pc: u32 = 0x8265FE48;
    'dispatch: loop {
        match pc {
            0x8265FE48 => {
    //   block [0x8265FE48..0x8265FE50)
	// 8265FE48: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8265FE4C: 480000A4  b 0x8265fef0
	sub_8265FEF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FE50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8265FE50 size=8
    let mut pc: u32 = 0x8265FE50;
    'dispatch: loop {
        match pc {
            0x8265FE50 => {
    //   block [0x8265FE50..0x8265FE58)
	// 8265FE50: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8265FE54: 4800009C  b 0x8265fef0
	sub_8265FEF0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265FE58 size=152
    let mut pc: u32 = 0x8265FE58;
    'dispatch: loop {
        match pc {
            0x8265FE58 => {
    //   block [0x8265FE58..0x8265FEF0)
	// 8265FE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FE60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265FE64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FE68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FE6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FE70: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265FE74: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8265FE78: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 8265FE7C: 396BA084  addi r11, r11, -0x5f7c
	ctx.r[11].s64 = ctx.r[11].s64 + -24444;
	// 8265FE80: 394AA070  addi r10, r10, -0x5f90
	ctx.r[10].s64 = ctx.r[10].s64 + -24464;
	// 8265FE84: 3929A024  addi r9, r9, -0x5fdc
	ctx.r[9].s64 = ctx.r[9].s64 + -24540;
	// 8265FE88: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8265FE8C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8265FE90: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 8265FE94: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 8265FE98: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 8265FE9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265FEA0: 419A0008  beq cr6, 0x8265fea8
	if ctx.cr[6].eq {
	pc = 0x8265FEA8; continue 'dispatch;
	}
	// 8265FEA4: 4BC609ED  bl 0x822c0890
	ctx.lr = 0x8265FEA8;
	sub_822C0890(ctx, base);
	// 8265FEA8: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 8265FEAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265FEB0: 419A0008  beq cr6, 0x8265feb8
	if ctx.cr[6].eq {
	pc = 0x8265FEB8; continue 'dispatch;
	}
	// 8265FEB4: 4BC609DD  bl 0x822c0890
	ctx.lr = 0x8265FEB8;
	sub_822C0890(ctx, base);
	// 8265FEB8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 8265FEBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8265FEC0: 419A0008  beq cr6, 0x8265fec8
	if ctx.cr[6].eq {
	pc = 0x8265FEC8; continue 'dispatch;
	}
	// 8265FEC4: 4BC609CD  bl 0x822c0890
	ctx.lr = 0x8265FEC8;
	sub_822C0890(ctx, base);
	// 8265FEC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265FECC: 4814778D  bl 0x827a7658
	ctx.lr = 0x8265FED0;
	sub_827A7658(ctx, base);
	// 8265FED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FED4: 4BCEF47D  bl 0x8234f350
	ctx.lr = 0x8265FED8;
	sub_8234F350(ctx, base);
	// 8265FED8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265FEDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FEE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FEE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265FEE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FEEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FEF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265FEF0 size=76
    let mut pc: u32 = 0x8265FEF0;
    'dispatch: loop {
        match pc {
            0x8265FEF0 => {
    //   block [0x8265FEF0..0x8265FF3C)
	// 8265FEF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FEF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8265FEF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8265FEFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8265FF00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FF08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8265FF0C: 4BFFFF4D  bl 0x8265fe58
	ctx.lr = 0x8265FF10;
	sub_8265FE58(ctx, base);
	// 8265FF10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8265FF14: 4182000C  beq 0x8265ff20
	if ctx.cr[0].eq {
	pc = 0x8265FF20; continue 'dispatch;
	}
	// 8265FF18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FF1C: 487924BD  bl 0x82df23d8
	ctx.lr = 0x8265FF20;
	sub_82DF23D8(ctx, base);
	// 8265FF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8265FF24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8265FF28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8265FF2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8265FF30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8265FF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8265FF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8265FF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8265FF40 size=752
    let mut pc: u32 = 0x8265FF40;
    'dispatch: loop {
        match pc {
            0x8265FF40 => {
    //   block [0x8265FF40..0x82660230)
	// 8265FF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8265FF44: 48B48221  bl 0x831a8164
	ctx.lr = 0x8265FF48;
	sub_831A8130(ctx, base);
	// 8265FF48: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8265FF4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8265FF50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8265FF54: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8265FF58: 4BEB1A81  bl 0x825119d8
	ctx.lr = 0x8265FF5C;
	sub_825119D8(ctx, base);
	// 8265FF5C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8265FF60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FF64: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8265FF68: 48793AA1  bl 0x82df3a08
	ctx.lr = 0x8265FF6C;
	sub_82DF3A08(ctx, base);
	// 8265FF6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8265FF70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8265FF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265FF78: 4BEA8809  bl 0x82508780
	ctx.lr = 0x8265FF7C;
	sub_82508780(ctx, base);
	// 8265FF7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8265FF80: 487934A9  bl 0x82df3428
	ctx.lr = 0x8265FF84;
	sub_82DF3428(ctx, base);
	// 8265FF84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8265FF88: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 8265FF8C: 409A0008  bne cr6, 0x8265ff94
	if !ctx.cr[6].eq {
	pc = 0x8265FF94; continue 'dispatch;
	}
	// 8265FF90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265FF94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8265FF98: 4BEA8809  bl 0x825087a0
	ctx.lr = 0x8265FF9C;
	sub_825087A0(ctx, base);
	// 8265FF9C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8265FFA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8265FFA4: 3BCBA0C0  addi r30, r11, -0x5f40
	ctx.r[30].s64 = ctx.r[11].s64 + -24384;
	// 8265FFA8: 38A00055  li r5, 0x55
	ctx.r[5].s64 = 85;
	// 8265FFAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8265FFB0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8265FFB4: 48792435  bl 0x82df23e8
	ctx.lr = 0x8265FFB8;
	sub_82DF23E8(ctx, base);
	// 8265FFB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8265FFBC: 41820010  beq 0x8265ffcc
	if ctx.cr[0].eq {
	pc = 0x8265FFCC; continue 'dispatch;
	}
	// 8265FFC0: 4BF2ACD9  bl 0x8258ac98
	ctx.lr = 0x8265FFC4;
	sub_8258AC98(ctx, base);
	// 8265FFC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8265FFC8: 48000008  b 0x8265ffd0
	pc = 0x8265FFD0; continue 'dispatch;
	// 8265FFCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8265FFD0: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 8265FFD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8265FFD8: 4BD73851  bl 0x823d3828
	ctx.lr = 0x8265FFDC;
	sub_823D3828(ctx, base);
	// 8265FFDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8265FFE0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8265FFE4: 839F00F8  lwz r28, 0xf8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 8265FFE8: 4BEB2131  bl 0x82512118
	ctx.lr = 0x8265FFEC;
	sub_82512118(ctx, base);
	// 8265FFEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8265FFF0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8265FFF4: 487B2E3D  bl 0x82e12e30
	ctx.lr = 0x8265FFF8;
	sub_82E12E30(ctx, base);
	// 8265FFF8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8265FFFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660000: 419A0008  beq cr6, 0x82660008
	if ctx.cr[6].eq {
	pc = 0x82660008; continue 'dispatch;
	}
	// 82660004: 4BC6088D  bl 0x822c0890
	ctx.lr = 0x82660008;
	sub_822C0890(ctx, base);
	// 82660008: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8266000C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660010: 487CAAD9  bl 0x82e2aae8
	ctx.lr = 0x82660014;
	sub_82E2AAE8(ctx, base);
	// 82660014: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82660018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266001C: 3B8B62D4  addi r28, r11, 0x62d4
	ctx.r[28].s64 = ctx.r[11].s64 + 25300;
	// 82660020: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82660024: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82660028: 7C8BE02E  lwzx r4, r11, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8266002C: 487939DD  bl 0x82df3a08
	ctx.lr = 0x82660030;
	sub_82DF3A08(ctx, base);
	// 82660030: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660034: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82660038: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8266003C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82660040: 487CEE31  bl 0x82e2ee70
	ctx.lr = 0x82660044;
	sub_82E2EE70(ctx, base);
	// 82660044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660048: 487933E1  bl 0x82df3428
	ctx.lr = 0x8266004C;
	sub_82DF3428(ctx, base);
	// 8266004C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82660050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660054: 419A009C  beq cr6, 0x826600f0
	if ctx.cr[6].eq {
	pc = 0x826600F0; continue 'dispatch;
	}
	// 82660058: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266005C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660060: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 82660064: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82660068: 48792381  bl 0x82df23e8
	ctx.lr = 0x8266006C;
	sub_82DF23E8(ctx, base);
	// 8266006C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82660070: 41820014  beq 0x82660084
	if ctx.cr[0].eq {
	pc = 0x82660084; continue 'dispatch;
	}
	// 82660074: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82660078: 487B6819  bl 0x82e16890
	ctx.lr = 0x8266007C;
	sub_82E16890(ctx, base);
	// 8266007C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82660080: 48000008  b 0x82660088
	pc = 0x82660088; continue 'dispatch;
	// 82660084: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82660088: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 8266008C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660090: 4BCFD2E1  bl 0x8235d370
	ctx.lr = 0x82660094;
	sub_8235D370(ctx, base);
	// 82660094: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82660098: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266009C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826600A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826600A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826600A8: 419A0024  beq cr6, 0x826600cc
	if ctx.cr[6].eq {
	pc = 0x826600CC; continue 'dispatch;
	}
	// 826600AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826600B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826600B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826600B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826600BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826600C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826600C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826600C8: 4082FFE8  bne 0x826600b0
	if !ctx.cr[0].eq {
	pc = 0x826600B0; continue 'dispatch;
	}
	// 826600CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826600D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826600D4: 487B4FDD  bl 0x82e150b0
	ctx.lr = 0x826600D8;
	sub_82E150B0(ctx, base);
	// 826600D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826600DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826600E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826600E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826600E8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826600EC: 4BEB0A6D  bl 0x82510b58
	ctx.lr = 0x826600F0;
	sub_82510B58(ctx, base);
	// 826600F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826600F4: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826600F8: 4BC87111  bl 0x822e7208
	ctx.lr = 0x826600FC;
	sub_822E7208(ctx, base);
	// 826600FC: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82660100: 397C000C  addi r11, r28, 0xc
	ctx.r[11].s64 = ctx.r[28].s64 + 12;
	// 82660104: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82660108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266010C: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82660110: 487938F9  bl 0x82df3a08
	ctx.lr = 0x82660114;
	sub_82DF3A08(ctx, base);
	// 82660114: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660118: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266011C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82660120: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82660124: 4BC8726D  bl 0x822e7390
	ctx.lr = 0x82660128;
	sub_822E7390(ctx, base);
	// 82660128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266012C: 487932FD  bl 0x82df3428
	ctx.lr = 0x82660130;
	sub_82DF3428(ctx, base);
	// 82660130: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82660134: 397C000C  addi r11, r28, 0xc
	ctx.r[11].s64 = ctx.r[28].s64 + 12;
	// 82660138: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8266013C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660140: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82660144: 487938C5  bl 0x82df3a08
	ctx.lr = 0x82660148;
	sub_82DF3A08(ctx, base);
	// 82660148: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 8266014C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82660150: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82660154: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82660158: 4BC8E581  bl 0x822ee6d8
	ctx.lr = 0x8266015C;
	sub_822EE6D8(ctx, base);
	// 8266015C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82660160: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 82660164: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82660168: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 8266016C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660170: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82660174: 4BC642ED  bl 0x822c4460
	ctx.lr = 0x82660178;
	sub_822C4460(ctx, base);
	// 82660178: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8266017C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660180: 419A0008  beq cr6, 0x82660188
	if ctx.cr[6].eq {
	pc = 0x82660188; continue 'dispatch;
	}
	// 82660184: 4BC6070D  bl 0x822c0890
	ctx.lr = 0x82660188;
	sub_822C0890(ctx, base);
	// 82660188: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266018C: 4879329D  bl 0x82df3428
	ctx.lr = 0x82660190;
	sub_82DF3428(ctx, base);
	// 82660190: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660194: 4BC8D2F5  bl 0x822ed488
	ctx.lr = 0x82660198;
	sub_822ED488(ctx, base);
	// 82660198: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266019C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826601A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826601A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826601A8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826601AC: 419A0024  beq cr6, 0x826601d0
	if ctx.cr[6].eq {
	pc = 0x826601D0; continue 'dispatch;
	}
	// 826601B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826601B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826601B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826601BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826601C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826601C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826601C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826601CC: 4082FFE8  bne 0x826601b4
	if !ctx.cr[0].eq {
	pc = 0x826601B4; continue 'dispatch;
	}
	// 826601D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826601D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826601D8: 4BC8DD89  bl 0x822edf60
	ctx.lr = 0x826601DC;
	sub_822EDF60(ctx, base);
	// 826601DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826601E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826601E4: 4BEB0B5D  bl 0x82510d40
	ctx.lr = 0x826601E8;
	sub_82510D40(ctx, base);
	// 826601E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826601EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826601F0: 808B6744  lwz r4, 0x6744(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26436 as u32) ) } as u64;
	// 826601F4: 4BE2F1AD  bl 0x8248f3a0
	ctx.lr = 0x826601F8;
	sub_8248F3A0(ctx, base);
	// 826601F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826601FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660200: 419A0008  beq cr6, 0x82660208
	if ctx.cr[6].eq {
	pc = 0x82660208; continue 'dispatch;
	}
	// 82660204: 4BC6068D  bl 0x822c0890
	ctx.lr = 0x82660208;
	sub_822C0890(ctx, base);
	// 82660208: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8266020C: 4BC87015  bl 0x822e7220
	ctx.lr = 0x82660210;
	sub_822E7220(ctx, base);
	// 82660210: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82660214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660218: 419A0008  beq cr6, 0x82660220
	if ctx.cr[6].eq {
	pc = 0x82660220; continue 'dispatch;
	}
	// 8266021C: 4BC60675  bl 0x822c0890
	ctx.lr = 0x82660220;
	sub_822C0890(ctx, base);
	// 82660220: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82660224: 487CA8DD  bl 0x82e2ab00
	ctx.lr = 0x82660228;
	sub_82E2AB00(ctx, base);
	// 82660228: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8266022C: 48B47F88  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82660230 size=388
    let mut pc: u32 = 0x82660230;
    'dispatch: loop {
        match pc {
            0x82660230 => {
    //   block [0x82660230..0x826603B4)
	// 82660230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660234: 48B47F35  bl 0x831a8168
	ctx.lr = 0x82660238;
	sub_831A8130(ctx, base);
	// 82660238: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266023C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82660240: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82660244: 3BFE00E8  addi r31, r30, 0xe8
	ctx.r[31].s64 = ctx.r[30].s64 + 232;
	// 82660248: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 8266024C: 817E00E8  lwz r11, 0xe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82660250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660254: 419A002C  beq cr6, 0x82660280
	if ctx.cr[6].eq {
	pc = 0x82660280; continue 'dispatch;
	}
	// 82660258: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8266025C: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82660260: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660264: 4BEAFF8D  bl 0x825101f0
	ctx.lr = 0x82660268;
	sub_825101F0(ctx, base);
	// 82660268: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 8266026C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82660270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660274: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82660278: 419A0008  beq cr6, 0x82660280
	if ctx.cr[6].eq {
	pc = 0x82660280; continue 'dispatch;
	}
	// 8266027C: 4BC60615  bl 0x822c0890
	ctx.lr = 0x82660280;
	sub_822C0890(ctx, base);
	// 82660280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82660284: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82660288: 4BEAF241  bl 0x8250f4c8
	ctx.lr = 0x8266028C;
	sub_8250F4C8(ctx, base);
	// 8266028C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660294: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82660298: 409A0008  bne cr6, 0x826602a0
	if !ctx.cr[6].eq {
	pc = 0x826602A0; continue 'dispatch;
	}
	// 8266029C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826602A0: 4BEA8289  bl 0x82508528
	ctx.lr = 0x826602A4;
	sub_82508528(ctx, base);
	// 826602A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826602A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826602AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826602B0: 487CA839  bl 0x82e2aae8
	ctx.lr = 0x826602B4;
	sub_82E2AAE8(ctx, base);
	// 826602B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826602B8: 487919D9  bl 0x82df1c90
	ctx.lr = 0x826602BC;
	sub_82DF1C90(ctx, base);
	// 826602BC: 815E0100  lwz r10, 0x100(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(256 as u32) ) } as u64;
	// 826602C0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826602C4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826602C8: 396B62D4  addi r11, r11, 0x62d4
	ctx.r[11].s64 = ctx.r[11].s64 + 25300;
	// 826602CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826602D0: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826602D4: 48793735  bl 0x82df3a08
	ctx.lr = 0x826602D8;
	sub_82DF3A08(ctx, base);
	// 826602D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826602DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826602E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826602E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826602E8: 487CEB89  bl 0x82e2ee70
	ctx.lr = 0x826602EC;
	sub_82E2EE70(ctx, base);
	// 826602EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826602F0: 48793139  bl 0x82df3428
	ctx.lr = 0x826602F4;
	sub_82DF3428(ctx, base);
	// 826602F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826602F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826602FC: 419A0098  beq cr6, 0x82660394
	if ctx.cr[6].eq {
	pc = 0x82660394; continue 'dispatch;
	}
	// 82660300: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660304: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660308: 388BA0C0  addi r4, r11, -0x5f40
	ctx.r[4].s64 = ctx.r[11].s64 + -24384;
	// 8266030C: 38A000B6  li r5, 0xb6
	ctx.r[5].s64 = 182;
	// 82660310: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82660314: 487920D5  bl 0x82df23e8
	ctx.lr = 0x82660318;
	sub_82DF23E8(ctx, base);
	// 82660318: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266031C: 41820014  beq 0x82660330
	if ctx.cr[0].eq {
	pc = 0x82660330; continue 'dispatch;
	}
	// 82660320: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82660324: 487B656D  bl 0x82e16890
	ctx.lr = 0x82660328;
	sub_82E16890(ctx, base);
	// 82660328: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266032C: 48000008  b 0x82660334
	pc = 0x82660334; continue 'dispatch;
	// 82660330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82660334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660338: 4BCFD039  bl 0x8235d370
	ctx.lr = 0x8266033C;
	sub_8235D370(ctx, base);
	// 8266033C: 817E00FC  lwz r11, 0xfc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 82660340: 815E00F8  lwz r10, 0xf8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 82660344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660348: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266034C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82660350: 419A0024  beq cr6, 0x82660374
	if ctx.cr[6].eq {
	pc = 0x82660374; continue 'dispatch;
	}
	// 82660354: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82660358: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8266035C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660360: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82660364: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82660368: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8266036C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660370: 4082FFE8  bne 0x82660358
	if !ctx.cr[0].eq {
	pc = 0x82660358; continue 'dispatch;
	}
	// 82660374: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82660378: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266037C: 487B4D35  bl 0x82e150b0
	ctx.lr = 0x82660380;
	sub_82E150B0(ctx, base);
	// 82660380: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82660384: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660388: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 8266038C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660390: 4BEB07C9  bl 0x82510b58
	ctx.lr = 0x82660394;
	sub_82510B58(ctx, base);
	// 82660394: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82660398: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266039C: 419A0008  beq cr6, 0x826603a4
	if ctx.cr[6].eq {
	pc = 0x826603A4; continue 'dispatch;
	}
	// 826603A0: 4BC604F1  bl 0x822c0890
	ctx.lr = 0x826603A4;
	sub_822C0890(ctx, base);
	// 826603A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826603A8: 487CA759  bl 0x82e2ab00
	ctx.lr = 0x826603AC;
	sub_82E2AB00(ctx, base);
	// 826603AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826603B0: 48B47E08  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826603B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826603B8 size=104
    let mut pc: u32 = 0x826603B8;
    'dispatch: loop {
        match pc {
            0x826603B8 => {
    //   block [0x826603B8..0x82660420)
	// 826603B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826603BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826603C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826603C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826603C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826603CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826603D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826603D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826603D8: 4BEAF0F1  bl 0x8250f4c8
	ctx.lr = 0x826603DC;
	sub_8250F4C8(ctx, base);
	// 826603DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826603E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826603E4: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 826603E8: 409A0008  bne cr6, 0x826603f0
	if !ctx.cr[6].eq {
	pc = 0x826603F0; continue 'dispatch;
	}
	// 826603EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826603F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826603F4: 4879189D  bl 0x82df1c90
	ctx.lr = 0x826603F8;
	sub_82DF1C90(ctx, base);
	// 826603F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826603FC: 419A000C  beq cr6, 0x82660408
	if ctx.cr[6].eq {
	pc = 0x82660408; continue 'dispatch;
	}
	// 82660400: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660404: 4BFFFE2D  bl 0x82660230
	ctx.lr = 0x82660408;
	sub_82660230(ctx, base);
	// 82660408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266040C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82660410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82660414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82660418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266041C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82660420 size=424
    let mut pc: u32 = 0x82660420;
    'dispatch: loop {
        match pc {
            0x82660420 => {
    //   block [0x82660420..0x826605C8)
	// 82660420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660424: 48B47D41  bl 0x831a8164
	ctx.lr = 0x82660428;
	sub_831A8130(ctx, base);
	// 82660428: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266042C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660430: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82660434: 3BCBA0C0  addi r30, r11, -0x5f40
	ctx.r[30].s64 = ctx.r[11].s64 + -24384;
	// 82660438: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8266043C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660440: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82660444: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82660448: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266044C: 3860010C  li r3, 0x10c
	ctx.r[3].s64 = 268;
	// 82660450: 48791F99  bl 0x82df23e8
	ctx.lr = 0x82660454;
	sub_82DF23E8(ctx, base);
	// 82660454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82660458: 41820010  beq 0x82660468
	if ctx.cr[0].eq {
	pc = 0x82660468; continue 'dispatch;
	}
	// 8266045C: 4BFFF94D  bl 0x8265fda8
	ctx.lr = 0x82660460;
	sub_8265FDA8(ctx, base);
	// 82660460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660464: 48000008  b 0x8266046c
	pc = 0x8266046C; continue 'dispatch;
	// 82660468: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266046C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82660470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82660478: 4BFFF821  bl 0x8265fc98
	ctx.lr = 0x8266047C;
	sub_8265FC98(ctx, base);
	// 8266047C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660484: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82660488: 4BC5FB79  bl 0x822c0000
	ctx.lr = 0x8266048C;
	sub_822C0000(ctx, base);
	// 8266048C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82660490: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660494: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 82660498: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8266049C: 4BC5FF3D  bl 0x822c03d8
	ctx.lr = 0x826604A0;
	sub_822C03D8(ctx, base);
	// 826604A0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826604A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826604A8: 418200B4  beq 0x8266055c
	if ctx.cr[0].eq {
	pc = 0x8266055C; continue 'dispatch;
	}
	// 826604AC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826604B0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826604B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826604B8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826604BC: 409A0008  bne cr6, 0x826604c4
	if !ctx.cr[6].eq {
	pc = 0x826604C4; continue 'dispatch;
	}
	// 826604C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826604C4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826604C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826604CC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826604D0: 419A0024  beq cr6, 0x826604f4
	if ctx.cr[6].eq {
	pc = 0x826604F4; continue 'dispatch;
	}
	// 826604D4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826604D8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826604DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826604E0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826604E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826604E8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826604EC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826604F0: 4082FFE8  bne 0x826604d8
	if !ctx.cr[0].eq {
	pc = 0x826604D8; continue 'dispatch;
	}
	// 826604F4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826604F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826604FC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82660500: 419A0024  beq cr6, 0x82660524
	if ctx.cr[6].eq {
	pc = 0x82660524; continue 'dispatch;
	}
	// 82660504: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82660508: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8266050C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660510: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82660514: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82660518: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8266051C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660520: 4082FFE8  bne 0x82660508
	if !ctx.cr[0].eq {
	pc = 0x82660508; continue 'dispatch;
	}
	// 82660524: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82660528: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8266052C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82660530: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82660534: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82660538: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266053C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82660540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82660544: 481389ED  bl 0x82798f30
	ctx.lr = 0x82660548;
	sub_82798F30(ctx, base);
	// 82660548: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266054C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660550: 4813B119  bl 0x8279b668
	ctx.lr = 0x82660554;
	sub_8279B668(ctx, base);
	// 82660554: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660558: 48000008  b 0x82660560
	pc = 0x82660560; continue 'dispatch;
	// 8266055C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82660560: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82660564: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82660568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266056C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660570: 4BF376E1  bl 0x82597c50
	ctx.lr = 0x82660574;
	sub_82597C50(ctx, base);
	// 82660574: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660578: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266057C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660580: 4BC5FA81  bl 0x822c0000
	ctx.lr = 0x82660584;
	sub_822C0000(ctx, base);
	// 82660584: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82660588: 41820024  beq 0x826605ac
	if ctx.cr[0].eq {
	pc = 0x826605AC; continue 'dispatch;
	}
	// 8266058C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82660590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660594: 419A0008  beq cr6, 0x8266059c
	if ctx.cr[6].eq {
	pc = 0x8266059C; continue 'dispatch;
	}
	// 82660598: 4BC602F9  bl 0x822c0890
	ctx.lr = 0x8266059C;
	sub_822C0890(ctx, base);
	// 8266059C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826605A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826605A4: 419A0008  beq cr6, 0x826605ac
	if ctx.cr[6].eq {
	pc = 0x826605AC; continue 'dispatch;
	}
	// 826605A8: 4BC602E9  bl 0x822c0890
	ctx.lr = 0x826605AC;
	sub_822C0890(ctx, base);
	// 826605AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826605B0: 419A000C  beq cr6, 0x826605bc
	if ctx.cr[6].eq {
	pc = 0x826605BC; continue 'dispatch;
	}
	// 826605B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826605B8: 4BC602D9  bl 0x822c0890
	ctx.lr = 0x826605BC;
	sub_822C0890(ctx, base);
	// 826605BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826605C0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826605C4: 48B47BF0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826605C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826605C8 size=128
    let mut pc: u32 = 0x826605C8;
    'dispatch: loop {
        match pc {
            0x826605C8 => {
    //   block [0x826605C8..0x82660648)
	// 826605C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826605CC: 48B47BA1  bl 0x831a816c
	ctx.lr = 0x826605D0;
	sub_831A8130(ctx, base);
	// 826605D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826605D4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826605D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826605DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826605E0: 3BEB80E8  addi r31, r11, -0x7f18
	ctx.r[31].s64 = ctx.r[11].s64 + -32536;
	// 826605E4: 816A80F0  lwz r11, -0x7f10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32528 as u32) ) } as u64;
	// 826605E8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826605EC: 40820024  bne 0x82660610
	if !ctx.cr[0].eq {
	pc = 0x82660610; continue 'dispatch;
	}
	// 826605F0: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 826605F4: 3D008266  lis r8, -0x7d9a
	ctx.r[8].s64 = -2107244544;
	// 826605F8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826605FC: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 82660600: 3908FD60  addi r8, r8, -0x2a0
	ctx.r[8].s64 = ctx.r[8].s64 + -672;
	// 82660604: 916A80F0  stw r11, -0x7f10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32528 as u32), ctx.r[11].u32 ) };
	// 82660608: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8266060C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82660610: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82660614: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82660618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266061C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82660620: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82660624: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82660628: 4BFF3F99  bl 0x826545c0
	ctx.lr = 0x8266062C;
	sub_826545C0(ctx, base);
	// 8266062C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82660630: 4182000C  beq 0x8266063c
	if ctx.cr[0].eq {
	pc = 0x8266063C; continue 'dispatch;
	}
	// 82660634: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82660638: 48000008  b 0x82660640
	pc = 0x82660640; continue 'dispatch;
	// 8266063C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82660640: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82660644: 48B47B78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82660648 size=684
    let mut pc: u32 = 0x82660648;
    'dispatch: loop {
        match pc {
            0x82660648 => {
    //   block [0x82660648..0x826608F4)
	// 82660648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266064C: 48B47B19  bl 0x831a8164
	ctx.lr = 0x82660650;
	sub_831A8130(ctx, base);
	// 82660650: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660654: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82660658: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266065C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82660660: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82660664: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82660668: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266066C: 388BA0C0  addi r4, r11, -0x5f40
	ctx.r[4].s64 = ctx.r[11].s64 + -24384;
	// 82660670: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82660674: 38A00077  li r5, 0x77
	ctx.r[5].s64 = 119;
	// 82660678: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8266067C: 4BC5FD5D  bl 0x822c03d8
	ctx.lr = 0x82660680;
	sub_822C03D8(ctx, base);
	// 82660680: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82660684: 41820060  beq 0x826606e4
	if ctx.cr[0].eq {
	pc = 0x826606E4; continue 'dispatch;
	}
	// 82660688: 3D608266  lis r11, -0x7d9a
	ctx.r[11].s64 = -2107244544;
	// 8266068C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82660690: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82660694: 396B03B8  addi r11, r11, 0x3b8
	ctx.r[11].s64 = ctx.r[11].s64 + 952;
	// 82660698: 388AA168  addi r4, r10, -0x5e98
	ctx.r[4].s64 = ctx.r[10].s64 + -24216;
	// 8266069C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826606A0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826606A4: 48793365  bl 0x82df3a08
	ctx.lr = 0x826606A8;
	sub_82DF3A08(ctx, base);
	// 826606A8: 397EFF1C  addi r11, r30, -0xe4
	ctx.r[11].s64 = ctx.r[30].s64 + -228;
	// 826606AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826606B0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826606B4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826606B8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826606BC: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 826606C0: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 826606C4: 4BFFFF05  bl 0x826605c8
	ctx.lr = 0x826606C8;
	sub_826605C8(ctx, base);
	// 826606C8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826606CC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 826606D0: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 826606D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826606D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826606DC: 4BF4BAB5  bl 0x825ac190
	ctx.lr = 0x826606E0;
	sub_825AC190(ctx, base);
	// 826606E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826606E4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826606E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826606EC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826606F0: 4BE92CC9  bl 0x824f33b8
	ctx.lr = 0x826606F4;
	sub_824F33B8(ctx, base);
	// 826606F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826606F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826606FC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82660700: 4BC5F901  bl 0x822c0000
	ctx.lr = 0x82660704;
	sub_822C0000(ctx, base);
	// 82660704: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82660708: 4182000C  beq 0x82660714
	if ctx.cr[0].eq {
	pc = 0x82660714; continue 'dispatch;
	}
	// 8266070C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660710: 48792D19  bl 0x82df3428
	ctx.lr = 0x82660714;
	sub_82DF3428(ctx, base);
	// 82660714: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82660718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266071C: 388B7D90  addi r4, r11, 0x7d90
	ctx.r[4].s64 = ctx.r[11].s64 + 32144;
	// 82660720: 487932E9  bl 0x82df3a08
	ctx.lr = 0x82660724;
	sub_82DF3A08(ctx, base);
	// 82660724: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82660728: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266072C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82660730: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82660734: 4BF4B68D  bl 0x825abdc0
	ctx.lr = 0x82660738;
	sub_825ABDC0(ctx, base);
	// 82660738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266073C: 48792CED  bl 0x82df3428
	ctx.lr = 0x82660740;
	sub_82DF3428(ctx, base);
	// 82660740: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660748: 388BA160  addi r4, r11, -0x5ea0
	ctx.r[4].s64 = ctx.r[11].s64 + -24224;
	// 8266074C: 487932BD  bl 0x82df3a08
	ctx.lr = 0x82660750;
	sub_82DF3A08(ctx, base);
	// 82660750: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82660754: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82660758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266075C: 4BF4B665  bl 0x825abdc0
	ctx.lr = 0x82660760;
	sub_825ABDC0(ctx, base);
	// 82660760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660764: 48792CC5  bl 0x82df3428
	ctx.lr = 0x82660768;
	sub_82DF3428(ctx, base);
	// 82660768: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266076C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660770: 388BA158  addi r4, r11, -0x5ea8
	ctx.r[4].s64 = ctx.r[11].s64 + -24232;
	// 82660774: 48793295  bl 0x82df3a08
	ctx.lr = 0x82660778;
	sub_82DF3A08(ctx, base);
	// 82660778: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266077C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82660780: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82660784: 4BF4B63D  bl 0x825abdc0
	ctx.lr = 0x82660788;
	sub_825ABDC0(ctx, base);
	// 82660788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266078C: 48792C9D  bl 0x82df3428
	ctx.lr = 0x82660790;
	sub_82DF3428(ctx, base);
	// 82660790: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660798: 388BA14C  addi r4, r11, -0x5eb4
	ctx.r[4].s64 = ctx.r[11].s64 + -24244;
	// 8266079C: 4879326D  bl 0x82df3a08
	ctx.lr = 0x826607A0;
	sub_82DF3A08(ctx, base);
	// 826607A0: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826607A4: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826607A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826607AC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826607B0: 419A0024  beq cr6, 0x826607d4
	if ctx.cr[6].eq {
	pc = 0x826607D4; continue 'dispatch;
	}
	// 826607B4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826607B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826607BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826607C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826607C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826607C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826607CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826607D0: 4082FFE8  bne 0x826607b8
	if !ctx.cr[0].eq {
	pc = 0x826607B8; continue 'dispatch;
	}
	// 826607D4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826607D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826607DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826607E0: 4BF41931  bl 0x825a2110
	ctx.lr = 0x826607E4;
	sub_825A2110(ctx, base);
	// 826607E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826607E8: 48792C41  bl 0x82df3428
	ctx.lr = 0x826607EC;
	sub_82DF3428(ctx, base);
	// 826607EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826607F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826607F4: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826607F8: 48793211  bl 0x82df3a08
	ctx.lr = 0x826607FC;
	sub_82DF3A08(ctx, base);
	// 826607FC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660804: 388BA13C  addi r4, r11, -0x5ec4
	ctx.r[4].s64 = ctx.r[11].s64 + -24260;
	// 82660808: 48793201  bl 0x82df3a08
	ctx.lr = 0x8266080C;
	sub_82DF3A08(ctx, base);
	// 8266080C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82660810: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82660814: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82660818: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 8266081C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82660820: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82660824: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82660828: C04A9A8C  lfs f2, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8266082C: C02908A4  lfs f1, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82660830: 4BF42A79  bl 0x825a32a8
	ctx.lr = 0x82660834;
	sub_825A32A8(ctx, base);
	// 82660834: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82660838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266083C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82660840: 4BF40F31  bl 0x825a1770
	ctx.lr = 0x82660844;
	sub_825A1770(ctx, base);
	// 82660844: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82660848: 48792BE1  bl 0x82df3428
	ctx.lr = 0x8266084C;
	sub_82DF3428(ctx, base);
	// 8266084C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82660850: 4BC68469  bl 0x822c8cb8
	ctx.lr = 0x82660854;
	sub_822C8CB8(ctx, base);
	// 82660854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660858: 48792BD1  bl 0x82df3428
	ctx.lr = 0x8266085C;
	sub_82DF3428(ctx, base);
	// 8266085C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82660860: 48792BC9  bl 0x82df3428
	ctx.lr = 0x82660864;
	sub_82DF3428(ctx, base);
	// 82660864: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266086C: 388BA124  addi r4, r11, -0x5edc
	ctx.r[4].s64 = ctx.r[11].s64 + -24284;
	// 82660870: 48793199  bl 0x82df3a08
	ctx.lr = 0x82660874;
	sub_82DF3A08(ctx, base);
	// 82660874: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660878: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266087C: 388BA114  addi r4, r11, -0x5eec
	ctx.r[4].s64 = ctx.r[11].s64 + -24300;
	// 82660880: 48793189  bl 0x82df3a08
	ctx.lr = 0x82660884;
	sub_82DF3A08(ctx, base);
	// 82660884: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82660888: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8266088C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82660890: 38BE0024  addi r5, r30, 0x24
	ctx.r[5].s64 = ctx.r[30].s64 + 36;
	// 82660894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82660898: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 8266089C: C06B9450  lfs f3, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826608A0: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826608A4: C0290210  lfs f1, 0x210(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(528 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826608A8: 4BF42A01  bl 0x825a32a8
	ctx.lr = 0x826608AC;
	sub_825A32A8(ctx, base);
	// 826608AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826608B0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826608B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826608B8: 4BF40EB9  bl 0x825a1770
	ctx.lr = 0x826608BC;
	sub_825A1770(ctx, base);
	// 826608BC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826608C0: 48792B69  bl 0x82df3428
	ctx.lr = 0x826608C4;
	sub_82DF3428(ctx, base);
	// 826608C4: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826608C8: 4BC683F1  bl 0x822c8cb8
	ctx.lr = 0x826608CC;
	sub_822C8CB8(ctx, base);
	// 826608CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826608D0: 48792B59  bl 0x82df3428
	ctx.lr = 0x826608D4;
	sub_82DF3428(ctx, base);
	// 826608D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826608D8: 48792B51  bl 0x82df3428
	ctx.lr = 0x826608DC;
	sub_82DF3428(ctx, base);
	// 826608DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826608E0: 419A000C  beq cr6, 0x826608ec
	if ctx.cr[6].eq {
	pc = 0x826608EC; continue 'dispatch;
	}
	// 826608E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826608E8: 4BC5FFA9  bl 0x822c0890
	ctx.lr = 0x826608EC;
	sub_822C0890(ctx, base);
	// 826608EC: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826608F0: 48B478C4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826608F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826608F8 size=196
    let mut pc: u32 = 0x826608F8;
    'dispatch: loop {
        match pc {
            0x826608F8 => {
    //   block [0x826608F8..0x826609BC)
	// 826608F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826608FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82660900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82660904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82660908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266090C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82660910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82660914: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82660918: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266091C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660920: 4BC60019  bl 0x822c0938
	ctx.lr = 0x82660924;
	sub_822C0938(ctx, base);
	// 82660924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82660928: 41820028  beq 0x82660950
	if ctx.cr[0].eq {
	pc = 0x82660950; continue 'dispatch;
	}
	// 8266092C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660930: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82660934: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82660938: 392BA180  addi r9, r11, -0x5e80
	ctx.r[9].s64 = ctx.r[11].s64 + -24192;
	// 8266093C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82660940: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82660944: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82660948: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266094C: 48000008  b 0x82660954
	pc = 0x82660954; continue 'dispatch;
	// 82660950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82660954: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266095C: 409A0044  bne cr6, 0x826609a0
	if !ctx.cr[6].eq {
	pc = 0x826609A0; continue 'dispatch;
	}
	// 82660960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82660964: 419A001C  beq cr6, 0x82660980
	if ctx.cr[6].eq {
	pc = 0x82660980; continue 'dispatch;
	}
	// 82660968: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266096C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82660970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660974: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266097C: 4E800421  bctrl
	ctx.lr = 0x82660980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82660980: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82660984: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82660988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266098C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82660990: 816B63EC  lwz r11, 0x63ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25580 as u32) ) } as u64;
	// 82660994: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82660998: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266099C: 4BC5F665  bl 0x822c0000
	ctx.lr = 0x826609A0;
	sub_822C0000(ctx, base);
	// 826609A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826609A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826609A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826609AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826609B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826609B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826609B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826609C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826609C0 size=196
    let mut pc: u32 = 0x826609C0;
    'dispatch: loop {
        match pc {
            0x826609C0 => {
    //   block [0x826609C0..0x82660A84)
	// 826609C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826609C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826609C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826609CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826609D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826609D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826609D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826609DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826609E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826609E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826609E8: 4BC5FF51  bl 0x822c0938
	ctx.lr = 0x826609EC;
	sub_822C0938(ctx, base);
	// 826609EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826609F0: 41820028  beq 0x82660a18
	if ctx.cr[0].eq {
	pc = 0x82660A18; continue 'dispatch;
	}
	// 826609F4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826609F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826609FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82660A00: 392BA194  addi r9, r11, -0x5e6c
	ctx.r[9].s64 = ctx.r[11].s64 + -24172;
	// 82660A04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82660A08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82660A0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82660A10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82660A14: 48000008  b 0x82660a1c
	pc = 0x82660A1C; continue 'dispatch;
	// 82660A18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82660A1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660A24: 409A0044  bne cr6, 0x82660a68
	if !ctx.cr[6].eq {
	pc = 0x82660A68; continue 'dispatch;
	}
	// 82660A28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82660A2C: 419A001C  beq cr6, 0x82660a48
	if ctx.cr[6].eq {
	pc = 0x82660A48; continue 'dispatch;
	}
	// 82660A30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660A34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82660A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660A3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82660A44: 4E800421  bctrl
	ctx.lr = 0x82660A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82660A48: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82660A4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82660A50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660A54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82660A58: 816B63EC  lwz r11, 0x63ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25580 as u32) ) } as u64;
	// 82660A5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82660A60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82660A64: 4BC5F59D  bl 0x822c0000
	ctx.lr = 0x82660A68;
	sub_822C0000(ctx, base);
	// 82660A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660A6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82660A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82660A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82660A78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82660A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82660A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82660A88 size=196
    let mut pc: u32 = 0x82660A88;
    'dispatch: loop {
        match pc {
            0x82660A88 => {
    //   block [0x82660A88..0x82660B4C)
	// 82660A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82660A90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82660A94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82660A98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660A9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82660AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82660AA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82660AA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82660AAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660AB0: 4BC5FE89  bl 0x822c0938
	ctx.lr = 0x82660AB4;
	sub_822C0938(ctx, base);
	// 82660AB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82660AB8: 41820028  beq 0x82660ae0
	if ctx.cr[0].eq {
	pc = 0x82660AE0; continue 'dispatch;
	}
	// 82660ABC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660AC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82660AC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82660AC8: 392BA1A8  addi r9, r11, -0x5e58
	ctx.r[9].s64 = ctx.r[11].s64 + -24152;
	// 82660ACC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82660AD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82660AD4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82660AD8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82660ADC: 48000008  b 0x82660ae4
	pc = 0x82660AE4; continue 'dispatch;
	// 82660AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82660AE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660AEC: 409A0044  bne cr6, 0x82660b30
	if !ctx.cr[6].eq {
	pc = 0x82660B30; continue 'dispatch;
	}
	// 82660AF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82660AF4: 419A001C  beq cr6, 0x82660b10
	if ctx.cr[6].eq {
	pc = 0x82660B10; continue 'dispatch;
	}
	// 82660AF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660AFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82660B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660B04: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660B08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82660B0C: 4E800421  bctrl
	ctx.lr = 0x82660B10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82660B10: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82660B14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82660B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82660B1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82660B20: 816B63EC  lwz r11, 0x63ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25580 as u32) ) } as u64;
	// 82660B24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82660B28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82660B2C: 4BC5F4D5  bl 0x822c0000
	ctx.lr = 0x82660B30;
	sub_822C0000(ctx, base);
	// 82660B30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660B34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82660B38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82660B3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82660B40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82660B44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82660B48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82660B50 size=124
    let mut pc: u32 = 0x82660B50;
    'dispatch: loop {
        match pc {
            0x82660B50 => {
    //   block [0x82660B50..0x82660BCC)
	// 82660B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660B54: 48B47619  bl 0x831a816c
	ctx.lr = 0x82660B58;
	sub_831A8130(ctx, base);
	// 82660B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660B5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82660B60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82660B64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660B68: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82660B6C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82660B70: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82660B74: 48791875  bl 0x82df23e8
	ctx.lr = 0x82660B78;
	sub_82DF23E8(ctx, base);
	// 82660B78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82660B7C: 4182001C  beq 0x82660b98
	if ctx.cr[0].eq {
	pc = 0x82660B98; continue 'dispatch;
	}
	// 82660B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660B84: 487F8AFD  bl 0x82e59680
	ctx.lr = 0x82660B88;
	sub_82E59680(ctx, base);
	// 82660B88: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660B8C: 396BA170  addi r11, r11, -0x5e90
	ctx.r[11].s64 = ctx.r[11].s64 + -24208;
	// 82660B90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660B94: 48000008  b 0x82660b9c
	pc = 0x82660B9C; continue 'dispatch;
	// 82660B98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82660B9C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82660BA0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82660BA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660BA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660BAC: 4BFFFE15  bl 0x826609c0
	ctx.lr = 0x82660BB0;
	sub_826609C0(ctx, base);
	// 82660BB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660BB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660BB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660BBC: 4BC5F445  bl 0x822c0000
	ctx.lr = 0x82660BC0;
	sub_822C0000(ctx, base);
	// 82660BC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82660BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82660BC8: 48B475F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82660BD0 size=124
    let mut pc: u32 = 0x82660BD0;
    'dispatch: loop {
        match pc {
            0x82660BD0 => {
    //   block [0x82660BD0..0x82660C4C)
	// 82660BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660BD4: 48B47599  bl 0x831a816c
	ctx.lr = 0x82660BD8;
	sub_831A8130(ctx, base);
	// 82660BD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660BDC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82660BE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82660BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660BE8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82660BEC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82660BF0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82660BF4: 487917F5  bl 0x82df23e8
	ctx.lr = 0x82660BF8;
	sub_82DF23E8(ctx, base);
	// 82660BF8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82660BFC: 4182001C  beq 0x82660c18
	if ctx.cr[0].eq {
	pc = 0x82660C18; continue 'dispatch;
	}
	// 82660C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660C04: 487F8A7D  bl 0x82e59680
	ctx.lr = 0x82660C08;
	sub_82E59680(ctx, base);
	// 82660C08: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660C0C: 396BA178  addi r11, r11, -0x5e88
	ctx.r[11].s64 = ctx.r[11].s64 + -24200;
	// 82660C10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82660C14: 48000008  b 0x82660c1c
	pc = 0x82660C1C; continue 'dispatch;
	// 82660C18: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82660C1C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82660C20: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82660C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660C28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660C2C: 4BFFFE5D  bl 0x82660a88
	ctx.lr = 0x82660C30;
	sub_82660A88(ctx, base);
	// 82660C30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660C34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660C38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660C3C: 4BC5F3C5  bl 0x822c0000
	ctx.lr = 0x82660C40;
	sub_822C0000(ctx, base);
	// 82660C40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82660C44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82660C48: 48B47574  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82660C50 size=124
    let mut pc: u32 = 0x82660C50;
    'dispatch: loop {
        match pc {
            0x82660C50 => {
    //   block [0x82660C50..0x82660CCC)
	// 82660C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660C54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82660C58: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82660C5C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660C60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660C64: 48035675  bl 0x826962d8
	ctx.lr = 0x82660C68;
	sub_826962D8(ctx, base);
	// 82660C68: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82660C6C: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 82660C70: 394AA21C  addi r10, r10, -0x5de4
	ctx.r[10].s64 = ctx.r[10].s64 + -24036;
	// 82660C74: 3929A208  addi r9, r9, -0x5df8
	ctx.r[9].s64 = ctx.r[9].s64 + -24056;
	// 82660C78: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 82660C7C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82660C80: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82660C84: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82660C88: 3908A1BC  addi r8, r8, -0x5e44
	ctx.r[8].s64 = ctx.r[8].s64 + -24132;
	// 82660C8C: 39400080  li r10, 0x80
	ctx.r[10].s64 = 128;
	// 82660C90: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82660C94: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82660C98: 911F00E8  stw r8, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 82660C9C: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82660CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660CA4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82660CA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82660CAC: 99210053  stb r9, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[9].u8 ) };
	// 82660CB0: 480345E1  bl 0x82695290
	ctx.lr = 0x82660CB4;
	sub_82695290(ctx, base);
	// 82660CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660CB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82660CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82660CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82660CC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82660CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82660CD0 size=184
    let mut pc: u32 = 0x82660CD0;
    'dispatch: loop {
        match pc {
            0x82660CD0 => {
    //   block [0x82660CD0..0x82660D88)
	// 82660CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82660CD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82660CDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82660CE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660CE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82660CEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82660CF0: 4BFFFE61  bl 0x82660b50
	ctx.lr = 0x82660CF4;
	sub_82660B50(ctx, base);
	// 82660CF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660CF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82660CFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82660D00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660D04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82660D08: 419A0024  beq cr6, 0x82660d2c
	if ctx.cr[6].eq {
	pc = 0x82660D2C; continue 'dispatch;
	}
	// 82660D0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82660D10: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82660D14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660D18: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82660D1C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82660D20: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82660D24: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660D28: 4082FFE8  bne 0x82660d10
	if !ctx.cr[0].eq {
	pc = 0x82660D10; continue 'dispatch;
	}
	// 82660D2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82660D30: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82660D34: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82660D38: 388AA268  addi r4, r10, -0x5d98
	ctx.r[4].s64 = ctx.r[10].s64 + -23960;
	// 82660D3C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82660D40: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 82660D44: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82660D48: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82660D4C: 487F7CF5  bl 0x82e58a40
	ctx.lr = 0x82660D50;
	sub_82E58A40(ctx, base);
	// 82660D50: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82660D54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660D58: 419A0008  beq cr6, 0x82660d60
	if ctx.cr[6].eq {
	pc = 0x82660D60; continue 'dispatch;
	}
	// 82660D5C: 4BC5FB35  bl 0x822c0890
	ctx.lr = 0x82660D60;
	sub_822C0890(ctx, base);
	// 82660D60: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82660D64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660D68: 419A0008  beq cr6, 0x82660d70
	if ctx.cr[6].eq {
	pc = 0x82660D70; continue 'dispatch;
	}
	// 82660D6C: 4BC5FB25  bl 0x822c0890
	ctx.lr = 0x82660D70;
	sub_822C0890(ctx, base);
	// 82660D70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82660D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82660D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82660D7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82660D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82660D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82660D88 size=184
    let mut pc: u32 = 0x82660D88;
    'dispatch: loop {
        match pc {
            0x82660D88 => {
    //   block [0x82660D88..0x82660E40)
	// 82660D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82660D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82660D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82660D98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660DA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82660DA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82660DA8: 4BFFFE29  bl 0x82660bd0
	ctx.lr = 0x82660DAC;
	sub_82660BD0(ctx, base);
	// 82660DAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82660DB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82660DB4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82660DB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82660DBC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82660DC0: 419A0024  beq cr6, 0x82660de4
	if ctx.cr[6].eq {
	pc = 0x82660DE4; continue 'dispatch;
	}
	// 82660DC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82660DC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82660DCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660DD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82660DD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82660DD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82660DDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660DE0: 4082FFE8  bne 0x82660dc8
	if !ctx.cr[0].eq {
	pc = 0x82660DC8; continue 'dispatch;
	}
	// 82660DE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82660DE8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82660DEC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82660DF0: 388AA268  addi r4, r10, -0x5d98
	ctx.r[4].s64 = ctx.r[10].s64 + -23960;
	// 82660DF4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82660DF8: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 82660DFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82660E00: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82660E04: 487F7C3D  bl 0x82e58a40
	ctx.lr = 0x82660E08;
	sub_82E58A40(ctx, base);
	// 82660E08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82660E0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660E10: 419A0008  beq cr6, 0x82660e18
	if ctx.cr[6].eq {
	pc = 0x82660E18; continue 'dispatch;
	}
	// 82660E14: 4BC5FA7D  bl 0x822c0890
	ctx.lr = 0x82660E18;
	sub_822C0890(ctx, base);
	// 82660E18: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82660E1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660E20: 419A0008  beq cr6, 0x82660e28
	if ctx.cr[6].eq {
	pc = 0x82660E28; continue 'dispatch;
	}
	// 82660E24: 4BC5FA6D  bl 0x822c0890
	ctx.lr = 0x82660E28;
	sub_822C0890(ctx, base);
	// 82660E28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82660E2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82660E30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82660E34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82660E38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82660E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82660E40 size=424
    let mut pc: u32 = 0x82660E40;
    'dispatch: loop {
        match pc {
            0x82660E40 => {
    //   block [0x82660E40..0x82660FE8)
	// 82660E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660E44: 48B47321  bl 0x831a8164
	ctx.lr = 0x82660E48;
	sub_831A8130(ctx, base);
	// 82660E48: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660E4C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82660E50: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82660E54: 3BCBA268  addi r30, r11, -0x5d98
	ctx.r[30].s64 = ctx.r[11].s64 + -23960;
	// 82660E58: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82660E5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660E60: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 82660E64: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82660E68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82660E6C: 38600138  li r3, 0x138
	ctx.r[3].s64 = 312;
	// 82660E70: 48791579  bl 0x82df23e8
	ctx.lr = 0x82660E74;
	sub_82DF23E8(ctx, base);
	// 82660E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82660E78: 41820010  beq 0x82660e88
	if ctx.cr[0].eq {
	pc = 0x82660E88; continue 'dispatch;
	}
	// 82660E7C: 4BFFFDD5  bl 0x82660c50
	ctx.lr = 0x82660E80;
	sub_82660C50(ctx, base);
	// 82660E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660E84: 48000008  b 0x82660e8c
	pc = 0x82660E8C; continue 'dispatch;
	// 82660E88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82660E8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82660E90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660E94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82660E98: 4BFFFA61  bl 0x826608f8
	ctx.lr = 0x82660E9C;
	sub_826608F8(ctx, base);
	// 82660E9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660EA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660EA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82660EA8: 4BC5F159  bl 0x822c0000
	ctx.lr = 0x82660EAC;
	sub_822C0000(ctx, base);
	// 82660EAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82660EB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82660EB4: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 82660EB8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82660EBC: 4BC5F51D  bl 0x822c03d8
	ctx.lr = 0x82660EC0;
	sub_822C03D8(ctx, base);
	// 82660EC0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82660EC4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82660EC8: 418200B4  beq 0x82660f7c
	if ctx.cr[0].eq {
	pc = 0x82660F7C; continue 'dispatch;
	}
	// 82660ECC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82660ED0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82660ED4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82660ED8: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82660EDC: 409A0008  bne cr6, 0x82660ee4
	if !ctx.cr[6].eq {
	pc = 0x82660EE4; continue 'dispatch;
	}
	// 82660EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82660EE4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82660EE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82660EEC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82660EF0: 419A0024  beq cr6, 0x82660f14
	if ctx.cr[6].eq {
	pc = 0x82660F14; continue 'dispatch;
	}
	// 82660EF4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82660EF8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82660EFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660F00: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82660F04: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82660F08: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82660F0C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660F10: 4082FFE8  bne 0x82660ef8
	if !ctx.cr[0].eq {
	pc = 0x82660EF8; continue 'dispatch;
	}
	// 82660F14: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82660F18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82660F1C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82660F20: 419A0024  beq cr6, 0x82660f44
	if ctx.cr[6].eq {
	pc = 0x82660F44; continue 'dispatch;
	}
	// 82660F24: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82660F28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82660F2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660F30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82660F34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82660F38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82660F3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82660F40: 4082FFE8  bne 0x82660f28
	if !ctx.cr[0].eq {
	pc = 0x82660F28; continue 'dispatch;
	}
	// 82660F44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82660F48: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82660F4C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82660F50: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82660F54: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82660F58: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82660F5C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82660F60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82660F64: 48137FCD  bl 0x82798f30
	ctx.lr = 0x82660F68;
	sub_82798F30(ctx, base);
	// 82660F68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82660F6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82660F70: 4813A6F9  bl 0x8279b668
	ctx.lr = 0x82660F74;
	sub_8279B668(ctx, base);
	// 82660F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82660F78: 48000008  b 0x82660f80
	pc = 0x82660F80; continue 'dispatch;
	// 82660F7C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82660F80: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82660F84: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82660F88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660F8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660F90: 4BF36CC1  bl 0x82597c50
	ctx.lr = 0x82660F94;
	sub_82597C50(ctx, base);
	// 82660F94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82660F98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82660F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82660FA0: 4BC5F061  bl 0x822c0000
	ctx.lr = 0x82660FA4;
	sub_822C0000(ctx, base);
	// 82660FA4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82660FA8: 41820024  beq 0x82660fcc
	if ctx.cr[0].eq {
	pc = 0x82660FCC; continue 'dispatch;
	}
	// 82660FAC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82660FB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660FB4: 419A0008  beq cr6, 0x82660fbc
	if ctx.cr[6].eq {
	pc = 0x82660FBC; continue 'dispatch;
	}
	// 82660FB8: 4BC5F8D9  bl 0x822c0890
	ctx.lr = 0x82660FBC;
	sub_822C0890(ctx, base);
	// 82660FBC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82660FC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82660FC4: 419A0008  beq cr6, 0x82660fcc
	if ctx.cr[6].eq {
	pc = 0x82660FCC; continue 'dispatch;
	}
	// 82660FC8: 4BC5F8C9  bl 0x822c0890
	ctx.lr = 0x82660FCC;
	sub_822C0890(ctx, base);
	// 82660FCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82660FD0: 419A000C  beq cr6, 0x82660fdc
	if ctx.cr[6].eq {
	pc = 0x82660FDC; continue 'dispatch;
	}
	// 82660FD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82660FD8: 4BC5F8B9  bl 0x822c0890
	ctx.lr = 0x82660FDC;
	sub_822C0890(ctx, base);
	// 82660FDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82660FE0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82660FE4: 48B471D0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82660FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82660FE8 size=196
    let mut pc: u32 = 0x82660FE8;
    'dispatch: loop {
        match pc {
            0x82660FE8 => {
    //   block [0x82660FE8..0x826610AC)
	// 82660FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82660FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82660FF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82660FF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82660FF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82660FFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82661000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661004: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82661008: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266100C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661010: 4BC5F929  bl 0x822c0938
	ctx.lr = 0x82661014;
	sub_822C0938(ctx, base);
	// 82661014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82661018: 41820028  beq 0x82661040
	if ctx.cr[0].eq {
	pc = 0x82661040; continue 'dispatch;
	}
	// 8266101C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82661020: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82661024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82661028: 392BA2C4  addi r9, r11, -0x5d3c
	ctx.r[9].s64 = ctx.r[11].s64 + -23868;
	// 8266102C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82661030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661034: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82661038: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266103C: 48000008  b 0x82661044
	pc = 0x82661044; continue 'dispatch;
	// 82661040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266104C: 409A0044  bne cr6, 0x82661090
	if !ctx.cr[6].eq {
	pc = 0x82661090; continue 'dispatch;
	}
	// 82661050: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82661054: 419A001C  beq cr6, 0x82661070
	if ctx.cr[6].eq {
	pc = 0x82661070; continue 'dispatch;
	}
	// 82661058: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266105C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82661060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661064: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266106C: 4E800421  bctrl
	ctx.lr = 0x82661070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82661070: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82661074: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82661078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266107C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82661080: 816B651C  lwz r11, 0x651c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25884 as u32) ) } as u64;
	// 82661084: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82661088: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266108C: 4BC5EF75  bl 0x822c0000
	ctx.lr = 0x82661090;
	sub_822C0000(ctx, base);
	// 82661090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661094: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266109C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826610A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826610A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826610A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826610B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826610B0 size=184
    let mut pc: u32 = 0x826610B0;
    'dispatch: loop {
        match pc {
            0x826610B0 => {
    //   block [0x826610B0..0x82661168)
	// 826610B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826610B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826610B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826610BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826610C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826610C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826610C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826610CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826610D0: 4BFFFA81  bl 0x82660b50
	ctx.lr = 0x826610D4;
	sub_82660B50(ctx, base);
	// 826610D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826610D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826610DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826610E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826610E4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826610E8: 419A0024  beq cr6, 0x8266110c
	if ctx.cr[6].eq {
	pc = 0x8266110C; continue 'dispatch;
	}
	// 826610EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826610F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826610F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826610F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826610FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82661100: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82661104: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82661108: 4082FFE8  bne 0x826610f0
	if !ctx.cr[0].eq {
	pc = 0x826610F0; continue 'dispatch;
	}
	// 8266110C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82661110: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82661114: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82661118: 388AA2D8  addi r4, r10, -0x5d28
	ctx.r[4].s64 = ctx.r[10].s64 + -23848;
	// 8266111C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82661120: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 82661124: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82661128: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8266112C: 487F7915  bl 0x82e58a40
	ctx.lr = 0x82661130;
	sub_82E58A40(ctx, base);
	// 82661130: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82661134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661138: 419A0008  beq cr6, 0x82661140
	if ctx.cr[6].eq {
	pc = 0x82661140; continue 'dispatch;
	}
	// 8266113C: 4BC5F755  bl 0x822c0890
	ctx.lr = 0x82661140;
	sub_822C0890(ctx, base);
	// 82661140: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82661144: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661148: 419A0008  beq cr6, 0x82661150
	if ctx.cr[6].eq {
	pc = 0x82661150; continue 'dispatch;
	}
	// 8266114C: 4BC5F745  bl 0x822c0890
	ctx.lr = 0x82661150;
	sub_822C0890(ctx, base);
	// 82661150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82661154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266115C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661168 size=184
    let mut pc: u32 = 0x82661168;
    'dispatch: loop {
        match pc {
            0x82661168 => {
    //   block [0x82661168..0x82661220)
	// 82661168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266116C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661178: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266117C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661180: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82661184: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82661188: 4BFFFA49  bl 0x82660bd0
	ctx.lr = 0x8266118C;
	sub_82660BD0(ctx, base);
	// 8266118C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661190: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82661194: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82661198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266119C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826611A0: 419A0024  beq cr6, 0x826611c4
	if ctx.cr[6].eq {
	pc = 0x826611C4; continue 'dispatch;
	}
	// 826611A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826611A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826611AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826611B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826611B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826611B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826611BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826611C0: 4082FFE8  bne 0x826611a8
	if !ctx.cr[0].eq {
	pc = 0x826611A8; continue 'dispatch;
	}
	// 826611C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826611C8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826611CC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826611D0: 388AA2D8  addi r4, r10, -0x5d28
	ctx.r[4].s64 = ctx.r[10].s64 + -23848;
	// 826611D4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826611D8: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 826611DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826611E0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826611E4: 487F785D  bl 0x82e58a40
	ctx.lr = 0x826611E8;
	sub_82E58A40(ctx, base);
	// 826611E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826611EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826611F0: 419A0008  beq cr6, 0x826611f8
	if ctx.cr[6].eq {
	pc = 0x826611F8; continue 'dispatch;
	}
	// 826611F4: 4BC5F69D  bl 0x822c0890
	ctx.lr = 0x826611F8;
	sub_822C0890(ctx, base);
	// 826611F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826611FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661200: 419A0008  beq cr6, 0x82661208
	if ctx.cr[6].eq {
	pc = 0x82661208; continue 'dispatch;
	}
	// 82661204: 4BC5F68D  bl 0x822c0890
	ctx.lr = 0x82661208;
	sub_822C0890(ctx, base);
	// 82661208: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8266120C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661210: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661214: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661218: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266121C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661220 size=220
    let mut pc: u32 = 0x82661220;
    'dispatch: loop {
        match pc {
            0x82661220 => {
    //   block [0x82661220..0x826612FC)
	// 82661220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661224: 48B46F45  bl 0x831a8168
	ctx.lr = 0x82661228;
	sub_831A8130(ctx, base);
	// 82661228: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266122C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661230: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82661234: 4803308D  bl 0x826942c0
	ctx.lr = 0x82661238;
	sub_826942C0(ctx, base);
	// 82661238: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266123C: 9BDF012C  stb r30, 0x12c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[30].u8 ) };
	// 82661240: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82661244: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 82661248: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 8266124C: 396BA3B4  addi r11, r11, -0x5c4c
	ctx.r[11].s64 = ctx.r[11].s64 + -23628;
	// 82661250: 394AA3A0  addi r10, r10, -0x5c60
	ctx.r[10].s64 = ctx.r[10].s64 + -23648;
	// 82661254: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 82661258: 3929A354  addi r9, r9, -0x5cac
	ctx.r[9].s64 = ctx.r[9].s64 + -23724;
	// 8266125C: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 82661260: 3B800080  li r28, 0x80
	ctx.r[28].s64 = 128;
	// 82661264: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661268: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8266126C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82661270: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 82661274: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82661278: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 8266127C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661280: 9BA10053  stb r29, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[29].u8 ) };
	// 82661284: 48032B85  bl 0x82693e08
	ctx.lr = 0x82661288;
	sub_82693E08(ctx, base);
	// 82661288: 9B810054  stb r28, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u8 ) };
	// 8266128C: 9BA10055  stb r29, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[29].u8 ) };
	// 82661290: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82661294: 9BC10056  stb r30, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[30].u8 ) };
	// 82661298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266129C: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 826612A0: 48032B91  bl 0x82693e30
	ctx.lr = 0x826612A4;
	sub_82693E30(ctx, base);
	// 826612A4: 897F012C  lbz r11, 0x12c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826612A8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826612AC: 40820010  bne 0x826612bc
	if !ctx.cr[0].eq {
	pc = 0x826612BC; continue 'dispatch;
	}
	// 826612B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826612B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826612B8: 48032BA9  bl 0x82693e60
	ctx.lr = 0x826612BC;
	sub_82693E60(ctx, base);
	// 826612BC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826612C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826612C4: 388BA334  addi r4, r11, -0x5ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -23756;
	// 826612C8: 4BC68029  bl 0x822c92f0
	ctx.lr = 0x826612CC;
	sub_822C92F0(ctx, base);
	// 826612CC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 826612D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826612D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826612D8: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 826612DC: 4BC67E55  bl 0x822c9130
	ctx.lr = 0x826612E0;
	sub_822C9130(ctx, base);
	// 826612E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826612E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826612E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826612EC: 4BC67B45  bl 0x822c8e30
	ctx.lr = 0x826612F0;
	sub_822C8E30(ctx, base);
	// 826612F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826612F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826612F8: 48B46EC0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661300 size=428
    let mut pc: u32 = 0x82661300;
    'dispatch: loop {
        match pc {
            0x82661300 => {
    //   block [0x82661300..0x826614AC)
	// 82661300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661304: 48B46E61  bl 0x831a8164
	ctx.lr = 0x82661308;
	sub_831A8130(ctx, base);
	// 82661308: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266130C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82661310: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82661314: 3BCBA2D8  addi r30, r11, -0x5d28
	ctx.r[30].s64 = ctx.r[11].s64 + -23848;
	// 82661318: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8266131C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82661320: 38A0001B  li r5, 0x1b
	ctx.r[5].s64 = 27;
	// 82661324: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82661328: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266132C: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 82661330: 487910B9  bl 0x82df23e8
	ctx.lr = 0x82661334;
	sub_82DF23E8(ctx, base);
	// 82661334: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82661338: 41820014  beq 0x8266134c
	if ctx.cr[0].eq {
	pc = 0x8266134C; continue 'dispatch;
	}
	// 8266133C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82661340: 4BFFFEE1  bl 0x82661220
	ctx.lr = 0x82661344;
	sub_82661220(ctx, base);
	// 82661344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661348: 48000008  b 0x82661350
	pc = 0x82661350; continue 'dispatch;
	// 8266134C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82661350: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82661354: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266135C: 4BFFFC8D  bl 0x82660fe8
	ctx.lr = 0x82661360;
	sub_82660FE8(ctx, base);
	// 82661360: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82661364: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661368: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266136C: 4BC5EC95  bl 0x822c0000
	ctx.lr = 0x82661370;
	sub_822C0000(ctx, base);
	// 82661370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82661374: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82661378: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 8266137C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82661380: 4BC5F059  bl 0x822c03d8
	ctx.lr = 0x82661384;
	sub_822C03D8(ctx, base);
	// 82661384: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82661388: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8266138C: 418200B4  beq 0x82661440
	if ctx.cr[0].eq {
	pc = 0x82661440; continue 'dispatch;
	}
	// 82661390: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82661394: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82661398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8266139C: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 826613A0: 409A0008  bne cr6, 0x826613a8
	if !ctx.cr[6].eq {
	pc = 0x826613A8; continue 'dispatch;
	}
	// 826613A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826613A8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826613AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826613B0: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826613B4: 419A0024  beq cr6, 0x826613d8
	if ctx.cr[6].eq {
	pc = 0x826613D8; continue 'dispatch;
	}
	// 826613B8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826613BC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826613C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826613C4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826613C8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826613CC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826613D0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826613D4: 4082FFE8  bne 0x826613bc
	if !ctx.cr[0].eq {
	pc = 0x826613BC; continue 'dispatch;
	}
	// 826613D8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826613DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826613E0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826613E4: 419A0024  beq cr6, 0x82661408
	if ctx.cr[6].eq {
	pc = 0x82661408; continue 'dispatch;
	}
	// 826613E8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826613EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826613F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826613F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826613F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826613FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82661400: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82661404: 4082FFE8  bne 0x826613ec
	if !ctx.cr[0].eq {
	pc = 0x826613EC; continue 'dispatch;
	}
	// 82661408: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266140C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82661410: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82661414: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82661418: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8266141C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82661420: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82661424: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82661428: 48137B09  bl 0x82798f30
	ctx.lr = 0x8266142C;
	sub_82798F30(ctx, base);
	// 8266142C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82661430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661434: 4813A235  bl 0x8279b668
	ctx.lr = 0x82661438;
	sub_8279B668(ctx, base);
	// 82661438: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266143C: 48000008  b 0x82661444
	pc = 0x82661444; continue 'dispatch;
	// 82661440: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82661444: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82661448: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8266144C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661454: 4BF367FD  bl 0x82597c50
	ctx.lr = 0x82661458;
	sub_82597C50(ctx, base);
	// 82661458: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266145C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661460: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661464: 4BC5EB9D  bl 0x822c0000
	ctx.lr = 0x82661468;
	sub_822C0000(ctx, base);
	// 82661468: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266146C: 41820024  beq 0x82661490
	if ctx.cr[0].eq {
	pc = 0x82661490; continue 'dispatch;
	}
	// 82661470: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82661474: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661478: 419A0008  beq cr6, 0x82661480
	if ctx.cr[6].eq {
	pc = 0x82661480; continue 'dispatch;
	}
	// 8266147C: 4BC5F415  bl 0x822c0890
	ctx.lr = 0x82661480;
	sub_822C0890(ctx, base);
	// 82661480: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82661484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661488: 419A0008  beq cr6, 0x82661490
	if ctx.cr[6].eq {
	pc = 0x82661490; continue 'dispatch;
	}
	// 8266148C: 4BC5F405  bl 0x822c0890
	ctx.lr = 0x82661490;
	sub_822C0890(ctx, base);
	// 82661490: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82661494: 419A000C  beq cr6, 0x826614a0
	if ctx.cr[6].eq {
	pc = 0x826614A0; continue 'dispatch;
	}
	// 82661498: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266149C: 4BC5F3F5  bl 0x822c0890
	ctx.lr = 0x826614A0;
	sub_822C0890(ctx, base);
	// 826614A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826614A4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826614A8: 48B46D0C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826614B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826614B0 size=480
    let mut pc: u32 = 0x826614B0;
    'dispatch: loop {
        match pc {
            0x826614B0 => {
    //   block [0x826614B0..0x82661690)
	// 826614B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826614B4: 48B46CB1  bl 0x831a8164
	ctx.lr = 0x826614B8;
	sub_831A8130(ctx, base);
	// 826614B8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826614BC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826614C0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826614C4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826614C8: 3BCBA2D8  addi r30, r11, -0x5d28
	ctx.r[30].s64 = ctx.r[11].s64 + -23848;
	// 826614CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826614D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826614D4: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 826614D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826614DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826614E0: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 826614E4: 48790F05  bl 0x82df23e8
	ctx.lr = 0x826614E8;
	sub_82DF23E8(ctx, base);
	// 826614E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826614EC: 41820014  beq 0x82661500
	if ctx.cr[0].eq {
	pc = 0x82661500; continue 'dispatch;
	}
	// 826614F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826614F4: 4BFFFD2D  bl 0x82661220
	ctx.lr = 0x826614F8;
	sub_82661220(ctx, base);
	// 826614F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826614FC: 48000008  b 0x82661504
	pc = 0x82661504; continue 'dispatch;
	// 82661500: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82661504: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82661508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266150C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82661510: 4BFFFAD9  bl 0x82660fe8
	ctx.lr = 0x82661514;
	sub_82660FE8(ctx, base);
	// 82661514: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82661518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266151C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82661520: 4BC5EAE1  bl 0x822c0000
	ctx.lr = 0x82661524;
	sub_822C0000(ctx, base);
	// 82661524: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82661528: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266152C: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 82661530: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82661534: 4BC5EEA5  bl 0x822c03d8
	ctx.lr = 0x82661538;
	sub_822C03D8(ctx, base);
	// 82661538: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8266153C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82661540: 418200E0  beq 0x82661620
	if ctx.cr[0].eq {
	pc = 0x82661620; continue 'dispatch;
	}
	// 82661544: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82661548: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8266154C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82661550: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82661554: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82661558: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8266155C: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82661560: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82661564: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82661568: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8266156C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82661570: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82661574: 409A0008  bne cr6, 0x8266157c
	if !ctx.cr[6].eq {
	pc = 0x8266157C; continue 'dispatch;
	}
	// 82661578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266157C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82661580: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82661584: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82661588: 419A0024  beq cr6, 0x826615ac
	if ctx.cr[6].eq {
	pc = 0x826615AC; continue 'dispatch;
	}
	// 8266158C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82661590: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82661594: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82661598: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8266159C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826615A0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826615A4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826615A8: 4082FFE8  bne 0x82661590
	if !ctx.cr[0].eq {
	pc = 0x82661590; continue 'dispatch;
	}
	// 826615AC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826615B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826615B4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826615B8: 419A0024  beq cr6, 0x826615dc
	if ctx.cr[6].eq {
	pc = 0x826615DC; continue 'dispatch;
	}
	// 826615BC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826615C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826615C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826615C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826615CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826615D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826615D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826615D8: 4082FFE8  bne 0x826615c0
	if !ctx.cr[0].eq {
	pc = 0x826615C0; continue 'dispatch;
	}
	// 826615DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 826615E0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826615E4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826615E8: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826615EC: 4881B655  bl 0x82e7cc40
	ctx.lr = 0x826615F0;
	sub_82E7CC40(ctx, base);
	// 826615F0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826615F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826615F8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826615FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82661600: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82661604: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82661608: 48137929  bl 0x82798f30
	ctx.lr = 0x8266160C;
	sub_82798F30(ctx, base);
	// 8266160C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82661610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661614: 4813A055  bl 0x8279b668
	ctx.lr = 0x82661618;
	sub_8279B668(ctx, base);
	// 82661618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266161C: 48000008  b 0x82661624
	pc = 0x82661624; continue 'dispatch;
	// 82661620: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82661624: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82661628: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8266162C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661634: 4BF3661D  bl 0x82597c50
	ctx.lr = 0x82661638;
	sub_82597C50(ctx, base);
	// 82661638: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266163C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661640: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661644: 4BC5E9BD  bl 0x822c0000
	ctx.lr = 0x82661648;
	sub_822C0000(ctx, base);
	// 82661648: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266164C: 41820024  beq 0x82661670
	if ctx.cr[0].eq {
	pc = 0x82661670; continue 'dispatch;
	}
	// 82661650: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82661654: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661658: 419A0008  beq cr6, 0x82661660
	if ctx.cr[6].eq {
	pc = 0x82661660; continue 'dispatch;
	}
	// 8266165C: 4BC5F235  bl 0x822c0890
	ctx.lr = 0x82661660;
	sub_822C0890(ctx, base);
	// 82661660: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82661664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82661668: 419A0008  beq cr6, 0x82661670
	if ctx.cr[6].eq {
	pc = 0x82661670; continue 'dispatch;
	}
	// 8266166C: 4BC5F225  bl 0x822c0890
	ctx.lr = 0x82661670;
	sub_822C0890(ctx, base);
	// 82661670: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82661674: 419A000C  beq cr6, 0x82661680
	if ctx.cr[6].eq {
	pc = 0x82661680; continue 'dispatch;
	}
	// 82661678: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266167C: 4BC5F215  bl 0x822c0890
	ctx.lr = 0x82661680;
	sub_822C0890(ctx, base);
	// 82661680: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82661684: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82661688: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8266168C: 48B46B28  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661690 size=72
    let mut pc: u32 = 0x82661690;
    'dispatch: loop {
        match pc {
            0x82661690 => {
    //   block [0x82661690..0x826616D8)
	// 82661690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266169C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826616A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826616A4: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 826616A8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 826616AC: 419A0010  beq cr6, 0x826616bc
	if ctx.cr[6].eq {
	pc = 0x826616BC; continue 'dispatch;
	}
	// 826616B0: 4BEB1459  bl 0x82512b08
	ctx.lr = 0x826616B4;
	sub_82512B08(ctx, base);
	// 826616B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826616B8: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 826616BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826616C0: 997F0194  stb r11, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u8 ) };
	// 826616C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826616C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826616CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826616D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826616D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826616D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826616D8 size=16
    let mut pc: u32 = 0x826616D8;
    'dispatch: loop {
        match pc {
            0x826616D8 => {
    //   block [0x826616D8..0x826616E8)
	// 826616D8: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826616DC: 816C0058  lwz r11, 0x58(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(88 as u32) ) } as u64;
	// 826616E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826616E4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826616E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826616E8 size=16
    let mut pc: u32 = 0x826616E8;
    'dispatch: loop {
        match pc {
            0x826616E8 => {
    //   block [0x826616E8..0x826616F8)
	// 826616E8: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826616EC: 816C003C  lwz r11, 0x3c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(60 as u32) ) } as u64;
	// 826616F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826616F4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826616F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826616F8 size=16
    let mut pc: u32 = 0x826616F8;
    'dispatch: loop {
        match pc {
            0x826616F8 => {
    //   block [0x826616F8..0x82661708)
	// 826616F8: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826616FC: 816C004C  lwz r11, 0x4c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(76 as u32) ) } as u64;
	// 82661700: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82661704: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82661708 size=16
    let mut pc: u32 = 0x82661708;
    'dispatch: loop {
        match pc {
            0x82661708 => {
    //   block [0x82661708..0x82661718)
	// 82661708: 81830000  lwz r12, 0(r3)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266170C: 816C005C  lwz r11, 0x5c(r12)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[12].u32.wrapping_add(92 as u32) ) } as u64;
	// 82661710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82661714: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661718 size=108
    let mut pc: u32 = 0x82661718;
    'dispatch: loop {
        match pc {
            0x82661718 => {
    //   block [0x82661718..0x82661784)
	// 82661718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266171C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661720: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661724: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266172C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661730: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82661734: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82661738: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266173C: 40820030  bne 0x8266176c
	if !ctx.cr[0].eq {
	pc = 0x8266176C; continue 'dispatch;
	}
	// 82661740: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82661744: 48008FA5  bl 0x8266a6e8
	ctx.lr = 0x82661748;
	sub_8266A6E8(ctx, base);
	// 82661748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266174C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82661750: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82661754: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 82661758: 38A00156  li r5, 0x156
	ctx.r[5].s64 = 342;
	// 8266175C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82661760: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82661764: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82661768: 487F7539  bl 0x82e58ca0
	ctx.lr = 0x8266176C;
	sub_82E58CA0(ctx, base);
	// 8266176C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661778: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266177C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661788 size=96
    let mut pc: u32 = 0x82661788;
    'dispatch: loop {
        match pc {
            0x82661788 => {
    //   block [0x82661788..0x826617E8)
	// 82661788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266178C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661790: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661794: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661798: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266179C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826617A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826617A4: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826617A8: 48008F41  bl 0x8266a6e8
	ctx.lr = 0x826617AC;
	sub_8266A6E8(ctx, base);
	// 826617AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826617B0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 826617B4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826617B8: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 826617BC: 38A00190  li r5, 0x190
	ctx.r[5].s64 = 400;
	// 826617C0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826617C4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826617C8: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 826617CC: 487F74D5  bl 0x82e58ca0
	ctx.lr = 0x826617D0;
	sub_82E58CA0(ctx, base);
	// 826617D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826617D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826617D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826617DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826617E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826617E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826617E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826617E8 size=64
    let mut pc: u32 = 0x826617E8;
    'dispatch: loop {
        match pc {
            0x826617E8 => {
    //   block [0x826617E8..0x82661828)
	// 826617E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826617EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826617F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826617F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826617F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826617FC: 8083018C  lwz r4, 0x18c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) } as u64;
	// 82661800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82661804: 48151A55  bl 0x827b3258
	ctx.lr = 0x82661808;
	sub_827B3258(ctx, base);
	// 82661808: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266180C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661828 size=96
    let mut pc: u32 = 0x82661828;
    'dispatch: loop {
        match pc {
            0x82661828 => {
    //   block [0x82661828..0x82661888)
	// 82661828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266182C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266183C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661840: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82661844: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82661848: 48008EA1  bl 0x8266a6e8
	ctx.lr = 0x8266184C;
	sub_8266A6E8(ctx, base);
	// 8266184C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82661850: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82661854: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82661858: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 8266185C: 38A0027B  li r5, 0x27b
	ctx.r[5].s64 = 635;
	// 82661860: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82661864: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82661868: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8266186C: 487F7435  bl 0x82e58ca0
	ctx.lr = 0x82661870;
	sub_82E58CA0(ctx, base);
	// 82661870: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266187C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661888 size=104
    let mut pc: u32 = 0x82661888;
    'dispatch: loop {
        match pc {
            0x82661888 => {
    //   block [0x82661888..0x826618F0)
	// 82661888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266188C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661894: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266189C: 897F0195  lbz r11, 0x195(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(405 as u32) ) } as u64;
	// 826618A0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826618A4: 41820038  beq 0x826618dc
	if ctx.cr[0].eq {
	pc = 0x826618DC; continue 'dispatch;
	}
	// 826618A8: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 826618AC: 4BC6E675  bl 0x822cff20
	ctx.lr = 0x826618B0;
	sub_822CFF20(ctx, base);
	// 826618B0: C01F0200  lfs f0, 0x200(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826618B4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826618B8: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 826618BC: C00B65D0  lfs f0, 0x65d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826618C0: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 826618C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826618C8: 40980014  bge cr6, 0x826618dc
	if !ctx.cr[6].lt {
	pc = 0x826618DC; continue 'dispatch;
	}
	// 826618CC: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826618D0: 480080A9  bl 0x82669978
	ctx.lr = 0x826618D4;
	sub_82669978(ctx, base);
	// 826618D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826618D8: 997F0195  stb r11, 0x195(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(405 as u32), ctx.r[11].u8 ) };
	// 826618DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826618E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826618E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826618E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826618EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826618F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826618F0 size=368
    let mut pc: u32 = 0x826618F0;
    'dispatch: loop {
        match pc {
            0x826618F0 => {
    //   block [0x826618F0..0x82661A60)
	// 826618F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826618F4: 48B46875  bl 0x831a8168
	ctx.lr = 0x826618F8;
	sub_831A8130(ctx, base);
	// 826618F8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 826618FC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661904: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 82661908: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266190C: 83DF018C  lwz r30, 0x18c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82661910: 48816C51  bl 0x82e78560
	ctx.lr = 0x82661914;
	sub_82E78560(ctx, base);
	// 82661914: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266191C: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82661920: 480091A1  bl 0x8266aac0
	ctx.lr = 0x82661924;
	sub_8266AAC0(ctx, base);
	// 82661924: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82661928: 83DF018C  lwz r30, 0x18c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8266192C: 48816C35  bl 0x82e78560
	ctx.lr = 0x82661930;
	sub_82E78560(ctx, base);
	// 82661930: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661938: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266193C: 48008EDD  bl 0x8266a818
	ctx.lr = 0x82661940;
	sub_8266A818(ctx, base);
	// 82661940: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661944: 4BEB01A5  bl 0x82511ae8
	ctx.lr = 0x82661948;
	sub_82511AE8(ctx, base);
	// 82661948: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266194C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82661950: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82661954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82661958: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82661A60 size=104
    let mut pc: u32 = 0x82661A60;
    'dispatch: loop {
        match pc {
            0x82661A60 => {
    //   block [0x82661A60..0x82661AC8)
	// 82661A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661A74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82661A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661A7C: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 82661A80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82661A84: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82661A88: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82661A8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82661A90: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82661A94: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82661A98: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82661A9C: 41990014  bgt cr6, 0x82661ab0
	if ctx.cr[6].gt {
	pc = 0x82661AB0; continue 'dispatch;
	}
	// 82661AA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82661AA4: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82661AA8: 4BE2D8F9  bl 0x8248f3a0
	ctx.lr = 0x82661AAC;
	sub_8248F3A0(ctx, base);
	// 82661AAC: 93DF01A0  stw r30, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[30].u32 ) };
	// 82661AB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661ABC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661AC8 size=88
    let mut pc: u32 = 0x82661AC8;
    'dispatch: loop {
        match pc {
            0x82661AC8 => {
    //   block [0x82661AC8..0x82661B20)
	// 82661AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661AD4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661ADC: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82661AE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82661AE4: 40990028  ble cr6, 0x82661b0c
	if !ctx.cr[6].gt {
	pc = 0x82661B0C; continue 'dispatch;
	}
	// 82661AE8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82661AEC: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82661AF0: 4082001C  bne 0x82661b0c
	if !ctx.cr[0].eq {
	pc = 0x82661B0C; continue 'dispatch;
	}
	// 82661AF4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82661AF8: 807F0170  lwz r3, 0x170(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 82661AFC: 808B670C  lwz r4, 0x670c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26380 as u32) ) } as u64;
	// 82661B00: 4BE2D8A1  bl 0x8248f3a0
	ctx.lr = 0x82661B04;
	sub_8248F3A0(ctx, base);
	// 82661B04: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82661B08: 917F01A0  stw r11, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82661B0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82661B10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661B14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661B20 size=68
    let mut pc: u32 = 0x82661B20;
    'dispatch: loop {
        match pc {
            0x82661B20 => {
    //   block [0x82661B20..0x82661B64)
	// 82661B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661B28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661B2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661B34: 809F022C  lwz r4, 0x22c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 82661B38: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82661B3C: 419A0014  beq cr6, 0x82661b50
	if ctx.cr[6].eq {
	pc = 0x82661B50; continue 'dispatch;
	}
	// 82661B40: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82661B44: 484E41E5  bl 0x82b45d28
	ctx.lr = 0x82661B48;
	sub_82B45D28(ctx, base);
	// 82661B48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661B4C: 917F022C  stw r11, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[11].u32 ) };
	// 82661B50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82661B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661B68 size=68
    let mut pc: u32 = 0x82661B68;
    'dispatch: loop {
        match pc {
            0x82661B68 => {
    //   block [0x82661B68..0x82661BAC)
	// 82661B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661B70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661B74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661B78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661B7C: 809F0228  lwz r4, 0x228(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82661B80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82661B84: 419A0014  beq cr6, 0x82661b98
	if ctx.cr[6].eq {
	pc = 0x82661B98; continue 'dispatch;
	}
	// 82661B88: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82661B8C: 484E419D  bl 0x82b45d28
	ctx.lr = 0x82661B90;
	sub_82B45D28(ctx, base);
	// 82661B90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661B94: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82661B98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82661B9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661BA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661BA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661BA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661BB0 size=108
    let mut pc: u32 = 0x82661BB0;
    'dispatch: loop {
        match pc {
            0x82661BB0 => {
    //   block [0x82661BB0..0x82661C1C)
	// 82661BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661BC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82661BCC: 809F0234  lwz r4, 0x234(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82661BD0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82661BD4: 419A0014  beq cr6, 0x82661be8
	if ctx.cr[6].eq {
	pc = 0x82661BE8; continue 'dispatch;
	}
	// 82661BD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82661BDC: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82661BE0: 4816DA31  bl 0x827cf610
	ctx.lr = 0x82661BE4;
	sub_827CF610(ctx, base);
	// 82661BE4: 93DF0234  stw r30, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[30].u32 ) };
	// 82661BE8: 809F0238  lwz r4, 0x238(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82661BEC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82661BF0: 419A0014  beq cr6, 0x82661c04
	if ctx.cr[6].eq {
	pc = 0x82661C04; continue 'dispatch;
	}
	// 82661BF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82661BF8: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82661BFC: 4816DA15  bl 0x827cf610
	ctx.lr = 0x82661C00;
	sub_827CF610(ctx, base);
	// 82661C00: 93DF0238  stw r30, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[30].u32 ) };
	// 82661C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661C10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661C20 size=60
    let mut pc: u32 = 0x82661C20;
    'dispatch: loop {
        match pc {
            0x82661C20 => {
    //   block [0x82661C20..0x82661C5C)
	// 82661C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661C24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661C28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661C2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661C30: 48AF29D1  bl 0x83154600
	ctx.lr = 0x82661C34;
	sub_83154600(ctx, base);
	// 82661C34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82661C38: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82661C3C: 48007D3D  bl 0x82669978
	ctx.lr = 0x82661C40;
	sub_82669978(ctx, base);
	// 82661C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661C44: 4BFFFF25  bl 0x82661b68
	ctx.lr = 0x82661C48;
	sub_82661B68(ctx, base);
	// 82661C48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82661C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661C54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661C60 size=40
    let mut pc: u32 = 0x82661C60;
    'dispatch: loop {
        match pc {
            0x82661C60 => {
    //   block [0x82661C60..0x82661C88)
	// 82661C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661C68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661C6C: 48AF2995  bl 0x83154600
	ctx.lr = 0x82661C70;
	sub_83154600(ctx, base);
	// 82661C70: 80630190  lwz r3, 0x190(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(400 as u32) ) } as u64;
	// 82661C74: 48007F75  bl 0x82669be8
	ctx.lr = 0x82661C78;
	sub_82669BE8(ctx, base);
	// 82661C78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82661C7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661C80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661C88 size=36
    let mut pc: u32 = 0x82661C88;
    'dispatch: loop {
        match pc {
            0x82661C88 => {
    //   block [0x82661C88..0x82661CAC)
	// 82661C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661C90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661C94: 48AF296D  bl 0x83154600
	ctx.lr = 0x82661C98;
	sub_83154600(ctx, base);
	// 82661C98: 4BEAE939  bl 0x825105d0
	ctx.lr = 0x82661C9C;
	sub_825105D0(ctx, base);
	// 82661C9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82661CA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661CA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661CB0 size=108
    let mut pc: u32 = 0x82661CB0;
    'dispatch: loop {
        match pc {
            0x82661CB0 => {
    //   block [0x82661CB0..0x82661D1C)
	// 82661CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661CB4: 48B464B9  bl 0x831a816c
	ctx.lr = 0x82661CB8;
	sub_831A8130(ctx, base);
	// 82661CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661CBC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82661CC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82661CC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82661CC8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82661CCC: 40820038  bne 0x82661d04
	if !ctx.cr[0].eq {
	pc = 0x82661D04; continue 'dispatch;
	}
	// 82661CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661CD4: 48B47CB5  bl 0x831a9988
	ctx.lr = 0x82661CD8;
	sub_831A9988(ctx, base);
	// 82661CD8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82661CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82661CE0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82661CE4: 48B46415  bl 0x831a80f8
	ctx.lr = 0x82661CE8;
	sub_831A80F8(ctx, base);
	// 82661CE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82661CEC: 41820018  beq 0x82661d04
	if ctx.cr[0].eq {
	pc = 0x82661D04; continue 'dispatch;
	}
	// 82661CF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661CF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82661CF8: 4820B8E9  bl 0x8286d5e0
	ctx.lr = 0x82661CFC;
	sub_8286D5E0(ctx, base);
	// 82661CFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82661D00: 48000014  b 0x82661d14
	pc = 0x82661D14; continue 'dispatch;
	// 82661D04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82661D08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82661D0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82661D10: 48B1C779  bl 0x8317e488
	ctx.lr = 0x82661D14;
	sub_8317E488(ctx, base);
	// 82661D14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661D18: 48B464A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661D20 size=196
    let mut pc: u32 = 0x82661D20;
    'dispatch: loop {
        match pc {
            0x82661D20 => {
    //   block [0x82661D20..0x82661DE4)
	// 82661D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661D34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82661D38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661D3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82661D40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82661D44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661D48: 4BC5EBF1  bl 0x822c0938
	ctx.lr = 0x82661D4C;
	sub_822C0938(ctx, base);
	// 82661D4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82661D50: 41820028  beq 0x82661d78
	if ctx.cr[0].eq {
	pc = 0x82661D78; continue 'dispatch;
	}
	// 82661D54: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82661D58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82661D5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82661D60: 392BA458  addi r9, r11, -0x5ba8
	ctx.r[9].s64 = ctx.r[11].s64 + -23464;
	// 82661D64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82661D68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661D6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82661D70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82661D74: 48000008  b 0x82661d7c
	pc = 0x82661D7C; continue 'dispatch;
	// 82661D78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661D7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82661D84: 409A0044  bne cr6, 0x82661dc8
	if !ctx.cr[6].eq {
	pc = 0x82661DC8; continue 'dispatch;
	}
	// 82661D88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82661D8C: 419A001C  beq cr6, 0x82661da8
	if ctx.cr[6].eq {
	pc = 0x82661DA8; continue 'dispatch;
	}
	// 82661D90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661D94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82661D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661D9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82661DA4: 4E800421  bctrl
	ctx.lr = 0x82661DA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82661DA8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82661DAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82661DB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82661DB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82661DB8: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 82661DBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82661DC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82661DC4: 4BC5E23D  bl 0x822c0000
	ctx.lr = 0x82661DC8;
	sub_822C0000(ctx, base);
	// 82661DC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661DCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661DD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661DD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661DD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661DE8 size=196
    let mut pc: u32 = 0x82661DE8;
    'dispatch: loop {
        match pc {
            0x82661DE8 => {
    //   block [0x82661DE8..0x82661EAC)
	// 82661DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661DFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82661E00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661E04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82661E08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82661E0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661E10: 4BC5EB29  bl 0x822c0938
	ctx.lr = 0x82661E14;
	sub_822C0938(ctx, base);
	// 82661E14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82661E18: 41820028  beq 0x82661e40
	if ctx.cr[0].eq {
	pc = 0x82661E40; continue 'dispatch;
	}
	// 82661E1C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82661E20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82661E24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82661E28: 392BA46C  addi r9, r11, -0x5b94
	ctx.r[9].s64 = ctx.r[11].s64 + -23444;
	// 82661E2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82661E30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661E34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82661E38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82661E3C: 48000008  b 0x82661e44
	pc = 0x82661E44; continue 'dispatch;
	// 82661E40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661E44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82661E4C: 409A0044  bne cr6, 0x82661e90
	if !ctx.cr[6].eq {
	pc = 0x82661E90; continue 'dispatch;
	}
	// 82661E50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82661E54: 419A001C  beq cr6, 0x82661e70
	if ctx.cr[6].eq {
	pc = 0x82661E70; continue 'dispatch;
	}
	// 82661E58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661E5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82661E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661E64: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661E68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82661E6C: 4E800421  bctrl
	ctx.lr = 0x82661E70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82661E70: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82661E74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82661E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82661E7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82661E80: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 82661E84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82661E88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82661E8C: 4BC5E175  bl 0x822c0000
	ctx.lr = 0x82661E90;
	sub_822C0000(ctx, base);
	// 82661E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661E94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661EA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661EA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661EB0 size=196
    let mut pc: u32 = 0x82661EB0;
    'dispatch: loop {
        match pc {
            0x82661EB0 => {
    //   block [0x82661EB0..0x82661F74)
	// 82661EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661EB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661EBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661EC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661EC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82661EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661ECC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82661ED0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82661ED4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661ED8: 4BC5EA61  bl 0x822c0938
	ctx.lr = 0x82661EDC;
	sub_822C0938(ctx, base);
	// 82661EDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82661EE0: 41820028  beq 0x82661f08
	if ctx.cr[0].eq {
	pc = 0x82661F08; continue 'dispatch;
	}
	// 82661EE4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82661EE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82661EEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82661EF0: 392BA480  addi r9, r11, -0x5b80
	ctx.r[9].s64 = ctx.r[11].s64 + -23424;
	// 82661EF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82661EF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661EFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82661F00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82661F04: 48000008  b 0x82661f0c
	pc = 0x82661F0C; continue 'dispatch;
	// 82661F08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661F0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82661F14: 409A0044  bne cr6, 0x82661f58
	if !ctx.cr[6].eq {
	pc = 0x82661F58; continue 'dispatch;
	}
	// 82661F18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82661F1C: 419A001C  beq cr6, 0x82661f38
	if ctx.cr[6].eq {
	pc = 0x82661F38; continue 'dispatch;
	}
	// 82661F20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661F24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82661F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661F2C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661F30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82661F34: 4E800421  bctrl
	ctx.lr = 0x82661F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82661F38: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82661F3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82661F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82661F44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82661F48: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 82661F4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82661F50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82661F54: 4BC5E0AD  bl 0x822c0000
	ctx.lr = 0x82661F58;
	sub_822C0000(ctx, base);
	// 82661F58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82661F5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82661F60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82661F64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82661F68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82661F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82661F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82661F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82661F78 size=196
    let mut pc: u32 = 0x82661F78;
    'dispatch: loop {
        match pc {
            0x82661F78 => {
    //   block [0x82661F78..0x8266203C)
	// 82661F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82661F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82661F80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82661F84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82661F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82661F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82661F90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661F94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82661F98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82661F9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661FA0: 4BC5E999  bl 0x822c0938
	ctx.lr = 0x82661FA4;
	sub_822C0938(ctx, base);
	// 82661FA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82661FA8: 41820028  beq 0x82661fd0
	if ctx.cr[0].eq {
	pc = 0x82661FD0; continue 'dispatch;
	}
	// 82661FAC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82661FB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82661FB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82661FB8: 392BA494  addi r9, r11, -0x5b6c
	ctx.r[9].s64 = ctx.r[11].s64 + -23404;
	// 82661FBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82661FC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82661FC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82661FC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82661FCC: 48000008  b 0x82661fd4
	pc = 0x82661FD4; continue 'dispatch;
	// 82661FD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82661FD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82661FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82661FDC: 409A0044  bne cr6, 0x82662020
	if !ctx.cr[6].eq {
	pc = 0x82662020; continue 'dispatch;
	}
	// 82661FE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82661FE4: 419A001C  beq cr6, 0x82662000
	if ctx.cr[6].eq {
	pc = 0x82662000; continue 'dispatch;
	}
	// 82661FE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661FEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82661FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82661FF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82661FF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82661FFC: 4E800421  bctrl
	ctx.lr = 0x82662000;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82662000: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82662004: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82662008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266200C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82662010: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 82662014: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82662018: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266201C: 4BC5DFE5  bl 0x822c0000
	ctx.lr = 0x82662020;
	sub_822C0000(ctx, base);
	// 82662020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82662024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82662028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266202C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82662030: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82662034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82662038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82662040 size=196
    let mut pc: u32 = 0x82662040;
    'dispatch: loop {
        match pc {
            0x82662040 => {
    //   block [0x82662040..0x82662104)
	// 82662040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82662048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266204C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82662050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82662058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266205C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82662060: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82662064: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662068: 4BC5E8D1  bl 0x822c0938
	ctx.lr = 0x8266206C;
	sub_822C0938(ctx, base);
	// 8266206C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662070: 41820028  beq 0x82662098
	if ctx.cr[0].eq {
	pc = 0x82662098; continue 'dispatch;
	}
	// 82662074: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662078: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266207C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82662080: 392BA4A8  addi r9, r11, -0x5b58
	ctx.r[9].s64 = ctx.r[11].s64 + -23384;
	// 82662084: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82662088: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266208C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82662090: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82662094: 48000008  b 0x8266209c
	pc = 0x8266209C; continue 'dispatch;
	// 82662098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266209C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826620A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826620A4: 409A0044  bne cr6, 0x826620e8
	if !ctx.cr[6].eq {
	pc = 0x826620E8; continue 'dispatch;
	}
	// 826620A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826620AC: 419A001C  beq cr6, 0x826620c8
	if ctx.cr[6].eq {
	pc = 0x826620C8; continue 'dispatch;
	}
	// 826620B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826620B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826620B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826620BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826620C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826620C4: 4E800421  bctrl
	ctx.lr = 0x826620C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826620C8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826620CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826620D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826620D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826620D8: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 826620DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826620E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826620E4: 4BC5DF1D  bl 0x822c0000
	ctx.lr = 0x826620E8;
	sub_822C0000(ctx, base);
	// 826620E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826620EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826620F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826620F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826620F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826620FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82662100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82662108 size=196
    let mut pc: u32 = 0x82662108;
    'dispatch: loop {
        match pc {
            0x82662108 => {
    //   block [0x82662108..0x826621CC)
	// 82662108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266210C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82662110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82662114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82662118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266211C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82662120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82662124: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82662128: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266212C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662130: 4BC5E809  bl 0x822c0938
	ctx.lr = 0x82662134;
	sub_822C0938(ctx, base);
	// 82662134: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662138: 41820028  beq 0x82662160
	if ctx.cr[0].eq {
	pc = 0x82662160; continue 'dispatch;
	}
	// 8266213C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662140: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82662144: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82662148: 392BA4BC  addi r9, r11, -0x5b44
	ctx.r[9].s64 = ctx.r[11].s64 + -23364;
	// 8266214C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82662150: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82662154: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82662158: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266215C: 48000008  b 0x82662164
	pc = 0x82662164; continue 'dispatch;
	// 82662160: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82662164: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266216C: 409A0044  bne cr6, 0x826621b0
	if !ctx.cr[6].eq {
	pc = 0x826621B0; continue 'dispatch;
	}
	// 82662170: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82662174: 419A001C  beq cr6, 0x82662190
	if ctx.cr[6].eq {
	pc = 0x82662190; continue 'dispatch;
	}
	// 82662178: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266217C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82662180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662184: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82662188: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266218C: 4E800421  bctrl
	ctx.lr = 0x82662190;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82662190: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82662194: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82662198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266219C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826621A0: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 826621A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826621A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826621AC: 4BC5DE55  bl 0x822c0000
	ctx.lr = 0x826621B0;
	sub_822C0000(ctx, base);
	// 826621B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826621B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826621B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826621BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826621C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826621C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826621C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826621D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826621D0 size=196
    let mut pc: u32 = 0x826621D0;
    'dispatch: loop {
        match pc {
            0x826621D0 => {
    //   block [0x826621D0..0x82662294)
	// 826621D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826621D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826621D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826621DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826621E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826621E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826621E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826621EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826621F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826621F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826621F8: 4BC5E741  bl 0x822c0938
	ctx.lr = 0x826621FC;
	sub_822C0938(ctx, base);
	// 826621FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662200: 41820028  beq 0x82662228
	if ctx.cr[0].eq {
	pc = 0x82662228; continue 'dispatch;
	}
	// 82662204: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662208: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266220C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82662210: 392BA4D0  addi r9, r11, -0x5b30
	ctx.r[9].s64 = ctx.r[11].s64 + -23344;
	// 82662214: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82662218: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266221C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82662220: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82662224: 48000008  b 0x8266222c
	pc = 0x8266222C; continue 'dispatch;
	// 82662228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266222C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82662234: 409A0044  bne cr6, 0x82662278
	if !ctx.cr[6].eq {
	pc = 0x82662278; continue 'dispatch;
	}
	// 82662238: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266223C: 419A001C  beq cr6, 0x82662258
	if ctx.cr[6].eq {
	pc = 0x82662258; continue 'dispatch;
	}
	// 82662240: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82662244: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82662248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266224C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82662250: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82662254: 4E800421  bctrl
	ctx.lr = 0x82662258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82662258: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266225C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82662260: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662264: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82662268: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 8266226C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82662270: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82662274: 4BC5DD8D  bl 0x822c0000
	ctx.lr = 0x82662278;
	sub_822C0000(ctx, base);
	// 82662278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266227C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82662280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82662284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82662288: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266228C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82662290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82662298 size=196
    let mut pc: u32 = 0x82662298;
    'dispatch: loop {
        match pc {
            0x82662298 => {
    //   block [0x82662298..0x8266235C)
	// 82662298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266229C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826622A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826622A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826622A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826622AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826622B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826622B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826622B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826622BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826622C0: 4BC5E679  bl 0x822c0938
	ctx.lr = 0x826622C4;
	sub_822C0938(ctx, base);
	// 826622C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826622C8: 41820028  beq 0x826622f0
	if ctx.cr[0].eq {
	pc = 0x826622F0; continue 'dispatch;
	}
	// 826622CC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826622D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826622D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826622D8: 392BA4E4  addi r9, r11, -0x5b1c
	ctx.r[9].s64 = ctx.r[11].s64 + -23324;
	// 826622DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826622E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826622E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826622E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826622EC: 48000008  b 0x826622f4
	pc = 0x826622F4; continue 'dispatch;
	// 826622F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826622F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826622F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826622FC: 409A0044  bne cr6, 0x82662340
	if !ctx.cr[6].eq {
	pc = 0x82662340; continue 'dispatch;
	}
	// 82662300: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82662304: 419A001C  beq cr6, 0x82662320
	if ctx.cr[6].eq {
	pc = 0x82662320; continue 'dispatch;
	}
	// 82662308: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266230C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82662310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662314: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82662318: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266231C: 4E800421  bctrl
	ctx.lr = 0x82662320;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82662320: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82662324: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82662328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266232C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82662330: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 82662334: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82662338: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266233C: 4BC5DCC5  bl 0x822c0000
	ctx.lr = 0x82662340;
	sub_822C0000(ctx, base);
	// 82662340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82662344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82662348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266234C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82662350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82662354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82662358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82662360 size=196
    let mut pc: u32 = 0x82662360;
    'dispatch: loop {
        match pc {
            0x82662360 => {
    //   block [0x82662360..0x82662424)
	// 82662360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82662368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266236C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82662370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82662378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266237C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82662380: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82662384: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662388: 4BC5E5B1  bl 0x822c0938
	ctx.lr = 0x8266238C;
	sub_822C0938(ctx, base);
	// 8266238C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662390: 41820028  beq 0x826623b8
	if ctx.cr[0].eq {
	pc = 0x826623B8; continue 'dispatch;
	}
	// 82662394: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662398: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266239C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826623A0: 392BA4F8  addi r9, r11, -0x5b08
	ctx.r[9].s64 = ctx.r[11].s64 + -23304;
	// 826623A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826623A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826623AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826623B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826623B4: 48000008  b 0x826623bc
	pc = 0x826623BC; continue 'dispatch;
	// 826623B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826623BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826623C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826623C4: 409A0044  bne cr6, 0x82662408
	if !ctx.cr[6].eq {
	pc = 0x82662408; continue 'dispatch;
	}
	// 826623C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826623CC: 419A001C  beq cr6, 0x826623e8
	if ctx.cr[6].eq {
	pc = 0x826623E8; continue 'dispatch;
	}
	// 826623D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826623D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826623D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826623DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826623E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826623E4: 4E800421  bctrl
	ctx.lr = 0x826623E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826623E8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826623EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826623F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826623F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826623F8: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 826623FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82662400: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82662404: 4BC5DBFD  bl 0x822c0000
	ctx.lr = 0x82662408;
	sub_822C0000(ctx, base);
	// 82662408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266240C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82662410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82662414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82662418: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266241C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82662420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82662428 size=196
    let mut pc: u32 = 0x82662428;
    'dispatch: loop {
        match pc {
            0x82662428 => {
    //   block [0x82662428..0x826624EC)
	// 82662428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266242C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82662430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82662434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82662438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266243C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82662440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82662444: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82662448: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266244C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662450: 4BC5E4E9  bl 0x822c0938
	ctx.lr = 0x82662454;
	sub_822C0938(ctx, base);
	// 82662454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662458: 41820028  beq 0x82662480
	if ctx.cr[0].eq {
	pc = 0x82662480; continue 'dispatch;
	}
	// 8266245C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662460: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82662464: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82662468: 392BA50C  addi r9, r11, -0x5af4
	ctx.r[9].s64 = ctx.r[11].s64 + -23284;
	// 8266246C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82662470: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82662474: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82662478: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266247C: 48000008  b 0x82662484
	pc = 0x82662484; continue 'dispatch;
	// 82662480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82662484: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82662488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266248C: 409A0044  bne cr6, 0x826624d0
	if !ctx.cr[6].eq {
	pc = 0x826624D0; continue 'dispatch;
	}
	// 82662490: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82662494: 419A001C  beq cr6, 0x826624b0
	if ctx.cr[6].eq {
	pc = 0x826624B0; continue 'dispatch;
	}
	// 82662498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266249C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826624A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826624A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826624A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826624AC: 4E800421  bctrl
	ctx.lr = 0x826624B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826624B0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826624B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826624B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826624BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826624C0: 816B65D4  lwz r11, 0x65d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26068 as u32) ) } as u64;
	// 826624C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826624C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826624CC: 4BC5DB35  bl 0x822c0000
	ctx.lr = 0x826624D0;
	sub_822C0000(ctx, base);
	// 826624D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826624D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826624D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826624DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826624E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826624E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826624E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826624F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826624F0 size=1320
    let mut pc: u32 = 0x826624F0;
    'dispatch: loop {
        match pc {
            0x826624F0 => {
    //   block [0x826624F0..0x82662A18)
	// 826624F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826624F4: 48B45C79  bl 0x831a816c
	ctx.lr = 0x826624F8;
	sub_831A8130(ctx, base);
	// 826624F8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 826624FC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82662500: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82662504: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 82662508: 48B48705  bl 0x831aac0c
	ctx.lr = 0x8266250C;
	sub_831AA9A0(ctx, base);
	// 8266250C: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662510: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82662514: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82662518: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266251C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82662520: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82662524: 40820228  bne 0x8266274c
	if !ctx.cr[0].eq {
	pc = 0x8266274C; continue 'dispatch;
	}
	// 82662528: 39610130  addi r11, r1, 0x130
	ctx.r[11].s64 = ctx.r[1].s64 + 304;
	// 8266252C: 13E028C7  vcmpequd (lvx128) v31, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82662530: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82662534: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82662A18 size=104
    let mut pc: u32 = 0x82662A18;
    'dispatch: loop {
        match pc {
            0x82662A18 => {
    //   block [0x82662A18..0x82662A80)
	// 82662A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82662A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82662A24: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662A28: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82662A30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662A34: 388BA610  addi r4, r11, -0x59f0
	ctx.r[4].s64 = ctx.r[11].s64 + -23024;
	// 82662A38: 48790FD1  bl 0x82df3a08
	ctx.lr = 0x82662A3C;
	sub_82DF3A08(ctx, base);
	// 82662A3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82662A40: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82662A44: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 82662A48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82662A4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82662A50: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82662A54: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82662A58: 487FBF09  bl 0x82e5e960
	ctx.lr = 0x82662A5C;
	sub_82E5E960(ctx, base);
	// 82662A5C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82662A60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82662A64: 419A0008  beq cr6, 0x82662a6c
	if ctx.cr[6].eq {
	pc = 0x82662A6C; continue 'dispatch;
	}
	// 82662A68: 4BC5DE29  bl 0x822c0890
	ctx.lr = 0x82662A6C;
	sub_822C0890(ctx, base);
	// 82662A6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82662A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82662A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82662A78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82662A7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82662A80 size=292
    let mut pc: u32 = 0x82662A80;
    'dispatch: loop {
        match pc {
            0x82662A80 => {
    //   block [0x82662A80..0x82662BA4)
	// 82662A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662A84: 48B456E9  bl 0x831a816c
	ctx.lr = 0x82662A88;
	sub_831A8130(ctx, base);
	// 82662A88: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82662A90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662A94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82662A98: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82662A9C: 481507BD  bl 0x827b3258
	ctx.lr = 0x82662AA0;
	sub_827B3258(ctx, base);
	// 82662AA0: 897E004A  lbz r11, 0x4a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(74 as u32) ) } as u64;
	// 82662AA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662AA8: 4182000C  beq 0x82662ab4
	if ctx.cr[0].eq {
	pc = 0x82662AB4; continue 'dispatch;
	}
	// 82662AAC: 389E0030  addi r4, r30, 0x30
	ctx.r[4].s64 = ctx.r[30].s64 + 48;
	// 82662AB0: 48000070  b 0x82662b20
	pc = 0x82662B20; continue 'dispatch;
	// 82662AB4: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 82662AB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82662ABC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82662AC0: 4881A991  bl 0x82e7d450
	ctx.lr = 0x82662AC4;
	sub_82E7D450(ctx, base);
	// 82662AC4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82662AC8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82662ACC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82662AD0: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82662AD4: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82662AD8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82662ADC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82662AE0: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82662AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82662BA8 size=380
    let mut pc: u32 = 0x82662BA8;
    'dispatch: loop {
        match pc {
            0x82662BA8 => {
    //   block [0x82662BA8..0x82662D24)
	// 82662BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662BAC: 48B455B1  bl 0x831a815c
	ctx.lr = 0x82662BB0;
	sub_831A8130(ctx, base);
	// 82662BB0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82662BB4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82662BBC: 897F0195  lbz r11, 0x195(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(405 as u32) ) } as u64;
	// 82662BC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662BC4: 41820154  beq 0x82662d18
	if ctx.cr[0].eq {
	pc = 0x82662D18; continue 'dispatch;
	}
	// 82662BC8: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 82662BCC: 83BF0154  lwz r29, 0x154(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82662BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82662BD4: 4881598D  bl 0x82e78560
	ctx.lr = 0x82662BD8;
	sub_82E78560(ctx, base);
	// 82662BD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82662BDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82662BE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82662BE4: C1AB0000  lfs f13, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82662BE8: C00A093C  lfs f0, 0x93c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82662BEC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82662BF0: 4BC6D311  bl 0x822cff00
	ctx.lr = 0x82662BF4;
	sub_822CFF00(ctx, base);
	// 82662BF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82662BF8: 83DF0154  lwz r30, 0x154(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82662BFC: 48815965  bl 0x82e78560
	ctx.lr = 0x82662C00;
	sub_82E78560(ctx, base);
	// 82662C00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82662C04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662C08: 4BEAEEE1  bl 0x82511ae8
	ctx.lr = 0x82662C0C;
	sub_82511AE8(ctx, base);
	// 82662C0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82662C10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82662C14: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82662C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82662C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82662C20: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82662C24: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82662C28: 4BC6E099  bl 0x822d0cc0
	ctx.lr = 0x82662C2C;
	sub_822D0CC0(ctx, base);
	// 82662C2C: 3BDF01F0  addi r30, r31, 0x1f0
	ctx.r[30].s64 = ctx.r[31].s64 + 496;
	// 82662C30: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82662C34: 3BBF01E0  addi r29, r31, 0x1e0
	ctx.r[29].s64 = ctx.r[31].s64 + 480;
	// 82662C38: 3B9F01D0  addi r28, r31, 0x1d0
	ctx.r[28].s64 = ctx.r[31].s64 + 464;
	// 82662C3C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82662C40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82662C44: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82662C48: 4BC6D411  bl 0x822d0058
	ctx.lr = 0x82662C4C;
	sub_822D0058(ctx, base);
	// 82662C4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82662C50: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82662C54: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82662C58: 3B6B28F0  addi r27, r11, 0x28f0
	ctx.r[27].s64 = ctx.r[11].s64 + 10480;
	// 82662C5C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82662C60: 3B400210  li r26, 0x210
	ctx.r[26].s64 = 528;
	// 82662C64: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82662D28 size=152
    let mut pc: u32 = 0x82662D28;
    'dispatch: loop {
        match pc {
            0x82662D28 => {
    //   block [0x82662D28..0x82662DC0)
	// 82662D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662D2C: 48B45439  bl 0x831a8164
	ctx.lr = 0x82662D30;
	sub_831A8130(ctx, base);
	// 82662D30: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82662D34: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82662D3C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82662D40: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82662D44: 83DF018C  lwz r30, 0x18c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82662D48: 48815819  bl 0x82e78560
	ctx.lr = 0x82662D4C;
	sub_82E78560(ctx, base);
	// 82662D4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82662D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82662D54: 48007955  bl 0x8266a6a8
	ctx.lr = 0x82662D58;
	sub_8266A6A8(ctx, base);
	// 82662D58: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82662D5C: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82662D60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662D64: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82662D68: 4BEAEDF1  bl 0x82511b58
	ctx.lr = 0x82662D6C;
	sub_82511B58(ctx, base);
	// 82662D6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82662D70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82662D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662D78: 481504E1  bl 0x827b3258
	ctx.lr = 0x82662D7C;
	sub_827B3258(ctx, base);
	// 82662D7C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82662D80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82662D84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82662D88: 48007A19  bl 0x8266a7a0
	ctx.lr = 0x82662D8C;
	sub_8266A7A0(ctx, base);
	// 82662D8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82662D90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82662D94: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82662D98: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82662D9C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82662DA0: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82662DA4: 4BFFF74D  bl 0x826624f0
	ctx.lr = 0x82662DA8;
	sub_826624F0(ctx, base);
	// 82662DA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82662DAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662DB0: 4BEAED41  bl 0x82511af0
	ctx.lr = 0x82662DB4;
	sub_82511AF0(ctx, base);
	// 82662DB4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82662DB8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82662DBC: 48B453F8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82662DC0 size=96
    let mut pc: u32 = 0x82662DC0;
    'dispatch: loop {
        match pc {
            0x82662DC0 => {
    //   block [0x82662DC0..0x82662E20)
	// 82662DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662DC4: 48B453A5  bl 0x831a8168
	ctx.lr = 0x82662DC8;
	sub_831A8130(ctx, base);
	// 82662DC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82662DD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82662DD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82662DD8: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82662DDC: 480078CD  bl 0x8266a6a8
	ctx.lr = 0x82662DE0;
	sub_8266A6A8(ctx, base);
	// 82662DE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82662DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662DE8: 4BEAED71  bl 0x82511b58
	ctx.lr = 0x82662DEC;
	sub_82511B58(ctx, base);
	// 82662DEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82662DF0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82662DF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82662DF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82662DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662E00: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82662E04: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82662E08: 4BFFF6E9  bl 0x826624f0
	ctx.lr = 0x82662E0C;
	sub_826624F0(ctx, base);
	// 82662E0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82662E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82662E14: 4BEAECDD  bl 0x82511af0
	ctx.lr = 0x82662E18;
	sub_82511AF0(ctx, base);
	// 82662E18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82662E1C: 48B4539C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82662E20 size=232
    let mut pc: u32 = 0x82662E20;
    'dispatch: loop {
        match pc {
            0x82662E20 => {
    //   block [0x82662E20..0x82662F08)
	// 82662E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82662E28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82662E2C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82662E30: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82662E34: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82662F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82662F08 size=332
    let mut pc: u32 = 0x82662F08;
    'dispatch: loop {
        match pc {
            0x82662F08 => {
    //   block [0x82662F08..0x82663054)
	// 82662F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82662F0C: 48B45261  bl 0x831a816c
	ctx.lr = 0x82662F10;
	sub_831A8130(ctx, base);
	// 82662F10: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82662F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82662F18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82662F1C: 4BFFEC4D  bl 0x82661b68
	ctx.lr = 0x82662F20;
	sub_82661B68(ctx, base);
	// 82662F20: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82662F24: 41820060  beq 0x82662f84
	if ctx.cr[0].eq {
	pc = 0x82662F84; continue 'dispatch;
	}
	// 82662F28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82662F2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662F30: 4BEAC599  bl 0x8250f4c8
	ctx.lr = 0x82662F34;
	sub_8250F4C8(ctx, base);
	// 82662F34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82662F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82662F3C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82662F40: 409A0008  bne cr6, 0x82662f48
	if !ctx.cr[6].eq {
	pc = 0x82662F48; continue 'dispatch;
	}
	// 82662F44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82662F48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82662F4C: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82662F50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82662F54: 4BEAF1C5  bl 0x82512118
	ctx.lr = 0x82662F58;
	sub_82512118(ctx, base);
	// 82662F58: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662F5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82662F60: 38ABA640  addi r5, r11, -0x59c0
	ctx.r[5].s64 = ctx.r[11].s64 + -22976;
	// 82662F64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82662F68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82662F6C: 484E3445  bl 0x82b463b0
	ctx.lr = 0x82662F70;
	sub_82B463B0(ctx, base);
	// 82662F70: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 82662F74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82662F78: 4878ED19  bl 0x82df1c90
	ctx.lr = 0x82662F7C;
	sub_82DF1C90(ctx, base);
	// 82662F7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82662F80: 480000C0  b 0x82663040
	pc = 0x82663040; continue 'dispatch;
	// 82662F84: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82662F88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82662F8C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82662F90: 4082005C  bne 0x82662fec
	if !ctx.cr[0].eq {
	pc = 0x82662FEC; continue 'dispatch;
	}
	// 82662F94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82662F98: 4BEAC531  bl 0x8250f4c8
	ctx.lr = 0x82662F9C;
	sub_8250F4C8(ctx, base);
	// 82662F9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82662FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82662FA4: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82662FA8: 409A0008  bne cr6, 0x82662fb0
	if !ctx.cr[6].eq {
	pc = 0x82662FB0; continue 'dispatch;
	}
	// 82662FAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82662FB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82662FB4: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82662FB8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82662FBC: 4BEAF15D  bl 0x82512118
	ctx.lr = 0x82662FC0;
	sub_82512118(ctx, base);
	// 82662FC0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82662FC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82662FC8: 38ABA62C  addi r5, r11, -0x59d4
	ctx.r[5].s64 = ctx.r[11].s64 + -22996;
	// 82662FCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82662FD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82662FD4: 484E33DD  bl 0x82b463b0
	ctx.lr = 0x82662FD8;
	sub_82B463B0(ctx, base);
	// 82662FD8: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 82662FDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82662FE0: 4878ECB1  bl 0x82df1c90
	ctx.lr = 0x82662FE4;
	sub_82DF1C90(ctx, base);
	// 82662FE4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82662FE8: 48000058  b 0x82663040
	pc = 0x82663040; continue 'dispatch;
	// 82662FEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82662FF0: 4BEAC4D9  bl 0x8250f4c8
	ctx.lr = 0x82662FF4;
	sub_8250F4C8(ctx, base);
	// 82662FF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82662FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82662FFC: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82663000: 409A0008  bne cr6, 0x82663008
	if !ctx.cr[6].eq {
	pc = 0x82663008; continue 'dispatch;
	}
	// 82663004: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82663008: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266300C: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82663010: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82663014: 4BEAF105  bl 0x82512118
	ctx.lr = 0x82663018;
	sub_82512118(ctx, base);
	// 82663018: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266301C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82663020: 38ABA618  addi r5, r11, -0x59e8
	ctx.r[5].s64 = ctx.r[11].s64 + -23016;
	// 82663024: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82663028: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266302C: 484E3385  bl 0x82b463b0
	ctx.lr = 0x82663030;
	sub_82B463B0(ctx, base);
	// 82663030: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 82663034: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82663038: 4878EC59  bl 0x82df1c90
	ctx.lr = 0x8266303C;
	sub_82DF1C90(ctx, base);
	// 8266303C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82663040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663044: 419A0008  beq cr6, 0x8266304c
	if ctx.cr[6].eq {
	pc = 0x8266304C; continue 'dispatch;
	}
	// 82663048: 4BC5D849  bl 0x822c0890
	ctx.lr = 0x8266304C;
	sub_822C0890(ctx, base);
	// 8266304C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82663050: 48B4516C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82663058 size=336
    let mut pc: u32 = 0x82663058;
    'dispatch: loop {
        match pc {
            0x82663058 => {
    //   block [0x82663058..0x826631A8)
	// 82663058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266305C: 48B45111  bl 0x831a816c
	ctx.lr = 0x82663060;
	sub_831A8130(ctx, base);
	// 82663060: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663068: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8266306C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82663070: 409A0130  bne cr6, 0x826631a0
	if !ctx.cr[6].eq {
	pc = 0x826631A0; continue 'dispatch;
	}
	// 82663074: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82663078: 41820060  beq 0x826630d8
	if ctx.cr[0].eq {
	pc = 0x826630D8; continue 'dispatch;
	}
	// 8266307C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82663080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663084: 4BEAC445  bl 0x8250f4c8
	ctx.lr = 0x82663088;
	sub_8250F4C8(ctx, base);
	// 82663088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266308C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82663090: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82663094: 409A0008  bne cr6, 0x8266309c
	if !ctx.cr[6].eq {
	pc = 0x8266309C; continue 'dispatch;
	}
	// 82663098: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8266309C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826630A0: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826630A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826630A8: 4BEAF071  bl 0x82512118
	ctx.lr = 0x826630AC;
	sub_82512118(ctx, base);
	// 826630AC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826630B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826630B4: 38ABA640  addi r5, r11, -0x59c0
	ctx.r[5].s64 = ctx.r[11].s64 + -22976;
	// 826630B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826630BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826630C0: 484E32F1  bl 0x82b463b0
	ctx.lr = 0x826630C4;
	sub_82B463B0(ctx, base);
	// 826630C4: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 826630C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826630CC: 4878EBC5  bl 0x82df1c90
	ctx.lr = 0x826630D0;
	sub_82DF1C90(ctx, base);
	// 826630D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826630D4: 480000C0  b 0x82663194
	pc = 0x82663194; continue 'dispatch;
	// 826630D8: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 826630DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826630E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826630E4: 4082005C  bne 0x82663140
	if !ctx.cr[0].eq {
	pc = 0x82663140; continue 'dispatch;
	}
	// 826630E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826630EC: 4BEAC3DD  bl 0x8250f4c8
	ctx.lr = 0x826630F0;
	sub_8250F4C8(ctx, base);
	// 826630F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826630F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826630F8: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826630FC: 409A0008  bne cr6, 0x82663104
	if !ctx.cr[6].eq {
	pc = 0x82663104; continue 'dispatch;
	}
	// 82663100: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82663104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82663108: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 8266310C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82663110: 4BEAF009  bl 0x82512118
	ctx.lr = 0x82663114;
	sub_82512118(ctx, base);
	// 82663114: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82663118: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8266311C: 38ABA62C  addi r5, r11, -0x59d4
	ctx.r[5].s64 = ctx.r[11].s64 + -22996;
	// 82663120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82663124: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82663128: 484E3289  bl 0x82b463b0
	ctx.lr = 0x8266312C;
	sub_82B463B0(ctx, base);
	// 8266312C: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 82663130: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82663134: 4878EB5D  bl 0x82df1c90
	ctx.lr = 0x82663138;
	sub_82DF1C90(ctx, base);
	// 82663138: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8266313C: 48000058  b 0x82663194
	pc = 0x82663194; continue 'dispatch;
	// 82663140: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82663144: 4BEAC385  bl 0x8250f4c8
	ctx.lr = 0x82663148;
	sub_8250F4C8(ctx, base);
	// 82663148: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266314C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82663150: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 82663154: 409A0008  bne cr6, 0x8266315c
	if !ctx.cr[6].eq {
	pc = 0x8266315C; continue 'dispatch;
	}
	// 82663158: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8266315C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82663160: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82663164: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82663168: 4BEAEFB1  bl 0x82512118
	ctx.lr = 0x8266316C;
	sub_82512118(ctx, base);
	// 8266316C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82663170: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82663174: 38ABA618  addi r5, r11, -0x59e8
	ctx.r[5].s64 = ctx.r[11].s64 + -23016;
	// 82663178: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266317C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82663180: 484E3231  bl 0x82b463b0
	ctx.lr = 0x82663184;
	sub_82B463B0(ctx, base);
	// 82663184: 907F0228  stw r3, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[3].u32 ) };
	// 82663188: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8266318C: 4878EB05  bl 0x82df1c90
	ctx.lr = 0x82663190;
	sub_82DF1C90(ctx, base);
	// 82663190: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82663194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663198: 419A0008  beq cr6, 0x826631a0
	if ctx.cr[6].eq {
	pc = 0x826631A0; continue 'dispatch;
	}
	// 8266319C: 4BC5D6F5  bl 0x822c0890
	ctx.lr = 0x826631A0;
	sub_822C0890(ctx, base);
	// 826631A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826631A4: 48B45018  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826631A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826631A8 size=140
    let mut pc: u32 = 0x826631A8;
    'dispatch: loop {
        match pc {
            0x826631A8 => {
    //   block [0x826631A8..0x82663234)
	// 826631A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826631AC: 48B44FC1  bl 0x831a816c
	ctx.lr = 0x826631B0;
	sub_831A8130(ctx, base);
	// 826631B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826631B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826631B8: 4BFFE969  bl 0x82661b20
	ctx.lr = 0x826631BC;
	sub_82661B20(ctx, base);
	// 826631BC: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 826631C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826631C4: 41820068  beq 0x8266322c
	if ctx.cr[0].eq {
	pc = 0x8266322C; continue 'dispatch;
	}
	// 826631C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826631CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826631D0: 4BEAC2F9  bl 0x8250f4c8
	ctx.lr = 0x826631D4;
	sub_8250F4C8(ctx, base);
	// 826631D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826631D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826631DC: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826631E0: 409A0008  bne cr6, 0x826631e8
	if !ctx.cr[6].eq {
	pc = 0x826631E8; continue 'dispatch;
	}
	// 826631E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826631E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826631EC: 83BF0224  lwz r29, 0x224(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826631F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826631F4: 4BEAEF25  bl 0x82512118
	ctx.lr = 0x826631F8;
	sub_82512118(ctx, base);
	// 826631F8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826631FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82663200: 38ABA658  addi r5, r11, -0x59a8
	ctx.r[5].s64 = ctx.r[11].s64 + -22952;
	// 82663204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82663208: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266320C: 484E31A5  bl 0x82b463b0
	ctx.lr = 0x82663210;
	sub_82B463B0(ctx, base);
	// 82663210: 907F022C  stw r3, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[3].u32 ) };
	// 82663214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663218: 4878EA79  bl 0x82df1c90
	ctx.lr = 0x8266321C;
	sub_82DF1C90(ctx, base);
	// 8266321C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82663220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663224: 419A0008  beq cr6, 0x8266322c
	if ctx.cr[6].eq {
	pc = 0x8266322C; continue 'dispatch;
	}
	// 82663228: 4BC5D669  bl 0x822c0890
	ctx.lr = 0x8266322C;
	sub_822C0890(ctx, base);
	// 8266322C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82663230: 48B44F8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663238 size=212
    let mut pc: u32 = 0x82663238;
    'dispatch: loop {
        match pc {
            0x82663238 => {
    //   block [0x82663238..0x8266330C)
	// 82663238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266323C: 48B44F31  bl 0x831a816c
	ctx.lr = 0x82663240;
	sub_831A8130(ctx, base);
	// 82663240: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82663244: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663248: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266324C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663250: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82663254: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82663258: D3FF00B0  stfs f31, 0xb0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8266325C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82663260: D3FF0088  stfs f31, 0x88(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82663264: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82663268: 997F006D  stb r11, 0x6d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(109 as u32), ctx.r[11].u8 ) };
	// 8266326C: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82663270: 48AF1391  bl 0x83154600
	ctx.lr = 0x82663274;
	sub_83154600(ctx, base);
	// 82663274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82663278: 4BEAE871  bl 0x82511ae8
	ctx.lr = 0x8266327C;
	sub_82511AE8(ctx, base);
	// 8266327C: 396000C0  li r11, 0xc0
	ctx.r[11].s64 = 192;
	// 82663280: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82663310 size=108
    let mut pc: u32 = 0x82663310;
    'dispatch: loop {
        match pc {
            0x82663310 => {
    //   block [0x82663310..0x8266337C)
	// 82663310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663314: 48B44E59  bl 0x831a816c
	ctx.lr = 0x82663318;
	sub_831A8130(ctx, base);
	// 82663318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266331C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82663320: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82663324: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82663328: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266332C: 40820038  bne 0x82663364
	if !ctx.cr[0].eq {
	pc = 0x82663364; continue 'dispatch;
	}
	// 82663330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82663334: 48B46655  bl 0x831a9988
	ctx.lr = 0x82663338;
	sub_831A9988(ctx, base);
	// 82663338: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266333C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82663340: 386B6AA8  addi r3, r11, 0x6aa8
	ctx.r[3].s64 = ctx.r[11].s64 + 27304;
	// 82663344: 48B44DB5  bl 0x831a80f8
	ctx.lr = 0x82663348;
	sub_831A80F8(ctx, base);
	// 82663348: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266334C: 41820018  beq 0x82663364
	if ctx.cr[0].eq {
	pc = 0x82663364; continue 'dispatch;
	}
	// 82663350: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82663354: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82663358: 4BFFE931  bl 0x82661c88
	ctx.lr = 0x8266335C;
	sub_82661C88(ctx, base);
	// 8266335C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82663360: 48000014  b 0x82663374
	pc = 0x82663374; continue 'dispatch;
	// 82663364: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82663368: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266336C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82663370: 48B1B119  bl 0x8317e488
	ctx.lr = 0x82663374;
	sub_8317E488(ctx, base);
	// 82663374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82663378: 48B44E44  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663380 size=216
    let mut pc: u32 = 0x82663380;
    'dispatch: loop {
        match pc {
            0x82663380 => {
    //   block [0x82663380..0x82663458)
	// 82663380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663384: 48B44DE5  bl 0x831a8168
	ctx.lr = 0x82663388;
	sub_831A8130(ctx, base);
	// 82663388: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266338C: 48AF1275  bl 0x83154600
	ctx.lr = 0x82663390;
	sub_83154600(ctx, base);
	// 82663390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663394: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82663398: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 8266339C: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826633A0: 4814FEB9  bl 0x827b3258
	ctx.lr = 0x826633A4;
	sub_827B3258(ctx, base);
	// 826633A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826633A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826633AC: 388BA68C  addi r4, r11, -0x5974
	ctx.r[4].s64 = ctx.r[11].s64 + -22900;
	// 826633B0: 48790659  bl 0x82df3a08
	ctx.lr = 0x826633B4;
	sub_82DF3A08(ctx, base);
	// 826633B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826633B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826633BC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826633C0: 83BF0230  lwz r29, 0x230(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826633C4: 4BEAED55  bl 0x82512118
	ctx.lr = 0x826633C8;
	sub_82512118(ctx, base);
	// 826633C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826633CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826633D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826633D4: 4BEAC0F5  bl 0x8250f4c8
	ctx.lr = 0x826633D8;
	sub_8250F4C8(ctx, base);
	// 826633D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826633DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826633E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826633E4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826633E8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826633EC: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 826633F0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826633F4: 4816BCD5  bl 0x827cf0c8
	ctx.lr = 0x826633F8;
	sub_827CF0C8(ctx, base);
	// 826633F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826633FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663400: 419A0008  beq cr6, 0x82663408
	if ctx.cr[6].eq {
	pc = 0x82663408; continue 'dispatch;
	}
	// 82663404: 4BC5D48D  bl 0x822c0890
	ctx.lr = 0x82663408;
	sub_822C0890(ctx, base);
	// 82663408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266340C: 4879001D  bl 0x82df3428
	ctx.lr = 0x82663410;
	sub_82DF3428(ctx, base);
	// 82663410: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82663414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82663418: 38ABA678  addi r5, r11, -0x5988
	ctx.r[5].s64 = ctx.r[11].s64 + -22920;
	// 8266341C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82663420: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82663424: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82663428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266342C: 4E800421  bctrl
	ctx.lr = 0x82663430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82663430: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82663434: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663438: 419A0008  beq cr6, 0x82663440
	if ctx.cr[6].eq {
	pc = 0x82663440; continue 'dispatch;
	}
	// 8266343C: 4BC5D455  bl 0x822c0890
	ctx.lr = 0x82663440;
	sub_822C0890(ctx, base);
	// 82663440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82663444: 4BFFE725  bl 0x82661b68
	ctx.lr = 0x82663448;
	sub_82661B68(ctx, base);
	// 82663448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266344C: 4BFFE765  bl 0x82661bb0
	ctx.lr = 0x82663450;
	sub_82661BB0(ctx, base);
	// 82663450: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82663454: 48B44D64  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82663458 size=88
    let mut pc: u32 = 0x82663458;
    'dispatch: loop {
        match pc {
            0x82663458 => {
    //   block [0x82663458..0x826634B0)
	// 82663458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266345C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663460: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663464: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266346C: 487F94BD  bl 0x82e5c928
	ctx.lr = 0x82663470;
	sub_82E5C928(ctx, base);
	// 82663470: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82663474: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82663478: 394AA69C  addi r10, r10, -0x5964
	ctx.r[10].s64 = ctx.r[10].s64 + -22884;
	// 8266347C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82663480: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82663484: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82663488: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8266348C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82663490: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82663494: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82663498: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 8266349C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826634A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826634A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826634A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826634AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826634B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826634B0 size=96
    let mut pc: u32 = 0x826634B0;
    'dispatch: loop {
        match pc {
            0x826634B0 => {
    //   block [0x826634B0..0x82663510)
	// 826634B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826634B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826634B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826634BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826634C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826634C4: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 826634C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826634CC: 419A0008  beq cr6, 0x826634d4
	if ctx.cr[6].eq {
	pc = 0x826634D4; continue 'dispatch;
	}
	// 826634D0: 4BC5D3C1  bl 0x822c0890
	ctx.lr = 0x826634D4;
	sub_822C0890(ctx, base);
	// 826634D4: 807F0090  lwz r3, 0x90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 826634D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826634DC: 419A0008  beq cr6, 0x826634e4
	if ctx.cr[6].eq {
	pc = 0x826634E4; continue 'dispatch;
	}
	// 826634E0: 4BC5D3B1  bl 0x822c0890
	ctx.lr = 0x826634E4;
	sub_822C0890(ctx, base);
	// 826634E4: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 826634E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826634EC: 419A0008  beq cr6, 0x826634f4
	if ctx.cr[6].eq {
	pc = 0x826634F4; continue 'dispatch;
	}
	// 826634F0: 4BC5D3A1  bl 0x822c0890
	ctx.lr = 0x826634F4;
	sub_822C0890(ctx, base);
	// 826634F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826634F8: 487F9091  bl 0x82e5c588
	ctx.lr = 0x826634FC;
	sub_82E5C588(ctx, base);
	// 826634FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82663500: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82663504: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82663508: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266350C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663510 size=476
    let mut pc: u32 = 0x82663510;
    'dispatch: loop {
        match pc {
            0x82663510 => {
    //   block [0x82663510..0x826636EC)
	// 82663510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663514: 48B44C55  bl 0x831a8168
	ctx.lr = 0x82663518;
	sub_831A8130(ctx, base);
	// 82663518: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266351C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663520: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82663524: 4BEAEE0D  bl 0x82512330
	ctx.lr = 0x82663528;
	sub_82512330(ctx, base);
	// 82663528: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8266352C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82663530: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82663534: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82663538: 487FA399  bl 0x82e5d8d0
	ctx.lr = 0x8266353C;
	sub_82E5D8D0(ctx, base);
	// 8266353C: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 82663540: 3CE08205  lis r7, -0x7dfb
	ctx.r[7].s64 = -2113601536;
	// 82663544: 3908A448  addi r8, r8, -0x5bb8
	ctx.r[8].s64 = ctx.r[8].s64 + -23480;
	// 82663548: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266354C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82663550: 911F00E8  stw r8, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 82663554: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 82663558: 396BA720  addi r11, r11, -0x58e0
	ctx.r[11].s64 = ctx.r[11].s64 + -22752;
	// 8266355C: 3907A734  addi r8, r7, -0x58cc
	ctx.r[8].s64 = ctx.r[7].s64 + -22732;
	// 82663560: 394AA6D4  addi r10, r10, -0x592c
	ctx.r[10].s64 = ctx.r[10].s64 + -22828;
	// 82663564: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82663568: 3929A6C4  addi r9, r9, -0x593c
	ctx.r[9].s64 = ctx.r[9].s64 + -22844;
	// 8266356C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82663570: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82663574: 915F00E4  stw r10, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 82663578: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 8266357C: 3D008329  lis r8, -0x7cd7
	ctx.r[8].s64 = -2094465024;
	// 82663580: 93DF0148  stw r30, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 82663584: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82663588: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 8266358C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82663590: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82663594: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 82663598: 93DF0154  stw r30, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[30].u32 ) };
	// 8266359C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 826635A0: 93DF0158  stw r30, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[30].u32 ) };
	// 826635A4: 38C001B0  li r6, 0x1b0
	ctx.r[6].s64 = 432;
	// 826635A8: 93DF015C  stw r30, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[30].u32 ) };
	// 826635AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826635B0: 93DF0160  stw r30, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u32 ) };
	// 826635B4: 3CA08205  lis r5, -0x7dfb
	ctx.r[5].s64 = -2113601536;
	// 826635B8: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 826635BC: C00865C0  lfs f0, 0x65c0(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826635C0: 93DF0168  stw r30, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[30].u32 ) };
	// 826635C4: 388001D0  li r4, 0x1d0
	ctx.r[4].s64 = 464;
	// 826635C8: 93DF016C  stw r30, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[30].u32 ) };
	// 826635CC: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 826635D0: 93DF0170  stw r30, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[30].u32 ) };
	// 826635D4: C1AB9534  lfs f13, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826635D8: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 826635DC: C185A440  lfs f12, -0x5bc0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-23488 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826635E0: 93DF0178  stw r30, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[30].u32 ) };
	// 826635E4: 3B8001F0  li r28, 0x1f0
	ctx.r[28].s64 = 496;
	// 826635E8: 93DF017C  stw r30, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u32 ) };
	// 826635EC: 397F0154  addi r11, r31, 0x154
	ctx.r[11].s64 = ctx.r[31].s64 + 340;
	// 826635F0: 93DF0180  stw r30, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[30].u32 ) };
	// 826635F4: 39600210  li r11, 0x210
	ctx.r[11].s64 = 528;
	// 826635F8: 93DF0184  stw r30, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[30].u32 ) };
	// 826635FC: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82663600: 93DF018C  stw r30, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[30].u32 ) };
	// 82663604: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82663608: 93DF0190  stw r30, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[30].u32 ) };
	// 8266360C: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82663610: 9BDF0194  stb r30, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[30].u8 ) };
	// 82663614: 9BDF0195  stb r30, 0x195(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(405 as u32), ctx.r[30].u8 ) };
	// 82663618: 9BDF0196  stb r30, 0x196(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(406 as u32), ctx.r[30].u8 ) };
	// 8266361C: 9BDF0197  stb r30, 0x197(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(407 as u32), ctx.r[30].u8 ) };
	// 82663620: 9BBF0198  stb r29, 0x198(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[29].u8 ) };
	// 82663624: 9BDF0199  stb r30, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[30].u8 ) };
	// 82663628: 90FF01A0  stw r7, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[7].u32 ) };
	// 8266362C: 9BDF01A4  stb r30, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[30].u8 ) };
	// 82663630: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826636F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826636F0 size=8
    let mut pc: u32 = 0x826636F0;
    'dispatch: loop {
        match pc {
            0x826636F0 => {
    //   block [0x826636F0..0x826636F8)
	// 826636F0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826636F4: 480013B4  b 0x82664aa8
	sub_82664AA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826636F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826636F8 size=8
    let mut pc: u32 = 0x826636F8;
    'dispatch: loop {
        match pc {
            0x826636F8 => {
    //   block [0x826636F8..0x82663700)
	// 826636F8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826636FC: 480013AC  b 0x82664aa8
	sub_82664AA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82663700 size=8
    let mut pc: u32 = 0x82663700;
    'dispatch: loop {
        match pc {
            0x82663700 => {
    //   block [0x82663700..0x82663708)
	// 82663700: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 82663704: 480013A4  b 0x82664aa8
	sub_82664AA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82663708 size=312
    let mut pc: u32 = 0x82663708;
    'dispatch: loop {
        match pc {
            0x82663708 => {
    //   block [0x82663708..0x82663840)
	// 82663708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266370C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82663714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266371C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663720: 807F0248  lwz r3, 0x248(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 82663724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663728: 419A0008  beq cr6, 0x82663730
	if ctx.cr[6].eq {
	pc = 0x82663730; continue 'dispatch;
	}
	// 8266372C: 4BC5D165  bl 0x822c0890
	ctx.lr = 0x82663730;
	sub_822C0890(ctx, base);
	// 82663730: 807F0240  lwz r3, 0x240(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 82663734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663738: 419A0008  beq cr6, 0x82663740
	if ctx.cr[6].eq {
	pc = 0x82663740; continue 'dispatch;
	}
	// 8266373C: 4BC5D155  bl 0x822c0890
	ctx.lr = 0x82663740;
	sub_822C0890(ctx, base);
	// 82663740: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82663744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663748: 419A0018  beq cr6, 0x82663760
	if ctx.cr[6].eq {
	pc = 0x82663760; continue 'dispatch;
	}
	// 8266374C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82663750: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82663754: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82663758: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266375C: 4E800421  bctrl
	ctx.lr = 0x82663760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82663760: 83DF0224  lwz r30, 0x224(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82663764: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82663768: 419A0014  beq cr6, 0x8266377c
	if ctx.cr[6].eq {
	pc = 0x8266377C; continue 'dispatch;
	}
	// 8266376C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82663770: 484E2CB9  bl 0x82b46428
	ctx.lr = 0x82663774;
	sub_82B46428(ctx, base);
	// 82663774: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82663778: 4BC5CAF1  bl 0x822c0268
	ctx.lr = 0x8266377C;
	sub_822C0268(ctx, base);
	// 8266377C: 83DF0190  lwz r30, 0x190(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82663780: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82663784: 419A0014  beq cr6, 0x82663798
	if ctx.cr[6].eq {
	pc = 0x82663798; continue 'dispatch;
	}
	// 82663788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266378C: 48005E6D  bl 0x826695f8
	ctx.lr = 0x82663790;
	sub_826695F8(ctx, base);
	// 82663790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82663794: 4BC5CAD5  bl 0x822c0268
	ctx.lr = 0x82663798;
	sub_822C0268(ctx, base);
	// 82663798: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8266379C: 4BC5CACD  bl 0x822c0268
	ctx.lr = 0x826637A0;
	sub_822C0268(ctx, base);
	// 826637A0: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 826637A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826637A8: 419A0008  beq cr6, 0x826637b0
	if ctx.cr[6].eq {
	pc = 0x826637B0; continue 'dispatch;
	}
	// 826637AC: 4BC5D0E5  bl 0x822c0890
	ctx.lr = 0x826637B0;
	sub_822C0890(ctx, base);
	// 826637B0: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 826637B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826637B8: 419A0008  beq cr6, 0x826637c0
	if ctx.cr[6].eq {
	pc = 0x826637C0; continue 'dispatch;
	}
	// 826637BC: 4BC5D0D5  bl 0x822c0890
	ctx.lr = 0x826637C0;
	sub_822C0890(ctx, base);
	// 826637C0: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 826637C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826637C8: 419A0008  beq cr6, 0x826637d0
	if ctx.cr[6].eq {
	pc = 0x826637D0; continue 'dispatch;
	}
	// 826637CC: 4BC5D0C5  bl 0x822c0890
	ctx.lr = 0x826637D0;
	sub_822C0890(ctx, base);
	// 826637D0: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 826637D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826637D8: 419A0008  beq cr6, 0x826637e0
	if ctx.cr[6].eq {
	pc = 0x826637E0; continue 'dispatch;
	}
	// 826637DC: 4BC5D0B5  bl 0x822c0890
	ctx.lr = 0x826637E0;
	sub_822C0890(ctx, base);
	// 826637E0: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 826637E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826637E8: 419A0008  beq cr6, 0x826637f0
	if ctx.cr[6].eq {
	pc = 0x826637F0; continue 'dispatch;
	}
	// 826637EC: 4BC5D0A5  bl 0x822c0890
	ctx.lr = 0x826637F0;
	sub_822C0890(ctx, base);
	// 826637F0: 807F0158  lwz r3, 0x158(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 826637F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826637F8: 419A0008  beq cr6, 0x82663800
	if ctx.cr[6].eq {
	pc = 0x82663800; continue 'dispatch;
	}
	// 826637FC: 4BC5D095  bl 0x822c0890
	ctx.lr = 0x82663800;
	sub_822C0890(ctx, base);
	// 82663800: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82663804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663808: 419A0008  beq cr6, 0x82663810
	if ctx.cr[6].eq {
	pc = 0x82663810; continue 'dispatch;
	}
	// 8266380C: 4BC5D085  bl 0x822c0890
	ctx.lr = 0x82663810;
	sub_822C0890(ctx, base);
	// 82663810: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82663814: 487FA035  bl 0x82e5d848
	ctx.lr = 0x82663818;
	sub_82E5D848(ctx, base);
	// 82663818: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 8266381C: 48143E3D  bl 0x827a7658
	ctx.lr = 0x82663820;
	sub_827A7658(ctx, base);
	// 82663820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82663824: 4BCEBB2D  bl 0x8234f350
	ctx.lr = 0x82663828;
	sub_8234F350(ctx, base);
	// 82663828: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266382C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82663830: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82663834: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82663838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266383C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663840 size=116
    let mut pc: u32 = 0x82663840;
    'dispatch: loop {
        match pc {
            0x82663840 => {
    //   block [0x82663840..0x826638B4)
	// 82663840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266384C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663850: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663854: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266385C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82663860: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663864: 4814F9F5  bl 0x827b3258
	ctx.lr = 0x82663868;
	sub_827B3258(ctx, base);
	// 82663868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266386C: 4BFFE25D  bl 0x82661ac8
	ctx.lr = 0x82663870;
	sub_82661AC8(ctx, base);
	// 82663870: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82663874: C01F01C4  lfs f0, 0x1c4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82663878: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266387C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82663880: 40990010  ble cr6, 0x82663890
	if !ctx.cr[6].gt {
	pc = 0x82663890; continue 'dispatch;
	}
	// 82663884: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82663888: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8266388C: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82663890: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82663894: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82663898: 487F95E1  bl 0x82e5ce78
	ctx.lr = 0x8266389C;
	sub_82E5CE78(ctx, base);
	// 8266389C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826638A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826638A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826638A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826638AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826638B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826638B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826638B8 size=528
    let mut pc: u32 = 0x826638B8;
    'dispatch: loop {
        match pc {
            0x826638B8 => {
    //   block [0x826638B8..0x82663AC8)
	// 826638B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826638BC: 48B448B1  bl 0x831a816c
	ctx.lr = 0x826638C0;
	sub_831A8130(ctx, base);
	// 826638C0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826638C4: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826638C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826638CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826638D0: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 826638D4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826638D8: 419A000C  beq cr6, 0x826638e4
	if ctx.cr[6].eq {
	pc = 0x826638E4; continue 'dispatch;
	}
	// 826638DC: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826638E0: 409A0014  bne cr6, 0x826638f4
	if !ctx.cr[6].eq {
	pc = 0x826638F4; continue 'dispatch;
	}
	// 826638E4: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826638E8: 48006DF1  bl 0x8266a6d8
	ctx.lr = 0x826638EC;
	sub_8266A6D8(ctx, base);
	// 826638EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826638F0: 408201CC  bne 0x82663abc
	if !ctx.cr[0].eq {
	pc = 0x82663ABC; continue 'dispatch;
	}
	// 826638F4: 897E0044  lbz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 826638F8: 3BBE0030  addi r29, r30, 0x30
	ctx.r[29].s64 = ctx.r[30].s64 + 48;
	// 826638FC: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663900: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82663904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82663908: 4182000C  beq 0x82663914
	if ctx.cr[0].eq {
	pc = 0x82663914; continue 'dispatch;
	}
	// 8266390C: 4814F94D  bl 0x827b3258
	ctx.lr = 0x82663910;
	sub_827B3258(ctx, base);
	// 82663910: 48000008  b 0x82663918
	pc = 0x82663918; continue 'dispatch;
	// 82663914: 48006EED  bl 0x8266a800
	ctx.lr = 0x82663918;
	sub_8266A800(ctx, base);
	// 82663918: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 8266391C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82663920: 419A0024  beq cr6, 0x82663944
	if ctx.cr[6].eq {
	pc = 0x82663944; continue 'dispatch;
	}
	// 82663924: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82663928: 419A001C  beq cr6, 0x82663944
	if ctx.cr[6].eq {
	pc = 0x82663944; continue 'dispatch;
	}
	// 8266392C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82663930: 419A0014  beq cr6, 0x82663944
	if ctx.cr[6].eq {
	pc = 0x82663944; continue 'dispatch;
	}
	// 82663934: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 82663938: 419A000C  beq cr6, 0x82663944
	if ctx.cr[6].eq {
	pc = 0x82663944; continue 'dispatch;
	}
	// 8266393C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82663940: 409A016C  bne cr6, 0x82663aac
	if !ctx.cr[6].eq {
	pc = 0x82663AAC; continue 'dispatch;
	}
	// 82663944: 3880002D  li r4, 0x2d
	ctx.r[4].s64 = 45;
	// 82663948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266394C: 4BFFE115  bl 0x82661a60
	ctx.lr = 0x82663950;
	sub_82661A60(ctx, base);
	// 82663950: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663954: 48006CD5  bl 0x8266a628
	ctx.lr = 0x82663958;
	sub_8266A628(ctx, base);
	// 82663958: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8266395C: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663960: 48006CF1  bl 0x8266a650
	ctx.lr = 0x82663964;
	sub_8266A650(ctx, base);
	// 82663964: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82663968: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8266396C: 48006D65  bl 0x8266a6d0
	ctx.lr = 0x82663970;
	sub_8266A6D0(ctx, base);
	// 82663970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82663974: 4BEAE175  bl 0x82511ae8
	ctx.lr = 0x82663978;
	sub_82511AE8(ctx, base);
	// 82663978: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8266397C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82663980: 394001B0  li r10, 0x1b0
	ctx.r[10].s64 = 432;
	// 82663984: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82663988: 13DE58C7  vcmpequd (lvx128) v30, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663AC8 size=120
    let mut pc: u32 = 0x82663AC8;
    'dispatch: loop {
        match pc {
            0x82663AC8 => {
    //   block [0x82663AC8..0x82663B40)
	// 82663AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663AD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663AD4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663AD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663ADC: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663AE0: 48006B59  bl 0x8266a638
	ctx.lr = 0x82663AE4;
	sub_8266A638(ctx, base);
	// 82663AE4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82663AE8: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663AEC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82663AF0: C02B65C4  lfs f1, 0x65c4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26052 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82663AF4: 4800709D  bl 0x8266ab90
	ctx.lr = 0x82663AF8;
	sub_8266AB90(ctx, base);
	// 82663AF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82663AFC: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663B00: 4814F759  bl 0x827b3258
	ctx.lr = 0x82663B04;
	sub_827B3258(ctx, base);
	// 82663B04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82663B08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663B0C: 48819945  bl 0x82e7d450
	ctx.lr = 0x82663B10;
	sub_82E7D450(ctx, base);
	// 82663B10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82663B14: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663B18: 48006C89  bl 0x8266a7a0
	ctx.lr = 0x82663B1C;
	sub_8266A7A0(ctx, base);
	// 82663B1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82663B20: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82663B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82663B28: 4BFFF299  bl 0x82662dc0
	ctx.lr = 0x82663B2C;
	sub_82662DC0(ctx, base);
	// 82663B2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82663B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82663B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82663B38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82663B3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663B40 size=188
    let mut pc: u32 = 0x82663B40;
    'dispatch: loop {
        match pc {
            0x82663B40 => {
    //   block [0x82663B40..0x82663BFC)
	// 82663B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663B44: 48B44621  bl 0x831a8164
	ctx.lr = 0x82663B48;
	sub_831A8130(ctx, base);
	// 82663B48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663B4C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82663B50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663B54: 3BABA7B0  addi r29, r11, -0x5850
	ctx.r[29].s64 = ctx.r[11].s64 + -22608;
	// 82663B58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82663B5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663B60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82663B64: 4878FEA5  bl 0x82df3a08
	ctx.lr = 0x82663B68;
	sub_82DF3A08(ctx, base);
	// 82663B68: 3B9F00E8  addi r28, r31, 0xe8
	ctx.r[28].s64 = ctx.r[31].s64 + 232;
	// 82663B6C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82663B70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82663B74: 487F6B5D  bl 0x82e5a6d0
	ctx.lr = 0x82663B78;
	sub_82E5A6D0(ctx, base);
	// 82663B78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82663B7C: 4878F725  bl 0x82df32a0
	ctx.lr = 0x82663B80;
	sub_82DF32A0(ctx, base);
	// 82663B80: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82663B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663B88: 4878F8A1  bl 0x82df3428
	ctx.lr = 0x82663B8C;
	sub_82DF3428(ctx, base);
	// 82663B8C: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82663B90: 41820064  beq 0x82663bf4
	if ctx.cr[0].eq {
	pc = 0x82663BF4; continue 'dispatch;
	}
	// 82663B94: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82663B98: 397E0018  addi r11, r30, 0x18
	ctx.r[11].s64 = ctx.r[30].s64 + 24;
	// 82663B9C: 395F0168  addi r10, r31, 0x168
	ctx.r[10].s64 = ctx.r[31].s64 + 360;
	// 82663BA0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82663BA4: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82663BA8: 913F0168  stw r9, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[9].u32 ) };
	// 82663BAC: 4BC608B5  bl 0x822c4460
	ctx.lr = 0x82663BB0;
	sub_822C4460(ctx, base);
	// 82663BB0: 897E0020  lbz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82663BB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82663BB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663BBC: 997F0199  stb r11, 0x199(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(409 as u32), ctx.r[11].u8 ) };
	// 82663BC0: 4878FE49  bl 0x82df3a08
	ctx.lr = 0x82663BC4;
	sub_82DF3A08(ctx, base);
	// 82663BC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82663BC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82663BCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82663BD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82663BD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82663BD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82663BDC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82663BE0: 487FAD81  bl 0x82e5e960
	ctx.lr = 0x82663BE4;
	sub_82E5E960(ctx, base);
	// 82663BE4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82663BE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663BEC: 419A0008  beq cr6, 0x82663bf4
	if ctx.cr[6].eq {
	pc = 0x82663BF4; continue 'dispatch;
	}
	// 82663BF0: 4BC5CCA1  bl 0x822c0890
	ctx.lr = 0x82663BF4;
	sub_822C0890(ctx, base);
	// 82663BF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82663BF8: 48B445BC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663C00 size=388
    let mut pc: u32 = 0x82663C00;
    'dispatch: loop {
        match pc {
            0x82663C00 => {
    //   block [0x82663C00..0x82663D84)
	// 82663C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82663C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663C10: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663C14: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82663C18: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 82663C1C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82663C20: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82663C24: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 82663C28: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 82663C2C: 38C100D0  addi r6, r1, 0xd0
	ctx.r[6].s64 = ctx.r[1].s64 + 208;
	// 82663C30: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82663C34: 3929A2F0  addi r9, r9, -0x5d10
	ctx.r[9].s64 = ctx.r[9].s64 + -23824;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663D88 size=232
    let mut pc: u32 = 0x82663D88;
    'dispatch: loop {
        match pc {
            0x82663D88 => {
    //   block [0x82663D88..0x82663E70)
	// 82663D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82663D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663D98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663D9C: 48AF0865  bl 0x83154600
	ctx.lr = 0x82663DA0;
	sub_83154600(ctx, base);
	// 82663DA0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82663DA4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82663DA8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82663DAC: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82663DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663DB4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82663DB8: 4883C979  bl 0x82ea0730
	ctx.lr = 0x82663DBC;
	sub_82EA0730(ctx, base);
	// 82663DBC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82663DC0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82663DC4: 396BA7D0  addi r11, r11, -0x5830
	ctx.r[11].s64 = ctx.r[11].s64 + -22576;
	// 82663DC8: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82663DCC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82663DD0: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 82663DD4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82663DD8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82663E70 size=212
    let mut pc: u32 = 0x82663E70;
    'dispatch: loop {
        match pc {
            0x82663E70 => {
    //   block [0x82663E70..0x82663F44)
	// 82663E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82663E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663E80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663E84: 48AF077D  bl 0x83154600
	ctx.lr = 0x82663E88;
	sub_83154600(ctx, base);
	// 82663E88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663E8C: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82663E90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82663E94: 40820098  bne 0x82663f2c
	if !ctx.cr[0].eq {
	pc = 0x82663F2C; continue 'dispatch;
	}
	// 82663E98: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663E9C: 4800680D  bl 0x8266a6a8
	ctx.lr = 0x82663EA0;
	sub_8266A6A8(ctx, base);
	// 82663EA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82663EA4: 40820088  bne 0x82663f2c
	if !ctx.cr[0].eq {
	pc = 0x82663F2C; continue 'dispatch;
	}
	// 82663EA8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82663EAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82663EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663EB4: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 82663EB8: 4878DD41  bl 0x82df1bf8
	ctx.lr = 0x82663EBC;
	sub_82DF1BF8(ctx, base);
	// 82663EBC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82663EC0: 484E3381  bl 0x82b47240
	ctx.lr = 0x82663EC4;
	sub_82B47240(ctx, base);
	// 82663EC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82663EC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82663ECC: 4878DDC5  bl 0x82df1c90
	ctx.lr = 0x82663ED0;
	sub_82DF1C90(ctx, base);
	// 82663ED0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82663ED4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82663ED8: 41820054  beq 0x82663f2c
	if ctx.cr[0].eq {
	pc = 0x82663F2C; continue 'dispatch;
	}
	// 82663EDC: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663EE0: 480067F9  bl 0x8266a6d8
	ctx.lr = 0x82663EE4;
	sub_8266A6D8(ctx, base);
	// 82663EE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82663EE8: 40820044  bne 0x82663f2c
	if !ctx.cr[0].eq {
	pc = 0x82663F2C; continue 'dispatch;
	}
	// 82663EEC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82663EF0: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663EF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82663EF8: C02B65A8  lfs f1, 0x65a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26024 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82663EFC: 48006C95  bl 0x8266ab90
	ctx.lr = 0x82663F00;
	sub_8266AB90(ctx, base);
	// 82663F00: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82663F04: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663F08: 4814F351  bl 0x827b3258
	ctx.lr = 0x82663F0C;
	sub_827B3258(ctx, base);
	// 82663F0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82663F10: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82663F14: C02B093C  lfs f1, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82663F18: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82663F1C: 40990010  ble cr6, 0x82663f2c
	if !ctx.cr[6].gt {
	pc = 0x82663F2C; continue 'dispatch;
	}
	// 82663F20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82663F24: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82663F28: 48006C69  bl 0x8266ab90
	ctx.lr = 0x82663F2C;
	sub_8266AB90(ctx, base);
	// 82663F2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82663F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82663F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82663F38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82663F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82663F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82663F48 size=92
    let mut pc: u32 = 0x82663F48;
    'dispatch: loop {
        match pc {
            0x82663F48 => {
    //   block [0x82663F48..0x82663FA4)
	// 82663F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82663F50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82663F54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663F58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663F5C: 48AF06A5  bl 0x83154600
	ctx.lr = 0x82663F60;
	sub_83154600(ctx, base);
	// 82663F60: 809F0094  lwz r4, 0x94(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82663F64: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82663F68: 419A0028  beq cr6, 0x82663f90
	if ctx.cr[6].eq {
	pc = 0x82663F90; continue 'dispatch;
	}
	// 82663F6C: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82663F70: 487AEA89  bl 0x82e129f8
	ctx.lr = 0x82663F74;
	sub_82E129F8(ctx, base);
	// 82663F74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82663F78: 917F0094  stw r11, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82663F7C: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82663F80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82663F84: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82663F88: 419A0008  beq cr6, 0x82663f90
	if ctx.cr[6].eq {
	pc = 0x82663F90; continue 'dispatch;
	}
	// 82663F8C: 4BC5C905  bl 0x822c0890
	ctx.lr = 0x82663F90;
	sub_822C0890(ctx, base);
	// 82663F90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82663F94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82663F98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82663F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82663FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82663FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82663FA8 size=120
    let mut pc: u32 = 0x82663FA8;
    'dispatch: loop {
        match pc {
            0x82663FA8 => {
    //   block [0x82663FA8..0x82664020)
	// 82663FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82663FAC: 48B441C1  bl 0x831a816c
	ctx.lr = 0x82663FB0;
	sub_831A8130(ctx, base);
	// 82663FB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82663FB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82663FB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82663FBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82663FC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82663FC4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82663FC8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82663FCC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82663FD0: 4878E419  bl 0x82df23e8
	ctx.lr = 0x82663FD4;
	sub_82DF23E8(ctx, base);
	// 82663FD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82663FD8: 41820014  beq 0x82663fec
	if ctx.cr[0].eq {
	pc = 0x82663FEC; continue 'dispatch;
	}
	// 82663FDC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82663FE0: 484F2999  bl 0x82b56978
	ctx.lr = 0x82663FE4;
	sub_82B56978(ctx, base);
	// 82663FE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82663FE8: 48000008  b 0x82663ff0
	pc = 0x82663FF0; continue 'dispatch;
	// 82663FEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82663FF0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82663FF4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82663FF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82663FFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664000: 4BFFDDE9  bl 0x82661de8
	ctx.lr = 0x82664004;
	sub_82661DE8(ctx, base);
	// 82664004: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664008: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266400C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664010: 4BC5BFF1  bl 0x822c0000
	ctx.lr = 0x82664014;
	sub_822C0000(ctx, base);
	// 82664014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664018: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266401C: 48B441A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664020 size=120
    let mut pc: u32 = 0x82664020;
    'dispatch: loop {
        match pc {
            0x82664020 => {
    //   block [0x82664020..0x82664098)
	// 82664020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664024: 48B44149  bl 0x831a816c
	ctx.lr = 0x82664028;
	sub_831A8130(ctx, base);
	// 82664028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266402C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664030: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82664034: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82664038: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266403C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82664040: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82664044: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82664048: 4878E3A1  bl 0x82df23e8
	ctx.lr = 0x8266404C;
	sub_82DF23E8(ctx, base);
	// 8266404C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82664050: 41820014  beq 0x82664064
	if ctx.cr[0].eq {
	pc = 0x82664064; continue 'dispatch;
	}
	// 82664054: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664058: 484F3AE1  bl 0x82b57b38
	ctx.lr = 0x8266405C;
	sub_82B57B38(ctx, base);
	// 8266405C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664060: 48000008  b 0x82664068
	pc = 0x82664068; continue 'dispatch;
	// 82664064: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82664068: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8266406C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664078: 4BFFDE39  bl 0x82661eb0
	ctx.lr = 0x8266407C;
	sub_82661EB0(ctx, base);
	// 8266407C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664088: 4BC5BF79  bl 0x822c0000
	ctx.lr = 0x8266408C;
	sub_822C0000(ctx, base);
	// 8266408C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664094: 48B44128  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664098 size=120
    let mut pc: u32 = 0x82664098;
    'dispatch: loop {
        match pc {
            0x82664098 => {
    //   block [0x82664098..0x82664110)
	// 82664098: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266409C: 48B440D1  bl 0x831a816c
	ctx.lr = 0x826640A0;
	sub_831A8130(ctx, base);
	// 826640A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826640A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826640A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826640AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826640B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826640B4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826640B8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 826640BC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 826640C0: 4878E329  bl 0x82df23e8
	ctx.lr = 0x826640C4;
	sub_82DF23E8(ctx, base);
	// 826640C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826640C8: 41820014  beq 0x826640dc
	if ctx.cr[0].eq {
	pc = 0x826640DC; continue 'dispatch;
	}
	// 826640CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826640D0: 484F2A79  bl 0x82b56b48
	ctx.lr = 0x826640D4;
	sub_82B56B48(ctx, base);
	// 826640D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826640D8: 48000008  b 0x826640e0
	pc = 0x826640E0; continue 'dispatch;
	// 826640DC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826640E0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826640E4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826640E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826640EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826640F0: 4BFFDE89  bl 0x82661f78
	ctx.lr = 0x826640F4;
	sub_82661F78(ctx, base);
	// 826640F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826640F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826640FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664100: 4BC5BF01  bl 0x822c0000
	ctx.lr = 0x82664104;
	sub_822C0000(ctx, base);
	// 82664104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664108: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266410C: 48B440B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664110 size=120
    let mut pc: u32 = 0x82664110;
    'dispatch: loop {
        match pc {
            0x82664110 => {
    //   block [0x82664110..0x82664188)
	// 82664110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664114: 48B44059  bl 0x831a816c
	ctx.lr = 0x82664118;
	sub_831A8130(ctx, base);
	// 82664118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266411C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664120: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82664124: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82664128: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266412C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82664130: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82664134: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82664138: 4878E2B1  bl 0x82df23e8
	ctx.lr = 0x8266413C;
	sub_82DF23E8(ctx, base);
	// 8266413C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82664140: 41820014  beq 0x82664154
	if ctx.cr[0].eq {
	pc = 0x82664154; continue 'dispatch;
	}
	// 82664144: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664148: 484F27E1  bl 0x82b56928
	ctx.lr = 0x8266414C;
	sub_82B56928(ctx, base);
	// 8266414C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664150: 48000008  b 0x82664158
	pc = 0x82664158; continue 'dispatch;
	// 82664154: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82664158: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8266415C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664168: 4BFFDED9  bl 0x82662040
	ctx.lr = 0x8266416C;
	sub_82662040(ctx, base);
	// 8266416C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664178: 4BC5BE89  bl 0x822c0000
	ctx.lr = 0x8266417C;
	sub_822C0000(ctx, base);
	// 8266417C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664184: 48B44038  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664188 size=172
    let mut pc: u32 = 0x82664188;
    'dispatch: loop {
        match pc {
            0x82664188 => {
    //   block [0x82664188..0x82664234)
	// 82664188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266418C: 48B43FD9  bl 0x831a8164
	ctx.lr = 0x82664190;
	sub_831A8130(ctx, base);
	// 82664190: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664194: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82664198: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266419C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826641A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826641A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826641A8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826641AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826641B0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826641B4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 826641B8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 826641BC: 4878E22D  bl 0x82df23e8
	ctx.lr = 0x826641C0;
	sub_82DF23E8(ctx, base);
	// 826641C0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826641C4: 4182002C  beq 0x826641f0
	if ctx.cr[0].eq {
	pc = 0x826641F0; continue 'dispatch;
	}
	// 826641C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826641CC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826641D0: 4878F839  bl 0x82df3a08
	ctx.lr = 0x826641D4;
	sub_82DF3A08(ctx, base);
	// 826641D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826641D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826641DC: 88BC0000  lbz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826641E0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826641E4: 484F27E5  bl 0x82b569c8
	ctx.lr = 0x826641E8;
	sub_82B569C8(ctx, base);
	// 826641E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826641EC: 48000008  b 0x826641f4
	pc = 0x826641F4; continue 'dispatch;
	// 826641F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826641F4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826641F8: 3BBB0004  addi r29, r27, 4
	ctx.r[29].s64 = ctx.r[27].s64 + 4;
	// 826641FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664204: 4BE52EFD  bl 0x824b7100
	ctx.lr = 0x82664208;
	sub_824B7100(ctx, base);
	// 82664208: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266420C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664210: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664214: 4BC5BDED  bl 0x822c0000
	ctx.lr = 0x82664218;
	sub_822C0000(ctx, base);
	// 82664218: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266421C: 4182000C  beq 0x82664228
	if ctx.cr[0].eq {
	pc = 0x82664228; continue 'dispatch;
	}
	// 82664220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664224: 4878F205  bl 0x82df3428
	ctx.lr = 0x82664228;
	sub_82DF3428(ctx, base);
	// 82664228: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8266422C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82664230: 48B43F84  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664238 size=116
    let mut pc: u32 = 0x82664238;
    'dispatch: loop {
        match pc {
            0x82664238 => {
    //   block [0x82664238..0x826642AC)
	// 82664238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266423C: 48B43F31  bl 0x831a816c
	ctx.lr = 0x82664240;
	sub_831A8130(ctx, base);
	// 82664240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664244: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664248: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8266424C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82664250: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82664254: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82664258: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 8266425C: 4878E18D  bl 0x82df23e8
	ctx.lr = 0x82664260;
	sub_82DF23E8(ctx, base);
	// 82664260: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82664264: 41820014  beq 0x82664278
	if ctx.cr[0].eq {
	pc = 0x82664278; continue 'dispatch;
	}
	// 82664268: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266426C: 484F48D5  bl 0x82b58b40
	ctx.lr = 0x82664270;
	sub_82B58B40(ctx, base);
	// 82664270: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664274: 48000008  b 0x8266427c
	pc = 0x8266427C; continue 'dispatch;
	// 82664278: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266427C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82664280: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266428C: 4BF8BEDD  bl 0x825f0168
	ctx.lr = 0x82664290;
	sub_825F0168(ctx, base);
	// 82664290: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664298: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266429C: 4BC5BD65  bl 0x822c0000
	ctx.lr = 0x826642A0;
	sub_822C0000(ctx, base);
	// 826642A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826642A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826642A8: 48B43F14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826642B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826642B0 size=124
    let mut pc: u32 = 0x826642B0;
    'dispatch: loop {
        match pc {
            0x826642B0 => {
    //   block [0x826642B0..0x8266432C)
	// 826642B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826642B4: 48B43EB9  bl 0x831a816c
	ctx.lr = 0x826642B8;
	sub_831A8130(ctx, base);
	// 826642B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826642BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826642C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826642C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826642C8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 826642CC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 826642D0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826642D4: 4878E115  bl 0x82df23e8
	ctx.lr = 0x826642D8;
	sub_82DF23E8(ctx, base);
	// 826642D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826642DC: 4182001C  beq 0x826642f8
	if ctx.cr[0].eq {
	pc = 0x826642F8; continue 'dispatch;
	}
	// 826642E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826642E4: 487F8645  bl 0x82e5c928
	ctx.lr = 0x826642E8;
	sub_82E5C928(ctx, base);
	// 826642E8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826642EC: 396BA570  addi r11, r11, -0x5a90
	ctx.r[11].s64 = ctx.r[11].s64 + -23184;
	// 826642F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826642F4: 48000008  b 0x826642fc
	pc = 0x826642FC; continue 'dispatch;
	// 826642F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826642FC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82664300: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266430C: 4BFFDDFD  bl 0x82662108
	ctx.lr = 0x82664310;
	sub_82662108(ctx, base);
	// 82664310: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664314: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266431C: 4BC5BCE5  bl 0x822c0000
	ctx.lr = 0x82664320;
	sub_822C0000(ctx, base);
	// 82664320: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664324: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664328: 48B43E94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664330 size=124
    let mut pc: u32 = 0x82664330;
    'dispatch: loop {
        match pc {
            0x82664330 => {
    //   block [0x82664330..0x826643AC)
	// 82664330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664334: 48B43E39  bl 0x831a816c
	ctx.lr = 0x82664338;
	sub_831A8130(ctx, base);
	// 82664338: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266433C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664340: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82664344: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82664348: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8266434C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82664350: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82664354: 4878E095  bl 0x82df23e8
	ctx.lr = 0x82664358;
	sub_82DF23E8(ctx, base);
	// 82664358: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8266435C: 4182001C  beq 0x82664378
	if ctx.cr[0].eq {
	pc = 0x82664378; continue 'dispatch;
	}
	// 82664360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664364: 487F85C5  bl 0x82e5c928
	ctx.lr = 0x82664368;
	sub_82E5C928(ctx, base);
	// 82664368: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266436C: 396BA59C  addi r11, r11, -0x5a64
	ctx.r[11].s64 = ctx.r[11].s64 + -23140;
	// 82664370: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82664374: 48000008  b 0x8266437c
	pc = 0x8266437C; continue 'dispatch;
	// 82664378: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266437C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82664380: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266438C: 4BFFDE45  bl 0x826621d0
	ctx.lr = 0x82664390;
	sub_826621D0(ctx, base);
	// 82664390: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266439C: 4BC5BC65  bl 0x822c0000
	ctx.lr = 0x826643A0;
	sub_822C0000(ctx, base);
	// 826643A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826643A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826643A8: 48B43E14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826643B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826643B0 size=124
    let mut pc: u32 = 0x826643B0;
    'dispatch: loop {
        match pc {
            0x826643B0 => {
    //   block [0x826643B0..0x8266442C)
	// 826643B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826643B4: 48B43DB9  bl 0x831a816c
	ctx.lr = 0x826643B8;
	sub_831A8130(ctx, base);
	// 826643B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826643BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826643C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826643C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826643C8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 826643CC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 826643D0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 826643D4: 4878E015  bl 0x82df23e8
	ctx.lr = 0x826643D8;
	sub_82DF23E8(ctx, base);
	// 826643D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826643DC: 4182001C  beq 0x826643f8
	if ctx.cr[0].eq {
	pc = 0x826643F8; continue 'dispatch;
	}
	// 826643E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826643E4: 487F8545  bl 0x82e5c928
	ctx.lr = 0x826643E8;
	sub_82E5C928(ctx, base);
	// 826643E8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826643EC: 396BA5C4  addi r11, r11, -0x5a3c
	ctx.r[11].s64 = ctx.r[11].s64 + -23100;
	// 826643F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826643F4: 48000008  b 0x826643fc
	pc = 0x826643FC; continue 'dispatch;
	// 826643F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826643FC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82664400: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664404: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266440C: 4BFFDE8D  bl 0x82662298
	ctx.lr = 0x82664410;
	sub_82662298(ctx, base);
	// 82664410: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266441C: 4BC5BBE5  bl 0x822c0000
	ctx.lr = 0x82664420;
	sub_822C0000(ctx, base);
	// 82664420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664428: 48B43D94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664430 size=112
    let mut pc: u32 = 0x82664430;
    'dispatch: loop {
        match pc {
            0x82664430 => {
    //   block [0x82664430..0x826644A0)
	// 82664430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664434: 48B43D39  bl 0x831a816c
	ctx.lr = 0x82664438;
	sub_831A8130(ctx, base);
	// 82664438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266443C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664440: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82664444: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82664448: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 8266444C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82664450: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82664454: 4878DF95  bl 0x82df23e8
	ctx.lr = 0x82664458;
	sub_82DF23E8(ctx, base);
	// 82664458: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266445C: 41820010  beq 0x8266446c
	if ctx.cr[0].eq {
	pc = 0x8266446C; continue 'dispatch;
	}
	// 82664460: 4BFFEFF9  bl 0x82663458
	ctx.lr = 0x82664464;
	sub_82663458(ctx, base);
	// 82664464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664468: 48000008  b 0x82664470
	pc = 0x82664470; continue 'dispatch;
	// 8266446C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82664470: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82664474: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82664478: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266447C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664480: 4BFFDEE1  bl 0x82662360
	ctx.lr = 0x82664484;
	sub_82662360(ctx, base);
	// 82664484: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664488: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266448C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664490: 4BC5BB71  bl 0x822c0000
	ctx.lr = 0x82664494;
	sub_822C0000(ctx, base);
	// 82664494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266449C: 48B43D20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826644A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826644A0 size=124
    let mut pc: u32 = 0x826644A0;
    'dispatch: loop {
        match pc {
            0x826644A0 => {
    //   block [0x826644A0..0x8266451C)
	// 826644A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826644A4: 48B43CC9  bl 0x831a816c
	ctx.lr = 0x826644A8;
	sub_831A8130(ctx, base);
	// 826644A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826644AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826644B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826644B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826644B8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 826644BC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 826644C0: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826644C4: 4878DF25  bl 0x82df23e8
	ctx.lr = 0x826644C8;
	sub_82DF23E8(ctx, base);
	// 826644C8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826644CC: 4182001C  beq 0x826644e8
	if ctx.cr[0].eq {
	pc = 0x826644E8; continue 'dispatch;
	}
	// 826644D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826644D4: 487F8455  bl 0x82e5c928
	ctx.lr = 0x826644D8;
	sub_82E5C928(ctx, base);
	// 826644D8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826644DC: 396BA5EC  addi r11, r11, -0x5a14
	ctx.r[11].s64 = ctx.r[11].s64 + -23060;
	// 826644E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826644E4: 48000008  b 0x826644ec
	pc = 0x826644EC; continue 'dispatch;
	// 826644E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826644EC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826644F0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826644F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826644F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826644FC: 4BFFDF2D  bl 0x82662428
	ctx.lr = 0x82664500;
	sub_82662428(ctx, base);
	// 82664500: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82664504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664508: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266450C: 4BC5BAF5  bl 0x822c0000
	ctx.lr = 0x82664510;
	sub_822C0000(ctx, base);
	// 82664510: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664518: 48B43CA4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664520 size=76
    let mut pc: u32 = 0x82664520;
    'dispatch: loop {
        match pc {
            0x82664520 => {
    //   block [0x82664520..0x8266456C)
	// 82664520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82664528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266452C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82664530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664534: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664538: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8266453C: 4BFFEF75  bl 0x826634b0
	ctx.lr = 0x82664540;
	sub_826634B0(ctx, base);
	// 82664540: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82664544: 4182000C  beq 0x82664550
	if ctx.cr[0].eq {
	pc = 0x82664550; continue 'dispatch;
	}
	// 82664548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266454C: 4878DE8D  bl 0x82df23d8
	ctx.lr = 0x82664550;
	sub_82DF23D8(ctx, base);
	// 82664550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266455C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82664560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82664564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82664568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664570 size=116
    let mut pc: u32 = 0x82664570;
    'dispatch: loop {
        match pc {
            0x82664570 => {
    //   block [0x82664570..0x826645E4)
	// 82664570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664574: 48B43BF9  bl 0x831a816c
	ctx.lr = 0x82664578;
	sub_831A8130(ctx, base);
	// 82664578: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266457C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664580: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82664584: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82664588: 388BA520  addi r4, r11, -0x5ae0
	ctx.r[4].s64 = ctx.r[11].s64 + -23264;
	// 8266458C: 38A000B1  li r5, 0xb1
	ctx.r[5].s64 = 177;
	// 82664590: 38600250  li r3, 0x250
	ctx.r[3].s64 = 592;
	// 82664594: 4878DE55  bl 0x82df23e8
	ctx.lr = 0x82664598;
	sub_82DF23E8(ctx, base);
	// 82664598: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266459C: 41820014  beq 0x826645b0
	if ctx.cr[0].eq {
	pc = 0x826645B0; continue 'dispatch;
	}
	// 826645A0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826645A4: 4BFFEF6D  bl 0x82663510
	ctx.lr = 0x826645A8;
	sub_82663510(ctx, base);
	// 826645A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826645AC: 48000008  b 0x826645b4
	pc = 0x826645B4; continue 'dispatch;
	// 826645B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826645B4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826645B8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826645BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826645C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826645C4: 4BFFD75D  bl 0x82661d20
	ctx.lr = 0x826645C8;
	sub_82661D20(ctx, base);
	// 826645C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826645CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826645D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826645D4: 4BC5BA2D  bl 0x822c0000
	ctx.lr = 0x826645D8;
	sub_822C0000(ctx, base);
	// 826645D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826645DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826645E0: 48B43BDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826645E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826645E8 size=1212
    let mut pc: u32 = 0x826645E8;
    'dispatch: loop {
        match pc {
            0x826645E8 => {
    //   block [0x826645E8..0x82664AA4)
	// 826645E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826645EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826645F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826645F4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 826645F8: 48B44481  bl 0x831a8a78
	ctx.lr = 0x826645FC;
	sub_831A8A40(ctx, base);
	// 826645FC: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664604: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82664608: 419A0480  beq cr6, 0x82664a88
	if ctx.cr[6].eq {
	pc = 0x82664A88; continue 'dispatch;
	}
	// 8266460C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664610: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664614: 388BA9A0  addi r4, r11, -0x5660
	ctx.r[4].s64 = ctx.r[11].s64 + -22112;
	// 82664618: 4878F3F1  bl 0x82df3a08
	ctx.lr = 0x8266461C;
	sub_82DF3A08(ctx, base);
	// 8266461C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664620: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664624: 388BA990  addi r4, r11, -0x5670
	ctx.r[4].s64 = ctx.r[11].s64 + -22128;
	// 82664628: 4878F3E1  bl 0x82df3a08
	ctx.lr = 0x8266462C;
	sub_82DF3A08(ctx, base);
	// 8266462C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82664630: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82664634: 38AB80F4  addi r5, r11, -0x7f0c
	ctx.r[5].s64 = ctx.r[11].s64 + -32524;
	// 82664638: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266463C: 4BF3EA15  bl 0x825a3050
	ctx.lr = 0x82664640;
	sub_825A3050(ctx, base);
	// 82664640: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82664644: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266464C: 4BF3DB3D  bl 0x825a2188
	ctx.lr = 0x82664650;
	sub_825A2188(ctx, base);
	// 82664650: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82664654: 4878EDD5  bl 0x82df3428
	ctx.lr = 0x82664658;
	sub_82DF3428(ctx, base);
	// 82664658: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8266465C: 4BC6465D  bl 0x822c8cb8
	ctx.lr = 0x82664660;
	sub_822C8CB8(ctx, base);
	// 82664660: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664664: 4878EDC5  bl 0x82df3428
	ctx.lr = 0x82664668;
	sub_82DF3428(ctx, base);
	// 82664668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266466C: 4878EDBD  bl 0x82df3428
	ctx.lr = 0x82664670;
	sub_82DF3428(ctx, base);
	// 82664670: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664674: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664678: 388BA970  addi r4, r11, -0x5690
	ctx.r[4].s64 = ctx.r[11].s64 + -22160;
	// 8266467C: 4878F38D  bl 0x82df3a08
	ctx.lr = 0x82664680;
	sub_82DF3A08(ctx, base);
	// 82664680: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664688: 388BA960  addi r4, r11, -0x56a0
	ctx.r[4].s64 = ctx.r[11].s64 + -22176;
	// 8266468C: 4878F37D  bl 0x82df3a08
	ctx.lr = 0x82664690;
	sub_82DF3A08(ctx, base);
	// 82664690: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82664694: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82664698: 38AB65CC  addi r5, r11, 0x65cc
	ctx.r[5].s64 = ctx.r[11].s64 + 26060;
	// 8266469C: 38E001F4  li r7, 0x1f4
	ctx.r[7].s64 = 500;
	// 826646A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826646A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826646A8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 826646AC: 4BF3ED6D  bl 0x825a3418
	ctx.lr = 0x826646B0;
	sub_825A3418(ctx, base);
	// 826646B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826646B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826646B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826646BC: 4BF3D81D  bl 0x825a1ed8
	ctx.lr = 0x826646C0;
	sub_825A1ED8(ctx, base);
	// 826646C0: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 826646C4: 4878ED65  bl 0x82df3428
	ctx.lr = 0x826646C8;
	sub_82DF3428(ctx, base);
	// 826646C8: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826646CC: 4BC645ED  bl 0x822c8cb8
	ctx.lr = 0x826646D0;
	sub_822C8CB8(ctx, base);
	// 826646D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826646D4: 4878ED55  bl 0x82df3428
	ctx.lr = 0x826646D8;
	sub_82DF3428(ctx, base);
	// 826646D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826646DC: 4878ED4D  bl 0x82df3428
	ctx.lr = 0x826646E0;
	sub_82DF3428(ctx, base);
	// 826646E0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826646E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826646E8: 388BA93C  addi r4, r11, -0x56c4
	ctx.r[4].s64 = ctx.r[11].s64 + -22212;
	// 826646EC: 4878F31D  bl 0x82df3a08
	ctx.lr = 0x826646F0;
	sub_82DF3A08(ctx, base);
	// 826646F0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826646F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826646F8: 388BA928  addi r4, r11, -0x56d8
	ctx.r[4].s64 = ctx.r[11].s64 + -22232;
	// 826646FC: 4878F30D  bl 0x82df3a08
	ctx.lr = 0x82664700;
	sub_82DF3A08(ctx, base);
	// 82664700: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664704: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82664708: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8266470C: 3D008329  lis r8, -0x7cd7
	ctx.r[8].s64 = -2094465024;
	// 82664710: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664714: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82664718: 38A865C4  addi r5, r8, 0x65c4
	ctx.r[5].s64 = ctx.r[8].s64 + 26052;
	// 8266471C: C38908A4  lfs f28, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82664720: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 82664724: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82664728: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8266472C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82664730: 4BF3EB79  bl 0x825a32a8
	ctx.lr = 0x82664734;
	sub_825A32A8(ctx, base);
	// 82664734: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82664738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266473C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664740: 4BF3D031  bl 0x825a1770
	ctx.lr = 0x82664744;
	sub_825A1770(ctx, base);
	// 82664744: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 82664748: 4878ECE1  bl 0x82df3428
	ctx.lr = 0x8266474C;
	sub_82DF3428(ctx, base);
	// 8266474C: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 82664750: 4BC64569  bl 0x822c8cb8
	ctx.lr = 0x82664754;
	sub_822C8CB8(ctx, base);
	// 82664754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664758: 4878ECD1  bl 0x82df3428
	ctx.lr = 0x8266475C;
	sub_82DF3428(ctx, base);
	// 8266475C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664760: 4878ECC9  bl 0x82df3428
	ctx.lr = 0x82664764;
	sub_82DF3428(ctx, base);
	// 82664764: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664768: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266476C: 388BA918  addi r4, r11, -0x56e8
	ctx.r[4].s64 = ctx.r[11].s64 + -22248;
	// 82664770: 4878F299  bl 0x82df3a08
	ctx.lr = 0x82664774;
	sub_82DF3A08(ctx, base);
	// 82664774: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266477C: 388BA90C  addi r4, r11, -0x56f4
	ctx.r[4].s64 = ctx.r[11].s64 + -22260;
	// 82664780: 4878F289  bl 0x82df3a08
	ctx.lr = 0x82664784;
	sub_82DF3A08(ctx, base);
	// 82664784: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664788: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8266478C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82664790: 3D208329  lis r9, -0x7cd7
	ctx.r[9].s64 = -2094465024;
	// 82664794: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664798: 38A965A4  addi r5, r9, 0x65a4
	ctx.r[5].s64 = ctx.r[9].s64 + 26020;
	// 8266479C: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826647A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826647A4: C3EA9A8C  lfs f31, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826647A8: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 826647AC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826647B0: 4BF3EAF9  bl 0x825a32a8
	ctx.lr = 0x826647B4;
	sub_825A32A8(ctx, base);
	// 826647B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826647B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826647BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826647C0: 4BF3CFB1  bl 0x825a1770
	ctx.lr = 0x826647C4;
	sub_825A1770(ctx, base);
	// 826647C4: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826647C8: 4878EC61  bl 0x82df3428
	ctx.lr = 0x826647CC;
	sub_82DF3428(ctx, base);
	// 826647CC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826647D0: 4BC644E9  bl 0x822c8cb8
	ctx.lr = 0x826647D4;
	sub_822C8CB8(ctx, base);
	// 826647D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826647D8: 4878EC51  bl 0x82df3428
	ctx.lr = 0x826647DC;
	sub_82DF3428(ctx, base);
	// 826647DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826647E0: 4878EC49  bl 0x82df3428
	ctx.lr = 0x826647E4;
	sub_82DF3428(ctx, base);
	// 826647E4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826647E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826647EC: 388BA8EC  addi r4, r11, -0x5714
	ctx.r[4].s64 = ctx.r[11].s64 + -22292;
	// 826647F0: 4878F219  bl 0x82df3a08
	ctx.lr = 0x826647F4;
	sub_82DF3A08(ctx, base);
	// 826647F4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826647F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826647FC: 388BA8DC  addi r4, r11, -0x5724
	ctx.r[4].s64 = ctx.r[11].s64 + -22308;
	// 82664800: 4878F209  bl 0x82df3a08
	ctx.lr = 0x82664804;
	sub_82DF3A08(ctx, base);
	// 82664804: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82664808: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 8266480C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82664810: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664814: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82664818: 38AA65AC  addi r5, r10, 0x65ac
	ctx.r[5].s64 = ctx.r[10].s64 + 26028;
	// 8266481C: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 82664820: C02B2B60  lfs f1, 0x2b60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664824: 4BF3EA85  bl 0x825a32a8
	ctx.lr = 0x82664828;
	sub_825A32A8(ctx, base);
	// 82664828: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266482C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82664830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664834: 4BF3CF3D  bl 0x825a1770
	ctx.lr = 0x82664838;
	sub_825A1770(ctx, base);
	// 82664838: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 8266483C: 4878EBED  bl 0x82df3428
	ctx.lr = 0x82664840;
	sub_82DF3428(ctx, base);
	// 82664840: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 82664844: 4BC64475  bl 0x822c8cb8
	ctx.lr = 0x82664848;
	sub_822C8CB8(ctx, base);
	// 82664848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266484C: 4878EBDD  bl 0x82df3428
	ctx.lr = 0x82664850;
	sub_82DF3428(ctx, base);
	// 82664850: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664854: 4878EBD5  bl 0x82df3428
	ctx.lr = 0x82664858;
	sub_82DF3428(ctx, base);
	// 82664858: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266485C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664860: 388BA8B0  addi r4, r11, -0x5750
	ctx.r[4].s64 = ctx.r[11].s64 + -22352;
	// 82664864: 4878F1A5  bl 0x82df3a08
	ctx.lr = 0x82664868;
	sub_82DF3A08(ctx, base);
	// 82664868: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266486C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664870: 388BA8A4  addi r4, r11, -0x575c
	ctx.r[4].s64 = ctx.r[11].s64 + -22364;
	// 82664874: 4878F195  bl 0x82df3a08
	ctx.lr = 0x82664878;
	sub_82DF3A08(ctx, base);
	// 82664878: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266487C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664880: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82664884: 38AB65B0  addi r5, r11, 0x65b0
	ctx.r[5].s64 = ctx.r[11].s64 + 26032;
	// 82664888: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8266488C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82664890: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82664894: 4BF3EA15  bl 0x825a32a8
	ctx.lr = 0x82664898;
	sub_825A32A8(ctx, base);
	// 82664898: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266489C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826648A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826648A4: 4BF3CECD  bl 0x825a1770
	ctx.lr = 0x826648A8;
	sub_825A1770(ctx, base);
	// 826648A8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826648AC: 4878EB7D  bl 0x82df3428
	ctx.lr = 0x826648B0;
	sub_82DF3428(ctx, base);
	// 826648B0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826648B4: 4BC64405  bl 0x822c8cb8
	ctx.lr = 0x826648B8;
	sub_822C8CB8(ctx, base);
	// 826648B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826648BC: 4878EB6D  bl 0x82df3428
	ctx.lr = 0x826648C0;
	sub_82DF3428(ctx, base);
	// 826648C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826648C4: 4878EB65  bl 0x82df3428
	ctx.lr = 0x826648C8;
	sub_82DF3428(ctx, base);
	// 826648C8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826648CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826648D0: 388BA878  addi r4, r11, -0x5788
	ctx.r[4].s64 = ctx.r[11].s64 + -22408;
	// 826648D4: 4878F135  bl 0x82df3a08
	ctx.lr = 0x826648D8;
	sub_82DF3A08(ctx, base);
	// 826648D8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826648DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826648E0: 388BA86C  addi r4, r11, -0x5794
	ctx.r[4].s64 = ctx.r[11].s64 + -22420;
	// 826648E4: 4878F125  bl 0x82df3a08
	ctx.lr = 0x826648E8;
	sub_82DF3A08(ctx, base);
	// 826648E8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826648EC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826648F0: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826648F4: 38AB65B8  addi r5, r11, 0x65b8
	ctx.r[5].s64 = ctx.r[11].s64 + 26040;
	// 826648F8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826648FC: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82664900: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82664904: 4BF3E9A5  bl 0x825a32a8
	ctx.lr = 0x82664908;
	sub_825A32A8(ctx, base);
	// 82664908: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266490C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82664910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664914: 4BF3CE5D  bl 0x825a1770
	ctx.lr = 0x82664918;
	sub_825A1770(ctx, base);
	// 82664918: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 8266491C: 4878EB0D  bl 0x82df3428
	ctx.lr = 0x82664920;
	sub_82DF3428(ctx, base);
	// 82664920: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82664924: 4BC64395  bl 0x822c8cb8
	ctx.lr = 0x82664928;
	sub_822C8CB8(ctx, base);
	// 82664928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266492C: 4878EAFD  bl 0x82df3428
	ctx.lr = 0x82664930;
	sub_82DF3428(ctx, base);
	// 82664930: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664934: 4878EAF5  bl 0x82df3428
	ctx.lr = 0x82664938;
	sub_82DF3428(ctx, base);
	// 82664938: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266493C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664940: 388BA85C  addi r4, r11, -0x57a4
	ctx.r[4].s64 = ctx.r[11].s64 + -22436;
	// 82664944: 4878F0C5  bl 0x82df3a08
	ctx.lr = 0x82664948;
	sub_82DF3A08(ctx, base);
	// 82664948: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266494C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664950: 388BA850  addi r4, r11, -0x57b0
	ctx.r[4].s64 = ctx.r[11].s64 + -22448;
	// 82664954: 4878F0B5  bl 0x82df3a08
	ctx.lr = 0x82664958;
	sub_82DF3A08(ctx, base);
	// 82664958: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266495C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664960: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82664964: 38AB65A8  addi r5, r11, 0x65a8
	ctx.r[5].s64 = ctx.r[11].s64 + 26024;
	// 82664968: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8266496C: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82664970: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82664974: 4BF3E935  bl 0x825a32a8
	ctx.lr = 0x82664978;
	sub_825A32A8(ctx, base);
	// 82664978: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266497C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82664980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664984: 4BF3CDED  bl 0x825a1770
	ctx.lr = 0x82664988;
	sub_825A1770(ctx, base);
	// 82664988: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 8266498C: 4878EA9D  bl 0x82df3428
	ctx.lr = 0x82664990;
	sub_82DF3428(ctx, base);
	// 82664990: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82664994: 4BC64325  bl 0x822c8cb8
	ctx.lr = 0x82664998;
	sub_822C8CB8(ctx, base);
	// 82664998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266499C: 4878EA8D  bl 0x82df3428
	ctx.lr = 0x826649A0;
	sub_82DF3428(ctx, base);
	// 826649A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826649A4: 4878EA85  bl 0x82df3428
	ctx.lr = 0x826649A8;
	sub_82DF3428(ctx, base);
	// 826649A8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826649AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826649B0: 388BA824  addi r4, r11, -0x57dc
	ctx.r[4].s64 = ctx.r[11].s64 + -22492;
	// 826649B4: 4878F055  bl 0x82df3a08
	ctx.lr = 0x826649B8;
	sub_82DF3A08(ctx, base);
	// 826649B8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826649BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826649C0: 388BA818  addi r4, r11, -0x57e8
	ctx.r[4].s64 = ctx.r[11].s64 + -22504;
	// 826649C4: 4878F045  bl 0x82df3a08
	ctx.lr = 0x826649C8;
	sub_82DF3A08(ctx, base);
	// 826649C8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826649CC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826649D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826649D4: 38AB65B4  addi r5, r11, 0x65b4
	ctx.r[5].s64 = ctx.r[11].s64 + 26036;
	// 826649D8: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 826649DC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826649E0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826649E4: 4BF3E8C5  bl 0x825a32a8
	ctx.lr = 0x826649E8;
	sub_825A32A8(ctx, base);
	// 826649E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826649EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826649F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826649F4: 4BF3CD7D  bl 0x825a1770
	ctx.lr = 0x826649F8;
	sub_825A1770(ctx, base);
	// 826649F8: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 826649FC: 4878EA2D  bl 0x82df3428
	ctx.lr = 0x82664A00;
	sub_82DF3428(ctx, base);
	// 82664A00: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 82664A04: 4BC642B5  bl 0x822c8cb8
	ctx.lr = 0x82664A08;
	sub_822C8CB8(ctx, base);
	// 82664A08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664A0C: 4878EA1D  bl 0x82df3428
	ctx.lr = 0x82664A10;
	sub_82DF3428(ctx, base);
	// 82664A10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664A14: 4878EA15  bl 0x82df3428
	ctx.lr = 0x82664A18;
	sub_82DF3428(ctx, base);
	// 82664A18: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664A1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664A20: 388BA7EC  addi r4, r11, -0x5814
	ctx.r[4].s64 = ctx.r[11].s64 + -22548;
	// 82664A24: 4878EFE5  bl 0x82df3a08
	ctx.lr = 0x82664A28;
	sub_82DF3A08(ctx, base);
	// 82664A28: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664A30: 388BA7E0  addi r4, r11, -0x5820
	ctx.r[4].s64 = ctx.r[11].s64 + -22560;
	// 82664A34: 4878EFD5  bl 0x82df3a08
	ctx.lr = 0x82664A38;
	sub_82DF3A08(ctx, base);
	// 82664A38: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82664A3C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664A40: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82664A44: 38AB65BC  addi r5, r11, 0x65bc
	ctx.r[5].s64 = ctx.r[11].s64 + 26044;
	// 82664A48: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82664A4C: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 82664A50: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82664A54: 4BF3E855  bl 0x825a32a8
	ctx.lr = 0x82664A58;
	sub_825A32A8(ctx, base);
	// 82664A58: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82664A5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82664A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664A64: 4BF3CD0D  bl 0x825a1770
	ctx.lr = 0x82664A68;
	sub_825A1770(ctx, base);
	// 82664A68: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 82664A6C: 4878E9BD  bl 0x82df3428
	ctx.lr = 0x82664A70;
	sub_82DF3428(ctx, base);
	// 82664A70: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 82664A74: 4BC64245  bl 0x822c8cb8
	ctx.lr = 0x82664A78;
	sub_822C8CB8(ctx, base);
	// 82664A78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664A7C: 4878E9AD  bl 0x82df3428
	ctx.lr = 0x82664A80;
	sub_82DF3428(ctx, base);
	// 82664A80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82664A84: 4878E9A5  bl 0x82df3428
	ctx.lr = 0x82664A88;
	sub_82DF3428(ctx, base);
	// 82664A88: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 82664A8C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82664A90: 48B44035  bl 0x831a8ac4
	ctx.lr = 0x82664A94;
	sub_831A8A8C(ctx, base);
	// 82664A94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82664A98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82664A9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82664AA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82664AA8 size=76
    let mut pc: u32 = 0x82664AA8;
    'dispatch: loop {
        match pc {
            0x82664AA8 => {
    //   block [0x82664AA8..0x82664AF4)
	// 82664AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82664AB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82664AB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82664AB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664AC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82664AC4: 4BFFEC45  bl 0x82663708
	ctx.lr = 0x82664AC8;
	sub_82663708(ctx, base);
	// 82664AC8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82664ACC: 4182000C  beq 0x82664ad8
	if ctx.cr[0].eq {
	pc = 0x82664AD8; continue 'dispatch;
	}
	// 82664AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664AD4: 4878D905  bl 0x82df23d8
	ctx.lr = 0x82664AD8;
	sub_82DF23D8(ctx, base);
	// 82664AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664ADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82664AE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82664AE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82664AE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82664AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82664AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82664AF8 size=308
    let mut pc: u32 = 0x82664AF8;
    'dispatch: loop {
        match pc {
            0x82664AF8 => {
    //   block [0x82664AF8..0x82664C2C)
	// 82664AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664AFC: 48B4366D  bl 0x831a8168
	ctx.lr = 0x82664B00;
	sub_831A8130(ctx, base);
	// 82664B00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664B04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82664B08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82664B0C: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82664B10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664B14: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82664B18: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82664B1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82664B20: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664B24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82664B28: 4BE45711  bl 0x824aa238
	ctx.lr = 0x82664B2C;
	sub_824AA238(ctx, base);
	// 82664B2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664B30: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82664B34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82664B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82664B3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82664B40: 419A0024  beq cr6, 0x82664b64
	if ctx.cr[6].eq {
	pc = 0x82664B64; continue 'dispatch;
	}
	// 82664B44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82664B48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82664B4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664B50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82664B54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82664B58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82664B5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664B60: 4082FFE8  bne 0x82664b48
	if !ctx.cr[0].eq {
	pc = 0x82664B48; continue 'dispatch;
	}
	// 82664B64: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82664B68: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82664B6C: 48005B7D  bl 0x8266a6e8
	ctx.lr = 0x82664B70;
	sub_8266A6E8(ctx, base);
	// 82664B70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664B74: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82664B78: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82664B7C: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 82664B80: 38A0012B  li r5, 0x12b
	ctx.r[5].s64 = 299;
	// 82664B84: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82664B88: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664B8C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82664B90: 487F3EB1  bl 0x82e58a40
	ctx.lr = 0x82664B94;
	sub_82E58A40(ctx, base);
	// 82664B94: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82664B98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664B9C: 419A0008  beq cr6, 0x82664ba4
	if ctx.cr[6].eq {
	pc = 0x82664BA4; continue 'dispatch;
	}
	// 82664BA0: 4BC5BCF1  bl 0x822c0890
	ctx.lr = 0x82664BA4;
	sub_822C0890(ctx, base);
	// 82664BA4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82664BA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664BAC: 419A0008  beq cr6, 0x82664bb4
	if ctx.cr[6].eq {
	pc = 0x82664BB4; continue 'dispatch;
	}
	// 82664BB0: 4BC5BCE1  bl 0x822c0890
	ctx.lr = 0x82664BB4;
	sub_822C0890(ctx, base);
	// 82664BB4: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82664BB8: 48004DC1  bl 0x82669978
	ctx.lr = 0x82664BBC;
	sub_82669978(ctx, base);
	// 82664BBC: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82664BC0: 48005029  bl 0x82669be8
	ctx.lr = 0x82664BC4;
	sub_82669BE8(ctx, base);
	// 82664BC4: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82664BC8: 3BDF0224  addi r30, r31, 0x224
	ctx.r[30].s64 = ctx.r[31].s64 + 548;
	// 82664BCC: 484E14AD  bl 0x82b46078
	ctx.lr = 0x82664BD0;
	sub_82B46078(ctx, base);
	// 82664BD0: 83DF0224  lwz r30, 0x224(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82664BD4: 93BF0224  stw r29, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[29].u32 ) };
	// 82664BD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82664BDC: 419A0014  beq cr6, 0x82664bf0
	if ctx.cr[6].eq {
	pc = 0x82664BF0; continue 'dispatch;
	}
	// 82664BE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664BE4: 484E1845  bl 0x82b46428
	ctx.lr = 0x82664BE8;
	sub_82B46428(ctx, base);
	// 82664BE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664BEC: 4BC5B67D  bl 0x822c0268
	ctx.lr = 0x82664BF0;
	sub_822C0268(ctx, base);
	// 82664BF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82664BF4: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82664BF8: 3BDF0230  addi r30, r31, 0x230
	ctx.r[30].s64 = ctx.r[31].s64 + 560;
	// 82664BFC: 4816B245  bl 0x827cfe40
	ctx.lr = 0x82664C00;
	sub_827CFE40(ctx, base);
	// 82664C00: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82664C04: 93BF0230  stw r29, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[29].u32 ) };
	// 82664C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664C0C: 419A0018  beq cr6, 0x82664c24
	if ctx.cr[6].eq {
	pc = 0x82664C24; continue 'dispatch;
	}
	// 82664C10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664C14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82664C18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664C1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82664C20: 4E800421  bctrl
	ctx.lr = 0x82664C24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82664C24: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82664C28: 48B43590  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82664C30 size=208
    let mut pc: u32 = 0x82664C30;
    'dispatch: loop {
        match pc {
            0x82664C30 => {
    //   block [0x82664C30..0x82664D00)
	// 82664C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82664C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82664C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82664C40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664C44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82664C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664C4C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82664C50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82664C54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82664C58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82664C5C: 4BFFF34D  bl 0x82663fa8
	ctx.lr = 0x82664C60;
	sub_82663FA8(ctx, base);
	// 82664C60: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664C64: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82664C68: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82664C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82664C70: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82664C74: 419A0024  beq cr6, 0x82664c98
	if ctx.cr[6].eq {
	pc = 0x82664C98; continue 'dispatch;
	}
	// 82664C78: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82664C7C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82664C80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664C84: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82664C88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82664C8C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82664C90: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664C94: 4082FFE8  bne 0x82664c7c
	if !ctx.cr[0].eq {
	pc = 0x82664C7C; continue 'dispatch;
	}
	// 82664C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664C9C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82664CA0: 489A3489  bl 0x83008128
	ctx.lr = 0x82664CA4;
	sub_83008128(ctx, base);
	// 82664CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664CA8: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82664CAC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82664CB0: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 82664CB4: 38A00148  li r5, 0x148
	ctx.r[5].s64 = 328;
	// 82664CB8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82664CBC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664CC0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82664CC4: 487F3D7D  bl 0x82e58a40
	ctx.lr = 0x82664CC8;
	sub_82E58A40(ctx, base);
	// 82664CC8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82664CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664CD0: 419A0008  beq cr6, 0x82664cd8
	if ctx.cr[6].eq {
	pc = 0x82664CD8; continue 'dispatch;
	}
	// 82664CD4: 4BC5BBBD  bl 0x822c0890
	ctx.lr = 0x82664CD8;
	sub_822C0890(ctx, base);
	// 82664CD8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82664CDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664CE0: 419A0008  beq cr6, 0x82664ce8
	if ctx.cr[6].eq {
	pc = 0x82664CE8; continue 'dispatch;
	}
	// 82664CE4: 4BC5BBAD  bl 0x822c0890
	ctx.lr = 0x82664CE8;
	sub_822C0890(ctx, base);
	// 82664CE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82664CEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82664CF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82664CF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82664CF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82664CFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82664D00 size=576
    let mut pc: u32 = 0x82664D00;
    'dispatch: loop {
        match pc {
            0x82664D00 => {
    //   block [0x82664D00..0x82664F40)
	// 82664D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664D04: 48B43469  bl 0x831a816c
	ctx.lr = 0x82664D08;
	sub_831A8130(ctx, base);
	// 82664D08: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82664D0C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664D10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664D14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664D18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82664D1C: C01F01C4  lfs f0, 0x1c4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82664D20: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82664D24: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82664D28: 4199020C  bgt cr6, 0x82664f34
	if ctx.cr[6].gt {
	pc = 0x82664F34; continue 'dispatch;
	}
	// 82664D2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664D30: 489A33F9  bl 0x83008128
	ctx.lr = 0x82664D34;
	sub_83008128(ctx, base);
	// 82664D34: 817F01C8  lwz r11, 0x1c8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(456 as u32) ) } as u64;
	// 82664D38: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82664D3C: 419A01F8  beq cr6, 0x82664f34
	if ctx.cr[6].eq {
	pc = 0x82664F34; continue 'dispatch;
	}
	// 82664D40: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664D44: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82664D48: C00BA440  lfs f0, -0x5bc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82664D4C: D01F01C4  stfs f0, 0x1c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 82664D50: 896A80F4  lbz r11, -0x7f0c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-32524 as u32) ) } as u64;
	// 82664D54: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82664D58: 408200C8  bne 0x82664e20
	if !ctx.cr[0].eq {
	pc = 0x82664E20; continue 'dispatch;
	}
	// 82664D5C: C01F0188  lfs f0, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82664D60: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82664D64: 409800BC  bge cr6, 0x82664e20
	if !ctx.cr[6].lt {
	pc = 0x82664E20; continue 'dispatch;
	}
	// 82664D68: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82664D6C: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82664D70: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82664D74: C02B65C8  lfs f1, 0x65c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26056 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664D78: 48005E19  bl 0x8266ab90
	ctx.lr = 0x82664D7C;
	sub_8266AB90(ctx, base);
	// 82664D7C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82664D80: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82664D84: 388B65CC  addi r4, r11, 0x65cc
	ctx.r[4].s64 = ctx.r[11].s64 + 26060;
	// 82664D88: 4BFFF299  bl 0x82664020
	ctx.lr = 0x82664D8C;
	sub_82664020(ctx, base);
	// 82664D8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664D90: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82664D94: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82664D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82664D9C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82664DA0: 419A0024  beq cr6, 0x82664dc4
	if ctx.cr[6].eq {
	pc = 0x82664DC4; continue 'dispatch;
	}
	// 82664DA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82664DA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82664DAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664DB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82664DB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82664DB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82664DBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664DC0: 4082FFE8  bne 0x82664da8
	if !ctx.cr[0].eq {
	pc = 0x82664DA8; continue 'dispatch;
	}
	// 82664DC4: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82664DC8: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82664DCC: 4800591D  bl 0x8266a6e8
	ctx.lr = 0x82664DD0;
	sub_8266A6E8(ctx, base);
	// 82664DD0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664DD4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82664DD8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82664DDC: 388BA520  addi r4, r11, -0x5ae0
	ctx.r[4].s64 = ctx.r[11].s64 + -23264;
	// 82664DE0: 38A0016D  li r5, 0x16d
	ctx.r[5].s64 = 365;
	// 82664DE4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82664DE8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82664DEC: 487F3C55  bl 0x82e58a40
	ctx.lr = 0x82664DF0;
	sub_82E58A40(ctx, base);
	// 82664DF0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82664DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664DF8: 419A0008  beq cr6, 0x82664e00
	if ctx.cr[6].eq {
	pc = 0x82664E00; continue 'dispatch;
	}
	// 82664DFC: 4BC5BA95  bl 0x822c0890
	ctx.lr = 0x82664E00;
	sub_822C0890(ctx, base);
	// 82664E00: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82664E04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664E08: 419A0008  beq cr6, 0x82664e10
	if ctx.cr[6].eq {
	pc = 0x82664E10; continue 'dispatch;
	}
	// 82664E0C: 4BC5BA85  bl 0x822c0890
	ctx.lr = 0x82664E10;
	sub_822C0890(ctx, base);
	// 82664E10: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82664E14: C00B65C0  lfs f0, 0x65c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82664E18: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82664E1C: 48000018  b 0x82664e34
	pc = 0x82664E34; continue 'dispatch;
	// 82664E20: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82664E24: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82664E28: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82664E2C: C02B65C8  lfs f1, 0x65c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26056 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664E30: 48005D61  bl 0x8266ab90
	ctx.lr = 0x82664E34;
	sub_8266AB90(ctx, base);
	// 82664E34: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 82664E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82664E3C: 4BFFCC25  bl 0x82661a60
	ctx.lr = 0x82664E40;
	sub_82661A60(ctx, base);
	// 82664E40: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82664E44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664E48: 388BA610  addi r4, r11, -0x59f0
	ctx.r[4].s64 = ctx.r[11].s64 + -23024;
	// 82664E4C: 4878EBBD  bl 0x82df3a08
	ctx.lr = 0x82664E50;
	sub_82DF3A08(ctx, base);
	// 82664E50: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82664E54: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82664E58: 487F5879  bl 0x82e5a6d0
	ctx.lr = 0x82664E5C;
	sub_82E5A6D0(ctx, base);
	// 82664E5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82664E60: 4878E4A9  bl 0x82df3308
	ctx.lr = 0x82664E64;
	sub_82DF3308(ctx, base);
	// 82664E64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82664E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664E6C: 4878E5BD  bl 0x82df3428
	ctx.lr = 0x82664E70;
	sub_82DF3428(ctx, base);
	// 82664E70: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82664E74: 41820030  beq 0x82664ea4
	if ctx.cr[0].eq {
	pc = 0x82664EA4; continue 'dispatch;
	}
	// 82664E78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82664E7C: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82664E80: 4814E3D9  bl 0x827b3258
	ctx.lr = 0x82664E84;
	sub_827B3258(ctx, base);
	// 82664E84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664E88: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82664E8C: C02B093C  lfs f1, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664E90: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82664E94: 40990010  ble cr6, 0x82664ea4
	if !ctx.cr[6].gt {
	pc = 0x82664EA4; continue 'dispatch;
	}
	// 82664E98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82664E9C: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82664EA0: 48005CF1  bl 0x8266ab90
	ctx.lr = 0x82664EA4;
	sub_8266AB90(ctx, base);
	// 82664EA4: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82664EA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82664EAC: 41820034  beq 0x82664ee0
	if ctx.cr[0].eq {
	pc = 0x82664EE0; continue 'dispatch;
	}
	// 82664EB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664EB4: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82664EB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82664EBC: 38AAA9B4  addi r5, r10, -0x564c
	ctx.r[5].s64 = ctx.r[10].s64 + -22092;
	// 82664EC0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82664EC4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82664EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82664ECC: 4E800421  bctrl
	ctx.lr = 0x82664ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82664ED0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82664ED4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664ED8: 419A0008  beq cr6, 0x82664ee0
	if ctx.cr[6].eq {
	pc = 0x82664EE0; continue 'dispatch;
	}
	// 82664EDC: 4BC5B9B5  bl 0x822c0890
	ctx.lr = 0x82664EE0;
	sub_822C0890(ctx, base);
	// 82664EE0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82664EE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82664EE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82664EEC: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 82664EF0: 4878CD09  bl 0x82df1bf8
	ctx.lr = 0x82664EF4;
	sub_82DF1BF8(ctx, base);
	// 82664EF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82664EF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82664EFC: 388B78E8  addi r4, r11, 0x78e8
	ctx.r[4].s64 = ctx.r[11].s64 + 30952;
	// 82664F00: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82664F04: 4879462D  bl 0x82df9530
	ctx.lr = 0x82664F08;
	sub_82DF9530(ctx, base);
	// 82664F08: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82664F0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664F10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82664F14: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664F18: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82664F1C: 4BEC1535  bl 0x82526450
	ctx.lr = 0x82664F20;
	sub_82526450(ctx, base);
	// 82664F20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82664F24: 4878CD6D  bl 0x82df1c90
	ctx.lr = 0x82664F28;
	sub_82DF1C90(ctx, base);
	// 82664F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664F2C: 489A31FD  bl 0x83008128
	ctx.lr = 0x82664F30;
	sub_83008128(ctx, base);
	// 82664F30: 907F01C8  stw r3, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[3].u32 ) };
	// 82664F34: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82664F38: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82664F3C: 48B43280  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82664F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82664F40 size=308
    let mut pc: u32 = 0x82664F40;
    'dispatch: loop {
        match pc {
            0x82664F40 => {
    //   block [0x82664F40..0x82665074)
	// 82664F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82664F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82664F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82664F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82664F50: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82664F54: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82664F58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82664F5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82664F60: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82664F64: 48004A15  bl 0x82669978
	ctx.lr = 0x82664F68;
	sub_82669978(ctx, base);
	// 82664F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82664F6C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82664F70: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82664F74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82664F78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82664F7C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82664F80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82664F84: 4BE452B5  bl 0x824aa238
	ctx.lr = 0x82664F88;
	sub_824AA238(ctx, base);
	// 82664F88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82664F8C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82664F90: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82664F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82664F98: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82664F9C: 419A0024  beq cr6, 0x82664fc0
	if ctx.cr[6].eq {
	pc = 0x82664FC0; continue 'dispatch;
	}
	// 82664FA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82664FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82664FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664FAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82664FB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82664FB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82664FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82664FBC: 4082FFE8  bne 0x82664fa4
	if !ctx.cr[0].eq {
	pc = 0x82664FA4; continue 'dispatch;
	}
	// 82664FC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82664FC4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82664FC8: 489A3161  bl 0x83008128
	ctx.lr = 0x82664FCC;
	sub_83008128(ctx, base);
	// 82664FCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82664FD0: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82664FD4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82664FD8: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 82664FDC: 38A001FB  li r5, 0x1fb
	ctx.r[5].s64 = 507;
	// 82664FE0: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82664FE4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82664FE8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82664FEC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82664FF0: 487F3A51  bl 0x82e58a40
	ctx.lr = 0x82664FF4;
	sub_82E58A40(ctx, base);
	// 82664FF4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82664FF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82664FFC: 419A0008  beq cr6, 0x82665004
	if ctx.cr[6].eq {
	pc = 0x82665004; continue 'dispatch;
	}
	// 82665000: 4BC5B891  bl 0x822c0890
	ctx.lr = 0x82665004;
	sub_822C0890(ctx, base);
	// 82665004: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82665008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266500C: 419A0008  beq cr6, 0x82665014
	if ctx.cr[6].eq {
	pc = 0x82665014; continue 'dispatch;
	}
	// 82665010: 4BC5B881  bl 0x822c0890
	ctx.lr = 0x82665014;
	sub_822C0890(ctx, base);
	// 82665014: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82665018: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266501C: 388BA9CC  addi r4, r11, -0x5634
	ctx.r[4].s64 = ctx.r[11].s64 + -22068;
	// 82665020: 4878E9E9  bl 0x82df3a08
	ctx.lr = 0x82665024;
	sub_82DF3A08(ctx, base);
	// 82665024: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82665028: 389F00E8  addi r4, r31, 0xe8
	ctx.r[4].s64 = ctx.r[31].s64 + 232;
	// 8266502C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82665030: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82665034: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82665038: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8266503C: 487F9925  bl 0x82e5e960
	ctx.lr = 0x82665040;
	sub_82E5E960(ctx, base);
	// 82665040: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82665044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82665048: 419A0008  beq cr6, 0x82665050
	if ctx.cr[6].eq {
	pc = 0x82665050; continue 'dispatch;
	}
	// 8266504C: 4BC5B845  bl 0x822c0890
	ctx.lr = 0x82665050;
	sub_822C0890(ctx, base);
	// 82665050: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82665054: 997F01A4  stb r11, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 82665058: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8266505C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82665060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82665064: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82665068: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266506C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82665070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82665078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82665078 size=892
    let mut pc: u32 = 0x82665078;
    'dispatch: loop {
        match pc {
            0x82665078 => {
    //   block [0x82665078..0x826653F4)
	// 82665078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266507C: 48B430D9  bl 0x831a8154
	ctx.lr = 0x82665080;
	sub_831A8130(ctx, base);
	// 82665080: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82665084: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82665088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266508C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82665090: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82665094: 480048E5  bl 0x82669978
	ctx.lr = 0x82665098;
	sub_82669978(ctx, base);
	// 82665098: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266509C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826650A0: 3BABA520  addi r29, r11, -0x5ae0
	ctx.r[29].s64 = ctx.r[11].s64 + -23264;
	// 826650A4: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826650A8: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 826650AC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826650B0: 419800E8  blt cr6, 0x82665198
	if ctx.cr[6].lt {
	pc = 0x82665198; continue 'dispatch;
	}
	// 826650B4: 409A0264  bne cr6, 0x82665318
	if !ctx.cr[6].eq {
	pc = 0x82665318; continue 'dispatch;
	}
	// 826650B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826650BC: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826650C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826650C4: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826650C8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826650CC: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 826650D0: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 826650D4: 3B810052  addi r28, r1, 0x52
	ctx.r[28].s64 = ctx.r[1].s64 + 82;
	// 826650D8: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 826650DC: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 826650E0: 3B410051  addi r26, r1, 0x51
	ctx.r[26].s64 = ctx.r[1].s64 + 81;
	// 826650E4: 3B210054  addi r25, r1, 0x54
	ctx.r[25].s64 = ctx.r[1].s64 + 84;
	// 826650E8: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 826650EC: 4814E16D  bl 0x827b3258
	ctx.lr = 0x826650F0;
	sub_827B3258(ctx, base);
	// 826650F0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 826650F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826650F8: 4BEAC9F1  bl 0x82511ae8
	ctx.lr = 0x826650FC;
	sub_82511AE8(ctx, base);
	// 826650FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82665100: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82665104: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 82665108: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8266510C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82665110: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82665114: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82665118: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8266511C: 4BD2D985  bl 0x82392aa0
	ctx.lr = 0x82665120;
	sub_82392AA0(ctx, base);
	// 82665120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82665124: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82665128: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266512C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82665130: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82665134: 419A0024  beq cr6, 0x82665158
	if ctx.cr[6].eq {
	pc = 0x82665158; continue 'dispatch;
	}
	// 82665138: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8266513C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82665140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82665144: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82665148: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8266514C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82665150: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82665154: 4082FFE8  bne 0x8266513c
	if !ctx.cr[0].eq {
	pc = 0x8266513C; continue 'dispatch;
	}
	// 82665158: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8266515C: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82665160: 48005589  bl 0x8266a6e8
	ctx.lr = 0x82665164;
	sub_8266A6E8(ctx, base);
	// 82665164: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82665168: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8266516C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82665170: 38A00231  li r5, 0x231
	ctx.r[5].s64 = 561;
	// 82665174: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82665178: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8266517C: 487F38C5  bl 0x82e58a40
	ctx.lr = 0x82665180;
	sub_82E58A40(ctx, base);
	// 82665180: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82665184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82665188: 419A0008  beq cr6, 0x82665190
	if ctx.cr[6].eq {
	pc = 0x82665190; continue 'dispatch;
	}
	// 8266518C: 4BC5B705  bl 0x822c0890
	ctx.lr = 0x82665190;
	sub_822C0890(ctx, base);
	// 82665190: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82665194: 48000178  b 0x8266530c
	pc = 0x8266530C; continue 'dispatch;
	// 82665198: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 8266519C: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826651A0: 4814E0B9  bl 0x827b3258
	ctx.lr = 0x826651A4;
	sub_827B3258(ctx, base);
	// 826651A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826651A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826651AC: 488182A5  bl 0x82e7d450
	ctx.lr = 0x826651B0;
	sub_82E7D450(ctx, base);
	// 826651B0: D3E10074  stfs f31, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826651B4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826651B8: 488182D9  bl 0x82e7d490
	ctx.lr = 0x826651BC;
	sub_82E7D490(ctx, base);
	// 826651BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826651C0: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826651C4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 826651C8: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826651CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826651D0: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826651D4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826651D8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826651DC: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826651E0: 48818141  bl 0x82e7d320
	ctx.lr = 0x826651E4;
	sub_82E7D320(ctx, base);
	// 826651E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826651E8: C1BE001C  lfs f13, 0x1c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826651EC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 826651F0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826651F4: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826651F8: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826651FC: 48817A45  bl 0x82e7cc40
	ctx.lr = 0x82665200;
	sub_82E7CC40(ctx, base);
	// 82665200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82665204: D3E10054  stfs f31, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82665208: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266520C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82665210: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82665214: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82665218: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 8266521C: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82665220: 48816C79  bl 0x82e7be98
	ctx.lr = 0x82665224;
	sub_82E7BE98(ctx, base);
	// 82665224: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82665228: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8266522C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82665230: 48816A99  bl 0x82e7bcc8
	ctx.lr = 0x82665234;
	sub_82E7BCC8(ctx, base);
	// 82665234: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82665238: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 8266523C: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 82665240: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82665244: 3B810051  addi r28, r1, 0x51
	ctx.r[28].s64 = ctx.r[1].s64 + 81;
	// 82665248: 13FE5C07  vcmpneb. (lvlx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266524C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826653F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826653F8 size=240
    let mut pc: u32 = 0x826653F8;
    'dispatch: loop {
        match pc {
            0x826653F8 => {
    //   block [0x826653F8..0x826654E8)
	// 826653F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826653FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82665400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82665404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82665408: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266540C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82665410: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82665414: 809F0150  lwz r4, 0x150(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82665418: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8266541C: 419A000C  beq cr6, 0x82665428
	if ctx.cr[6].eq {
	pc = 0x82665428; continue 'dispatch;
	}
	// 82665420: 4BEAD6E9  bl 0x82512b08
	ctx.lr = 0x82665424;
	sub_82512B08(ctx, base);
	// 82665424: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 82665428: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8266542C: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82665430: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82665434: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82665438: 997F0194  stb r11, 0x194(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u8 ) };
	// 8266543C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82665440: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82665444: 4BE44DF5  bl 0x824aa238
	ctx.lr = 0x82665448;
	sub_824AA238(ctx, base);
	// 82665448: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266544C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82665450: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82665454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82665458: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8266545C: 419A0024  beq cr6, 0x82665480
	if ctx.cr[6].eq {
	pc = 0x82665480; continue 'dispatch;
	}
	// 82665460: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82665464: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82665468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266546C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82665470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82665474: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82665478: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266547C: 4082FFE8  bne 0x82665464
	if !ctx.cr[0].eq {
	pc = 0x82665464; continue 'dispatch;
	}
	// 82665480: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82665484: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82665488: 48005261  bl 0x8266a6e8
	ctx.lr = 0x8266548C;
	sub_8266A6E8(ctx, base);
	// 8266548C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82665490: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82665494: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82665498: 388AA520  addi r4, r10, -0x5ae0
	ctx.r[4].s64 = ctx.r[10].s64 + -23264;
	// 8266549C: 38A00264  li r5, 0x264
	ctx.r[5].s64 = 612;
	// 826654A0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826654A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826654A8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826654AC: 487F3595  bl 0x82e58a40
	ctx.lr = 0x826654B0;
	sub_82E58A40(ctx, base);
	// 826654B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826654B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826654B8: 419A0008  beq cr6, 0x826654c0
	if ctx.cr[6].eq {
	pc = 0x826654C0; continue 'dispatch;
	}
	// 826654BC: 4BC5B3D5  bl 0x822c0890
	ctx.lr = 0x826654C0;
	sub_822C0890(ctx, base);
	// 826654C0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826654C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826654C8: 419A0008  beq cr6, 0x826654d0
	if ctx.cr[6].eq {
	pc = 0x826654D0; continue 'dispatch;
	}
	// 826654CC: 4BC5B3C5  bl 0x822c0890
	ctx.lr = 0x826654D0;
	sub_822C0890(ctx, base);
	// 826654D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826654D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826654D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826654DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826654E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826654E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826654E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826654E8 size=516
    let mut pc: u32 = 0x826654E8;
    'dispatch: loop {
        match pc {
            0x826654E8 => {
    //   block [0x826654E8..0x826656EC)
	// 826654E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826654EC: 48B42C7D  bl 0x831a8168
	ctx.lr = 0x826654F0;
	sub_831A8130(ctx, base);
	// 826654F0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 826654F4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826654F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826654FC: 807E0190  lwz r3, 0x190(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(400 as u32) ) } as u64;
	// 82665500: 48004479  bl 0x82669978
	ctx.lr = 0x82665504;
	sub_82669978(ctx, base);
	// 82665504: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82665508: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266550C: 3BABA520  addi r29, r11, -0x5ae0
	ctx.r[29].s64 = ctx.r[11].s64 + -23264;
	// 82665510: 38A00270  li r5, 0x270
	ctx.r[5].s64 = 624;
	// 82665514: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82665518: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 8266551C: 4878CECD  bl 0x82df23e8
	ctx.lr = 0x82665520;
	sub_82DF23E8(ctx, base);
	// 82665520: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82665524: 41820010  beq 0x82665534
	if ctx.cr[0].eq {
	pc = 0x82665534; continue 'dispatch;
	}
	// 82665528: 4BE0FA39  bl 0x82474f60
	ctx.lr = 0x8266552C;
	sub_82474F60(ctx, base);
	// 8266552C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82665530: 48000008  b 0x82665538
	pc = 0x82665538; continue 'dispatch;
	// 82665534: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82665538: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 8266553C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82665540: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82665544: 4BDFFC2D  bl 0x82465170
	ctx.lr = 0x82665548;
	sub_82465170(ctx, base);
	// 82665548: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266554C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82665550: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82665554: 4BC5AAAD  bl 0x822c0000
	ctx.lr = 0x82665558;
	sub_822C0000(ctx, base);
	// 82665558: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266555C: 394007D3  li r10, 0x7d3
	ctx.r[10].s64 = 2003;
	// 82665560: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82665564: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82665568: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 8266556C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82665570: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82665574: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82665578: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8266557C: 480041DD  bl 0x82669758
	ctx.lr = 0x82665580;
	sub_82669758(ctx, base);
	// 82665580: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82665584: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82665588: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266558C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82665590: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82665594: 419A0024  beq cr6, 0x826655b8
	if ctx.cr[6].eq {
	pc = 0x826655B8; continue 'dispatch;
	}
	// 82665598: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8266559C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826655A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826655A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826655A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826655AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826655B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826655B4: 4082FFE8  bne 0x8266559c
	if !ctx.cr[0].eq {
	pc = 0x8266559C; continue 'dispatch;
	}
	// 826655B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826655BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826655C0: 4BEA9F59  bl 0x8250f518
	ctx.lr = 0x826655C4;
	sub_8250F518(ctx, base);
	// 826655C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826655C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826655CC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 826655D0: 409A0008  bne cr6, 0x826655d8
	if !ctx.cr[6].eq {
	pc = 0x826655D8; continue 'dispatch;
	}
	// 826655D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826655D8: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 826655DC: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 826655E0: 4BEC2A71  bl 0x82528050
	ctx.lr = 0x826655E4;
	sub_82528050(ctx, base);
	// 826655E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826655E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826655EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826655F0: 38A00271  li r5, 0x271
	ctx.r[5].s64 = 625;
	// 826655F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826655F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 826655FC: 487F3445  bl 0x82e58a40
	ctx.lr = 0x82665600;
	sub_82E58A40(ctx, base);
	// 82665600: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82665604: 4878C68D  bl 0x82df1c90
	ctx.lr = 0x82665608;
	sub_82DF1C90(ctx, base);
	// 82665608: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8266560C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82665610: 419A0008  beq cr6, 0x82665618
	if ctx.cr[6].eq {
	pc = 0x82665618; continue 'dispatch;
	}
	// 82665614: 4BC5B27D  bl 0x822c0890
	ctx.lr = 0x82665618;
	sub_822C0890(ctx, base);
	// 82665618: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8266561C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82665620: 419A0008  beq cr6, 0x82665628
	if ctx.cr[6].eq {
	pc = 0x82665628; continue 'dispatch;
	}
	// 82665624: 4BC5B26D  bl 0x822c0890
	ctx.lr = 0x82665628;
	sub_822C0890(ctx, base);
	// 82665628: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8266562C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82665630: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82665634: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82665638: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 8266563C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82665640: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82665644: 4BE44BF5  bl 0x824aa238
	ctx.lr = 0x82665648;
	sub_824AA238(ctx, base);
	// 82665648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266564C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82665650: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82665654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82665658: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8266565C: 419A0024  beq cr6, 0x82665680
	if ctx.cr[6].eq {
	pc = 0x82665680; continue 'dispatch;
	}
	// 82665660: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82665664: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82665668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266566C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82665670: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82665674: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82665678: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266567C: 4082FFE8  bne 0x82665664
	if !ctx.cr[0].eq {
	pc = 0x82665664; continue 'dispatch;
	}
	// 82665680: 807E018C  lwz r3, 0x18c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(396 as u32) ) } as u64;
	// 82665684: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 82665688: 48005061  bl 0x8266a6e8
	ctx.lr = 0x8266568C;
	sub_8266A6E8(ctx, base);
	// 8266568C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82665690: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82665694: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82665698: 38A00272  li r5, 0x272
	ctx.r[5].s64 = 626;
	// 8266569C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826656A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 826656A4: 487F339D  bl 0x82e58a40
	ctx.lr = 0x826656A8;
	sub_82E58A40(ctx, base);
	// 826656A8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826656AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826656B0: 419A0008  beq cr6, 0x826656b8
	if ctx.cr[6].eq {
	pc = 0x826656B8; continue 'dispatch;
	}
	// 826656B4: 4BC5B1DD  bl 0x822c0890
	ctx.lr = 0x826656B8;
	sub_822C0890(ctx, base);
	// 826656B8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826656BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826656C0: 419A0008  beq cr6, 0x826656c8
	if ctx.cr[6].eq {
	pc = 0x826656C8; continue 'dispatch;
	}
	// 826656C4: 4BC5B1CD  bl 0x822c0890
	ctx.lr = 0x826656C8;
	sub_822C0890(ctx, base);
	// 826656C8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826656CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826656D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826656D4: 997E01A4  stb r11, 0x1a4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(420 as u32), ctx.r[11].u8 ) };
	// 826656D8: 419A0008  beq cr6, 0x826656e0
	if ctx.cr[6].eq {
	pc = 0x826656E0; continue 'dispatch;
	}
	// 826656DC: 4BC5B1B5  bl 0x822c0890
	ctx.lr = 0x826656E0;
	sub_822C0890(ctx, base);
	// 826656E0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826656E4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826656E8: 48B42AD0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826656F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826656F0 size=604
    let mut pc: u32 = 0x826656F0;
    'dispatch: loop {
        match pc {
            0x826656F0 => {
    //   block [0x826656F0..0x8266594C)
	// 826656F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826656F4: 48B42A71  bl 0x831a8164
	ctx.lr = 0x826656F8;
	sub_831A8130(ctx, base);
	// 826656F8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826656FC: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82665950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82665950 size=768
    let mut pc: u32 = 0x82665950;
    'dispatch: loop {
        match pc {
            0x82665950 => {
    //   block [0x82665950..0x82665C50)
	// 82665950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82665954: 48B42815  bl 0x831a8168
	ctx.lr = 0x82665958;
	sub_831A8130(ctx, base);
	// 82665958: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8266595C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82665960: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82665964: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82665968: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266596C: 390B6910  addi r8, r11, 0x6910
	ctx.r[8].s64 = ctx.r[11].s64 + 26896;
	// 82665970: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82665974: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 82665978: 38C100E0  addi r6, r1, 0xe0
	ctx.r[6].s64 = ctx.r[1].s64 + 224;
	// 8266597C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82665980: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82665984: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82665988: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 8266598C: C3C908A8  lfs f30, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82665990: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 82665994: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82665998: D3E100C0  stfs f31, 0xc0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8266599C: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 826659A0: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 826659A4: 996100B0  stb r11, 0xb0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u8 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82665C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82665C50 size=944
    let mut pc: u32 = 0x82665C50;
    'dispatch: loop {
        match pc {
            0x82665C50 => {
    //   block [0x82665C50..0x82666000)
	// 82665C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82665C54: 48B42511  bl 0x831a8164
	ctx.lr = 0x82665C58;
	sub_831A8130(ctx, base);
	// 82665C58: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82665C5C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82665C60: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82666000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82666000 size=820
    let mut pc: u32 = 0x82666000;
    'dispatch: loop {
        match pc {
            0x82666000 => {
    //   block [0x82666000..0x82666334)
	// 82666000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82666004: 48B4215D  bl 0x831a8160
	ctx.lr = 0x82666008;
	sub_831A8130(ctx, base);
	// 82666008: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8266600C: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82666010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82666014: 4BFFBB9D  bl 0x82661bb0
	ctx.lr = 0x82666018;
	sub_82661BB0(ctx, base);
	// 82666018: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 8266601C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82666020: 41820290  beq 0x826662b0
	if ctx.cr[0].eq {
	pc = 0x826662B0; continue 'dispatch;
	}
	// 82666024: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82666028: 813F023C  lwz r9, 0x23c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8266602C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82666030: 3BDF023C  addi r30, r31, 0x23c
	ctx.r[30].s64 = ctx.r[31].s64 + 572;
	// 82666034: 3B8BA520  addi r28, r11, -0x5ae0
	ctx.r[28].s64 = ctx.r[11].s64 + -23264;
	// 82666038: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8266603C: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82666040: 409A008C  bne cr6, 0x826660cc
	if !ctx.cr[6].eq {
	pc = 0x826660CC; continue 'dispatch;
	}
	// 82666044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82666048: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8266604C: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82666050: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82666054: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82666058: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8266605C: C00B6144  lfs f0, 0x6144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82666060: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82666064: 48815F75  bl 0x82e7bfd8
	ctx.lr = 0x82666068;
	sub_82E7BFD8(ctx, base);
	// 82666068: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266606C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82666070: 38A00419  li r5, 0x419
	ctx.r[5].s64 = 1049;
	// 82666074: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82666078: 4878C371  bl 0x82df23e8
	ctx.lr = 0x8266607C;
	sub_82DF23E8(ctx, base);
	// 8266607C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82666080: 41820014  beq 0x82666094
	if ctx.cr[0].eq {
	pc = 0x82666094; continue 'dispatch;
	}
	// 82666084: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82666088: 487AD069  bl 0x82e130f0
	ctx.lr = 0x8266608C;
	sub_82E130F0(ctx, base);
	// 8266608C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82666090: 48000008  b 0x82666098
	pc = 0x82666098; continue 'dispatch;
	// 82666094: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82666098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266609C: 4BC7BCB5  bl 0x822e1d50
	ctx.lr = 0x826660A0;
	sub_822E1D50(ctx, base);
	// 826660A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826660A4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826660A8: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826660AC: 4BEAC06D  bl 0x82512118
	ctx.lr = 0x826660B0;
	sub_82512118(ctx, base);
	// 826660B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826660B4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826660B8: 487ACD79  bl 0x82e12e30
	ctx.lr = 0x826660BC;
	sub_82E12E30(ctx, base);
	// 826660BC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826660C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826660C4: 419A0008  beq cr6, 0x826660cc
	if ctx.cr[6].eq {
	pc = 0x826660CC; continue 'dispatch;
	}
	// 826660C8: 4BC5A7C9  bl 0x822c0890
	ctx.lr = 0x826660CC;
	sub_822C0890(ctx, base);
	// 826660CC: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 826660D0: 3BBF0244  addi r29, r31, 0x244
	ctx.r[29].s64 = ctx.r[31].s64 + 580;
	// 826660D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826660D8: 409A008C  bne cr6, 0x82666164
	if !ctx.cr[6].eq {
	pc = 0x82666164; continue 'dispatch;
	}
	// 826660DC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826660E0: D3E10074  stfs f31, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826660E4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826660E8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826660EC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 826660F0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826660F4: C00BAA0C  lfs f0, -0x55f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22004 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826660F8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826660FC: 48815EDD  bl 0x82e7bfd8
	ctx.lr = 0x82666100;
	sub_82E7BFD8(ctx, base);
	// 82666100: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82666104: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82666108: 38A0041F  li r5, 0x41f
	ctx.r[5].s64 = 1055;
	// 8266610C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82666110: 4878C2D9  bl 0x82df23e8
	ctx.lr = 0x82666114;
	sub_82DF23E8(ctx, base);
	// 82666114: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82666118: 41820014  beq 0x8266612c
	if ctx.cr[0].eq {
	pc = 0x8266612C; continue 'dispatch;
	}
	// 8266611C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82666120: 487ACFD1  bl 0x82e130f0
	ctx.lr = 0x82666124;
	sub_82E130F0(ctx, base);
	// 82666124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82666128: 48000008  b 0x82666130
	pc = 0x82666130; continue 'dispatch;
	// 8266612C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82666130: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82666134: 4BC7BC1D  bl 0x822e1d50
	ctx.lr = 0x82666138;
	sub_822E1D50(ctx, base);
	// 82666138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266613C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82666140: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666144: 4BEABFD5  bl 0x82512118
	ctx.lr = 0x82666148;
	sub_82512118(ctx, base);
	// 82666148: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266614C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666150: 487ACCE1  bl 0x82e12e30
	ctx.lr = 0x82666154;
	sub_82E12E30(ctx, base);
	// 82666154: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82666158: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266615C: 419A0008  beq cr6, 0x82666164
	if ctx.cr[6].eq {
	pc = 0x82666164; continue 'dispatch;
	}
	// 82666160: 4BC5A731  bl 0x822c0890
	ctx.lr = 0x82666164;
	sub_822C0890(ctx, base);
	// 82666164: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82666168: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266616C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82666170: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82666174: 3B8B1F80  addi r28, r11, 0x1f80
	ctx.r[28].s64 = ctx.r[11].s64 + 8064;
	// 82666178: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8266617C: 419A00A0  beq cr6, 0x8266621c
	if ctx.cr[6].eq {
	pc = 0x8266621C; continue 'dispatch;
	}
	// 82666180: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82666184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666188: 4878D881  bl 0x82df3a08
	ctx.lr = 0x8266618C;
	sub_82DF3A08(ctx, base);
	// 8266618C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82666190: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666194: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666198: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8266619C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826661A0: 419A0024  beq cr6, 0x826661c4
	if ctx.cr[6].eq {
	pc = 0x826661C4; continue 'dispatch;
	}
	// 826661A4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826661A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826661AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826661B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826661B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826661B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826661BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826661C0: 4082FFE8  bne 0x826661a8
	if !ctx.cr[0].eq {
	pc = 0x826661A8; continue 'dispatch;
	}
	// 826661C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826661C8: 83DF0230  lwz r30, 0x230(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826661CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826661D0: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 826661D4: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 826661D8: 4BEA92F1  bl 0x8250f4c8
	ctx.lr = 0x826661DC;
	sub_8250F4C8(ctx, base);
	// 826661DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826661E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826661E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826661E8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 826661EC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 826661F0: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 826661F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826661F8: 4816A141  bl 0x827d0338
	ctx.lr = 0x826661FC;
	sub_827D0338(ctx, base);
	// 826661FC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82666200: 907F0234  stw r3, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 82666204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666208: 419A000C  beq cr6, 0x82666214
	if ctx.cr[6].eq {
	pc = 0x82666214; continue 'dispatch;
	}
	// 8266620C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82666210: 4BC5A681  bl 0x822c0890
	ctx.lr = 0x82666214;
	sub_822C0890(ctx, base);
	// 82666214: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666218: 4878D211  bl 0x82df3428
	ctx.lr = 0x8266621C;
	sub_82DF3428(ctx, base);
	// 8266621C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666224: 419A0104  beq cr6, 0x82666328
	if ctx.cr[6].eq {
	pc = 0x82666328; continue 'dispatch;
	}
	// 82666228: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266622C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666230: 4878D7D9  bl 0x82df3a08
	ctx.lr = 0x82666234;
	sub_82DF3A08(ctx, base);
	// 82666234: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82666238: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266623C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666240: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82666244: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82666248: 419A0024  beq cr6, 0x8266626c
	if ctx.cr[6].eq {
	pc = 0x8266626C; continue 'dispatch;
	}
	// 8266624C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82666250: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82666254: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82666258: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8266625C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82666260: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82666264: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82666268: 4082FFE8  bne 0x82666250
	if !ctx.cr[0].eq {
	pc = 0x82666250; continue 'dispatch;
	}
	// 8266626C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82666270: 83DF0230  lwz r30, 0x230(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82666274: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82666278: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8266627C: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82666280: 4BEA9249  bl 0x8250f4c8
	ctx.lr = 0x82666284;
	sub_8250F4C8(ctx, base);
	// 82666284: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82666288: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8266628C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82666290: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82666294: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82666298: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 8266629C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826662A0: 4816A099  bl 0x827d0338
	ctx.lr = 0x826662A4;
	sub_827D0338(ctx, base);
	// 826662A4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826662A8: 907F0238  stw r3, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[3].u32 ) };
	// 826662AC: 48000064  b 0x82666310
	pc = 0x82666310; continue 'dispatch;
	// 826662B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826662B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826662B8: 388B6BD0  addi r4, r11, 0x6bd0
	ctx.r[4].s64 = ctx.r[11].s64 + 27600;
	// 826662BC: 4878D74D  bl 0x82df3a08
	ctx.lr = 0x826662C0;
	sub_82DF3A08(ctx, base);
	// 826662C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826662C4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826662C8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826662CC: 83BF0230  lwz r29, 0x230(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826662D0: 4BEABE49  bl 0x82512118
	ctx.lr = 0x826662D4;
	sub_82512118(ctx, base);
	// 826662D4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826662D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826662DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826662E0: 4BEA91E9  bl 0x8250f4c8
	ctx.lr = 0x826662E4;
	sub_8250F4C8(ctx, base);
	// 826662E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826662E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826662EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826662F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826662F4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826662F8: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 826662FC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82666300: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82666304: 4816A035  bl 0x827d0338
	ctx.lr = 0x82666308;
	sub_827D0338(ctx, base);
	// 82666308: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8266630C: 907F0234  stw r3, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 82666310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666314: 419A000C  beq cr6, 0x82666320
	if ctx.cr[6].eq {
	pc = 0x82666320; continue 'dispatch;
	}
	// 82666318: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8266631C: 4BC5A575  bl 0x822c0890
	ctx.lr = 0x82666320;
	sub_822C0890(ctx, base);
	// 82666320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666324: 4878D105  bl 0x82df3428
	ctx.lr = 0x82666328;
	sub_82DF3428(ctx, base);
	// 82666328: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 8266632C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82666330: 48B41E80  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82666338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82666338 size=828
    let mut pc: u32 = 0x82666338;
    'dispatch: loop {
        match pc {
            0x82666338 => {
    //   block [0x82666338..0x82666674)
	// 82666338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266633C: 48B41E25  bl 0x831a8160
	ctx.lr = 0x82666340;
	sub_831A8130(ctx, base);
	// 82666340: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82666344: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82666348: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266634C: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 82666350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666354: 409A0314  bne cr6, 0x82666668
	if !ctx.cr[6].eq {
	pc = 0x82666668; continue 'dispatch;
	}
	// 82666358: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 8266635C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82666360: 41820290  beq 0x826665f0
	if ctx.cr[0].eq {
	pc = 0x826665F0; continue 'dispatch;
	}
	// 82666364: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82666368: 813F023C  lwz r9, 0x23c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8266636C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82666370: 3BDF023C  addi r30, r31, 0x23c
	ctx.r[30].s64 = ctx.r[31].s64 + 572;
	// 82666374: 3B8BA520  addi r28, r11, -0x5ae0
	ctx.r[28].s64 = ctx.r[11].s64 + -23264;
	// 82666378: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8266637C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82666380: 409A008C  bne cr6, 0x8266640c
	if !ctx.cr[6].eq {
	pc = 0x8266640C; continue 'dispatch;
	}
	// 82666384: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82666388: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8266638C: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82666390: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82666394: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82666398: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8266639C: C00B6144  lfs f0, 0x6144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24900 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826663A0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826663A4: 48815C35  bl 0x82e7bfd8
	ctx.lr = 0x826663A8;
	sub_82E7BFD8(ctx, base);
	// 826663A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826663AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826663B0: 38A00440  li r5, 0x440
	ctx.r[5].s64 = 1088;
	// 826663B4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826663B8: 4878C031  bl 0x82df23e8
	ctx.lr = 0x826663BC;
	sub_82DF23E8(ctx, base);
	// 826663BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826663C0: 41820014  beq 0x826663d4
	if ctx.cr[0].eq {
	pc = 0x826663D4; continue 'dispatch;
	}
	// 826663C4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826663C8: 487ACD29  bl 0x82e130f0
	ctx.lr = 0x826663CC;
	sub_82E130F0(ctx, base);
	// 826663CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826663D0: 48000008  b 0x826663d8
	pc = 0x826663D8; continue 'dispatch;
	// 826663D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826663D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826663DC: 4BC7B975  bl 0x822e1d50
	ctx.lr = 0x826663E0;
	sub_822E1D50(ctx, base);
	// 826663E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826663E4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826663E8: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826663EC: 4BEABD2D  bl 0x82512118
	ctx.lr = 0x826663F0;
	sub_82512118(ctx, base);
	// 826663F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826663F4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826663F8: 487ACA39  bl 0x82e12e30
	ctx.lr = 0x826663FC;
	sub_82E12E30(ctx, base);
	// 826663FC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82666400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82666404: 419A0008  beq cr6, 0x8266640c
	if ctx.cr[6].eq {
	pc = 0x8266640C; continue 'dispatch;
	}
	// 82666408: 4BC5A489  bl 0x822c0890
	ctx.lr = 0x8266640C;
	sub_822C0890(ctx, base);
	// 8266640C: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 82666410: 3BBF0244  addi r29, r31, 0x244
	ctx.r[29].s64 = ctx.r[31].s64 + 580;
	// 82666414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666418: 409A008C  bne cr6, 0x826664a4
	if !ctx.cr[6].eq {
	pc = 0x826664A4; continue 'dispatch;
	}
	// 8266641C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82666420: D3E10074  stfs f31, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82666424: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82666428: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8266642C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82666430: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82666434: C00BAA0C  lfs f0, -0x55f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22004 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82666438: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8266643C: 48815B9D  bl 0x82e7bfd8
	ctx.lr = 0x82666440;
	sub_82E7BFD8(ctx, base);
	// 82666440: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82666444: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82666448: 38A00446  li r5, 0x446
	ctx.r[5].s64 = 1094;
	// 8266644C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82666450: 4878BF99  bl 0x82df23e8
	ctx.lr = 0x82666454;
	sub_82DF23E8(ctx, base);
	// 82666454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82666458: 41820014  beq 0x8266646c
	if ctx.cr[0].eq {
	pc = 0x8266646C; continue 'dispatch;
	}
	// 8266645C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82666460: 487ACC91  bl 0x82e130f0
	ctx.lr = 0x82666464;
	sub_82E130F0(ctx, base);
	// 82666464: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82666468: 48000008  b 0x82666470
	pc = 0x82666470; continue 'dispatch;
	// 8266646C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82666470: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82666474: 4BC7B8DD  bl 0x822e1d50
	ctx.lr = 0x82666478;
	sub_822E1D50(ctx, base);
	// 82666478: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266647C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82666480: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666484: 4BEABC95  bl 0x82512118
	ctx.lr = 0x82666488;
	sub_82512118(ctx, base);
	// 82666488: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266648C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666490: 487AC9A1  bl 0x82e12e30
	ctx.lr = 0x82666494;
	sub_82E12E30(ctx, base);
	// 82666494: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82666498: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266649C: 419A0008  beq cr6, 0x826664a4
	if ctx.cr[6].eq {
	pc = 0x826664A4; continue 'dispatch;
	}
	// 826664A0: 4BC5A3F1  bl 0x822c0890
	ctx.lr = 0x826664A4;
	sub_822C0890(ctx, base);
	// 826664A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826664A8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826664AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826664B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826664B4: 3B8B1F80  addi r28, r11, 0x1f80
	ctx.r[28].s64 = ctx.r[11].s64 + 8064;
	// 826664B8: C3EA08A8  lfs f31, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826664BC: 419A00A0  beq cr6, 0x8266655c
	if ctx.cr[6].eq {
	pc = 0x8266655C; continue 'dispatch;
	}
	// 826664C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826664C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826664C8: 4878D541  bl 0x82df3a08
	ctx.lr = 0x826664CC;
	sub_82DF3A08(ctx, base);
	// 826664CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826664D0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826664D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826664D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826664DC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826664E0: 419A0024  beq cr6, 0x82666504
	if ctx.cr[6].eq {
	pc = 0x82666504; continue 'dispatch;
	}
	// 826664E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826664E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826664EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826664F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826664F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826664F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826664FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82666500: 4082FFE8  bne 0x826664e8
	if !ctx.cr[0].eq {
	pc = 0x826664E8; continue 'dispatch;
	}
	// 82666504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82666508: 83DF0230  lwz r30, 0x230(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 8266650C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82666510: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 82666514: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 82666518: 4BEA8FB1  bl 0x8250f4c8
	ctx.lr = 0x8266651C;
	sub_8250F4C8(ctx, base);
	// 8266651C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82666520: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82666524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82666528: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 8266652C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82666530: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82666534: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82666538: 48169E01  bl 0x827d0338
	ctx.lr = 0x8266653C;
	sub_827D0338(ctx, base);
	// 8266653C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82666540: 907F0234  stw r3, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 82666544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666548: 419A000C  beq cr6, 0x82666554
	if ctx.cr[6].eq {
	pc = 0x82666554; continue 'dispatch;
	}
	// 8266654C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82666550: 4BC5A341  bl 0x822c0890
	ctx.lr = 0x82666554;
	sub_822C0890(ctx, base);
	// 82666554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666558: 4878CED1  bl 0x82df3428
	ctx.lr = 0x8266655C;
	sub_82DF3428(ctx, base);
	// 8266655C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666564: 419A0104  beq cr6, 0x82666668
	if ctx.cr[6].eq {
	pc = 0x82666668; continue 'dispatch;
	}
	// 82666568: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266656C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666570: 4878D499  bl 0x82df3a08
	ctx.lr = 0x82666574;
	sub_82DF3A08(ctx, base);
	// 82666574: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82666578: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266657C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666580: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82666584: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82666588: 419A0024  beq cr6, 0x826665ac
	if ctx.cr[6].eq {
	pc = 0x826665AC; continue 'dispatch;
	}
	// 8266658C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82666590: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82666594: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82666598: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8266659C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826665A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826665A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826665A8: 4082FFE8  bne 0x82666590
	if !ctx.cr[0].eq {
	pc = 0x82666590; continue 'dispatch;
	}
	// 826665AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826665B0: 83DF0230  lwz r30, 0x230(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826665B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826665B8: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 826665BC: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 826665C0: 4BEA8F09  bl 0x8250f4c8
	ctx.lr = 0x826665C4;
	sub_8250F4C8(ctx, base);
	// 826665C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826665C8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826665CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826665D0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826665D4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 826665D8: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 826665DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826665E0: 48169D59  bl 0x827d0338
	ctx.lr = 0x826665E4;
	sub_827D0338(ctx, base);
	// 826665E4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826665E8: 907F0238  stw r3, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[3].u32 ) };
	// 826665EC: 48000064  b 0x82666650
	pc = 0x82666650; continue 'dispatch;
	// 826665F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826665F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826665F8: 388B6BD0  addi r4, r11, 0x6bd0
	ctx.r[4].s64 = ctx.r[11].s64 + 27600;
	// 826665FC: 4878D40D  bl 0x82df3a08
	ctx.lr = 0x82666600;
	sub_82DF3A08(ctx, base);
	// 82666600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82666604: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82666608: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8266660C: 83BF0230  lwz r29, 0x230(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82666610: 4BEABB09  bl 0x82512118
	ctx.lr = 0x82666614;
	sub_82512118(ctx, base);
	// 82666614: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82666618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266661C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82666620: 4BEA8EA9  bl 0x8250f4c8
	ctx.lr = 0x82666624;
	sub_8250F4C8(ctx, base);
	// 82666624: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82666628: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266662C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82666630: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82666634: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82666638: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 8266663C: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82666640: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82666644: 48169CF5  bl 0x827d0338
	ctx.lr = 0x82666648;
	sub_827D0338(ctx, base);
	// 82666648: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 8266664C: 907F0234  stw r3, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[3].u32 ) };
	// 82666650: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666654: 419A000C  beq cr6, 0x82666660
	if ctx.cr[6].eq {
	pc = 0x82666660; continue 'dispatch;
	}
	// 82666658: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8266665C: 4BC5A235  bl 0x822c0890
	ctx.lr = 0x82666660;
	sub_822C0890(ctx, base);
	// 82666660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82666664: 4878CDC5  bl 0x82df3428
	ctx.lr = 0x82666668;
	sub_82DF3428(ctx, base);
	// 82666668: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 8266666C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82666670: 48B41B40  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82666678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82666678 size=312
    let mut pc: u32 = 0x82666678;
    'dispatch: loop {
        match pc {
            0x82666678 => {
    //   block [0x82666678..0x826667B0)
	// 82666678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266667C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82666680: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82666684: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82666688: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266668C: 48AEDF75  bl 0x83154600
	ctx.lr = 0x82666690;
	sub_83154600(ctx, base);
	// 82666690: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82666694: 897F0195  lbz r11, 0x195(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(405 as u32) ) } as u64;
	// 82666698: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266669C: 41820014  beq 0x826666b0
	if ctx.cr[0].eq {
	pc = 0x826666B0; continue 'dispatch;
	}
	// 826666A0: 389F015C  addi r4, r31, 0x15c
	ctx.r[4].s64 = ctx.r[31].s64 + 348;
	// 826666A4: 88BF0198  lbz r5, 0x198(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 826666A8: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 826666AC: 480031B5  bl 0x82669860
	ctx.lr = 0x826666B0;
	sub_82669860(ctx, base);
	// 826666B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826666B4: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826666B8: 4814CBA1  bl 0x827b3258
	ctx.lr = 0x826666BC;
	sub_827B3258(ctx, base);
	// 826666BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826666C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826666C4: 48816D8D  bl 0x82e7d450
	ctx.lr = 0x826666C8;
	sub_82E7D450(ctx, base);
	// 826666C8: 39600210  li r11, 0x210
	ctx.r[11].s64 = 528;
	// 826666CC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826667B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826667B0 size=1312
    let mut pc: u32 = 0x826667B0;
    'dispatch: loop {
        match pc {
            0x826667B0 => {
    //   block [0x826667B0..0x82666CD0)
	// 826667B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826667B4: 48B419B1  bl 0x831a8164
	ctx.lr = 0x826667B8;
	sub_831A8130(ctx, base);
	// 826667B8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 826667BC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826667C0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82666CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82666CD0 size=572
    let mut pc: u32 = 0x82666CD0;
    'dispatch: loop {
        match pc {
            0x82666CD0 => {
    //   block [0x82666CD0..0x82666F0C)
	// 82666CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82666CD4: 48B41495  bl 0x831a8168
	ctx.lr = 0x82666CD8;
	sub_831A8130(ctx, base);
	// 82666CD8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82666CDC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82666CE0: 48AED921  bl 0x83154600
	ctx.lr = 0x82666CE4;
	sub_83154600(ctx, base);
	// 82666CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82666CE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82666CEC: 4BFFD54D  bl 0x82664238
	ctx.lr = 0x82666CF0;
	sub_82664238(ctx, base);
	// 82666CF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82666CF4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82666CF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82666CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82666D00: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82666D04: 419A0024  beq cr6, 0x82666d28
	if ctx.cr[6].eq {
	pc = 0x82666D28; continue 'dispatch;
	}
	// 82666D08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82666D0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82666D10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82666D14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82666D18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82666D1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82666D20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82666D24: 4082FFE8  bne 0x82666d0c
	if !ctx.cr[0].eq {
	pc = 0x82666D0C; continue 'dispatch;
	}
	// 82666D28: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82666D2C: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82666D30: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82666D34: 480039B5  bl 0x8266a6e8
	ctx.lr = 0x82666D38;
	sub_8266A6E8(ctx, base);
	// 82666D38: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82666D3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82666D40: 3BABA520  addi r29, r11, -0x5ae0
	ctx.r[29].s64 = ctx.r[11].s64 + -23264;
	// 82666D44: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82666D48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82666D4C: 38A00574  li r5, 0x574
	ctx.r[5].s64 = 1396;
	// 82666D50: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82666D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82666D58: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82666D5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82666D60: 487F1CE1  bl 0x82e58a40
	ctx.lr = 0x82666D64;
	sub_82E58A40(ctx, base);
	// 82666D64: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82666D68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82666D6C: 419A0008  beq cr6, 0x82666d74
	if ctx.cr[6].eq {
	pc = 0x82666D74; continue 'dispatch;
	}
	// 82666D70: 4BC59B21  bl 0x822c0890
	ctx.lr = 0x82666D74;
	sub_822C0890(ctx, base);
	// 82666D74: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82666D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82666D7C: 419A0008  beq cr6, 0x82666d84
	if ctx.cr[6].eq {
	pc = 0x82666D84; continue 'dispatch;
	}
	// 82666D80: 4BC59B11  bl 0x822c0890
	ctx.lr = 0x82666D84;
	sub_822C0890(ctx, base);
	// 82666D84: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82666D88: 48002BF1  bl 0x82669978
	ctx.lr = 0x82666D8C;
	sub_82669978(ctx, base);
	// 82666D8C: 807F0190  lwz r3, 0x190(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82666D90: 48002CC9  bl 0x82669a58
	ctx.lr = 0x82666D94;
	sub_82669A58(ctx, base);
	// 82666D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82666D98: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82666D9C: 4BFFE955  bl 0x826656f0
	ctx.lr = 0x82666DA0;
	sub_826656F0(ctx, base);
	// 82666DA0: 987F0195  stb r3, 0x195(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(405 as u32), ctx.r[3].u8 ) };
	// 82666DA4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82666DA8: 809F018C  lwz r4, 0x18c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82666DAC: 4814C4AD  bl 0x827b3258
	ctx.lr = 0x82666DB0;
	sub_827B3258(ctx, base);
	// 82666DB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82666DB4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82666DB8: 48816699  bl 0x82e7d450
	ctx.lr = 0x82666DBC;
	sub_82E7D450(ctx, base);
	// 82666DBC: 39600210  li r11, 0x210
	ctx.r[11].s64 = 528;
	// 82666DC0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82666F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82666F10 size=820
    let mut pc: u32 = 0x82666F10;
    'dispatch: loop {
        match pc {
            0x82666F10 => {
    //   block [0x82666F10..0x82667244)
	// 82666F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82666F14: 48B41259  bl 0x831a816c
	ctx.lr = 0x82666F18;
	sub_831A8130(ctx, base);
	// 82666F18: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82666F1C: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82667248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82667248 size=1932
    let mut pc: u32 = 0x82667248;
    'dispatch: loop {
        match pc {
            0x82667248 => {
    //   block [0x82667248..0x826679D4)
	// 82667248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266724C: 48B40F19  bl 0x831a8164
	ctx.lr = 0x82667250;
	sub_831A8130(ctx, base);
	// 82667250: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82667254: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82667258: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826679D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826679D8 size=256
    let mut pc: u32 = 0x826679D8;
    'dispatch: loop {
        match pc {
            0x826679D8 => {
    //   block [0x826679D8..0x82667AD8)
	// 826679D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826679DC: 48B40791  bl 0x831a816c
	ctx.lr = 0x826679E0;
	sub_831A8130(ctx, base);
	// 826679E0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826679E4: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826679E8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 826679EC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826679F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826679F4: 39000070  li r8, 0x70
	ctx.r[8].s64 = 112;
	// 826679F8: 394B003C  addi r10, r11, 0x3c
	ctx.r[10].s64 = ctx.r[11].s64 + 60;
	// 826679FC: 3BDF008C  addi r30, r31, 0x8c
	ctx.r[30].s64 = ctx.r[31].s64 + 140;
	// 82667A00: 13EB48C7  vcmpequd (lvx128) v31, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82667A04: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 82667A08: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82667AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82667AD8 size=948
    let mut pc: u32 = 0x82667AD8;
    'dispatch: loop {
        match pc {
            0x82667AD8 => {
    //   block [0x82667AD8..0x82667E8C)
	// 82667AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82667ADC: 48B4068D  bl 0x831a8168
	ctx.lr = 0x82667AE0;
	sub_831A8130(ctx, base);
	// 82667AE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82667AE4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82667AE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82667AEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82667AF0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82667AF4: 41820038  beq 0x82667b2c
	if ctx.cr[0].eq {
	pc = 0x82667B2C; continue 'dispatch;
	}
	// 82667AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667AFC: 48B41E8D  bl 0x831a9988
	ctx.lr = 0x82667B00;
	sub_831A9988(ctx, base);
	// 82667B00: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667B04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667B08: 386B68D0  addi r3, r11, 0x68d0
	ctx.r[3].s64 = ctx.r[11].s64 + 26832;
	// 82667B0C: 48B405ED  bl 0x831a80f8
	ctx.lr = 0x82667B10;
	sub_831A80F8(ctx, base);
	// 82667B10: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667B14: 41820018  beq 0x82667b2c
	if ctx.cr[0].eq {
	pc = 0x82667B2C; continue 'dispatch;
	}
	// 82667B18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667B1C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667B20: 4BFF9BC9  bl 0x826616e8
	ctx.lr = 0x82667B24;
	sub_826616E8(ctx, base);
	// 82667B24: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82667B28: 4800035C  b 0x82667e84
	pc = 0x82667E84; continue 'dispatch;
	// 82667B2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667B30: 409A0074  bne cr6, 0x82667ba4
	if !ctx.cr[6].eq {
	pc = 0x82667BA4; continue 'dispatch;
	}
	// 82667B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667B38: 48B41E51  bl 0x831a9988
	ctx.lr = 0x82667B3C;
	sub_831A9988(ctx, base);
	// 82667B3C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82667B40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667B44: 386B3A30  addi r3, r11, 0x3a30
	ctx.r[3].s64 = ctx.r[11].s64 + 14896;
	// 82667B48: 48B405B1  bl 0x831a80f8
	ctx.lr = 0x82667B4C;
	sub_831A80F8(ctx, base);
	// 82667B4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667B50: 41820014  beq 0x82667b64
	if ctx.cr[0].eq {
	pc = 0x82667B64; continue 'dispatch;
	}
	// 82667B54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667B58: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667B5C: 4842CCCD  bl 0x82a94828
	ctx.lr = 0x82667B60;
	sub_82A94828(ctx, base);
	// 82667B60: 4BFFFFC4  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667B64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667B68: 409A003C  bne cr6, 0x82667ba4
	if !ctx.cr[6].eq {
	pc = 0x82667BA4; continue 'dispatch;
	}
	// 82667B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667B70: 48B41E19  bl 0x831a9988
	ctx.lr = 0x82667B74;
	sub_831A9988(ctx, base);
	// 82667B74: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667B78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667B7C: 386B76D0  addi r3, r11, 0x76d0
	ctx.r[3].s64 = ctx.r[11].s64 + 30416;
	// 82667B80: 48B40579  bl 0x831a80f8
	ctx.lr = 0x82667B84;
	sub_831A80F8(ctx, base);
	// 82667B84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667B88: 41820014  beq 0x82667b9c
	if ctx.cr[0].eq {
	pc = 0x82667B9C; continue 'dispatch;
	}
	// 82667B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667B90: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667B94: 480397C5  bl 0x826a1358
	ctx.lr = 0x82667B98;
	sub_826A1358(ctx, base);
	// 82667B98: 4BFFFF8C  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667B9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667BA0: 419A00AC  beq cr6, 0x82667c4c
	if ctx.cr[6].eq {
	pc = 0x82667C4C; continue 'dispatch;
	}
	// 82667BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667BA8: 48B41DE1  bl 0x831a9988
	ctx.lr = 0x82667BAC;
	sub_831A9988(ctx, base);
	// 82667BAC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667BB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667BB4: 386B6F44  addi r3, r11, 0x6f44
	ctx.r[3].s64 = ctx.r[11].s64 + 28484;
	// 82667BB8: 48B40541  bl 0x831a80f8
	ctx.lr = 0x82667BBC;
	sub_831A80F8(ctx, base);
	// 82667BBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667BC0: 41820014  beq 0x82667bd4
	if ctx.cr[0].eq {
	pc = 0x82667BD4; continue 'dispatch;
	}
	// 82667BC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667BC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667BCC: 4BFF9B2D  bl 0x826616f8
	ctx.lr = 0x82667BD0;
	sub_826616F8(ctx, base);
	// 82667BD0: 4BFFFF54  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667BD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667BD8: 419A0074  beq cr6, 0x82667c4c
	if ctx.cr[6].eq {
	pc = 0x82667C4C; continue 'dispatch;
	}
	// 82667BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667BE0: 48B41DA9  bl 0x831a9988
	ctx.lr = 0x82667BE4;
	sub_831A9988(ctx, base);
	// 82667BE4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82667BE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667BEC: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82667BF0: 48B40509  bl 0x831a80f8
	ctx.lr = 0x82667BF4;
	sub_831A80F8(ctx, base);
	// 82667BF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667BF8: 41820014  beq 0x82667c0c
	if ctx.cr[0].eq {
	pc = 0x82667C0C; continue 'dispatch;
	}
	// 82667BFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667C00: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667C04: 481833BD  bl 0x827eafc0
	ctx.lr = 0x82667C08;
	sub_827EAFC0(ctx, base);
	// 82667C08: 4BFFFF1C  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667C0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667C10: 419A003C  beq cr6, 0x82667c4c
	if ctx.cr[6].eq {
	pc = 0x82667C4C; continue 'dispatch;
	}
	// 82667C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667C18: 48B41D71  bl 0x831a9988
	ctx.lr = 0x82667C1C;
	sub_831A9988(ctx, base);
	// 82667C1C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82667C20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667C24: 386B3678  addi r3, r11, 0x3678
	ctx.r[3].s64 = ctx.r[11].s64 + 13944;
	// 82667C28: 48B404D1  bl 0x831a80f8
	ctx.lr = 0x82667C2C;
	sub_831A80F8(ctx, base);
	// 82667C2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667C30: 41820014  beq 0x82667c44
	if ctx.cr[0].eq {
	pc = 0x82667C44; continue 'dispatch;
	}
	// 82667C34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667C38: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667C3C: 48266FED  bl 0x828cec28
	ctx.lr = 0x82667C40;
	sub_828CEC28(ctx, base);
	// 82667C40: 4BFFFEE4  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667C44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667C48: 409A003C  bne cr6, 0x82667c84
	if !ctx.cr[6].eq {
	pc = 0x82667C84; continue 'dispatch;
	}
	// 82667C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667C50: 48B41D39  bl 0x831a9988
	ctx.lr = 0x82667C54;
	sub_831A9988(ctx, base);
	// 82667C54: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667C5C: 386B772C  addi r3, r11, 0x772c
	ctx.r[3].s64 = ctx.r[11].s64 + 30508;
	// 82667C60: 48B40499  bl 0x831a80f8
	ctx.lr = 0x82667C64;
	sub_831A80F8(ctx, base);
	// 82667C64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667C68: 41820014  beq 0x82667c7c
	if ctx.cr[0].eq {
	pc = 0x82667C7C; continue 'dispatch;
	}
	// 82667C6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667C70: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667C74: 4BFF9A65  bl 0x826616d8
	ctx.lr = 0x82667C78;
	sub_826616D8(ctx, base);
	// 82667C78: 4BFFFEAC  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667C7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667C80: 419A00AC  beq cr6, 0x82667d2c
	if ctx.cr[6].eq {
	pc = 0x82667D2C; continue 'dispatch;
	}
	// 82667C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667C88: 48B41D01  bl 0x831a9988
	ctx.lr = 0x82667C8C;
	sub_831A9988(ctx, base);
	// 82667C8C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82667C90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667C94: 386BE0A0  addi r3, r11, -0x1f60
	ctx.r[3].s64 = ctx.r[11].s64 + -8032;
	// 82667C98: 48B40461  bl 0x831a80f8
	ctx.lr = 0x82667C9C;
	sub_831A80F8(ctx, base);
	// 82667C9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667CA0: 41820014  beq 0x82667cb4
	if ctx.cr[0].eq {
	pc = 0x82667CB4; continue 'dispatch;
	}
	// 82667CA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667CA8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667CAC: 4BFF9A5D  bl 0x82661708
	ctx.lr = 0x82667CB0;
	sub_82661708(ctx, base);
	// 82667CB0: 4BFFFE74  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667CB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667CB8: 419A0074  beq cr6, 0x82667d2c
	if ctx.cr[6].eq {
	pc = 0x82667D2C; continue 'dispatch;
	}
	// 82667CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667CC0: 48B41CC9  bl 0x831a9988
	ctx.lr = 0x82667CC4;
	sub_831A9988(ctx, base);
	// 82667CC4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667CC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667CCC: 386B7818  addi r3, r11, 0x7818
	ctx.r[3].s64 = ctx.r[11].s64 + 30744;
	// 82667CD0: 48B40429  bl 0x831a80f8
	ctx.lr = 0x82667CD4;
	sub_831A80F8(ctx, base);
	// 82667CD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667CD8: 41820014  beq 0x82667cec
	if ctx.cr[0].eq {
	pc = 0x82667CEC; continue 'dispatch;
	}
	// 82667CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667CE0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667CE4: 4842CB35  bl 0x82a94818
	ctx.lr = 0x82667CE8;
	sub_82A94818(ctx, base);
	// 82667CE8: 4BFFFE3C  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667CEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667CF0: 419A003C  beq cr6, 0x82667d2c
	if ctx.cr[6].eq {
	pc = 0x82667D2C; continue 'dispatch;
	}
	// 82667CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667CF8: 48B41C91  bl 0x831a9988
	ctx.lr = 0x82667CFC;
	sub_831A9988(ctx, base);
	// 82667CFC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82667D00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667D04: 386B6B98  addi r3, r11, 0x6b98
	ctx.r[3].s64 = ctx.r[11].s64 + 27544;
	// 82667D08: 48B403F1  bl 0x831a80f8
	ctx.lr = 0x82667D0C;
	sub_831A80F8(ctx, base);
	// 82667D0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667D10: 41820014  beq 0x82667d24
	if ctx.cr[0].eq {
	pc = 0x82667D24; continue 'dispatch;
	}
	// 82667D14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667D18: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667D1C: 4BFFBDAD  bl 0x82663ac8
	ctx.lr = 0x82667D20;
	sub_82663AC8(ctx, base);
	// 82667D20: 4BFFFE04  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667D24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667D28: 409A003C  bne cr6, 0x82667d64
	if !ctx.cr[6].eq {
	pc = 0x82667D64; continue 'dispatch;
	}
	// 82667D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667D30: 48B41C59  bl 0x831a9988
	ctx.lr = 0x82667D34;
	sub_831A9988(ctx, base);
	// 82667D34: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82667D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667D3C: 386B6B6C  addi r3, r11, 0x6b6c
	ctx.r[3].s64 = ctx.r[11].s64 + 27500;
	// 82667D40: 48B403B9  bl 0x831a80f8
	ctx.lr = 0x82667D44;
	sub_831A80F8(ctx, base);
	// 82667D44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667D48: 41820014  beq 0x82667d5c
	if ctx.cr[0].eq {
	pc = 0x82667D5C; continue 'dispatch;
	}
	// 82667D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667D50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667D54: 4BFFBDED  bl 0x82663b40
	ctx.lr = 0x82667D58;
	sub_82663B40(ctx, base);
	// 82667D58: 4BFFFDCC  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667D5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667D60: 419A0114  beq cr6, 0x82667e74
	if ctx.cr[6].eq {
	pc = 0x82667E74; continue 'dispatch;
	}
	// 82667D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667D68: 48B41C21  bl 0x831a9988
	ctx.lr = 0x82667D6C;
	sub_831A9988(ctx, base);
	// 82667D6C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82667D70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667D74: 386B6B34  addi r3, r11, 0x6b34
	ctx.r[3].s64 = ctx.r[11].s64 + 27444;
	// 82667D78: 48B40381  bl 0x831a80f8
	ctx.lr = 0x82667D7C;
	sub_831A80F8(ctx, base);
	// 82667D7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667D80: 41820014  beq 0x82667d94
	if ctx.cr[0].eq {
	pc = 0x82667D94; continue 'dispatch;
	}
	// 82667D84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667D88: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667D8C: 4BFFD2ED  bl 0x82665078
	ctx.lr = 0x82667D90;
	sub_82665078(ctx, base);
	// 82667D90: 4BFFFD94  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667D94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667D98: 419A00DC  beq cr6, 0x82667e74
	if ctx.cr[6].eq {
	pc = 0x82667E74; continue 'dispatch;
	}
	// 82667D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667DA0: 48B41BE9  bl 0x831a9988
	ctx.lr = 0x82667DA4;
	sub_831A9988(ctx, base);
	// 82667DA4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82667DA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667DAC: 386BD788  addi r3, r11, -0x2878
	ctx.r[3].s64 = ctx.r[11].s64 + -10360;
	// 82667DB0: 48B40349  bl 0x831a80f8
	ctx.lr = 0x82667DB4;
	sub_831A80F8(ctx, base);
	// 82667DB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667DB8: 41820014  beq 0x82667dcc
	if ctx.cr[0].eq {
	pc = 0x82667DCC; continue 'dispatch;
	}
	// 82667DBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667DC0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667DC4: 4BFF98CD  bl 0x82661690
	ctx.lr = 0x82667DC8;
	sub_82661690(ctx, base);
	// 82667DC8: 4BFFFD5C  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667DCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667DD0: 419A00A4  beq cr6, 0x82667e74
	if ctx.cr[6].eq {
	pc = 0x82667E74; continue 'dispatch;
	}
	// 82667DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667DD8: 48B41BB1  bl 0x831a9988
	ctx.lr = 0x82667DDC;
	sub_831A9988(ctx, base);
	// 82667DDC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667DE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667DE4: 386B6B50  addi r3, r11, 0x6b50
	ctx.r[3].s64 = ctx.r[11].s64 + 27472;
	// 82667DE8: 48B40311  bl 0x831a80f8
	ctx.lr = 0x82667DEC;
	sub_831A80F8(ctx, base);
	// 82667DEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667DF0: 41820014  beq 0x82667e04
	if ctx.cr[0].eq {
	pc = 0x82667E04; continue 'dispatch;
	}
	// 82667DF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667DF8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667DFC: 4BFFD5FD  bl 0x826653f8
	ctx.lr = 0x82667E00;
	sub_826653F8(ctx, base);
	// 82667E00: 4BFFFD24  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667E04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667E08: 419A006C  beq cr6, 0x82667e74
	if ctx.cr[6].eq {
	pc = 0x82667E74; continue 'dispatch;
	}
	// 82667E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667E10: 48B41B79  bl 0x831a9988
	ctx.lr = 0x82667E14;
	sub_831A9988(ctx, base);
	// 82667E14: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82667E18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667E1C: 386B3650  addi r3, r11, 0x3650
	ctx.r[3].s64 = ctx.r[11].s64 + 13904;
	// 82667E20: 48B402D9  bl 0x831a80f8
	ctx.lr = 0x82667E24;
	sub_831A80F8(ctx, base);
	// 82667E24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667E28: 41820014  beq 0x82667e3c
	if ctx.cr[0].eq {
	pc = 0x82667E3C; continue 'dispatch;
	}
	// 82667E2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667E30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667E34: 4BFFD6B5  bl 0x826654e8
	ctx.lr = 0x82667E38;
	sub_826654E8(ctx, base);
	// 82667E38: 4BFFFCEC  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667E3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82667E40: 419A0034  beq cr6, 0x82667e74
	if ctx.cr[6].eq {
	pc = 0x82667E74; continue 'dispatch;
	}
	// 82667E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667E48: 48B41B41  bl 0x831a9988
	ctx.lr = 0x82667E4C;
	sub_831A9988(ctx, base);
	// 82667E4C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82667E50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82667E54: 386B75A4  addi r3, r11, 0x75a4
	ctx.r[3].s64 = ctx.r[11].s64 + 30116;
	// 82667E58: 48B402A1  bl 0x831a80f8
	ctx.lr = 0x82667E5C;
	sub_831A80F8(ctx, base);
	// 82667E5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667E60: 41820014  beq 0x82667e74
	if ctx.cr[0].eq {
	pc = 0x82667E74; continue 'dispatch;
	}
	// 82667E64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667E68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82667E6C: 4BFF99BD  bl 0x82661828
	ctx.lr = 0x82667E70;
	sub_82661828(ctx, base);
	// 82667E70: 4BFFFCB4  b 0x82667b24
	pc = 0x82667B24; continue 'dispatch;
	// 82667E74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82667E78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82667E7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82667E80: 4BEAA799  bl 0x82512618
	ctx.lr = 0x82667E84;
	sub_82512618(ctx, base);
	// 82667E84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82667E88: 48B40330  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82667E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82667E90 size=424
    let mut pc: u32 = 0x82667E90;
    'dispatch: loop {
        match pc {
            0x82667E90 => {
    //   block [0x82667E90..0x82668038)
	// 82667E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82667E94: 48B402D9  bl 0x831a816c
	ctx.lr = 0x82667E98;
	sub_831A8130(ctx, base);
	// 82667E98: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82667E9C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82667EA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82667EA4: 48AEC75D  bl 0x83154600
	ctx.lr = 0x82667EA8;
	sub_83154600(ctx, base);
	// 82667EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82667EAC: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82667EB0: 480027F9  bl 0x8266a6a8
	ctx.lr = 0x82667EB4;
	sub_8266A6A8(ctx, base);
	// 82667EB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82667EB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667EBC: 41820014  beq 0x82667ed0
	if ctx.cr[0].eq {
	pc = 0x82667ED0; continue 'dispatch;
	}
	// 82667EC0: 4BFF9CA9  bl 0x82661b68
	ctx.lr = 0x82667EC4;
	sub_82661B68(ctx, base);
	// 82667EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667EC8: 4BFF9CE9  bl 0x82661bb0
	ctx.lr = 0x82667ECC;
	sub_82661BB0(ctx, base);
	// 82667ECC: 48000014  b 0x82667ee0
	pc = 0x82667EE0; continue 'dispatch;
	// 82667ED0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82667ED4: 4BFFB185  bl 0x82663058
	ctx.lr = 0x82667ED8;
	sub_82663058(ctx, base);
	// 82667ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667EDC: 4BFFE45D  bl 0x82666338
	ctx.lr = 0x82667EE0;
	sub_82666338(ctx, base);
	// 82667EE0: 897F0220  lbz r11, 0x220(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 82667EE4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82667EE8: 41820020  beq 0x82667f08
	if ctx.cr[0].eq {
	pc = 0x82667F08; continue 'dispatch;
	}
	// 82667EEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82667EF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667EF4: 4BFFB015  bl 0x82662f08
	ctx.lr = 0x82667EF8;
	sub_82662F08(ctx, base);
	// 82667EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667EFC: 4BFFE105  bl 0x82666000
	ctx.lr = 0x82667F00;
	sub_82666000(ctx, base);
	// 82667F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82667F04: 997F0220  stb r11, 0x220(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u8 ) };
	// 82667F08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82667F0C: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82667F10: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82667F14: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82667F18: 4099001C  ble cr6, 0x82667f34
	if !ctx.cr[6].gt {
	pc = 0x82667F34; continue 'dispatch;
	}
	// 82667F1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82667F20: 487F1849  bl 0x82e59768
	ctx.lr = 0x82667F24;
	sub_82E59768(ctx, base);
	// 82667F24: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82667F28: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82667F2C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82667F30: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82667F34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667F38: 4BFFAC71  bl 0x82662ba8
	ctx.lr = 0x82667F3C;
	sub_82662BA8(ctx, base);
	// 82667F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667F40: 4BFF99B1  bl 0x826618f0
	ctx.lr = 0x82667F44;
	sub_826618F0(ctx, base);
	// 82667F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82667F48: 83BF018C  lwz r29, 0x18c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82667F4C: 487F181D  bl 0x82e59768
	ctx.lr = 0x82667F50;
	sub_82E59768(ctx, base);
	// 82667F50: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82667F54: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82667F58: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 82667F5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82667F60: C0690000  lfs f3, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82667F64: C04B65B8  lfs f2, 0x65b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26040 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82667F68: C02A65B0  lfs f1, 0x65b0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26032 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82667F6C: 48002965  bl 0x8266a8d0
	ctx.lr = 0x82667F70;
	sub_8266A8D0(ctx, base);
	// 82667F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667F74: 4BFFDCDD  bl 0x82665c50
	ctx.lr = 0x82667F78;
	sub_82665C50(ctx, base);
	// 82667F78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667F7C: 4BFFD9D5  bl 0x82665950
	ctx.lr = 0x82667F80;
	sub_82665950(ctx, base);
	// 82667F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82667F84: 4BFF9905  bl 0x82661888
	ctx.lr = 0x82667F88;
	sub_82661888(ctx, base);
	// 82667F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82667F8C: 4BFFE825  bl 0x826667b0
	ctx.lr = 0x82667F90;
	sub_826667B0(ctx, base);
	// 82667F90: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82667F94: 480026B5  bl 0x8266a648
	ctx.lr = 0x82667F98;
	sub_8266A648(ctx, base);
	// 82667F98: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 82667F9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82667FA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82667FA4: 4BFFC16D  bl 0x82664110
	ctx.lr = 0x82667FA8;
	sub_82664110(ctx, base);
	// 82667FA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82667FAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82667FB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82667FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82667FB8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82667FBC: 419A0024  beq cr6, 0x82667fe0
	if ctx.cr[6].eq {
	pc = 0x82667FE0; continue 'dispatch;
	}
	// 82667FC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82667FC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82667FC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82667FCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82667FD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82667FD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82667FD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82667FDC: 4082FFE8  bne 0x82667fc4
	if !ctx.cr[0].eq {
	pc = 0x82667FC4; continue 'dispatch;
	}
	// 82667FE0: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82667FE4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82667FE8: 48002701  bl 0x8266a6e8
	ctx.lr = 0x82667FEC;
	sub_8266A6E8(ctx, base);
	// 82667FEC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82667FF0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82667FF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82667FF8: 388BA520  addi r4, r11, -0x5ae0
	ctx.r[4].s64 = ctx.r[11].s64 + -23264;
	// 82667FFC: 38A00514  li r5, 0x514
	ctx.r[5].s64 = 1300;
	// 82668000: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82668004: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82668008: 487F0A39  bl 0x82e58a40
	ctx.lr = 0x8266800C;
	sub_82E58A40(ctx, base);
	// 8266800C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82668010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82668014: 419A0008  beq cr6, 0x8266801c
	if ctx.cr[6].eq {
	pc = 0x8266801C; continue 'dispatch;
	}
	// 82668018: 4BC58879  bl 0x822c0890
	ctx.lr = 0x8266801C;
	sub_822C0890(ctx, base);
	// 8266801C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82668020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82668024: 419A0008  beq cr6, 0x8266802c
	if ctx.cr[6].eq {
	pc = 0x8266802C; continue 'dispatch;
	}
	// 82668028: 4BC58869  bl 0x822c0890
	ctx.lr = 0x8266802C;
	sub_822C0890(ctx, base);
	// 8266802C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82668030: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82668034: 48B40188  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82668038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82668038 size=432
    let mut pc: u32 = 0x82668038;
    'dispatch: loop {
        match pc {
            0x82668038 => {
    //   block [0x82668038..0x826681E8)
	// 82668038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266803C: 48B40131  bl 0x831a816c
	ctx.lr = 0x82668040;
	sub_831A8130(ctx, base);
	// 82668040: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82668044: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82668048: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266804C: 48AEC5B5  bl 0x83154600
	ctx.lr = 0x82668050;
	sub_83154600(ctx, base);
	// 82668050: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82668054: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82668058: 480025F1  bl 0x8266a648
	ctx.lr = 0x8266805C;
	sub_8266A648(ctx, base);
	// 8266805C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82668060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668064: 40820014  bne 0x82668078
	if !ctx.cr[0].eq {
	pc = 0x82668078; continue 'dispatch;
	}
	// 82668068: 4BFF9B01  bl 0x82661b68
	ctx.lr = 0x8266806C;
	sub_82661B68(ctx, base);
	// 8266806C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668070: 4BFF9B41  bl 0x82661bb0
	ctx.lr = 0x82668074;
	sub_82661BB0(ctx, base);
	// 82668074: 48000014  b 0x82668088
	pc = 0x82668088; continue 'dispatch;
	// 82668078: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8266807C: 4BFFAFDD  bl 0x82663058
	ctx.lr = 0x82668080;
	sub_82663058(ctx, base);
	// 82668080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668084: 4BFFE2B5  bl 0x82666338
	ctx.lr = 0x82668088;
	sub_82666338(ctx, base);
	// 82668088: 897F0220  lbz r11, 0x220(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 8266808C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668090: 41820020  beq 0x826680b0
	if ctx.cr[0].eq {
	pc = 0x826680B0; continue 'dispatch;
	}
	// 82668094: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82668098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266809C: 4BFFAE6D  bl 0x82662f08
	ctx.lr = 0x826680A0;
	sub_82662F08(ctx, base);
	// 826680A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826680A4: 4BFFDF5D  bl 0x82666000
	ctx.lr = 0x826680A8;
	sub_82666000(ctx, base);
	// 826680A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826680AC: 997F0220  stb r11, 0x220(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u8 ) };
	// 826680B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826680B4: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826680B8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826680BC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 826680C0: 4099001C  ble cr6, 0x826680dc
	if !ctx.cr[6].gt {
	pc = 0x826680DC; continue 'dispatch;
	}
	// 826680C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826680C8: 487F16A1  bl 0x82e59768
	ctx.lr = 0x826680CC;
	sub_82E59768(ctx, base);
	// 826680CC: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826680D0: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826680D4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826680D8: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 826680DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826680E0: 4BFFAAC9  bl 0x82662ba8
	ctx.lr = 0x826680E4;
	sub_82662BA8(ctx, base);
	// 826680E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826680E8: 4BFF9809  bl 0x826618f0
	ctx.lr = 0x826680EC;
	sub_826618F0(ctx, base);
	// 826680EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826680F0: 83BF018C  lwz r29, 0x18c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826680F4: 487F1675  bl 0x82e59768
	ctx.lr = 0x826680F8;
	sub_82E59768(ctx, base);
	// 826680F8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 826680FC: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82668100: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 82668104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82668108: C0690000  lfs f3, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8266810C: C04B65BC  lfs f2, 0x65bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26044 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82668110: C02A65B4  lfs f1, 0x65b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26036 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82668114: 480027BD  bl 0x8266a8d0
	ctx.lr = 0x82668118;
	sub_8266A8D0(ctx, base);
	// 82668118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266811C: 4BFFDB35  bl 0x82665c50
	ctx.lr = 0x82668120;
	sub_82665C50(ctx, base);
	// 82668120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668124: 4BFFBADD  bl 0x82663c00
	ctx.lr = 0x82668128;
	sub_82663C00(ctx, base);
	// 82668128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266812C: 4BFFEDE5  bl 0x82666f10
	ctx.lr = 0x82668130;
	sub_82666F10(ctx, base);
	// 82668130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668134: 4BFF9755  bl 0x82661888
	ctx.lr = 0x82668138;
	sub_82661888(ctx, base);
	// 82668138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266813C: 4BFFBD35  bl 0x82663e70
	ctx.lr = 0x82668140;
	sub_82663E70(ctx, base);
	// 82668140: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82668144: 48002505  bl 0x8266a648
	ctx.lr = 0x82668148;
	sub_8266A648(ctx, base);
	// 82668148: 98610050  stb r3, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u8 ) };
	// 8266814C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82668150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82668154: 4BFFBFBD  bl 0x82664110
	ctx.lr = 0x82668158;
	sub_82664110(ctx, base);
	// 82668158: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266815C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82668160: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82668164: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82668168: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8266816C: 419A0024  beq cr6, 0x82668190
	if ctx.cr[6].eq {
	pc = 0x82668190; continue 'dispatch;
	}
	// 82668170: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82668174: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82668178: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266817C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82668180: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82668184: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82668188: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266818C: 4082FFE8  bne 0x82668174
	if !ctx.cr[0].eq {
	pc = 0x82668174; continue 'dispatch;
	}
	// 82668190: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82668194: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 82668198: 48002551  bl 0x8266a6e8
	ctx.lr = 0x8266819C;
	sub_8266A6E8(ctx, base);
	// 8266819C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826681A0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826681A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826681A8: 388BA520  addi r4, r11, -0x5ae0
	ctx.r[4].s64 = ctx.r[11].s64 + -23264;
	// 826681AC: 38A005B9  li r5, 0x5b9
	ctx.r[5].s64 = 1465;
	// 826681B0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826681B4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826681B8: 487F0889  bl 0x82e58a40
	ctx.lr = 0x826681BC;
	sub_82E58A40(ctx, base);
	// 826681BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826681C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826681C4: 419A0008  beq cr6, 0x826681cc
	if ctx.cr[6].eq {
	pc = 0x826681CC; continue 'dispatch;
	}
	// 826681C8: 4BC586C9  bl 0x822c0890
	ctx.lr = 0x826681CC;
	sub_822C0890(ctx, base);
	// 826681CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826681D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826681D4: 419A0008  beq cr6, 0x826681dc
	if ctx.cr[6].eq {
	pc = 0x826681DC; continue 'dispatch;
	}
	// 826681D8: 4BC586B9  bl 0x822c0890
	ctx.lr = 0x826681DC;
	sub_822C0890(ctx, base);
	// 826681DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826681E0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826681E4: 48B3FFD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826681E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826681E8 size=108
    let mut pc: u32 = 0x826681E8;
    'dispatch: loop {
        match pc {
            0x826681E8 => {
    //   block [0x826681E8..0x82668254)
	// 826681E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826681EC: 48B3FF81  bl 0x831a816c
	ctx.lr = 0x826681F0;
	sub_831A8130(ctx, base);
	// 826681F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826681F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826681F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826681FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82668200: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82668204: 40820038  bne 0x8266823c
	if !ctx.cr[0].eq {
	pc = 0x8266823C; continue 'dispatch;
	}
	// 82668208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266820C: 48B4177D  bl 0x831a9988
	ctx.lr = 0x82668210;
	sub_831A9988(ctx, base);
	// 82668210: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82668214: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668218: 386B6BC4  addi r3, r11, 0x6bc4
	ctx.r[3].s64 = ctx.r[11].s64 + 27588;
	// 8266821C: 48B3FEDD  bl 0x831a80f8
	ctx.lr = 0x82668220;
	sub_831A80F8(ctx, base);
	// 82668220: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82668224: 41820018  beq 0x8266823c
	if ctx.cr[0].eq {
	pc = 0x8266823C; continue 'dispatch;
	}
	// 82668228: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266822C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82668230: 4BFFF7A9  bl 0x826679d8
	ctx.lr = 0x82668234;
	sub_826679D8(ctx, base);
	// 82668234: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82668238: 48000014  b 0x8266824c
	pc = 0x8266824C; continue 'dispatch;
	// 8266823C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82668240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82668244: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82668248: 48B16241  bl 0x8317e488
	ctx.lr = 0x8266824C;
	sub_8317E488(ctx, base);
	// 8266824C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82668250: 48B3FF6C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82668258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82668258 size=404
    let mut pc: u32 = 0x82668258;
    'dispatch: loop {
        match pc {
            0x82668258 => {
    //   block [0x82668258..0x826683EC)
	// 82668258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266825C: 48B3FF0D  bl 0x831a8168
	ctx.lr = 0x82668260;
	sub_831A8130(ctx, base);
	// 82668260: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82668264: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82668268: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8266826C: 3BCBA520  addi r30, r11, -0x5ae0
	ctx.r[30].s64 = ctx.r[11].s64 + -23264;
	// 82668270: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668274: 38A000A9  li r5, 0xa9
	ctx.r[5].s64 = 169;
	// 82668278: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266827C: 38600250  li r3, 0x250
	ctx.r[3].s64 = 592;
	// 82668280: 4878A169  bl 0x82df23e8
	ctx.lr = 0x82668284;
	sub_82DF23E8(ctx, base);
	// 82668284: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668288: 41820014  beq 0x8266829c
	if ctx.cr[0].eq {
	pc = 0x8266829C; continue 'dispatch;
	}
	// 8266828C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82668290: 4BFFB281  bl 0x82663510
	ctx.lr = 0x82668294;
	sub_82663510(ctx, base);
	// 82668294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82668298: 48000008  b 0x826682a0
	pc = 0x826682A0; continue 'dispatch;
	// 8266829C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826682A0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826682A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826682A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826682AC: 4BFF9A75  bl 0x82661d20
	ctx.lr = 0x826682B0;
	sub_82661D20(ctx, base);
	// 826682B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826682B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826682B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826682BC: 4BC57D45  bl 0x822c0000
	ctx.lr = 0x826682C0;
	sub_822C0000(ctx, base);
	// 826682C0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826682C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826682C8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826682CC: 409A0008  bne cr6, 0x826682d4
	if !ctx.cr[6].eq {
	pc = 0x826682D4; continue 'dispatch;
	}
	// 826682D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826682D4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826682D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826682DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826682E0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 826682E4: 419A0024  beq cr6, 0x82668308
	if ctx.cr[6].eq {
	pc = 0x82668308; continue 'dispatch;
	}
	// 826682E8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826682EC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826682F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826682F4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826682F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826682FC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82668300: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82668304: 4082FFE8  bne 0x826682ec
	if !ctx.cr[0].eq {
	pc = 0x826682EC; continue 'dispatch;
	}
	// 82668308: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8266830C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82668310: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82668314: 419A0024  beq cr6, 0x82668338
	if ctx.cr[6].eq {
	pc = 0x82668338; continue 'dispatch;
	}
	// 82668318: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8266831C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82668320: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82668324: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82668328: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8266832C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82668330: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82668334: 4082FFE8  bne 0x8266831c
	if !ctx.cr[0].eq {
	pc = 0x8266831C; continue 'dispatch;
	}
	// 82668338: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266833C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82668340: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82668344: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82668348: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266834C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82668350: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82668354: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82668358: 48130BD9  bl 0x82798f30
	ctx.lr = 0x8266835C;
	sub_82798F30(ctx, base);
	// 8266835C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82668360: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668364: 38A000AB  li r5, 0xab
	ctx.r[5].s64 = 171;
	// 82668368: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8266836C: 4BC5806D  bl 0x822c03d8
	ctx.lr = 0x82668370;
	sub_822C03D8(ctx, base);
	// 82668370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668374: 41820014  beq 0x82668388
	if ctx.cr[0].eq {
	pc = 0x82668388; continue 'dispatch;
	}
	// 82668378: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266837C: 481332ED  bl 0x8279b668
	ctx.lr = 0x82668380;
	sub_8279B668(ctx, base);
	// 82668380: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82668384: 48000008  b 0x8266838c
	pc = 0x8266838C; continue 'dispatch;
	// 82668388: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266838C: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82668390: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82668394: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82668398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266839C: 4BF2F8B5  bl 0x82597c50
	ctx.lr = 0x826683A0;
	sub_82597C50(ctx, base);
	// 826683A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826683A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826683A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826683AC: 4BC57C55  bl 0x822c0000
	ctx.lr = 0x826683B0;
	sub_822C0000(ctx, base);
	// 826683B0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826683B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826683B8: 419A0008  beq cr6, 0x826683c0
	if ctx.cr[6].eq {
	pc = 0x826683C0; continue 'dispatch;
	}
	// 826683BC: 4BC584D5  bl 0x822c0890
	ctx.lr = 0x826683C0;
	sub_822C0890(ctx, base);
	// 826683C0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826683C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826683C8: 419A0008  beq cr6, 0x826683d0
	if ctx.cr[6].eq {
	pc = 0x826683D0; continue 'dispatch;
	}
	// 826683CC: 4BC584C5  bl 0x822c0890
	ctx.lr = 0x826683D0;
	sub_822C0890(ctx, base);
	// 826683D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826683D4: 419A000C  beq cr6, 0x826683e0
	if ctx.cr[6].eq {
	pc = 0x826683E0; continue 'dispatch;
	}
	// 826683D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826683DC: 4BC584B5  bl 0x822c0890
	ctx.lr = 0x826683E0;
	sub_822C0890(ctx, base);
	// 826683E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826683E4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826683E8: 48B3FDD0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826683F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826683F0 size=92
    let mut pc: u32 = 0x826683F0;
    'dispatch: loop {
        match pc {
            0x826683F0 => {
    //   block [0x826683F0..0x8266844C)
	// 826683F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826683F4: 48B3FD79  bl 0x831a816c
	ctx.lr = 0x826683F8;
	sub_831A8130(ctx, base);
	// 826683F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826683FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82668400: 3D408266  lis r10, -0x7d9a
	ctx.r[10].s64 = -2107244544;
	// 82668404: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82668408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266840C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82668410: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82668414: 388A42B0  addi r4, r10, 0x42b0
	ctx.r[4].s64 = ctx.r[10].s64 + 17072;
	// 82668418: 4BCF7659  bl 0x8235fa70
	ctx.lr = 0x8266841C;
	sub_8235FA70(ctx, base);
	// 8266841C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82668420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668424: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82668428: 4878B7D9  bl 0x82df3c00
	ctx.lr = 0x8266842C;
	sub_82DF3C00(ctx, base);
	// 8266842C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668434: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82668438: 487F3D21  bl 0x82e5c158
	ctx.lr = 0x8266843C;
	sub_82E5C158(ctx, base);
	// 8266843C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668440: 4878AFE9  bl 0x82df3428
	ctx.lr = 0x82668444;
	sub_82DF3428(ctx, base);
	// 82668444: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82668448: 48B3FD74  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82668450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82668450 size=92
    let mut pc: u32 = 0x82668450;
    'dispatch: loop {
        match pc {
            0x82668450 => {
    //   block [0x82668450..0x826684AC)
	// 82668450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82668454: 48B3FD19  bl 0x831a816c
	ctx.lr = 0x82668458;
	sub_831A8130(ctx, base);
	// 82668458: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266845C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82668460: 3D408266  lis r10, -0x7d9a
	ctx.r[10].s64 = -2107244544;
	// 82668464: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82668468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266846C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82668470: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82668474: 388A4330  addi r4, r10, 0x4330
	ctx.r[4].s64 = ctx.r[10].s64 + 17200;
	// 82668478: 4BCF75F9  bl 0x8235fa70
	ctx.lr = 0x8266847C;
	sub_8235FA70(ctx, base);
	// 8266847C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82668480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668484: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82668488: 4878B779  bl 0x82df3c00
	ctx.lr = 0x8266848C;
	sub_82DF3C00(ctx, base);
	// 8266848C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668494: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82668498: 487F3CC1  bl 0x82e5c158
	ctx.lr = 0x8266849C;
	sub_82E5C158(ctx, base);
	// 8266849C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826684A0: 4878AF89  bl 0x82df3428
	ctx.lr = 0x826684A4;
	sub_82DF3428(ctx, base);
	// 826684A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826684A8: 48B3FD14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826684B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826684B0 size=92
    let mut pc: u32 = 0x826684B0;
    'dispatch: loop {
        match pc {
            0x826684B0 => {
    //   block [0x826684B0..0x8266850C)
	// 826684B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826684B4: 48B3FCB9  bl 0x831a816c
	ctx.lr = 0x826684B8;
	sub_831A8130(ctx, base);
	// 826684B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826684BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826684C0: 3D408266  lis r10, -0x7d9a
	ctx.r[10].s64 = -2107244544;
	// 826684C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826684C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826684CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826684D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826684D4: 388A43B0  addi r4, r10, 0x43b0
	ctx.r[4].s64 = ctx.r[10].s64 + 17328;
	// 826684D8: 4BCF7599  bl 0x8235fa70
	ctx.lr = 0x826684DC;
	sub_8235FA70(ctx, base);
	// 826684DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826684E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826684E4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 826684E8: 4878B719  bl 0x82df3c00
	ctx.lr = 0x826684EC;
	sub_82DF3C00(ctx, base);
	// 826684EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826684F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826684F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826684F8: 487F3C61  bl 0x82e5c158
	ctx.lr = 0x826684FC;
	sub_82E5C158(ctx, base);
	// 826684FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668500: 4878AF29  bl 0x82df3428
	ctx.lr = 0x82668504;
	sub_82DF3428(ctx, base);
	// 82668504: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82668508: 48B3FCB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82668510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82668510 size=92
    let mut pc: u32 = 0x82668510;
    'dispatch: loop {
        match pc {
            0x82668510 => {
    //   block [0x82668510..0x8266856C)
	// 82668510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82668514: 48B3FC59  bl 0x831a816c
	ctx.lr = 0x82668518;
	sub_831A8130(ctx, base);
	// 82668518: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266851C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82668520: 3D408266  lis r10, -0x7d9a
	ctx.r[10].s64 = -2107244544;
	// 82668524: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82668528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266852C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82668530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82668534: 388A4430  addi r4, r10, 0x4430
	ctx.r[4].s64 = ctx.r[10].s64 + 17456;
	// 82668538: 4BCF7539  bl 0x8235fa70
	ctx.lr = 0x8266853C;
	sub_8235FA70(ctx, base);
	// 8266853C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82668540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668544: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82668548: 4878B6B9  bl 0x82df3c00
	ctx.lr = 0x8266854C;
	sub_82DF3C00(ctx, base);
	// 8266854C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82668554: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82668558: 487F3C01  bl 0x82e5c158
	ctx.lr = 0x8266855C;
	sub_82E5C158(ctx, base);
	// 8266855C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668560: 4878AEC9  bl 0x82df3428
	ctx.lr = 0x82668564;
	sub_82DF3428(ctx, base);
	// 82668564: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82668568: 48B3FC54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82668570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82668570 size=92
    let mut pc: u32 = 0x82668570;
    'dispatch: loop {
        match pc {
            0x82668570 => {
    //   block [0x82668570..0x826685CC)
	// 82668570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82668574: 48B3FBF9  bl 0x831a816c
	ctx.lr = 0x82668578;
	sub_831A8130(ctx, base);
	// 82668578: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266857C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82668580: 3D408266  lis r10, -0x7d9a
	ctx.r[10].s64 = -2107244544;
	// 82668584: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82668588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266858C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82668590: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82668594: 388A44A0  addi r4, r10, 0x44a0
	ctx.r[4].s64 = ctx.r[10].s64 + 17568;
	// 82668598: 4BCF74D9  bl 0x8235fa70
	ctx.lr = 0x8266859C;
	sub_8235FA70(ctx, base);
	// 8266859C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826685A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826685A4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 826685A8: 4878B659  bl 0x82df3c00
	ctx.lr = 0x826685AC;
	sub_82DF3C00(ctx, base);
	// 826685AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826685B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826685B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826685B8: 487F3BA1  bl 0x82e5c158
	ctx.lr = 0x826685BC;
	sub_82E5C158(ctx, base);
	// 826685BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826685C0: 4878AE69  bl 0x82df3428
	ctx.lr = 0x826685C4;
	sub_82DF3428(ctx, base);
	// 826685C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826685C8: 48B3FBF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826685D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826685D0 size=1668
    let mut pc: u32 = 0x826685D0;
    'dispatch: loop {
        match pc {
            0x826685D0 => {
    //   block [0x826685D0..0x82668C54)
	// 826685D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826685D4: 48B3FB6D  bl 0x831a8140
	ctx.lr = 0x826685D8;
	sub_831A8130(ctx, base);
	// 826685D8: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 826685DC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826685E0: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 826685E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826685E8: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 826685EC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 826685F0: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 826685F4: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 826685F8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 826685FC: 4BEA93DD  bl 0x825119d8
	ctx.lr = 0x82668600;
	sub_825119D8(ctx, base);
	// 82668600: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82668604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668608: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8266860C: 4878B3FD  bl 0x82df3a08
	ctx.lr = 0x82668610;
	sub_82DF3A08(ctx, base);
	// 82668610: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82668614: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82668618: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 8266861C: 4BEA0165  bl 0x82508780
	ctx.lr = 0x82668620;
	sub_82508780(ctx, base);
	// 82668620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668624: 4878AE05  bl 0x82df3428
	ctx.lr = 0x82668628;
	sub_82DF3428(ctx, base);
	// 82668628: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266862C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 82668630: 409A0008  bne cr6, 0x82668638
	if !ctx.cr[6].eq {
	pc = 0x82668638; continue 'dispatch;
	}
	// 82668634: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 82668638: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8266863C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668640: 808BD068  lwz r4, -0x2f98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12184 as u32) ) } as u64;
	// 82668644: 4878B3C5  bl 0x82df3a08
	ctx.lr = 0x82668648;
	sub_82DF3A08(ctx, base);
	// 82668648: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8266864C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82668650: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82668654: 4BEA019D  bl 0x825087f0
	ctx.lr = 0x82668658;
	sub_825087F0(ctx, base);
	// 82668658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266865C: 4878ADCD  bl 0x82df3428
	ctx.lr = 0x82668660;
	sub_82DF3428(ctx, base);
	// 82668660: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82668664: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668668: 487C2481  bl 0x82e2aae8
	ctx.lr = 0x8266866C;
	sub_82E2AAE8(ctx, base);
	// 8266866C: 897F0198  lbz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82668670: 92810068  stw r20, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[20].u32 ) };
	// 82668674: 9281006C  stw r20, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[20].u32 ) };
	// 82668678: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266867C: 41820010  beq 0x8266868c
	if ctx.cr[0].eq {
	pc = 0x8266868C; continue 'dispatch;
	}
	// 82668680: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82668684: 808B65A0  lwz r4, 0x65a0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26016 as u32) ) } as u64;
	// 82668688: 4800000C  b 0x82668694
	pc = 0x82668694; continue 'dispatch;
	// 8266868C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82668690: 808B659C  lwz r4, 0x659c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26012 as u32) ) } as u64;
	// 82668694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668698: 4878B371  bl 0x82df3a08
	ctx.lr = 0x8266869C;
	sub_82DF3A08(ctx, base);
	// 8266869C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826686A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826686A4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826686A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826686AC: 487C67C5  bl 0x82e2ee70
	ctx.lr = 0x826686B0;
	sub_82E2EE70(ctx, base);
	// 826686B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826686B4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 826686B8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826686BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826686C0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826686C4: 4BC5BD9D  bl 0x822c4460
	ctx.lr = 0x826686C8;
	sub_822C4460(ctx, base);
	// 826686C8: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826686CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826686D0: 419A0008  beq cr6, 0x826686d8
	if ctx.cr[6].eq {
	pc = 0x826686D8; continue 'dispatch;
	}
	// 826686D4: 4BC581BD  bl 0x822c0890
	ctx.lr = 0x826686D8;
	sub_822C0890(ctx, base);
	// 826686D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826686DC: 4878AD4D  bl 0x82df3428
	ctx.lr = 0x826686E0;
	sub_82DF3428(ctx, base);
	// 826686E0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826686E4: 3AEBA520  addi r23, r11, -0x5ae0
	ctx.r[23].s64 = ctx.r[11].s64 + -23264;
	// 826686E8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826686EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826686F0: 419A0074  beq cr6, 0x82668764
	if ctx.cr[6].eq {
	pc = 0x82668764; continue 'dispatch;
	}
	// 826686F4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826686F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826686FC: 38A000FA  li r5, 0xfa
	ctx.r[5].s64 = 250;
	// 82668700: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82668704: 48789CE5  bl 0x82df23e8
	ctx.lr = 0x82668708;
	sub_82DF23E8(ctx, base);
	// 82668708: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266870C: 41820014  beq 0x82668720
	if ctx.cr[0].eq {
	pc = 0x82668720; continue 'dispatch;
	}
	// 82668710: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82668714: 487AE17D  bl 0x82e16890
	ctx.lr = 0x82668718;
	sub_82E16890(ctx, base);
	// 82668718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266871C: 48000008  b 0x82668724
	pc = 0x82668724; continue 'dispatch;
	// 82668720: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82668724: 3BDF0148  addi r30, r31, 0x148
	ctx.r[30].s64 = ctx.r[31].s64 + 328;
	// 82668728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266872C: 4BCF4C45  bl 0x8235d370
	ctx.lr = 0x82668730;
	sub_8235D370(ctx, base);
	// 82668730: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82668734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668738: 83BF0148  lwz r29, 0x148(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 8266873C: 4BEA99DD  bl 0x82512118
	ctx.lr = 0x82668740;
	sub_82512118(ctx, base);
	// 82668740: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82668748: 487AC969  bl 0x82e150b0
	ctx.lr = 0x8266874C;
	sub_82E150B0(ctx, base);
	// 8266874C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82668750: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82668754: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82668758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266875C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82668760: 4BEA83F9  bl 0x82510b58
	ctx.lr = 0x82668764;
	sub_82510B58(ctx, base);
	// 82668764: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82668768: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266876C: 38A00100  li r5, 0x100
	ctx.r[5].s64 = 256;
	// 82668770: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 82668774: 48789C75  bl 0x82df23e8
	ctx.lr = 0x82668778;
	sub_82DF23E8(ctx, base);
	// 82668778: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8266877C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82668780: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82668784: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82668788: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8266878C: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 82668790: 3F808205  lis r28, -0x7dfb
	ctx.r[28].s64 = -2113601536;
	// 82668794: 3B6B6910  addi r27, r11, 0x6910
	ctx.r[27].s64 = ctx.r[11].s64 + 26896;
	// 82668798: 3B4ABA80  addi r26, r10, -0x4580
	ctx.r[26].s64 = ctx.r[10].s64 + -17792;
	// 8266879C: 41820088  beq 0x82668824
	if ctx.cr[0].eq {
	pc = 0x82668824; continue 'dispatch;
	}
	// 826687A0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826687A4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 826687A8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826687AC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 826687B0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826687B4: 48837F7D  bl 0x82ea0730
	ctx.lr = 0x826687B8;
	sub_82EA0730(ctx, base);
	// 826687B8: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 826687BC: C03CA434  lfs f1, -0x5bcc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-23500 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826687C0: 488B1A31  bl 0x82f1a1f0
	ctx.lr = 0x826687C4;
	sub_82F1A1F0(ctx, base);
	// 826687C4: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 826687C8: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 826687CC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826687D0: D3E100A4  stfs f31, 0xa4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 826687D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826687D8: D3E100A8  stfs f31, 0xa8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 826687DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826687E0: D3E100AC  stfs f31, 0xac(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 826687E4: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 826687E8: 3A6100A0  addi r19, r1, 0xa0
	ctx.r[19].s64 = ctx.r[1].s64 + 160;
	// 826687EC: 83AB670C  lwz r29, 0x670c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26380 as u32) ) } as u64;
	// 826687F0: 3A410060  addi r18, r1, 0x60
	ctx.r[18].s64 = ctx.r[1].s64 + 96;
	// 826687F4: 4BEA6D25  bl 0x8250f518
	ctx.lr = 0x826687F8;
	sub_8250F518(ctx, base);
	// 826687F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826687FC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82668800: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668804: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 82668808: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8266880C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82668810: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82668814: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 82668818: 4847EAC9  bl 0x82ae72e0
	ctx.lr = 0x8266881C;
	sub_82AE72E0(ctx, base);
	// 8266881C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668820: 48000008  b 0x82668828
	pc = 0x82668828; continue 'dispatch;
	// 82668824: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82668828: 3BDF0170  addi r30, r31, 0x170
	ctx.r[30].s64 = ctx.r[31].s64 + 368;
	// 8266882C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668830: 4BD0BA29  bl 0x82374258
	ctx.lr = 0x82668834;
	sub_82374258(ctx, base);
	// 82668834: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82668838: 41820010  beq 0x82668848
	if ctx.cr[0].eq {
	pc = 0x82668848; continue 'dispatch;
	}
	// 8266883C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82668840: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 82668844: 4878944D  bl 0x82df1c90
	ctx.lr = 0x82668848;
	sub_82DF1C90(ctx, base);
	// 82668848: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266884C: 41820018  beq 0x82668864
	if ctx.cr[0].eq {
	pc = 0x82668864; continue 'dispatch;
	}
	// 82668850: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82668854: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 82668858: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266885C: 419A0008  beq cr6, 0x82668864
	if ctx.cr[6].eq {
	pc = 0x82668864; continue 'dispatch;
	}
	// 82668860: 4BC7FA09  bl 0x822e8268
	ctx.lr = 0x82668864;
	sub_822E8268(ctx, base);
	// 82668864: C01CA434  lfs f0, -0x5bcc(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-23500 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82668868: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8266886C: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82668870: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668874: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82668878: D3E100B8  stfs f31, 0xb8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8266887C: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82668880: 4847AC79  bl 0x82ae34f8
	ctx.lr = 0x82668884;
	sub_82AE34F8(ctx, base);
	// 82668884: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82668888: D3E100C0  stfs f31, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8266888C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82668890: D3E100C8  stfs f31, 0xc8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82668894: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668898: D3E100CC  stfs f31, 0xcc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8266889C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826688A0: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 826688A4: 4847ACE5  bl 0x82ae3588
	ctx.lr = 0x826688A8;
	sub_82AE3588(ctx, base);
	// 826688A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826688AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826688B0: 808B8654  lwz r4, -0x79ac(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31148 as u32) ) } as u64;
	// 826688B4: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826688B8: 4BCC3E71  bl 0x8232c728
	ctx.lr = 0x826688BC;
	sub_8232C728(ctx, base);
	// 826688BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826688C0: E86B0000  ld r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 826688C4: E88B0008  ld r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 826688C8: 48151AA9  bl 0x827ba370
	ctx.lr = 0x826688CC;
	sub_827BA370(ctx, base);
	// 826688CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826688D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826688D4: 4847AA6D  bl 0x82ae3340
	ctx.lr = 0x826688D8;
	sub_82AE3340(ctx, base);
	// 826688D8: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826688DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826688E0: C02BDFAC  lfs f1, -0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826688E4: 4847AF75  bl 0x82ae3858
	ctx.lr = 0x826688E8;
	sub_82AE3858(ctx, base);
	// 826688E8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826688EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826688F0: 419A0008  beq cr6, 0x826688f8
	if ctx.cr[6].eq {
	pc = 0x826688F8; continue 'dispatch;
	}
	// 826688F4: 4BC57F9D  bl 0x822c0890
	ctx.lr = 0x826688F8;
	sub_822C0890(ctx, base);
	// 826688F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826688FC: 487C2205  bl 0x82e2ab00
	ctx.lr = 0x82668900;
	sub_82E2AB00(ctx, base);
	// 82668900: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82668904: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 82668908: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266890C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668910: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82668914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82668918: 4E800421  bctrl
	ctx.lr = 0x8266891C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266891C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82668920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668924: 3BABCFB0  addi r29, r11, -0x3050
	ctx.r[29].s64 = ctx.r[11].s64 + -12368;
	// 82668928: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8266892C: 4878B0DD  bl 0x82df3a08
	ctx.lr = 0x82668930;
	sub_82DF3A08(ctx, base);
	// 82668930: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668934: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668938: 4BFFFAB9  bl 0x826683f0
	ctx.lr = 0x8266893C;
	sub_826683F0(ctx, base);
	// 8266893C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82668940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668944: 388BA670  addi r4, r11, -0x5990
	ctx.r[4].s64 = ctx.r[11].s64 + -22928;
	// 82668948: 4878B0C1  bl 0x82df3a08
	ctx.lr = 0x8266894C;
	sub_82DF3A08(ctx, base);
	// 8266894C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668954: 4BFFFAFD  bl 0x82668450
	ctx.lr = 0x82668958;
	sub_82668450(ctx, base);
	// 82668958: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266895C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668960: 388BA610  addi r4, r11, -0x59f0
	ctx.r[4].s64 = ctx.r[11].s64 + -23024;
	// 82668964: 4878B0A5  bl 0x82df3a08
	ctx.lr = 0x82668968;
	sub_82DF3A08(ctx, base);
	// 82668968: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266896C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668970: 4BFFFB41  bl 0x826684b0
	ctx.lr = 0x82668974;
	sub_826684B0(ctx, base);
	// 82668974: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82668978: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266897C: 388BA7B0  addi r4, r11, -0x5850
	ctx.r[4].s64 = ctx.r[11].s64 + -22608;
	// 82668980: 4878B089  bl 0x82df3a08
	ctx.lr = 0x82668984;
	sub_82DF3A08(ctx, base);
	// 82668984: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266898C: 4BFFFB85  bl 0x82668510
	ctx.lr = 0x82668990;
	sub_82668510(ctx, base);
	// 82668990: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82668994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668998: 388BA9CC  addi r4, r11, -0x5634
	ctx.r[4].s64 = ctx.r[11].s64 + -22068;
	// 8266899C: 4878B06D  bl 0x82df3a08
	ctx.lr = 0x826689A0;
	sub_82DF3A08(ctx, base);
	// 826689A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826689A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826689A8: 4BFFFBC9  bl 0x82668570
	ctx.lr = 0x826689AC;
	sub_82668570(ctx, base);
	// 826689AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826689B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826689B4: 4878B055  bl 0x82df3a08
	ctx.lr = 0x826689B8;
	sub_82DF3A08(ctx, base);
	// 826689B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826689BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826689C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826689C4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826689C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826689CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826689D0: 487F5F91  bl 0x82e5e960
	ctx.lr = 0x826689D4;
	sub_82E5E960(ctx, base);
	// 826689D4: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826689D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826689DC: 419A0008  beq cr6, 0x826689e4
	if ctx.cr[6].eq {
	pc = 0x826689E4; continue 'dispatch;
	}
	// 826689E0: 4BC57EB1  bl 0x822c0890
	ctx.lr = 0x826689E4;
	sub_822C0890(ctx, base);
	// 826689E4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826689E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826689EC: 38A0011A  li r5, 0x11a
	ctx.r[5].s64 = 282;
	// 826689F0: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 826689F4: 4BC579E5  bl 0x822c03d8
	ctx.lr = 0x826689F8;
	sub_822C03D8(ctx, base);
	// 826689F8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826689FC: 418200A4  beq 0x82668aa0
	if ctx.cr[0].eq {
	pc = 0x82668AA0; continue 'dispatch;
	}
	// 82668A00: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668A04: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82668A08: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82668A0C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82668A10: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82668A14: 48837D1D  bl 0x82ea0730
	ctx.lr = 0x82668A18;
	sub_82EA0730(ctx, base);
	// 82668A18: B3030004  sth r24, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[24].u16 ) };
	// 82668A1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82668A20: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82668A24: 488B17CD  bl 0x82f1a1f0
	ctx.lr = 0x82668A28;
	sub_82F1A1F0(ctx, base);
	// 82668A28: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82668A2C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82668A30: 632A0004  ori r10, r25, 4
	ctx.r[10].u64 = ctx.r[25].u64 | 4;
	// 82668A34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82668A38: 61590008  ori r25, r10, 8
	ctx.r[25].u64 = ctx.r[10].u64 | 8;
	// 82668A3C: 808B679C  lwz r4, 0x679c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26524 as u32) ) } as u64;
	// 82668A40: 4BC7C4F1  bl 0x822e4f30
	ctx.lr = 0x82668A44;
	sub_822E4F30(ctx, base);
	// 82668A44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82668A48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82668A4C: 4BC7C475  bl 0x822e4ec0
	ctx.lr = 0x82668A50;
	sub_822E4EC0(ctx, base);
	// 82668A50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82668A54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668A58: E89D0000  ld r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82668A5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82668A60: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82668A64: 4BE23825  bl 0x8248c288
	ctx.lr = 0x82668A68;
	sub_8248C288(ctx, base);
	// 82668A68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82668A6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82668A70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82668A74: 3B810064  addi r28, r1, 0x64
	ctx.r[28].s64 = ctx.r[1].s64 + 100;
	// 82668A78: 4BEA6AA1  bl 0x8250f518
	ctx.lr = 0x82668A7C;
	sub_8250F518(ctx, base);
	// 82668A7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668A80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668A84: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82668A88: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82668A8C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82668A90: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82668A94: 4BE2970D  bl 0x824921a0
	ctx.lr = 0x82668A98;
	sub_824921A0(ctx, base);
	// 82668A98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668A9C: 48000008  b 0x82668aa4
	pc = 0x82668AA4; continue 'dispatch;
	// 82668AA0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82668AA4: 387F0178  addi r3, r31, 0x178
	ctx.r[3].s64 = ctx.r[31].s64 + 376;
	// 82668AA8: 4BC7C341  bl 0x822e4de8
	ctx.lr = 0x82668AAC;
	sub_822E4DE8(ctx, base);
	// 82668AAC: 572B0739  rlwinm. r11, r25, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82668AB0: 41820010  beq 0x82668ac0
	if ctx.cr[0].eq {
	pc = 0x82668AC0; continue 'dispatch;
	}
	// 82668AB4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82668AB8: 57390776  rlwinm r25, r25, 0, 0x1d, 0x1b
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 82668ABC: 487891D5  bl 0x82df1c90
	ctx.lr = 0x82668AC0;
	sub_82DF1C90(ctx, base);
	// 82668AC0: 572B077B  rlwinm. r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82668AC4: 41820014  beq 0x82668ad8
	if ctx.cr[0].eq {
	pc = 0x82668AD8; continue 'dispatch;
	}
	// 82668AC8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82668ACC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82668AD0: 419A0008  beq cr6, 0x82668ad8
	if ctx.cr[6].eq {
	pc = 0x82668AD8; continue 'dispatch;
	}
	// 82668AD4: 4BC7F795  bl 0x822e8268
	ctx.lr = 0x82668AD8;
	sub_822E8268(ctx, base);
	// 82668AD8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82668ADC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668AE0: 38A0011B  li r5, 0x11b
	ctx.r[5].s64 = 283;
	// 82668AE4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82668AE8: 4BC578F1  bl 0x822c03d8
	ctx.lr = 0x82668AEC;
	sub_822C03D8(ctx, base);
	// 82668AEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668AF0: 41820014  beq 0x82668b04
	if ctx.cr[0].eq {
	pc = 0x82668B04; continue 'dispatch;
	}
	// 82668AF4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82668AF8: 4BE285F9  bl 0x824910f0
	ctx.lr = 0x82668AFC;
	sub_824910F0(ctx, base);
	// 82668AFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668B00: 48000008  b 0x82668b08
	pc = 0x82668B08; continue 'dispatch;
	// 82668B04: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82668B08: 387F0180  addi r3, r31, 0x180
	ctx.r[3].s64 = ctx.r[31].s64 + 384;
	// 82668B0C: 4BCA1BD5  bl 0x8230a6e0
	ctx.lr = 0x82668B10;
	sub_8230A6E0(ctx, base);
	// 82668B10: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82668B14: 4BE9FF45  bl 0x82508a58
	ctx.lr = 0x82668B18;
	sub_82508A58(ctx, base);
	// 82668B18: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668B1C: 41820020  beq 0x82668b3c
	if ctx.cr[0].eq {
	pc = 0x82668B3C; continue 'dispatch;
	}
	// 82668B20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82668B24: 83DF018C  lwz r30, 0x18c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82668B28: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82668B2C: 4BE9FEED  bl 0x82508a18
	ctx.lr = 0x82668B30;
	sub_82508A18(ctx, base);
	// 82668B30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82668B34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668B38: 48001BA9  bl 0x8266a6e0
	ctx.lr = 0x82668B3C;
	sub_8266A6E0(ctx, base);
	// 82668B3C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82668B40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668B44: 38A00123  li r5, 0x123
	ctx.r[5].s64 = 291;
	// 82668B48: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82668B4C: 4BC5788D  bl 0x822c03d8
	ctx.lr = 0x82668B50;
	sub_822C03D8(ctx, base);
	// 82668B50: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82668B54: 41820030  beq 0x82668b84
	if ctx.cr[0].eq {
	pc = 0x82668B84; continue 'dispatch;
	}
	// 82668B58: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668B5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82668B60: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82668B64: 409A0008  bne cr6, 0x82668b6c
	if !ctx.cr[6].eq {
	pc = 0x82668B6C; continue 'dispatch;
	}
	// 82668B68: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82668B6C: 4BEBF4E5  bl 0x82528050
	ctx.lr = 0x82668B70;
	sub_82528050(ctx, base);
	// 82668B70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82668B74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82668B78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668B7C: 48000ADD  bl 0x82669658
	ctx.lr = 0x82668B80;
	sub_82669658(ctx, base);
	// 82668B80: 48000008  b 0x82668b88
	pc = 0x82668B88; continue 'dispatch;
	// 82668B84: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82668B88: 83DF0190  lwz r30, 0x190(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82668B8C: 907F0190  stw r3, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[3].u32 ) };
	// 82668B90: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82668B94: 419A0014  beq cr6, 0x82668ba8
	if ctx.cr[6].eq {
	pc = 0x82668BA8; continue 'dispatch;
	}
	// 82668B98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668B9C: 48000A5D  bl 0x826695f8
	ctx.lr = 0x82668BA0;
	sub_826695F8(ctx, base);
	// 82668BA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668BA4: 4BC576C5  bl 0x822c0268
	ctx.lr = 0x82668BA8;
	sub_822C0268(ctx, base);
	// 82668BA8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82668BAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668BB0: 38A00124  li r5, 0x124
	ctx.r[5].s64 = 292;
	// 82668BB4: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82668BB8: 4BC57821  bl 0x822c03d8
	ctx.lr = 0x82668BBC;
	sub_822C03D8(ctx, base);
	// 82668BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668BC0: 41820010  beq 0x82668bd0
	if ctx.cr[0].eq {
	pc = 0x82668BD0; continue 'dispatch;
	}
	// 82668BC4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82668BC8: 484DD869  bl 0x82b46430
	ctx.lr = 0x82668BCC;
	sub_82B46430(ctx, base);
	// 82668BCC: 48000008  b 0x82668bd4
	pc = 0x82668BD4; continue 'dispatch;
	// 82668BD0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82668BD4: 83DF0224  lwz r30, 0x224(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82668BD8: 907F0224  stw r3, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[3].u32 ) };
	// 82668BDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82668BE0: 419A0014  beq cr6, 0x82668bf4
	if ctx.cr[6].eq {
	pc = 0x82668BF4; continue 'dispatch;
	}
	// 82668BE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668BE8: 484DD841  bl 0x82b46428
	ctx.lr = 0x82668BEC;
	sub_82B46428(ctx, base);
	// 82668BEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82668BF0: 4BC57679  bl 0x822c0268
	ctx.lr = 0x82668BF4;
	sub_822C0268(ctx, base);
	// 82668BF4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82668BF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82668BFC: 38A00125  li r5, 0x125
	ctx.r[5].s64 = 293;
	// 82668C00: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 82668C04: 487897E5  bl 0x82df23e8
	ctx.lr = 0x82668C08;
	sub_82DF23E8(ctx, base);
	// 82668C08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82668C0C: 41820010  beq 0x82668c1c
	if ctx.cr[0].eq {
	pc = 0x82668C1C; continue 'dispatch;
	}
	// 82668C10: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82668C14: 4816793D  bl 0x827d0550
	ctx.lr = 0x82668C18;
	sub_827D0550(ctx, base);
	// 82668C18: 48000008  b 0x82668c20
	pc = 0x82668C20; continue 'dispatch;
	// 82668C1C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82668C20: 817F0230  lwz r11, 0x230(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82668C24: 907F0230  stw r3, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[3].u32 ) };
	// 82668C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82668C2C: 419A001C  beq cr6, 0x82668c48
	if ctx.cr[6].eq {
	pc = 0x82668C48; continue 'dispatch;
	}
	// 82668C30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668C34: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82668C38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82668C3C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82668C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82668C44: 4E800421  bctrl
	ctx.lr = 0x82668C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82668C48: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82668C4C: CBE1FF80  lfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82668C50: 48B3F540  b 0x831a8190
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82668C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82668C58 size=2260
    let mut pc: u32 = 0x82668C58;
    'dispatch: loop {
        match pc {
            0x82668C58 => {
    //   block [0x82668C58..0x8266952C)
	// 82668C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82668C5C: 48B3F4F5  bl 0x831a8150
	ctx.lr = 0x82668C60;
	sub_831A8130(ctx, base);
	// 82668C60: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82668C64: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82668C68: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82668C6C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82668C70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82668C74: 48AEB98D  bl 0x83154600
	ctx.lr = 0x82668C78;
	sub_83154600(ctx, base);
	// 82668C78: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82668C7C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82668C80: 4BEA66F1  bl 0x8250f370
	ctx.lr = 0x82668C84;
	sub_8250F370(ctx, base);
	// 82668C84: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82668C88: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82668C8C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82668C90: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82668C94: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 82668C98: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82668C9C: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82668CA0: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82668CA4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82668CA8: D3E100E0  stfs f31, 0xe0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82668CAC: D3E100E4  stfs f31, 0xe4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82668CB0: D00100E8  stfs f0, 0xe8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82668CB4: D3E100EC  stfs f31, 0xec(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82669530 size=196
    let mut pc: u32 = 0x82669530;
    'dispatch: loop {
        match pc {
            0x82669530 => {
    //   block [0x82669530..0x826695F4)
	// 82669530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266953C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669544: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82669548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266954C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82669550: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82669554: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669558: 4BC573E1  bl 0x822c0938
	ctx.lr = 0x8266955C;
	sub_822C0938(ctx, base);
	// 8266955C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82669560: 41820028  beq 0x82669588
	if ctx.cr[0].eq {
	pc = 0x82669588; continue 'dispatch;
	}
	// 82669564: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669568: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266956C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82669570: 392BAA34  addi r9, r11, -0x55cc
	ctx.r[9].s64 = ctx.r[11].s64 + -21964;
	// 82669574: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82669578: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266957C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82669580: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82669584: 48000008  b 0x8266958c
	pc = 0x8266958C; continue 'dispatch;
	// 82669588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266958C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669594: 409A0044  bne cr6, 0x826695d8
	if !ctx.cr[6].eq {
	pc = 0x826695D8; continue 'dispatch;
	}
	// 82669598: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266959C: 419A001C  beq cr6, 0x826695b8
	if ctx.cr[6].eq {
	pc = 0x826695B8; continue 'dispatch;
	}
	// 826695A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826695A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826695A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826695AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826695B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826695B4: 4E800421  bctrl
	ctx.lr = 0x826695B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826695B8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826695BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826695C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826695C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826695C8: 816B6BF4  lwz r11, 0x6bf4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27636 as u32) ) } as u64;
	// 826695CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826695D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826695D4: 4BC56A2D  bl 0x822c0000
	ctx.lr = 0x826695D8;
	sub_822C0000(ctx, base);
	// 826695D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826695DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826695E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826695E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826695E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826695EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826695F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826695F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826695F8 size=96
    let mut pc: u32 = 0x826695F8;
    'dispatch: loop {
        match pc {
            0x826695F8 => {
    //   block [0x826695F8..0x82669658)
	// 826695F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826695FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669604: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266960C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82669610: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82669614: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82669618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266961C: 419A0008  beq cr6, 0x82669624
	if ctx.cr[6].eq {
	pc = 0x82669624; continue 'dispatch;
	}
	// 82669620: 4BC57271  bl 0x822c0890
	ctx.lr = 0x82669624;
	sub_822C0890(ctx, base);
	// 82669624: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82669628: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266962C: 419A0008  beq cr6, 0x82669634
	if ctx.cr[6].eq {
	pc = 0x82669634; continue 'dispatch;
	}
	// 82669630: 4BC57261  bl 0x822c0890
	ctx.lr = 0x82669634;
	sub_822C0890(ctx, base);
	// 82669634: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82669638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266963C: 419A0008  beq cr6, 0x82669644
	if ctx.cr[6].eq {
	pc = 0x82669644; continue 'dispatch;
	}
	// 82669640: 4BC57251  bl 0x822c0890
	ctx.lr = 0x82669644;
	sub_822C0890(ctx, base);
	// 82669644: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82669648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266964C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82669658 size=140
    let mut pc: u32 = 0x82669658;
    'dispatch: loop {
        match pc {
            0x82669658 => {
    //   block [0x82669658..0x826696E4)
	// 82669658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266965C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82669664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266966C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669670: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82669674: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82669678: 90BF0000  stw r5, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8266967C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82669680: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82669684: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82669688: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 8266968C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82669690: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82669694: 909F001C  stw r4, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82669698: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8266969C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826696A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826696A4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 826696A8: 419A0008  beq cr6, 0x826696b0
	if ctx.cr[6].eq {
	pc = 0x826696B0; continue 'dispatch;
	}
	// 826696AC: 4BC571E5  bl 0x822c0890
	ctx.lr = 0x826696B0;
	sub_822C0890(ctx, base);
	// 826696B0: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 826696B4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 826696B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826696BC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 826696C0: 419A0008  beq cr6, 0x826696c8
	if ctx.cr[6].eq {
	pc = 0x826696C8; continue 'dispatch;
	}
	// 826696C4: 4BC571CD  bl 0x822c0890
	ctx.lr = 0x826696C8;
	sub_822C0890(ctx, base);
	// 826696C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826696CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826696D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826696D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826696D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826696DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826696E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826696E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826696E8 size=112
    let mut pc: u32 = 0x826696E8;
    'dispatch: loop {
        match pc {
            0x826696E8 => {
    //   block [0x826696E8..0x82669758)
	// 826696E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826696EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826696F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826696F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826696F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826696FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82669700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669704: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82669708: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266970C: 4BFFFE25  bl 0x82669530
	ctx.lr = 0x82669710;
	sub_82669530(ctx, base);
	// 82669710: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82669714: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82669718: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266971C: 4BC568E5  bl 0x822c0000
	ctx.lr = 0x82669720;
	sub_822C0000(ctx, base);
	// 82669720: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82669724: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82669728: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266972C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82669730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669734: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82669738: 419A0008  beq cr6, 0x82669740
	if ctx.cr[6].eq {
	pc = 0x82669740; continue 'dispatch;
	}
	// 8266973C: 4BC57155  bl 0x822c0890
	ctx.lr = 0x82669740;
	sub_822C0890(ctx, base);
	// 82669740: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82669744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266974C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82669750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82669758 size=148
    let mut pc: u32 = 0x82669758;
    'dispatch: loop {
        match pc {
            0x82669758 => {
    //   block [0x82669758..0x826697EC)
	// 82669758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266975C: 48B3EA0D  bl 0x831a8168
	ctx.lr = 0x82669760;
	sub_831A8130(ctx, base);
	// 82669760: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669764: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82669768: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8266976C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82669770: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82669774: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82669778: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266977C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82669780: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82669784: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82669788: 48788C61  bl 0x82df23e8
	ctx.lr = 0x8266978C;
	sub_82DF23E8(ctx, base);
	// 8266978C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82669790: 41820028  beq 0x826697b8
	if ctx.cr[0].eq {
	pc = 0x826697B8; continue 'dispatch;
	}
	// 82669794: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82669798: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266979C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826697A0: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826697A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826697A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826697AC: 484E8075  bl 0x82b51820
	ctx.lr = 0x826697B0;
	sub_82B51820(ctx, base);
	// 826697B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826697B4: 48000008  b 0x826697bc
	pc = 0x826697BC; continue 'dispatch;
	// 826697B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826697BC: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826697C0: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 826697C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826697C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826697CC: 4BC97A55  bl 0x82301220
	ctx.lr = 0x826697D0;
	sub_82301220(ctx, base);
	// 826697D0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826697D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826697D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826697DC: 4BC56825  bl 0x822c0000
	ctx.lr = 0x826697E0;
	sub_822C0000(ctx, base);
	// 826697E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826697E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826697E8: 48B3E9D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826697F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826697F0 size=112
    let mut pc: u32 = 0x826697F0;
    'dispatch: loop {
        match pc {
            0x826697F0 => {
    //   block [0x826697F0..0x82669860)
	// 826697F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826697F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826697F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826697FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82669808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266980C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82669810: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82669814: 4BDFBAED  bl 0x82465300
	ctx.lr = 0x82669818;
	sub_82465300(ctx, base);
	// 82669818: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8266981C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82669820: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82669824: 4BC567DD  bl 0x822c0000
	ctx.lr = 0x82669828;
	sub_822C0000(ctx, base);
	// 82669828: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8266982C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82669830: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669834: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82669838: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266983C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82669840: 419A0008  beq cr6, 0x82669848
	if ctx.cr[6].eq {
	pc = 0x82669848; continue 'dispatch;
	}
	// 82669844: 4BC5704D  bl 0x822c0890
	ctx.lr = 0x82669848;
	sub_822C0890(ctx, base);
	// 82669848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266984C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82669858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266985C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82669860 size=280
    let mut pc: u32 = 0x82669860;
    'dispatch: loop {
        match pc {
            0x82669860 => {
    //   block [0x82669860..0x82669978)
	// 82669860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669864: 48B3E905  bl 0x831a8168
	ctx.lr = 0x82669868;
	sub_831A8130(ctx, base);
	// 82669868: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266986C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669874: 3B8BAA48  addi r28, r11, -0x55b8
	ctx.r[28].s64 = ctx.r[11].s64 + -21944;
	// 82669878: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8266987C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82669880: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82669884: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 82669888: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266988C: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 82669890: 48788B59  bl 0x82df23e8
	ctx.lr = 0x82669894;
	sub_82DF23E8(ctx, base);
	// 82669894: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82669898: 41820018  beq 0x826698b0
	if ctx.cr[0].eq {
	pc = 0x826698B0; continue 'dispatch;
	}
	// 8266989C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826698A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826698A4: 4BE02005  bl 0x8246b8a8
	ctx.lr = 0x826698A8;
	sub_8246B8A8(ctx, base);
	// 826698A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826698AC: 48000008  b 0x826698b4
	pc = 0x826698B4; continue 'dispatch;
	// 826698B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826698B4: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 826698B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826698BC: 4BFFFE2D  bl 0x826696e8
	ctx.lr = 0x826698C0;
	sub_826696E8(ctx, base);
	// 826698C0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 826698C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826698C8: 419A00A8  beq cr6, 0x82669970
	if ctx.cr[6].eq {
	pc = 0x82669970; continue 'dispatch;
	}
	// 826698CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826698D0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 826698D4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826698D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826698DC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 826698E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826698E4: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826698E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826698EC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826698F0: 4BFFFE69  bl 0x82669758
	ctx.lr = 0x826698F4;
	sub_82669758(ctx, base);
	// 826698F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826698F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826698FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82669900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669904: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82669908: 419A0024  beq cr6, 0x8266992c
	if ctx.cr[6].eq {
	pc = 0x8266992C; continue 'dispatch;
	}
	// 8266990C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82669910: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82669914: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82669918: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8266991C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82669920: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82669924: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82669928: 4082FFE8  bne 0x82669910
	if !ctx.cr[0].eq {
	pc = 0x82669910; continue 'dispatch;
	}
	// 8266992C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82669930: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669934: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82669938: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266993C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82669940: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 82669944: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82669948: C02A6150  lfs f1, 0x6150(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266994C: 487EF0F5  bl 0x82e58a40
	ctx.lr = 0x82669950;
	sub_82E58A40(ctx, base);
	// 82669950: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82669954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669958: 419A0008  beq cr6, 0x82669960
	if ctx.cr[6].eq {
	pc = 0x82669960; continue 'dispatch;
	}
	// 8266995C: 4BC56F35  bl 0x822c0890
	ctx.lr = 0x82669960;
	sub_822C0890(ctx, base);
	// 82669960: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82669964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669968: 419A0008  beq cr6, 0x82669970
	if ctx.cr[6].eq {
	pc = 0x82669970; continue 'dispatch;
	}
	// 8266996C: 4BC56F25  bl 0x822c0890
	ctx.lr = 0x82669970;
	sub_822C0890(ctx, base);
	// 82669970: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82669974: 48B3E844  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82669978 size=224
    let mut pc: u32 = 0x82669978;
    'dispatch: loop {
        match pc {
            0x82669978 => {
    //   block [0x82669978..0x82669A58)
	// 82669978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266997C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669984: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266998C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669994: 419A00B0  beq cr6, 0x82669a44
	if ctx.cr[6].eq {
	pc = 0x82669A44; continue 'dispatch;
	}
	// 82669998: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266999C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826699A0: 419A00A4  beq cr6, 0x82669a44
	if ctx.cr[6].eq {
	pc = 0x82669A44; continue 'dispatch;
	}
	// 826699A4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826699A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826699AC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 826699B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826699B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826699B8: C00A9524  lfs f0, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826699BC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826699C0: 481DCC51  bl 0x82846610
	ctx.lr = 0x826699C4;
	sub_82846610(ctx, base);
	// 826699C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826699C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826699CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826699D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826699D4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826699D8: 419A0024  beq cr6, 0x826699fc
	if ctx.cr[6].eq {
	pc = 0x826699FC; continue 'dispatch;
	}
	// 826699DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826699E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826699E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826699E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826699EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826699F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826699F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826699F8: 4082FFE8  bne 0x826699e0
	if !ctx.cr[0].eq {
	pc = 0x826699E0; continue 'dispatch;
	}
	// 826699FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82669A00: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669A04: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 82669A08: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669A0C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82669A10: 3889AA48  addi r4, r9, -0x55b8
	ctx.r[4].s64 = ctx.r[9].s64 + -21944;
	// 82669A14: 38A00049  li r5, 0x49
	ctx.r[5].s64 = 73;
	// 82669A18: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82669A1C: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82669A20: 487EF021  bl 0x82e58a40
	ctx.lr = 0x82669A24;
	sub_82E58A40(ctx, base);
	// 82669A24: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82669A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669A2C: 419A0008  beq cr6, 0x82669a34
	if ctx.cr[6].eq {
	pc = 0x82669A34; continue 'dispatch;
	}
	// 82669A30: 4BC56E61  bl 0x822c0890
	ctx.lr = 0x82669A34;
	sub_822C0890(ctx, base);
	// 82669A34: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82669A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669A3C: 419A0008  beq cr6, 0x82669a44
	if ctx.cr[6].eq {
	pc = 0x82669A44; continue 'dispatch;
	}
	// 82669A40: 4BC56E51  bl 0x822c0890
	ctx.lr = 0x82669A44;
	sub_822C0890(ctx, base);
	// 82669A44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82669A48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669A4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669A50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669A54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82669A58 size=400
    let mut pc: u32 = 0x82669A58;
    'dispatch: loop {
        match pc {
            0x82669A58 => {
    //   block [0x82669A58..0x82669BE8)
	// 82669A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669A5C: 48B3E711  bl 0x831a816c
	ctx.lr = 0x82669A60;
	sub_831A8130(ctx, base);
	// 82669A60: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82669A64: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82669A68: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669A70: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 82669A74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82669A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669A7C: 409A015C  bne cr6, 0x82669bd8
	if !ctx.cr[6].eq {
	pc = 0x82669BD8; continue 'dispatch;
	}
	// 82669A80: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82669A84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82669A88: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82669A8C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82669A90: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82669A94: C00B2788  lfs f0, 0x2788(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82669A98: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82669A9C: C3CA9524  lfs f30, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82669AA0: C1A9959C  lfs f13, -0x6a64(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82669AA4: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82669AA8: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82669AAC: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82669AB0: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82669AB4: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82669AB8: 48813A89  bl 0x82e7d540
	ctx.lr = 0x82669ABC;
	sub_82E7D540(ctx, base);
	// 82669ABC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82669AC0: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 82669AC4: FCA0F890  fmr f5, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[5].f64 = ctx.f[31].f64;
	// 82669AC8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82669ACC: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82669AD0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82669AD4: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82669AD8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82669ADC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82669AE0: C04B08A8  lfs f2, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82669AE4: 4BE0ACA5  bl 0x82474788
	ctx.lr = 0x82669AE8;
	sub_82474788(ctx, base);
	// 82669AE8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669AEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82669AF0: 3BABAA48  addi r29, r11, -0x55b8
	ctx.r[29].s64 = ctx.r[11].s64 + -21944;
	// 82669AF4: 38A00059  li r5, 0x59
	ctx.r[5].s64 = 89;
	// 82669AF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82669AFC: 386001C0  li r3, 0x1c0
	ctx.r[3].s64 = 448;
	// 82669B00: 487888E9  bl 0x82df23e8
	ctx.lr = 0x82669B04;
	sub_82DF23E8(ctx, base);
	// 82669B04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82669B08: 41820014  beq 0x82669b1c
	if ctx.cr[0].eq {
	pc = 0x82669B1C; continue 'dispatch;
	}
	// 82669B0C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82669B10: 4BE08649  bl 0x82472158
	ctx.lr = 0x82669B14;
	sub_82472158(ctx, base);
	// 82669B14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82669B18: 48000008  b 0x82669b20
	pc = 0x82669B20; continue 'dispatch;
	// 82669B1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82669B20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82669B24: 4BFFFCCD  bl 0x826697f0
	ctx.lr = 0x82669B28;
	sub_826697F0(ctx, base);
	// 82669B28: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669B2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669B30: 419A00A8  beq cr6, 0x82669bd8
	if ctx.cr[6].eq {
	pc = 0x82669BD8; continue 'dispatch;
	}
	// 82669B34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82669B38: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82669B3C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82669B40: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82669B44: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82669B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82669B4C: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82669B50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82669B54: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82669B58: 4BFFFC01  bl 0x82669758
	ctx.lr = 0x82669B5C;
	sub_82669758(ctx, base);
	// 82669B5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669B60: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82669B64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82669B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669B6C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82669B70: 419A0024  beq cr6, 0x82669b94
	if ctx.cr[6].eq {
	pc = 0x82669B94; continue 'dispatch;
	}
	// 82669B74: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82669B78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82669B7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82669B80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82669B84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82669B88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82669B8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82669B90: 4082FFE8  bne 0x82669b78
	if !ctx.cr[0].eq {
	pc = 0x82669B78; continue 'dispatch;
	}
	// 82669B94: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82669B98: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669B9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82669BA0: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669BA4: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 82669BA8: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 82669BAC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82669BB0: C02A7BC8  lfs f1, 0x7bc8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82669BB4: 487EEE8D  bl 0x82e58a40
	ctx.lr = 0x82669BB8;
	sub_82E58A40(ctx, base);
	// 82669BB8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82669BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669BC0: 419A0008  beq cr6, 0x82669bc8
	if ctx.cr[6].eq {
	pc = 0x82669BC8; continue 'dispatch;
	}
	// 82669BC4: 4BC56CCD  bl 0x822c0890
	ctx.lr = 0x82669BC8;
	sub_822C0890(ctx, base);
	// 82669BC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82669BCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669BD0: 419A0008  beq cr6, 0x82669bd8
	if ctx.cr[6].eq {
	pc = 0x82669BD8; continue 'dispatch;
	}
	// 82669BD4: 4BC56CBD  bl 0x822c0890
	ctx.lr = 0x82669BD8;
	sub_822C0890(ctx, base);
	// 82669BD8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82669BDC: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82669BE0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82669BE4: 48B3E5D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82669BE8 size=224
    let mut pc: u32 = 0x82669BE8;
    'dispatch: loop {
        match pc {
            0x82669BE8 => {
    //   block [0x82669BE8..0x82669CC8)
	// 82669BE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669BEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669BF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669BF4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669BF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669BFC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669C00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669C04: 419A00B0  beq cr6, 0x82669cb4
	if ctx.cr[6].eq {
	pc = 0x82669CB4; continue 'dispatch;
	}
	// 82669C08: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82669C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669C10: 419A00A4  beq cr6, 0x82669cb4
	if ctx.cr[6].eq {
	pc = 0x82669CB4; continue 'dispatch;
	}
	// 82669C14: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82669C18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82669C1C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82669C20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82669C24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82669C28: C00A9450  lfs f0, -0x6bb0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82669C2C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82669C30: 481DC9E1  bl 0x82846610
	ctx.lr = 0x82669C34;
	sub_82846610(ctx, base);
	// 82669C34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669C38: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82669C3C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82669C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669C44: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82669C48: 419A0024  beq cr6, 0x82669c6c
	if ctx.cr[6].eq {
	pc = 0x82669C6C; continue 'dispatch;
	}
	// 82669C4C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82669C50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82669C54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82669C58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82669C5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82669C60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82669C64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82669C68: 4082FFE8  bne 0x82669c50
	if !ctx.cr[0].eq {
	pc = 0x82669C50; continue 'dispatch;
	}
	// 82669C6C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82669C70: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82669C74: 3D208205  lis r9, -0x7dfb
	ctx.r[9].s64 = -2113601536;
	// 82669C78: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669C7C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82669C80: 3889AA48  addi r4, r9, -0x55b8
	ctx.r[4].s64 = ctx.r[9].s64 + -21944;
	// 82669C84: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82669C88: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 82669C8C: C02A6150  lfs f1, 0x6150(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82669C90: 487EEDB1  bl 0x82e58a40
	ctx.lr = 0x82669C94;
	sub_82E58A40(ctx, base);
	// 82669C94: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82669C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669C9C: 419A0008  beq cr6, 0x82669ca4
	if ctx.cr[6].eq {
	pc = 0x82669CA4; continue 'dispatch;
	}
	// 82669CA0: 4BC56BF1  bl 0x822c0890
	ctx.lr = 0x82669CA4;
	sub_822C0890(ctx, base);
	// 82669CA4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82669CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82669CAC: 419A0008  beq cr6, 0x82669cb4
	if ctx.cr[6].eq {
	pc = 0x82669CB4; continue 'dispatch;
	}
	// 82669CB0: 4BC56BE1  bl 0x822c0890
	ctx.lr = 0x82669CB4;
	sub_822C0890(ctx, base);
	// 82669CB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82669CB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669CBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669CC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82669CC8 size=160
    let mut pc: u32 = 0x82669CC8;
    'dispatch: loop {
        match pc {
            0x82669CC8 => {
    //   block [0x82669CC8..0x82669D68)
	// 82669CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669CD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82669CD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669CD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669CE0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82669CE4: 4802B055  bl 0x82694d38
	ctx.lr = 0x82669CE8;
	sub_82694D38(ctx, base);
	// 82669CE8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82669CEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669CF0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82669CF4: 48789D15  bl 0x82df3a08
	ctx.lr = 0x82669CF8;
	sub_82DF3A08(ctx, base);
	// 82669CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82669CFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82669D00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82669D04: 4BE9EA7D  bl 0x82508780
	ctx.lr = 0x82669D08;
	sub_82508780(ctx, base);
	// 82669D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669D0C: 4878971D  bl 0x82df3428
	ctx.lr = 0x82669D10;
	sub_82DF3428(ctx, base);
	// 82669D10: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82669D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669D18: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 82669D1C: 48789CED  bl 0x82df3a08
	ctx.lr = 0x82669D20;
	sub_82DF3A08(ctx, base);
	// 82669D20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82669D24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82669D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82669D2C: 4BE9EA55  bl 0x82508780
	ctx.lr = 0x82669D30;
	sub_82508780(ctx, base);
	// 82669D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669D34: 487896F5  bl 0x82df3428
	ctx.lr = 0x82669D38;
	sub_82DF3428(ctx, base);
	// 82669D38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82669D3C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82669D40: 409A0008  bne cr6, 0x82669d48
	if !ctx.cr[6].eq {
	pc = 0x82669D48; continue 'dispatch;
	}
	// 82669D44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82669D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82669D4C: 4BE9EA55  bl 0x825087a0
	ctx.lr = 0x82669D50;
	sub_825087A0(ctx, base);
	// 82669D50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82669D54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669D58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669D5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82669D60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669D64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82669D68 size=108
    let mut pc: u32 = 0x82669D68;
    'dispatch: loop {
        match pc {
            0x82669D68 => {
    //   block [0x82669D68..0x82669DD4)
	// 82669D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669D6C: 48B3E401  bl 0x831a816c
	ctx.lr = 0x82669D70;
	sub_831A8130(ctx, base);
	// 82669D70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669D74: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82669D78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82669D7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82669D80: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82669D84: 41820038  beq 0x82669dbc
	if ctx.cr[0].eq {
	pc = 0x82669DBC; continue 'dispatch;
	}
	// 82669D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82669D8C: 48B3FBFD  bl 0x831a9988
	ctx.lr = 0x82669D90;
	sub_831A9988(ctx, base);
	// 82669D90: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82669D94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82669D98: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82669D9C: 48B3E35D  bl 0x831a80f8
	ctx.lr = 0x82669DA0;
	sub_831A80F8(ctx, base);
	// 82669DA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82669DA4: 41820018  beq 0x82669dbc
	if ctx.cr[0].eq {
	pc = 0x82669DBC; continue 'dispatch;
	}
	// 82669DA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82669DAC: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82669DB0: 4842AA79  bl 0x82a94828
	ctx.lr = 0x82669DB4;
	sub_82A94828(ctx, base);
	// 82669DB4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82669DB8: 48000014  b 0x82669dcc
	pc = 0x82669DCC; continue 'dispatch;
	// 82669DBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82669DC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82669DC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82669DC8: 4BEA8851  bl 0x82512618
	ctx.lr = 0x82669DCC;
	sub_82512618(ctx, base);
	// 82669DCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82669DD0: 48B3E3EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82669DD8 size=196
    let mut pc: u32 = 0x82669DD8;
    'dispatch: loop {
        match pc {
            0x82669DD8 => {
    //   block [0x82669DD8..0x82669E9C)
	// 82669DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669DE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82669DE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669DE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669DEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82669DF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82669DF4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82669DF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82669DFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669E00: 4BC56B39  bl 0x822c0938
	ctx.lr = 0x82669E04;
	sub_822C0938(ctx, base);
	// 82669E04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82669E08: 41820028  beq 0x82669e30
	if ctx.cr[0].eq {
	pc = 0x82669E30; continue 'dispatch;
	}
	// 82669E0C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669E10: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82669E14: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82669E18: 392BAAA4  addi r9, r11, -0x555c
	ctx.r[9].s64 = ctx.r[11].s64 + -21852;
	// 82669E1C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82669E20: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82669E24: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82669E28: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82669E2C: 48000008  b 0x82669e34
	pc = 0x82669E34; continue 'dispatch;
	// 82669E30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82669E34: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669E3C: 409A0044  bne cr6, 0x82669e80
	if !ctx.cr[6].eq {
	pc = 0x82669E80; continue 'dispatch;
	}
	// 82669E40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82669E44: 419A001C  beq cr6, 0x82669e60
	if ctx.cr[6].eq {
	pc = 0x82669E60; continue 'dispatch;
	}
	// 82669E48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669E4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82669E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82669E54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669E58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82669E5C: 4E800421  bctrl
	ctx.lr = 0x82669E60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82669E60: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82669E64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82669E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669E6C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82669E70: 816B6C40  lwz r11, 0x6c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27712 as u32) ) } as u64;
	// 82669E74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82669E78: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82669E7C: 4BC56185  bl 0x822c0000
	ctx.lr = 0x82669E80;
	sub_822C0000(ctx, base);
	// 82669E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82669E84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82669E88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669E8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669E90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82669E94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669E98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82669EA0 size=196
    let mut pc: u32 = 0x82669EA0;
    'dispatch: loop {
        match pc {
            0x82669EA0 => {
    //   block [0x82669EA0..0x82669F64)
	// 82669EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82669EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82669EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82669EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669EB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82669EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82669EBC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82669EC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82669EC4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669EC8: 4BC56A71  bl 0x822c0938
	ctx.lr = 0x82669ECC;
	sub_822C0938(ctx, base);
	// 82669ECC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82669ED0: 41820028  beq 0x82669ef8
	if ctx.cr[0].eq {
	pc = 0x82669EF8; continue 'dispatch;
	}
	// 82669ED4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669ED8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82669EDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82669EE0: 392BAAB8  addi r9, r11, -0x5548
	ctx.r[9].s64 = ctx.r[11].s64 + -21832;
	// 82669EE4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82669EE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82669EEC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82669EF0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82669EF4: 48000008  b 0x82669efc
	pc = 0x82669EFC; continue 'dispatch;
	// 82669EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82669EFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82669F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82669F04: 409A0044  bne cr6, 0x82669f48
	if !ctx.cr[6].eq {
	pc = 0x82669F48; continue 'dispatch;
	}
	// 82669F08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82669F0C: 419A001C  beq cr6, 0x82669f28
	if ctx.cr[6].eq {
	pc = 0x82669F28; continue 'dispatch;
	}
	// 82669F10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669F14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82669F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82669F1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82669F20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82669F24: 4E800421  bctrl
	ctx.lr = 0x82669F28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82669F28: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82669F2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82669F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669F34: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82669F38: 816B6C40  lwz r11, 0x6c40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27712 as u32) ) } as u64;
	// 82669F3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82669F40: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82669F44: 4BC560BD  bl 0x822c0000
	ctx.lr = 0x82669F48;
	sub_822C0000(ctx, base);
	// 82669F48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82669F4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82669F50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82669F54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82669F58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82669F5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82669F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82669F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82669F68 size=748
    let mut pc: u32 = 0x82669F68;
    'dispatch: loop {
        match pc {
            0x82669F68 => {
    //   block [0x82669F68..0x8266A254)
	// 82669F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82669F6C: 48B3E1FD  bl 0x831a8168
	ctx.lr = 0x82669F70;
	sub_831A8130(ctx, base);
	// 82669F70: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82669F74: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82669F78: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82669F7C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82669F80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82669F84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82669F88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82669F8C: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82669F90: 419A02B4  beq cr6, 0x8266a244
	if ctx.cr[6].eq {
	pc = 0x8266A244; continue 'dispatch;
	}
	// 82669F94: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669F98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82669F9C: 388BAB60  addi r4, r11, -0x54a0
	ctx.r[4].s64 = ctx.r[11].s64 + -21664;
	// 82669FA0: 38A0006E  li r5, 0x6e
	ctx.r[5].s64 = 110;
	// 82669FA4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82669FA8: 4BC56431  bl 0x822c03d8
	ctx.lr = 0x82669FAC;
	sub_822C03D8(ctx, base);
	// 82669FAC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82669FB0: 41820034  beq 0x82669fe4
	if ctx.cr[0].eq {
	pc = 0x82669FE4; continue 'dispatch;
	}
	// 82669FB4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 82669FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82669FBC: 388BAB44  addi r4, r11, -0x54bc
	ctx.r[4].s64 = ctx.r[11].s64 + -21692;
	// 82669FC0: 48789A49  bl 0x82df3a08
	ctx.lr = 0x82669FC4;
	sub_82DF3A08(ctx, base);
	// 82669FC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82669FC8: 38BE0044  addi r5, r30, 0x44
	ctx.r[5].s64 = ctx.r[30].s64 + 68;
	// 82669FCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82669FD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82669FD4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82669FD8: 4BF42439  bl 0x825ac410
	ctx.lr = 0x82669FDC;
	sub_825AC410(ctx, base);
	// 82669FDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82669FE0: 48000008  b 0x82669fe8
	pc = 0x82669FE8; continue 'dispatch;
	// 82669FE4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82669FE8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82669FEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82669FF0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82669FF4: 4BE893C5  bl 0x824f33b8
	ctx.lr = 0x82669FF8;
	sub_824F33B8(ctx, base);
	// 82669FF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82669FFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A000: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8266A004: 4BC55FFD  bl 0x822c0000
	ctx.lr = 0x8266A008;
	sub_822C0000(ctx, base);
	// 8266A008: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266A00C: 4182000C  beq 0x8266a018
	if ctx.cr[0].eq {
	pc = 0x8266A018; continue 'dispatch;
	}
	// 8266A010: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A014: 48789415  bl 0x82df3428
	ctx.lr = 0x8266A018;
	sub_82DF3428(ctx, base);
	// 8266A018: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A01C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A020: 388BAB34  addi r4, r11, -0x54cc
	ctx.r[4].s64 = ctx.r[11].s64 + -21708;
	// 8266A024: 487899E5  bl 0x82df3a08
	ctx.lr = 0x8266A028;
	sub_82DF3A08(ctx, base);
	// 8266A028: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8266A02C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266A030: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8266A034: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8266A038: 4BF41D89  bl 0x825abdc0
	ctx.lr = 0x8266A03C;
	sub_825ABDC0(ctx, base);
	// 8266A03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A040: 487893E9  bl 0x82df3428
	ctx.lr = 0x8266A044;
	sub_82DF3428(ctx, base);
	// 8266A044: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A04C: 388BAB28  addi r4, r11, -0x54d8
	ctx.r[4].s64 = ctx.r[11].s64 + -21720;
	// 8266A050: 487899B9  bl 0x82df3a08
	ctx.lr = 0x8266A054;
	sub_82DF3A08(ctx, base);
	// 8266A054: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266A058: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266A05C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8266A060: 4BF41D61  bl 0x825abdc0
	ctx.lr = 0x8266A064;
	sub_825ABDC0(ctx, base);
	// 8266A064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A068: 487893C1  bl 0x82df3428
	ctx.lr = 0x8266A06C;
	sub_82DF3428(ctx, base);
	// 8266A06C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A074: 388BAB1C  addi r4, r11, -0x54e4
	ctx.r[4].s64 = ctx.r[11].s64 + -21732;
	// 8266A078: 48789991  bl 0x82df3a08
	ctx.lr = 0x8266A07C;
	sub_82DF3A08(ctx, base);
	// 8266A07C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8266A080: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 8266A084: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266A088: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8266A08C: 419A0024  beq cr6, 0x8266a0b0
	if ctx.cr[6].eq {
	pc = 0x8266A0B0; continue 'dispatch;
	}
	// 8266A090: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8266A094: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8266A098: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A09C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8266A0A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8266A0A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8266A0A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A0AC: 4082FFE8  bne 0x8266a094
	if !ctx.cr[0].eq {
	pc = 0x8266A094; continue 'dispatch;
	}
	// 8266A0B0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8266A0B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266A0B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266A0BC: 4BF38055  bl 0x825a2110
	ctx.lr = 0x8266A0C0;
	sub_825A2110(ctx, base);
	// 8266A0C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A0C4: 48789365  bl 0x82df3428
	ctx.lr = 0x8266A0C8;
	sub_82DF3428(ctx, base);
	// 8266A0C8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A0CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A0D0: 388BAB00  addi r4, r11, -0x5500
	ctx.r[4].s64 = ctx.r[11].s64 + -21760;
	// 8266A0D4: 48789935  bl 0x82df3a08
	ctx.lr = 0x8266A0D8;
	sub_82DF3A08(ctx, base);
	// 8266A0D8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A0DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A0E0: 388BAAF4  addi r4, r11, -0x550c
	ctx.r[4].s64 = ctx.r[11].s64 + -21772;
	// 8266A0E4: 48789925  bl 0x82df3a08
	ctx.lr = 0x8266A0E8;
	sub_82DF3A08(ctx, base);
	// 8266A0E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A0EC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8266A0F0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8266A0F4: 38BE0048  addi r5, r30, 0x48
	ctx.r[5].s64 = ctx.r[30].s64 + 72;
	// 8266A0F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8266A0FC: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8266A100: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8266A104: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8266A108: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8266A10C: C04A95A0  lfs f2, -0x6a60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8266A110: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8266A114: 4BF39195  bl 0x825a32a8
	ctx.lr = 0x8266A118;
	sub_825A32A8(ctx, base);
	// 8266A118: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266A11C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266A120: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266A124: 4BF3764D  bl 0x825a1770
	ctx.lr = 0x8266A128;
	sub_825A1770(ctx, base);
	// 8266A128: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 8266A12C: 487892FD  bl 0x82df3428
	ctx.lr = 0x8266A130;
	sub_82DF3428(ctx, base);
	// 8266A130: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8266A134: 4BC5EB85  bl 0x822c8cb8
	ctx.lr = 0x8266A138;
	sub_822C8CB8(ctx, base);
	// 8266A138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A13C: 487892ED  bl 0x82df3428
	ctx.lr = 0x8266A140;
	sub_82DF3428(ctx, base);
	// 8266A140: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A144: 487892E5  bl 0x82df3428
	ctx.lr = 0x8266A148;
	sub_82DF3428(ctx, base);
	// 8266A148: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A150: 388BAADC  addi r4, r11, -0x5524
	ctx.r[4].s64 = ctx.r[11].s64 + -21796;
	// 8266A154: 487898B5  bl 0x82df3a08
	ctx.lr = 0x8266A158;
	sub_82DF3A08(ctx, base);
	// 8266A158: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A15C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A160: 388BEB64  addi r4, r11, -0x149c
	ctx.r[4].s64 = ctx.r[11].s64 + -5276;
	// 8266A164: 487898A5  bl 0x82df3a08
	ctx.lr = 0x8266A168;
	sub_82DF3A08(ctx, base);
	// 8266A168: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A16C: 38BE004C  addi r5, r30, 0x4c
	ctx.r[5].s64 = ctx.r[30].s64 + 76;
	// 8266A170: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8266A174: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266A178: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8266A17C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8266A180: C04B95F4  lfs f2, -0x6a0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27148 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8266A184: 4BF39125  bl 0x825a32a8
	ctx.lr = 0x8266A188;
	sub_825A32A8(ctx, base);
	// 8266A188: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266A18C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8266A190: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266A194: 4BF375DD  bl 0x825a1770
	ctx.lr = 0x8266A198;
	sub_825A1770(ctx, base);
	// 8266A198: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 8266A19C: 4878928D  bl 0x82df3428
	ctx.lr = 0x8266A1A0;
	sub_82DF3428(ctx, base);
	// 8266A1A0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8266A1A4: 4BC5EB15  bl 0x822c8cb8
	ctx.lr = 0x8266A1A8;
	sub_822C8CB8(ctx, base);
	// 8266A1A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A1AC: 4878927D  bl 0x82df3428
	ctx.lr = 0x8266A1B0;
	sub_82DF3428(ctx, base);
	// 8266A1B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A1B4: 48789275  bl 0x82df3428
	ctx.lr = 0x8266A1B8;
	sub_82DF3428(ctx, base);
	// 8266A1B8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8266A1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A1C0: 388B9214  addi r4, r11, -0x6dec
	ctx.r[4].s64 = ctx.r[11].s64 + -28140;
	// 8266A1C4: 48789845  bl 0x82df3a08
	ctx.lr = 0x8266A1C8;
	sub_82DF3A08(ctx, base);
	// 8266A1C8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A1CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A1D0: 388BAAC8  addi r4, r11, -0x5538
	ctx.r[4].s64 = ctx.r[11].s64 + -21816;
	// 8266A1D4: 48789835  bl 0x82df3a08
	ctx.lr = 0x8266A1D8;
	sub_82DF3A08(ctx, base);
	// 8266A1D8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8266A1DC: 38BE0050  addi r5, r30, 0x50
	ctx.r[5].s64 = ctx.r[30].s64 + 80;
	// 8266A1E0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8266A1E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266A1E8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8266A1EC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 8266A1F0: C04B6218  lfs f2, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8266A1F4: 4BF390B5  bl 0x825a32a8
	ctx.lr = 0x8266A1F8;
	sub_825A32A8(ctx, base);
	// 8266A1F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266A1FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8266A200: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266A204: 4BF3756D  bl 0x825a1770
	ctx.lr = 0x8266A208;
	sub_825A1770(ctx, base);
	// 8266A208: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 8266A20C: 4878921D  bl 0x82df3428
	ctx.lr = 0x8266A210;
	sub_82DF3428(ctx, base);
	// 8266A210: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 8266A214: 4BC5EAA5  bl 0x822c8cb8
	ctx.lr = 0x8266A218;
	sub_822C8CB8(ctx, base);
	// 8266A218: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A21C: 4878920D  bl 0x82df3428
	ctx.lr = 0x8266A220;
	sub_82DF3428(ctx, base);
	// 8266A220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A224: 48789205  bl 0x82df3428
	ctx.lr = 0x8266A228;
	sub_82DF3428(ctx, base);
	// 8266A228: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8266A22C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266A230: 4802A159  bl 0x82694388
	ctx.lr = 0x8266A234;
	sub_82694388(ctx, base);
	// 8266A234: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266A238: 419A000C  beq cr6, 0x8266a244
	if ctx.cr[6].eq {
	pc = 0x8266A244; continue 'dispatch;
	}
	// 8266A23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266A240: 4BC56651  bl 0x822c0890
	ctx.lr = 0x8266A244;
	sub_822C0890(ctx, base);
	// 8266A244: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 8266A248: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8266A24C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8266A250: 48B3DF68  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266A258 size=144
    let mut pc: u32 = 0x8266A258;
    'dispatch: loop {
        match pc {
            0x8266A258 => {
    //   block [0x8266A258..0x8266A2E8)
	// 8266A258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266A25C: 48B3DF09  bl 0x831a8164
	ctx.lr = 0x8266A260;
	sub_831A8130(ctx, base);
	// 8266A260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266A264: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A268: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8266A26C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266A270: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8266A274: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8266A278: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266A27C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8266A280: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8266A284: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 8266A288: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8266A28C: 4878815D  bl 0x82df23e8
	ctx.lr = 0x8266A290;
	sub_82DF23E8(ctx, base);
	// 8266A290: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A294: 41820020  beq 0x8266a2b4
	if ctx.cr[0].eq {
	pc = 0x8266A2B4; continue 'dispatch;
	}
	// 8266A298: C07C0000  lfs f3, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8266A29C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266A2A0: C05D0000  lfs f2, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8266A2A4: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266A2A8: 484E6D61  bl 0x82b51008
	ctx.lr = 0x8266A2AC;
	sub_82B51008(ctx, base);
	// 8266A2AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266A2B0: 48000008  b 0x8266a2b8
	pc = 0x8266A2B8; continue 'dispatch;
	// 8266A2B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266A2B8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8266A2BC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8266A2C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A2C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266A2C8: 4BFFFBD9  bl 0x82669ea0
	ctx.lr = 0x8266A2CC;
	sub_82669EA0(ctx, base);
	// 8266A2CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266A2D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A2D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266A2D8: 4BC55D29  bl 0x822c0000
	ctx.lr = 0x8266A2DC;
	sub_822C0000(ctx, base);
	// 8266A2DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8266A2E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8266A2E4: 48B3DED0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266A2E8 size=212
    let mut pc: u32 = 0x8266A2E8;
    'dispatch: loop {
        match pc {
            0x8266A2E8 => {
    //   block [0x8266A2E8..0x8266A3BC)
	// 8266A2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266A2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266A2F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266A2F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266A2F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266A2FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266A300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8266A304: 38FF0138  addi r7, r31, 0x138
	ctx.r[7].s64 = ctx.r[31].s64 + 312;
	// 8266A308: 38DF0134  addi r6, r31, 0x134
	ctx.r[6].s64 = ctx.r[31].s64 + 308;
	// 8266A30C: 38BF0130  addi r5, r31, 0x130
	ctx.r[5].s64 = ctx.r[31].s64 + 304;
	// 8266A310: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 8266A314: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8266A318: 4BFFFF41  bl 0x8266a258
	ctx.lr = 0x8266A31C;
	sub_8266A258(ctx, base);
	// 8266A31C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266A320: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8266A324: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266A328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266A32C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266A330: 419A0024  beq cr6, 0x8266a354
	if ctx.cr[6].eq {
	pc = 0x8266A354; continue 'dispatch;
	}
	// 8266A334: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8266A338: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8266A33C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A340: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8266A344: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8266A348: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8266A34C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A350: 4082FFE8  bne 0x8266a338
	if !ctx.cr[0].eq {
	pc = 0x8266A338; continue 'dispatch;
	}
	// 8266A354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266A358: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8266A35C: 4899DDCD  bl 0x83008128
	ctx.lr = 0x8266A360;
	sub_83008128(ctx, base);
	// 8266A360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266A364: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 8266A368: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8266A36C: 388AAB60  addi r4, r10, -0x54a0
	ctx.r[4].s64 = ctx.r[10].s64 + -21664;
	// 8266A370: 38A00085  li r5, 0x85
	ctx.r[5].s64 = 133;
	// 8266A374: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8266A378: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266A37C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8266A380: 487EE6C1  bl 0x82e58a40
	ctx.lr = 0x8266A384;
	sub_82E58A40(ctx, base);
	// 8266A384: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8266A388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266A38C: 419A0008  beq cr6, 0x8266a394
	if ctx.cr[6].eq {
	pc = 0x8266A394; continue 'dispatch;
	}
	// 8266A390: 4BC56501  bl 0x822c0890
	ctx.lr = 0x8266A394;
	sub_822C0890(ctx, base);
	// 8266A394: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8266A398: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266A39C: 419A0008  beq cr6, 0x8266a3a4
	if ctx.cr[6].eq {
	pc = 0x8266A3A4; continue 'dispatch;
	}
	// 8266A3A0: 4BC564F1  bl 0x822c0890
	ctx.lr = 0x8266A3A4;
	sub_822C0890(ctx, base);
	// 8266A3A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8266A3A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266A3AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266A3B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266A3B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266A3B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266A3C0 size=212
    let mut pc: u32 = 0x8266A3C0;
    'dispatch: loop {
        match pc {
            0x8266A3C0 => {
    //   block [0x8266A3C0..0x8266A494)
	// 8266A3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266A3C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266A3C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266A3CC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266A3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266A3D4: 48029EED  bl 0x826942c0
	ctx.lr = 0x8266A3D8;
	sub_826942C0(ctx, base);
	// 8266A3D8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A3DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266A3E0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8266A3E4: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8266A3E8: 3CE08205  lis r7, -0x7dfb
	ctx.r[7].s64 = -2113601536;
	// 8266A3EC: 3CC08205  lis r6, -0x7dfb
	ctx.r[6].s64 = -2113601536;
	// 8266A3F0: C00B0A9C  lfs f0, 0xa9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2716 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A3F4: C1AA093C  lfs f13, 0x93c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2364 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266A3F8: 3968AC4C  addi r11, r8, -0x53b4
	ctx.r[11].s64 = ctx.r[8].s64 + -21428;
	// 8266A3FC: C189964C  lfs f12, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8266A400: 3947AC38  addi r10, r7, -0x53c8
	ctx.r[10].s64 = ctx.r[7].s64 + -21448;
	// 8266A404: 3926ABEC  addi r9, r6, -0x5414
	ctx.r[9].s64 = ctx.r[6].s64 + -21524;
	// 8266A408: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266A40C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8266A410: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 8266A414: D1BF0134  stfs f13, 0x134(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 8266A418: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8266A41C: D19F0138  stfs f12, 0x138(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 8266A420: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 8266A424: 911F012C  stw r8, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[8].u32 ) };
	// 8266A428: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8266A42C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266A430: 388B9FBC  addi r4, r11, -0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + -24644;
	// 8266A434: 4802998D  bl 0x82693dc0
	ctx.lr = 0x8266A438;
	sub_82693DC0(ctx, base);
	// 8266A438: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8266A43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266A440: C02B6150  lfs f1, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266A444: 48029A35  bl 0x82693e78
	ctx.lr = 0x8266A448;
	sub_82693E78(ctx, base);
	// 8266A448: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A44C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A450: 388BABB8  addi r4, r11, -0x5448
	ctx.r[4].s64 = ctx.r[11].s64 + -21576;
	// 8266A454: 4BC5EE9D  bl 0x822c92f0
	ctx.lr = 0x8266A458;
	sub_822C92F0(ctx, base);
	// 8266A458: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 8266A45C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8266A460: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8266A464: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266A468: 4BC5ECC9  bl 0x822c9130
	ctx.lr = 0x8266A46C;
	sub_822C9130(ctx, base);
	// 8266A46C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8266A470: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266A474: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266A478: 4BC5E9B9  bl 0x822c8e30
	ctx.lr = 0x8266A47C;
	sub_822C8E30(ctx, base);
	// 8266A47C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266A480: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8266A484: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266A488: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266A48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266A490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266A498 size=400
    let mut pc: u32 = 0x8266A498;
    'dispatch: loop {
        match pc {
            0x8266A498 => {
    //   block [0x8266A498..0x8266A628)
	// 8266A498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266A49C: 48B3DCCD  bl 0x831a8168
	ctx.lr = 0x8266A4A0;
	sub_831A8130(ctx, base);
	// 8266A4A0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266A4A4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A4A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8266A4AC: 3BCBAB60  addi r30, r11, -0x54a0
	ctx.r[30].s64 = ctx.r[11].s64 + -21664;
	// 8266A4B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266A4B4: 38A0002B  li r5, 0x2b
	ctx.r[5].s64 = 43;
	// 8266A4B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266A4BC: 3860013C  li r3, 0x13c
	ctx.r[3].s64 = 316;
	// 8266A4C0: 48787F29  bl 0x82df23e8
	ctx.lr = 0x8266A4C4;
	sub_82DF23E8(ctx, base);
	// 8266A4C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A4C8: 41820010  beq 0x8266a4d8
	if ctx.cr[0].eq {
	pc = 0x8266A4D8; continue 'dispatch;
	}
	// 8266A4CC: 4BFFFEF5  bl 0x8266a3c0
	ctx.lr = 0x8266A4D0;
	sub_8266A3C0(ctx, base);
	// 8266A4D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266A4D4: 48000008  b 0x8266a4dc
	pc = 0x8266A4DC; continue 'dispatch;
	// 8266A4D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266A4DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8266A4E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A4E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266A4E8: 4BFFF8F1  bl 0x82669dd8
	ctx.lr = 0x8266A4EC;
	sub_82669DD8(ctx, base);
	// 8266A4EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266A4F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A4F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8266A4F8: 4BC55B09  bl 0x822c0000
	ctx.lr = 0x8266A4FC;
	sub_822C0000(ctx, base);
	// 8266A4FC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8266A500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8266A504: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 8266A508: 409A0008  bne cr6, 0x8266a510
	if !ctx.cr[6].eq {
	pc = 0x8266A510; continue 'dispatch;
	}
	// 8266A50C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266A510: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8266A514: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8266A518: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8266A51C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8266A520: 419A0024  beq cr6, 0x8266a544
	if ctx.cr[6].eq {
	pc = 0x8266A544; continue 'dispatch;
	}
	// 8266A524: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8266A528: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8266A52C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A530: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8266A534: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8266A538: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8266A53C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A540: 4082FFE8  bne 0x8266a528
	if !ctx.cr[0].eq {
	pc = 0x8266A528; continue 'dispatch;
	}
	// 8266A544: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8266A548: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8266A54C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8266A550: 419A0024  beq cr6, 0x8266a574
	if ctx.cr[6].eq {
	pc = 0x8266A574; continue 'dispatch;
	}
	// 8266A554: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8266A558: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8266A55C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A560: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8266A564: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8266A568: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8266A56C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8266A570: 4082FFE8  bne 0x8266a558
	if !ctx.cr[0].eq {
	pc = 0x8266A558; continue 'dispatch;
	}
	// 8266A574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266A578: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8266A57C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8266A580: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 8266A584: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8266A588: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8266A58C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266A590: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266A594: 4812E99D  bl 0x82798f30
	ctx.lr = 0x8266A598;
	sub_82798F30(ctx, base);
	// 8266A598: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266A59C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8266A5A0: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 8266A5A4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8266A5A8: 4BC55E31  bl 0x822c03d8
	ctx.lr = 0x8266A5AC;
	sub_822C03D8(ctx, base);
	// 8266A5AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A5B0: 41820014  beq 0x8266a5c4
	if ctx.cr[0].eq {
	pc = 0x8266A5C4; continue 'dispatch;
	}
	// 8266A5B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266A5B8: 481310B1  bl 0x8279b668
	ctx.lr = 0x8266A5BC;
	sub_8279B668(ctx, base);
	// 8266A5BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266A5C0: 48000008  b 0x8266a5c8
	pc = 0x8266A5C8; continue 'dispatch;
	// 8266A5C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266A5C8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8266A5CC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 8266A5D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A5D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266A5D8: 4BF2D679  bl 0x82597c50
	ctx.lr = 0x8266A5DC;
	sub_82597C50(ctx, base);
	// 8266A5DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266A5E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266A5E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266A5E8: 4BC55A19  bl 0x822c0000
	ctx.lr = 0x8266A5EC;
	sub_822C0000(ctx, base);
	// 8266A5EC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8266A5F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266A5F4: 419A0008  beq cr6, 0x8266a5fc
	if ctx.cr[6].eq {
	pc = 0x8266A5FC; continue 'dispatch;
	}
	// 8266A5F8: 4BC56299  bl 0x822c0890
	ctx.lr = 0x8266A5FC;
	sub_822C0890(ctx, base);
	// 8266A5FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8266A600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8266A604: 419A0008  beq cr6, 0x8266a60c
	if ctx.cr[6].eq {
	pc = 0x8266A60C; continue 'dispatch;
	}
	// 8266A608: 4BC56289  bl 0x822c0890
	ctx.lr = 0x8266A60C;
	sub_822C0890(ctx, base);
	// 8266A60C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8266A610: 419A000C  beq cr6, 0x8266a61c
	if ctx.cr[6].eq {
	pc = 0x8266A61C; continue 'dispatch;
	}
	// 8266A614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8266A618: 4BC56279  bl 0x822c0890
	ctx.lr = 0x8266A61C;
	sub_822C0890(ctx, base);
	// 8266A61C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8266A620: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8266A624: 48B3DB94  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A628 size=12
    let mut pc: u32 = 0x8266A628;
    'dispatch: loop {
        match pc {
            0x8266A628 => {
    //   block [0x8266A628..0x8266A634)
	// 8266A628: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8266A62C: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 8266A630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A638 size=12
    let mut pc: u32 = 0x8266A638;
    'dispatch: loop {
        match pc {
            0x8266A638 => {
    //   block [0x8266A638..0x8266A644)
	// 8266A638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266A63C: 99630030  stb r11, 0x30(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 8266A640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A648 size=8
    let mut pc: u32 = 0x8266A648;
    'dispatch: loop {
        match pc {
            0x8266A648 => {
    //   block [0x8266A648..0x8266A650)
	// 8266A648: 88630050  lbz r3, 0x50(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) } as u64;
	// 8266A64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A650 size=8
    let mut pc: u32 = 0x8266A650;
    'dispatch: loop {
        match pc {
            0x8266A650 => {
    //   block [0x8266A650..0x8266A658)
	// 8266A650: 98830050  stb r4, 0x50(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[4].u8 ) };
	// 8266A654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A658 size=8
    let mut pc: u32 = 0x8266A658;
    'dispatch: loop {
        match pc {
            0x8266A658 => {
    //   block [0x8266A658..0x8266A660)
	// 8266A658: D0230054  stfs f1, 0x54(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8266A65C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A660 size=20
    let mut pc: u32 = 0x8266A660;
    'dispatch: loop {
        match pc {
            0x8266A660 => {
    //   block [0x8266A660..0x8266A674)
	// 8266A660: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266A664: C0030054  lfs f0, 0x54(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A668: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266A66C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8266A670: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A674(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A674 size=12
    let mut pc: u32 = 0x8266A674;
    'dispatch: loop {
        match pc {
            0x8266A674 => {
    //   block [0x8266A674..0x8266A680)
	// 8266A674: EC000828  fsubs f0, f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 8266A678: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8266A67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A680 size=16
    let mut pc: u32 = 0x8266A680;
    'dispatch: loop {
        match pc {
            0x8266A680 => {
    //   block [0x8266A680..0x8266A690)
	// 8266A680: C0030058  lfs f0, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A684: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 8266A688: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8266A68C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A690 size=8
    let mut pc: u32 = 0x8266A690;
    'dispatch: loop {
        match pc {
            0x8266A690 => {
    //   block [0x8266A690..0x8266A698)
	// 8266A690: C0230058  lfs f1, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266A694: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A698 size=16
    let mut pc: u32 = 0x8266A698;
    'dispatch: loop {
        match pc {
            0x8266A698 => {
    //   block [0x8266A698..0x8266A6A8)
	// 8266A698: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266A69C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A6A0: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8266A6A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A6A8 size=36
    let mut pc: u32 = 0x8266A6A8;
    'dispatch: loop {
        match pc {
            0x8266A6A8 => {
    //   block [0x8266A6A8..0x8266A6CC)
	// 8266A6A8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A6AC: C1A30058  lfs f13, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266A6B0: C00BAC94  lfs f0, -0x536c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A6B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8266A6B8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8266A6BC: 41990008  bgt cr6, 0x8266a6c4
	if ctx.cr[6].gt {
	pc = 0x8266A6C4; continue 'dispatch;
	}
	// 8266A6C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266A6C4: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8266A6C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A6D0 size=8
    let mut pc: u32 = 0x8266A6D0;
    'dispatch: loop {
        match pc {
            0x8266A6D0 => {
    //   block [0x8266A6D0..0x8266A6D8)
	// 8266A6D0: 9883005C  stb r4, 0x5c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[4].u8 ) };
	// 8266A6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A6D8 size=8
    let mut pc: u32 = 0x8266A6D8;
    'dispatch: loop {
        match pc {
            0x8266A6D8 => {
    //   block [0x8266A6D8..0x8266A6E0)
	// 8266A6D8: 8863005C  lbz r3, 0x5c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 8266A6DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A6E0 size=8
    let mut pc: u32 = 0x8266A6E0;
    'dispatch: loop {
        match pc {
            0x8266A6E0 => {
    //   block [0x8266A6E0..0x8266A6E8)
	// 8266A6E0: 90830060  stw r4, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 8266A6E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A6E8 size=8
    let mut pc: u32 = 0x8266A6E8;
    'dispatch: loop {
        match pc {
            0x8266A6E8 => {
    //   block [0x8266A6E8..0x8266A6F0)
	// 8266A6E8: 80630060  lwz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 8266A6EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A6F0 size=108
    let mut pc: u32 = 0x8266A6F0;
    'dispatch: loop {
        match pc {
            0x8266A6F0 => {
    //   block [0x8266A6F0..0x8266A75C)
	// 8266A6F0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8266A6F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266A6F8: 392B6910  addi r9, r11, 0x6910
	ctx.r[9].s64 = ctx.r[11].s64 + 26896;
	// 8266A6FC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8266A700: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8266A704: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266A708: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A70C: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 8266A710: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266A714: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A760 size=48
    let mut pc: u32 = 0x8266A760;
    'dispatch: loop {
        match pc {
            0x8266A760 => {
    //   block [0x8266A760..0x8266A790)
	// 8266A760: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A764: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266A768: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8266A76C: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 8266A770: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8266A774: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A790 size=12
    let mut pc: u32 = 0x8266A790;
    'dispatch: loop {
        match pc {
            0x8266A790 => {
    //   block [0x8266A790..0x8266A79C)
	// 8266A790: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A7A0 size=16
    let mut pc: u32 = 0x8266A7A0;
    'dispatch: loop {
        match pc {
            0x8266A7A0 => {
    //   block [0x8266A7A0..0x8266A7B0)
	// 8266A7A0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 8266A7A4: 13E458C7  vcmpequd (lvx128) v31, v4, v11
	tmp.u32 = ctx.r[4].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A7B0 size=48
    let mut pc: u32 = 0x8266A7B0;
    'dispatch: loop {
        match pc {
            0x8266A7B0 => {
    //   block [0x8266A7B0..0x8266A7E0)
	// 8266A7B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266A7B4: C1A40054  lfs f13, 0x54(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266A7B8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A7BC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8266A7C0: 40990020  ble cr6, 0x8266a7e0
	if !ctx.cr[6].gt {
		sub_8266A7E0(ctx, base);
		return;
	}
	// 8266A7C4: 89640050  lbz r11, 0x50(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(80 as u32) ) } as u64;
	// 8266A7C8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A7CC: 40820014  bne 0x8266a7e0
	if !ctx.cr[0].eq {
		sub_8266A7E0(ctx, base);
		return;
	}
	// 8266A7D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8266A7D4: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8266A7D8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266A7DC: 4800001C  b 0x8266a7f8
	sub_8266A7E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A7E0 size=32
    let mut pc: u32 = 0x8266A7E0;
    'dispatch: loop {
        match pc {
            0x8266A7E0 => {
    //   block [0x8266A7E0..0x8266A800)
	// 8266A7E0: 89640030  lbz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 8266A7E4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A7E8: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 8266A7EC: 40820008  bne 0x8266a7f4
	if !ctx.cr[0].eq {
	pc = 0x8266A7F4; continue 'dispatch;
	}
	// 8266A7F0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8266A7F4: 13E458C7  vcmpequd (lvx128) v31, v4, v11
	tmp.u32 = ctx.r[4].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A800 size=20
    let mut pc: u32 = 0x8266A800;
    'dispatch: loop {
        match pc {
            0x8266A800 => {
    //   block [0x8266A800..0x8266A814)
	// 8266A800: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266A804: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A818 size=40
    let mut pc: u32 = 0x8266A818;
    'dispatch: loop {
        match pc {
            0x8266A818 => {
    //   block [0x8266A818..0x8266A840)
	// 8266A818: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266A81C: C1A30058  lfs f13, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266A820: D021001C  stfs f1, 0x1c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8266A824: C00BAC94  lfs f0, -0x536c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8266A82C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8266A830: 41990008  bgt cr6, 0x8266a838
	if ctx.cr[6].gt {
	pc = 0x8266A838; continue 'dispatch;
	}
	// 8266A834: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266A838: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266A83C: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266A840 size=12
    let mut pc: u32 = 0x8266A840;
    'dispatch: loop {
        match pc {
            0x8266A840 => {
    //   block [0x8266A840..0x8266A84C)
	// 8266A840: 8963005C  lbz r11, 0x5c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 8266A844: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A848: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A84C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266A84C size=132
    let mut pc: u32 = 0x8266A84C;
    'dispatch: loop {
        match pc {
            0x8266A84C => {
    //   block [0x8266A84C..0x8266A8D0)
	// 8266A84C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266A850: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A854: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 8266A858: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8266A85C: 3D208329  lis r9, -0x7cd7
	ctx.r[9].s64 = -2094465024;
	// 8266A860: C1830018  lfs f12, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8266A864: 3901FFF0  addi r8, r1, -0x10
	ctx.r[8].s64 = ctx.r[1].s64 + -16;
	// 8266A868: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266A86C: 39296D20  addi r9, r9, 0x6d20
	ctx.r[9].s64 = ctx.r[9].s64 + 27936;
	// 8266A870: C163001C  lfs f11, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8266A874: C00BA1C4  lfs f0, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8266A878: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8266A87C: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8266A880: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8266A884: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266A888: FD805850  fneg f12, f11
	ctx.f[12].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 8266A88C: D141FFF0  stfs f10, -0x10(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8266A890: 3961001C  addi r11, r1, 0x1c
	ctx.r[11].s64 = ctx.r[1].s64 + 28;
	// 8266A894: 13C04C07  vcmpneb. (lvlx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266A8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266A8D0 size=496
    let mut pc: u32 = 0x8266A8D0;
    'dispatch: loop {
        match pc {
            0x8266A8D0 => {
    //   block [0x8266A8D0..0x8266AAC0)
	// 8266A8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266A8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266A8D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266A8DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266A8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266A8E4: 897F0050  lbz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 8266A8E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A8EC: 418201C0  beq 0x8266aaac
	if ctx.cr[0].eq {
	pc = 0x8266AAAC; continue 'dispatch;
	}
	// 8266A8F0: 897F005C  lbz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 8266A8F4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266A8F8: 408201B4  bne 0x8266aaac
	if !ctx.cr[0].eq {
	pc = 0x8266AAAC; continue 'dispatch;
	}
	// 8266A8FC: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AAC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266AAC0 size=208
    let mut pc: u32 = 0x8266AAC0;
    'dispatch: loop {
        match pc {
            0x8266AAC0 => {
    //   block [0x8266AAC0..0x8266AB90)
	// 8266AAC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266AAC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266AAC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AACC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266AAD0: D02100AC  stfs f1, 0xac(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8266AAD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266AAD8: 396BACA0  addi r11, r11, -0x5360
	ctx.r[11].s64 = ctx.r[11].s64 + -21344;
	// 8266AADC: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 8266AAE0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8266AAE4: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8266AAE8: 3929A2F0  addi r9, r9, -0x5d10
	ctx.r[9].s64 = ctx.r[9].s64 + -23824;
	// 8266AAEC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266AAF0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266AB90 size=36
    let mut pc: u32 = 0x8266AB90;
    'dispatch: loop {
        match pc {
            0x8266AB90 => {
    //   block [0x8266AB90..0x8266ABB4)
	// 8266AB90: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8266AB94: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266AB98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8266AB9C: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266ABA0: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266ABB4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8266ABB4 size=56
    let mut pc: u32 = 0x8266ABB4;
    'dispatch: loop {
        match pc {
            0x8266ABB4 => {
    //   block [0x8266ABB4..0x8266ABEC)
	// 8266ABB4: C1A1FFF4  lfs f13, -0xc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8266ABB8: 3961FFE0  addi r11, r1, -0x20
	ctx.r[11].s64 = ctx.r[1].s64 + -32;
	// 8266ABBC: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 8266ABC0: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8266ABC4: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8266ABC8: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8266ABCC: D1A1FFE4  stfs f13, -0x1c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 8266ABD0: D001FFE8  stfs f0, -0x18(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 8266ABD4: D001FFEC  stfs f0, -0x14(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 8266ABD8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8266ABDC: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266ABF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266ABF0 size=92
    let mut pc: u32 = 0x8266ABF0;
    'dispatch: loop {
        match pc {
            0x8266ABF0 => {
    //   block [0x8266ABF0..0x8266AC4C)
	// 8266ABF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266ABF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266ABF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266ABFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266AC00: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8266AC04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AC08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266AC0C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8266AC10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8266AC14: 487EEA6D  bl 0x82e59680
	ctx.lr = 0x8266AC18;
	sub_82E59680(ctx, base);
	// 8266AC18: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266AC1C: D3FF001C  stfs f31, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8266AC20: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 8266AC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266AC28: 396BACDC  addi r11, r11, -0x5324
	ctx.r[11].s64 = ctx.r[11].s64 + -21284;
	// 8266AC2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266AC30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266AC34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266AC38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266AC3C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8266AC40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266AC44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266AC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266AC50 size=128
    let mut pc: u32 = 0x8266AC50;
    'dispatch: loop {
        match pc {
            0x8266AC50 => {
    //   block [0x8266AC50..0x8266ACD0)
	// 8266AC50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266AC54: 48B3D519  bl 0x831a816c
	ctx.lr = 0x8266AC58;
	sub_831A8130(ctx, base);
	// 8266AC58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AC5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266AC60: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8266AC64: 4802A0D5  bl 0x82694d38
	ctx.lr = 0x8266AC68;
	sub_82694D38(ctx, base);
	// 8266AC68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266AC6C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 8266AC70: 409A0008  bne cr6, 0x8266ac78
	if !ctx.cr[6].eq {
	pc = 0x8266AC78; continue 'dispatch;
	}
	// 8266AC74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8266AC78: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8266AC7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AC80: 808BD05C  lwz r4, -0x2fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12196 as u32) ) } as u64;
	// 8266AC84: 48788D85  bl 0x82df3a08
	ctx.lr = 0x8266AC88;
	sub_82DF3A08(ctx, base);
	// 8266AC88: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8266AC8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266AC90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266AC94: 4BE9DB5D  bl 0x825087f0
	ctx.lr = 0x8266AC98;
	sub_825087F0(ctx, base);
	// 8266AC98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AC9C: 4878878D  bl 0x82df3428
	ctx.lr = 0x8266ACA0;
	sub_82DF3428(ctx, base);
	// 8266ACA0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8266ACA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266ACA8: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 8266ACAC: 48788D5D  bl 0x82df3a08
	ctx.lr = 0x8266ACB0;
	sub_82DF3A08(ctx, base);
	// 8266ACB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8266ACB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266ACB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266ACBC: 4BE9DAC5  bl 0x82508780
	ctx.lr = 0x8266ACC0;
	sub_82508780(ctx, base);
	// 8266ACC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266ACC4: 48788765  bl 0x82df3428
	ctx.lr = 0x8266ACC8;
	sub_82DF3428(ctx, base);
	// 8266ACC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8266ACCC: 48B3D4F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266ACD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266ACD0 size=12
    let mut pc: u32 = 0x8266ACD0;
    'dispatch: loop {
        match pc {
            0x8266ACD0 => {
    //   block [0x8266ACD0..0x8266ACDC)
	// 8266ACD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8266ACD4: 99630044  stb r11, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 8266ACD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266ACE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266ACE0 size=12
    let mut pc: u32 = 0x8266ACE0;
    'dispatch: loop {
        match pc {
            0x8266ACE0 => {
    //   block [0x8266ACE0..0x8266ACEC)
	// 8266ACE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266ACE4: 99630044  stb r11, 0x44(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 8266ACE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266ACF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266ACF0 size=12
    let mut pc: u32 = 0x8266ACF0;
    'dispatch: loop {
        match pc {
            0x8266ACF0 => {
    //   block [0x8266ACF0..0x8266ACFC)
	// 8266ACF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266ACF4: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 8266ACF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266AD00 size=136
    let mut pc: u32 = 0x8266AD00;
    'dispatch: loop {
        match pc {
            0x8266AD00 => {
    //   block [0x8266AD00..0x8266AD88)
	// 8266AD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266AD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266AD08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266AD0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266AD10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AD14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266AD18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266AD1C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8266AD20: 409A0020  bne cr6, 0x8266ad40
	if !ctx.cr[6].eq {
	pc = 0x8266AD40; continue 'dispatch;
	}
	// 8266AD24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266AD28: 419A0048  beq cr6, 0x8266ad70
	if ctx.cr[6].eq {
	pc = 0x8266AD70; continue 'dispatch;
	}
	// 8266AD2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266AD30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266AD34: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266AD38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 8266AD3C: 48000034  b 0x8266ad70
	pc = 0x8266AD70; continue 'dispatch;
	// 8266AD40: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 8266AD44: 419A002C  beq cr6, 0x8266ad70
	if ctx.cr[6].eq {
	pc = 0x8266AD70; continue 'dispatch;
	}
	// 8266AD48: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266AD4C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266AD50: 388B7298  addi r4, r11, 0x7298
	ctx.r[4].s64 = ctx.r[11].s64 + 29336;
	// 8266AD54: 48B3D3A5  bl 0x831a80f8
	ctx.lr = 0x8266AD58;
	sub_831A80F8(ctx, base);
	// 8266AD58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8266AD5C: 4182000C  beq 0x8266ad68
	if ctx.cr[0].eq {
	pc = 0x8266AD68; continue 'dispatch;
	}
	// 8266AD60: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8266AD64: 4800000C  b 0x8266ad70
	pc = 0x8266AD70; continue 'dispatch;
	// 8266AD68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266AD6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266AD70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266AD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266AD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266AD7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266AD80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266AD84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266AD88 size=324
    let mut pc: u32 = 0x8266AD88;
    'dispatch: loop {
        match pc {
            0x8266AD88 => {
    //   block [0x8266AD88..0x8266AECC)
	// 8266AD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266AD8C: 48B3D3D5  bl 0x831a8160
	ctx.lr = 0x8266AD90;
	sub_831A8130(ctx, base);
	// 8266AD90: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AD94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8266AD98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266AD9C: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	// 8266ADA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266ADA4: 4878840D  bl 0x82df31b0
	ctx.lr = 0x8266ADA8;
	sub_82DF31B0(ctx, base);
	// 8266ADA8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266ADAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266ADB0: 3B8BADBC  addi r28, r11, -0x5244
	ctx.r[28].s64 = ctx.r[11].s64 + -21060;
	// 8266ADB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266ADB8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266ADBC: 4856231D  bl 0x82bcd0d8
	ctx.lr = 0x8266ADC0;
	sub_82BCD0D8(ctx, base);
	// 8266ADC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266ADC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266ADC8: 48788C41  bl 0x82df3a08
	ctx.lr = 0x8266ADCC;
	sub_82DF3A08(ctx, base);
	// 8266ADCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266ADD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8266ADD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266ADD8: 4BF367B1  bl 0x825a1588
	ctx.lr = 0x8266ADDC;
	sub_825A1588(ctx, base);
	// 8266ADDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266ADE0: 48788649  bl 0x82df3428
	ctx.lr = 0x8266ADE4;
	sub_82DF3428(ctx, base);
	// 8266ADE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266ADE8: 487883C9  bl 0x82df31b0
	ctx.lr = 0x8266ADEC;
	sub_82DF31B0(ctx, base);
	// 8266ADEC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266ADF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266ADF4: 3B4BADB0  addi r26, r11, -0x5250
	ctx.r[26].s64 = ctx.r[11].s64 + -21072;
	// 8266ADF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266ADFC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8266AE00: 485622D9  bl 0x82bcd0d8
	ctx.lr = 0x8266AE04;
	sub_82BCD0D8(ctx, base);
	// 8266AE04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266AE08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AE0C: 48788BFD  bl 0x82df3a08
	ctx.lr = 0x8266AE10;
	sub_82DF3A08(ctx, base);
	// 8266AE10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8266AE14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266AE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266AE1C: 4BF3676D  bl 0x825a1588
	ctx.lr = 0x8266AE20;
	sub_825A1588(ctx, base);
	// 8266AE20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AE24: 48788605  bl 0x82df3428
	ctx.lr = 0x8266AE28;
	sub_82DF3428(ctx, base);
	// 8266AE28: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 8266AE2C: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 8266AE30: 817B853C  lwz r11, -0x7ac4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 8266AE34: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8266AE38: 419A0044  beq cr6, 0x8266ae7c
	if ctx.cr[6].eq {
	pc = 0x8266AE7C; continue 'dispatch;
	}
	// 8266AE3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266AE40: 48788371  bl 0x82df31b0
	ctx.lr = 0x8266AE44;
	sub_82DF31B0(ctx, base);
	// 8266AE44: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266AE48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8266AE4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266AE50: 48562289  bl 0x82bcd0d8
	ctx.lr = 0x8266AE54;
	sub_82BCD0D8(ctx, base);
	// 8266AE54: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266AE58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AE5C: 48788BAD  bl 0x82df3a08
	ctx.lr = 0x8266AE60;
	sub_82DF3A08(ctx, base);
	// 8266AE60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8266AE64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266AE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266AE6C: 4BF3671D  bl 0x825a1588
	ctx.lr = 0x8266AE70;
	sub_825A1588(ctx, base);
	// 8266AE70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AE74: 487885B5  bl 0x82df3428
	ctx.lr = 0x8266AE78;
	sub_82DF3428(ctx, base);
	// 8266AE78: 817B853C  lwz r11, -0x7ac4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 8266AE7C: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8266AE80: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8266AE84: 419A0040  beq cr6, 0x8266aec4
	if ctx.cr[6].eq {
	pc = 0x8266AEC4; continue 'dispatch;
	}
	// 8266AE88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266AE8C: 48788325  bl 0x82df31b0
	ctx.lr = 0x8266AE90;
	sub_82DF31B0(ctx, base);
	// 8266AE90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8266AE94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8266AE98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266AE9C: 4856223D  bl 0x82bcd0d8
	ctx.lr = 0x8266AEA0;
	sub_82BCD0D8(ctx, base);
	// 8266AEA0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8266AEA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AEA8: 48788B61  bl 0x82df3a08
	ctx.lr = 0x8266AEAC;
	sub_82DF3A08(ctx, base);
	// 8266AEAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8266AEB0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8266AEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266AEB8: 4BF366D1  bl 0x825a1588
	ctx.lr = 0x8266AEBC;
	sub_825A1588(ctx, base);
	// 8266AEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266AEC0: 48788569  bl 0x82df3428
	ctx.lr = 0x8266AEC4;
	sub_82DF3428(ctx, base);
	// 8266AEC4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8266AEC8: 48B3D2E8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266AED0 size=116
    let mut pc: u32 = 0x8266AED0;
    'dispatch: loop {
        match pc {
            0x8266AED0 => {
    //   block [0x8266AED0..0x8266AF44)
	// 8266AED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266AED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266AED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266AEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266AEE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AEE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266AEE8: 80640010  lwz r3, 0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 8266AEEC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8266AEF0: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 8266AEF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266AEF8: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266AF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266AF48 size=264
    let mut pc: u32 = 0x8266AF48;
    'dispatch: loop {
        match pc {
            0x8266AF48 => {
    //   block [0x8266AF48..0x8266B050)
	// 8266AF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266AF4C: 48B3D221  bl 0x831a816c
	ctx.lr = 0x8266AF50;
	sub_831A8130(ctx, base);
	// 8266AF50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266AF54: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 8266AF58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266AF5C: 409A00A0  bne cr6, 0x8266affc
	if !ctx.cr[6].eq {
	pc = 0x8266AFFC; continue 'dispatch;
	}
	// 8266AF60: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266AF64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266AF68: 419A0010  beq cr6, 0x8266af78
	if ctx.cr[6].eq {
	pc = 0x8266AF78; continue 'dispatch;
	}
	// 8266AF6C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266AF70: 816B6D3C  lwz r11, 0x6d3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27964 as u32) ) } as u64;
	// 8266AF74: 4800002C  b 0x8266afa0
	pc = 0x8266AFA0; continue 'dispatch;
	// 8266AF78: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8266AF7C: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8266AF80: 816B853C  lwz r11, -0x7ac4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 8266AF84: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8266AF88: 419A0010  beq cr6, 0x8266af98
	if ctx.cr[6].eq {
	pc = 0x8266AF98; continue 'dispatch;
	}
	// 8266AF8C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266AF90: 816B6D38  lwz r11, 0x6d38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27960 as u32) ) } as u64;
	// 8266AF94: 4800000C  b 0x8266afa0
	pc = 0x8266AFA0; continue 'dispatch;
	// 8266AF98: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266AF9C: 816B6D34  lwz r11, 0x6d34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27956 as u32) ) } as u64;
	// 8266AFA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8266AFA4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266AFA8: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 8266AFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266AFB0: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 8266AFB4: 409A0008  bne cr6, 0x8266afbc
	if !ctx.cr[6].eq {
	pc = 0x8266AFBC; continue 'dispatch;
	}
	// 8266AFB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266AFBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266AFC0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8266AFC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8266AFC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266AFCC: 4E800421  bctrl
	ctx.lr = 0x8266AFD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266AFD0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8266AFD4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8266AFD8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8266AFDC: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 8266AFE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266AFE4: C06B08A8  lfs f3, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8266AFE8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 8266AFEC: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 8266AFF0: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 8266AFF4: 4BC5CB55  bl 0x822c7b48
	ctx.lr = 0x8266AFF8;
	sub_822C7B48(ctx, base);
	// 8266AFF8: 48000050  b 0x8266b048
	pc = 0x8266B048; continue 'dispatch;
	// 8266AFFC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B004: 3BEBFF34  addi r31, r11, -0xcc
	ctx.r[31].s64 = ctx.r[11].s64 + -204;
	// 8266B008: 409A0008  bne cr6, 0x8266b010
	if !ctx.cr[6].eq {
	pc = 0x8266B010; continue 'dispatch;
	}
	// 8266B00C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8266B010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266B014: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 8266B018: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 8266B01C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8266B020: 3BCBBA80  addi r30, r11, -0x4580
	ctx.r[30].s64 = ctx.r[11].s64 + -17792;
	// 8266B024: 3BAA6D40  addi r29, r10, 0x6d40
	ctx.r[29].s64 = ctx.r[10].s64 + 27968;
	// 8266B028: 4BFFFEA9  bl 0x8266aed0
	ctx.lr = 0x8266B02C;
	sub_8266AED0(ctx, base);
	// 8266B02C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8266B030: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8266B034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B038: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8266B03C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8266B040: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8266B044: 4BC5CA25  bl 0x822c7a68
	ctx.lr = 0x8266B048;
	sub_822C7A68(ctx, base);
	// 8266B048: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8266B04C: 48B3D170  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B050 size=104
    let mut pc: u32 = 0x8266B050;
    'dispatch: loop {
        match pc {
            0x8266B050 => {
    //   block [0x8266B050..0x8266B0B8)
	// 8266B050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B058: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B05C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B060: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266B068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8266B06C: 4BC54F95  bl 0x822c0000
	ctx.lr = 0x8266B070;
	sub_822C0000(ctx, base);
	// 8266B070: 807F0080  lwz r3, 0x80(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8266B074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266B078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B07C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266B080: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B084: 4E800421  bctrl
	ctx.lr = 0x8266B088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B088: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8266B08C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8266B090: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B094: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8266B098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B09C: 4E800421  bctrl
	ctx.lr = 0x8266B0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B0A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B0AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B0B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B0B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266B0B8 size=68
    let mut pc: u32 = 0x8266B0B8;
    'dispatch: loop {
        match pc {
            0x8266B0B8 => {
    //   block [0x8266B0B8..0x8266B0FC)
	// 8266B0B8: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 8266B0BC: 81030080  lwz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 8266B0C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8266B0C4: 8169853C  lwz r11, -0x7ac4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 8266B0C8: 91680030  stw r11, 0x30(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8266B0CC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8266B0D0: 91680020  stw r11, 0x20(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8266B0D4: 8169853C  lwz r11, -0x7ac4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 8266B0D8: 81030088  lwz r8, 0x88(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 8266B0DC: 91680030  stw r11, 0x30(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 8266B0E0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8266B0E4: 91680020  stw r11, 0x20(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 8266B0E8: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 8266B0EC: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8266B0F0: 81630088  lwz r11, 0x88(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) } as u64;
	// 8266B0F4: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8266B0F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266B100 size=36
    let mut pc: u32 = 0x8266B100;
    'dispatch: loop {
        match pc {
            0x8266B100 => {
    //   block [0x8266B100..0x8266B124)
	// 8266B100: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 8266B104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B108: 39630168  addi r11, r3, 0x168
	ctx.r[11].s64 = ctx.r[3].s64 + 360;
	// 8266B10C: 419A0008  beq cr6, 0x8266b114
	if ctx.cr[6].eq {
	pc = 0x8266B114; continue 'dispatch;
	}
	// 8266B110: 39630170  addi r11, r3, 0x170
	ctx.r[11].s64 = ctx.r[3].s64 + 368;
	// 8266B114: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B118: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8266B11C: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 8266B120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B128 size=156
    let mut pc: u32 = 0x8266B128;
    'dispatch: loop {
        match pc {
            0x8266B128 => {
    //   block [0x8266B128..0x8266B1C4)
	// 8266B128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B134: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B138: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8266B13C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266B140: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8266B144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B148: 397F0168  addi r11, r31, 0x168
	ctx.r[11].s64 = ctx.r[31].s64 + 360;
	// 8266B14C: 419A0008  beq cr6, 0x8266b154
	if ctx.cr[6].eq {
	pc = 0x8266B154; continue 'dispatch;
	}
	// 8266B150: 397F0170  addi r11, r31, 0x170
	ctx.r[11].s64 = ctx.r[31].s64 + 368;
	// 8266B154: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B158: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266B15C: 810A0024  lwz r8, 0x24(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 8266B160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B164: 91090030  stw r8, 0x30(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), ctx.r[8].u32 ) };
	// 8266B168: 91090020  stw r8, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 8266B16C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B170: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266B174: 91090034  stw r8, 0x34(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 8266B178: 91090024  stw r8, 0x24(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 8266B17C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B180: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 8266B184: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 8266B188: 4BEA43E1  bl 0x8250f568
	ctx.lr = 0x8266B18C;
	sub_8250F568(ctx, base);
	// 8266B18C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B194: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 8266B198: 409A0008  bne cr6, 0x8266b1a0
	if !ctx.cr[6].eq {
	pc = 0x8266B1A0; continue 'dispatch;
	}
	// 8266B19C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8266B1A0: 809F0138  lwz r4, 0x138(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8266B1A4: 48144485  bl 0x827af628
	ctx.lr = 0x8266B1A8;
	sub_827AF628(ctx, base);
	// 8266B1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B1AC: 48786AE5  bl 0x82df1c90
	ctx.lr = 0x8266B1B0;
	sub_82DF1C90(ctx, base);
	// 8266B1B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B1B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B1B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B1BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B1C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B1C8 size=144
    let mut pc: u32 = 0x8266B1C8;
    'dispatch: loop {
        match pc {
            0x8266B1C8 => {
    //   block [0x8266B1C8..0x8266B258)
	// 8266B1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B1CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B1D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B1D4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B1D8: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 8266B1DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8266B1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B1E4: 397F0168  addi r11, r31, 0x168
	ctx.r[11].s64 = ctx.r[31].s64 + 360;
	// 8266B1E8: 419A0008  beq cr6, 0x8266b1f0
	if ctx.cr[6].eq {
	pc = 0x8266B1F0; continue 'dispatch;
	}
	// 8266B1EC: 397F0170  addi r11, r31, 0x170
	ctx.r[11].s64 = ctx.r[31].s64 + 368;
	// 8266B1F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B1F4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 8266B1F8: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8266B1FC: 814A853C  lwz r10, -0x7ac4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 8266B200: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8266B204: 419A0040  beq cr6, 0x8266b244
	if ctx.cr[6].eq {
	pc = 0x8266B244; continue 'dispatch;
	}
	// 8266B208: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8266B20C: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8266B210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8266B214: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 8266B218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B21C: 4BEA434D  bl 0x8250f568
	ctx.lr = 0x8266B220;
	sub_8250F568(ctx, base);
	// 8266B220: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B228: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 8266B22C: 409A0008  bne cr6, 0x8266b234
	if !ctx.cr[6].eq {
	pc = 0x8266B234; continue 'dispatch;
	}
	// 8266B230: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8266B234: 809F0138  lwz r4, 0x138(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 8266B238: 481443F1  bl 0x827af628
	ctx.lr = 0x8266B23C;
	sub_827AF628(ctx, base);
	// 8266B23C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B240: 48786A51  bl 0x82df1c90
	ctx.lr = 0x8266B244;
	sub_82DF1C90(ctx, base);
	// 8266B244: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B24C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B250: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B254: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266B258 size=40
    let mut pc: u32 = 0x8266B258;
    'dispatch: loop {
        match pc {
            0x8266B258 => {
    //   block [0x8266B258..0x8266B280)
	// 8266B258: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266B25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B260: 39630168  addi r11, r3, 0x168
	ctx.r[11].s64 = ctx.r[3].s64 + 360;
	// 8266B264: 419A0008  beq cr6, 0x8266b26c
	if ctx.cr[6].eq {
	pc = 0x8266B26C; continue 'dispatch;
	}
	// 8266B268: 39630170  addi r11, r3, 0x170
	ctx.r[11].s64 = ctx.r[3].s64 + 368;
	// 8266B26C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B270: 8144001C  lwz r10, 0x1c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 8266B274: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8266B278: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B27C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8266B280 size=84
    let mut pc: u32 = 0x8266B280;
    'dispatch: loop {
        match pc {
            0x8266B280 => {
    //   block [0x8266B280..0x8266B2D4)
	// 8266B280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B28C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B294: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266B298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B29C: 39630168  addi r11, r3, 0x168
	ctx.r[11].s64 = ctx.r[3].s64 + 360;
	// 8266B2A0: 419A0008  beq cr6, 0x8266b2a8
	if ctx.cr[6].eq {
	pc = 0x8266B2A8; continue 'dispatch;
	}
	// 8266B2A4: 39630170  addi r11, r3, 0x170
	ctx.r[11].s64 = ctx.r[3].s64 + 368;
	// 8266B2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B2AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B2B0: 4BFFFC21  bl 0x8266aed0
	ctx.lr = 0x8266B2B4;
	sub_8266AED0(ctx, base);
	// 8266B2B4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8266B2B8: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266B2D8 size=36
    let mut pc: u32 = 0x8266B2D8;
    'dispatch: loop {
        match pc {
            0x8266B2D8 => {
    //   block [0x8266B2D8..0x8266B2FC)
	// 8266B2D8: 81430168  lwz r10, 0x168(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(360 as u32) ) } as u64;
	// 8266B2DC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8266B2E0: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266B2E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8266B2E8: 409A0014  bne cr6, 0x8266b2fc
	if !ctx.cr[6].eq {
		sub_8266B2FC(ctx, base);
		return;
	}
	// 8266B2EC: 81430170  lwz r10, 0x170(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) } as u64;
	// 8266B2F0: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266B2F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8266B2F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B2FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266B2FC size=28
    let mut pc: u32 = 0x8266B2FC;
    'dispatch: loop {
        match pc {
            0x8266B2FC => {
    //   block [0x8266B2FC..0x8266B318)
	// 8266B2FC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8266B300: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8266B304: 3D008205  lis r8, -0x7dfb
	ctx.r[8].s64 = -2113601536;
	// 8266B308: 3888ADC8  addi r4, r8, -0x5238
	ctx.r[4].s64 = ctx.r[8].s64 + -21048;
	// 8266B30C: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 8266B310: 806B001C  lwz r3, 0x1c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 8266B314: 48788564  b 0x82df3878
	sub_82DF3878(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8266B318 size=4
    let mut pc: u32 = 0x8266B318;
    'dispatch: loop {
        match pc {
            0x8266B318 => {
    //   block [0x8266B318..0x8266B31C)
	// 8266B318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B320 size=196
    let mut pc: u32 = 0x8266B320;
    'dispatch: loop {
        match pc {
            0x8266B320 => {
    //   block [0x8266B320..0x8266B3E4)
	// 8266B320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B32C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B33C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B340: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B344: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B348: 4BC555F1  bl 0x822c0938
	ctx.lr = 0x8266B34C;
	sub_822C0938(ctx, base);
	// 8266B34C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B350: 41820028  beq 0x8266b378
	if ctx.cr[0].eq {
	pc = 0x8266B378; continue 'dispatch;
	}
	// 8266B354: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B358: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B35C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B360: 392BACEC  addi r9, r11, -0x5314
	ctx.r[9].s64 = ctx.r[11].s64 + -21268;
	// 8266B364: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B36C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B370: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B374: 48000008  b 0x8266b37c
	pc = 0x8266B37C; continue 'dispatch;
	// 8266B378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B37C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B384: 409A0044  bne cr6, 0x8266b3c8
	if !ctx.cr[6].eq {
	pc = 0x8266B3C8; continue 'dispatch;
	}
	// 8266B388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B38C: 419A001C  beq cr6, 0x8266b3a8
	if ctx.cr[6].eq {
	pc = 0x8266B3A8; continue 'dispatch;
	}
	// 8266B390: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B394: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B39C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B3A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B3A4: 4E800421  bctrl
	ctx.lr = 0x8266B3A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B3A8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B3AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B3B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B3B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B3B8: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B3BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B3C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B3C4: 4BC54C3D  bl 0x822c0000
	ctx.lr = 0x8266B3C8;
	sub_822C0000(ctx, base);
	// 8266B3C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B3CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B3D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B3D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B3D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B3DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B3E8 size=196
    let mut pc: u32 = 0x8266B3E8;
    'dispatch: loop {
        match pc {
            0x8266B3E8 => {
    //   block [0x8266B3E8..0x8266B4AC)
	// 8266B3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B3FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B404: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B408: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B40C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B410: 4BC55529  bl 0x822c0938
	ctx.lr = 0x8266B414;
	sub_822C0938(ctx, base);
	// 8266B414: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B418: 41820028  beq 0x8266b440
	if ctx.cr[0].eq {
	pc = 0x8266B440; continue 'dispatch;
	}
	// 8266B41C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B420: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B424: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B428: 392BAD00  addi r9, r11, -0x5300
	ctx.r[9].s64 = ctx.r[11].s64 + -21248;
	// 8266B42C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B430: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B434: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B438: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B43C: 48000008  b 0x8266b444
	pc = 0x8266B444; continue 'dispatch;
	// 8266B440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B444: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B44C: 409A0044  bne cr6, 0x8266b490
	if !ctx.cr[6].eq {
	pc = 0x8266B490; continue 'dispatch;
	}
	// 8266B450: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B454: 419A001C  beq cr6, 0x8266b470
	if ctx.cr[6].eq {
	pc = 0x8266B470; continue 'dispatch;
	}
	// 8266B458: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B45C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B464: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B46C: 4E800421  bctrl
	ctx.lr = 0x8266B470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B470: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B474: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B47C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B480: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B484: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B488: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B48C: 4BC54B75  bl 0x822c0000
	ctx.lr = 0x8266B490;
	sub_822C0000(ctx, base);
	// 8266B490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B494: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B498: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B49C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B4A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B4A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B4A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B4B0 size=196
    let mut pc: u32 = 0x8266B4B0;
    'dispatch: loop {
        match pc {
            0x8266B4B0 => {
    //   block [0x8266B4B0..0x8266B574)
	// 8266B4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B4B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B4B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B4BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B4C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B4C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B4C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B4CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B4D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B4D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B4D8: 4BC55461  bl 0x822c0938
	ctx.lr = 0x8266B4DC;
	sub_822C0938(ctx, base);
	// 8266B4DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B4E0: 41820028  beq 0x8266b508
	if ctx.cr[0].eq {
	pc = 0x8266B508; continue 'dispatch;
	}
	// 8266B4E4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B4E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B4EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B4F0: 392BAD14  addi r9, r11, -0x52ec
	ctx.r[9].s64 = ctx.r[11].s64 + -21228;
	// 8266B4F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B4F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B4FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B500: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B504: 48000008  b 0x8266b50c
	pc = 0x8266B50C; continue 'dispatch;
	// 8266B508: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B50C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B514: 409A0044  bne cr6, 0x8266b558
	if !ctx.cr[6].eq {
	pc = 0x8266B558; continue 'dispatch;
	}
	// 8266B518: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B51C: 419A001C  beq cr6, 0x8266b538
	if ctx.cr[6].eq {
	pc = 0x8266B538; continue 'dispatch;
	}
	// 8266B520: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B524: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B52C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B530: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B534: 4E800421  bctrl
	ctx.lr = 0x8266B538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B538: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B53C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B544: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B548: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B54C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B550: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B554: 4BC54AAD  bl 0x822c0000
	ctx.lr = 0x8266B558;
	sub_822C0000(ctx, base);
	// 8266B558: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B55C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B56C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B578 size=196
    let mut pc: u32 = 0x8266B578;
    'dispatch: loop {
        match pc {
            0x8266B578 => {
    //   block [0x8266B578..0x8266B63C)
	// 8266B578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B58C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B590: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B594: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B598: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B59C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B5A0: 4BC55399  bl 0x822c0938
	ctx.lr = 0x8266B5A4;
	sub_822C0938(ctx, base);
	// 8266B5A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B5A8: 41820028  beq 0x8266b5d0
	if ctx.cr[0].eq {
	pc = 0x8266B5D0; continue 'dispatch;
	}
	// 8266B5AC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B5B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B5B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B5B8: 392BAD28  addi r9, r11, -0x52d8
	ctx.r[9].s64 = ctx.r[11].s64 + -21208;
	// 8266B5BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B5C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B5C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B5C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B5CC: 48000008  b 0x8266b5d4
	pc = 0x8266B5D4; continue 'dispatch;
	// 8266B5D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B5D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B5DC: 409A0044  bne cr6, 0x8266b620
	if !ctx.cr[6].eq {
	pc = 0x8266B620; continue 'dispatch;
	}
	// 8266B5E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B5E4: 419A001C  beq cr6, 0x8266b600
	if ctx.cr[6].eq {
	pc = 0x8266B600; continue 'dispatch;
	}
	// 8266B5E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B5EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B5F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B5F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B5F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B5FC: 4E800421  bctrl
	ctx.lr = 0x8266B600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B600: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B604: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B60C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B610: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B614: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B618: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B61C: 4BC549E5  bl 0x822c0000
	ctx.lr = 0x8266B620;
	sub_822C0000(ctx, base);
	// 8266B620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B624: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B628: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B62C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B630: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B640 size=196
    let mut pc: u32 = 0x8266B640;
    'dispatch: loop {
        match pc {
            0x8266B640 => {
    //   block [0x8266B640..0x8266B704)
	// 8266B640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B64C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B65C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B660: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B664: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B668: 4BC552D1  bl 0x822c0938
	ctx.lr = 0x8266B66C;
	sub_822C0938(ctx, base);
	// 8266B66C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B670: 41820028  beq 0x8266b698
	if ctx.cr[0].eq {
	pc = 0x8266B698; continue 'dispatch;
	}
	// 8266B674: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B678: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B67C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B680: 392BAD50  addi r9, r11, -0x52b0
	ctx.r[9].s64 = ctx.r[11].s64 + -21168;
	// 8266B684: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B688: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B68C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B690: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B694: 48000008  b 0x8266b69c
	pc = 0x8266B69C; continue 'dispatch;
	// 8266B698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B69C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B6A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B6A4: 409A0044  bne cr6, 0x8266b6e8
	if !ctx.cr[6].eq {
	pc = 0x8266B6E8; continue 'dispatch;
	}
	// 8266B6A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B6AC: 419A001C  beq cr6, 0x8266b6c8
	if ctx.cr[6].eq {
	pc = 0x8266B6C8; continue 'dispatch;
	}
	// 8266B6B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B6B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B6BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B6C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B6C4: 4E800421  bctrl
	ctx.lr = 0x8266B6C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B6C8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B6CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B6D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B6D8: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B6DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B6E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B6E4: 4BC5491D  bl 0x822c0000
	ctx.lr = 0x8266B6E8;
	sub_822C0000(ctx, base);
	// 8266B6E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B6EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B6F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B6FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B708 size=196
    let mut pc: u32 = 0x8266B708;
    'dispatch: loop {
        match pc {
            0x8266B708 => {
    //   block [0x8266B708..0x8266B7CC)
	// 8266B708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B710: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B714: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B718: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B71C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B720: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B724: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B728: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B72C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B730: 4BC55209  bl 0x822c0938
	ctx.lr = 0x8266B734;
	sub_822C0938(ctx, base);
	// 8266B734: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B738: 41820028  beq 0x8266b760
	if ctx.cr[0].eq {
	pc = 0x8266B760; continue 'dispatch;
	}
	// 8266B73C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B740: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B744: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B748: 392BAD64  addi r9, r11, -0x529c
	ctx.r[9].s64 = ctx.r[11].s64 + -21148;
	// 8266B74C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B754: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B758: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B75C: 48000008  b 0x8266b764
	pc = 0x8266B764; continue 'dispatch;
	// 8266B760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B764: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B76C: 409A0044  bne cr6, 0x8266b7b0
	if !ctx.cr[6].eq {
	pc = 0x8266B7B0; continue 'dispatch;
	}
	// 8266B770: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B774: 419A001C  beq cr6, 0x8266b790
	if ctx.cr[6].eq {
	pc = 0x8266B790; continue 'dispatch;
	}
	// 8266B778: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B77C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B784: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B788: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B78C: 4E800421  bctrl
	ctx.lr = 0x8266B790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B790: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B794: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B79C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B7A0: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B7A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B7A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B7AC: 4BC54855  bl 0x822c0000
	ctx.lr = 0x8266B7B0;
	sub_822C0000(ctx, base);
	// 8266B7B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B7B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B7B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B7BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B7C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B7C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B7C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B7D0 size=196
    let mut pc: u32 = 0x8266B7D0;
    'dispatch: loop {
        match pc {
            0x8266B7D0 => {
    //   block [0x8266B7D0..0x8266B894)
	// 8266B7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B7D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B7D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B7DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B7E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B7E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B7E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B7EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B7F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B7F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B7F8: 4BC55141  bl 0x822c0938
	ctx.lr = 0x8266B7FC;
	sub_822C0938(ctx, base);
	// 8266B7FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B800: 41820028  beq 0x8266b828
	if ctx.cr[0].eq {
	pc = 0x8266B828; continue 'dispatch;
	}
	// 8266B804: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B808: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B80C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B810: 392BAD78  addi r9, r11, -0x5288
	ctx.r[9].s64 = ctx.r[11].s64 + -21128;
	// 8266B814: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B81C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B820: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B824: 48000008  b 0x8266b82c
	pc = 0x8266B82C; continue 'dispatch;
	// 8266B828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B82C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B834: 409A0044  bne cr6, 0x8266b878
	if !ctx.cr[6].eq {
	pc = 0x8266B878; continue 'dispatch;
	}
	// 8266B838: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B83C: 419A001C  beq cr6, 0x8266b858
	if ctx.cr[6].eq {
	pc = 0x8266B858; continue 'dispatch;
	}
	// 8266B840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B844: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B84C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B850: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B854: 4E800421  bctrl
	ctx.lr = 0x8266B858;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B858: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B85C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B864: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B868: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B86C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B870: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B874: 4BC5478D  bl 0x822c0000
	ctx.lr = 0x8266B878;
	sub_822C0000(ctx, base);
	// 8266B878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B87C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B888: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B88C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8266B898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8266B898 size=196
    let mut pc: u32 = 0x8266B898;
    'dispatch: loop {
        match pc {
            0x8266B898 => {
    //   block [0x8266B898..0x8266B95C)
	// 8266B898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8266B89C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8266B8A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8266B8A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8266B8A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8266B8AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8266B8B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B8B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8266B8B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8266B8BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B8C0: 4BC55079  bl 0x822c0938
	ctx.lr = 0x8266B8C4;
	sub_822C0938(ctx, base);
	// 8266B8C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8266B8C8: 41820028  beq 0x8266b8f0
	if ctx.cr[0].eq {
	pc = 0x8266B8F0; continue 'dispatch;
	}
	// 8266B8CC: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 8266B8D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8266B8D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8266B8D8: 392BAD8C  addi r9, r11, -0x5274
	ctx.r[9].s64 = ctx.r[11].s64 + -21108;
	// 8266B8DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8266B8E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8266B8E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8266B8E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8266B8EC: 48000008  b 0x8266b8f4
	pc = 0x8266B8F4; continue 'dispatch;
	// 8266B8F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8266B8F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8266B8F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8266B8FC: 409A0044  bne cr6, 0x8266b940
	if !ctx.cr[6].eq {
	pc = 0x8266B940; continue 'dispatch;
	}
	// 8266B900: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8266B904: 419A001C  beq cr6, 0x8266b920
	if ctx.cr[6].eq {
	pc = 0x8266B920; continue 'dispatch;
	}
	// 8266B908: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B90C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8266B910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8266B914: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8266B918: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8266B91C: 4E800421  bctrl
	ctx.lr = 0x8266B920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8266B920: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8266B924: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8266B928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8266B92C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8266B930: 816B6D28  lwz r11, 0x6d28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27944 as u32) ) } as u64;
	// 8266B934: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8266B938: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8266B93C: 4BC546C5  bl 0x822c0000
	ctx.lr = 0x8266B940;
	sub_822C0000(ctx, base);
	// 8266B940: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8266B944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8266B948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8266B94C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8266B950: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8266B954: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8266B958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


