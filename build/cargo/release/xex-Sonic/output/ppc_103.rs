pub fn sub_828A3C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3C30 size=196
    let mut pc: u32 = 0x828A3C30;
    'dispatch: loop {
        match pc {
            0x828A3C30 => {
    //   block [0x828A3C30..0x828A3CF4)
	// 828A3C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3C38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3C3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3C40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3C4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3C50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3C54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3C58: 4BA1CCE1  bl 0x822c0938
	ctx.lr = 0x828A3C5C;
	sub_822C0938(ctx, base);
	// 828A3C5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3C60: 41820028  beq 0x828a3c88
	if ctx.cr[0].eq {
	pc = 0x828A3C88; continue 'dispatch;
	}
	// 828A3C64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3C68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3C6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3C70: 392B9B20  addi r9, r11, -0x64e0
	ctx.r[9].s64 = ctx.r[11].s64 + -25824;
	// 828A3C74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3C78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3C7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3C80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3C84: 48000008  b 0x828a3c8c
	pc = 0x828A3C8C; continue 'dispatch;
	// 828A3C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3C8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3C94: 409A0044  bne cr6, 0x828a3cd8
	if !ctx.cr[6].eq {
	pc = 0x828A3CD8; continue 'dispatch;
	}
	// 828A3C98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3C9C: 419A001C  beq cr6, 0x828a3cb8
	if ctx.cr[6].eq {
	pc = 0x828A3CB8; continue 'dispatch;
	}
	// 828A3CA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3CA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3CAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3CB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3CB4: 4E800421  bctrl
	ctx.lr = 0x828A3CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3CB8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3CBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3CC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3CC8: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3CCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3CD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3CD4: 4BA1C32D  bl 0x822c0000
	ctx.lr = 0x828A3CD8;
	sub_822C0000(ctx, base);
	// 828A3CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3CE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3CEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3CF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3CF8 size=196
    let mut pc: u32 = 0x828A3CF8;
    'dispatch: loop {
        match pc {
            0x828A3CF8 => {
    //   block [0x828A3CF8..0x828A3DBC)
	// 828A3CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3D0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3D10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3D14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3D18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3D1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3D20: 4BA1CC19  bl 0x822c0938
	ctx.lr = 0x828A3D24;
	sub_822C0938(ctx, base);
	// 828A3D24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3D28: 41820028  beq 0x828a3d50
	if ctx.cr[0].eq {
	pc = 0x828A3D50; continue 'dispatch;
	}
	// 828A3D2C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3D30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3D34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3D38: 392B9B34  addi r9, r11, -0x64cc
	ctx.r[9].s64 = ctx.r[11].s64 + -25804;
	// 828A3D3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3D40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3D44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3D48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3D4C: 48000008  b 0x828a3d54
	pc = 0x828A3D54; continue 'dispatch;
	// 828A3D50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3D54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3D5C: 409A0044  bne cr6, 0x828a3da0
	if !ctx.cr[6].eq {
	pc = 0x828A3DA0; continue 'dispatch;
	}
	// 828A3D60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3D64: 419A001C  beq cr6, 0x828a3d80
	if ctx.cr[6].eq {
	pc = 0x828A3D80; continue 'dispatch;
	}
	// 828A3D68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3D6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3D70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3D74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3D78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3D7C: 4E800421  bctrl
	ctx.lr = 0x828A3D80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3D80: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3D84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3D8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3D90: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3D94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3D98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3D9C: 4BA1C265  bl 0x822c0000
	ctx.lr = 0x828A3DA0;
	sub_822C0000(ctx, base);
	// 828A3DA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3DB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3DC0 size=196
    let mut pc: u32 = 0x828A3DC0;
    'dispatch: loop {
        match pc {
            0x828A3DC0 => {
    //   block [0x828A3DC0..0x828A3E84)
	// 828A3DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3DD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3DD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3DDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3DE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3DE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3DE8: 4BA1CB51  bl 0x822c0938
	ctx.lr = 0x828A3DEC;
	sub_822C0938(ctx, base);
	// 828A3DEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3DF0: 41820028  beq 0x828a3e18
	if ctx.cr[0].eq {
	pc = 0x828A3E18; continue 'dispatch;
	}
	// 828A3DF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3DF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3DFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3E00: 392B9B48  addi r9, r11, -0x64b8
	ctx.r[9].s64 = ctx.r[11].s64 + -25784;
	// 828A3E04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3E08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3E0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3E10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3E14: 48000008  b 0x828a3e1c
	pc = 0x828A3E1C; continue 'dispatch;
	// 828A3E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3E1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3E20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3E24: 409A0044  bne cr6, 0x828a3e68
	if !ctx.cr[6].eq {
	pc = 0x828A3E68; continue 'dispatch;
	}
	// 828A3E28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3E2C: 419A001C  beq cr6, 0x828a3e48
	if ctx.cr[6].eq {
	pc = 0x828A3E48; continue 'dispatch;
	}
	// 828A3E30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3E34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3E3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3E40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3E44: 4E800421  bctrl
	ctx.lr = 0x828A3E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3E48: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3E4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3E50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3E54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3E58: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3E5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3E60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3E64: 4BA1C19D  bl 0x822c0000
	ctx.lr = 0x828A3E68;
	sub_822C0000(ctx, base);
	// 828A3E68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3E6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3E70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3E74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3E78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3E88 size=196
    let mut pc: u32 = 0x828A3E88;
    'dispatch: loop {
        match pc {
            0x828A3E88 => {
    //   block [0x828A3E88..0x828A3F4C)
	// 828A3E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3E90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3E94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3E98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3EA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3EA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3EA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3EAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3EB0: 4BA1CA89  bl 0x822c0938
	ctx.lr = 0x828A3EB4;
	sub_822C0938(ctx, base);
	// 828A3EB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3EB8: 41820028  beq 0x828a3ee0
	if ctx.cr[0].eq {
	pc = 0x828A3EE0; continue 'dispatch;
	}
	// 828A3EBC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3EC0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3EC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3EC8: 392B9B5C  addi r9, r11, -0x64a4
	ctx.r[9].s64 = ctx.r[11].s64 + -25764;
	// 828A3ECC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3ED0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3ED4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3ED8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3EDC: 48000008  b 0x828a3ee4
	pc = 0x828A3EE4; continue 'dispatch;
	// 828A3EE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3EE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3EEC: 409A0044  bne cr6, 0x828a3f30
	if !ctx.cr[6].eq {
	pc = 0x828A3F30; continue 'dispatch;
	}
	// 828A3EF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3EF4: 419A001C  beq cr6, 0x828a3f10
	if ctx.cr[6].eq {
	pc = 0x828A3F10; continue 'dispatch;
	}
	// 828A3EF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3EFC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3F04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3F0C: 4E800421  bctrl
	ctx.lr = 0x828A3F10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3F10: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3F14: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3F18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3F1C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3F20: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3F24: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3F28: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3F2C: 4BA1C0D5  bl 0x822c0000
	ctx.lr = 0x828A3F30;
	sub_822C0000(ctx, base);
	// 828A3F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A3F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A3F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A3F40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A3F44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A3F48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A3F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A3F50 size=196
    let mut pc: u32 = 0x828A3F50;
    'dispatch: loop {
        match pc {
            0x828A3F50 => {
    //   block [0x828A3F50..0x828A4014)
	// 828A3F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A3F54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A3F58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A3F5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A3F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A3F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A3F68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3F6C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A3F70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A3F74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3F78: 4BA1C9C1  bl 0x822c0938
	ctx.lr = 0x828A3F7C;
	sub_822C0938(ctx, base);
	// 828A3F7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A3F80: 41820028  beq 0x828a3fa8
	if ctx.cr[0].eq {
	pc = 0x828A3FA8; continue 'dispatch;
	}
	// 828A3F84: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A3F88: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A3F8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A3F90: 392B9B70  addi r9, r11, -0x6490
	ctx.r[9].s64 = ctx.r[11].s64 + -25744;
	// 828A3F94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A3F98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A3F9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A3FA0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A3FA4: 48000008  b 0x828a3fac
	pc = 0x828A3FAC; continue 'dispatch;
	// 828A3FA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A3FAC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A3FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A3FB4: 409A0044  bne cr6, 0x828a3ff8
	if !ctx.cr[6].eq {
	pc = 0x828A3FF8; continue 'dispatch;
	}
	// 828A3FB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A3FBC: 419A001C  beq cr6, 0x828a3fd8
	if ctx.cr[6].eq {
	pc = 0x828A3FD8; continue 'dispatch;
	}
	// 828A3FC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A3FC4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A3FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A3FCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A3FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A3FD4: 4E800421  bctrl
	ctx.lr = 0x828A3FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A3FD8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A3FDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A3FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A3FE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A3FE8: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A3FEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A3FF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A3FF4: 4BA1C00D  bl 0x822c0000
	ctx.lr = 0x828A3FF8;
	sub_822C0000(ctx, base);
	// 828A3FF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A3FFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4008: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A400C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4018 size=196
    let mut pc: u32 = 0x828A4018;
    'dispatch: loop {
        match pc {
            0x828A4018 => {
    //   block [0x828A4018..0x828A40DC)
	// 828A4018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A401C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A4024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A402C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4034: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4038: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A403C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4040: 4BA1C8F9  bl 0x822c0938
	ctx.lr = 0x828A4044;
	sub_822C0938(ctx, base);
	// 828A4044: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4048: 41820028  beq 0x828a4070
	if ctx.cr[0].eq {
	pc = 0x828A4070; continue 'dispatch;
	}
	// 828A404C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4050: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A4054: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4058: 392B9B84  addi r9, r11, -0x647c
	ctx.r[9].s64 = ctx.r[11].s64 + -25724;
	// 828A405C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4060: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A4064: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4068: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A406C: 48000008  b 0x828a4074
	pc = 0x828A4074; continue 'dispatch;
	// 828A4070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4074: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A407C: 409A0044  bne cr6, 0x828a40c0
	if !ctx.cr[6].eq {
	pc = 0x828A40C0; continue 'dispatch;
	}
	// 828A4080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A4084: 419A001C  beq cr6, 0x828a40a0
	if ctx.cr[6].eq {
	pc = 0x828A40A0; continue 'dispatch;
	}
	// 828A4088: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A408C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4094: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A409C: 4E800421  bctrl
	ctx.lr = 0x828A40A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A40A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A40A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A40A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A40AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A40B0: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A40B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A40B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A40BC: 4BA1BF45  bl 0x822c0000
	ctx.lr = 0x828A40C0;
	sub_822C0000(ctx, base);
	// 828A40C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A40C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A40C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A40CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A40D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A40D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A40D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A40E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A40E0 size=196
    let mut pc: u32 = 0x828A40E0;
    'dispatch: loop {
        match pc {
            0x828A40E0 => {
    //   block [0x828A40E0..0x828A41A4)
	// 828A40E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A40E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A40E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A40EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A40F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A40F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A40F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A40FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4100: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A4104: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4108: 4BA1C831  bl 0x822c0938
	ctx.lr = 0x828A410C;
	sub_822C0938(ctx, base);
	// 828A410C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4110: 41820028  beq 0x828a4138
	if ctx.cr[0].eq {
	pc = 0x828A4138; continue 'dispatch;
	}
	// 828A4114: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4118: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A411C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4120: 392B9B98  addi r9, r11, -0x6468
	ctx.r[9].s64 = ctx.r[11].s64 + -25704;
	// 828A4124: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4128: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A412C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4130: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A4134: 48000008  b 0x828a413c
	pc = 0x828A413C; continue 'dispatch;
	// 828A4138: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A413C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4144: 409A0044  bne cr6, 0x828a4188
	if !ctx.cr[6].eq {
	pc = 0x828A4188; continue 'dispatch;
	}
	// 828A4148: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A414C: 419A001C  beq cr6, 0x828a4168
	if ctx.cr[6].eq {
	pc = 0x828A4168; continue 'dispatch;
	}
	// 828A4150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4154: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A415C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4160: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4164: 4E800421  bctrl
	ctx.lr = 0x828A4168;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4168: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A416C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4174: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4178: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A417C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4180: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A4184: 4BA1BE7D  bl 0x822c0000
	ctx.lr = 0x828A4188;
	sub_822C0000(ctx, base);
	// 828A4188: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A418C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4190: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4194: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4198: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A419C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A41A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A41A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A41A8 size=196
    let mut pc: u32 = 0x828A41A8;
    'dispatch: loop {
        match pc {
            0x828A41A8 => {
    //   block [0x828A41A8..0x828A426C)
	// 828A41A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A41AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A41B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A41B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A41B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A41BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A41C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A41C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A41C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A41CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A41D0: 4BA1C769  bl 0x822c0938
	ctx.lr = 0x828A41D4;
	sub_822C0938(ctx, base);
	// 828A41D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A41D8: 41820028  beq 0x828a4200
	if ctx.cr[0].eq {
	pc = 0x828A4200; continue 'dispatch;
	}
	// 828A41DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A41E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A41E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A41E8: 392B9BAC  addi r9, r11, -0x6454
	ctx.r[9].s64 = ctx.r[11].s64 + -25684;
	// 828A41EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A41F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A41F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A41F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A41FC: 48000008  b 0x828a4204
	pc = 0x828A4204; continue 'dispatch;
	// 828A4200: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4204: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A420C: 409A0044  bne cr6, 0x828a4250
	if !ctx.cr[6].eq {
	pc = 0x828A4250; continue 'dispatch;
	}
	// 828A4210: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A4214: 419A001C  beq cr6, 0x828a4230
	if ctx.cr[6].eq {
	pc = 0x828A4230; continue 'dispatch;
	}
	// 828A4218: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A421C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4224: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A422C: 4E800421  bctrl
	ctx.lr = 0x828A4230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4230: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A4234: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A423C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4240: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A4244: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4248: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A424C: 4BA1BDB5  bl 0x822c0000
	ctx.lr = 0x828A4250;
	sub_822C0000(ctx, base);
	// 828A4250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4254: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4258: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A425C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4260: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A4264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4270 size=196
    let mut pc: u32 = 0x828A4270;
    'dispatch: loop {
        match pc {
            0x828A4270 => {
    //   block [0x828A4270..0x828A4334)
	// 828A4270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A427C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4284: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A428C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A4294: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4298: 4BA1C6A1  bl 0x822c0938
	ctx.lr = 0x828A429C;
	sub_822C0938(ctx, base);
	// 828A429C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A42A0: 41820028  beq 0x828a42c8
	if ctx.cr[0].eq {
	pc = 0x828A42C8; continue 'dispatch;
	}
	// 828A42A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A42A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A42AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A42B0: 392B9BC0  addi r9, r11, -0x6440
	ctx.r[9].s64 = ctx.r[11].s64 + -25664;
	// 828A42B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A42B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A42BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A42C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A42C4: 48000008  b 0x828a42cc
	pc = 0x828A42CC; continue 'dispatch;
	// 828A42C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A42CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A42D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A42D4: 409A0044  bne cr6, 0x828a4318
	if !ctx.cr[6].eq {
	pc = 0x828A4318; continue 'dispatch;
	}
	// 828A42D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A42DC: 419A001C  beq cr6, 0x828a42f8
	if ctx.cr[6].eq {
	pc = 0x828A42F8; continue 'dispatch;
	}
	// 828A42E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A42E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A42E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A42EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A42F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A42F4: 4E800421  bctrl
	ctx.lr = 0x828A42F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A42F8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A42FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4304: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4308: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A430C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4310: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A4314: 4BA1BCED  bl 0x822c0000
	ctx.lr = 0x828A4318;
	sub_822C0000(ctx, base);
	// 828A4318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A431C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4328: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A432C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4338 size=196
    let mut pc: u32 = 0x828A4338;
    'dispatch: loop {
        match pc {
            0x828A4338 => {
    //   block [0x828A4338..0x828A43FC)
	// 828A4338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A433C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A4344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A434C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4354: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4358: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A435C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4360: 4BA1C5D9  bl 0x822c0938
	ctx.lr = 0x828A4364;
	sub_822C0938(ctx, base);
	// 828A4364: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4368: 41820028  beq 0x828a4390
	if ctx.cr[0].eq {
	pc = 0x828A4390; continue 'dispatch;
	}
	// 828A436C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4370: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A4374: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4378: 392B9BD4  addi r9, r11, -0x642c
	ctx.r[9].s64 = ctx.r[11].s64 + -25644;
	// 828A437C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4380: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A4384: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4388: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A438C: 48000008  b 0x828a4394
	pc = 0x828A4394; continue 'dispatch;
	// 828A4390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4394: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A439C: 409A0044  bne cr6, 0x828a43e0
	if !ctx.cr[6].eq {
	pc = 0x828A43E0; continue 'dispatch;
	}
	// 828A43A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A43A4: 419A001C  beq cr6, 0x828a43c0
	if ctx.cr[6].eq {
	pc = 0x828A43C0; continue 'dispatch;
	}
	// 828A43A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A43AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A43B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A43B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A43B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A43BC: 4E800421  bctrl
	ctx.lr = 0x828A43C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A43C0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A43C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A43C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A43CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A43D0: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A43D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A43D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A43DC: 4BA1BC25  bl 0x822c0000
	ctx.lr = 0x828A43E0;
	sub_822C0000(ctx, base);
	// 828A43E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A43E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A43E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A43EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A43F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A43F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A43F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4400 size=196
    let mut pc: u32 = 0x828A4400;
    'dispatch: loop {
        match pc {
            0x828A4400 => {
    //   block [0x828A4400..0x828A44C4)
	// 828A4400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4408: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A440C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4418: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A441C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4420: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A4424: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4428: 4BA1C511  bl 0x822c0938
	ctx.lr = 0x828A442C;
	sub_822C0938(ctx, base);
	// 828A442C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4430: 41820028  beq 0x828a4458
	if ctx.cr[0].eq {
	pc = 0x828A4458; continue 'dispatch;
	}
	// 828A4434: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4438: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A443C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4440: 392B9BE8  addi r9, r11, -0x6418
	ctx.r[9].s64 = ctx.r[11].s64 + -25624;
	// 828A4444: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4448: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A444C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4450: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A4454: 48000008  b 0x828a445c
	pc = 0x828A445C; continue 'dispatch;
	// 828A4458: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A445C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4464: 409A0044  bne cr6, 0x828a44a8
	if !ctx.cr[6].eq {
	pc = 0x828A44A8; continue 'dispatch;
	}
	// 828A4468: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A446C: 419A001C  beq cr6, 0x828a4488
	if ctx.cr[6].eq {
	pc = 0x828A4488; continue 'dispatch;
	}
	// 828A4470: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4474: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A447C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4484: 4E800421  bctrl
	ctx.lr = 0x828A4488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4488: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A448C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4494: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4498: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A449C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A44A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A44A4: 4BA1BB5D  bl 0x822c0000
	ctx.lr = 0x828A44A8;
	sub_822C0000(ctx, base);
	// 828A44A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A44AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A44B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A44B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A44B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A44BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A44C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A44C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A44C8 size=196
    let mut pc: u32 = 0x828A44C8;
    'dispatch: loop {
        match pc {
            0x828A44C8 => {
    //   block [0x828A44C8..0x828A458C)
	// 828A44C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A44CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A44D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A44D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A44D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A44DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A44E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A44E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A44E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A44EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A44F0: 4BA1C449  bl 0x822c0938
	ctx.lr = 0x828A44F4;
	sub_822C0938(ctx, base);
	// 828A44F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A44F8: 41820028  beq 0x828a4520
	if ctx.cr[0].eq {
	pc = 0x828A4520; continue 'dispatch;
	}
	// 828A44FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4500: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A4504: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4508: 392B9BFC  addi r9, r11, -0x6404
	ctx.r[9].s64 = ctx.r[11].s64 + -25604;
	// 828A450C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4510: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A4514: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4518: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A451C: 48000008  b 0x828a4524
	pc = 0x828A4524; continue 'dispatch;
	// 828A4520: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4524: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A452C: 409A0044  bne cr6, 0x828a4570
	if !ctx.cr[6].eq {
	pc = 0x828A4570; continue 'dispatch;
	}
	// 828A4530: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A4534: 419A001C  beq cr6, 0x828a4550
	if ctx.cr[6].eq {
	pc = 0x828A4550; continue 'dispatch;
	}
	// 828A4538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A453C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4544: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4548: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A454C: 4E800421  bctrl
	ctx.lr = 0x828A4550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4550: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A4554: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A455C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4560: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A4564: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4568: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A456C: 4BA1BA95  bl 0x822c0000
	ctx.lr = 0x828A4570;
	sub_822C0000(ctx, base);
	// 828A4570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4574: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4578: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A457C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4580: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A4584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4590 size=196
    let mut pc: u32 = 0x828A4590;
    'dispatch: loop {
        match pc {
            0x828A4590 => {
    //   block [0x828A4590..0x828A4654)
	// 828A4590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A459C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A45A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A45A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A45A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A45AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A45B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A45B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A45B8: 4BA1C381  bl 0x822c0938
	ctx.lr = 0x828A45BC;
	sub_822C0938(ctx, base);
	// 828A45BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A45C0: 41820028  beq 0x828a45e8
	if ctx.cr[0].eq {
	pc = 0x828A45E8; continue 'dispatch;
	}
	// 828A45C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A45C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A45CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A45D0: 392B9C10  addi r9, r11, -0x63f0
	ctx.r[9].s64 = ctx.r[11].s64 + -25584;
	// 828A45D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A45D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A45DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A45E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A45E4: 48000008  b 0x828a45ec
	pc = 0x828A45EC; continue 'dispatch;
	// 828A45E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A45EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A45F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A45F4: 409A0044  bne cr6, 0x828a4638
	if !ctx.cr[6].eq {
	pc = 0x828A4638; continue 'dispatch;
	}
	// 828A45F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A45FC: 419A001C  beq cr6, 0x828a4618
	if ctx.cr[6].eq {
	pc = 0x828A4618; continue 'dispatch;
	}
	// 828A4600: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4604: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A460C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4610: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4614: 4E800421  bctrl
	ctx.lr = 0x828A4618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4618: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A461C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4624: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4628: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A462C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4630: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A4634: 4BA1B9CD  bl 0x822c0000
	ctx.lr = 0x828A4638;
	sub_822C0000(ctx, base);
	// 828A4638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A463C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4640: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4644: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4648: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A464C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4658 size=196
    let mut pc: u32 = 0x828A4658;
    'dispatch: loop {
        match pc {
            0x828A4658 => {
    //   block [0x828A4658..0x828A471C)
	// 828A4658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A465C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A4664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A466C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4670: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4674: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4678: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A467C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4680: 4BA1C2B9  bl 0x822c0938
	ctx.lr = 0x828A4684;
	sub_822C0938(ctx, base);
	// 828A4684: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4688: 41820028  beq 0x828a46b0
	if ctx.cr[0].eq {
	pc = 0x828A46B0; continue 'dispatch;
	}
	// 828A468C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4690: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A4694: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4698: 392B9C24  addi r9, r11, -0x63dc
	ctx.r[9].s64 = ctx.r[11].s64 + -25564;
	// 828A469C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A46A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A46A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A46A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A46AC: 48000008  b 0x828a46b4
	pc = 0x828A46B4; continue 'dispatch;
	// 828A46B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A46B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A46B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A46BC: 409A0044  bne cr6, 0x828a4700
	if !ctx.cr[6].eq {
	pc = 0x828A4700; continue 'dispatch;
	}
	// 828A46C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A46C4: 419A001C  beq cr6, 0x828a46e0
	if ctx.cr[6].eq {
	pc = 0x828A46E0; continue 'dispatch;
	}
	// 828A46C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A46CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A46D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A46D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A46D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A46DC: 4E800421  bctrl
	ctx.lr = 0x828A46E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A46E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A46E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A46E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A46EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A46F0: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A46F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A46F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A46FC: 4BA1B905  bl 0x822c0000
	ctx.lr = 0x828A4700;
	sub_822C0000(ctx, base);
	// 828A4700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4708: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A470C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4710: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A4714: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4718: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4720 size=196
    let mut pc: u32 = 0x828A4720;
    'dispatch: loop {
        match pc {
            0x828A4720 => {
    //   block [0x828A4720..0x828A47E4)
	// 828A4720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A472C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4734: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A473C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4740: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A4744: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4748: 4BA1C1F1  bl 0x822c0938
	ctx.lr = 0x828A474C;
	sub_822C0938(ctx, base);
	// 828A474C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4750: 41820028  beq 0x828a4778
	if ctx.cr[0].eq {
	pc = 0x828A4778; continue 'dispatch;
	}
	// 828A4754: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4758: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A475C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4760: 392B9C38  addi r9, r11, -0x63c8
	ctx.r[9].s64 = ctx.r[11].s64 + -25544;
	// 828A4764: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4768: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A476C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4770: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A4774: 48000008  b 0x828a477c
	pc = 0x828A477C; continue 'dispatch;
	// 828A4778: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A477C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4784: 409A0044  bne cr6, 0x828a47c8
	if !ctx.cr[6].eq {
	pc = 0x828A47C8; continue 'dispatch;
	}
	// 828A4788: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A478C: 419A001C  beq cr6, 0x828a47a8
	if ctx.cr[6].eq {
	pc = 0x828A47A8; continue 'dispatch;
	}
	// 828A4790: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4794: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A479C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A47A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A47A4: 4E800421  bctrl
	ctx.lr = 0x828A47A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A47A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A47AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A47B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A47B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A47B8: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A47BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A47C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A47C4: 4BA1B83D  bl 0x822c0000
	ctx.lr = 0x828A47C8;
	sub_822C0000(ctx, base);
	// 828A47C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A47CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A47D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A47D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A47D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A47DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A47E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A47E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A47E8 size=196
    let mut pc: u32 = 0x828A47E8;
    'dispatch: loop {
        match pc {
            0x828A47E8 => {
    //   block [0x828A47E8..0x828A48AC)
	// 828A47E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A47EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A47F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A47F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A47F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A47FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A4800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4804: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A4808: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A480C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4810: 4BA1C129  bl 0x822c0938
	ctx.lr = 0x828A4814;
	sub_822C0938(ctx, base);
	// 828A4814: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A4818: 41820028  beq 0x828a4840
	if ctx.cr[0].eq {
	pc = 0x828A4840; continue 'dispatch;
	}
	// 828A481C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4820: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A4824: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A4828: 392B9C4C  addi r9, r11, -0x63b4
	ctx.r[9].s64 = ctx.r[11].s64 + -25524;
	// 828A482C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A4830: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A4834: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4838: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A483C: 48000008  b 0x828a4844
	pc = 0x828A4844; continue 'dispatch;
	// 828A4840: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A4844: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A484C: 409A0044  bne cr6, 0x828a4890
	if !ctx.cr[6].eq {
	pc = 0x828A4890; continue 'dispatch;
	}
	// 828A4850: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A4854: 419A001C  beq cr6, 0x828a4870
	if ctx.cr[6].eq {
	pc = 0x828A4870; continue 'dispatch;
	}
	// 828A4858: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A485C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4864: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A486C: 4E800421  bctrl
	ctx.lr = 0x828A4870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4870: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A4874: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A487C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4880: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A4884: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4888: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A488C: 4BA1B775  bl 0x822c0000
	ctx.lr = 0x828A4890;
	sub_822C0000(ctx, base);
	// 828A4890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A489C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A48A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A48A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A48A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A48B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A48B0 size=196
    let mut pc: u32 = 0x828A48B0;
    'dispatch: loop {
        match pc {
            0x828A48B0 => {
    //   block [0x828A48B0..0x828A4974)
	// 828A48B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A48B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A48B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A48BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A48C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A48C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A48C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A48CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A48D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A48D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A48D8: 4BA1C061  bl 0x822c0938
	ctx.lr = 0x828A48DC;
	sub_822C0938(ctx, base);
	// 828A48DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A48E0: 41820028  beq 0x828a4908
	if ctx.cr[0].eq {
	pc = 0x828A4908; continue 'dispatch;
	}
	// 828A48E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A48E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A48EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A48F0: 392B9C60  addi r9, r11, -0x63a0
	ctx.r[9].s64 = ctx.r[11].s64 + -25504;
	// 828A48F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A48F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A48FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A4900: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A4904: 48000008  b 0x828a490c
	pc = 0x828A490C; continue 'dispatch;
	// 828A4908: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A490C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A4914: 409A0044  bne cr6, 0x828a4958
	if !ctx.cr[6].eq {
	pc = 0x828A4958; continue 'dispatch;
	}
	// 828A4918: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A491C: 419A001C  beq cr6, 0x828a4938
	if ctx.cr[6].eq {
	pc = 0x828A4938; continue 'dispatch;
	}
	// 828A4920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4924: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A492C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4930: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4934: 4E800421  bctrl
	ctx.lr = 0x828A4938;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4938: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A493C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4944: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A4948: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A494C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A4950: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A4954: 4BA1B6AD  bl 0x822c0000
	ctx.lr = 0x828A4958;
	sub_822C0000(ctx, base);
	// 828A4958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A495C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A496C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4978 size=500
    let mut pc: u32 = 0x828A4978;
    'dispatch: loop {
        match pc {
            0x828A4978 => {
    //   block [0x828A4978..0x828A4B6C)
	// 828A4978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A497C: 489037ED  bl 0x831a8168
	ctx.lr = 0x828A4980;
	sub_831A8130(ctx, base);
	// 828A4980: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4984: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828A4988: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A498C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A4990: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A4994: 41820038  beq 0x828a49cc
	if ctx.cr[0].eq {
	pc = 0x828A49CC; continue 'dispatch;
	}
	// 828A4998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A499C: 48904FED  bl 0x831a9988
	ctx.lr = 0x828A49A0;
	sub_831A9988(ctx, base);
	// 828A49A0: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 828A49A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A49A8: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 828A49AC: 4890374D  bl 0x831a80f8
	ctx.lr = 0x828A49B0;
	sub_831A80F8(ctx, base);
	// 828A49B0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A49B4: 41820018  beq 0x828a49cc
	if ctx.cr[0].eq {
	pc = 0x828A49CC; continue 'dispatch;
	}
	// 828A49B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A49BC: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828A49C0: 481EFE59  bl 0x82a94818
	ctx.lr = 0x828A49C4;
	sub_82A94818(ctx, base);
	// 828A49C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828A49C8: 4800019C  b 0x828a4b64
	pc = 0x828A4B64; continue 'dispatch;
	// 828A49CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A49D0: 419A0184  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A49D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A49D8: 48904FB1  bl 0x831a9988
	ctx.lr = 0x828A49DC;
	sub_831A9988(ctx, base);
	// 828A49DC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828A49E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A49E4: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 828A49E8: 48903711  bl 0x831a80f8
	ctx.lr = 0x828A49EC;
	sub_831A80F8(ctx, base);
	// 828A49EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A49F0: 41820014  beq 0x828a4a04
	if ctx.cr[0].eq {
	pc = 0x828A4A04; continue 'dispatch;
	}
	// 828A49F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A49F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A49FC: 480354E5  bl 0x828d9ee0
	ctx.lr = 0x828A4A00;
	sub_828D9EE0(ctx, base);
	// 828A4A00: 4BFFFFC4  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4A04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A4A08: 419A014C  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4A10: 48904F79  bl 0x831a9988
	ctx.lr = 0x828A4A14;
	sub_831A9988(ctx, base);
	// 828A4A14: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828A4A18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4A1C: 386BD5B0  addi r3, r11, -0x2a50
	ctx.r[3].s64 = ctx.r[11].s64 + -10832;
	// 828A4A20: 489036D9  bl 0x831a80f8
	ctx.lr = 0x828A4A24;
	sub_831A80F8(ctx, base);
	// 828A4A24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4A28: 41820014  beq 0x828a4a3c
	if ctx.cr[0].eq {
	pc = 0x828A4A3C; continue 'dispatch;
	}
	// 828A4A2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4A30: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828A4A34: 4BDBCCC5  bl 0x826616f8
	ctx.lr = 0x828A4A38;
	sub_826616F8(ctx, base);
	// 828A4A38: 4BFFFF8C  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4A3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A4A40: 419A0114  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4A48: 48904F41  bl 0x831a9988
	ctx.lr = 0x828A4A4C;
	sub_831A9988(ctx, base);
	// 828A4A4C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828A4A50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4A54: 386B5CEC  addi r3, r11, 0x5cec
	ctx.r[3].s64 = ctx.r[11].s64 + 23788;
	// 828A4A58: 489036A1  bl 0x831a80f8
	ctx.lr = 0x828A4A5C;
	sub_831A80F8(ctx, base);
	// 828A4A5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4A60: 41820014  beq 0x828a4a74
	if ctx.cr[0].eq {
	pc = 0x828A4A74; continue 'dispatch;
	}
	// 828A4A64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4A68: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828A4A6C: 4BF46555  bl 0x827eafc0
	ctx.lr = 0x828A4A70;
	sub_827EAFC0(ctx, base);
	// 828A4A70: 4BFFFF54  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4A74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A4A78: 419A00DC  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4A80: 48904F09  bl 0x831a9988
	ctx.lr = 0x828A4A84;
	sub_831A9988(ctx, base);
	// 828A4A84: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 828A4A88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4A8C: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 828A4A90: 48903669  bl 0x831a80f8
	ctx.lr = 0x828A4A94;
	sub_831A80F8(ctx, base);
	// 828A4A94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4A98: 41820014  beq 0x828a4aac
	if ctx.cr[0].eq {
	pc = 0x828A4AAC; continue 'dispatch;
	}
	// 828A4A9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4AA0: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828A4AA4: 4802A185  bl 0x828cec28
	ctx.lr = 0x828A4AA8;
	sub_828CEC28(ctx, base);
	// 828A4AA8: 4BFFFF1C  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4AAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A4AB0: 419A00A4  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4AB8: 48904ED1  bl 0x831a9988
	ctx.lr = 0x828A4ABC;
	sub_831A9988(ctx, base);
	// 828A4ABC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828A4AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4AC4: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 828A4AC8: 48903631  bl 0x831a80f8
	ctx.lr = 0x828A4ACC;
	sub_831A80F8(ctx, base);
	// 828A4ACC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4AD0: 41820014  beq 0x828a4ae4
	if ctx.cr[0].eq {
	pc = 0x828A4AE4; continue 'dispatch;
	}
	// 828A4AD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4AD8: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828A4ADC: 4800D2A5  bl 0x828b1d80
	ctx.lr = 0x828A4AE0;
	sub_828B1D80(ctx, base);
	// 828A4AE0: 4BFFFEE4  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4AE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A4AE8: 419A006C  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4AEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4AF0: 48904E99  bl 0x831a9988
	ctx.lr = 0x828A4AF4;
	sub_831A9988(ctx, base);
	// 828A4AF4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828A4AF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4AFC: 386B5CC4  addi r3, r11, 0x5cc4
	ctx.r[3].s64 = ctx.r[11].s64 + 23748;
	// 828A4B00: 489035F9  bl 0x831a80f8
	ctx.lr = 0x828A4B04;
	sub_831A80F8(ctx, base);
	// 828A4B04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4B08: 41820014  beq 0x828a4b1c
	if ctx.cr[0].eq {
	pc = 0x828A4B1C; continue 'dispatch;
	}
	// 828A4B0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4B10: 387EFFC8  addi r3, r30, -0x38
	ctx.r[3].s64 = ctx.r[30].s64 + -56;
	// 828A4B14: 48029F0D  bl 0x828cea20
	ctx.lr = 0x828A4B18;
	sub_828CEA20(ctx, base);
	// 828A4B18: 4BFFFEAC  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4B1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A4B20: 419A0034  beq cr6, 0x828a4b54
	if ctx.cr[6].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4B28: 48904E61  bl 0x831a9988
	ctx.lr = 0x828A4B2C;
	sub_831A9988(ctx, base);
	// 828A4B2C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 828A4B30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4B34: 386B595C  addi r3, r11, 0x595c
	ctx.r[3].s64 = ctx.r[11].s64 + 22876;
	// 828A4B38: 489035C1  bl 0x831a80f8
	ctx.lr = 0x828A4B3C;
	sub_831A80F8(ctx, base);
	// 828A4B3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A4B40: 41820014  beq 0x828a4b54
	if ctx.cr[0].eq {
	pc = 0x828A4B54; continue 'dispatch;
	}
	// 828A4B44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4B48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 828A4B4C: 480647B5  bl 0x82909300
	ctx.lr = 0x828A4B50;
	sub_82909300(ctx, base);
	// 828A4B50: 4BFFFE74  b 0x828a49c4
	pc = 0x828A49C4; continue 'dispatch;
	// 828A4B54: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A4B58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A4B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4B60: 4806AF31  bl 0x8290fa90
	ctx.lr = 0x828A4B64;
	sub_8290FA90(ctx, base);
	// 828A4B64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A4B68: 48903650  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4B70 size=300
    let mut pc: u32 = 0x828A4B70;
    'dispatch: loop {
        match pc {
            0x828A4B70 => {
    //   block [0x828A4B70..0x828A4C9C)
	// 828A4B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A4B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4B80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4B88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4B8C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828A4B90: 396B9E64  addi r11, r11, -0x619c
	ctx.r[11].s64 = ctx.r[11].s64 + -24988;
	// 828A4B94: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A4B98: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A4B9C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A4BA0: 394A9CA4  addi r10, r10, -0x635c
	ctx.r[10].s64 = ctx.r[10].s64 + -25436;
	// 828A4BA4: 807F03CC  lwz r3, 0x3cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828A4BA8: 39299C90  addi r9, r9, -0x6370
	ctx.r[9].s64 = ctx.r[9].s64 + -25456;
	// 828A4BAC: 39689E48  addi r11, r8, -0x61b8
	ctx.r[11].s64 = ctx.r[8].s64 + -25016;
	// 828A4BB0: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828A4BB4: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828A4BB8: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828A4BBC: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828A4BC0: 4BA1B6A9  bl 0x822c0268
	ctx.lr = 0x828A4BC4;
	sub_822C0268(ctx, base);
	// 828A4BC4: 807F03B8  lwz r3, 0x3b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 828A4BC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4BCC: 419A0008  beq cr6, 0x828a4bd4
	if ctx.cr[6].eq {
	pc = 0x828A4BD4; continue 'dispatch;
	}
	// 828A4BD0: 4BA1BCC1  bl 0x822c0890
	ctx.lr = 0x828A4BD4;
	sub_822C0890(ctx, base);
	// 828A4BD4: 807F03B0  lwz r3, 0x3b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(944 as u32) ) } as u64;
	// 828A4BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4BDC: 419A0008  beq cr6, 0x828a4be4
	if ctx.cr[6].eq {
	pc = 0x828A4BE4; continue 'dispatch;
	}
	// 828A4BE0: 4BA1BCB1  bl 0x822c0890
	ctx.lr = 0x828A4BE4;
	sub_822C0890(ctx, base);
	// 828A4BE4: 807F03A8  lwz r3, 0x3a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 828A4BE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4BEC: 419A0008  beq cr6, 0x828a4bf4
	if ctx.cr[6].eq {
	pc = 0x828A4BF4; continue 'dispatch;
	}
	// 828A4BF0: 4BA1BCA1  bl 0x822c0890
	ctx.lr = 0x828A4BF4;
	sub_822C0890(ctx, base);
	// 828A4BF4: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 828A4BF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4BFC: 419A0008  beq cr6, 0x828a4c04
	if ctx.cr[6].eq {
	pc = 0x828A4C04; continue 'dispatch;
	}
	// 828A4C00: 4BA1BC91  bl 0x822c0890
	ctx.lr = 0x828A4C04;
	sub_822C0890(ctx, base);
	// 828A4C04: 807F0398  lwz r3, 0x398(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) } as u64;
	// 828A4C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4C0C: 419A0018  beq cr6, 0x828a4c24
	if ctx.cr[6].eq {
	pc = 0x828A4C24; continue 'dispatch;
	}
	// 828A4C10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4C14: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828A4C18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4C1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4C20: 4E800421  bctrl
	ctx.lr = 0x828A4C24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4C24: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828A4C28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4C2C: 419A0008  beq cr6, 0x828a4c34
	if ctx.cr[6].eq {
	pc = 0x828A4C34; continue 'dispatch;
	}
	// 828A4C30: 4BA1BC61  bl 0x822c0890
	ctx.lr = 0x828A4C34;
	sub_822C0890(ctx, base);
	// 828A4C34: 807F038C  lwz r3, 0x38c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 828A4C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4C3C: 419A0008  beq cr6, 0x828a4c44
	if ctx.cr[6].eq {
	pc = 0x828A4C44; continue 'dispatch;
	}
	// 828A4C40: 4BA1BC51  bl 0x822c0890
	ctx.lr = 0x828A4C44;
	sub_822C0890(ctx, base);
	// 828A4C44: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 828A4C48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4C4C: 419A0008  beq cr6, 0x828a4c54
	if ctx.cr[6].eq {
	pc = 0x828A4C54; continue 'dispatch;
	}
	// 828A4C50: 4BA1BC41  bl 0x822c0890
	ctx.lr = 0x828A4C54;
	sub_822C0890(ctx, base);
	// 828A4C54: 807F037C  lwz r3, 0x37c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(892 as u32) ) } as u64;
	// 828A4C58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4C5C: 419A0008  beq cr6, 0x828a4c64
	if ctx.cr[6].eq {
	pc = 0x828A4C64; continue 'dispatch;
	}
	// 828A4C60: 4BA1BC31  bl 0x822c0890
	ctx.lr = 0x828A4C64;
	sub_822C0890(ctx, base);
	// 828A4C64: 807F0374  lwz r3, 0x374(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(884 as u32) ) } as u64;
	// 828A4C68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4C6C: 419A0008  beq cr6, 0x828a4c74
	if ctx.cr[6].eq {
	pc = 0x828A4C74; continue 'dispatch;
	}
	// 828A4C70: 4BA1BC21  bl 0x822c0890
	ctx.lr = 0x828A4C74;
	sub_822C0890(ctx, base);
	// 828A4C74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A4C78: 4806C019  bl 0x82910c90
	ctx.lr = 0x828A4C7C;
	sub_82910C90(ctx, base);
	// 828A4C7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4C80: 4BF029D9  bl 0x827a7658
	ctx.lr = 0x828A4C84;
	sub_827A7658(ctx, base);
	// 828A4C84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A4C88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A4C8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A4C90: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A4C94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A4C98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A4CA0 size=8
    let mut pc: u32 = 0x828A4CA0;
    'dispatch: loop {
        match pc {
            0x828A4CA0 => {
    //   block [0x828A4CA0..0x828A4CA8)
	// 828A4CA0: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 828A4CA4: 48000A74  b 0x828a5718
	sub_828A5718(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A4CA8 size=8
    let mut pc: u32 = 0x828A4CA8;
    'dispatch: loop {
        match pc {
            0x828A4CA8 => {
    //   block [0x828A4CA8..0x828A4CB0)
	// 828A4CA8: 3863FFC8  addi r3, r3, -0x38
	ctx.r[3].s64 = ctx.r[3].s64 + -56;
	// 828A4CAC: 48000A6C  b 0x828a5718
	sub_828A5718(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A4CB0 size=8
    let mut pc: u32 = 0x828A4CB0;
    'dispatch: loop {
        match pc {
            0x828A4CB0 => {
    //   block [0x828A4CB0..0x828A4CB8)
	// 828A4CB0: 3863FDE8  addi r3, r3, -0x218
	ctx.r[3].s64 = ctx.r[3].s64 + -536;
	// 828A4CB4: 48000A64  b 0x828a5718
	sub_828A5718(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A4CB8 size=180
    let mut pc: u32 = 0x828A4CB8;
    'dispatch: loop {
        match pc {
            0x828A4CB8 => {
    //   block [0x828A4CB8..0x828A4D6C)
	// 828A4CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4CBC: 489034A5  bl 0x831a8160
	ctx.lr = 0x828A4CC0;
	sub_831A8130(ctx, base);
	// 828A4CC0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4CC4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A4CC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A4CCC: 3BEBC870  addi r31, r11, -0x3790
	ctx.r[31].s64 = ctx.r[11].s64 + -14224;
	// 828A4CD0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A4CD4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A4CD8: 3B40000A  li r26, 0xa
	ctx.r[26].s64 = 10;
	// 828A4CDC: 3F608337  lis r27, -0x7cc9
	ctx.r[27].s64 = -2093547520;
	// 828A4CE0: 3B8B9EBC  addi r28, r11, -0x6144
	ctx.r[28].s64 = ctx.r[11].s64 + -24900;
	// 828A4CE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A4CE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A4CEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A4CF0: 48903DE9  bl 0x831a8ad8
	ctx.lr = 0x828A4CF4;
	sub_831A8AD8(ctx, base);
	// 828A4CF4: 93FBC86C  stw r31, -0x3794(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-14228 as u32), ctx.r[31].u32 ) };
	// 828A4CF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A4CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4D00: 4854ED09  bl 0x82df3a08
	ctx.lr = 0x828A4D04;
	sub_82DF3A08(ctx, base);
	// 828A4D04: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4D08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A4D0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A4D10: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4D14: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828A4D18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4D1C: 4E800421  bctrl
	ctx.lr = 0x828A4D20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4D24: 4854E705  bl 0x82df3428
	ctx.lr = 0x828A4D28;
	sub_82DF3428(ctx, base);
	// 828A4D28: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A4D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4D30: 48007AB9  bl 0x828ac7e8
	ctx.lr = 0x828A4D34;
	sub_828AC7E8(ctx, base);
	// 828A4D34: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A4D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4D3C: 419A0008  beq cr6, 0x828a4d44
	if ctx.cr[6].eq {
	pc = 0x828A4D44; continue 'dispatch;
	}
	// 828A4D40: 4BA1BB51  bl 0x822c0890
	ctx.lr = 0x828A4D44;
	sub_822C0890(ctx, base);
	// 828A4D44: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 828A4D48: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 828A4D4C: 3BFF03B4  addi r31, r31, 0x3b4
	ctx.r[31].s64 = ctx.r[31].s64 + 948;
	// 828A4D50: 4082FF94  bne 0x828a4ce4
	if !ctx.cr[0].eq {
	pc = 0x828A4CE4; continue 'dispatch;
	}
	// 828A4D54: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4D58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A4D5C: 419A0008  beq cr6, 0x828a4d64
	if ctx.cr[6].eq {
	pc = 0x828A4D64; continue 'dispatch;
	}
	// 828A4D60: 4BA1BB31  bl 0x822c0890
	ctx.lr = 0x828A4D64;
	sub_822C0890(ctx, base);
	// 828A4D64: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828A4D68: 48903448  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A4D70 size=552
    let mut pc: u32 = 0x828A4D70;
    'dispatch: loop {
        match pc {
            0x828A4D70 => {
    //   block [0x828A4D70..0x828A4F98)
	// 828A4D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4D74: 489033F9  bl 0x831a816c
	ctx.lr = 0x828A4D78;
	sub_831A8130(ctx, base);
	// 828A4D78: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828A4D7C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828A4D80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4D88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A4D8C: 4806C495  bl 0x82911220
	ctx.lr = 0x828A4D90;
	sub_82911220(ctx, base);
	// 828A4D90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A4D94: 807F0370  lwz r3, 0x370(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) } as u64;
	// 828A4D98: 4807DBE1  bl 0x82922978
	ctx.lr = 0x828A4D9C;
	sub_82922978(ctx, base);
	// 828A4D9C: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A4DA0: 480D7D59  bl 0x8297caf8
	ctx.lr = 0x828A4DA4;
	sub_8297CAF8(ctx, base);
	// 828A4DA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A4DA8: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 828A4DAC: 4BF453E5  bl 0x827ea190
	ctx.lr = 0x828A4DB0;
	sub_827EA190(ctx, base);
	// 828A4DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4DB4: 4BF473AD  bl 0x827ec160
	ctx.lr = 0x828A4DB8;
	sub_827EC160(ctx, base);
	// 828A4DB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4DBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A4DC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4DC4: 4E800421  bctrl
	ctx.lr = 0x828A4DC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4DC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4DD0: 4821D1C1  bl 0x82ac1f90
	ctx.lr = 0x828A4DD4;
	sub_82AC1F90(ctx, base);
	// 828A4DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4DD8: 4BF47389  bl 0x827ec160
	ctx.lr = 0x828A4DDC;
	sub_827EC160(ctx, base);
	// 828A4DDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4DE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828A4DE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A4DE8: 4E800421  bctrl
	ctx.lr = 0x828A4DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A4DEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A4DF4: 482066E5  bl 0x82aab4d8
	ctx.lr = 0x828A4DF8;
	sub_82AAB4D8(ctx, base);
	// 828A4DF8: 807F0394  lwz r3, 0x394(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) } as u64;
	// 828A4DFC: 48077005  bl 0x8291be00
	ctx.lr = 0x828A4E00;
	sub_8291BE00(ctx, base);
	// 828A4E00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A4E04: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A4E08: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A4E0C: 4182000C  beq 0x828a4e18
	if ctx.cr[0].eq {
	pc = 0x828A4E18; continue 'dispatch;
	}
	// 828A4E10: D3FF03AC  stfs f31, 0x3ac(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 828A4E14: 48000014  b 0x828a4e28
	pc = 0x828A4E28; continue 'dispatch;
	// 828A4E18: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A4E1C: C1BF03AC  lfs f13, 0x3ac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A4E20: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 828A4E24: D01F03AC  stfs f0, 0x3ac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), tmp.u32 ) };
	// 828A4E28: 3BDF03C0  addi r30, r31, 0x3c0
	ctx.r[30].s64 = ctx.r[31].s64 + 960;
	// 828A4E2C: 396003D0  li r11, 0x3d0
	ctx.r[11].s64 = 976;
	// 828A4E30: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828A4E34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4E38: 388AF820  addi r4, r10, -0x7e0
	ctx.r[4].s64 = ctx.r[10].s64 + -2016;
	// 828A4E3C: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A4F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A4F98 size=216
    let mut pc: u32 = 0x828A4F98;
    'dispatch: loop {
        match pc {
            0x828A4F98 => {
    //   block [0x828A4F98..0x828A5070)
	// 828A4F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A4F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A4FA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A4FA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A4FA8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A4FAC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A4FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A4FB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A4FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A4FBC: 388B7868  addi r4, r11, 0x7868
	ctx.r[4].s64 = ctx.r[11].s64 + 30824;
	// 828A4FC0: 4854EA49  bl 0x82df3a08
	ctx.lr = 0x828A4FC4;
	sub_82DF3A08(ctx, base);
	// 828A4FC4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828A4FC8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828A4FCC: 4BF4720D  bl 0x827ec1d8
	ctx.lr = 0x828A4FD0;
	sub_827EC1D8(ctx, base);
	// 828A4FD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A4FD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A4FD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A4FDC: 48570055  bl 0x82e15030
	ctx.lr = 0x828A4FE0;
	sub_82E15030(ctx, base);
	// 828A4FE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A4FE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A4FE8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A4FEC: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	// 828A4FF0: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A4FF4: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A4FF8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828A4FFC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828A5000: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828A5004: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828A5008: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A500C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A5010: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A5014: 4E800421  bctrl
	ctx.lr = 0x828A5018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A5018: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A501C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A5020: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5024: 485D6CA5  bl 0x82e7bcc8
	ctx.lr = 0x828A5028;
	sub_82E7BCC8(ctx, base);
	// 828A5028: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A502C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A5030: 419A0008  beq cr6, 0x828a5038
	if ctx.cr[6].eq {
	pc = 0x828A5038; continue 'dispatch;
	}
	// 828A5034: 4BA1B85D  bl 0x822c0890
	ctx.lr = 0x828A5038;
	sub_822C0890(ctx, base);
	// 828A5038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A503C: 4854E3ED  bl 0x82df3428
	ctx.lr = 0x828A5040;
	sub_82DF3428(ctx, base);
	// 828A5040: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 828A5044: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 828A5048: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828A504C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5070 size=80
    let mut pc: u32 = 0x828A5070;
    'dispatch: loop {
        match pc {
            0x828A5070 => {
    //   block [0x828A5070..0x828A50C0)
	// 828A5070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A507C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5084: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828A5088: 419A0014  beq cr6, 0x828a509c
	if ctx.cr[6].eq {
	pc = 0x828A509C; continue 'dispatch;
	}
	// 828A508C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A5090: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5094: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828A5098: 48000014  b 0x828a50ac
	pc = 0x828A50AC; continue 'dispatch;
	// 828A509C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A50A0: 38AB9ED0  addi r5, r11, -0x6130
	ctx.r[5].s64 = ctx.r[11].s64 + -24880;
	// 828A50A4: 4BC6D0D5  bl 0x82512178
	ctx.lr = 0x828A50A8;
	sub_82512178(ctx, base);
	// 828A50A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A50AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A50B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A50B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A50B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A50BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A50C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A50C0 size=168
    let mut pc: u32 = 0x828A50C0;
    'dispatch: loop {
        match pc {
            0x828A50C0 => {
    //   block [0x828A50C0..0x828A5168)
	// 828A50C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A50C4: 489030A9  bl 0x831a816c
	ctx.lr = 0x828A50C8;
	sub_831A8130(ctx, base);
	// 828A50C8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A5168 size=244
    let mut pc: u32 = 0x828A5168;
    'dispatch: loop {
        match pc {
            0x828A5168 => {
    //   block [0x828A5168..0x828A525C)
	// 828A5168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A516C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A5174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A5178: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A517C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A5180: 897E03C8  lbz r11, 0x3c8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(968 as u32) ) } as u64;
	// 828A5184: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5188: 408200BC  bne 0x828a5244
	if !ctx.cr[0].eq {
	pc = 0x828A5244; continue 'dispatch;
	}
	// 828A518C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5190: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5194: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 828A5198: 4854E871  bl 0x82df3a08
	ctx.lr = 0x828A519C;
	sub_82DF3A08(ctx, base);
	// 828A519C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A51A0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828A51A4: 388B9EE8  addi r4, r11, -0x6118
	ctx.r[4].s64 = ctx.r[11].s64 + -24856;
	// 828A51A8: 4854E861  bl 0x82df3a08
	ctx.lr = 0x828A51AC;
	sub_82DF3A08(ctx, base);
	// 828A51AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A51B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A51B4: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 828A51B8: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828A51BC: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828A51C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828A51C4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A51C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A51CC: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A51D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A51D4: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828A51D8: D0210088  stfs f1, 0x88(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828A51DC: D021008C  stfs f1, 0x8c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828A51E0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828A51E4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828A51E8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828A51EC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828A51F0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828A51F4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828A51F8: 4BF47411  bl 0x827ec608
	ctx.lr = 0x828A51FC;
	sub_827EC608(ctx, base);
	// 828A51FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A5200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5204: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 828A5208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A520C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A5210: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A5214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A5218: 4E800421  bctrl
	ctx.lr = 0x828A521C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A521C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A5220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A5224: 419A0008  beq cr6, 0x828a522c
	if ctx.cr[6].eq {
	pc = 0x828A522C; continue 'dispatch;
	}
	// 828A5228: 4BA1B669  bl 0x822c0890
	ctx.lr = 0x828A522C;
	sub_822C0890(ctx, base);
	// 828A522C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A5230: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828A5234: 997E03C8  stb r11, 0x3c8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(968 as u32), ctx.r[11].u8 ) };
	// 828A5238: 4854E1F1  bl 0x82df3428
	ctx.lr = 0x828A523C;
	sub_82DF3428(ctx, base);
	// 828A523C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5240: 4854E1E9  bl 0x82df3428
	ctx.lr = 0x828A5244;
	sub_82DF3428(ctx, base);
	// 828A5244: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A5248: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A524C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5250: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A5254: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A5258: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5260 size=188
    let mut pc: u32 = 0x828A5260;
    'dispatch: loop {
        match pc {
            0x828A5260 => {
    //   block [0x828A5260..0x828A531C)
	// 828A5260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A526C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A5270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5274: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A5278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A527C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A5280: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A5284: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5288: 4BA1B6B1  bl 0x822c0938
	ctx.lr = 0x828A528C;
	sub_822C0938(ctx, base);
	// 828A528C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5290: 41820028  beq 0x828a52b8
	if ctx.cr[0].eq {
	pc = 0x828A52B8; continue 'dispatch;
	}
	// 828A5294: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A5298: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A529C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A52A0: 392B9A80  addi r9, r11, -0x6580
	ctx.r[9].s64 = ctx.r[11].s64 + -25984;
	// 828A52A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A52A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A52AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A52B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A52B4: 48000008  b 0x828a52bc
	pc = 0x828A52BC; continue 'dispatch;
	// 828A52B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A52BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A52C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A52C4: 409A003C  bne cr6, 0x828a5300
	if !ctx.cr[6].eq {
	pc = 0x828A5300; continue 'dispatch;
	}
	// 828A52C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A52CC: 419A0014  beq cr6, 0x828a52e0
	if ctx.cr[6].eq {
	pc = 0x828A52E0; continue 'dispatch;
	}
	// 828A52D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A52D4: 480765A5  bl 0x8291b878
	ctx.lr = 0x828A52D8;
	sub_8291B878(ctx, base);
	// 828A52D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A52DC: 4BA1AF8D  bl 0x822c0268
	ctx.lr = 0x828A52E0;
	sub_822C0268(ctx, base);
	// 828A52E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A52E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A52E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A52EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A52F0: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A52F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A52F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A52FC: 4BA1AD05  bl 0x822c0000
	ctx.lr = 0x828A5300;
	sub_822C0000(ctx, base);
	// 828A5300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A530C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5310: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A5314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A5318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5320 size=188
    let mut pc: u32 = 0x828A5320;
    'dispatch: loop {
        match pc {
            0x828A5320 => {
    //   block [0x828A5320..0x828A53DC)
	// 828A5320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5328: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A532C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A5330: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A5338: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A533C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A5340: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A5344: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5348: 4BA1B5F1  bl 0x822c0938
	ctx.lr = 0x828A534C;
	sub_822C0938(ctx, base);
	// 828A534C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5350: 41820028  beq 0x828a5378
	if ctx.cr[0].eq {
	pc = 0x828A5378; continue 'dispatch;
	}
	// 828A5354: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A5358: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828A535C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828A5360: 392B9A94  addi r9, r11, -0x656c
	ctx.r[9].s64 = ctx.r[11].s64 + -25964;
	// 828A5364: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A5368: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A536C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828A5370: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828A5374: 48000008  b 0x828a537c
	pc = 0x828A537C; continue 'dispatch;
	// 828A5378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A537C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A5384: 409A003C  bne cr6, 0x828a53c0
	if !ctx.cr[6].eq {
	pc = 0x828A53C0; continue 'dispatch;
	}
	// 828A5388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A538C: 419A0014  beq cr6, 0x828a53a0
	if ctx.cr[6].eq {
	pc = 0x828A53A0; continue 'dispatch;
	}
	// 828A5390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5394: 4800638D  bl 0x828ab720
	ctx.lr = 0x828A5398;
	sub_828AB720(ctx, base);
	// 828A5398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A539C: 4BA1AECD  bl 0x822c0268
	ctx.lr = 0x828A53A0;
	sub_822C0268(ctx, base);
	// 828A53A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A53A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A53A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A53AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828A53B0: 816BFEA8  lwz r11, -0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-344 as u32) ) } as u64;
	// 828A53B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828A53B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A53BC: 4BA1AC45  bl 0x822c0000
	ctx.lr = 0x828A53C0;
	sub_822C0000(ctx, base);
	// 828A53C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A53C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A53C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A53CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A53D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A53D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A53D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A53E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A53E0 size=64
    let mut pc: u32 = 0x828A53E0;
    'dispatch: loop {
        match pc {
            0x828A53E0 => {
    //   block [0x828A53E0..0x828A5420)
	// 828A53E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A53E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A53E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A53EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A53F0: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A53F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A53F8: 419A0014  beq cr6, 0x828a540c
	if ctx.cr[6].eq {
	pc = 0x828A540C; continue 'dispatch;
	}
	// 828A53FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5400: 48076479  bl 0x8291b878
	ctx.lr = 0x828A5404;
	sub_8291B878(ctx, base);
	// 828A5404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5408: 4BA1AE61  bl 0x822c0268
	ctx.lr = 0x828A540C;
	sub_822C0268(ctx, base);
	// 828A540C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A5410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A5414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A541C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5420 size=64
    let mut pc: u32 = 0x828A5420;
    'dispatch: loop {
        match pc {
            0x828A5420 => {
    //   block [0x828A5420..0x828A5460)
	// 828A5420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5428: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A542C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5430: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 828A5434: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A5438: 419A0014  beq cr6, 0x828a544c
	if ctx.cr[6].eq {
	pc = 0x828A544C; continue 'dispatch;
	}
	// 828A543C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5440: 480062E1  bl 0x828ab720
	ctx.lr = 0x828A5444;
	sub_828AB720(ctx, base);
	// 828A5444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5448: 4BA1AE21  bl 0x822c0268
	ctx.lr = 0x828A544C;
	sub_822C0268(ctx, base);
	// 828A544C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A5450: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A5454: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A545C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5460 size=72
    let mut pc: u32 = 0x828A5460;
    'dispatch: loop {
        match pc {
            0x828A5460 => {
    //   block [0x828A5460..0x828A54A8)
	// 828A5460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5468: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A546C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828A5470: 419A001C  beq cr6, 0x828a548c
	if ctx.cr[6].eq {
	pc = 0x828A548C; continue 'dispatch;
	}
	// 828A5474: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A5478: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A547C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828A5480: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A5484: 4BFFDE9D  bl 0x828a3320
	ctx.lr = 0x828A5488;
	sub_828A3320(ctx, base);
	// 828A5488: 48000010  b 0x828a5498
	pc = 0x828A5498; continue 'dispatch;
	// 828A548C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A5490: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 828A5494: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5498: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A549C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A54A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A54A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A54A8 size=72
    let mut pc: u32 = 0x828A54A8;
    'dispatch: loop {
        match pc {
            0x828A54A8 => {
    //   block [0x828A54A8..0x828A54F0)
	// 828A54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A54AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A54B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A54B4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828A54B8: 419A001C  beq cr6, 0x828a54d4
	if ctx.cr[6].eq {
	pc = 0x828A54D4; continue 'dispatch;
	}
	// 828A54BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A54C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A54C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828A54C8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A54CC: 4BFFDEDD  bl 0x828a33a8
	ctx.lr = 0x828A54D0;
	sub_828A33A8(ctx, base);
	// 828A54D0: 48000010  b 0x828a54e0
	pc = 0x828A54E0; continue 'dispatch;
	// 828A54D4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A54D8: 396B08B8  addi r11, r11, 0x8b8
	ctx.r[11].s64 = ctx.r[11].s64 + 2232;
	// 828A54DC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A54E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A54E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A54E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A54EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A54F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A54F0 size=72
    let mut pc: u32 = 0x828A54F0;
    'dispatch: loop {
        match pc {
            0x828A54F0 => {
    //   block [0x828A54F0..0x828A5538)
	// 828A54F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A54F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A54F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A54FC: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828A5500: 419A001C  beq cr6, 0x828a551c
	if ctx.cr[6].eq {
	pc = 0x828A551C; continue 'dispatch;
	}
	// 828A5504: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A5508: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A550C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828A5510: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A5514: 4BFFDF1D  bl 0x828a3430
	ctx.lr = 0x828A5518;
	sub_828A3430(ctx, base);
	// 828A5518: 48000010  b 0x828a5528
	pc = 0x828A5528; continue 'dispatch;
	// 828A551C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A5520: 396B0960  addi r11, r11, 0x960
	ctx.r[11].s64 = ctx.r[11].s64 + 2400;
	// 828A5524: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5528: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A552C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A5530: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5538 size=176
    let mut pc: u32 = 0x828A5538;
    'dispatch: loop {
        match pc {
            0x828A5538 => {
    //   block [0x828A5538..0x828A55E8)
	// 828A5538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A553C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A5544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A5548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A554C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5550: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A5554: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828A5558: 409A0044  bne cr6, 0x828a559c
	if !ctx.cr[6].eq {
	pc = 0x828A559C; continue 'dispatch;
	}
	// 828A555C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A5560: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5564: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828A5568: 4800C6F9  bl 0x828b1c60
	ctx.lr = 0x828A556C;
	sub_828B1C60(ctx, base);
	// 828A556C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5570: 41820024  beq 0x828a5594
	if ctx.cr[0].eq {
	pc = 0x828A5594; continue 'dispatch;
	}
	// 828A5574: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 828A5578: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828A557C: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 828A5580: F9630008  std r11, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828A5584: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 828A5588: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828A558C: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828A5590: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 828A5594: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828A5598: 4800001C  b 0x828a55b4
	pc = 0x828A55B4; continue 'dispatch;
	// 828A559C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A55A0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828A55A4: 409A0028  bne cr6, 0x828a55cc
	if !ctx.cr[6].eq {
	pc = 0x828A55CC; continue 'dispatch;
	}
	// 828A55A8: 4BA1ACC1  bl 0x822c0268
	ctx.lr = 0x828A55AC;
	sub_822C0268(ctx, base);
	// 828A55AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A55B0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A55B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A55B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A55BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A55C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A55C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A55C8: 4E800020  blr
	return;
	// 828A55CC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A55D0: 388B0A58  addi r4, r11, 0xa58
	ctx.r[4].s64 = ctx.r[11].s64 + 2648;
	// 828A55D4: 48902B25  bl 0x831a80f8
	ctx.lr = 0x828A55D8;
	sub_831A80F8(ctx, base);
	// 828A55D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A55DC: 4182FFD0  beq 0x828a55ac
	if ctx.cr[0].eq {
	pc = 0x828A55AC; continue 'dispatch;
	}
	// 828A55E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A55E4: 4BFFFFCC  b 0x828a55b0
	pc = 0x828A55B0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A55E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A55E8 size=300
    let mut pc: u32 = 0x828A55E8;
    'dispatch: loop {
        match pc {
            0x828A55E8 => {
    //   block [0x828A55E8..0x828A5714)
	// 828A55E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A55EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A55F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A55F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A55F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A55FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5600: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828A5604: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828A5608: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 828A560C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 828A5610: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5614: 4806B505  bl 0x82910b18
	ctx.lr = 0x828A5618;
	sub_82910B18(ctx, base);
	// 828A5618: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A561C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828A5620: 396B9E64  addi r11, r11, -0x619c
	ctx.r[11].s64 = ctx.r[11].s64 + -24988;
	// 828A5624: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A5628: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828A562C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5630: 39689E48  addi r11, r8, -0x61b8
	ctx.r[11].s64 = ctx.r[8].s64 + -25016;
	// 828A5634: 394A9CA4  addi r10, r10, -0x635c
	ctx.r[10].s64 = ctx.r[10].s64 + -25436;
	// 828A5638: 39299C90  addi r9, r9, -0x6370
	ctx.r[9].s64 = ctx.r[9].s64 + -25456;
	// 828A563C: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 828A5640: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A5644: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 828A5648: 913F0038  stw r9, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 828A564C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828A5650: 93DF0370  stw r30, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[30].u32 ) };
	// 828A5654: 394003D0  li r10, 0x3d0
	ctx.r[10].s64 = 976;
	// 828A5658: 93DF0374  stw r30, 0x374(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(884 as u32), ctx.r[30].u32 ) };
	// 828A565C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 828A5660: 93DF0378  stw r30, 0x378(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[30].u32 ) };
	// 828A5664: 392003F0  li r9, 0x3f0
	ctx.r[9].s64 = 1008;
	// 828A5668: 93DF037C  stw r30, 0x37c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(892 as u32), ctx.r[30].u32 ) };
	// 828A566C: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828A5670: 93DF0380  stw r30, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[30].u32 ) };
	// 828A5674: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5678: 93DF0384  stw r30, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[30].u32 ) };
	// 828A567C: 38889F00  addi r4, r8, -0x6100
	ctx.r[4].s64 = ctx.r[8].s64 + -24832;
	// 828A5680: 93DF0388  stw r30, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[30].u32 ) };
	// 828A5684: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 828A5688: 93DF038C  stw r30, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[30].u32 ) };
	// 828A568C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828A5690: 93DF0390  stw r30, 0x390(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), ctx.r[30].u32 ) };
	// 828A5694: 93DF0394  stw r30, 0x394(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), ctx.r[30].u32 ) };
	// 828A5698: 93DF0398  stw r30, 0x398(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), ctx.r[30].u32 ) };
	// 828A569C: 93DF039C  stw r30, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[30].u32 ) };
	// 828A56A0: 93DF03A0  stw r30, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[30].u32 ) };
	// 828A56A4: 93DF03A4  stw r30, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[30].u32 ) };
	// 828A56A8: 93DF03A8  stw r30, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[30].u32 ) };
	// 828A56AC: 93DF03AC  stw r30, 0x3ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(940 as u32), ctx.r[30].u32 ) };
	// 828A56B0: 93DF03B0  stw r30, 0x3b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(944 as u32), ctx.r[30].u32 ) };
	// 828A56B4: 93DF03B4  stw r30, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[30].u32 ) };
	// 828A56B8: 93DF03B8  stw r30, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[30].u32 ) };
	// 828A56BC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5718 size=76
    let mut pc: u32 = 0x828A5718;
    'dispatch: loop {
        match pc {
            0x828A5718 => {
    //   block [0x828A5718..0x828A5764)
	// 828A5718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A571C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5720: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A5724: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A5728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A572C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5730: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A5734: 4BFFF43D  bl 0x828a4b70
	ctx.lr = 0x828A5738;
	sub_828A4B70(ctx, base);
	// 828A5738: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A573C: 4182000C  beq 0x828a5748
	if ctx.cr[0].eq {
	pc = 0x828A5748; continue 'dispatch;
	}
	// 828A5740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5744: 4854CC95  bl 0x82df23d8
	ctx.lr = 0x828A5748;
	sub_82DF23D8(ctx, base);
	// 828A5748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A574C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A5754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5758: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A575C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A5760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A5768 size=388
    let mut pc: u32 = 0x828A5768;
    'dispatch: loop {
        match pc {
            0x828A5768 => {
    //   block [0x828A5768..0x828A58EC)
	// 828A5768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A576C: 489029FD  bl 0x831a8168
	ctx.lr = 0x828A5770;
	sub_831A8130(ctx, base);
	// 828A5770: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A5778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A577C: 3B9E00FC  addi r28, r30, 0xfc
	ctx.r[28].s64 = ctx.r[30].s64 + 252;
	// 828A5780: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A5784: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A5788: 485B4D99  bl 0x82e5a520
	ctx.lr = 0x828A578C;
	sub_82E5A520(ctx, base);
	// 828A578C: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5790: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A5794: 419A0024  beq cr6, 0x828a57b8
	if ctx.cr[6].eq {
	pc = 0x828A57B8; continue 'dispatch;
	}
	// 828A5798: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828A579C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A57A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A57A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A57A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A57AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A57B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A57B4: 4082FFE8  bne 0x828a579c
	if !ctx.cr[0].eq {
	pc = 0x828A579C; continue 'dispatch;
	}
	// 828A57B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A57BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A57C0: 419A0008  beq cr6, 0x828a57c8
	if ctx.cr[6].eq {
	pc = 0x828A57C8; continue 'dispatch;
	}
	// 828A57C4: 4BA1B0CD  bl 0x822c0890
	ctx.lr = 0x828A57C8;
	sub_822C0890(ctx, base);
	// 828A57C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A57CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A57D0: 388B9F64  addi r4, r11, -0x609c
	ctx.r[4].s64 = ctx.r[11].s64 + -24732;
	// 828A57D4: 4854E235  bl 0x82df3a08
	ctx.lr = 0x828A57D8;
	sub_82DF3A08(ctx, base);
	// 828A57D8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828A57DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A57E0: 3B8B7688  addi r28, r11, 0x7688
	ctx.r[28].s64 = ctx.r[11].s64 + 30344;
	// 828A57E4: 485B4EED  bl 0x82e5a6d0
	ctx.lr = 0x828A57E8;
	sub_82E5A6D0(ctx, base);
	// 828A57E8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828A57EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A57F0: 388B5E50  addi r4, r11, 0x5e50
	ctx.r[4].s64 = ctx.r[11].s64 + 24144;
	// 828A57F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A57F8: 4854E4A9  bl 0x82df3ca0
	ctx.lr = 0x828A57FC;
	sub_82DF3CA0(ctx, base);
	// 828A57FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A5800: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A5804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5808: 4854E4F1  bl 0x82df3cf8
	ctx.lr = 0x828A580C;
	sub_82DF3CF8(ctx, base);
	// 828A580C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A5810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5814: 4854E09D  bl 0x82df38b0
	ctx.lr = 0x828A5818;
	sub_82DF38B0(ctx, base);
	// 828A5818: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A581C: 4854DC0D  bl 0x82df3428
	ctx.lr = 0x828A5820;
	sub_82DF3428(ctx, base);
	// 828A5820: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A5824: 4854DC05  bl 0x82df3428
	ctx.lr = 0x828A5828;
	sub_82DF3428(ctx, base);
	// 828A5828: 807E0368  lwz r3, 0x368(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(872 as u32) ) } as u64;
	// 828A582C: 4BF44A7D  bl 0x827ea2a8
	ctx.lr = 0x828A5830;
	sub_827EA2A8(ctx, base);
	// 828A5830: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A5834: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A5838: 388B8FA0  addi r4, r11, -0x7060
	ctx.r[4].s64 = ctx.r[11].s64 + -28768;
	// 828A583C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5840: 4854E461  bl 0x82df3ca0
	ctx.lr = 0x828A5844;
	sub_82DF3CA0(ctx, base);
	// 828A5844: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A5848: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A584C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A5850: 4854E4A9  bl 0x82df3cf8
	ctx.lr = 0x828A5854;
	sub_82DF3CF8(ctx, base);
	// 828A5854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A5858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A585C: 4854E055  bl 0x82df38b0
	ctx.lr = 0x828A5860;
	sub_82DF38B0(ctx, base);
	// 828A5860: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A5864: 4854DBC5  bl 0x82df3428
	ctx.lr = 0x828A5868;
	sub_82DF3428(ctx, base);
	// 828A5868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A586C: 4854DBBD  bl 0x82df3428
	ctx.lr = 0x828A5870;
	sub_82DF3428(ctx, base);
	// 828A5870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5874: 4816DE0D  bl 0x82a13680
	ctx.lr = 0x828A5878;
	sub_82A13680(ctx, base);
	// 828A5878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A587C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A5880: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A5884: 388A8F80  addi r4, r10, -0x7080
	ctx.r[4].s64 = ctx.r[10].s64 + -28800;
	// 828A5888: C06B0008  lfs f3, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828A588C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828A5890: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A5894: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 828A5898: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 828A589C: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 828A58A0: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 828A58A4: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 828A58A8: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 828A58AC: 4890322D  bl 0x831a8ad8
	ctx.lr = 0x828A58B0;
	sub_831A8AD8(ctx, base);
	// 828A58B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A58B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A58B8: 4854E151  bl 0x82df3a08
	ctx.lr = 0x828A58BC;
	sub_82DF3A08(ctx, base);
	// 828A58BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A58C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A58C4: 4854DFED  bl 0x82df38b0
	ctx.lr = 0x828A58C8;
	sub_82DF38B0(ctx, base);
	// 828A58C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A58CC: 4854DB5D  bl 0x82df3428
	ctx.lr = 0x828A58D0;
	sub_82DF3428(ctx, base);
	// 828A58D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A58D4: 419A000C  beq cr6, 0x828a58e0
	if ctx.cr[6].eq {
	pc = 0x828A58E0; continue 'dispatch;
	}
	// 828A58D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A58DC: 4BA1AFB5  bl 0x822c0890
	ctx.lr = 0x828A58E0;
	sub_822C0890(ctx, base);
	// 828A58E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A58E4: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 828A58E8: 489028D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A58F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A58F0 size=76
    let mut pc: u32 = 0x828A58F0;
    'dispatch: loop {
        match pc {
            0x828A58F0 => {
    //   block [0x828A58F0..0x828A593C)
	// 828A58F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A58F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A58F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A58FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5900: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5904: 48063425  bl 0x82908d28
	ctx.lr = 0x828A5908;
	sub_82908D28(ctx, base);
	// 828A5908: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 828A590C: 4BFFF85D  bl 0x828a5168
	ctx.lr = 0x828A5910;
	sub_828A5168(ctx, base);
	// 828A5910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5914: 4806AA35  bl 0x82910348
	ctx.lr = 0x828A5918;
	sub_82910348(ctx, base);
	// 828A5918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A591C: 4806AA75  bl 0x82910390
	ctx.lr = 0x828A5920;
	sub_82910390(ctx, base);
	// 828A5920: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5924: 4BC6ACAD  bl 0x825105d0
	ctx.lr = 0x828A5928;
	sub_825105D0(ctx, base);
	// 828A5928: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A592C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A5930: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A5938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A5940 size=524
    let mut pc: u32 = 0x828A5940;
    'dispatch: loop {
        match pc {
            0x828A5940 => {
    //   block [0x828A5940..0x828A5B4C)
	// 828A5940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5944: 48902825  bl 0x831a8168
	ctx.lr = 0x828A5948;
	sub_831A8130(ctx, base);
	// 828A5948: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 828A594C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 828A5950: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828A5954: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5958: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A595C: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828A5960: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 828A5964: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 828A5968: 3BDC0010  addi r30, r28, 0x10
	ctx.r[30].s64 = ctx.r[28].s64 + 16;
	// 828A596C: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 828A5970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5974: 4816DD0D  bl 0x82a13680
	ctx.lr = 0x828A5978;
	sub_82A13680(ctx, base);
	// 828A5978: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A597C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A5980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5984: 48063CD5  bl 0x82909658
	ctx.lr = 0x828A5988;
	sub_82909658(ctx, base);
	// 828A5988: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828A598C: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5B50 size=112
    let mut pc: u32 = 0x828A5B50;
    'dispatch: loop {
        match pc {
            0x828A5B50 => {
    //   block [0x828A5B50..0x828A5BC0)
	// 828A5B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A5B58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A5B5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A5B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5B64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A5B68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5B6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828A5B70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A5B74: 4BFFDB45  bl 0x828a36b8
	ctx.lr = 0x828A5B78;
	sub_828A36B8(ctx, base);
	// 828A5B78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A5B7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A5B80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A5B84: 4BA1A47D  bl 0x822c0000
	ctx.lr = 0x828A5B88;
	sub_822C0000(ctx, base);
	// 828A5B88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A5B8C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A5B90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A5B94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A5B98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A5B9C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A5BA0: 419A0008  beq cr6, 0x828a5ba8
	if ctx.cr[6].eq {
	pc = 0x828A5BA8; continue 'dispatch;
	}
	// 828A5BA4: 4BA1ACED  bl 0x822c0890
	ctx.lr = 0x828A5BA8;
	sub_822C0890(ctx, base);
	// 828A5BA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5BAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A5BB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A5BB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A5BB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A5BBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5BC0 size=164
    let mut pc: u32 = 0x828A5BC0;
    'dispatch: loop {
        match pc {
            0x828A5BC0 => {
    //   block [0x828A5BC0..0x828A5C64)
	// 828A5BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5BC4: 489025A5  bl 0x831a8168
	ctx.lr = 0x828A5BC8;
	sub_831A8130(ctx, base);
	// 828A5BC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5BCC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A5BD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5BD4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 828A5BD8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A5BDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A5BE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5BE4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828A5BE8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828A5BEC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828A5BF0: 4854C7F9  bl 0x82df23e8
	ctx.lr = 0x828A5BF4;
	sub_82DF23E8(ctx, base);
	// 828A5BF4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828A5BF8: 41820028  beq 0x828a5c20
	if ctx.cr[0].eq {
	pc = 0x828A5C20; continue 'dispatch;
	}
	// 828A5BFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A5C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5C04: 4854DE05  bl 0x82df3a08
	ctx.lr = 0x828A5C08;
	sub_82DF3A08(ctx, base);
	// 828A5C08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A5C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A5C10: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828A5C14: 480AF815  bl 0x82955428
	ctx.lr = 0x828A5C18;
	sub_82955428(ctx, base);
	// 828A5C18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5C1C: 48000008  b 0x828a5c24
	pc = 0x828A5C24; continue 'dispatch;
	// 828A5C20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5C24: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5C28: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828A5C2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5C34: 4BFCE8CD  bl 0x82874500
	ctx.lr = 0x828A5C38;
	sub_82874500(ctx, base);
	// 828A5C38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5C3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5C40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5C44: 4BA1A3BD  bl 0x822c0000
	ctx.lr = 0x828A5C48;
	sub_822C0000(ctx, base);
	// 828A5C48: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A5C4C: 4182000C  beq 0x828a5c58
	if ctx.cr[0].eq {
	pc = 0x828A5C58; continue 'dispatch;
	}
	// 828A5C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A5C54: 4854D7D5  bl 0x82df3428
	ctx.lr = 0x828A5C58;
	sub_82DF3428(ctx, base);
	// 828A5C58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A5C5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A5C60: 48902558  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A5C68 size=160
    let mut pc: u32 = 0x828A5C68;
    'dispatch: loop {
        match pc {
            0x828A5C68 => {
    //   block [0x828A5C68..0x828A5D08)
	// 828A5C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5C6C: 489024F1  bl 0x831a815c
	ctx.lr = 0x828A5C70;
	sub_831A8130(ctx, base);
	// 828A5C70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5C74: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5C78: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A5C7C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A5C80: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A5C84: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828A5C88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5C8C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828A5C90: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828A5C94: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828A5C98: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828A5C9C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 828A5CA0: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 828A5CA4: 4854C745  bl 0x82df23e8
	ctx.lr = 0x828A5CA8;
	sub_82DF23E8(ctx, base);
	// 828A5CA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5CAC: 41820028  beq 0x828a5cd4
	if ctx.cr[0].eq {
	pc = 0x828A5CD4; continue 'dispatch;
	}
	// 828A5CB0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 828A5CB4: C05C0000  lfs f2, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828A5CB8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 828A5CBC: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A5CC0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5CC4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5CC8: 482ACE89  bl 0x82b52b50
	ctx.lr = 0x828A5CCC;
	sub_82B52B50(ctx, base);
	// 828A5CCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5CD0: 48000008  b 0x828a5cd8
	pc = 0x828A5CD8; continue 'dispatch;
	// 828A5CD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5CD8: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5CDC: 3BD90004  addi r30, r25, 4
	ctx.r[30].s64 = ctx.r[25].s64 + 4;
	// 828A5CE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5CE8: 4BFFDA99  bl 0x828a3780
	ctx.lr = 0x828A5CEC;
	sub_828A3780(ctx, base);
	// 828A5CEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5CF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5CF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5CF8: 4BA1A309  bl 0x822c0000
	ctx.lr = 0x828A5CFC;
	sub_822C0000(ctx, base);
	// 828A5CFC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A5D00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A5D04: 489024A8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5D08 size=128
    let mut pc: u32 = 0x828A5D08;
    'dispatch: loop {
        match pc {
            0x828A5D08 => {
    //   block [0x828A5D08..0x828A5D88)
	// 828A5D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5D0C: 48902461  bl 0x831a816c
	ctx.lr = 0x828A5D10;
	sub_831A8130(ctx, base);
	// 828A5D10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5D14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5D18: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5D1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A5D20: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A5D24: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5D28: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828A5D2C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828A5D30: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828A5D34: 4854C6B5  bl 0x82df23e8
	ctx.lr = 0x828A5D38;
	sub_82DF23E8(ctx, base);
	// 828A5D38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5D3C: 41820018  beq 0x828a5d54
	if ctx.cr[0].eq {
	pc = 0x828A5D54; continue 'dispatch;
	}
	// 828A5D40: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5D44: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5D48: 482ACED9  bl 0x82b52c20
	ctx.lr = 0x828A5D4C;
	sub_82B52C20(ctx, base);
	// 828A5D4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5D50: 48000008  b 0x828a5d58
	pc = 0x828A5D58; continue 'dispatch;
	// 828A5D54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5D58: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5D5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A5D60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5D68: 4BFFDAE1  bl 0x828a3848
	ctx.lr = 0x828A5D6C;
	sub_828A3848(ctx, base);
	// 828A5D6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5D70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5D74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5D78: 4BA1A289  bl 0x822c0000
	ctx.lr = 0x828A5D7C;
	sub_822C0000(ctx, base);
	// 828A5D7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A5D80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5D84: 48902438  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5D88 size=120
    let mut pc: u32 = 0x828A5D88;
    'dispatch: loop {
        match pc {
            0x828A5D88 => {
    //   block [0x828A5D88..0x828A5E00)
	// 828A5D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5D8C: 489023E1  bl 0x831a816c
	ctx.lr = 0x828A5D90;
	sub_831A8130(ctx, base);
	// 828A5D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5D94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5D98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5D9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A5DA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5DA4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828A5DA8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828A5DAC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828A5DB0: 4854C639  bl 0x82df23e8
	ctx.lr = 0x828A5DB4;
	sub_82DF23E8(ctx, base);
	// 828A5DB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5DB8: 41820014  beq 0x828a5dcc
	if ctx.cr[0].eq {
	pc = 0x828A5DCC; continue 'dispatch;
	}
	// 828A5DBC: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5DC0: 482ACEA1  bl 0x82b52c60
	ctx.lr = 0x828A5DC4;
	sub_82B52C60(ctx, base);
	// 828A5DC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5DC8: 48000008  b 0x828a5dd0
	pc = 0x828A5DD0; continue 'dispatch;
	// 828A5DCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5DD0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5DD4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A5DD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5DDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5DE0: 4BFFDB31  bl 0x828a3910
	ctx.lr = 0x828A5DE4;
	sub_828A3910(ctx, base);
	// 828A5DE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5DE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5DEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5DF0: 4BA1A211  bl 0x822c0000
	ctx.lr = 0x828A5DF4;
	sub_822C0000(ctx, base);
	// 828A5DF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A5DF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5DFC: 489023C0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5E00 size=120
    let mut pc: u32 = 0x828A5E00;
    'dispatch: loop {
        match pc {
            0x828A5E00 => {
    //   block [0x828A5E00..0x828A5E78)
	// 828A5E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5E04: 48902369  bl 0x831a816c
	ctx.lr = 0x828A5E08;
	sub_831A8130(ctx, base);
	// 828A5E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5E0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5E10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5E14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A5E18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5E1C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828A5E20: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828A5E24: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828A5E28: 4854C5C1  bl 0x82df23e8
	ctx.lr = 0x828A5E2C;
	sub_82DF23E8(ctx, base);
	// 828A5E2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5E30: 41820014  beq 0x828a5e44
	if ctx.cr[0].eq {
	pc = 0x828A5E44; continue 'dispatch;
	}
	// 828A5E34: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A5E38: 482ACD99  bl 0x82b52bd0
	ctx.lr = 0x828A5E3C;
	sub_82B52BD0(ctx, base);
	// 828A5E3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5E40: 48000008  b 0x828a5e48
	pc = 0x828A5E48; continue 'dispatch;
	// 828A5E44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5E48: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5E4C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A5E50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5E54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5E58: 4BFFDB81  bl 0x828a39d8
	ctx.lr = 0x828A5E5C;
	sub_828A39D8(ctx, base);
	// 828A5E5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5E60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5E68: 4BA1A199  bl 0x822c0000
	ctx.lr = 0x828A5E6C;
	sub_822C0000(ctx, base);
	// 828A5E6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A5E70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5E74: 48902348  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5E78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5E78 size=112
    let mut pc: u32 = 0x828A5E78;
    'dispatch: loop {
        match pc {
            0x828A5E78 => {
    //   block [0x828A5E78..0x828A5EE8)
	// 828A5E78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5E7C: 489022F1  bl 0x831a816c
	ctx.lr = 0x828A5E80;
	sub_831A8130(ctx, base);
	// 828A5E80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5E84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5E88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5E8C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5E90: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A5E94: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A5E98: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A5E9C: 4854C54D  bl 0x82df23e8
	ctx.lr = 0x828A5EA0;
	sub_82DF23E8(ctx, base);
	// 828A5EA0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5EA4: 41820010  beq 0x828a5eb4
	if ctx.cr[0].eq {
	pc = 0x828A5EB4; continue 'dispatch;
	}
	// 828A5EA8: 48007899  bl 0x828ad740
	ctx.lr = 0x828A5EAC;
	sub_828AD740(ctx, base);
	// 828A5EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5EB0: 48000008  b 0x828a5eb8
	pc = 0x828A5EB8; continue 'dispatch;
	// 828A5EB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5EB8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5EBC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A5EC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5EC8: 4BFFDBD9  bl 0x828a3aa0
	ctx.lr = 0x828A5ECC;
	sub_828A3AA0(ctx, base);
	// 828A5ECC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5ED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5ED8: 4BA1A129  bl 0x822c0000
	ctx.lr = 0x828A5EDC;
	sub_822C0000(ctx, base);
	// 828A5EDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A5EE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5EE4: 489022D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5EE8 size=112
    let mut pc: u32 = 0x828A5EE8;
    'dispatch: loop {
        match pc {
            0x828A5EE8 => {
    //   block [0x828A5EE8..0x828A5F58)
	// 828A5EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5EEC: 48902281  bl 0x831a816c
	ctx.lr = 0x828A5EF0;
	sub_831A8130(ctx, base);
	// 828A5EF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5EF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5EF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5EFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5F00: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A5F04: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A5F08: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828A5F0C: 4854C4DD  bl 0x82df23e8
	ctx.lr = 0x828A5F10;
	sub_82DF23E8(ctx, base);
	// 828A5F10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5F14: 41820010  beq 0x828a5f24
	if ctx.cr[0].eq {
	pc = 0x828A5F24; continue 'dispatch;
	}
	// 828A5F18: 4800B271  bl 0x828b1188
	ctx.lr = 0x828A5F1C;
	sub_828B1188(ctx, base);
	// 828A5F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5F20: 48000008  b 0x828a5f28
	pc = 0x828A5F28; continue 'dispatch;
	// 828A5F24: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5F28: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5F2C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A5F30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5F34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5F38: 4BFFDC31  bl 0x828a3b68
	ctx.lr = 0x828A5F3C;
	sub_828A3B68(ctx, base);
	// 828A5F3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5F40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5F48: 4BA1A0B9  bl 0x822c0000
	ctx.lr = 0x828A5F4C;
	sub_822C0000(ctx, base);
	// 828A5F4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A5F50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5F54: 48902268  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5F58 size=112
    let mut pc: u32 = 0x828A5F58;
    'dispatch: loop {
        match pc {
            0x828A5F58 => {
    //   block [0x828A5F58..0x828A5FC8)
	// 828A5F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5F5C: 48902211  bl 0x831a816c
	ctx.lr = 0x828A5F60;
	sub_831A8130(ctx, base);
	// 828A5F60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5F64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5F68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5F6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5F70: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A5F74: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A5F78: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A5F7C: 4854C46D  bl 0x82df23e8
	ctx.lr = 0x828A5F80;
	sub_82DF23E8(ctx, base);
	// 828A5F80: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5F84: 41820010  beq 0x828a5f94
	if ctx.cr[0].eq {
	pc = 0x828A5F94; continue 'dispatch;
	}
	// 828A5F88: 4800A009  bl 0x828aff90
	ctx.lr = 0x828A5F8C;
	sub_828AFF90(ctx, base);
	// 828A5F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A5F90: 48000008  b 0x828a5f98
	pc = 0x828A5F98; continue 'dispatch;
	// 828A5F94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A5F98: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A5F9C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A5FA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5FA8: 4BFFDC89  bl 0x828a3c30
	ctx.lr = 0x828A5FAC;
	sub_828A3C30(ctx, base);
	// 828A5FAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A5FB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A5FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A5FB8: 4BA1A049  bl 0x822c0000
	ctx.lr = 0x828A5FBC;
	sub_822C0000(ctx, base);
	// 828A5FBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A5FC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A5FC4: 489021F8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A5FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A5FC8 size=112
    let mut pc: u32 = 0x828A5FC8;
    'dispatch: loop {
        match pc {
            0x828A5FC8 => {
    //   block [0x828A5FC8..0x828A6038)
	// 828A5FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A5FCC: 489021A1  bl 0x831a816c
	ctx.lr = 0x828A5FD0;
	sub_831A8130(ctx, base);
	// 828A5FD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A5FD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A5FD8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A5FDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A5FE0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A5FE4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A5FE8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A5FEC: 4854C3FD  bl 0x82df23e8
	ctx.lr = 0x828A5FF0;
	sub_82DF23E8(ctx, base);
	// 828A5FF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A5FF4: 41820010  beq 0x828a6004
	if ctx.cr[0].eq {
	pc = 0x828A6004; continue 'dispatch;
	}
	// 828A5FF8: 48009DD9  bl 0x828afdd0
	ctx.lr = 0x828A5FFC;
	sub_828AFDD0(ctx, base);
	// 828A5FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6000: 48000008  b 0x828a6008
	pc = 0x828A6008; continue 'dispatch;
	// 828A6004: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6008: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A600C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6018: 4BFFDCE1  bl 0x828a3cf8
	ctx.lr = 0x828A601C;
	sub_828A3CF8(ctx, base);
	// 828A601C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6028: 4BA19FD9  bl 0x822c0000
	ctx.lr = 0x828A602C;
	sub_822C0000(ctx, base);
	// 828A602C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6034: 48902188  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6038 size=112
    let mut pc: u32 = 0x828A6038;
    'dispatch: loop {
        match pc {
            0x828A6038 => {
    //   block [0x828A6038..0x828A60A8)
	// 828A6038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A603C: 48902131  bl 0x831a816c
	ctx.lr = 0x828A6040;
	sub_831A8130(ctx, base);
	// 828A6040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6048: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A604C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6050: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6054: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6058: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828A605C: 4854C38D  bl 0x82df23e8
	ctx.lr = 0x828A6060;
	sub_82DF23E8(ctx, base);
	// 828A6060: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6064: 41820010  beq 0x828a6074
	if ctx.cr[0].eq {
	pc = 0x828A6074; continue 'dispatch;
	}
	// 828A6068: 480077C1  bl 0x828ad828
	ctx.lr = 0x828A606C;
	sub_828AD828(ctx, base);
	// 828A606C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6070: 48000008  b 0x828a6078
	pc = 0x828A6078; continue 'dispatch;
	// 828A6074: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6078: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A607C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6088: 4BFFDD39  bl 0x828a3dc0
	ctx.lr = 0x828A608C;
	sub_828A3DC0(ctx, base);
	// 828A608C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6098: 4BA19F69  bl 0x822c0000
	ctx.lr = 0x828A609C;
	sub_822C0000(ctx, base);
	// 828A609C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A60A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A60A4: 48902118  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A60A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A60A8 size=112
    let mut pc: u32 = 0x828A60A8;
    'dispatch: loop {
        match pc {
            0x828A60A8 => {
    //   block [0x828A60A8..0x828A6118)
	// 828A60A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A60AC: 489020C1  bl 0x831a816c
	ctx.lr = 0x828A60B0;
	sub_831A8130(ctx, base);
	// 828A60B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A60B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A60B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A60BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A60C0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A60C4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A60C8: 38600074  li r3, 0x74
	ctx.r[3].s64 = 116;
	// 828A60CC: 4854C31D  bl 0x82df23e8
	ctx.lr = 0x828A60D0;
	sub_82DF23E8(ctx, base);
	// 828A60D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A60D4: 41820010  beq 0x828a60e4
	if ctx.cr[0].eq {
	pc = 0x828A60E4; continue 'dispatch;
	}
	// 828A60D8: 4800A569  bl 0x828b0640
	ctx.lr = 0x828A60DC;
	sub_828B0640(ctx, base);
	// 828A60DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A60E0: 48000008  b 0x828a60e8
	pc = 0x828A60E8; continue 'dispatch;
	// 828A60E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A60E8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A60EC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A60F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A60F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A60F8: 4BFFDD91  bl 0x828a3e88
	ctx.lr = 0x828A60FC;
	sub_828A3E88(ctx, base);
	// 828A60FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6104: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6108: 4BA19EF9  bl 0x822c0000
	ctx.lr = 0x828A610C;
	sub_822C0000(ctx, base);
	// 828A610C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6110: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6114: 489020A8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6118 size=112
    let mut pc: u32 = 0x828A6118;
    'dispatch: loop {
        match pc {
            0x828A6118 => {
    //   block [0x828A6118..0x828A6188)
	// 828A6118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A611C: 48902051  bl 0x831a816c
	ctx.lr = 0x828A6120;
	sub_831A8130(ctx, base);
	// 828A6120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6124: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6128: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A612C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6130: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6134: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6138: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828A613C: 4854C2AD  bl 0x82df23e8
	ctx.lr = 0x828A6140;
	sub_82DF23E8(ctx, base);
	// 828A6140: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6144: 41820010  beq 0x828a6154
	if ctx.cr[0].eq {
	pc = 0x828A6154; continue 'dispatch;
	}
	// 828A6148: 480078D9  bl 0x828ada20
	ctx.lr = 0x828A614C;
	sub_828ADA20(ctx, base);
	// 828A614C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6150: 48000008  b 0x828a6158
	pc = 0x828A6158; continue 'dispatch;
	// 828A6154: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6158: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A615C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6168: 4BFFDDE9  bl 0x828a3f50
	ctx.lr = 0x828A616C;
	sub_828A3F50(ctx, base);
	// 828A616C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6174: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6178: 4BA19E89  bl 0x822c0000
	ctx.lr = 0x828A617C;
	sub_822C0000(ctx, base);
	// 828A617C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6180: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6184: 48902038  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6188 size=112
    let mut pc: u32 = 0x828A6188;
    'dispatch: loop {
        match pc {
            0x828A6188 => {
    //   block [0x828A6188..0x828A61F8)
	// 828A6188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A618C: 48901FE1  bl 0x831a816c
	ctx.lr = 0x828A6190;
	sub_831A8130(ctx, base);
	// 828A6190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6194: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6198: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A619C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A61A0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A61A4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A61A8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A61AC: 4854C23D  bl 0x82df23e8
	ctx.lr = 0x828A61B0;
	sub_82DF23E8(ctx, base);
	// 828A61B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A61B4: 41820010  beq 0x828a61c4
	if ctx.cr[0].eq {
	pc = 0x828A61C4; continue 'dispatch;
	}
	// 828A61B8: 480078C9  bl 0x828ada80
	ctx.lr = 0x828A61BC;
	sub_828ADA80(ctx, base);
	// 828A61BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A61C0: 48000008  b 0x828a61c8
	pc = 0x828A61C8; continue 'dispatch;
	// 828A61C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A61C8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A61CC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A61D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A61D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A61D8: 4BFFDE41  bl 0x828a4018
	ctx.lr = 0x828A61DC;
	sub_828A4018(ctx, base);
	// 828A61DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A61E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A61E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A61E8: 4BA19E19  bl 0x822c0000
	ctx.lr = 0x828A61EC;
	sub_822C0000(ctx, base);
	// 828A61EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A61F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A61F4: 48901FC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A61F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A61F8 size=112
    let mut pc: u32 = 0x828A61F8;
    'dispatch: loop {
        match pc {
            0x828A61F8 => {
    //   block [0x828A61F8..0x828A6268)
	// 828A61F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A61FC: 48901F71  bl 0x831a816c
	ctx.lr = 0x828A6200;
	sub_831A8130(ctx, base);
	// 828A6200: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6204: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6208: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A620C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6210: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6214: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6218: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A621C: 4854C1CD  bl 0x82df23e8
	ctx.lr = 0x828A6220;
	sub_82DF23E8(ctx, base);
	// 828A6220: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6224: 41820010  beq 0x828a6234
	if ctx.cr[0].eq {
	pc = 0x828A6234; continue 'dispatch;
	}
	// 828A6228: 480078E1  bl 0x828adb08
	ctx.lr = 0x828A622C;
	sub_828ADB08(ctx, base);
	// 828A622C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6230: 48000008  b 0x828a6238
	pc = 0x828A6238; continue 'dispatch;
	// 828A6234: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6238: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A623C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6248: 4BFFDE99  bl 0x828a40e0
	ctx.lr = 0x828A624C;
	sub_828A40E0(ctx, base);
	// 828A624C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6250: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6258: 4BA19DA9  bl 0x822c0000
	ctx.lr = 0x828A625C;
	sub_822C0000(ctx, base);
	// 828A625C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6260: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6264: 48901F58  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6268 size=112
    let mut pc: u32 = 0x828A6268;
    'dispatch: loop {
        match pc {
            0x828A6268 => {
    //   block [0x828A6268..0x828A62D8)
	// 828A6268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A626C: 48901F01  bl 0x831a816c
	ctx.lr = 0x828A6270;
	sub_831A8130(ctx, base);
	// 828A6270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6274: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6278: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A627C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6280: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6284: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6288: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 828A628C: 4854C15D  bl 0x82df23e8
	ctx.lr = 0x828A6290;
	sub_82DF23E8(ctx, base);
	// 828A6290: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6294: 41820010  beq 0x828a62a4
	if ctx.cr[0].eq {
	pc = 0x828A62A4; continue 'dispatch;
	}
	// 828A6298: 480078D1  bl 0x828adb68
	ctx.lr = 0x828A629C;
	sub_828ADB68(ctx, base);
	// 828A629C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A62A0: 48000008  b 0x828a62a8
	pc = 0x828A62A8; continue 'dispatch;
	// 828A62A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A62A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A62AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A62B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A62B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A62B8: 4BFFDEF1  bl 0x828a41a8
	ctx.lr = 0x828A62BC;
	sub_828A41A8(ctx, base);
	// 828A62BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A62C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A62C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A62C8: 4BA19D39  bl 0x822c0000
	ctx.lr = 0x828A62CC;
	sub_822C0000(ctx, base);
	// 828A62CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A62D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A62D4: 48901EE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A62D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A62D8 size=112
    let mut pc: u32 = 0x828A62D8;
    'dispatch: loop {
        match pc {
            0x828A62D8 => {
    //   block [0x828A62D8..0x828A6348)
	// 828A62D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A62DC: 48901E91  bl 0x831a816c
	ctx.lr = 0x828A62E0;
	sub_831A8130(ctx, base);
	// 828A62E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A62E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A62E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A62EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A62F0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A62F4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A62F8: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 828A62FC: 4854C0ED  bl 0x82df23e8
	ctx.lr = 0x828A6300;
	sub_82DF23E8(ctx, base);
	// 828A6300: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6304: 41820010  beq 0x828a6314
	if ctx.cr[0].eq {
	pc = 0x828A6314; continue 'dispatch;
	}
	// 828A6308: 48008289  bl 0x828ae590
	ctx.lr = 0x828A630C;
	sub_828AE590(ctx, base);
	// 828A630C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6310: 48000008  b 0x828a6318
	pc = 0x828A6318; continue 'dispatch;
	// 828A6314: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6318: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A631C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6328: 4BFFDF49  bl 0x828a4270
	ctx.lr = 0x828A632C;
	sub_828A4270(ctx, base);
	// 828A632C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6330: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6338: 4BA19CC9  bl 0x822c0000
	ctx.lr = 0x828A633C;
	sub_822C0000(ctx, base);
	// 828A633C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6340: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6344: 48901E78  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6348 size=112
    let mut pc: u32 = 0x828A6348;
    'dispatch: loop {
        match pc {
            0x828A6348 => {
    //   block [0x828A6348..0x828A63B8)
	// 828A6348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A634C: 48901E21  bl 0x831a816c
	ctx.lr = 0x828A6350;
	sub_831A8130(ctx, base);
	// 828A6350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6354: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6358: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A635C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6360: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6364: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6368: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A636C: 4854C07D  bl 0x82df23e8
	ctx.lr = 0x828A6370;
	sub_82DF23E8(ctx, base);
	// 828A6370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6374: 41820010  beq 0x828a6384
	if ctx.cr[0].eq {
	pc = 0x828A6384; continue 'dispatch;
	}
	// 828A6378: 48007911  bl 0x828adc88
	ctx.lr = 0x828A637C;
	sub_828ADC88(ctx, base);
	// 828A637C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6380: 48000008  b 0x828a6388
	pc = 0x828A6388; continue 'dispatch;
	// 828A6384: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6388: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A638C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6390: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6394: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6398: 4BFFDFA1  bl 0x828a4338
	ctx.lr = 0x828A639C;
	sub_828A4338(ctx, base);
	// 828A639C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A63A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A63A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A63A8: 4BA19C59  bl 0x822c0000
	ctx.lr = 0x828A63AC;
	sub_822C0000(ctx, base);
	// 828A63AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A63B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A63B4: 48901E08  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A63B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A63B8 size=112
    let mut pc: u32 = 0x828A63B8;
    'dispatch: loop {
        match pc {
            0x828A63B8 => {
    //   block [0x828A63B8..0x828A6428)
	// 828A63B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A63BC: 48901DB1  bl 0x831a816c
	ctx.lr = 0x828A63C0;
	sub_831A8130(ctx, base);
	// 828A63C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A63C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A63C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A63CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A63D0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A63D4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A63D8: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828A63DC: 4854C00D  bl 0x82df23e8
	ctx.lr = 0x828A63E0;
	sub_82DF23E8(ctx, base);
	// 828A63E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A63E4: 41820010  beq 0x828a63f4
	if ctx.cr[0].eq {
	pc = 0x828A63F4; continue 'dispatch;
	}
	// 828A63E8: 480079C1  bl 0x828adda8
	ctx.lr = 0x828A63EC;
	sub_828ADDA8(ctx, base);
	// 828A63EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A63F0: 48000008  b 0x828a63f8
	pc = 0x828A63F8; continue 'dispatch;
	// 828A63F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A63F8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A63FC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6400: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6408: 4BFFDFF9  bl 0x828a4400
	ctx.lr = 0x828A640C;
	sub_828A4400(ctx, base);
	// 828A640C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6418: 4BA19BE9  bl 0x822c0000
	ctx.lr = 0x828A641C;
	sub_822C0000(ctx, base);
	// 828A641C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6424: 48901D98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6428 size=112
    let mut pc: u32 = 0x828A6428;
    'dispatch: loop {
        match pc {
            0x828A6428 => {
    //   block [0x828A6428..0x828A6498)
	// 828A6428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A642C: 48901D41  bl 0x831a816c
	ctx.lr = 0x828A6430;
	sub_831A8130(ctx, base);
	// 828A6430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6434: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6438: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A643C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6440: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6444: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6448: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A644C: 4854BF9D  bl 0x82df23e8
	ctx.lr = 0x828A6450;
	sub_82DF23E8(ctx, base);
	// 828A6450: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6454: 41820010  beq 0x828a6464
	if ctx.cr[0].eq {
	pc = 0x828A6464; continue 'dispatch;
	}
	// 828A6458: 48009AD9  bl 0x828aff30
	ctx.lr = 0x828A645C;
	sub_828AFF30(ctx, base);
	// 828A645C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6460: 48000008  b 0x828a6468
	pc = 0x828A6468; continue 'dispatch;
	// 828A6464: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6468: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A646C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6478: 4BFFE051  bl 0x828a44c8
	ctx.lr = 0x828A647C;
	sub_828A44C8(ctx, base);
	// 828A647C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6484: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6488: 4BA19B79  bl 0x822c0000
	ctx.lr = 0x828A648C;
	sub_822C0000(ctx, base);
	// 828A648C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6494: 48901D28  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6498 size=112
    let mut pc: u32 = 0x828A6498;
    'dispatch: loop {
        match pc {
            0x828A6498 => {
    //   block [0x828A6498..0x828A6508)
	// 828A6498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A649C: 48901CD1  bl 0x831a816c
	ctx.lr = 0x828A64A0;
	sub_831A8130(ctx, base);
	// 828A64A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A64A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A64A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A64AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A64B0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A64B4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A64B8: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A64BC: 4854BF2D  bl 0x82df23e8
	ctx.lr = 0x828A64C0;
	sub_82DF23E8(ctx, base);
	// 828A64C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A64C4: 41820010  beq 0x828a64d4
	if ctx.cr[0].eq {
	pc = 0x828A64D4; continue 'dispatch;
	}
	// 828A64C8: 480099A9  bl 0x828afe70
	ctx.lr = 0x828A64CC;
	sub_828AFE70(ctx, base);
	// 828A64CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A64D0: 48000008  b 0x828a64d8
	pc = 0x828A64D8; continue 'dispatch;
	// 828A64D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A64D8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A64DC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A64E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A64E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A64E8: 4BFFE0A9  bl 0x828a4590
	ctx.lr = 0x828A64EC;
	sub_828A4590(ctx, base);
	// 828A64EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A64F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A64F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A64F8: 4BA19B09  bl 0x822c0000
	ctx.lr = 0x828A64FC;
	sub_822C0000(ctx, base);
	// 828A64FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6500: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6504: 48901CB8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6508 size=112
    let mut pc: u32 = 0x828A6508;
    'dispatch: loop {
        match pc {
            0x828A6508 => {
    //   block [0x828A6508..0x828A6578)
	// 828A6508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A650C: 48901C61  bl 0x831a816c
	ctx.lr = 0x828A6510;
	sub_831A8130(ctx, base);
	// 828A6510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6514: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6518: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A651C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6520: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6524: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6528: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A652C: 4854BEBD  bl 0x82df23e8
	ctx.lr = 0x828A6530;
	sub_82DF23E8(ctx, base);
	// 828A6530: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6534: 41820010  beq 0x828a6544
	if ctx.cr[0].eq {
	pc = 0x828A6544; continue 'dispatch;
	}
	// 828A6538: 4800A049  bl 0x828b0580
	ctx.lr = 0x828A653C;
	sub_828B0580(ctx, base);
	// 828A653C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6540: 48000008  b 0x828a6548
	pc = 0x828A6548; continue 'dispatch;
	// 828A6544: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6548: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A654C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6558: 4BFFE101  bl 0x828a4658
	ctx.lr = 0x828A655C;
	sub_828A4658(ctx, base);
	// 828A655C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6568: 4BA19A99  bl 0x822c0000
	ctx.lr = 0x828A656C;
	sub_822C0000(ctx, base);
	// 828A656C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6570: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6574: 48901C48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6578 size=112
    let mut pc: u32 = 0x828A6578;
    'dispatch: loop {
        match pc {
            0x828A6578 => {
    //   block [0x828A6578..0x828A65E8)
	// 828A6578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A657C: 48901BF1  bl 0x831a816c
	ctx.lr = 0x828A6580;
	sub_831A8130(ctx, base);
	// 828A6580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6584: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6588: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A658C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6590: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6594: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6598: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 828A659C: 4854BE4D  bl 0x82df23e8
	ctx.lr = 0x828A65A0;
	sub_82DF23E8(ctx, base);
	// 828A65A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A65A4: 41820010  beq 0x828a65b4
	if ctx.cr[0].eq {
	pc = 0x828A65B4; continue 'dispatch;
	}
	// 828A65A8: 48007741  bl 0x828adce8
	ctx.lr = 0x828A65AC;
	sub_828ADCE8(ctx, base);
	// 828A65AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A65B0: 48000008  b 0x828a65b8
	pc = 0x828A65B8; continue 'dispatch;
	// 828A65B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A65B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A65BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A65C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A65C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A65C8: 4BFFE159  bl 0x828a4720
	ctx.lr = 0x828A65CC;
	sub_828A4720(ctx, base);
	// 828A65CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A65D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A65D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A65D8: 4BA19A29  bl 0x822c0000
	ctx.lr = 0x828A65DC;
	sub_822C0000(ctx, base);
	// 828A65DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A65E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A65E4: 48901BD8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A65E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A65E8 size=112
    let mut pc: u32 = 0x828A65E8;
    'dispatch: loop {
        match pc {
            0x828A65E8 => {
    //   block [0x828A65E8..0x828A6658)
	// 828A65E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A65EC: 48901B81  bl 0x831a816c
	ctx.lr = 0x828A65F0;
	sub_831A8130(ctx, base);
	// 828A65F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A65F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A65F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A65FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6600: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6604: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6608: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828A660C: 4854BDDD  bl 0x82df23e8
	ctx.lr = 0x828A6610;
	sub_82DF23E8(ctx, base);
	// 828A6610: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6614: 41820010  beq 0x828a6624
	if ctx.cr[0].eq {
	pc = 0x828A6624; continue 'dispatch;
	}
	// 828A6618: 48007731  bl 0x828add48
	ctx.lr = 0x828A661C;
	sub_828ADD48(ctx, base);
	// 828A661C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6620: 48000008  b 0x828a6628
	pc = 0x828A6628; continue 'dispatch;
	// 828A6624: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6628: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A662C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A6630: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6638: 4BFFE1B1  bl 0x828a47e8
	ctx.lr = 0x828A663C;
	sub_828A47E8(ctx, base);
	// 828A663C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A6640: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6644: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6648: 4BA199B9  bl 0x822c0000
	ctx.lr = 0x828A664C;
	sub_822C0000(ctx, base);
	// 828A664C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A6650: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6654: 48901B68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A6658 size=112
    let mut pc: u32 = 0x828A6658;
    'dispatch: loop {
        match pc {
            0x828A6658 => {
    //   block [0x828A6658..0x828A66C8)
	// 828A6658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A665C: 48901B11  bl 0x831a816c
	ctx.lr = 0x828A6660;
	sub_831A8130(ctx, base);
	// 828A6660: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6664: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6668: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A666C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6670: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828A6674: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828A6678: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828A667C: 4854BD6D  bl 0x82df23e8
	ctx.lr = 0x828A6680;
	sub_82DF23E8(ctx, base);
	// 828A6680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6684: 41820010  beq 0x828a6694
	if ctx.cr[0].eq {
	pc = 0x828A6694; continue 'dispatch;
	}
	// 828A6688: 4807E839  bl 0x82924ec0
	ctx.lr = 0x828A668C;
	sub_82924EC0(ctx, base);
	// 828A668C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6690: 48000008  b 0x828a6698
	pc = 0x828A6698; continue 'dispatch;
	// 828A6694: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A6698: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A669C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828A66A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A66A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A66A8: 4BFFE209  bl 0x828a48b0
	ctx.lr = 0x828A66AC;
	sub_828A48B0(ctx, base);
	// 828A66AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A66B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A66B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A66B8: 4BA19949  bl 0x822c0000
	ctx.lr = 0x828A66BC;
	sub_822C0000(ctx, base);
	// 828A66BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A66C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A66C4: 48901AF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A66C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A66C8 size=140
    let mut pc: u32 = 0x828A66C8;
    'dispatch: loop {
        match pc {
            0x828A66C8 => {
    //   block [0x828A66C8..0x828A6754)
	// 828A66C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A66CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A66D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A66D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A66D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A66DC: F8810090  std r4, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[4].u64 ) };
	// 828A66E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A66E4: F8A10098  std r5, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[5].u64 ) };
	// 828A66E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A66EC: F8C100A0  std r6, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[6].u64 ) };
	// 828A66F0: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 828A66F4: F8E100A8  std r7, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[7].u64 ) };
	// 828A66F8: 4BF28AE1  bl 0x827cf1d8
	ctx.lr = 0x828A66FC;
	sub_827CF1D8(ctx, base);
	// 828A66FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6700: 40820038  bne 0x828a6738
	if !ctx.cr[0].eq {
	pc = 0x828A6738; continue 'dispatch;
	}
	// 828A6704: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A6708: E8810090  ld r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 828A670C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A6710: E8A10098  ld r5, 0x98(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 828A6714: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 828A6718: E8C100A0  ld r6, 0xa0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A671C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6720: E8E100A8  ld r7, 0xa8(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A6724: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828A6728: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A672C: 4800CE85  bl 0x828b35b0
	ctx.lr = 0x828A6730;
	sub_828B35B0(ctx, base);
	// 828A6730: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828A6734: 48000008  b 0x828a673c
	pc = 0x828A673C; continue 'dispatch;
	// 828A6738: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A673C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A6740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A6744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A6748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A674C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A6750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A6758 size=384
    let mut pc: u32 = 0x828A6758;
    'dispatch: loop {
        match pc {
            0x828A6758 => {
    //   block [0x828A6758..0x828A68D8)
	// 828A6758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A675C: 48901A09  bl 0x831a8164
	ctx.lr = 0x828A6760;
	sub_831A8130(ctx, base);
	// 828A6760: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828A6764: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6768: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A676C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 828A6770: 4806A151  bl 0x829108c0
	ctx.lr = 0x828A6774;
	sub_829108C0(ctx, base);
	// 828A6774: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6778: 40820148  bne 0x828a68c0
	if !ctx.cr[0].eq {
	pc = 0x828A68C0; continue 'dispatch;
	}
	// 828A677C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828A6780: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A6784: 4BC61EFD  bl 0x82508680
	ctx.lr = 0x828A6788;
	sub_82508680(ctx, base);
	// 828A6788: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A678C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A6790: 4BFCFF99  bl 0x82876728
	ctx.lr = 0x828A6794;
	sub_82876728(ctx, base);
	// 828A6794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6798: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A679C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A67A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A67A4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A67A8: 419A0024  beq cr6, 0x828a67cc
	if ctx.cr[6].eq {
	pc = 0x828A67CC; continue 'dispatch;
	}
	// 828A67AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A67B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A67B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A67B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A67BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A67C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A67C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A67C8: 4082FFE8  bne 0x828a67b0
	if !ctx.cr[0].eq {
	pc = 0x828A67B0; continue 'dispatch;
	}
	// 828A67CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A67D0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828A67D4: 3BAB9F00  addi r29, r11, -0x6100
	ctx.r[29].s64 = ctx.r[11].s64 + -24832;
	// 828A67D8: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 828A67DC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 828A67E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A67E4: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A67E8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828A67EC: 38A00250  li r5, 0x250
	ctx.r[5].s64 = 592;
	// 828A67F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A67F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A67F8: 485B2249  bl 0x82e58a40
	ctx.lr = 0x828A67FC;
	sub_82E58A40(ctx, base);
	// 828A67FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A6800: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6804: 419A0008  beq cr6, 0x828a680c
	if ctx.cr[6].eq {
	pc = 0x828A680C; continue 'dispatch;
	}
	// 828A6808: 4BA1A089  bl 0x822c0890
	ctx.lr = 0x828A680C;
	sub_822C0890(ctx, base);
	// 828A680C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A6810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6814: 419A0008  beq cr6, 0x828a681c
	if ctx.cr[6].eq {
	pc = 0x828A681C; continue 'dispatch;
	}
	// 828A6818: 4BA1A079  bl 0x822c0890
	ctx.lr = 0x828A681C;
	sub_822C0890(ctx, base);
	// 828A681C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6820: 4BF45901  bl 0x827ec120
	ctx.lr = 0x828A6824;
	sub_827EC120(ctx, base);
	// 828A6824: 817F0400  lwz r11, 0x400(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 828A6828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A682C: 419A0088  beq cr6, 0x828a68b4
	if ctx.cr[6].eq {
	pc = 0x828A68B4; continue 'dispatch;
	}
	// 828A6830: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A6834: 4BB2D0D5  bl 0x823d3908
	ctx.lr = 0x828A6838;
	sub_823D3908(ctx, base);
	// 828A6838: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A683C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A6840: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6848: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A684C: 419A0024  beq cr6, 0x828a6870
	if ctx.cr[6].eq {
	pc = 0x828A6870; continue 'dispatch;
	}
	// 828A6850: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A6854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A6858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A685C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A6860: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A6864: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A6868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A686C: 4082FFE8  bne 0x828a6854
	if !ctx.cr[0].eq {
	pc = 0x828A6854; continue 'dispatch;
	}
	// 828A6870: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A6874: 80DF0400  lwz r6, 0x400(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1024 as u32) ) } as u64;
	// 828A6878: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828A687C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A6880: 38A00259  li r5, 0x259
	ctx.r[5].s64 = 601;
	// 828A6884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6888: 485B21B9  bl 0x82e58a40
	ctx.lr = 0x828A688C;
	sub_82E58A40(ctx, base);
	// 828A688C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A6890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6894: 419A0008  beq cr6, 0x828a689c
	if ctx.cr[6].eq {
	pc = 0x828A689C; continue 'dispatch;
	}
	// 828A6898: 4BA19FF9  bl 0x822c0890
	ctx.lr = 0x828A689C;
	sub_822C0890(ctx, base);
	// 828A689C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A68A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A68A4: 419A0008  beq cr6, 0x828a68ac
	if ctx.cr[6].eq {
	pc = 0x828A68AC; continue 'dispatch;
	}
	// 828A68A8: 4BA19FE9  bl 0x822c0890
	ctx.lr = 0x828A68AC;
	sub_822C0890(ctx, base);
	// 828A68AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A68B0: 917F0400  stw r11, 0x400(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1024 as u32), ctx.r[11].u32 ) };
	// 828A68B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A68B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A68BC: 48067875  bl 0x8290e130
	ctx.lr = 0x828A68C0;
	sub_8290E130(ctx, base);
	// 828A68C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A68C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A68C8: 4806A8B9  bl 0x82911180
	ctx.lr = 0x828A68CC;
	sub_82911180(ctx, base);
	// 828A68CC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A68D0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828A68D4: 489018E0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A68D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A68D8 size=172
    let mut pc: u32 = 0x828A68D8;
    'dispatch: loop {
        match pc {
            0x828A68D8 => {
    //   block [0x828A68D8..0x828A6984)
	// 828A68D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A68DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A68E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A68E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A68E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A68EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A68F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A68F4: 817F03CC  lwz r11, 0x3cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828A68F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A68FC: 419A0070  beq cr6, 0x828a696c
	if ctx.cr[6].eq {
	pc = 0x828A696C; continue 'dispatch;
	}
	// 828A6900: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A6904: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6908: 388B12B0  addi r4, r11, 0x12b0
	ctx.r[4].s64 = ctx.r[11].s64 + 4784;
	// 828A690C: 4854D0FD  bl 0x82df3a08
	ctx.lr = 0x828A6910;
	sub_82DF3A08(ctx, base);
	// 828A6910: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828A6914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A6918: 388BBE80  addi r4, r11, -0x4180
	ctx.r[4].s64 = ctx.r[11].s64 + -16768;
	// 828A691C: 4854D0ED  bl 0x82df3a08
	ctx.lr = 0x828A6920;
	sub_82DF3A08(ctx, base);
	// 828A6920: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828A6924: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 828A6928: 80BF03CC  lwz r5, 0x3cc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828A692C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6930: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A6934: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A6938: 4BD07259  bl 0x825adb90
	ctx.lr = 0x828A693C;
	sub_825ADB90(ctx, base);
	// 828A693C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A6940: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A6944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A6948: 4BCFB471  bl 0x825a1db8
	ctx.lr = 0x828A694C;
	sub_825A1DB8(ctx, base);
	// 828A694C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828A6950: 4854CAD9  bl 0x82df3428
	ctx.lr = 0x828A6954;
	sub_82DF3428(ctx, base);
	// 828A6954: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A6958: 4BA22361  bl 0x822c8cb8
	ctx.lr = 0x828A695C;
	sub_822C8CB8(ctx, base);
	// 828A695C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A6960: 4854CAC9  bl 0x82df3428
	ctx.lr = 0x828A6964;
	sub_82DF3428(ctx, base);
	// 828A6964: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6968: 4854CAC1  bl 0x82df3428
	ctx.lr = 0x828A696C;
	sub_82DF3428(ctx, base);
	// 828A696C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828A6970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A6974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A6978: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A697C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A6980: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A6988 size=1020
    let mut pc: u32 = 0x828A6988;
    'dispatch: loop {
        match pc {
            0x828A6988 => {
    //   block [0x828A6988..0x828A6D84)
	// 828A6988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A698C: 489017D1  bl 0x831a815c
	ctx.lr = 0x828A6990;
	sub_831A8130(ctx, base);
	// 828A6990: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828A6994: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6998: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A699C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828A69A0: 3B3D0038  addi r25, r29, 0x38
	ctx.r[25].s64 = ctx.r[29].s64 + 56;
	// 828A69A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A69A8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A69AC: 4876260D  bl 0x83008fb8
	ctx.lr = 0x828A69B0;
	sub_83008FB8(ctx, base);
	// 828A69B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A69B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A69B8: 48761771  bl 0x83008128
	ctx.lr = 0x828A69BC;
	sub_83008128(ctx, base);
	// 828A69BC: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 828A69C0: 419A03B8  beq cr6, 0x828a6d78
	if ctx.cr[6].eq {
	pc = 0x828A6D78; continue 'dispatch;
	}
	// 828A69C4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A69C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A69CC: 808B1524  lwz r4, 0x1524(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5412 as u32) ) } as u64;
	// 828A69D0: 4854D039  bl 0x82df3a08
	ctx.lr = 0x828A69D4;
	sub_82DF3A08(ctx, base);
	// 828A69D4: 3B7D010C  addi r27, r29, 0x10c
	ctx.r[27].s64 = ctx.r[29].s64 + 268;
	// 828A69D8: 3BC10054  addi r30, r1, 0x54
	ctx.r[30].s64 = ctx.r[1].s64 + 84;
	// 828A69DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A69E0: 485B3CF1  bl 0x82e5a6d0
	ctx.lr = 0x828A69E4;
	sub_82E5A6D0(ctx, base);
	// 828A69E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A69E8: 4854C921  bl 0x82df3308
	ctx.lr = 0x828A69EC;
	sub_82DF3308(ctx, base);
	// 828A69EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A69F0: 41820014  beq 0x828a6a04
	if ctx.cr[0].eq {
	pc = 0x828A6A04; continue 'dispatch;
	}
	// 828A69F4: 817C0060  lwz r11, 0x60(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 828A69F8: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A69FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6A00: 40820008  bne 0x828a6a08
	if !ctx.cr[0].eq {
	pc = 0x828A6A08; continue 'dispatch;
	}
	// 828A6A04: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828A6A08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6A0C: 557E063E  clrlwi r30, r11, 0x18
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A6A10: 4854CA19  bl 0x82df3428
	ctx.lr = 0x828A6A14;
	sub_82DF3428(ctx, base);
	// 828A6A14: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A6A18: 40820360  bne 0x828a6d78
	if !ctx.cr[0].eq {
	pc = 0x828A6D78; continue 'dispatch;
	}
	// 828A6A1C: 807D0370  lwz r3, 0x370(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(880 as u32) ) } as u64;
	// 828A6A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6A24: 419A0354  beq cr6, 0x828a6d78
	if ctx.cr[6].eq {
	pc = 0x828A6D78; continue 'dispatch;
	}
	// 828A6A28: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828A6A2C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828A6A30: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A6A34: 4BF2F09D  bl 0x827d5ad0
	ctx.lr = 0x828A6A38;
	sub_827D5AD0(ctx, base);
	// 828A6A38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6A3C: 4182033C  beq 0x828a6d78
	if ctx.cr[0].eq {
	pc = 0x828A6D78; continue 'dispatch;
	}
	// 828A6A40: 3F40832D  lis r26, -0x7cd3
	ctx.r[26].s64 = -2094202880;
	// 828A6A44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6A48: 809A0B2C  lwz r4, 0xb2c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828A6A4C: 4854CFBD  bl 0x82df3a08
	ctx.lr = 0x828A6A50;
	sub_82DF3A08(ctx, base);
	// 828A6A50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A6A54: 3BE10054  addi r31, r1, 0x54
	ctx.r[31].s64 = ctx.r[1].s64 + 84;
	// 828A6A58: 485B3C79  bl 0x82e5a6d0
	ctx.lr = 0x828A6A5C;
	sub_82E5A6D0(ctx, base);
	// 828A6A5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6A60: 4854C841  bl 0x82df32a0
	ctx.lr = 0x828A6A64;
	sub_82DF32A0(ctx, base);
	// 828A6A64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6A68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6A6C: 4854C9BD  bl 0x82df3428
	ctx.lr = 0x828A6A70;
	sub_82DF3428(ctx, base);
	// 828A6A70: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A6A74: 41820304  beq 0x828a6d78
	if ctx.cr[0].eq {
	pc = 0x828A6D78; continue 'dispatch;
	}
	// 828A6A78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A6A7C: 83FD0380  lwz r31, 0x380(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(896 as u32) ) } as u64;
	// 828A6A80: 485B3C51  bl 0x82e5a6d0
	ctx.lr = 0x828A6A84;
	sub_82E5A6D0(ctx, base);
	// 828A6A84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A6A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6A8C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828A6A90: 4807B601  bl 0x82922090
	ctx.lr = 0x828A6A94;
	sub_82922090(ctx, base);
	// 828A6A94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A6A98: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A6A9C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A6AA0: 4182022C  beq 0x828a6ccc
	if ctx.cr[0].eq {
	pc = 0x828A6CCC; continue 'dispatch;
	}
	// 828A6AA4: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828A6AA8: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828A6AAC: 814A85E4  lwz r10, -0x7a1c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31260 as u32) ) } as u64;
	// 828A6AB0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A6AB4: 419A0014  beq cr6, 0x828a6ac8
	if ctx.cr[6].eq {
	pc = 0x828A6AC8; continue 'dispatch;
	}
	// 828A6AB8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 828A6ABC: 814A85E8  lwz r10, -0x7a18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31256 as u32) ) } as u64;
	// 828A6AC0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828A6AC4: 409A0014  bne cr6, 0x828a6ad8
	if !ctx.cr[6].eq {
	pc = 0x828A6AD8; continue 'dispatch;
	}
	// 828A6AC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A6ACC: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828A6AD0: C02B9450  lfs f1, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A6AD4: 4BC6B195  bl 0x82511c68
	ctx.lr = 0x828A6AD8;
	sub_82511C68(ctx, base);
	// 828A6AD8: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828A6ADC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 828A6AE0: 814A0BD4  lwz r10, 0xbd4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3028 as u32) ) } as u64;
	// 828A6AE4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6AE8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6AEC: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828A6AF0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 828A6AF4: 41820014  beq 0x828a6b08
	if ctx.cr[0].eq {
	pc = 0x828A6B08; continue 'dispatch;
	}
	// 828A6AF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 828A6AFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A6B00: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828A6B04: 419AFFE0  beq cr6, 0x828a6ae4
	if ctx.cr[6].eq {
	pc = 0x828A6AE4; continue 'dispatch;
	}
	// 828A6B08: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A6B0C: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 828A6B10: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 828A6B14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A6B18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A6B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6B20: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A6B24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A6B28: 408200EC  bne 0x828a6c14
	if !ctx.cr[0].eq {
	pc = 0x828A6C14; continue 'dispatch;
	}
	// 828A6B2C: 4E800421  bctrl
	ctx.lr = 0x828A6B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A6B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6B34: 48062325  bl 0x82908e58
	ctx.lr = 0x828A6B38;
	sub_82908E58(ctx, base);
	// 828A6B38: FF01F800  fcmpu cr6, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828A6B3C: 41990190  bgt cr6, 0x828a6ccc
	if ctx.cr[6].gt {
	pc = 0x828A6CCC; continue 'dispatch;
	}
	// 828A6B40: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A6B44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6B48: 3BEB14A8  addi r31, r11, 0x14a8
	ctx.r[31].s64 = ctx.r[11].s64 + 5288;
	// 828A6B4C: 808B14A8  lwz r4, 0x14a8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5288 as u32) ) } as u64;
	// 828A6B50: 4854CEB9  bl 0x82df3a08
	ctx.lr = 0x828A6B54;
	sub_82DF3A08(ctx, base);
	// 828A6B54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A6B58: 807D0378  lwz r3, 0x378(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(888 as u32) ) } as u64;
	// 828A6B5C: 4BF43985  bl 0x827ea4e0
	ctx.lr = 0x828A6B60;
	sub_827EA4E0(ctx, base);
	// 828A6B60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6B64: 4854C8C5  bl 0x82df3428
	ctx.lr = 0x828A6B68;
	sub_82DF3428(ctx, base);
	// 828A6B68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A6B6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6B70: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828A6B74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A6B78: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828A6B7C: 4BF71D6D  bl 0x828188e8
	ctx.lr = 0x828A6B80;
	sub_828188E8(ctx, base);
	// 828A6B80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A6B84: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A6B88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A6B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6B90: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828A6B94: 419A0024  beq cr6, 0x828a6bb8
	if ctx.cr[6].eq {
	pc = 0x828A6BB8; continue 'dispatch;
	}
	// 828A6B98: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A6B9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A6BA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A6BA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A6BA8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A6BAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A6BB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A6BB4: 4082FFE8  bne 0x828a6b9c
	if !ctx.cr[0].eq {
	pc = 0x828A6B9C; continue 'dispatch;
	}
	// 828A6BB8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A6BBC: 807D0388  lwz r3, 0x388(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A6BC0: 4BF514B9  bl 0x827f8078
	ctx.lr = 0x828A6BC4;
	sub_827F8078(ctx, base);
	// 828A6BC4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A6BC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6BCC: 419A0008  beq cr6, 0x828a6bd4
	if ctx.cr[6].eq {
	pc = 0x828A6BD4; continue 'dispatch;
	}
	// 828A6BD0: 4BA19CC1  bl 0x822c0890
	ctx.lr = 0x828A6BD4;
	sub_822C0890(ctx, base);
	// 828A6BD4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 828A6BD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6BDC: 419A0008  beq cr6, 0x828a6be4
	if ctx.cr[6].eq {
	pc = 0x828A6BE4; continue 'dispatch;
	}
	// 828A6BE0: 4BA19CB1  bl 0x822c0890
	ctx.lr = 0x828A6BE4;
	sub_822C0890(ctx, base);
	// 828A6BE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A6BE8: 809A0B2C  lwz r4, 0xb2c(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828A6BEC: 4854CE1D  bl 0x82df3a08
	ctx.lr = 0x828A6BF0;
	sub_82DF3A08(ctx, base);
	// 828A6BF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A6BF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A6BF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A6BFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828A6C00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A6C04: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828A6C08: 485B7D59  bl 0x82e5e960
	ctx.lr = 0x828A6C0C;
	sub_82E5E960(ctx, base);
	// 828A6C0C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828A6C10: 480000B0  b 0x828a6cc0
	pc = 0x828A6CC0; continue 'dispatch;
	// 828A6C14: 4E800421  bctrl
	ctx.lr = 0x828A6C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A6C18: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A6C1C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828A6C20: 38AB9F70  addi r5, r11, -0x6090
	ctx.r[5].s64 = ctx.r[11].s64 + -24720;
	// 828A6C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6C28: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 828A6C2C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828A6C30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A6C34: 4E800421  bctrl
	ctx.lr = 0x828A6C38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A6C38: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 828A6C3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A6C40: 419A0008  beq cr6, 0x828a6c48
	if ctx.cr[6].eq {
	pc = 0x828A6C48; continue 'dispatch;
	}
	// 828A6C44: 4BA19C4D  bl 0x822c0890
	ctx.lr = 0x828A6C48;
	sub_822C0890(ctx, base);
	// 828A6C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6C4C: 4BF45515  bl 0x827ec160
	ctx.lr = 0x828A6C50;
	sub_827EC160(ctx, base);
	// 828A6C50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A6C54: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A6C58: 48070141  bl 0x82916d98
	ctx.lr = 0x828A6C5C;
	sub_82916D98(ctx, base);
	// 828A6C5C: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 828A6C60: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 828A6C64: 394000D0  li r10, 0xd0
	ctx.r[10].s64 = 208;
	// 828A6C68: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828A6C6C: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	// 828A6C70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A6C74: 13FC58C7  vcmpequd (lvx128) v31, v28, v11
	tmp.u32 = ctx.r[28].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828A6C78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A6D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A6D88 size=928
    let mut pc: u32 = 0x828A6D88;
    'dispatch: loop {
        match pc {
            0x828A6D88 => {
    //   block [0x828A6D88..0x828A7128)
	// 828A6D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A6D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A6D90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A6D94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A6D98: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828A6D9C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A6DA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A6DA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A6DA8: 817F0360  lwz r11, 0x360(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(864 as u32) ) } as u64;
	// 828A6DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A6DB0: 419A035C  beq cr6, 0x828a710c
	if ctx.cr[6].eq {
	pc = 0x828A710C; continue 'dispatch;
	}
	// 828A6DB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A6DB8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A6DBC: 4806289D  bl 0x82909658
	ctx.lr = 0x828A6DC0;
	sub_82909658(ctx, base);
	// 828A6DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A6DC4: 4816C8BD  bl 0x82a13680
	ctx.lr = 0x828A6DC8;
	sub_82A13680(ctx, base);
	// 828A6DC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A6DCC: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 828A6DD0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828A6DD4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828A6DD8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7128 size=172
    let mut pc: u32 = 0x828A7128;
    'dispatch: loop {
        match pc {
            0x828A7128 => {
    //   block [0x828A7128..0x828A71D4)
	// 828A7128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A712C: 48901041  bl 0x831a816c
	ctx.lr = 0x828A7130;
	sub_831A8130(ctx, base);
	// 828A7130: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7134: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A7138: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A713C: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 828A7140: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7144: 807D0378  lwz r3, 0x378(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(888 as u32) ) } as u64;
	// 828A7148: 4BF43399  bl 0x827ea4e0
	ctx.lr = 0x828A714C;
	sub_827EA4E0(ctx, base);
	// 828A714C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7150: 4854C061  bl 0x82df31b0
	ctx.lr = 0x828A7154;
	sub_82DF31B0(ctx, base);
	// 828A7154: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828A7158: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 828A715C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7160: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7164: 4BF71785  bl 0x828188e8
	ctx.lr = 0x828A7168;
	sub_828188E8(ctx, base);
	// 828A7168: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A716C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A7170: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7174: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7178: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A717C: 419A0024  beq cr6, 0x828a71a0
	if ctx.cr[6].eq {
	pc = 0x828A71A0; continue 'dispatch;
	}
	// 828A7180: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A7184: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A7188: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A718C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7190: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7194: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7198: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A719C: 4082FFE8  bne 0x828a7184
	if !ctx.cr[0].eq {
	pc = 0x828A7184; continue 'dispatch;
	}
	// 828A71A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A71A4: 807D0388  lwz r3, 0x388(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A71A8: 4BF50ED1  bl 0x827f8078
	ctx.lr = 0x828A71AC;
	sub_827F8078(ctx, base);
	// 828A71AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A71B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A71B4: 419A0008  beq cr6, 0x828a71bc
	if ctx.cr[6].eq {
	pc = 0x828A71BC; continue 'dispatch;
	}
	// 828A71B8: 4BA196D9  bl 0x822c0890
	ctx.lr = 0x828A71BC;
	sub_822C0890(ctx, base);
	// 828A71BC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A71C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A71C4: 419A0008  beq cr6, 0x828a71cc
	if ctx.cr[6].eq {
	pc = 0x828A71CC; continue 'dispatch;
	}
	// 828A71C8: 4BA196C9  bl 0x822c0890
	ctx.lr = 0x828A71CC;
	sub_822C0890(ctx, base);
	// 828A71CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A71D0: 48900FEC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A71D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A71D8 size=180
    let mut pc: u32 = 0x828A71D8;
    'dispatch: loop {
        match pc {
            0x828A71D8 => {
    //   block [0x828A71D8..0x828A728C)
	// 828A71D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A71DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A71E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A71E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A71E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A71EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A71F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828A71F4: 48062DBD  bl 0x82909fb0
	ctx.lr = 0x828A71F8;
	sub_82909FB0(ctx, base);
	// 828A71F8: 817E0378  lwz r11, 0x378(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(888 as u32) ) } as u64;
	// 828A71FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7200: 419A0074  beq cr6, 0x828a7274
	if ctx.cr[6].eq {
	pc = 0x828A7274; continue 'dispatch;
	}
	// 828A7204: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 828A7208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A720C: 4BCD16C5  bl 0x825788d0
	ctx.lr = 0x828A7210;
	sub_825788D0(ctx, base);
	// 828A7210: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7214: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A7218: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A721C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7220: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A7224: 419A0024  beq cr6, 0x828a7248
	if ctx.cr[6].eq {
	pc = 0x828A7248; continue 'dispatch;
	}
	// 828A7228: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A722C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A7230: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7234: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A723C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7240: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7244: 4082FFE8  bne 0x828a722c
	if !ctx.cr[0].eq {
	pc = 0x828A722C; continue 'dispatch;
	}
	// 828A7248: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A724C: 807E0378  lwz r3, 0x378(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(888 as u32) ) } as u64;
	// 828A7250: 4BF50E29  bl 0x827f8078
	ctx.lr = 0x828A7254;
	sub_827F8078(ctx, base);
	// 828A7254: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A725C: 419A0008  beq cr6, 0x828a7264
	if ctx.cr[6].eq {
	pc = 0x828A7264; continue 'dispatch;
	}
	// 828A7260: 4BA19631  bl 0x822c0890
	ctx.lr = 0x828A7264;
	sub_822C0890(ctx, base);
	// 828A7264: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A7268: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A726C: 419A0008  beq cr6, 0x828a7274
	if ctx.cr[6].eq {
	pc = 0x828A7274; continue 'dispatch;
	}
	// 828A7270: 4BA19621  bl 0x822c0890
	ctx.lr = 0x828A7274;
	sub_822C0890(ctx, base);
	// 828A7274: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A7278: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A727C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A7280: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A7284: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7288: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7290 size=196
    let mut pc: u32 = 0x828A7290;
    'dispatch: loop {
        match pc {
            0x828A7290 => {
    //   block [0x828A7290..0x828A7354)
	// 828A7290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7298: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A729C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A72A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A72A4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A72A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A72AC: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A72B0: 815F03CC  lwz r10, 0x3cc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828A72B4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A72B8: 1D4A03B4  mulli r10, r10, 0x3b4
	ctx.r[10].s64 = ctx.r[10].s64 * 948;
	// 828A72BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A72C0: 392B031C  addi r9, r11, 0x31c
	ctx.r[9].s64 = ctx.r[11].s64 + 796;
	// 828A72C4: 390B0318  addi r8, r11, 0x318
	ctx.r[8].s64 = ctx.r[11].s64 + 792;
	// 828A72C8: 38EB0310  addi r7, r11, 0x310
	ctx.r[7].s64 = ctx.r[11].s64 + 784;
	// 828A72CC: 38CB030C  addi r6, r11, 0x30c
	ctx.r[6].s64 = ctx.r[11].s64 + 780;
	// 828A72D0: 38AB0308  addi r5, r11, 0x308
	ctx.r[5].s64 = ctx.r[11].s64 + 776;
	// 828A72D4: 388B0304  addi r4, r11, 0x304
	ctx.r[4].s64 = ctx.r[11].s64 + 772;
	// 828A72D8: 4BFFE991  bl 0x828a5c68
	ctx.lr = 0x828A72DC;
	sub_828A5C68(ctx, base);
	// 828A72DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A72E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A72E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A72E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A72EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A72F0: 419A0024  beq cr6, 0x828a7314
	if ctx.cr[6].eq {
	pc = 0x828A7314; continue 'dispatch;
	}
	// 828A72F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A72F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A72FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7300: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7304: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7308: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A730C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7310: 4082FFE8  bne 0x828a72f8
	if !ctx.cr[0].eq {
	pc = 0x828A72F8; continue 'dispatch;
	}
	// 828A7314: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7318: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A731C: 4BF50D5D  bl 0x827f8078
	ctx.lr = 0x828A7320;
	sub_827F8078(ctx, base);
	// 828A7320: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7324: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7328: 419A0008  beq cr6, 0x828a7330
	if ctx.cr[6].eq {
	pc = 0x828A7330; continue 'dispatch;
	}
	// 828A732C: 4BA19565  bl 0x822c0890
	ctx.lr = 0x828A7330;
	sub_822C0890(ctx, base);
	// 828A7330: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A7334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7338: 419A0008  beq cr6, 0x828a7340
	if ctx.cr[6].eq {
	pc = 0x828A7340; continue 'dispatch;
	}
	// 828A733C: 4BA19555  bl 0x822c0890
	ctx.lr = 0x828A7340;
	sub_822C0890(ctx, base);
	// 828A7340: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A734C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A7358 size=400
    let mut pc: u32 = 0x828A7358;
    'dispatch: loop {
        match pc {
            0x828A7358 => {
    //   block [0x828A7358..0x828A74E8)
	// 828A7358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A735C: 48900E01  bl 0x831a815c
	ctx.lr = 0x828A7360;
	sub_831A8130(ctx, base);
	// 828A7360: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7364: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A7368: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828A736C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828A7370: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 828A7374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7378: C06B0140  lfs f3, 0x140(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828A737C: C04A9524  lfs f2, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828A7380: C029964C  lfs f1, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A7384: 4BFFE5BD  bl 0x828a5940
	ctx.lr = 0x828A7388;
	sub_828A5940(ctx, base);
	// 828A7388: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828A738C: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A7390: 388A9F00  addi r4, r10, -0x6100
	ctx.r[4].s64 = ctx.r[10].s64 + -24832;
	// 828A7394: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A7398: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A739C: 38A00463  li r5, 0x463
	ctx.r[5].s64 = 1123;
	// 828A73A0: 38600144  li r3, 0x144
	ctx.r[3].s64 = 324;
	// 828A73A4: 815F03CC  lwz r10, 0x3cc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(972 as u32) ) } as u64;
	// 828A73A8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A73AC: 1D4A03B4  mulli r10, r10, 0x3b4
	ctx.r[10].s64 = ctx.r[10].s64 * 948;
	// 828A73B0: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A73B4: 4854B035  bl 0x82df23e8
	ctx.lr = 0x828A73B8;
	sub_82DF23E8(ctx, base);
	// 828A73B8: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A73BC: 4182005C  beq 0x828a7418
	if ctx.cr[0].eq {
	pc = 0x828A7418; continue 'dispatch;
	}
	// 828A73C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828A73C4: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828A73C8: 3B7C02D4  addi r27, r28, 0x2d4
	ctx.r[27].s64 = ctx.r[28].s64 + 724;
	// 828A73CC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828A73D0: 838B6818  lwz r28, 0x6818(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26648 as u32) ) } as u64;
	// 828A73D4: 48761BE5  bl 0x83008fb8
	ctx.lr = 0x828A73D8;
	sub_83008FB8(ctx, base);
	// 828A73D8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828A73DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A73E0: 4816C2A9  bl 0x82a13688
	ctx.lr = 0x828A73E4;
	sub_82A13688(ctx, base);
	// 828A73E4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828A73E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A73EC: 4816C295  bl 0x82a13680
	ctx.lr = 0x828A73F0;
	sub_82A13680(ctx, base);
	// 828A73F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A73F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A73F8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 828A73FC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 828A7400: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828A7404: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 828A7408: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 828A740C: 4BF63F25  bl 0x8280b330
	ctx.lr = 0x828A7410;
	sub_8280B330(ctx, base);
	// 828A7410: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A7414: 48000008  b 0x828a741c
	pc = 0x828A741C; continue 'dispatch;
	// 828A7418: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A741C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828A7420: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7424: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7428: 4BFCCC29  bl 0x82874050
	ctx.lr = 0x828A742C;
	sub_82874050(ctx, base);
	// 828A742C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A7430: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7434: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7438: 4BA18BC9  bl 0x822c0000
	ctx.lr = 0x828A743C;
	sub_822C0000(ctx, base);
	// 828A743C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7440: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A7444: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A7448: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828A744C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A7450: 419A0024  beq cr6, 0x828a7474
	if ctx.cr[6].eq {
	pc = 0x828A7474; continue 'dispatch;
	}
	// 828A7454: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828A7458: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A745C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7460: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7464: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7468: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A746C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7470: 4082FFE8  bne 0x828a7458
	if !ctx.cr[0].eq {
	pc = 0x828A7458; continue 'dispatch;
	}
	// 828A7474: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	// 828A7478: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A747C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A7480: 4BC68049  bl 0x8250f4c8
	ctx.lr = 0x828A7484;
	sub_8250F4C8(ctx, base);
	// 828A7484: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A748C: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828A7490: 409A0008  bne cr6, 0x828a7498
	if !ctx.cr[6].eq {
	pc = 0x828A7498; continue 'dispatch;
	}
	// 828A7494: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828A7498: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828A749C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A74A0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828A74A4: 4BC68075  bl 0x8250f518
	ctx.lr = 0x828A74A8;
	sub_8250F518(ctx, base);
	// 828A74A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828A74AC: 389F0410  addi r4, r31, 0x410
	ctx.r[4].s64 = ctx.r[31].s64 + 1040;
	// 828A74B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A74B4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828A74B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828A74BC: 4BC660D5  bl 0x8250d590
	ctx.lr = 0x828A74C0;
	sub_8250D590(ctx, base);
	// 828A74C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A74C4: 4854A7CD  bl 0x82df1c90
	ctx.lr = 0x828A74C8;
	sub_82DF1C90(ctx, base);
	// 828A74C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A74CC: 4854A7C5  bl 0x82df1c90
	ctx.lr = 0x828A74D0;
	sub_82DF1C90(ctx, base);
	// 828A74D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A74D4: 419A000C  beq cr6, 0x828a74e0
	if ctx.cr[6].eq {
	pc = 0x828A74E0; continue 'dispatch;
	}
	// 828A74D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A74DC: 4BA193B5  bl 0x822c0890
	ctx.lr = 0x828A74E0;
	sub_822C0890(ctx, base);
	// 828A74E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A74E4: 48900CC8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A74E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A74E8 size=260
    let mut pc: u32 = 0x828A74E8;
    'dispatch: loop {
        match pc {
            0x828A74E8 => {
    //   block [0x828A74E8..0x828A75EC)
	// 828A74E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A74EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A74F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A74F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A74F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A74FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A7500: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A7504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7508: 388B9A38  addi r4, r11, -0x65c8
	ctx.r[4].s64 = ctx.r[11].s64 + -26056;
	// 828A750C: 4854C4FD  bl 0x82df3a08
	ctx.lr = 0x828A7510;
	sub_82DF3A08(ctx, base);
	// 828A7510: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828A7514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7518: 4BF44C49  bl 0x827ec160
	ctx.lr = 0x828A751C;
	sub_827EC160(ctx, base);
	// 828A751C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7520: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7524: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 828A7528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A752C: 4E800421  bctrl
	ctx.lr = 0x828A7530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A7530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7534: 4854BEF5  bl 0x82df3428
	ctx.lr = 0x828A7538;
	sub_82DF3428(ctx, base);
	// 828A7538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A753C: 4BF44C25  bl 0x827ec160
	ctx.lr = 0x828A7540;
	sub_827EC160(ctx, base);
	// 828A7540: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7544: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7548: 4806F851  bl 0x82916d98
	ctx.lr = 0x828A754C;
	sub_82916D98(ctx, base);
	// 828A754C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828A7550: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A7554: 38AB00F8  addi r5, r11, 0xf8
	ctx.r[5].s64 = ctx.r[11].s64 + 248;
	// 828A7558: 388B00F4  addi r4, r11, 0xf4
	ctx.r[4].s64 = ctx.r[11].s64 + 244;
	// 828A755C: 4BFFE7AD  bl 0x828a5d08
	ctx.lr = 0x828A7560;
	sub_828A5D08(ctx, base);
	// 828A7560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7564: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A7568: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A756C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7570: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A7574: 419A0024  beq cr6, 0x828a7598
	if ctx.cr[6].eq {
	pc = 0x828A7598; continue 'dispatch;
	}
	// 828A7578: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A757C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A7580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7584: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A758C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7590: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7594: 4082FFE8  bne 0x828a757c
	if !ctx.cr[0].eq {
	pc = 0x828A757C; continue 'dispatch;
	}
	// 828A7598: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A759C: 807E0388  lwz r3, 0x388(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A75A0: 4BF50AD9  bl 0x827f8078
	ctx.lr = 0x828A75A4;
	sub_827F8078(ctx, base);
	// 828A75A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A75A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A75AC: 419A0008  beq cr6, 0x828a75b4
	if ctx.cr[6].eq {
	pc = 0x828A75B4; continue 'dispatch;
	}
	// 828A75B0: 4BA192E1  bl 0x822c0890
	ctx.lr = 0x828A75B4;
	sub_822C0890(ctx, base);
	// 828A75B4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A75B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A75BC: 419A0008  beq cr6, 0x828a75c4
	if ctx.cr[6].eq {
	pc = 0x828A75C4; continue 'dispatch;
	}
	// 828A75C0: 4BA192D1  bl 0x822c0890
	ctx.lr = 0x828A75C4;
	sub_822C0890(ctx, base);
	// 828A75C4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A75C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A75CC: 419A0008  beq cr6, 0x828a75d4
	if ctx.cr[6].eq {
	pc = 0x828A75D4; continue 'dispatch;
	}
	// 828A75D0: 4BA192C1  bl 0x822c0890
	ctx.lr = 0x828A75D4;
	sub_822C0890(ctx, base);
	// 828A75D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A75D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A75DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A75E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A75E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A75E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A75F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A75F0 size=260
    let mut pc: u32 = 0x828A75F0;
    'dispatch: loop {
        match pc {
            0x828A75F0 => {
    //   block [0x828A75F0..0x828A76F4)
	// 828A75F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A75F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A75F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A75FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7600: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7604: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A7608: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A760C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7610: 388B9A1C  addi r4, r11, -0x65e4
	ctx.r[4].s64 = ctx.r[11].s64 + -26084;
	// 828A7614: 4854C3F5  bl 0x82df3a08
	ctx.lr = 0x828A7618;
	sub_82DF3A08(ctx, base);
	// 828A7618: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828A761C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7620: 4BF44B41  bl 0x827ec160
	ctx.lr = 0x828A7624;
	sub_827EC160(ctx, base);
	// 828A7624: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7628: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A762C: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 828A7630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A7634: 4E800421  bctrl
	ctx.lr = 0x828A7638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828A7638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A763C: 4854BDED  bl 0x82df3428
	ctx.lr = 0x828A7640;
	sub_82DF3428(ctx, base);
	// 828A7640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7644: 4BF44B1D  bl 0x827ec160
	ctx.lr = 0x828A7648;
	sub_827EC160(ctx, base);
	// 828A7648: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A764C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7650: 4806F749  bl 0x82916d98
	ctx.lr = 0x828A7654;
	sub_82916D98(ctx, base);
	// 828A7654: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 828A7658: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A765C: 38AB00F8  addi r5, r11, 0xf8
	ctx.r[5].s64 = ctx.r[11].s64 + 248;
	// 828A7660: 388B00F4  addi r4, r11, 0xf4
	ctx.r[4].s64 = ctx.r[11].s64 + 244;
	// 828A7664: 4BFFE6A5  bl 0x828a5d08
	ctx.lr = 0x828A7668;
	sub_828A5D08(ctx, base);
	// 828A7668: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A766C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A7670: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7678: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A767C: 419A0024  beq cr6, 0x828a76a0
	if ctx.cr[6].eq {
	pc = 0x828A76A0; continue 'dispatch;
	}
	// 828A7680: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A7684: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A7688: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A768C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7690: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7694: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7698: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A769C: 4082FFE8  bne 0x828a7684
	if !ctx.cr[0].eq {
	pc = 0x828A7684; continue 'dispatch;
	}
	// 828A76A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A76A4: 807E0388  lwz r3, 0x388(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A76A8: 4BF509D1  bl 0x827f8078
	ctx.lr = 0x828A76AC;
	sub_827F8078(ctx, base);
	// 828A76AC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A76B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A76B4: 419A0008  beq cr6, 0x828a76bc
	if ctx.cr[6].eq {
	pc = 0x828A76BC; continue 'dispatch;
	}
	// 828A76B8: 4BA191D9  bl 0x822c0890
	ctx.lr = 0x828A76BC;
	sub_822C0890(ctx, base);
	// 828A76BC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A76C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A76C4: 419A0008  beq cr6, 0x828a76cc
	if ctx.cr[6].eq {
	pc = 0x828A76CC; continue 'dispatch;
	}
	// 828A76C8: 4BA191C9  bl 0x822c0890
	ctx.lr = 0x828A76CC;
	sub_822C0890(ctx, base);
	// 828A76CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A76D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A76D4: 419A0008  beq cr6, 0x828a76dc
	if ctx.cr[6].eq {
	pc = 0x828A76DC; continue 'dispatch;
	}
	// 828A76D8: 4BA191B9  bl 0x822c0890
	ctx.lr = 0x828A76DC;
	sub_822C0890(ctx, base);
	// 828A76DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A76E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A76E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A76E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A76EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A76F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A76F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A76F8 size=156
    let mut pc: u32 = 0x828A76F8;
    'dispatch: loop {
        match pc {
            0x828A76F8 => {
    //   block [0x828A76F8..0x828A7794)
	// 828A76F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A76FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7700: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7704: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7708: 9881008F  stb r4, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[4].u8 ) };
	// 828A770C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7710: 3881008F  addi r4, r1, 0x8f
	ctx.r[4].s64 = ctx.r[1].s64 + 143;
	// 828A7714: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A7718: 4BFFE671  bl 0x828a5d88
	ctx.lr = 0x828A771C;
	sub_828A5D88(ctx, base);
	// 828A771C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7720: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A7724: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A772C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A7730: 419A0024  beq cr6, 0x828a7754
	if ctx.cr[6].eq {
	pc = 0x828A7754; continue 'dispatch;
	}
	// 828A7734: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A7738: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A773C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7740: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7744: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7748: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A774C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7750: 4082FFE8  bne 0x828a7738
	if !ctx.cr[0].eq {
	pc = 0x828A7738; continue 'dispatch;
	}
	// 828A7754: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7758: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A775C: 4BF5091D  bl 0x827f8078
	ctx.lr = 0x828A7760;
	sub_827F8078(ctx, base);
	// 828A7760: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7764: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7768: 419A0008  beq cr6, 0x828a7770
	if ctx.cr[6].eq {
	pc = 0x828A7770; continue 'dispatch;
	}
	// 828A776C: 4BA19125  bl 0x822c0890
	ctx.lr = 0x828A7770;
	sub_822C0890(ctx, base);
	// 828A7770: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A7774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7778: 419A0008  beq cr6, 0x828a7780
	if ctx.cr[6].eq {
	pc = 0x828A7780; continue 'dispatch;
	}
	// 828A777C: 4BA19115  bl 0x822c0890
	ctx.lr = 0x828A7780;
	sub_822C0890(ctx, base);
	// 828A7780: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A778C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7798 size=156
    let mut pc: u32 = 0x828A7798;
    'dispatch: loop {
        match pc {
            0x828A7798 => {
    //   block [0x828A7798..0x828A7834)
	// 828A7798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A779C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A77A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A77A4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A77A8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 828A77AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A77B0: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 828A77B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A77B8: 4BFFE649  bl 0x828a5e00
	ctx.lr = 0x828A77BC;
	sub_828A5E00(ctx, base);
	// 828A77BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A77C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A77C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A77C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A77CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828A77D0: 419A0024  beq cr6, 0x828a77f4
	if ctx.cr[6].eq {
	pc = 0x828A77F4; continue 'dispatch;
	}
	// 828A77D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A77D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A77DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A77E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A77E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A77E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A77EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A77F0: 4082FFE8  bne 0x828a77d8
	if !ctx.cr[0].eq {
	pc = 0x828A77D8; continue 'dispatch;
	}
	// 828A77F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A77F8: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A77FC: 4BF5087D  bl 0x827f8078
	ctx.lr = 0x828A7800;
	sub_827F8078(ctx, base);
	// 828A7800: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7808: 419A0008  beq cr6, 0x828a7810
	if ctx.cr[6].eq {
	pc = 0x828A7810; continue 'dispatch;
	}
	// 828A780C: 4BA19085  bl 0x822c0890
	ctx.lr = 0x828A7810;
	sub_822C0890(ctx, base);
	// 828A7810: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A7814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7818: 419A0008  beq cr6, 0x828a7820
	if ctx.cr[6].eq {
	pc = 0x828A7820; continue 'dispatch;
	}
	// 828A781C: 4BA19075  bl 0x822c0890
	ctx.lr = 0x828A7820;
	sub_822C0890(ctx, base);
	// 828A7820: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A782C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7838 size=112
    let mut pc: u32 = 0x828A7838;
    'dispatch: loop {
        match pc {
            0x828A7838 => {
    //   block [0x828A7838..0x828A78A8)
	// 828A7838: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A783C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7840: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A7844: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A7848: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A784C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A7850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7854: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828A7858: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A785C: 4BFFDA05  bl 0x828a5260
	ctx.lr = 0x828A7860;
	sub_828A5260(ctx, base);
	// 828A7860: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A7864: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7868: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A786C: 4BA18795  bl 0x822c0000
	ctx.lr = 0x828A7870;
	sub_822C0000(ctx, base);
	// 828A7870: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A7874: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7878: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A787C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7884: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A7888: 419A0008  beq cr6, 0x828a7890
	if ctx.cr[6].eq {
	pc = 0x828A7890; continue 'dispatch;
	}
	// 828A788C: 4BA19005  bl 0x822c0890
	ctx.lr = 0x828A7890;
	sub_822C0890(ctx, base);
	// 828A7890: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A789C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A78A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A78A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A78A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A78A8 size=112
    let mut pc: u32 = 0x828A78A8;
    'dispatch: loop {
        match pc {
            0x828A78A8 => {
    //   block [0x828A78A8..0x828A7918)
	// 828A78A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A78AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A78B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A78B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A78B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A78BC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A78C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A78C4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828A78C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A78CC: 4BFFDA55  bl 0x828a5320
	ctx.lr = 0x828A78D0;
	sub_828A5320(ctx, base);
	// 828A78D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A78D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A78D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A78DC: 4BA18725  bl 0x822c0000
	ctx.lr = 0x828A78E0;
	sub_822C0000(ctx, base);
	// 828A78E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A78E4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A78E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A78EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A78F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A78F4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828A78F8: 419A0008  beq cr6, 0x828a7900
	if ctx.cr[6].eq {
	pc = 0x828A7900; continue 'dispatch;
	}
	// 828A78FC: 4BA18F95  bl 0x822c0890
	ctx.lr = 0x828A7900;
	sub_822C0890(ctx, base);
	// 828A7900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828A7904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A790C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A7910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A7914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7918 size=72
    let mut pc: u32 = 0x828A7918;
    'dispatch: loop {
        match pc {
            0x828A7918 => {
    //   block [0x828A7918..0x828A7960)
	// 828A7918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A791C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A7920: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7924: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828A7928: 419A001C  beq cr6, 0x828a7944
	if ctx.cr[6].eq {
	pc = 0x828A7944; continue 'dispatch;
	}
	// 828A792C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A7930: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828A7934: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828A7938: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A793C: 4BFFDBFD  bl 0x828a5538
	ctx.lr = 0x828A7940;
	sub_828A5538(ctx, base);
	// 828A7940: 48000010  b 0x828a7950
	pc = 0x828A7950; continue 'dispatch;
	// 828A7944: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A7948: 396B0A58  addi r11, r11, 0xa58
	ctx.r[11].s64 = ctx.r[11].s64 + 2648;
	// 828A794C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A7950: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828A7954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A7958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A795C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7960 size=512
    let mut pc: u32 = 0x828A7960;
    'dispatch: loop {
        match pc {
            0x828A7960 => {
    //   block [0x828A7960..0x828A7B60)
	// 828A7960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7964: 489007FD  bl 0x831a8160
	ctx.lr = 0x828A7968;
	sub_831A8130(ctx, base);
	// 828A7968: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A796C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A7970: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 828A7974: 3B7DFFF0  addi r27, r29, -0x10
	ctx.r[27].s64 = ctx.r[29].s64 + -16;
	// 828A7978: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A797C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A7980: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7984: 4BFFFD75  bl 0x828a76f8
	ctx.lr = 0x828A7988;
	sub_828A76F8(ctx, base);
	// 828A7988: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A798C: 807D0360  lwz r3, 0x360(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 828A7990: 48003C61  bl 0x828ab5f0
	ctx.lr = 0x828A7994;
	sub_828AB5F0(ctx, base);
	// 828A7994: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A7998: 807D0360  lwz r3, 0x360(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 828A799C: 48003C5D  bl 0x828ab5f8
	ctx.lr = 0x828A79A0;
	sub_828AB5F8(ctx, base);
	// 828A79A0: 387D00FC  addi r3, r29, 0xfc
	ctx.r[3].s64 = ctx.r[29].s64 + 252;
	// 828A79A4: 485B2D2D  bl 0x82e5a6d0
	ctx.lr = 0x828A79A8;
	sub_82E5A6D0(ctx, base);
	// 828A79A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A79AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A79B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A79B4: 808B1518  lwz r4, 0x1518(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5400 as u32) ) } as u64;
	// 828A79B8: 4854C051  bl 0x82df3a08
	ctx.lr = 0x828A79BC;
	sub_82DF3A08(ctx, base);
	// 828A79BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A79C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A79C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 828A79C8: 4854B941  bl 0x82df3308
	ctx.lr = 0x828A79CC;
	sub_82DF3308(ctx, base);
	// 828A79CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A79D0: 40820058  bne 0x828a7a28
	if !ctx.cr[0].eq {
	pc = 0x828A7A28; continue 'dispatch;
	}
	// 828A79D4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A79D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A79DC: 808B151C  lwz r4, 0x151c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5404 as u32) ) } as u64;
	// 828A79E0: 4854C029  bl 0x82df3a08
	ctx.lr = 0x828A79E4;
	sub_82DF3A08(ctx, base);
	// 828A79E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A79E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A79EC: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 828A79F0: 4854B919  bl 0x82df3308
	ctx.lr = 0x828A79F4;
	sub_82DF3308(ctx, base);
	// 828A79F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A79F8: 40820030  bne 0x828a7a28
	if !ctx.cr[0].eq {
	pc = 0x828A7A28; continue 'dispatch;
	}
	// 828A79FC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A7A00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7A04: 808B1528  lwz r4, 0x1528(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5416 as u32) ) } as u64;
	// 828A7A08: 4854C001  bl 0x82df3a08
	ctx.lr = 0x828A7A0C;
	sub_82DF3A08(ctx, base);
	// 828A7A0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A7A10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7A14: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 828A7A18: 4854B8F1  bl 0x82df3308
	ctx.lr = 0x828A7A1C;
	sub_82DF3308(ctx, base);
	// 828A7A1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7A20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7A24: 41820008  beq 0x828a7a2c
	if ctx.cr[0].eq {
	pc = 0x828A7A2C; continue 'dispatch;
	}
	// 828A7A28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7A2C: 57EA077B  rlwinm. r10, r31, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A7A30: 557C063E  clrlwi r28, r11, 0x18
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7A34: 41820010  beq 0x828a7a44
	if ctx.cr[0].eq {
	pc = 0x828A7A44; continue 'dispatch;
	}
	// 828A7A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7A3C: 57FF07B8  rlwinm r31, r31, 0, 0x1e, 0x1c
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7A40: 4854B9E9  bl 0x82df3428
	ctx.lr = 0x828A7A44;
	sub_82DF3428(ctx, base);
	// 828A7A44: 57EB07BD  rlwinm. r11, r31, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7A48: 41820010  beq 0x828a7a58
	if ctx.cr[0].eq {
	pc = 0x828A7A58; continue 'dispatch;
	}
	// 828A7A4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7A50: 57FF07FA  rlwinm r31, r31, 0, 0x1f, 0x1d
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7A54: 4854B9D5  bl 0x82df3428
	ctx.lr = 0x828A7A58;
	sub_82DF3428(ctx, base);
	// 828A7A58: 57EB07FF  clrlwi. r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7A5C: 41820010  beq 0x828a7a6c
	if ctx.cr[0].eq {
	pc = 0x828A7A6C; continue 'dispatch;
	}
	// 828A7A60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A7A64: 57FF003C  rlwinm r31, r31, 0, 0, 0x1e
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7A68: 4854B9C1  bl 0x82df3428
	ctx.lr = 0x828A7A6C;
	sub_82DF3428(ctx, base);
	// 828A7A6C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7A70: 41820014  beq 0x828a7a84
	if ctx.cr[0].eq {
	pc = 0x828A7A84; continue 'dispatch;
	}
	// 828A7A74: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A7A78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A7A7C: 4BFFFC7D  bl 0x828a76f8
	ctx.lr = 0x828A7A80;
	sub_828A76F8(ctx, base);
	// 828A7A80: 480000D8  b 0x828a7b58
	pc = 0x828A7B58; continue 'dispatch;
	// 828A7A84: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A7A88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7A8C: 808B1520  lwz r4, 0x1520(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5408 as u32) ) } as u64;
	// 828A7A90: 4854BF79  bl 0x82df3a08
	ctx.lr = 0x828A7A94;
	sub_82DF3A08(ctx, base);
	// 828A7A94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A7A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7A9C: 63FF0008  ori r31, r31, 8
	ctx.r[31].u64 = ctx.r[31].u64 | 8;
	// 828A7AA0: 4854B869  bl 0x82df3308
	ctx.lr = 0x828A7AA4;
	sub_82DF3308(ctx, base);
	// 828A7AA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7AA8: 40820030  bne 0x828a7ad8
	if !ctx.cr[0].eq {
	pc = 0x828A7AD8; continue 'dispatch;
	}
	// 828A7AAC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A7AB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A7AB4: 808B152C  lwz r4, 0x152c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5420 as u32) ) } as u64;
	// 828A7AB8: 4854BF51  bl 0x82df3a08
	ctx.lr = 0x828A7ABC;
	sub_82DF3A08(ctx, base);
	// 828A7ABC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A7AC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7AC4: 63FF0010  ori r31, r31, 0x10
	ctx.r[31].u64 = ctx.r[31].u64 | 16;
	// 828A7AC8: 4854B841  bl 0x82df3308
	ctx.lr = 0x828A7ACC;
	sub_82DF3308(ctx, base);
	// 828A7ACC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7AD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7AD4: 41820008  beq 0x828a7adc
	if ctx.cr[0].eq {
	pc = 0x828A7ADC; continue 'dispatch;
	}
	// 828A7AD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828A7ADC: 57EA06F7  rlwinm. r10, r31, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828A7AE0: 557C063E  clrlwi r28, r11, 0x18
	ctx.r[28].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828A7AE4: 41820010  beq 0x828a7af4
	if ctx.cr[0].eq {
	pc = 0x828A7AF4; continue 'dispatch;
	}
	// 828A7AE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A7AEC: 57FF0734  rlwinm r31, r31, 0, 0x1c, 0x1a
	ctx.r[31].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 828A7AF0: 4854B939  bl 0x82df3428
	ctx.lr = 0x828A7AF4;
	sub_82DF3428(ctx, base);
	// 828A7AF4: 57EB0739  rlwinm. r11, r31, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7AF8: 4182000C  beq 0x828a7b04
	if ctx.cr[0].eq {
	pc = 0x828A7B04; continue 'dispatch;
	}
	// 828A7AFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7B00: 4854B929  bl 0x82df3428
	ctx.lr = 0x828A7B04;
	sub_82DF3428(ctx, base);
	// 828A7B04: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7B08: 41820014  beq 0x828a7b1c
	if ctx.cr[0].eq {
	pc = 0x828A7B1C; continue 'dispatch;
	}
	// 828A7B0C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A7B10: 807D0360  lwz r3, 0x360(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 828A7B14: 48003ADD  bl 0x828ab5f0
	ctx.lr = 0x828A7B18;
	sub_828AB5F0(ctx, base);
	// 828A7B18: 48000040  b 0x828a7b58
	pc = 0x828A7B58; continue 'dispatch;
	// 828A7B1C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A7B20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A7B24: 808B1524  lwz r4, 0x1524(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5412 as u32) ) } as u64;
	// 828A7B28: 4854BEE1  bl 0x82df3a08
	ctx.lr = 0x828A7B2C;
	sub_82DF3A08(ctx, base);
	// 828A7B2C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A7B30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7B34: 4854B7D5  bl 0x82df3308
	ctx.lr = 0x828A7B38;
	sub_82DF3308(ctx, base);
	// 828A7B38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7B3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828A7B40: 4854B8E9  bl 0x82df3428
	ctx.lr = 0x828A7B44;
	sub_82DF3428(ctx, base);
	// 828A7B44: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A7B48: 41820010  beq 0x828a7b58
	if ctx.cr[0].eq {
	pc = 0x828A7B58; continue 'dispatch;
	}
	// 828A7B4C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A7B50: 807D0360  lwz r3, 0x360(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(864 as u32) ) } as u64;
	// 828A7B54: 48003AA5  bl 0x828ab5f8
	ctx.lr = 0x828A7B58;
	sub_828AB5F8(ctx, base);
	// 828A7B58: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A7B5C: 48900654  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7B60 size=372
    let mut pc: u32 = 0x828A7B60;
    'dispatch: loop {
        match pc {
            0x828A7B60 => {
    //   block [0x828A7B60..0x828A7CD4)
	// 828A7B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7B64: 48900601  bl 0x831a8164
	ctx.lr = 0x828A7B68;
	sub_831A8130(ctx, base);
	// 828A7B68: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7B6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A7B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7B74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A7B78: 388B9F00  addi r4, r11, -0x6100
	ctx.r[4].s64 = ctx.r[11].s64 + -24832;
	// 828A7B7C: 38A00432  li r5, 0x432
	ctx.r[5].s64 = 1074;
	// 828A7B80: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828A7B84: 4BA18855  bl 0x822c03d8
	ctx.lr = 0x828A7B88;
	sub_822C03D8(ctx, base);
	// 828A7B88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A7B8C: 41820020  beq 0x828a7bac
	if ctx.cr[0].eq {
	pc = 0x828A7BAC; continue 'dispatch;
	}
	// 828A7B90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A7B94: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 828A7B98: 409A0008  bne cr6, 0x828a7ba0
	if !ctx.cr[6].eq {
	pc = 0x828A7BA0; continue 'dispatch;
	}
	// 828A7B9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A7BA0: 4BF50991  bl 0x827f8530
	ctx.lr = 0x828A7BA4;
	sub_827F8530(ctx, base);
	// 828A7BA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7BA8: 48000008  b 0x828a7bb0
	pc = 0x828A7BB0; continue 'dispatch;
	// 828A7BAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828A7BB0: 3BBF0388  addi r29, r31, 0x388
	ctx.r[29].s64 = ctx.r[31].s64 + 904;
	// 828A7BB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A7BB8: 4BFE14A1  bl 0x82889058
	ctx.lr = 0x828A7BBC;
	sub_82889058(ctx, base);
	// 828A7BBC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828A7BC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7BC4: 388BF818  addi r4, r11, -0x7e8
	ctx.r[4].s64 = ctx.r[11].s64 + -2024;
	// 828A7BC8: 4854BE41  bl 0x82df3a08
	ctx.lr = 0x828A7BCC;
	sub_82DF3A08(ctx, base);
	// 828A7BCC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828A7BD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A7BD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7BD8: 4BF449F1  bl 0x827ec5c8
	ctx.lr = 0x828A7BDC;
	sub_827EC5C8(ctx, base);
	// 828A7BDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A7BE0: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 828A7BE4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7BE8: 487613D1  bl 0x83008fb8
	ctx.lr = 0x828A7BEC;
	sub_83008FB8(ctx, base);
	// 828A7BEC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828A7BF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A7BF4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A7BF8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A7BFC: 4856D435  bl 0x82e15030
	ctx.lr = 0x828A7C00;
	sub_82E15030(ctx, base);
	// 828A7C00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7C04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7C08: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828A7C0C: 4BF537B5  bl 0x827fb3c0
	ctx.lr = 0x828A7C10;
	sub_827FB3C0(ctx, base);
	// 828A7C10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7C14: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A7C18: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A7C1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C20: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A7C24: 419A0024  beq cr6, 0x828a7c48
	if ctx.cr[6].eq {
	pc = 0x828A7C48; continue 'dispatch;
	}
	// 828A7C28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A7C2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A7C30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7C34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7C38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7C3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7C40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7C44: 4082FFE8  bne 0x828a7c2c
	if !ctx.cr[0].eq {
	pc = 0x828A7C2C; continue 'dispatch;
	}
	// 828A7C48: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A7C4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7C50: 419A0008  beq cr6, 0x828a7c58
	if ctx.cr[6].eq {
	pc = 0x828A7C58; continue 'dispatch;
	}
	// 828A7C54: 4BA18C3D  bl 0x822c0890
	ctx.lr = 0x828A7C58;
	sub_822C0890(ctx, base);
	// 828A7C58: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A7C5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7C60: 419A0008  beq cr6, 0x828a7c68
	if ctx.cr[6].eq {
	pc = 0x828A7C68; continue 'dispatch;
	}
	// 828A7C64: 4BA18C2D  bl 0x822c0890
	ctx.lr = 0x828A7C68;
	sub_822C0890(ctx, base);
	// 828A7C68: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828A7C6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7C70: 419A0008  beq cr6, 0x828a7c78
	if ctx.cr[6].eq {
	pc = 0x828A7C78; continue 'dispatch;
	}
	// 828A7C74: 4BA18C1D  bl 0x822c0890
	ctx.lr = 0x828A7C78;
	sub_822C0890(ctx, base);
	// 828A7C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7C7C: 4854B7AD  bl 0x82df3428
	ctx.lr = 0x828A7C80;
	sub_82DF3428(ctx, base);
	// 828A7C80: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7C88: 419A0034  beq cr6, 0x828a7cbc
	if ctx.cr[6].eq {
	pc = 0x828A7CBC; continue 'dispatch;
	}
	// 828A7C8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828A7C90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828A7C94: 409A0008  bne cr6, 0x828a7c9c
	if !ctx.cr[6].eq {
	pc = 0x828A7C9C; continue 'dispatch;
	}
	// 828A7C98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828A7C9C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A7CA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7CA4: 4BF453CD  bl 0x827ed070
	ctx.lr = 0x828A7CA8;
	sub_827ED070(ctx, base);
	// 828A7CA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A7CAC: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A7CB0: 388B9F88  addi r4, r11, -0x6078
	ctx.r[4].s64 = ctx.r[11].s64 + -24696;
	// 828A7CB4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A7CB8: 4BF50751  bl 0x827f8408
	ctx.lr = 0x828A7CBC;
	sub_827F8408(ctx, base);
	// 828A7CBC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A7CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7CC4: 419A0008  beq cr6, 0x828a7ccc
	if ctx.cr[6].eq {
	pc = 0x828A7CCC; continue 'dispatch;
	}
	// 828A7CC8: 4BA18BC9  bl 0x822c0890
	ctx.lr = 0x828A7CCC;
	sub_822C0890(ctx, base);
	// 828A7CCC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828A7CD0: 489004E4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A7CD8 size=440
    let mut pc: u32 = 0x828A7CD8;
    'dispatch: loop {
        match pc {
            0x828A7CD8 => {
    //   block [0x828A7CD8..0x828A7E90)
	// 828A7CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7CDC: 48900489  bl 0x831a8164
	ctx.lr = 0x828A7CE0;
	sub_831A8130(ctx, base);
	// 828A7CE0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7CE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A7CE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828A7CEC: 3BCB9F00  addi r30, r11, -0x6100
	ctx.r[30].s64 = ctx.r[11].s64 + -24832;
	// 828A7CF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A7CF4: 38A00076  li r5, 0x76
	ctx.r[5].s64 = 118;
	// 828A7CF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7CFC: 38600420  li r3, 0x420
	ctx.r[3].s64 = 1056;
	// 828A7D00: 4854A6E9  bl 0x82df23e8
	ctx.lr = 0x828A7D04;
	sub_82DF23E8(ctx, base);
	// 828A7D04: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 828A7D08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A7D0C: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 828A7D10: 4182001C  beq 0x828a7d2c
	if ctx.cr[0].eq {
	pc = 0x828A7D2C; continue 'dispatch;
	}
	// 828A7D14: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828A7D18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A7D1C: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828A7D20: 4BFFD8C9  bl 0x828a55e8
	ctx.lr = 0x828A7D24;
	sub_828A55E8(ctx, base);
	// 828A7D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7D28: 48000008  b 0x828a7d30
	pc = 0x828A7D30; continue 'dispatch;
	// 828A7D2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A7D30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828A7D34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7D38: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7D3C: 4BFFB8B5  bl 0x828a35f0
	ctx.lr = 0x828A7D40;
	sub_828A35F0(ctx, base);
	// 828A7D40: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A7D44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7D48: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A7D4C: 4BA182B5  bl 0x822c0000
	ctx.lr = 0x828A7D50;
	sub_822C0000(ctx, base);
	// 828A7D50: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828A7D54: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A7D58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A7D5C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828A7D60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828A7D64: 419A0024  beq cr6, 0x828a7d88
	if ctx.cr[6].eq {
	pc = 0x828A7D88; continue 'dispatch;
	}
	// 828A7D68: 395C0004  addi r10, r28, 4
	ctx.r[10].s64 = ctx.r[28].s64 + 4;
	// 828A7D6C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828A7D70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7D74: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828A7D78: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828A7D7C: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7D80: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7D84: 4082FFE8  bne 0x828a7d6c
	if !ctx.cr[0].eq {
	pc = 0x828A7D6C; continue 'dispatch;
	}
	// 828A7D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A7D8C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 828A7D90: 409A0008  bne cr6, 0x828a7d98
	if !ctx.cr[6].eq {
	pc = 0x828A7D98; continue 'dispatch;
	}
	// 828A7D94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7D98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A7D9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A7DA0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 828A7DA4: 419A0024  beq cr6, 0x828a7dc8
	if ctx.cr[6].eq {
	pc = 0x828A7DC8; continue 'dispatch;
	}
	// 828A7DA8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828A7DAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A7DB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7DB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A7DB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A7DBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A7DC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A7DC4: 4082FFE8  bne 0x828a7dac
	if !ctx.cr[0].eq {
	pc = 0x828A7DAC; continue 'dispatch;
	}
	// 828A7DC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A7DCC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828A7DD0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828A7DD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A7DD8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A7DDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7DE0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A7DE4: 4BEF114D  bl 0x82798f30
	ctx.lr = 0x828A7DE8;
	sub_82798F30(ctx, base);
	// 828A7DE8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A7DEC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828A7DF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7DF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A7DF8: 38A00081  li r5, 0x81
	ctx.r[5].s64 = 129;
	// 828A7DFC: C00B95A0  lfs f0, -0x6a60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A7E00: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828A7E04: C1AA6218  lfs f13, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828A7E08: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 828A7E0C: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 828A7E10: 4BA185C9  bl 0x822c03d8
	ctx.lr = 0x828A7E14;
	sub_822C03D8(ctx, base);
	// 828A7E14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A7E18: 41820014  beq 0x828a7e2c
	if ctx.cr[0].eq {
	pc = 0x828A7E2C; continue 'dispatch;
	}
	// 828A7E1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828A7E20: 4BEF3849  bl 0x8279b668
	ctx.lr = 0x828A7E24;
	sub_8279B668(ctx, base);
	// 828A7E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7E28: 48000008  b 0x828a7e30
	pc = 0x828A7E30; continue 'dispatch;
	// 828A7E2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A7E30: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A7E34: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 828A7E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7E40: 4BCEFE11  bl 0x82597c50
	ctx.lr = 0x828A7E44;
	sub_82597C50(ctx, base);
	// 828A7E44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828A7E48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A7E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7E50: 4BA181B1  bl 0x822c0000
	ctx.lr = 0x828A7E54;
	sub_822C0000(ctx, base);
	// 828A7E54: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828A7E58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7E5C: 419A0008  beq cr6, 0x828a7e64
	if ctx.cr[6].eq {
	pc = 0x828A7E64; continue 'dispatch;
	}
	// 828A7E60: 4BA18A31  bl 0x822c0890
	ctx.lr = 0x828A7E64;
	sub_822C0890(ctx, base);
	// 828A7E64: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A7E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A7E6C: 419A0008  beq cr6, 0x828a7e74
	if ctx.cr[6].eq {
	pc = 0x828A7E74; continue 'dispatch;
	}
	// 828A7E70: 4BA18A21  bl 0x822c0890
	ctx.lr = 0x828A7E74;
	sub_822C0890(ctx, base);
	// 828A7E74: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828A7E78: 419A000C  beq cr6, 0x828a7e84
	if ctx.cr[6].eq {
	pc = 0x828A7E84; continue 'dispatch;
	}
	// 828A7E7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A7E80: 4BA18A11  bl 0x822c0890
	ctx.lr = 0x828A7E84;
	sub_822C0890(ctx, base);
	// 828A7E84: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828A7E88: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828A7E8C: 48900328  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7E90 size=92
    let mut pc: u32 = 0x828A7E90;
    'dispatch: loop {
        match pc {
            0x828A7E90 => {
    //   block [0x828A7E90..0x828A7EEC)
	// 828A7E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7E94: 489002D9  bl 0x831a816c
	ctx.lr = 0x828A7E98;
	sub_831A8130(ctx, base);
	// 828A7E98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7E9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7EA0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A7EA4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A7EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7EAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A7EB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7EB4: 388A5E78  addi r4, r10, 0x5e78
	ctx.r[4].s64 = ctx.r[10].s64 + 24184;
	// 828A7EB8: 4BAB7BB9  bl 0x8235fa70
	ctx.lr = 0x828A7EBC;
	sub_8235FA70(ctx, base);
	// 828A7EBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7EC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7EC4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A7EC8: 4854BD39  bl 0x82df3c00
	ctx.lr = 0x828A7ECC;
	sub_82DF3C00(ctx, base);
	// 828A7ECC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7ED4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A7ED8: 485B4281  bl 0x82e5c158
	ctx.lr = 0x828A7EDC;
	sub_82E5C158(ctx, base);
	// 828A7EDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7EE0: 4854B549  bl 0x82df3428
	ctx.lr = 0x828A7EE4;
	sub_82DF3428(ctx, base);
	// 828A7EE4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A7EE8: 489002D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7EF0 size=92
    let mut pc: u32 = 0x828A7EF0;
    'dispatch: loop {
        match pc {
            0x828A7EF0 => {
    //   block [0x828A7EF0..0x828A7F4C)
	// 828A7EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7EF4: 48900279  bl 0x831a816c
	ctx.lr = 0x828A7EF8;
	sub_831A8130(ctx, base);
	// 828A7EF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7EFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7F00: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A7F04: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A7F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7F0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A7F10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7F14: 388A5EE8  addi r4, r10, 0x5ee8
	ctx.r[4].s64 = ctx.r[10].s64 + 24296;
	// 828A7F18: 4BAB7B59  bl 0x8235fa70
	ctx.lr = 0x828A7F1C;
	sub_8235FA70(ctx, base);
	// 828A7F1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7F24: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A7F28: 4854BCD9  bl 0x82df3c00
	ctx.lr = 0x828A7F2C;
	sub_82DF3C00(ctx, base);
	// 828A7F2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7F30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7F34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A7F38: 485B4221  bl 0x82e5c158
	ctx.lr = 0x828A7F3C;
	sub_82E5C158(ctx, base);
	// 828A7F3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7F40: 4854B4E9  bl 0x82df3428
	ctx.lr = 0x828A7F44;
	sub_82DF3428(ctx, base);
	// 828A7F44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A7F48: 48900274  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7F50 size=92
    let mut pc: u32 = 0x828A7F50;
    'dispatch: loop {
        match pc {
            0x828A7F50 => {
    //   block [0x828A7F50..0x828A7FAC)
	// 828A7F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7F54: 48900219  bl 0x831a816c
	ctx.lr = 0x828A7F58;
	sub_831A8130(ctx, base);
	// 828A7F58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7F5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7F60: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A7F64: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A7F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7F6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A7F70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7F74: 388A5F58  addi r4, r10, 0x5f58
	ctx.r[4].s64 = ctx.r[10].s64 + 24408;
	// 828A7F78: 4BAB7AF9  bl 0x8235fa70
	ctx.lr = 0x828A7F7C;
	sub_8235FA70(ctx, base);
	// 828A7F7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7F80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7F84: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A7F88: 4854BC79  bl 0x82df3c00
	ctx.lr = 0x828A7F8C;
	sub_82DF3C00(ctx, base);
	// 828A7F8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7F94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A7F98: 485B41C1  bl 0x82e5c158
	ctx.lr = 0x828A7F9C;
	sub_82E5C158(ctx, base);
	// 828A7F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A7FA0: 4854B489  bl 0x82df3428
	ctx.lr = 0x828A7FA4;
	sub_82DF3428(ctx, base);
	// 828A7FA4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A7FA8: 48900214  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A7FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A7FB0 size=92
    let mut pc: u32 = 0x828A7FB0;
    'dispatch: loop {
        match pc {
            0x828A7FB0 => {
    //   block [0x828A7FB0..0x828A800C)
	// 828A7FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A7FB4: 489001B9  bl 0x831a816c
	ctx.lr = 0x828A7FB8;
	sub_831A8130(ctx, base);
	// 828A7FB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A7FBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A7FC0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A7FC4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A7FC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A7FCC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A7FD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A7FD4: 388A5FC8  addi r4, r10, 0x5fc8
	ctx.r[4].s64 = ctx.r[10].s64 + 24520;
	// 828A7FD8: 4BAB7A99  bl 0x8235fa70
	ctx.lr = 0x828A7FDC;
	sub_8235FA70(ctx, base);
	// 828A7FDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A7FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A7FE4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A7FE8: 4854BC19  bl 0x82df3c00
	ctx.lr = 0x828A7FEC;
	sub_82DF3C00(ctx, base);
	// 828A7FEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A7FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A7FF4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A7FF8: 485B4161  bl 0x82e5c158
	ctx.lr = 0x828A7FFC;
	sub_82E5C158(ctx, base);
	// 828A7FFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8000: 4854B429  bl 0x82df3428
	ctx.lr = 0x828A8004;
	sub_82DF3428(ctx, base);
	// 828A8004: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8008: 489001B4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8010 size=92
    let mut pc: u32 = 0x828A8010;
    'dispatch: loop {
        match pc {
            0x828A8010 => {
    //   block [0x828A8010..0x828A806C)
	// 828A8010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8014: 48900159  bl 0x831a816c
	ctx.lr = 0x828A8018;
	sub_831A8130(ctx, base);
	// 828A8018: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A801C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8020: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8024: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8028: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A802C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8030: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8034: 388A6038  addi r4, r10, 0x6038
	ctx.r[4].s64 = ctx.r[10].s64 + 24632;
	// 828A8038: 4BAB7A39  bl 0x8235fa70
	ctx.lr = 0x828A803C;
	sub_8235FA70(ctx, base);
	// 828A803C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8040: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8044: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8048: 4854BBB9  bl 0x82df3c00
	ctx.lr = 0x828A804C;
	sub_82DF3C00(ctx, base);
	// 828A804C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8054: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8058: 485B4101  bl 0x82e5c158
	ctx.lr = 0x828A805C;
	sub_82E5C158(ctx, base);
	// 828A805C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8060: 4854B3C9  bl 0x82df3428
	ctx.lr = 0x828A8064;
	sub_82DF3428(ctx, base);
	// 828A8064: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8068: 48900154  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8070 size=92
    let mut pc: u32 = 0x828A8070;
    'dispatch: loop {
        match pc {
            0x828A8070 => {
    //   block [0x828A8070..0x828A80CC)
	// 828A8070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8074: 489000F9  bl 0x831a816c
	ctx.lr = 0x828A8078;
	sub_831A8130(ctx, base);
	// 828A8078: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A807C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8080: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8084: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A808C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8090: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8094: 388A60A8  addi r4, r10, 0x60a8
	ctx.r[4].s64 = ctx.r[10].s64 + 24744;
	// 828A8098: 4BAB79D9  bl 0x8235fa70
	ctx.lr = 0x828A809C;
	sub_8235FA70(ctx, base);
	// 828A809C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A80A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A80A4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A80A8: 4854BB59  bl 0x82df3c00
	ctx.lr = 0x828A80AC;
	sub_82DF3C00(ctx, base);
	// 828A80AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A80B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A80B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A80B8: 485B40A1  bl 0x82e5c158
	ctx.lr = 0x828A80BC;
	sub_82E5C158(ctx, base);
	// 828A80BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A80C0: 4854B369  bl 0x82df3428
	ctx.lr = 0x828A80C4;
	sub_82DF3428(ctx, base);
	// 828A80C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A80C8: 489000F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A80D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A80D0 size=92
    let mut pc: u32 = 0x828A80D0;
    'dispatch: loop {
        match pc {
            0x828A80D0 => {
    //   block [0x828A80D0..0x828A812C)
	// 828A80D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A80D4: 48900099  bl 0x831a816c
	ctx.lr = 0x828A80D8;
	sub_831A8130(ctx, base);
	// 828A80D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A80DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A80E0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A80E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A80E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A80EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A80F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A80F4: 388A6118  addi r4, r10, 0x6118
	ctx.r[4].s64 = ctx.r[10].s64 + 24856;
	// 828A80F8: 4BAB7979  bl 0x8235fa70
	ctx.lr = 0x828A80FC;
	sub_8235FA70(ctx, base);
	// 828A80FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8104: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8108: 4854BAF9  bl 0x82df3c00
	ctx.lr = 0x828A810C;
	sub_82DF3C00(ctx, base);
	// 828A810C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8114: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8118: 485B4041  bl 0x82e5c158
	ctx.lr = 0x828A811C;
	sub_82E5C158(ctx, base);
	// 828A811C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8120: 4854B309  bl 0x82df3428
	ctx.lr = 0x828A8124;
	sub_82DF3428(ctx, base);
	// 828A8124: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8128: 48900094  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8130 size=92
    let mut pc: u32 = 0x828A8130;
    'dispatch: loop {
        match pc {
            0x828A8130 => {
    //   block [0x828A8130..0x828A818C)
	// 828A8130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8134: 48900039  bl 0x831a816c
	ctx.lr = 0x828A8138;
	sub_831A8130(ctx, base);
	// 828A8138: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A813C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8140: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8144: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8148: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A814C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8150: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8154: 388A6188  addi r4, r10, 0x6188
	ctx.r[4].s64 = ctx.r[10].s64 + 24968;
	// 828A8158: 4BAB7919  bl 0x8235fa70
	ctx.lr = 0x828A815C;
	sub_8235FA70(ctx, base);
	// 828A815C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8164: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8168: 4854BA99  bl 0x82df3c00
	ctx.lr = 0x828A816C;
	sub_82DF3C00(ctx, base);
	// 828A816C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8174: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8178: 485B3FE1  bl 0x82e5c158
	ctx.lr = 0x828A817C;
	sub_82E5C158(ctx, base);
	// 828A817C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8180: 4854B2A9  bl 0x82df3428
	ctx.lr = 0x828A8184;
	sub_82DF3428(ctx, base);
	// 828A8184: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8188: 48900034  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8190 size=92
    let mut pc: u32 = 0x828A8190;
    'dispatch: loop {
        match pc {
            0x828A8190 => {
    //   block [0x828A8190..0x828A81EC)
	// 828A8190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8194: 488FFFD9  bl 0x831a816c
	ctx.lr = 0x828A8198;
	sub_831A8130(ctx, base);
	// 828A8198: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A819C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A81A0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A81A4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A81A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A81AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A81B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A81B4: 388A61F8  addi r4, r10, 0x61f8
	ctx.r[4].s64 = ctx.r[10].s64 + 25080;
	// 828A81B8: 4BAB78B9  bl 0x8235fa70
	ctx.lr = 0x828A81BC;
	sub_8235FA70(ctx, base);
	// 828A81BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A81C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A81C4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A81C8: 4854BA39  bl 0x82df3c00
	ctx.lr = 0x828A81CC;
	sub_82DF3C00(ctx, base);
	// 828A81CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A81D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A81D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A81D8: 485B3F81  bl 0x82e5c158
	ctx.lr = 0x828A81DC;
	sub_82E5C158(ctx, base);
	// 828A81DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A81E0: 4854B249  bl 0x82df3428
	ctx.lr = 0x828A81E4;
	sub_82DF3428(ctx, base);
	// 828A81E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A81E8: 488FFFD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A81F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A81F0 size=92
    let mut pc: u32 = 0x828A81F0;
    'dispatch: loop {
        match pc {
            0x828A81F0 => {
    //   block [0x828A81F0..0x828A824C)
	// 828A81F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A81F4: 488FFF79  bl 0x831a816c
	ctx.lr = 0x828A81F8;
	sub_831A8130(ctx, base);
	// 828A81F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A81FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8200: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8204: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A820C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8210: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8214: 388A6268  addi r4, r10, 0x6268
	ctx.r[4].s64 = ctx.r[10].s64 + 25192;
	// 828A8218: 4BAB7859  bl 0x8235fa70
	ctx.lr = 0x828A821C;
	sub_8235FA70(ctx, base);
	// 828A821C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8224: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8228: 4854B9D9  bl 0x82df3c00
	ctx.lr = 0x828A822C;
	sub_82DF3C00(ctx, base);
	// 828A822C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8234: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8238: 485B3F21  bl 0x82e5c158
	ctx.lr = 0x828A823C;
	sub_82E5C158(ctx, base);
	// 828A823C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8240: 4854B1E9  bl 0x82df3428
	ctx.lr = 0x828A8244;
	sub_82DF3428(ctx, base);
	// 828A8244: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8248: 488FFF74  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8250 size=92
    let mut pc: u32 = 0x828A8250;
    'dispatch: loop {
        match pc {
            0x828A8250 => {
    //   block [0x828A8250..0x828A82AC)
	// 828A8250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8254: 488FFF19  bl 0x831a816c
	ctx.lr = 0x828A8258;
	sub_831A8130(ctx, base);
	// 828A8258: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A825C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8260: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8264: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A826C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8270: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8274: 388A62D8  addi r4, r10, 0x62d8
	ctx.r[4].s64 = ctx.r[10].s64 + 25304;
	// 828A8278: 4BAB77F9  bl 0x8235fa70
	ctx.lr = 0x828A827C;
	sub_8235FA70(ctx, base);
	// 828A827C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8284: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8288: 4854B979  bl 0x82df3c00
	ctx.lr = 0x828A828C;
	sub_82DF3C00(ctx, base);
	// 828A828C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8294: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8298: 485B3EC1  bl 0x82e5c158
	ctx.lr = 0x828A829C;
	sub_82E5C158(ctx, base);
	// 828A829C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A82A0: 4854B189  bl 0x82df3428
	ctx.lr = 0x828A82A4;
	sub_82DF3428(ctx, base);
	// 828A82A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A82A8: 488FFF14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A82B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A82B0 size=92
    let mut pc: u32 = 0x828A82B0;
    'dispatch: loop {
        match pc {
            0x828A82B0 => {
    //   block [0x828A82B0..0x828A830C)
	// 828A82B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A82B4: 488FFEB9  bl 0x831a816c
	ctx.lr = 0x828A82B8;
	sub_831A8130(ctx, base);
	// 828A82B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A82BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A82C0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A82C4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A82C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A82CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A82D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A82D4: 388A6348  addi r4, r10, 0x6348
	ctx.r[4].s64 = ctx.r[10].s64 + 25416;
	// 828A82D8: 4BAB7799  bl 0x8235fa70
	ctx.lr = 0x828A82DC;
	sub_8235FA70(ctx, base);
	// 828A82DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A82E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A82E4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A82E8: 4854B919  bl 0x82df3c00
	ctx.lr = 0x828A82EC;
	sub_82DF3C00(ctx, base);
	// 828A82EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A82F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A82F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A82F8: 485B3E61  bl 0x82e5c158
	ctx.lr = 0x828A82FC;
	sub_82E5C158(ctx, base);
	// 828A82FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8300: 4854B129  bl 0x82df3428
	ctx.lr = 0x828A8304;
	sub_82DF3428(ctx, base);
	// 828A8304: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8308: 488FFEB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8310 size=92
    let mut pc: u32 = 0x828A8310;
    'dispatch: loop {
        match pc {
            0x828A8310 => {
    //   block [0x828A8310..0x828A836C)
	// 828A8310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8314: 488FFE59  bl 0x831a816c
	ctx.lr = 0x828A8318;
	sub_831A8130(ctx, base);
	// 828A8318: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A831C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8320: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8324: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A832C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8330: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8334: 388A63B8  addi r4, r10, 0x63b8
	ctx.r[4].s64 = ctx.r[10].s64 + 25528;
	// 828A8338: 4BAB7739  bl 0x8235fa70
	ctx.lr = 0x828A833C;
	sub_8235FA70(ctx, base);
	// 828A833C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8344: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8348: 4854B8B9  bl 0x82df3c00
	ctx.lr = 0x828A834C;
	sub_82DF3C00(ctx, base);
	// 828A834C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8354: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8358: 485B3E01  bl 0x82e5c158
	ctx.lr = 0x828A835C;
	sub_82E5C158(ctx, base);
	// 828A835C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8360: 4854B0C9  bl 0x82df3428
	ctx.lr = 0x828A8364;
	sub_82DF3428(ctx, base);
	// 828A8364: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8368: 488FFE54  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8370 size=92
    let mut pc: u32 = 0x828A8370;
    'dispatch: loop {
        match pc {
            0x828A8370 => {
    //   block [0x828A8370..0x828A83CC)
	// 828A8370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8374: 488FFDF9  bl 0x831a816c
	ctx.lr = 0x828A8378;
	sub_831A8130(ctx, base);
	// 828A8378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A837C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8380: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8384: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A838C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8390: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8394: 388A6428  addi r4, r10, 0x6428
	ctx.r[4].s64 = ctx.r[10].s64 + 25640;
	// 828A8398: 4BAB76D9  bl 0x8235fa70
	ctx.lr = 0x828A839C;
	sub_8235FA70(ctx, base);
	// 828A839C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A83A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A83A4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A83A8: 4854B859  bl 0x82df3c00
	ctx.lr = 0x828A83AC;
	sub_82DF3C00(ctx, base);
	// 828A83AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A83B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A83B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A83B8: 485B3DA1  bl 0x82e5c158
	ctx.lr = 0x828A83BC;
	sub_82E5C158(ctx, base);
	// 828A83BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A83C0: 4854B069  bl 0x82df3428
	ctx.lr = 0x828A83C4;
	sub_82DF3428(ctx, base);
	// 828A83C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A83C8: 488FFDF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A83D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A83D0 size=92
    let mut pc: u32 = 0x828A83D0;
    'dispatch: loop {
        match pc {
            0x828A83D0 => {
    //   block [0x828A83D0..0x828A842C)
	// 828A83D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A83D4: 488FFD99  bl 0x831a816c
	ctx.lr = 0x828A83D8;
	sub_831A8130(ctx, base);
	// 828A83D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A83DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A83E0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A83E4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A83E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A83EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A83F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A83F4: 388A6498  addi r4, r10, 0x6498
	ctx.r[4].s64 = ctx.r[10].s64 + 25752;
	// 828A83F8: 4BAB7679  bl 0x8235fa70
	ctx.lr = 0x828A83FC;
	sub_8235FA70(ctx, base);
	// 828A83FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8404: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8408: 4854B7F9  bl 0x82df3c00
	ctx.lr = 0x828A840C;
	sub_82DF3C00(ctx, base);
	// 828A840C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8414: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8418: 485B3D41  bl 0x82e5c158
	ctx.lr = 0x828A841C;
	sub_82E5C158(ctx, base);
	// 828A841C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8420: 4854B009  bl 0x82df3428
	ctx.lr = 0x828A8424;
	sub_82DF3428(ctx, base);
	// 828A8424: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8428: 488FFD94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8430 size=92
    let mut pc: u32 = 0x828A8430;
    'dispatch: loop {
        match pc {
            0x828A8430 => {
    //   block [0x828A8430..0x828A848C)
	// 828A8430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8434: 488FFD39  bl 0x831a816c
	ctx.lr = 0x828A8438;
	sub_831A8130(ctx, base);
	// 828A8438: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A843C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8440: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8444: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A844C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8450: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8454: 388A6508  addi r4, r10, 0x6508
	ctx.r[4].s64 = ctx.r[10].s64 + 25864;
	// 828A8458: 4BAB7619  bl 0x8235fa70
	ctx.lr = 0x828A845C;
	sub_8235FA70(ctx, base);
	// 828A845C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8460: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8464: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8468: 4854B799  bl 0x82df3c00
	ctx.lr = 0x828A846C;
	sub_82DF3C00(ctx, base);
	// 828A846C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8474: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8478: 485B3CE1  bl 0x82e5c158
	ctx.lr = 0x828A847C;
	sub_82E5C158(ctx, base);
	// 828A847C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8480: 4854AFA9  bl 0x82df3428
	ctx.lr = 0x828A8484;
	sub_82DF3428(ctx, base);
	// 828A8484: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8488: 488FFD34  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8490 size=92
    let mut pc: u32 = 0x828A8490;
    'dispatch: loop {
        match pc {
            0x828A8490 => {
    //   block [0x828A8490..0x828A84EC)
	// 828A8490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8494: 488FFCD9  bl 0x831a816c
	ctx.lr = 0x828A8498;
	sub_831A8130(ctx, base);
	// 828A8498: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A849C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A84A0: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A84A4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A84A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A84AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A84B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A84B4: 388A6578  addi r4, r10, 0x6578
	ctx.r[4].s64 = ctx.r[10].s64 + 25976;
	// 828A84B8: 4BAB75B9  bl 0x8235fa70
	ctx.lr = 0x828A84BC;
	sub_8235FA70(ctx, base);
	// 828A84BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A84C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A84C4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A84C8: 4854B739  bl 0x82df3c00
	ctx.lr = 0x828A84CC;
	sub_82DF3C00(ctx, base);
	// 828A84CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A84D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A84D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A84D8: 485B3C81  bl 0x82e5c158
	ctx.lr = 0x828A84DC;
	sub_82E5C158(ctx, base);
	// 828A84DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A84E0: 4854AF49  bl 0x82df3428
	ctx.lr = 0x828A84E4;
	sub_82DF3428(ctx, base);
	// 828A84E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A84E8: 488FFCD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A84F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A84F0 size=92
    let mut pc: u32 = 0x828A84F0;
    'dispatch: loop {
        match pc {
            0x828A84F0 => {
    //   block [0x828A84F0..0x828A854C)
	// 828A84F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A84F4: 488FFC79  bl 0x831a816c
	ctx.lr = 0x828A84F8;
	sub_831A8130(ctx, base);
	// 828A84F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A84FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8500: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8504: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A850C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8510: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8514: 388A65E8  addi r4, r10, 0x65e8
	ctx.r[4].s64 = ctx.r[10].s64 + 26088;
	// 828A8518: 4BAB7559  bl 0x8235fa70
	ctx.lr = 0x828A851C;
	sub_8235FA70(ctx, base);
	// 828A851C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8524: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8528: 4854B6D9  bl 0x82df3c00
	ctx.lr = 0x828A852C;
	sub_82DF3C00(ctx, base);
	// 828A852C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8534: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8538: 485B3C21  bl 0x82e5c158
	ctx.lr = 0x828A853C;
	sub_82E5C158(ctx, base);
	// 828A853C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8540: 4854AEE9  bl 0x82df3428
	ctx.lr = 0x828A8544;
	sub_82DF3428(ctx, base);
	// 828A8544: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A8548: 488FFC74  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8550 size=92
    let mut pc: u32 = 0x828A8550;
    'dispatch: loop {
        match pc {
            0x828A8550 => {
    //   block [0x828A8550..0x828A85AC)
	// 828A8550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8554: 488FFC19  bl 0x831a816c
	ctx.lr = 0x828A8558;
	sub_831A8130(ctx, base);
	// 828A8558: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A855C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828A8560: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A8564: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828A8568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A856C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828A8570: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8574: 388A6658  addi r4, r10, 0x6658
	ctx.r[4].s64 = ctx.r[10].s64 + 26200;
	// 828A8578: 4BAB74F9  bl 0x8235fa70
	ctx.lr = 0x828A857C;
	sub_8235FA70(ctx, base);
	// 828A857C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A8584: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828A8588: 4854B679  bl 0x82df3c00
	ctx.lr = 0x828A858C;
	sub_82DF3C00(ctx, base);
	// 828A858C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8594: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828A8598: 485B3BC1  bl 0x82e5c158
	ctx.lr = 0x828A859C;
	sub_82E5C158(ctx, base);
	// 828A859C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A85A0: 4854AE89  bl 0x82df3428
	ctx.lr = 0x828A85A4;
	sub_82DF3428(ctx, base);
	// 828A85A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828A85A8: 488FFC14  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A85B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A85B0 size=128
    let mut pc: u32 = 0x828A85B0;
    'dispatch: loop {
        match pc {
            0x828A85B0 => {
    //   block [0x828A85B0..0x828A8630)
	// 828A85B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A85B4: 488FFBB9  bl 0x831a816c
	ctx.lr = 0x828A85B8;
	sub_831A8130(ctx, base);
	// 828A85B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A85BC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828A85C0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A85C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A85C8: 3BEBED78  addi r31, r11, -0x1288
	ctx.r[31].s64 = ctx.r[11].s64 + -4744;
	// 828A85CC: 816AED80  lwz r11, -0x1280(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4736 as u32) ) } as u64;
	// 828A85D0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828A85D4: 40820024  bne 0x828a85f8
	if !ctx.cr[0].eq {
	pc = 0x828A85F8; continue 'dispatch;
	}
	// 828A85D8: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 828A85DC: 3D00828A  lis r8, -0x7d76
	ctx.r[8].s64 = -2104885248;
	// 828A85E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828A85E4: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 828A85E8: 39085460  addi r8, r8, 0x5460
	ctx.r[8].s64 = ctx.r[8].s64 + 21600;
	// 828A85EC: 916AED80  stw r11, -0x1280(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4736 as u32), ctx.r[11].u32 ) };
	// 828A85F0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A85F4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828A85F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A85FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A8600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8604: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828A8608: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828A860C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A8610: 4BDABFB1  bl 0x826545c0
	ctx.lr = 0x828A8614;
	sub_826545C0(ctx, base);
	// 828A8614: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8618: 4182000C  beq 0x828a8624
	if ctx.cr[0].eq {
	pc = 0x828A8624; continue 'dispatch;
	}
	// 828A861C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A8620: 48000008  b 0x828a8628
	pc = 0x828A8628; continue 'dispatch;
	// 828A8624: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A8628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A862C: 488FFB90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8630 size=128
    let mut pc: u32 = 0x828A8630;
    'dispatch: loop {
        match pc {
            0x828A8630 => {
    //   block [0x828A8630..0x828A86B0)
	// 828A8630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8634: 488FFB39  bl 0x831a816c
	ctx.lr = 0x828A8638;
	sub_831A8130(ctx, base);
	// 828A8638: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A863C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828A8640: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A8644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A8648: 3BEBED84  addi r31, r11, -0x127c
	ctx.r[31].s64 = ctx.r[11].s64 + -4732;
	// 828A864C: 816AED8C  lwz r11, -0x1274(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4724 as u32) ) } as u64;
	// 828A8650: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828A8654: 40820024  bne 0x828a8678
	if !ctx.cr[0].eq {
	pc = 0x828A8678; continue 'dispatch;
	}
	// 828A8658: 3D208289  lis r9, -0x7d77
	ctx.r[9].s64 = -2104950784;
	// 828A865C: 3D00828A  lis r8, -0x7d76
	ctx.r[8].s64 = -2104885248;
	// 828A8660: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828A8664: 392990C8  addi r9, r9, -0x6f38
	ctx.r[9].s64 = ctx.r[9].s64 + -28472;
	// 828A8668: 390854A8  addi r8, r8, 0x54a8
	ctx.r[8].s64 = ctx.r[8].s64 + 21672;
	// 828A866C: 916AED8C  stw r11, -0x1274(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4724 as u32), ctx.r[11].u32 ) };
	// 828A8670: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A8674: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828A8678: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A867C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A8680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8684: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828A8688: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828A868C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A8690: 4BDABF31  bl 0x826545c0
	ctx.lr = 0x828A8694;
	sub_826545C0(ctx, base);
	// 828A8694: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8698: 4182000C  beq 0x828a86a4
	if ctx.cr[0].eq {
	pc = 0x828A86A4; continue 'dispatch;
	}
	// 828A869C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A86A0: 48000008  b 0x828a86a8
	pc = 0x828A86A8; continue 'dispatch;
	// 828A86A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A86A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A86AC: 488FFB10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A86B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A86B0 size=128
    let mut pc: u32 = 0x828A86B0;
    'dispatch: loop {
        match pc {
            0x828A86B0 => {
    //   block [0x828A86B0..0x828A8730)
	// 828A86B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A86B4: 488FFAB9  bl 0x831a816c
	ctx.lr = 0x828A86B8;
	sub_831A8130(ctx, base);
	// 828A86B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A86BC: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828A86C0: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A86C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A86C8: 3BEBED90  addi r31, r11, -0x1270
	ctx.r[31].s64 = ctx.r[11].s64 + -4720;
	// 828A86CC: 816AED98  lwz r11, -0x1268(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4712 as u32) ) } as u64;
	// 828A86D0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828A86D4: 40820024  bne 0x828a86f8
	if !ctx.cr[0].eq {
	pc = 0x828A86F8; continue 'dispatch;
	}
	// 828A86D8: 3D20828B  lis r9, -0x7d75
	ctx.r[9].s64 = -2104819712;
	// 828A86DC: 3D00828A  lis r8, -0x7d76
	ctx.r[8].s64 = -2104885248;
	// 828A86E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828A86E4: 392956D8  addi r9, r9, 0x56d8
	ctx.r[9].s64 = ctx.r[9].s64 + 22232;
	// 828A86E8: 39087918  addi r8, r8, 0x7918
	ctx.r[8].s64 = ctx.r[8].s64 + 31000;
	// 828A86EC: 916AED98  stw r11, -0x1268(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4712 as u32), ctx.r[11].u32 ) };
	// 828A86F0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A86F4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828A86F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A86FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A8700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8704: 391E0008  addi r8, r30, 8
	ctx.r[8].s64 = ctx.r[30].s64 + 8;
	// 828A8708: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828A870C: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A8710: 4BFFDFB9  bl 0x828a66c8
	ctx.lr = 0x828A8714;
	sub_828A66C8(ctx, base);
	// 828A8714: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8718: 4182000C  beq 0x828a8724
	if ctx.cr[0].eq {
	pc = 0x828A8724; continue 'dispatch;
	}
	// 828A871C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A8720: 48000008  b 0x828a8728
	pc = 0x828A8728; continue 'dispatch;
	// 828A8724: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A8728: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A872C: 488FFA90  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A8730 size=128
    let mut pc: u32 = 0x828A8730;
    'dispatch: loop {
        match pc {
            0x828A8730 => {
    //   block [0x828A8730..0x828A87B0)
	// 828A8730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8734: 488FFA39  bl 0x831a816c
	ctx.lr = 0x828A8738;
	sub_831A8130(ctx, base);
	// 828A8738: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A873C: 3D408337  lis r10, -0x7cc9
	ctx.r[10].s64 = -2093547520;
	// 828A8740: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A8744: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A8748: 3BEBED9C  addi r31, r11, -0x1264
	ctx.r[31].s64 = ctx.r[11].s64 + -4708;
	// 828A874C: 816AEDA4  lwz r11, -0x125c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4700 as u32) ) } as u64;
	// 828A8750: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828A8754: 40820024  bne 0x828a8778
	if !ctx.cr[0].eq {
	pc = 0x828A8778; continue 'dispatch;
	}
	// 828A8758: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 828A875C: 3D00828A  lis r8, -0x7d76
	ctx.r[8].s64 = -2104885248;
	// 828A8760: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828A8764: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828A8768: 390854F0  addi r8, r8, 0x54f0
	ctx.r[8].s64 = ctx.r[8].s64 + 21744;
	// 828A876C: 916AEDA4  stw r11, -0x125c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4700 as u32), ctx.r[11].u32 ) };
	// 828A8770: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828A8774: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828A8778: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828A877C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828A8780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8784: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828A8788: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828A878C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828A8790: 4BDABE31  bl 0x826545c0
	ctx.lr = 0x828A8794;
	sub_826545C0(ctx, base);
	// 828A8794: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8798: 4182000C  beq 0x828a87a4
	if ctx.cr[0].eq {
	pc = 0x828A87A4; continue 'dispatch;
	}
	// 828A879C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828A87A0: 48000008  b 0x828a87a8
	pc = 0x828A87A8; continue 'dispatch;
	// 828A87A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828A87A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828A87AC: 488FFA10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A87B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A87B0 size=508
    let mut pc: u32 = 0x828A87B0;
    'dispatch: loop {
        match pc {
            0x828A87B0 => {
    //   block [0x828A87B0..0x828A89AC)
	// 828A87B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A87B4: 488FF99D  bl 0x831a8150
	ctx.lr = 0x828A87B8;
	sub_831A8130(ctx, base);
	// 828A87B8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A87BC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A87C0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828A87C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828A87C8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 828A87CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A87D0: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 828A87D4: 409A0008  bne cr6, 0x828a87dc
	if !ctx.cr[6].eq {
	pc = 0x828A87DC; continue 'dispatch;
	}
	// 828A87D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828A87DC: 4BC7F8AD  bl 0x82528088
	ctx.lr = 0x828A87E0;
	sub_82528088(ctx, base);
	// 828A87E0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A87E4: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828A87E8: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828A87EC: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 828A87F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A87F4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 828A87F8: 485F7F39  bl 0x82ea0730
	ctx.lr = 0x828A87FC;
	sub_82EA0730(ctx, base);
	// 828A87FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A8800: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828A8804: 396B9F90  addi r11, r11, -0x6070
	ctx.r[11].s64 = ctx.r[11].s64 + -24688;
	// 828A8808: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 828A880C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 828A8810: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 828A8814: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828A8818: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A89B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828A89B0 size=240
    let mut pc: u32 = 0x828A89B0;
    'dispatch: loop {
        match pc {
            0x828A89B0 => {
    //   block [0x828A89B0..0x828A8AA0)
	// 828A89B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A89B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828A89B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828A89BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828A89C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A89C4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828A89C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828A89CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828A89D0: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 828A89D4: 4BA3C55D  bl 0x822e4f30
	ctx.lr = 0x828A89D8;
	sub_822E4F30(ctx, base);
	// 828A89D8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828A89DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828A89E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828A89E4: 808B6874  lwz r4, 0x6874(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26740 as u32) ) } as u64;
	// 828A89E8: 4BA3C549  bl 0x822e4f30
	ctx.lr = 0x828A89EC;
	sub_822E4F30(ctx, base);
	// 828A89EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A89F0: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828A89F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A89F8: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 828A89FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828A8A00: 4BBE3889  bl 0x8248c288
	ctx.lr = 0x828A8A04;
	sub_8248C288(ctx, base);
	// 828A8A04: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828A8A08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A8A0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A8A10: 4BF7BD81  bl 0x82824790
	ctx.lr = 0x828A8A14;
	sub_82824790(ctx, base);
	// 828A8A14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8A18: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828A8A1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828A8A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8A24: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828A8A28: 419A0024  beq cr6, 0x828a8a4c
	if ctx.cr[6].eq {
	pc = 0x828A8A4C; continue 'dispatch;
	}
	// 828A8A2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A8A30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A8A34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A8A38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A8A3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A8A40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A8A44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A8A48: 4082FFE8  bne 0x828a8a30
	if !ctx.cr[0].eq {
	pc = 0x828A8A30; continue 'dispatch;
	}
	// 828A8A4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828A8A50: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A8A54: 4BF4F625  bl 0x827f8078
	ctx.lr = 0x828A8A58;
	sub_827F8078(ctx, base);
	// 828A8A58: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828A8A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8A60: 419A0008  beq cr6, 0x828a8a68
	if ctx.cr[6].eq {
	pc = 0x828A8A68; continue 'dispatch;
	}
	// 828A8A64: 4BA17E2D  bl 0x822c0890
	ctx.lr = 0x828A8A68;
	sub_822C0890(ctx, base);
	// 828A8A68: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828A8A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8A70: 419A0008  beq cr6, 0x828a8a78
	if ctx.cr[6].eq {
	pc = 0x828A8A78; continue 'dispatch;
	}
	// 828A8A74: 4BA17E1D  bl 0x822c0890
	ctx.lr = 0x828A8A78;
	sub_822C0890(ctx, base);
	// 828A8A78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A8A7C: 807F0388  lwz r3, 0x388(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(904 as u32) ) } as u64;
	// 828A8A80: 388B9F88  addi r4, r11, -0x6078
	ctx.r[4].s64 = ctx.r[11].s64 + -24696;
	// 828A8A84: 4BF4F88D  bl 0x827f8310
	ctx.lr = 0x828A8A88;
	sub_827F8310(ctx, base);
	// 828A8A88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828A8A8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828A8A90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828A8A94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828A8A98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828A8A9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828A8AA0 size=4
    let mut pc: u32 = 0x828A8AA0;
    'dispatch: loop {
        match pc {
            0x828A8AA0 => {
    //   block [0x828A8AA0..0x828A8AA4)
	// 828A8AA0: 4BFFFF10  b 0x828a89b0
	sub_828A89B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828A8AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828A8AA8 size=11008
    let mut pc: u32 = 0x828A8AA8;
    'dispatch: loop {
        match pc {
            0x828A8AA8 => {
    //   block [0x828A8AA8..0x828AB5A8)
	// 828A8AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828A8AAC: 488FF685  bl 0x831a8130
	ctx.lr = 0x828A8AB0;
	sub_831A8130(ctx, base);
	// 828A8AB0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 828A8AB4: 488FFFB5  bl 0x831a8a68
	ctx.lr = 0x828A8AB8;
	sub_831A8A40(ctx, base);
	// 828A8AB8: 9421FCC0  stwu r1, -0x340(r1)
	ea = ctx.r[1].u32.wrapping_add(-832 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828A8ABC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828A8AC0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 828A8AC4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828A8AC8: 93810354  stw r28, 0x354(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(852 as u32), ctx.r[28].u32 ) };
	// 828A8ACC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 828A8AD0: 9321035C  stw r25, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[25].u32 ) };
	// 828A8AD4: 93C10364  stw r30, 0x364(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[30].u32 ) };
	// 828A8AD8: 9341036C  stw r26, 0x36c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(876 as u32), ctx.r[26].u32 ) };
	// 828A8ADC: 480682B5  bl 0x82910d90
	ctx.lr = 0x828A8AE0;
	sub_82910D90(ctx, base);
	// 828A8AE0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828A8AE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A8AE8: 4BC66889  bl 0x8250f370
	ctx.lr = 0x828A8AEC;
	sub_8250F370(ctx, base);
	// 828A8AEC: 37BCFFF0  addic. r29, r28, -0x10
	ctx.xer.ca = (ctx.r[28].u32 > (!(-16 as u32)));
	ctx.r[29].s64 = ctx.r[28].s64 + -16;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828A8AF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828A8AF4: 93A100C8  stw r29, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 828A8AF8: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 828A8AFC: 40820008  bne 0x828a8b04
	if !ctx.cr[0].eq {
	pc = 0x828A8B04; continue 'dispatch;
	}
	// 828A8B00: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 828A8B04: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 828A8B08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8B0C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 828A8B10: 4854AEF9  bl 0x82df3a08
	ctx.lr = 0x828A8B14;
	sub_82DF3A08(ctx, base);
	// 828A8B14: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828A8B18: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8B1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8B20: 4BC5FC61  bl 0x82508780
	ctx.lr = 0x828A8B24;
	sub_82508780(ctx, base);
	// 828A8B24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8B28: 4854A901  bl 0x82df3428
	ctx.lr = 0x828A8B2C;
	sub_82DF3428(ctx, base);
	// 828A8B2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828A8B30: 389C0028  addi r4, r28, 0x28
	ctx.r[4].s64 = ctx.r[28].s64 + 40;
	// 828A8B34: 409A0008  bne cr6, 0x828a8b3c
	if !ctx.cr[6].eq {
	pc = 0x828A8B3C; continue 'dispatch;
	}
	// 828A8B38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A8B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8B40: 4BC5FC61  bl 0x825087a0
	ctx.lr = 0x828A8B44;
	sub_825087A0(ctx, base);
	// 828A8B44: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828A8B48: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828A8B4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8B50: 396BC870  addi r11, r11, -0x3790
	ctx.r[11].s64 = ctx.r[11].s64 + -14224;
	// 828A8B54: 808A0B68  lwz r4, 0xb68(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828A8B58: 815C03BC  lwz r10, 0x3bc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(956 as u32) ) } as u64;
	// 828A8B5C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8B60: 1D4A03B4  mulli r10, r10, 0x3b4
	ctx.r[10].s64 = ctx.r[10].s64 * 948;
	// 828A8B64: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828A8B68: 916100D4  stw r11, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 828A8B6C: 4854AE9D  bl 0x82df3a08
	ctx.lr = 0x828A8B70;
	sub_82DF3A08(ctx, base);
	// 828A8B70: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828A8B74: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828A8B78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A8B7C: 48067A85  bl 0x82910600
	ctx.lr = 0x828A8B80;
	sub_82910600(ctx, base);
	// 828A8B80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8B84: 4854A8A5  bl 0x82df3428
	ctx.lr = 0x828A8B88;
	sub_82DF3428(ctx, base);
	// 828A8B88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A8B8C: 48067D35  bl 0x829108c0
	ctx.lr = 0x828A8B90;
	sub_829108C0(ctx, base);
	// 828A8B90: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828A8B94: 41820010  beq 0x828a8ba4
	if ctx.cr[0].eq {
	pc = 0x828A8BA4; continue 'dispatch;
	}
	// 828A8B98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828A8B9C: 4BC67A35  bl 0x825105d0
	ctx.lr = 0x828A8BA0;
	sub_825105D0(ctx, base);
	// 828A8BA0: 480029F8  b 0x828ab598
	pc = 0x828AB598; continue 'dispatch;
	// 828A8BA4: 3BBCFFF0  addi r29, r28, -0x10
	ctx.r[29].s64 = ctx.r[28].s64 + -16;
	// 828A8BA8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828A8BAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A8BB0: 4BFFFC01  bl 0x828a87b0
	ctx.lr = 0x828A8BB4;
	sub_828A87B0(ctx, base);
	// 828A8BB4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828A8BB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828A8BBC: 4BFFEFA5  bl 0x828a7b60
	ctx.lr = 0x828A8BC0;
	sub_828A7B60(ctx, base);
	// 828A8BC0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A8BC4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A8BC8: 3B6B9F00  addi r27, r11, -0x6100
	ctx.r[27].s64 = ctx.r[11].s64 + -24832;
	// 828A8BCC: 38A000D8  li r5, 0xd8
	ctx.r[5].s64 = 216;
	// 828A8BD0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A8BD4: 936100D0  stw r27, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 828A8BD8: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828A8BDC: 4BA177FD  bl 0x822c03d8
	ctx.lr = 0x828A8BE0;
	sub_822C03D8(ctx, base);
	// 828A8BE0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828A8BE4: 41820020  beq 0x828a8c04
	if ctx.cr[0].eq {
	pc = 0x828A8C04; continue 'dispatch;
	}
	// 828A8BE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8BEC: 4BF420C5  bl 0x827eacb0
	ctx.lr = 0x828A8BF0;
	sub_827EACB0(ctx, base);
	// 828A8BF0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A8BF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828A8BF8: 396B09D8  addi r11, r11, 0x9d8
	ctx.r[11].s64 = ctx.r[11].s64 + 2520;
	// 828A8BFC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A8C00: 48000008  b 0x828a8c08
	pc = 0x828A8C08; continue 'dispatch;
	// 828A8C04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828A8C08: 3BDC0368  addi r30, r28, 0x368
	ctx.r[30].s64 = ctx.r[28].s64 + 872;
	// 828A8C0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828A8C10: 4BFBF671  bl 0x82868280
	ctx.lr = 0x828A8C14;
	sub_82868280(ctx, base);
	// 828A8C14: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8C18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8C1C: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828A8C20: 4854ADE9  bl 0x82df3a08
	ctx.lr = 0x828A8C24;
	sub_82DF3A08(ctx, base);
	// 828A8C24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A8C28: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 828A8C2C: 3B410054  addi r26, r1, 0x54
	ctx.r[26].s64 = ctx.r[1].s64 + 84;
	// 828A8C30: 833C0368  lwz r25, 0x368(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(872 as u32) ) } as u64;
	// 828A8C34: 4BC66895  bl 0x8250f4c8
	ctx.lr = 0x828A8C38;
	sub_8250F4C8(ctx, base);
	// 828A8C38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A8C3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8C40: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828A8C44: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828A8C48: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A8C4C: 4BF41D1D  bl 0x827ea968
	ctx.lr = 0x828A8C50;
	sub_827EA968(ctx, base);
	// 828A8C50: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 828A8C54: 4854903D  bl 0x82df1c90
	ctx.lr = 0x828A8C58;
	sub_82DF1C90(ctx, base);
	// 828A8C58: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8C5C: 4854A7CD  bl 0x82df3428
	ctx.lr = 0x828A8C60;
	sub_82DF3428(ctx, base);
	// 828A8C60: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A8C64: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828A8C68: 807C0368  lwz r3, 0x368(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(872 as u32) ) } as u64;
	// 828A8C6C: 388A0B78  addi r4, r10, 0xb78
	ctx.r[4].s64 = ctx.r[10].s64 + 2936;
	// 828A8C70: 80ABA24C  lwz r5, -0x5db4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23988 as u32) ) } as u64;
	// 828A8C74: 4BF41A4D  bl 0x827ea6c0
	ctx.lr = 0x828A8C78;
	sub_827EA6C0(ctx, base);
	// 828A8C78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828A8C7C: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 828A8C80: 4BF43949  bl 0x827ec5c8
	ctx.lr = 0x828A8C84;
	sub_827EC5C8(ctx, base);
	// 828A8C84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828A8C88: 807C0368  lwz r3, 0x368(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(872 as u32) ) } as u64;
	// 828A8C8C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8C90: 4BF41A39  bl 0x827ea6c8
	ctx.lr = 0x828A8C94;
	sub_827EA6C8(ctx, base);
	// 828A8C94: 806101DC  lwz r3, 0x1dc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(476 as u32) ) } as u64;
	// 828A8C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8C9C: 419A0008  beq cr6, 0x828a8ca4
	if ctx.cr[6].eq {
	pc = 0x828A8CA4; continue 'dispatch;
	}
	// 828A8CA0: 4BA17BF1  bl 0x822c0890
	ctx.lr = 0x828A8CA4;
	sub_822C0890(ctx, base);
	// 828A8CA4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828A8CA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828A8CAC: 38A000DF  li r5, 0xdf
	ctx.r[5].s64 = 223;
	// 828A8CB0: 38600198  li r3, 0x198
	ctx.r[3].s64 = 408;
	// 828A8CB4: 48549735  bl 0x82df23e8
	ctx.lr = 0x828A8CB8;
	sub_82DF23E8(ctx, base);
	// 828A8CB8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828A8CBC: 4182000C  beq 0x828a8cc8
	if ctx.cr[0].eq {
	pc = 0x828A8CC8; continue 'dispatch;
	}
	// 828A8CC0: 4BA563B9  bl 0x822ff078
	ctx.lr = 0x828A8CC4;
	sub_822FF078(ctx, base);
	// 828A8CC4: 48000008  b 0x828a8ccc
	pc = 0x828A8CCC; continue 'dispatch;
	// 828A8CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828A8CCC: 397C0380  addi r11, r28, 0x380
	ctx.r[11].s64 = ctx.r[28].s64 + 896;
	// 828A8CD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828A8CD4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828A8CD8: 4BFF29F9  bl 0x8289b6d0
	ctx.lr = 0x828A8CDC;
	sub_8289B6D0(ctx, base);
	// 828A8CDC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8CE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8CE4: 808B1500  lwz r4, 0x1500(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5376 as u32) ) } as u64;
	// 828A8CE8: 4854AD21  bl 0x82df3a08
	ctx.lr = 0x828A8CEC;
	sub_82DF3A08(ctx, base);
	// 828A8CEC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8CF0: 807C0380  lwz r3, 0x380(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(896 as u32) ) } as u64;
	// 828A8CF4: 4BA562CD  bl 0x822fefc0
	ctx.lr = 0x828A8CF8;
	sub_822FEFC0(ctx, base);
	// 828A8CF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8CFC: 4854A72D  bl 0x82df3428
	ctx.lr = 0x828A8D00;
	sub_82DF3428(ctx, base);
	// 828A8D00: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8D04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8D08: 808B14FC  lwz r4, 0x14fc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5372 as u32) ) } as u64;
	// 828A8D0C: 4854ACFD  bl 0x82df3a08
	ctx.lr = 0x828A8D10;
	sub_82DF3A08(ctx, base);
	// 828A8D10: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8D14: 807C0380  lwz r3, 0x380(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(896 as u32) ) } as u64;
	// 828A8D18: 4BA562A9  bl 0x822fefc0
	ctx.lr = 0x828A8D1C;
	sub_822FEFC0(ctx, base);
	// 828A8D1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8D20: 4854A709  bl 0x82df3428
	ctx.lr = 0x828A8D24;
	sub_82DF3428(ctx, base);
	// 828A8D24: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8D28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8D2C: 808B1504  lwz r4, 0x1504(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5380 as u32) ) } as u64;
	// 828A8D30: 4854ACD9  bl 0x82df3a08
	ctx.lr = 0x828A8D34;
	sub_82DF3A08(ctx, base);
	// 828A8D34: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8D38: 807C0380  lwz r3, 0x380(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(896 as u32) ) } as u64;
	// 828A8D3C: 4BA56285  bl 0x822fefc0
	ctx.lr = 0x828A8D40;
	sub_822FEFC0(ctx, base);
	// 828A8D40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8D44: 4854A6E5  bl 0x82df3428
	ctx.lr = 0x828A8D48;
	sub_82DF3428(ctx, base);
	// 828A8D48: 817C0384  lwz r11, 0x384(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(900 as u32) ) } as u64;
	// 828A8D4C: 815C0380  lwz r10, 0x380(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(896 as u32) ) } as u64;
	// 828A8D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828A8D54: 916100F4  stw r11, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 828A8D58: 914100F0  stw r10, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 828A8D5C: 419A0024  beq cr6, 0x828a8d80
	if ctx.cr[6].eq {
	pc = 0x828A8D80; continue 'dispatch;
	}
	// 828A8D60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828A8D64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828A8D68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A8D6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828A8D70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828A8D74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828A8D78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828A8D7C: 4082FFE8  bne 0x828a8d64
	if !ctx.cr[0].eq {
	pc = 0x828A8D64; continue 'dispatch;
	}
	// 828A8D80: 3F80832C  lis r28, -0x7cd4
	ctx.r[28].s64 = -2094268416;
	// 828A8D84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8D88: 809C1508  lwz r4, 0x1508(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5384 as u32) ) } as u64;
	// 828A8D8C: 4854AC7D  bl 0x82df3a08
	ctx.lr = 0x828A8D90;
	sub_82DF3A08(ctx, base);
	// 828A8D90: 38A100F0  addi r5, r1, 0xf0
	ctx.r[5].s64 = ctx.r[1].s64 + 240;
	// 828A8D94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8D98: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8D9C: 4BF413E5  bl 0x827ea180
	ctx.lr = 0x828A8DA0;
	sub_827EA180(ctx, base);
	// 828A8DA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8DA4: 4854A685  bl 0x82df3428
	ctx.lr = 0x828A8DA8;
	sub_82DF3428(ctx, base);
	// 828A8DA8: 806100F4  lwz r3, 0xf4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 828A8DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828A8DB0: 419A0008  beq cr6, 0x828a8db8
	if ctx.cr[6].eq {
	pc = 0x828A8DB8; continue 'dispatch;
	}
	// 828A8DB4: 4BA17ADD  bl 0x822c0890
	ctx.lr = 0x828A8DB8;
	sub_822C0890(ctx, base);
	// 828A8DB8: 3F60832C  lis r27, -0x7cd4
	ctx.r[27].s64 = -2094268416;
	// 828A8DBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8DC0: 809B14B0  lwz r4, 0x14b0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5296 as u32) ) } as u64;
	// 828A8DC4: 4854AC45  bl 0x82df3a08
	ctx.lr = 0x828A8DC8;
	sub_82DF3A08(ctx, base);
	// 828A8DC8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8DCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8DD0: 4BF417C9  bl 0x827ea598
	ctx.lr = 0x828A8DD4;
	sub_827EA598(ctx, base);
	// 828A8DD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A8DD8: C02B03E8  lfs f1, 0x3e8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1000 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A8DDC: 4830FC95  bl 0x82bb8a70
	ctx.lr = 0x828A8DE0;
	sub_82BB8A70(ctx, base);
	// 828A8DE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8DE4: 4854A645  bl 0x82df3428
	ctx.lr = 0x828A8DE8;
	sub_82DF3428(ctx, base);
	// 828A8DE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8DEC: 809C1508  lwz r4, 0x1508(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5384 as u32) ) } as u64;
	// 828A8DF0: 4854AC19  bl 0x82df3a08
	ctx.lr = 0x828A8DF4;
	sub_82DF3A08(ctx, base);
	// 828A8DF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A8DF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8DFC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8E00: C32B9450  lfs f25, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 828A8E04: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 828A8E08: 4BF41531  bl 0x827ea338
	ctx.lr = 0x828A8E0C;
	sub_827EA338(ctx, base);
	// 828A8E0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E10: 4854A619  bl 0x82df3428
	ctx.lr = 0x828A8E14;
	sub_82DF3428(ctx, base);
	// 828A8E14: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8E18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E1C: 808B14EC  lwz r4, 0x14ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5356 as u32) ) } as u64;
	// 828A8E20: 4854ABE9  bl 0x82df3a08
	ctx.lr = 0x828A8E24;
	sub_82DF3A08(ctx, base);
	// 828A8E24: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8E28: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8E2C: FC20C890  fmr f1, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[25].f64;
	// 828A8E30: 4BF41509  bl 0x827ea338
	ctx.lr = 0x828A8E34;
	sub_827EA338(ctx, base);
	// 828A8E34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E38: 4854A5F1  bl 0x82df3428
	ctx.lr = 0x828A8E3C;
	sub_82DF3428(ctx, base);
	// 828A8E3C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8E40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E44: 808B14F0  lwz r4, 0x14f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5360 as u32) ) } as u64;
	// 828A8E48: 4854ABC1  bl 0x82df3a08
	ctx.lr = 0x828A8E4C;
	sub_82DF3A08(ctx, base);
	// 828A8E4C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8E50: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8E54: FC20C890  fmr f1, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[25].f64;
	// 828A8E58: 4BF414E1  bl 0x827ea338
	ctx.lr = 0x828A8E5C;
	sub_827EA338(ctx, base);
	// 828A8E5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E60: 4854A5C9  bl 0x82df3428
	ctx.lr = 0x828A8E64;
	sub_82DF3428(ctx, base);
	// 828A8E64: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E68: 809B14B0  lwz r4, 0x14b0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5296 as u32) ) } as u64;
	// 828A8E6C: 4854AB9D  bl 0x82df3a08
	ctx.lr = 0x828A8E70;
	sub_82DF3A08(ctx, base);
	// 828A8E70: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A8E74: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8E78: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8E7C: C02B9F78  lfs f1, -0x6088(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A8E80: 4BF414B9  bl 0x827ea338
	ctx.lr = 0x828A8E84;
	sub_827EA338(ctx, base);
	// 828A8E84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E88: 4854A5A1  bl 0x82df3428
	ctx.lr = 0x828A8E8C;
	sub_82DF3428(ctx, base);
	// 828A8E8C: 3F60832C  lis r27, -0x7cd4
	ctx.r[27].s64 = -2094268416;
	// 828A8E90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8E94: 809B14B4  lwz r4, 0x14b4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828A8E98: 4854AB71  bl 0x82df3a08
	ctx.lr = 0x828A8E9C;
	sub_82DF3A08(ctx, base);
	// 828A8E9C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A8EA0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8EA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8EA8: C3AB6150  lfs f29, 0x6150(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24912 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828A8EAC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A8EB0: 4BF41489  bl 0x827ea338
	ctx.lr = 0x828A8EB4;
	sub_827EA338(ctx, base);
	// 828A8EB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8EB8: 4854A571  bl 0x82df3428
	ctx.lr = 0x828A8EBC;
	sub_82DF3428(ctx, base);
	// 828A8EBC: 3E80832C  lis r20, -0x7cd4
	ctx.r[20].s64 = -2094268416;
	// 828A8EC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8EC4: 80941478  lwz r4, 0x1478(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(5240 as u32) ) } as u64;
	// 828A8EC8: 4854AB41  bl 0x82df3a08
	ctx.lr = 0x828A8ECC;
	sub_82DF3A08(ctx, base);
	// 828A8ECC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A8ED0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8ED4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8ED8: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A8EDC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8EE0: 4BF41459  bl 0x827ea338
	ctx.lr = 0x828A8EE4;
	sub_827EA338(ctx, base);
	// 828A8EE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8EE8: 4854A541  bl 0x82df3428
	ctx.lr = 0x828A8EEC;
	sub_82DF3428(ctx, base);
	// 828A8EEC: 3F80832C  lis r28, -0x7cd4
	ctx.r[28].s64 = -2094268416;
	// 828A8EF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8EF4: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828A8EF8: 4854AB11  bl 0x82df3a08
	ctx.lr = 0x828A8EFC;
	sub_82DF3A08(ctx, base);
	// 828A8EFC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8F00: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8F04: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8F08: 4BF41431  bl 0x827ea338
	ctx.lr = 0x828A8F0C;
	sub_827EA338(ctx, base);
	// 828A8F0C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F10: 4854A519  bl 0x82df3428
	ctx.lr = 0x828A8F14;
	sub_82DF3428(ctx, base);
	// 828A8F14: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8F18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F1C: 808B1490  lwz r4, 0x1490(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5264 as u32) ) } as u64;
	// 828A8F20: 4854AAE9  bl 0x82df3a08
	ctx.lr = 0x828A8F24;
	sub_82DF3A08(ctx, base);
	// 828A8F24: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8F28: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8F2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8F30: 4BF41409  bl 0x827ea338
	ctx.lr = 0x828A8F34;
	sub_827EA338(ctx, base);
	// 828A8F34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F38: 4854A4F1  bl 0x82df3428
	ctx.lr = 0x828A8F3C;
	sub_82DF3428(ctx, base);
	// 828A8F3C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A8F40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F44: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 828A8F48: 808B147C  lwz r4, 0x147c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5244 as u32) ) } as u64;
	// 828A8F4C: 4854AABD  bl 0x82df3a08
	ctx.lr = 0x828A8F50;
	sub_82DF3A08(ctx, base);
	// 828A8F50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8F54: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8F58: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8F5C: 4BF413DD  bl 0x827ea338
	ctx.lr = 0x828A8F60;
	sub_827EA338(ctx, base);
	// 828A8F60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F64: 4854A4C5  bl 0x82df3428
	ctx.lr = 0x828A8F68;
	sub_82DF3428(ctx, base);
	// 828A8F68: 3E60832C  lis r19, -0x7cd4
	ctx.r[19].s64 = -2094268416;
	// 828A8F6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F70: 80931480  lwz r4, 0x1480(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(5248 as u32) ) } as u64;
	// 828A8F74: 4854AA95  bl 0x82df3a08
	ctx.lr = 0x828A8F78;
	sub_82DF3A08(ctx, base);
	// 828A8F78: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8F7C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8F80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8F84: 4BF413B5  bl 0x827ea338
	ctx.lr = 0x828A8F88;
	sub_827EA338(ctx, base);
	// 828A8F88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F8C: 4854A49D  bl 0x82df3428
	ctx.lr = 0x828A8F90;
	sub_82DF3428(ctx, base);
	// 828A8F90: 3E40832C  lis r18, -0x7cd4
	ctx.r[18].s64 = -2094268416;
	// 828A8F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8F98: 80921484  lwz r4, 0x1484(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(5252 as u32) ) } as u64;
	// 828A8F9C: 4854AA6D  bl 0x82df3a08
	ctx.lr = 0x828A8FA0;
	sub_82DF3A08(ctx, base);
	// 828A8FA0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8FA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8FA8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8FAC: 4BF4138D  bl 0x827ea338
	ctx.lr = 0x828A8FB0;
	sub_827EA338(ctx, base);
	// 828A8FB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8FB4: 4854A475  bl 0x82df3428
	ctx.lr = 0x828A8FB8;
	sub_82DF3428(ctx, base);
	// 828A8FB8: 3E20832C  lis r17, -0x7cd4
	ctx.r[17].s64 = -2094268416;
	// 828A8FBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8FC0: 80911488  lwz r4, 0x1488(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(5256 as u32) ) } as u64;
	// 828A8FC4: 4854AA45  bl 0x82df3a08
	ctx.lr = 0x828A8FC8;
	sub_82DF3A08(ctx, base);
	// 828A8FC8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8FCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8FD0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8FD4: 4BF41365  bl 0x827ea338
	ctx.lr = 0x828A8FD8;
	sub_827EA338(ctx, base);
	// 828A8FD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8FDC: 4854A44D  bl 0x82df3428
	ctx.lr = 0x828A8FE0;
	sub_82DF3428(ctx, base);
	// 828A8FE0: 3E00832C  lis r16, -0x7cd4
	ctx.r[16].s64 = -2094268416;
	// 828A8FE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A8FE8: 8090148C  lwz r4, 0x148c(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(5260 as u32) ) } as u64;
	// 828A8FEC: 4854AA1D  bl 0x82df3a08
	ctx.lr = 0x828A8FF0;
	sub_82DF3A08(ctx, base);
	// 828A8FF0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A8FF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A8FF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A8FFC: 4BF4133D  bl 0x827ea338
	ctx.lr = 0x828A9000;
	sub_827EA338(ctx, base);
	// 828A9000: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9004: 4854A425  bl 0x82df3428
	ctx.lr = 0x828A9008;
	sub_82DF3428(ctx, base);
	// 828A9008: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A900C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9010: 808B14E4  lwz r4, 0x14e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5348 as u32) ) } as u64;
	// 828A9014: 4854A9F5  bl 0x82df3a08
	ctx.lr = 0x828A9018;
	sub_82DF3A08(ctx, base);
	// 828A9018: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A901C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9020: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9024: 4BF41315  bl 0x827ea338
	ctx.lr = 0x828A9028;
	sub_827EA338(ctx, base);
	// 828A9028: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A902C: 4854A3FD  bl 0x82df3428
	ctx.lr = 0x828A9030;
	sub_82DF3428(ctx, base);
	// 828A9030: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A9034: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9038: 808B14D8  lwz r4, 0x14d8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5336 as u32) ) } as u64;
	// 828A903C: 4854A9CD  bl 0x82df3a08
	ctx.lr = 0x828A9040;
	sub_82DF3A08(ctx, base);
	// 828A9040: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9044: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9048: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A904C: 4BF412ED  bl 0x827ea338
	ctx.lr = 0x828A9050;
	sub_827EA338(ctx, base);
	// 828A9050: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9054: 4854A3D5  bl 0x82df3428
	ctx.lr = 0x828A9058;
	sub_82DF3428(ctx, base);
	// 828A9058: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A905C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9060: 808B14DC  lwz r4, 0x14dc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5340 as u32) ) } as u64;
	// 828A9064: 4854A9A5  bl 0x82df3a08
	ctx.lr = 0x828A9068;
	sub_82DF3A08(ctx, base);
	// 828A9068: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A906C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9070: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9074: 4BF412C5  bl 0x827ea338
	ctx.lr = 0x828A9078;
	sub_827EA338(ctx, base);
	// 828A9078: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A907C: 4854A3AD  bl 0x82df3428
	ctx.lr = 0x828A9080;
	sub_82DF3428(ctx, base);
	// 828A9080: 3DC0832C  lis r14, -0x7cd4
	ctx.r[14].s64 = -2094268416;
	// 828A9084: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9088: 808E14E0  lwz r4, 0x14e0(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(5344 as u32) ) } as u64;
	// 828A908C: 4854A97D  bl 0x82df3a08
	ctx.lr = 0x828A9090;
	sub_82DF3A08(ctx, base);
	// 828A9090: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9094: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9098: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A909C: 4BF4129D  bl 0x827ea338
	ctx.lr = 0x828A90A0;
	sub_827EA338(ctx, base);
	// 828A90A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A90A4: 4854A385  bl 0x82df3428
	ctx.lr = 0x828A90A8;
	sub_82DF3428(ctx, base);
	// 828A90A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A90AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A90B0: 808B14C4  lwz r4, 0x14c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5316 as u32) ) } as u64;
	// 828A90B4: 4854A955  bl 0x82df3a08
	ctx.lr = 0x828A90B8;
	sub_82DF3A08(ctx, base);
	// 828A90B8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A90BC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A90C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A90C4: 4BF41275  bl 0x827ea338
	ctx.lr = 0x828A90C8;
	sub_827EA338(ctx, base);
	// 828A90C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A90CC: 4854A35D  bl 0x82df3428
	ctx.lr = 0x828A90D0;
	sub_82DF3428(ctx, base);
	// 828A90D0: 3F40832C  lis r26, -0x7cd4
	ctx.r[26].s64 = -2094268416;
	// 828A90D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A90D8: 809A14C0  lwz r4, 0x14c0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828A90DC: 4854A92D  bl 0x82df3a08
	ctx.lr = 0x828A90E0;
	sub_82DF3A08(ctx, base);
	// 828A90E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A90E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A90E8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A90EC: 4BF4124D  bl 0x827ea338
	ctx.lr = 0x828A90F0;
	sub_827EA338(ctx, base);
	// 828A90F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A90F4: 4854A335  bl 0x82df3428
	ctx.lr = 0x828A90F8;
	sub_82DF3428(ctx, base);
	// 828A90F8: 3F20832C  lis r25, -0x7cd4
	ctx.r[25].s64 = -2094268416;
	// 828A90FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9100: 809914CC  lwz r4, 0x14cc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(5324 as u32) ) } as u64;
	// 828A9104: 4854A905  bl 0x82df3a08
	ctx.lr = 0x828A9108;
	sub_82DF3A08(ctx, base);
	// 828A9108: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A910C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9110: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9114: 4BF41225  bl 0x827ea338
	ctx.lr = 0x828A9118;
	sub_827EA338(ctx, base);
	// 828A9118: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A911C: 4854A30D  bl 0x82df3428
	ctx.lr = 0x828A9120;
	sub_82DF3428(ctx, base);
	// 828A9120: 3F00832C  lis r24, -0x7cd4
	ctx.r[24].s64 = -2094268416;
	// 828A9124: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9128: 809814D4  lwz r4, 0x14d4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(5332 as u32) ) } as u64;
	// 828A912C: 4854A8DD  bl 0x82df3a08
	ctx.lr = 0x828A9130;
	sub_82DF3A08(ctx, base);
	// 828A9130: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9134: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9138: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A913C: 4BF411FD  bl 0x827ea338
	ctx.lr = 0x828A9140;
	sub_827EA338(ctx, base);
	// 828A9140: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9144: 4854A2E5  bl 0x82df3428
	ctx.lr = 0x828A9148;
	sub_82DF3428(ctx, base);
	// 828A9148: 3EE0832C  lis r23, -0x7cd4
	ctx.r[23].s64 = -2094268416;
	// 828A914C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9150: 809714C8  lwz r4, 0x14c8(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(5320 as u32) ) } as u64;
	// 828A9154: 4854A8B5  bl 0x82df3a08
	ctx.lr = 0x828A9158;
	sub_82DF3A08(ctx, base);
	// 828A9158: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A915C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9160: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9164: 4BF411D5  bl 0x827ea338
	ctx.lr = 0x828A9168;
	sub_827EA338(ctx, base);
	// 828A9168: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A916C: 4854A2BD  bl 0x82df3428
	ctx.lr = 0x828A9170;
	sub_82DF3428(ctx, base);
	// 828A9170: 3EC0832C  lis r22, -0x7cd4
	ctx.r[22].s64 = -2094268416;
	// 828A9174: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9178: 809614D0  lwz r4, 0x14d0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(5328 as u32) ) } as u64;
	// 828A917C: 4854A88D  bl 0x82df3a08
	ctx.lr = 0x828A9180;
	sub_82DF3A08(ctx, base);
	// 828A9180: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9184: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9188: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A918C: 4BF411AD  bl 0x827ea338
	ctx.lr = 0x828A9190;
	sub_827EA338(ctx, base);
	// 828A9190: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9194: 4854A295  bl 0x82df3428
	ctx.lr = 0x828A9198;
	sub_82DF3428(ctx, base);
	// 828A9198: 3EA0832C  lis r21, -0x7cd4
	ctx.r[21].s64 = -2094268416;
	// 828A919C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A91A0: 809514A8  lwz r4, 0x14a8(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(5288 as u32) ) } as u64;
	// 828A91A4: 4854A865  bl 0x82df3a08
	ctx.lr = 0x828A91A8;
	sub_82DF3A08(ctx, base);
	// 828A91A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A91AC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A91B0: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A91B4: 4BF41185  bl 0x827ea338
	ctx.lr = 0x828A91B8;
	sub_827EA338(ctx, base);
	// 828A91B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A91BC: 4854A26D  bl 0x82df3428
	ctx.lr = 0x828A91C0;
	sub_82DF3428(ctx, base);
	// 828A91C0: 3DE0832C  lis r15, -0x7cd4
	ctx.r[15].s64 = -2094268416;
	// 828A91C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A91C8: 808F14AC  lwz r4, 0x14ac(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5292 as u32) ) } as u64;
	// 828A91CC: 4854A83D  bl 0x82df3a08
	ctx.lr = 0x828A91D0;
	sub_82DF3A08(ctx, base);
	// 828A91D0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A91D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A91D8: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A91DC: 4BF4115D  bl 0x827ea338
	ctx.lr = 0x828A91E0;
	sub_827EA338(ctx, base);
	// 828A91E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A91E4: 4854A245  bl 0x82df3428
	ctx.lr = 0x828A91E8;
	sub_82DF3428(ctx, base);
	// 828A91E8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A91EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A91F0: 808B149C  lwz r4, 0x149c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5276 as u32) ) } as u64;
	// 828A91F4: 4854A815  bl 0x82df3a08
	ctx.lr = 0x828A91F8;
	sub_82DF3A08(ctx, base);
	// 828A91F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A91FC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9200: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A9204: 4BF41135  bl 0x827ea338
	ctx.lr = 0x828A9208;
	sub_827EA338(ctx, base);
	// 828A9208: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A920C: 4854A21D  bl 0x82df3428
	ctx.lr = 0x828A9210;
	sub_82DF3428(ctx, base);
	// 828A9210: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A9214: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9218: 808B1498  lwz r4, 0x1498(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5272 as u32) ) } as u64;
	// 828A921C: 4854A7ED  bl 0x82df3a08
	ctx.lr = 0x828A9220;
	sub_82DF3A08(ctx, base);
	// 828A9220: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9224: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9228: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A922C: 4BF4110D  bl 0x827ea338
	ctx.lr = 0x828A9230;
	sub_827EA338(ctx, base);
	// 828A9230: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9234: 4854A1F5  bl 0x82df3428
	ctx.lr = 0x828A9238;
	sub_82DF3428(ctx, base);
	// 828A9238: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A923C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9240: 808B14A4  lwz r4, 0x14a4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5284 as u32) ) } as u64;
	// 828A9244: 4854A7C5  bl 0x82df3a08
	ctx.lr = 0x828A9248;
	sub_82DF3A08(ctx, base);
	// 828A9248: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A924C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9250: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A9254: 4BF410E5  bl 0x827ea338
	ctx.lr = 0x828A9258;
	sub_827EA338(ctx, base);
	// 828A9258: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A925C: 4854A1CD  bl 0x82df3428
	ctx.lr = 0x828A9260;
	sub_82DF3428(ctx, base);
	// 828A9260: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A9264: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9268: 808B14A0  lwz r4, 0x14a0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5280 as u32) ) } as u64;
	// 828A926C: 4854A79D  bl 0x82df3a08
	ctx.lr = 0x828A9270;
	sub_82DF3A08(ctx, base);
	// 828A9270: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9274: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9278: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A927C: 4BF410BD  bl 0x827ea338
	ctx.lr = 0x828A9280;
	sub_827EA338(ctx, base);
	// 828A9280: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9284: 4854A1A5  bl 0x82df3428
	ctx.lr = 0x828A9288;
	sub_82DF3428(ctx, base);
	// 828A9288: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828A928C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9290: 808BF470  lwz r4, -0xb90(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2960 as u32) ) } as u64;
	// 828A9294: 4854A775  bl 0x82df3a08
	ctx.lr = 0x828A9298;
	sub_82DF3A08(ctx, base);
	// 828A9298: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A929C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A92A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A92A4: C02BA9F0  lfs f1, -0x5610(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A92A8: 4BF41091  bl 0x827ea338
	ctx.lr = 0x828A92AC;
	sub_827EA338(ctx, base);
	// 828A92AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A92B0: 4854A179  bl 0x82df3428
	ctx.lr = 0x828A92B4;
	sub_82DF3428(ctx, base);
	// 828A92B4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828A92B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A92BC: 808BF474  lwz r4, -0xb8c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2956 as u32) ) } as u64;
	// 828A92C0: 4854A749  bl 0x82df3a08
	ctx.lr = 0x828A92C4;
	sub_82DF3A08(ctx, base);
	// 828A92C4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A92C8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A92CC: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828A92D0: 4BF41069  bl 0x827ea338
	ctx.lr = 0x828A92D4;
	sub_827EA338(ctx, base);
	// 828A92D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A92D8: 4854A151  bl 0x82df3428
	ctx.lr = 0x828A92DC;
	sub_82DF3428(ctx, base);
	// 828A92DC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A92E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A92E4: 808B14F4  lwz r4, 0x14f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5364 as u32) ) } as u64;
	// 828A92E8: 4854A721  bl 0x82df3a08
	ctx.lr = 0x828A92EC;
	sub_82DF3A08(ctx, base);
	// 828A92EC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828A92F0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A92F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A92F8: C36B7BC8  lfs f27, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828A92FC: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 828A9300: 4BF41039  bl 0x827ea338
	ctx.lr = 0x828A9304;
	sub_827EA338(ctx, base);
	// 828A9304: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9308: 4854A121  bl 0x82df3428
	ctx.lr = 0x828A930C;
	sub_82DF3428(ctx, base);
	// 828A930C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828A9310: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9314: 808B14B8  lwz r4, 0x14b8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5304 as u32) ) } as u64;
	// 828A9318: 4854A6F1  bl 0x82df3a08
	ctx.lr = 0x828A931C;
	sub_82DF3A08(ctx, base);
	// 828A931C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A9320: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9324: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9328: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A932C: 4BF4100D  bl 0x827ea338
	ctx.lr = 0x828A9330;
	sub_827EA338(ctx, base);
	// 828A9330: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9334: 4854A0F5  bl 0x82df3428
	ctx.lr = 0x828A9338;
	sub_82DF3428(ctx, base);
	// 828A9338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A933C: 809B14B4  lwz r4, 0x14b4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828A9340: 4854A6C9  bl 0x82df3a08
	ctx.lr = 0x828A9344;
	sub_82DF3A08(ctx, base);
	// 828A9344: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A9348: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A934C: 388BA034  addi r4, r11, -0x5fcc
	ctx.r[4].s64 = ctx.r[11].s64 + -24524;
	// 828A9350: 4854A6B9  bl 0x82df3a08
	ctx.lr = 0x828A9354;
	sub_82DF3A08(ctx, base);
	// 828A9354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A9358: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A935C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9360: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828A9364: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828A9368: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828A936C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9370: 4BF40FE9  bl 0x827ea358
	ctx.lr = 0x828A9374;
	sub_827EA358(ctx, base);
	// 828A9374: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9378: 4854A0B1  bl 0x82df3428
	ctx.lr = 0x828A937C;
	sub_82DF3428(ctx, base);
	// 828A937C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9380: 4854A0A9  bl 0x82df3428
	ctx.lr = 0x828A9384;
	sub_82DF3428(ctx, base);
	// 828A9384: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9388: 809B14B4  lwz r4, 0x14b4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828A938C: 4854A67D  bl 0x82df3a08
	ctx.lr = 0x828A9390;
	sub_82DF3A08(ctx, base);
	// 828A9390: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A9394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9398: 388BA01C  addi r4, r11, -0x5fe4
	ctx.r[4].s64 = ctx.r[11].s64 + -24548;
	// 828A939C: 4854A66D  bl 0x82df3a08
	ctx.lr = 0x828A93A0;
	sub_82DF3A08(ctx, base);
	// 828A93A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A93A4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828A93A8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A93AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A93B0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A93B4: 4BF40FA5  bl 0x827ea358
	ctx.lr = 0x828A93B8;
	sub_827EA358(ctx, base);
	// 828A93B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A93BC: 4854A06D  bl 0x82df3428
	ctx.lr = 0x828A93C0;
	sub_82DF3428(ctx, base);
	// 828A93C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A93C4: 4854A065  bl 0x82df3428
	ctx.lr = 0x828A93C8;
	sub_82DF3428(ctx, base);
	// 828A93C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A93CC: 809B14B4  lwz r4, 0x14b4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828A93D0: 4854A639  bl 0x82df3a08
	ctx.lr = 0x828A93D4;
	sub_82DF3A08(ctx, base);
	// 828A93D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A93D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A93DC: 388BA004  addi r4, r11, -0x5ffc
	ctx.r[4].s64 = ctx.r[11].s64 + -24572;
	// 828A93E0: 4854A629  bl 0x82df3a08
	ctx.lr = 0x828A93E4;
	sub_82DF3A08(ctx, base);
	// 828A93E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 828A93E8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 828A93EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A93F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A93F4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A93F8: 4BF40F61  bl 0x827ea358
	ctx.lr = 0x828A93FC;
	sub_827EA358(ctx, base);
	// 828A93FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9400: 4854A029  bl 0x82df3428
	ctx.lr = 0x828A9404;
	sub_82DF3428(ctx, base);
	// 828A9404: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828A9408: 4854A021  bl 0x82df3428
	ctx.lr = 0x828A940C;
	sub_82DF3428(ctx, base);
	// 828A940C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9410: 809A14C0  lwz r4, 0x14c0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828A9414: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9418: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A941C: 396B7290  addi r11, r11, 0x7290
	ctx.r[11].s64 = ctx.r[11].s64 + 29328;
	// 828A9420: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9424: 4854A5E5  bl 0x82df3a08
	ctx.lr = 0x828A9428;
	sub_82DF3A08(ctx, base);
	// 828A9428: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A942C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9430: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9434: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9438: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A943C: 4BFFF175  bl 0x828a85b0
	ctx.lr = 0x828A9440;
	sub_828A85B0(ctx, base);
	// 828A9440: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A9444: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9448: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A944C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9450: C38B0944  lfs f28, 0x944(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2372 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828A9454: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A9458: 4BF41359  bl 0x827ea7b0
	ctx.lr = 0x828A945C;
	sub_827EA7B0(ctx, base);
	// 828A945C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9460: 48549FC9  bl 0x82df3428
	ctx.lr = 0x828A9464;
	sub_82DF3428(ctx, base);
	// 828A9464: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A946C: 809714C8  lwz r4, 0x14c8(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(5320 as u32) ) } as u64;
	// 828A9470: 396B7290  addi r11, r11, 0x7290
	ctx.r[11].s64 = ctx.r[11].s64 + 29328;
	// 828A9474: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9478: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A947C: 4854A58D  bl 0x82df3a08
	ctx.lr = 0x828A9480;
	sub_82DF3A08(ctx, base);
	// 828A9480: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9484: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9488: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A948C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9490: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9494: 4BFFF11D  bl 0x828a85b0
	ctx.lr = 0x828A9498;
	sub_828A85B0(ctx, base);
	// 828A9498: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A949C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A94A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A94A4: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A94A8: 4BF41309  bl 0x827ea7b0
	ctx.lr = 0x828A94AC;
	sub_827EA7B0(ctx, base);
	// 828A94AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A94B0: 48549F79  bl 0x82df3428
	ctx.lr = 0x828A94B4;
	sub_82DF3428(ctx, base);
	// 828A94B4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A94B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A94BC: 809614D0  lwz r4, 0x14d0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(5328 as u32) ) } as u64;
	// 828A94C0: 396B7290  addi r11, r11, 0x7290
	ctx.r[11].s64 = ctx.r[11].s64 + 29328;
	// 828A94C4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A94C8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A94CC: 4854A53D  bl 0x82df3a08
	ctx.lr = 0x828A94D0;
	sub_82DF3A08(ctx, base);
	// 828A94D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A94D4: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A94D8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A94DC: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A94E0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A94E4: 4BFFF0CD  bl 0x828a85b0
	ctx.lr = 0x828A94E8;
	sub_828A85B0(ctx, base);
	// 828A94E8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A94EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A94F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A94F4: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A94F8: 4BF412B9  bl 0x827ea7b0
	ctx.lr = 0x828A94FC;
	sub_827EA7B0(ctx, base);
	// 828A94FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9500: 48549F29  bl 0x82df3428
	ctx.lr = 0x828A9504;
	sub_82DF3428(ctx, base);
	// 828A9504: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A950C: 809914CC  lwz r4, 0x14cc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(5324 as u32) ) } as u64;
	// 828A9510: 396B7290  addi r11, r11, 0x7290
	ctx.r[11].s64 = ctx.r[11].s64 + 29328;
	// 828A9514: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9518: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A951C: 4854A4ED  bl 0x82df3a08
	ctx.lr = 0x828A9520;
	sub_82DF3A08(ctx, base);
	// 828A9520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9524: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9528: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A952C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9530: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9534: 4BFFF07D  bl 0x828a85b0
	ctx.lr = 0x828A9538;
	sub_828A85B0(ctx, base);
	// 828A9538: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A953C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9540: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9544: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A9548: 4BF41269  bl 0x827ea7b0
	ctx.lr = 0x828A954C;
	sub_827EA7B0(ctx, base);
	// 828A954C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9550: 48549ED9  bl 0x82df3428
	ctx.lr = 0x828A9554;
	sub_82DF3428(ctx, base);
	// 828A9554: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A955C: 809814D4  lwz r4, 0x14d4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(5332 as u32) ) } as u64;
	// 828A9560: 396B7290  addi r11, r11, 0x7290
	ctx.r[11].s64 = ctx.r[11].s64 + 29328;
	// 828A9564: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9568: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A956C: 4854A49D  bl 0x82df3a08
	ctx.lr = 0x828A9570;
	sub_82DF3A08(ctx, base);
	// 828A9570: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9574: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9578: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A957C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9580: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9584: 4BFFF02D  bl 0x828a85b0
	ctx.lr = 0x828A9588;
	sub_828A85B0(ctx, base);
	// 828A9588: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A958C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9594: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A9598: 4BF41219  bl 0x827ea7b0
	ctx.lr = 0x828A959C;
	sub_827EA7B0(ctx, base);
	// 828A959C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A95A0: 48549E89  bl 0x82df3428
	ctx.lr = 0x828A95A4;
	sub_82DF3428(ctx, base);
	// 828A95A4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A95A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A95AC: 808E14E0  lwz r4, 0x14e0(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(5344 as u32) ) } as u64;
	// 828A95B0: 396B7358  addi r11, r11, 0x7358
	ctx.r[11].s64 = ctx.r[11].s64 + 29528;
	// 828A95B4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A95B8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A95BC: 4854A44D  bl 0x82df3a08
	ctx.lr = 0x828A95C0;
	sub_82DF3A08(ctx, base);
	// 828A95C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A95C4: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A95C8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A95CC: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A95D0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A95D4: 4BFFEFDD  bl 0x828a85b0
	ctx.lr = 0x828A95D8;
	sub_828A85B0(ctx, base);
	// 828A95D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828A95DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A95E0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A95E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A95E8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A95EC: 4BF411C5  bl 0x827ea7b0
	ctx.lr = 0x828A95F0;
	sub_827EA7B0(ctx, base);
	// 828A95F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A95F4: 48549E35  bl 0x82df3428
	ctx.lr = 0x828A95F8;
	sub_82DF3428(ctx, base);
	// 828A95F8: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A95FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9600: 80941478  lwz r4, 0x1478(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(5240 as u32) ) } as u64;
	// 828A9604: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9608: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A960C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9610: 4854A3F9  bl 0x82df3a08
	ctx.lr = 0x828A9614;
	sub_82DF3A08(ctx, base);
	// 828A9614: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 828A9618: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A961C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9620: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9624: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A9628: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A962C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9630: 4BFFF001  bl 0x828a8630
	ctx.lr = 0x828A9634;
	sub_828A8630(ctx, base);
	// 828A9634: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A9638: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A963C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9640: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9644: C38B957C  lfs f28, -0x6a84(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27268 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828A9648: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A964C: 4BF41165  bl 0x827ea7b0
	ctx.lr = 0x828A9650;
	sub_827EA7B0(ctx, base);
	// 828A9650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9654: 48549DD5  bl 0x82df3428
	ctx.lr = 0x828A9658;
	sub_82DF3428(ctx, base);
	// 828A9658: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A965C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9660: 80931480  lwz r4, 0x1480(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(5248 as u32) ) } as u64;
	// 828A9664: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9668: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A966C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9670: 4854A399  bl 0x82df3a08
	ctx.lr = 0x828A9674;
	sub_82DF3A08(ctx, base);
	// 828A9674: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9678: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A967C: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A9680: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9684: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9688: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A968C: 4BFFEFA5  bl 0x828a8630
	ctx.lr = 0x828A9690;
	sub_828A8630(ctx, base);
	// 828A9690: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9694: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9698: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A969C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A96A0: 4BF41111  bl 0x827ea7b0
	ctx.lr = 0x828A96A4;
	sub_827EA7B0(ctx, base);
	// 828A96A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A96A8: 48549D81  bl 0x82df3428
	ctx.lr = 0x828A96AC;
	sub_82DF3428(ctx, base);
	// 828A96AC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A96B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A96B4: 80911488  lwz r4, 0x1488(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(5256 as u32) ) } as u64;
	// 828A96B8: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A96BC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A96C0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A96C4: 4854A345  bl 0x82df3a08
	ctx.lr = 0x828A96C8;
	sub_82DF3A08(ctx, base);
	// 828A96C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A96CC: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A96D0: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A96D4: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A96D8: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A96DC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A96E0: 4BFFEF51  bl 0x828a8630
	ctx.lr = 0x828A96E4;
	sub_828A8630(ctx, base);
	// 828A96E4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A96E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A96EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A96F0: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A96F4: 4BF410BD  bl 0x827ea7b0
	ctx.lr = 0x828A96F8;
	sub_827EA7B0(ctx, base);
	// 828A96F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A96FC: 48549D2D  bl 0x82df3428
	ctx.lr = 0x828A9700;
	sub_82DF3428(ctx, base);
	// 828A9700: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9704: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9708: 80921484  lwz r4, 0x1484(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(5252 as u32) ) } as u64;
	// 828A970C: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9710: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9714: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9718: 4854A2F1  bl 0x82df3a08
	ctx.lr = 0x828A971C;
	sub_82DF3A08(ctx, base);
	// 828A971C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9720: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A9724: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A9728: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A972C: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9730: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9734: 4BFFEEFD  bl 0x828a8630
	ctx.lr = 0x828A9738;
	sub_828A8630(ctx, base);
	// 828A9738: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A973C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9740: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9744: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A9748: 4BF41069  bl 0x827ea7b0
	ctx.lr = 0x828A974C;
	sub_827EA7B0(ctx, base);
	// 828A974C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9750: 48549CD9  bl 0x82df3428
	ctx.lr = 0x828A9754;
	sub_82DF3428(ctx, base);
	// 828A9754: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A975C: 8090148C  lwz r4, 0x148c(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(5260 as u32) ) } as u64;
	// 828A9760: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9764: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9768: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A976C: 4854A29D  bl 0x82df3a08
	ctx.lr = 0x828A9770;
	sub_82DF3A08(ctx, base);
	// 828A9770: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9774: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A9778: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A977C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9780: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9784: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9788: 4BFFEEA9  bl 0x828a8630
	ctx.lr = 0x828A978C;
	sub_828A8630(ctx, base);
	// 828A978C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9790: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9794: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9798: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A979C: 4BF41015  bl 0x827ea7b0
	ctx.lr = 0x828A97A0;
	sub_827EA7B0(ctx, base);
	// 828A97A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A97A4: 48549C85  bl 0x82df3428
	ctx.lr = 0x828A97A8;
	sub_82DF3428(ctx, base);
	// 828A97A8: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A97AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A97B0: 809A14C0  lwz r4, 0x14c0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828A97B4: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A97B8: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A97BC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A97C0: 4854A249  bl 0x82df3a08
	ctx.lr = 0x828A97C4;
	sub_82DF3A08(ctx, base);
	// 828A97C4: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A97C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A97CC: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 828A97D0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A97D4: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A97D8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A97DC: 4BFFEE55  bl 0x828a8630
	ctx.lr = 0x828A97E0;
	sub_828A8630(ctx, base);
	// 828A97E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A97E4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A97E8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A97EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A97F0: C38BDF2C  lfs f28, -0x20d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8404 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828A97F4: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A97F8: 4BF40FB9  bl 0x827ea7b0
	ctx.lr = 0x828A97FC;
	sub_827EA7B0(ctx, base);
	// 828A97FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9800: 48549C29  bl 0x82df3428
	ctx.lr = 0x828A9804;
	sub_82DF3428(ctx, base);
	// 828A9804: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A980C: 809714C8  lwz r4, 0x14c8(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(5320 as u32) ) } as u64;
	// 828A9810: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9814: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9818: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A981C: 4854A1ED  bl 0x82df3a08
	ctx.lr = 0x828A9820;
	sub_82DF3A08(ctx, base);
	// 828A9820: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9824: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A9828: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 828A982C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9830: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9834: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9838: 4BFFEDF9  bl 0x828a8630
	ctx.lr = 0x828A983C;
	sub_828A8630(ctx, base);
	// 828A983C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9840: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9844: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9848: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A984C: 4BF40F65  bl 0x827ea7b0
	ctx.lr = 0x828A9850;
	sub_827EA7B0(ctx, base);
	// 828A9850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9854: 48549BD5  bl 0x82df3428
	ctx.lr = 0x828A9858;
	sub_82DF3428(ctx, base);
	// 828A9858: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A985C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9860: 809614D0  lwz r4, 0x14d0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(5328 as u32) ) } as u64;
	// 828A9864: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9868: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A986C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9870: 4854A199  bl 0x82df3a08
	ctx.lr = 0x828A9874;
	sub_82DF3A08(ctx, base);
	// 828A9874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9878: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A987C: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 828A9880: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9884: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9888: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A988C: 4BFFEDA5  bl 0x828a8630
	ctx.lr = 0x828A9890;
	sub_828A8630(ctx, base);
	// 828A9890: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9894: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A989C: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A98A0: 4BF40F11  bl 0x827ea7b0
	ctx.lr = 0x828A98A4;
	sub_827EA7B0(ctx, base);
	// 828A98A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A98A8: 48549B81  bl 0x82df3428
	ctx.lr = 0x828A98AC;
	sub_82DF3428(ctx, base);
	// 828A98AC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A98B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A98B4: 809914CC  lwz r4, 0x14cc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(5324 as u32) ) } as u64;
	// 828A98B8: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A98BC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A98C0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A98C4: 4854A145  bl 0x82df3a08
	ctx.lr = 0x828A98C8;
	sub_82DF3A08(ctx, base);
	// 828A98C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A98CC: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A98D0: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 828A98D4: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A98D8: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A98DC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A98E0: 4BFFED51  bl 0x828a8630
	ctx.lr = 0x828A98E4;
	sub_828A8630(ctx, base);
	// 828A98E4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A98E8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A98EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A98F0: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A98F4: 4BF40EBD  bl 0x827ea7b0
	ctx.lr = 0x828A98F8;
	sub_827EA7B0(ctx, base);
	// 828A98F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A98FC: 48549B2D  bl 0x82df3428
	ctx.lr = 0x828A9900;
	sub_82DF3428(ctx, base);
	// 828A9900: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9908: 809814D4  lwz r4, 0x14d4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(5332 as u32) ) } as u64;
	// 828A990C: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9910: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9914: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9918: 4854A0F1  bl 0x82df3a08
	ctx.lr = 0x828A991C;
	sub_82DF3A08(ctx, base);
	// 828A991C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9920: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A9924: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 828A9928: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A992C: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9930: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9934: 4BFFECFD  bl 0x828a8630
	ctx.lr = 0x828A9938;
	sub_828A8630(ctx, base);
	// 828A9938: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A993C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9940: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9944: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A9948: 4BF40E69  bl 0x827ea7b0
	ctx.lr = 0x828A994C;
	sub_827EA7B0(ctx, base);
	// 828A994C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9950: 48549AD9  bl 0x82df3428
	ctx.lr = 0x828A9954;
	sub_82DF3428(ctx, base);
	// 828A9954: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A995C: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828A9960: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9964: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9968: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A996C: 4854A09D  bl 0x82df3a08
	ctx.lr = 0x828A9970;
	sub_82DF3A08(ctx, base);
	// 828A9970: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9974: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A9978: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A997C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9980: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9984: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9988: 4BFFECA9  bl 0x828a8630
	ctx.lr = 0x828A998C;
	sub_828A8630(ctx, base);
	// 828A998C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A9990: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9994: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9998: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A999C: C34BD86C  lfs f26, -0x2794(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 828A99A0: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 828A99A4: 4BF40E0D  bl 0x827ea7b0
	ctx.lr = 0x828A99A8;
	sub_827EA7B0(ctx, base);
	// 828A99A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A99AC: 48549A7D  bl 0x82df3428
	ctx.lr = 0x828A99B0;
	sub_82DF3428(ctx, base);
	// 828A99B0: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A99B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A99B8: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828A99BC: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A99C0: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A99C4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A99C8: 4854A041  bl 0x82df3a08
	ctx.lr = 0x828A99CC;
	sub_82DF3A08(ctx, base);
	// 828A99CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A99D0: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A99D4: 936100A4  stw r27, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[27].u32 ) };
	// 828A99D8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A99DC: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A99E0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A99E4: 4BFFEC4D  bl 0x828a8630
	ctx.lr = 0x828A99E8;
	sub_828A8630(ctx, base);
	// 828A99E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828A99EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A99F0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A99F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A99F8: C38B958C  lfs f28, -0x6a74(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27252 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828A99FC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828A9A00: 4BF40DB1  bl 0x827ea7b0
	ctx.lr = 0x828A9A04;
	sub_827EA7B0(ctx, base);
	// 828A9A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A08: 48549A21  bl 0x82df3428
	ctx.lr = 0x828A9A0C;
	sub_82DF3428(ctx, base);
	// 828A9A0C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A14: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828A9A18: 396B7798  addi r11, r11, 0x7798
	ctx.r[11].s64 = ctx.r[11].s64 + 30616;
	// 828A9A1C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9A20: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9A24: 48549FE5  bl 0x82df3a08
	ctx.lr = 0x828A9A28;
	sub_82DF3A08(ctx, base);
	// 828A9A28: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828A9A2C: 93A100A0  stw r29, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u32 ) };
	// 828A9A30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9A34: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9A38: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 828A9A3C: E8A100A0  ld r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 828A9A40: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9A44: 4BFFEBED  bl 0x828a8630
	ctx.lr = 0x828A9A48;
	sub_828A8630(ctx, base);
	// 828A9A48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A9A4C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9A50: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9A54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9A58: C02BA000  lfs f1, -0x6000(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24576 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A9A5C: 4BF40D55  bl 0x827ea7b0
	ctx.lr = 0x828A9A60;
	sub_827EA7B0(ctx, base);
	// 828A9A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A64: 485499C5  bl 0x82df3428
	ctx.lr = 0x828A9A68;
	sub_82DF3428(ctx, base);
	// 828A9A68: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 828A9A6C: 3D40828A  lis r10, -0x7d76
	ctx.r[10].s64 = -2104885248;
	// 828A9A70: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9A74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9A78: 394A74E8  addi r10, r10, 0x74e8
	ctx.r[10].s64 = ctx.r[10].s64 + 29928;
	// 828A9A7C: 808B147C  lwz r4, 0x147c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5244 as u32) ) } as u64;
	// 828A9A80: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 828A9A84: 48549F85  bl 0x82df3a08
	ctx.lr = 0x828A9A88;
	sub_82DF3A08(ctx, base);
	// 828A9A88: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9A8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9A90: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9A94: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9A98: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9A9C: 4BFFEB15  bl 0x828a85b0
	ctx.lr = 0x828A9AA0;
	sub_828A85B0(ctx, base);
	// 828A9AA0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9AA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9AA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9AAC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9AB0: 4BF40D01  bl 0x827ea7b0
	ctx.lr = 0x828A9AB4;
	sub_827EA7B0(ctx, base);
	// 828A9AB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9AB8: 48549971  bl 0x82df3428
	ctx.lr = 0x828A9ABC;
	sub_82DF3428(ctx, base);
	// 828A9ABC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9AC4: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828A9AC8: 396B75F0  addi r11, r11, 0x75f0
	ctx.r[11].s64 = ctx.r[11].s64 + 30192;
	// 828A9ACC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9AD0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9AD4: 48549F35  bl 0x82df3a08
	ctx.lr = 0x828A9AD8;
	sub_82DF3A08(ctx, base);
	// 828A9AD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9ADC: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9AE0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9AE4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9AE8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9AEC: 4BFFEAC5  bl 0x828a85b0
	ctx.lr = 0x828A9AF0;
	sub_828A85B0(ctx, base);
	// 828A9AF0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9AF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9AF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9AFC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9B00: 4BF40CB1  bl 0x827ea7b0
	ctx.lr = 0x828A9B04;
	sub_827EA7B0(ctx, base);
	// 828A9B04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9B08: 48549921  bl 0x82df3428
	ctx.lr = 0x828A9B0C;
	sub_82DF3428(ctx, base);
	// 828A9B0C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9B10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9B14: 809514A8  lwz r4, 0x14a8(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(5288 as u32) ) } as u64;
	// 828A9B18: 396B5940  addi r11, r11, 0x5940
	ctx.r[11].s64 = ctx.r[11].s64 + 22848;
	// 828A9B1C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9B20: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9B24: 48549EE5  bl 0x82df3a08
	ctx.lr = 0x828A9B28;
	sub_82DF3A08(ctx, base);
	// 828A9B28: 3F608201  lis r27, -0x7dff
	ctx.r[27].s64 = -2113863680;
	// 828A9B2C: D3610058  stfs f27, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828A9B30: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A9B34: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828A9B38: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A9B3C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828A9B40: E8E10080  ld r7, 0x80(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9B44: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 828A9B48: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 828A9B4C: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828A9B50: C01B9524  lfs f0, -0x6adc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A9B54: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828A9B58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828A9B5C: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A9B60: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828A9B64: F8E10060  std r7, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u64 ) };
	// 828A9B68: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 828A9B6C: 9101008C  stw r8, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 828A9B70: 90A10088  stw r5, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[5].u32 ) };
	// 828A9B74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A9B78: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9B7C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828A9B80: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A9B84: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828A9B88: 4200FFF0  bdnz 0x828a9b78
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828A9B78; continue 'dispatch;
	}
	// 828A9B8C: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 828A9B90: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A9B94: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828A9B98: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828A9B9C: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828A9BA0: E8E10078  ld r7, 0x78(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828A9BA4: 4BFFEB0D  bl 0x828a86b0
	ctx.lr = 0x828A9BA8;
	sub_828A86B0(ctx, base);
	// 828A9BA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828A9BAC: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828A9BB0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9BB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9BB8: C30B3364  lfs f24, 0x3364(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13156 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 828A9BBC: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 828A9BC0: 4BF40BF1  bl 0x827ea7b0
	ctx.lr = 0x828A9BC4;
	sub_827EA7B0(ctx, base);
	// 828A9BC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9BC8: 48549861  bl 0x82df3428
	ctx.lr = 0x828A9BCC;
	sub_82DF3428(ctx, base);
	// 828A9BCC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9BD4: 808F14AC  lwz r4, 0x14ac(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5292 as u32) ) } as u64;
	// 828A9BD8: 396B5940  addi r11, r11, 0x5940
	ctx.r[11].s64 = ctx.r[11].s64 + 22848;
	// 828A9BDC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9BE0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9BE4: 48549E25  bl 0x82df3a08
	ctx.lr = 0x828A9BE8;
	sub_82DF3A08(ctx, base);
	// 828A9BE8: D3E100CC  stfs f31, 0xcc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 828A9BEC: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9BF0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 828A9BF4: D3610058  stfs f27, 0x58(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 828A9BF8: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828A9BFC: C01B9524  lfs f0, -0x6adc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828A9C00: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 828A9C04: 9101008C  stw r8, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 828A9C08: 80E100CC  lwz r7, 0xcc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 828A9C0C: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 828A9C10: 810100C4  lwz r8, 0xc4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 828A9C14: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 828A9C18: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828A9C1C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 828A9C20: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 828A9C24: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 828A9C28: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 828A9C2C: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 828A9C30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828A9C34: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9C38: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 828A9C3C: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828A9C40: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 828A9C44: 4200FFF0  bdnz 0x828a9c34
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x828A9C34; continue 'dispatch;
	}
	// 828A9C48: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 828A9C4C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828A9C50: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 828A9C54: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 828A9C58: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 828A9C5C: E8E10078  ld r7, 0x78(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 828A9C60: 4BFFEA51  bl 0x828a86b0
	ctx.lr = 0x828A9C64;
	sub_828A86B0(ctx, base);
	// 828A9C64: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 828A9C68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9C6C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9C70: FC20C090  fmr f1, f24
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[24].f64;
	// 828A9C74: 4BF40B3D  bl 0x827ea7b0
	ctx.lr = 0x828A9C78;
	sub_827EA7B0(ctx, base);
	// 828A9C78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9C7C: 485497AD  bl 0x82df3428
	ctx.lr = 0x828A9C80;
	sub_82DF3428(ctx, base);
	// 828A9C80: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9C84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9C88: 809514A8  lwz r4, 0x14a8(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(5288 as u32) ) } as u64;
	// 828A9C8C: 396B5168  addi r11, r11, 0x5168
	ctx.r[11].s64 = ctx.r[11].s64 + 20840;
	// 828A9C90: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9C94: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9C98: 48549D71  bl 0x82df3a08
	ctx.lr = 0x828A9C9C;
	sub_82DF3A08(ctx, base);
	// 828A9C9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9CA0: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9CA4: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9CA8: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9CAC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9CB0: 4BFFE901  bl 0x828a85b0
	ctx.lr = 0x828A9CB4;
	sub_828A85B0(ctx, base);
	// 828A9CB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A9CB8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9CBC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9CC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9CC4: C3EB9FFC  lfs f31, -0x6004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24580 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A9CC8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9CCC: 4BF40AE5  bl 0x827ea7b0
	ctx.lr = 0x828A9CD0;
	sub_827EA7B0(ctx, base);
	// 828A9CD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9CD4: 48549755  bl 0x82df3428
	ctx.lr = 0x828A9CD8;
	sub_82DF3428(ctx, base);
	// 828A9CD8: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9CE0: 808F14AC  lwz r4, 0x14ac(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(5292 as u32) ) } as u64;
	// 828A9CE4: 396B5168  addi r11, r11, 0x5168
	ctx.r[11].s64 = ctx.r[11].s64 + 20840;
	// 828A9CE8: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9CEC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9CF0: 48549D19  bl 0x82df3a08
	ctx.lr = 0x828A9CF4;
	sub_82DF3A08(ctx, base);
	// 828A9CF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9CF8: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9CFC: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9D00: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9D04: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9D08: 4BFFE8A9  bl 0x828a85b0
	ctx.lr = 0x828A9D0C;
	sub_828A85B0(ctx, base);
	// 828A9D0C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9D10: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9D18: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9D1C: 4BF40A95  bl 0x827ea7b0
	ctx.lr = 0x828A9D20;
	sub_827EA7B0(ctx, base);
	// 828A9D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D24: 48549705  bl 0x82df3428
	ctx.lr = 0x828A9D28;
	sub_82DF3428(ctx, base);
	// 828A9D28: 3D60828B  lis r11, -0x7d75
	ctx.r[11].s64 = -2104819712;
	// 828A9D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D30: 809514A8  lwz r4, 0x14a8(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(5288 as u32) ) } as u64;
	// 828A9D34: 396B8AA0  addi r11, r11, -0x7560
	ctx.r[11].s64 = ctx.r[11].s64 + -30048;
	// 828A9D38: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9D3C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9D40: 48549CC9  bl 0x82df3a08
	ctx.lr = 0x828A9D44;
	sub_82DF3A08(ctx, base);
	// 828A9D44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9D48: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9D4C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9D50: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9D54: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9D58: 4BFFE859  bl 0x828a85b0
	ctx.lr = 0x828A9D5C;
	sub_828A85B0(ctx, base);
	// 828A9D5C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828A9D60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9D64: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9D68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9D6C: C02B9FF8  lfs f1, -0x6008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24584 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828A9D70: 4BF40A41  bl 0x827ea7b0
	ctx.lr = 0x828A9D74;
	sub_827EA7B0(ctx, base);
	// 828A9D74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D78: 485496B1  bl 0x82df3428
	ctx.lr = 0x828A9D7C;
	sub_82DF3428(ctx, base);
	// 828A9D7C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9D80: 80941478  lwz r4, 0x1478(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(5240 as u32) ) } as u64;
	// 828A9D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9D88: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828A9D8C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9D90: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9D94: 48549C75  bl 0x82df3a08
	ctx.lr = 0x828A9D98;
	sub_82DF3A08(ctx, base);
	// 828A9D98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9D9C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9DA0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9DA4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9DA8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9DAC: 4BFFE805  bl 0x828a85b0
	ctx.lr = 0x828A9DB0;
	sub_828A85B0(ctx, base);
	// 828A9DB0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9DB4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9DB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9DBC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9DC0: 4BF409F1  bl 0x827ea7b0
	ctx.lr = 0x828A9DC4;
	sub_827EA7B0(ctx, base);
	// 828A9DC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9DC8: 48549661  bl 0x82df3428
	ctx.lr = 0x828A9DCC;
	sub_82DF3428(ctx, base);
	// 828A9DCC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9DD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9DD4: 80931480  lwz r4, 0x1480(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(5248 as u32) ) } as u64;
	// 828A9DD8: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828A9DDC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9DE0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9DE4: 48549C25  bl 0x82df3a08
	ctx.lr = 0x828A9DE8;
	sub_82DF3A08(ctx, base);
	// 828A9DE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9DEC: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9DF0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9DF4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9DF8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9DFC: 4BFFE7B5  bl 0x828a85b0
	ctx.lr = 0x828A9E00;
	sub_828A85B0(ctx, base);
	// 828A9E00: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9E04: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9E08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9E0C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9E10: 4BF409A1  bl 0x827ea7b0
	ctx.lr = 0x828A9E14;
	sub_827EA7B0(ctx, base);
	// 828A9E14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E18: 48549611  bl 0x82df3428
	ctx.lr = 0x828A9E1C;
	sub_82DF3428(ctx, base);
	// 828A9E1C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E24: 80911488  lwz r4, 0x1488(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(5256 as u32) ) } as u64;
	// 828A9E28: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828A9E2C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9E30: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9E34: 48549BD5  bl 0x82df3a08
	ctx.lr = 0x828A9E38;
	sub_82DF3A08(ctx, base);
	// 828A9E38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9E3C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9E40: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9E44: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9E48: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9E4C: 4BFFE765  bl 0x828a85b0
	ctx.lr = 0x828A9E50;
	sub_828A85B0(ctx, base);
	// 828A9E50: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9E54: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9E58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9E5C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9E60: 4BF40951  bl 0x827ea7b0
	ctx.lr = 0x828A9E64;
	sub_827EA7B0(ctx, base);
	// 828A9E64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E68: 485495C1  bl 0x82df3428
	ctx.lr = 0x828A9E6C;
	sub_82DF3428(ctx, base);
	// 828A9E6C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9E74: 80921484  lwz r4, 0x1484(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(5252 as u32) ) } as u64;
	// 828A9E78: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828A9E7C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9E80: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9E84: 48549B85  bl 0x82df3a08
	ctx.lr = 0x828A9E88;
	sub_82DF3A08(ctx, base);
	// 828A9E88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9E8C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9E90: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9E94: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9E98: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9E9C: 4BFFE715  bl 0x828a85b0
	ctx.lr = 0x828A9EA0;
	sub_828A85B0(ctx, base);
	// 828A9EA0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9EA4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9EA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9EAC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9EB0: 4BF40901  bl 0x827ea7b0
	ctx.lr = 0x828A9EB4;
	sub_827EA7B0(ctx, base);
	// 828A9EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9EB8: 48549571  bl 0x82df3428
	ctx.lr = 0x828A9EBC;
	sub_82DF3428(ctx, base);
	// 828A9EBC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9EC0: 8090148C  lwz r4, 0x148c(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(5260 as u32) ) } as u64;
	// 828A9EC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9EC8: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828A9ECC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9ED0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9ED4: 48549B35  bl 0x82df3a08
	ctx.lr = 0x828A9ED8;
	sub_82DF3A08(ctx, base);
	// 828A9ED8: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9EDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9EE0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9EE4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9EE8: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9EEC: 4BFFE6C5  bl 0x828a85b0
	ctx.lr = 0x828A9EF0;
	sub_828A85B0(ctx, base);
	// 828A9EF0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9EF4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9EFC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828A9F00: 4BF408B1  bl 0x827ea7b0
	ctx.lr = 0x828A9F04;
	sub_827EA7B0(ctx, base);
	// 828A9F04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F08: 48549521  bl 0x82df3428
	ctx.lr = 0x828A9F0C;
	sub_82DF3428(ctx, base);
	// 828A9F0C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F14: 80941478  lwz r4, 0x1478(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(5240 as u32) ) } as u64;
	// 828A9F18: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828A9F1C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9F20: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9F24: 48549AE5  bl 0x82df3a08
	ctx.lr = 0x828A9F28;
	sub_82DF3A08(ctx, base);
	// 828A9F28: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9F2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9F30: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9F34: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9F38: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9F3C: 4BFFE675  bl 0x828a85b0
	ctx.lr = 0x828A9F40;
	sub_828A85B0(ctx, base);
	// 828A9F40: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828A9F44: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9F48: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9F4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9F50: C3EB28C8  lfs f31, 0x28c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10440 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828A9F54: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9F58: 4BF40859  bl 0x827ea7b0
	ctx.lr = 0x828A9F5C;
	sub_827EA7B0(ctx, base);
	// 828A9F5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F60: 485494C9  bl 0x82df3428
	ctx.lr = 0x828A9F64;
	sub_82DF3428(ctx, base);
	// 828A9F64: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9F68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9F6C: 80931480  lwz r4, 0x1480(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(5248 as u32) ) } as u64;
	// 828A9F70: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828A9F74: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9F78: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9F7C: 48549A8D  bl 0x82df3a08
	ctx.lr = 0x828A9F80;
	sub_82DF3A08(ctx, base);
	// 828A9F80: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828A9F84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9F88: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9F8C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9F90: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828A9F94: 4BFFE61D  bl 0x828a85b0
	ctx.lr = 0x828A9F98;
	sub_828A85B0(ctx, base);
	// 828A9F98: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9F9C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9FA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9FA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9FA8: 4BF40809  bl 0x827ea7b0
	ctx.lr = 0x828A9FAC;
	sub_827EA7B0(ctx, base);
	// 828A9FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9FB0: 48549479  bl 0x82df3428
	ctx.lr = 0x828A9FB4;
	sub_82DF3428(ctx, base);
	// 828A9FB4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828A9FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828A9FBC: 80911488  lwz r4, 0x1488(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(5256 as u32) ) } as u64;
	// 828A9FC0: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828A9FC4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828A9FC8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828A9FCC: 48549A3D  bl 0x82df3a08
	ctx.lr = 0x828A9FD0;
	sub_82DF3A08(ctx, base);
	// 828A9FD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828A9FD4: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 828A9FD8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828A9FDC: E8A10088  ld r5, 0x88(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 828A9FE0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828A9FE4: 4BFFE5CD  bl 0x828a85b0
	ctx.lr = 0x828A9FE8;
	sub_828A85B0(ctx, base);
	// 828A9FE8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828A9FEC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828A9FF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828A9FF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828A9FF8: 4BF407B9  bl 0x827ea7b0
	ctx.lr = 0x828A9FFC;
	sub_827EA7B0(ctx, base);
	// 828A9FFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA000: 48549429  bl 0x82df3428
	ctx.lr = 0x828AA004;
	sub_82DF3428(ctx, base);
	// 828AA004: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA008: 80921484  lwz r4, 0x1484(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(5252 as u32) ) } as u64;
	// 828AA00C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA010: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA014: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA018: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA01C: 485499ED  bl 0x82df3a08
	ctx.lr = 0x828AA020;
	sub_82DF3A08(ctx, base);
	// 828AA020: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA024: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA028: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA02C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA030: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA034: 4BFFE57D  bl 0x828a85b0
	ctx.lr = 0x828AA038;
	sub_828A85B0(ctx, base);
	// 828AA038: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA03C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA040: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA044: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA048: 4BF40769  bl 0x827ea7b0
	ctx.lr = 0x828AA04C;
	sub_827EA7B0(ctx, base);
	// 828AA04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA050: 485493D9  bl 0x82df3428
	ctx.lr = 0x828AA054;
	sub_82DF3428(ctx, base);
	// 828AA054: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA05C: 8090148C  lwz r4, 0x148c(r16)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(5260 as u32) ) } as u64;
	// 828AA060: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA064: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA068: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA06C: 4854999D  bl 0x82df3a08
	ctx.lr = 0x828AA070;
	sub_82DF3A08(ctx, base);
	// 828AA070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA074: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA078: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA07C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA080: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA084: 4BFFE52D  bl 0x828a85b0
	ctx.lr = 0x828AA088;
	sub_828A85B0(ctx, base);
	// 828AA088: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA08C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA090: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA094: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA098: 4BF40719  bl 0x827ea7b0
	ctx.lr = 0x828AA09C;
	sub_827EA7B0(ctx, base);
	// 828AA09C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA0A0: 48549389  bl 0x82df3428
	ctx.lr = 0x828AA0A4;
	sub_82DF3428(ctx, base);
	// 828AA0A4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA0AC: 809A14C0  lwz r4, 0x14c0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828AA0B0: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA0B4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA0B8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA0BC: 4854994D  bl 0x82df3a08
	ctx.lr = 0x828AA0C0;
	sub_82DF3A08(ctx, base);
	// 828AA0C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA0C4: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA0C8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA0CC: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA0D0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA0D4: 4BFFE4DD  bl 0x828a85b0
	ctx.lr = 0x828AA0D8;
	sub_828A85B0(ctx, base);
	// 828AA0D8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA0DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA0E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA0E4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AA0E8: 4BF406C9  bl 0x827ea7b0
	ctx.lr = 0x828AA0EC;
	sub_827EA7B0(ctx, base);
	// 828AA0EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA0F0: 48549339  bl 0x82df3428
	ctx.lr = 0x828AA0F4;
	sub_82DF3428(ctx, base);
	// 828AA0F4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA0F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA0FC: 809714C8  lwz r4, 0x14c8(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(5320 as u32) ) } as u64;
	// 828AA100: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA104: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA108: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA10C: 485498FD  bl 0x82df3a08
	ctx.lr = 0x828AA110;
	sub_82DF3A08(ctx, base);
	// 828AA110: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA118: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA11C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA120: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA124: 4BFFE48D  bl 0x828a85b0
	ctx.lr = 0x828AA128;
	sub_828A85B0(ctx, base);
	// 828AA128: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA12C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA130: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA134: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AA138: 4BF40679  bl 0x827ea7b0
	ctx.lr = 0x828AA13C;
	sub_827EA7B0(ctx, base);
	// 828AA13C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA140: 485492E9  bl 0x82df3428
	ctx.lr = 0x828AA144;
	sub_82DF3428(ctx, base);
	// 828AA144: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA148: 809614D0  lwz r4, 0x14d0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(5328 as u32) ) } as u64;
	// 828AA14C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA150: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA154: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA158: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA15C: 485498AD  bl 0x82df3a08
	ctx.lr = 0x828AA160;
	sub_82DF3A08(ctx, base);
	// 828AA160: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA164: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA168: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA16C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA170: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA174: 4BFFE43D  bl 0x828a85b0
	ctx.lr = 0x828AA178;
	sub_828A85B0(ctx, base);
	// 828AA178: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA17C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA184: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AA188: 4BF40629  bl 0x827ea7b0
	ctx.lr = 0x828AA18C;
	sub_827EA7B0(ctx, base);
	// 828AA18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA190: 48549299  bl 0x82df3428
	ctx.lr = 0x828AA194;
	sub_82DF3428(ctx, base);
	// 828AA194: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA19C: 809914CC  lwz r4, 0x14cc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(5324 as u32) ) } as u64;
	// 828AA1A0: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA1A4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA1A8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA1AC: 4854985D  bl 0x82df3a08
	ctx.lr = 0x828AA1B0;
	sub_82DF3A08(ctx, base);
	// 828AA1B0: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA1B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA1B8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA1BC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA1C0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA1C4: 4BFFE3ED  bl 0x828a85b0
	ctx.lr = 0x828AA1C8;
	sub_828A85B0(ctx, base);
	// 828AA1C8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA1CC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA1D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA1D4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AA1D8: 4BF405D9  bl 0x827ea7b0
	ctx.lr = 0x828AA1DC;
	sub_827EA7B0(ctx, base);
	// 828AA1DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA1E0: 48549249  bl 0x82df3428
	ctx.lr = 0x828AA1E4;
	sub_82DF3428(ctx, base);
	// 828AA1E4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA1E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA1EC: 809814D4  lwz r4, 0x14d4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(5332 as u32) ) } as u64;
	// 828AA1F0: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA1F4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA1F8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA1FC: 4854980D  bl 0x82df3a08
	ctx.lr = 0x828AA200;
	sub_82DF3A08(ctx, base);
	// 828AA200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA204: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA208: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA20C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA210: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA214: 4BFFE39D  bl 0x828a85b0
	ctx.lr = 0x828AA218;
	sub_828A85B0(ctx, base);
	// 828AA218: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA21C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA220: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA224: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AA228: 4BF40589  bl 0x827ea7b0
	ctx.lr = 0x828AA22C;
	sub_827EA7B0(ctx, base);
	// 828AA22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA230: 485491F9  bl 0x82df3428
	ctx.lr = 0x828AA234;
	sub_82DF3428(ctx, base);
	// 828AA234: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA23C: 809A14C0  lwz r4, 0x14c0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828AA240: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA244: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA248: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA24C: 485497BD  bl 0x82df3a08
	ctx.lr = 0x828AA250;
	sub_82DF3A08(ctx, base);
	// 828AA250: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA254: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA258: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA25C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA260: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA264: 4BFFE34D  bl 0x828a85b0
	ctx.lr = 0x828AA268;
	sub_828A85B0(ctx, base);
	// 828AA268: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AA26C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA270: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA274: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA278: C3EB89AC  lfs f31, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AA27C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA280: 4BF40531  bl 0x827ea7b0
	ctx.lr = 0x828AA284;
	sub_827EA7B0(ctx, base);
	// 828AA284: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA288: 485491A1  bl 0x82df3428
	ctx.lr = 0x828AA28C;
	sub_82DF3428(ctx, base);
	// 828AA28C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA290: 809714C8  lwz r4, 0x14c8(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(5320 as u32) ) } as u64;
	// 828AA294: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA298: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA29C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA2A0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA2A4: 48549765  bl 0x82df3a08
	ctx.lr = 0x828AA2A8;
	sub_82DF3A08(ctx, base);
	// 828AA2A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA2AC: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA2B0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA2B4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA2B8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA2BC: 4BFFE2F5  bl 0x828a85b0
	ctx.lr = 0x828AA2C0;
	sub_828A85B0(ctx, base);
	// 828AA2C0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA2C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA2C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA2CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA2D0: 4BF404E1  bl 0x827ea7b0
	ctx.lr = 0x828AA2D4;
	sub_827EA7B0(ctx, base);
	// 828AA2D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA2D8: 48549151  bl 0x82df3428
	ctx.lr = 0x828AA2DC;
	sub_82DF3428(ctx, base);
	// 828AA2DC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA2E4: 809614D0  lwz r4, 0x14d0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(5328 as u32) ) } as u64;
	// 828AA2E8: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA2EC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA2F0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA2F4: 48549715  bl 0x82df3a08
	ctx.lr = 0x828AA2F8;
	sub_82DF3A08(ctx, base);
	// 828AA2F8: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA2FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA300: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA304: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA308: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA30C: 4BFFE2A5  bl 0x828a85b0
	ctx.lr = 0x828AA310;
	sub_828A85B0(ctx, base);
	// 828AA310: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA314: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA318: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA31C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA320: 4BF40491  bl 0x827ea7b0
	ctx.lr = 0x828AA324;
	sub_827EA7B0(ctx, base);
	// 828AA324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA328: 48549101  bl 0x82df3428
	ctx.lr = 0x828AA32C;
	sub_82DF3428(ctx, base);
	// 828AA32C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA334: 809914CC  lwz r4, 0x14cc(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(5324 as u32) ) } as u64;
	// 828AA338: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA33C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA340: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA344: 485496C5  bl 0x82df3a08
	ctx.lr = 0x828AA348;
	sub_82DF3A08(ctx, base);
	// 828AA348: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA34C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA350: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA354: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA358: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA35C: 4BFFE255  bl 0x828a85b0
	ctx.lr = 0x828AA360;
	sub_828A85B0(ctx, base);
	// 828AA360: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA364: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA36C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA370: 4BF40441  bl 0x827ea7b0
	ctx.lr = 0x828AA374;
	sub_827EA7B0(ctx, base);
	// 828AA374: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA378: 485490B1  bl 0x82df3428
	ctx.lr = 0x828AA37C;
	sub_82DF3428(ctx, base);
	// 828AA37C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA384: 809814D4  lwz r4, 0x14d4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(5332 as u32) ) } as u64;
	// 828AA388: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA38C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA390: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA394: 48549675  bl 0x82df3a08
	ctx.lr = 0x828AA398;
	sub_82DF3A08(ctx, base);
	// 828AA398: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA39C: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA3A0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA3A4: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA3A8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA3AC: 4BFFE205  bl 0x828a85b0
	ctx.lr = 0x828AA3B0;
	sub_828A85B0(ctx, base);
	// 828AA3B0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA3B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA3B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA3BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AA3C0: 4BF403F1  bl 0x827ea7b0
	ctx.lr = 0x828AA3C4;
	sub_827EA7B0(ctx, base);
	// 828AA3C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA3C8: 48549061  bl 0x82df3428
	ctx.lr = 0x828AA3CC;
	sub_82DF3428(ctx, base);
	// 828AA3CC: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA3D0: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA3D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA3D8: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA3DC: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA3E0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA3E4: 48549625  bl 0x82df3a08
	ctx.lr = 0x828AA3E8;
	sub_82DF3A08(ctx, base);
	// 828AA3E8: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA3EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA3F0: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA3F4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA3F8: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA3FC: 4BFFE1B5  bl 0x828a85b0
	ctx.lr = 0x828AA400;
	sub_828A85B0(ctx, base);
	// 828AA400: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AA404: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA408: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA40C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA410: C02B9FF4  lfs f1, -0x600c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24588 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AA414: 4BF4039D  bl 0x827ea7b0
	ctx.lr = 0x828AA418;
	sub_827EA7B0(ctx, base);
	// 828AA418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA41C: 4854900D  bl 0x82df3428
	ctx.lr = 0x828AA420;
	sub_82DF3428(ctx, base);
	// 828AA420: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA428: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA42C: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA430: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA434: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA438: 485495D1  bl 0x82df3a08
	ctx.lr = 0x828AA43C;
	sub_82DF3A08(ctx, base);
	// 828AA43C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA440: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA444: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA448: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA44C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA450: 4BFFE161  bl 0x828a85b0
	ctx.lr = 0x828AA454;
	sub_828A85B0(ctx, base);
	// 828AA454: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA458: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA45C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AA460: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 828AA464: 4BF4034D  bl 0x827ea7b0
	ctx.lr = 0x828AA468;
	sub_827EA7B0(ctx, base);
	// 828AA468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA46C: 48548FBD  bl 0x82df3428
	ctx.lr = 0x828AA470;
	sub_82DF3428(ctx, base);
	// 828AA470: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA478: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA47C: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA480: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA484: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA488: 48549581  bl 0x82df3a08
	ctx.lr = 0x828AA48C;
	sub_82DF3A08(ctx, base);
	// 828AA48C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA490: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA494: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA498: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA49C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA4A0: 4BFFE111  bl 0x828a85b0
	ctx.lr = 0x828AA4A4;
	sub_828A85B0(ctx, base);
	// 828AA4A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AA4A8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA4AC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA4B0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828AA4B4: C02B9C48  lfs f1, -0x63b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25528 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AA4B8: 4BF402F9  bl 0x827ea7b0
	ctx.lr = 0x828AA4BC;
	sub_827EA7B0(ctx, base);
	// 828AA4BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AA4C0: 48548F69  bl 0x82df3428
	ctx.lr = 0x828AA4C4;
	sub_82DF3428(ctx, base);
	// 828AA4C4: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA4C8: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 828AA4CC: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA4D0: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA4D4: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA4D8: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA4DC: 4854952D  bl 0x82df3a08
	ctx.lr = 0x828AA4E0;
	sub_82DF3A08(ctx, base);
	// 828AA4E0: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA4E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA4E8: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA4EC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA4F0: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA4F4: 4BFFE0BD  bl 0x828a85b0
	ctx.lr = 0x828AA4F8;
	sub_828A85B0(ctx, base);
	// 828AA4F8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA4FC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA500: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 828AA504: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 828AA508: 4BF402A9  bl 0x827ea7b0
	ctx.lr = 0x828AA50C;
	sub_827EA7B0(ctx, base);
	// 828AA50C: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 828AA510: 48548F19  bl 0x82df3428
	ctx.lr = 0x828AA514;
	sub_82DF3428(ctx, base);
	// 828AA514: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA518: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA51C: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 828AA520: 396B3128  addi r11, r11, 0x3128
	ctx.r[11].s64 = ctx.r[11].s64 + 12584;
	// 828AA524: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA528: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA52C: 485494DD  bl 0x82df3a08
	ctx.lr = 0x828AA530;
	sub_82DF3A08(ctx, base);
	// 828AA530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA534: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA538: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA53C: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA540: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA544: 4BFFE06D  bl 0x828a85b0
	ctx.lr = 0x828AA548;
	sub_828A85B0(ctx, base);
	// 828AA548: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AA54C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA550: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA554: 388100C4  addi r4, r1, 0xc4
	ctx.r[4].s64 = ctx.r[1].s64 + 196;
	// 828AA558: C02B9FF0  lfs f1, -0x6010(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24592 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AA55C: 4BF40255  bl 0x827ea7b0
	ctx.lr = 0x828AA560;
	sub_827EA7B0(ctx, base);
	// 828AA560: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 828AA564: 48548EC5  bl 0x82df3428
	ctx.lr = 0x828AA568;
	sub_82DF3428(ctx, base);
	// 828AA568: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AA56C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA570: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA574: 396B3140  addi r11, r11, 0x3140
	ctx.r[11].s64 = ctx.r[11].s64 + 12608;
	// 828AA578: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AA57C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA580: 48549489  bl 0x82df3a08
	ctx.lr = 0x828AA584;
	sub_82DF3A08(ctx, base);
	// 828AA584: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AA588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA58C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AA590: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AA594: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AA598: 4BFFE019  bl 0x828a85b0
	ctx.lr = 0x828AA59C;
	sub_828A85B0(ctx, base);
	// 828AA59C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AA5A0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA5A4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 828AA5A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AA5AC: C02B61C0  lfs f1, 0x61c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25024 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AA5B0: 4BF40201  bl 0x827ea7b0
	ctx.lr = 0x828AA5B4;
	sub_827EA7B0(ctx, base);
	// 828AA5B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA5B8: 48548E71  bl 0x82df3428
	ctx.lr = 0x828AA5BC;
	sub_82DF3428(ctx, base);
	// 828AA5BC: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828AA5C0: 82A10354  lwz r21, 0x354(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(852 as u32) ) } as u64;
	// 828AA5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA5C8: 7EAFAB78  mr r15, r21
	ctx.r[15].u64 = ctx.r[21].u64;
	// 828AA5CC: 409A0008  bne cr6, 0x828aa5d4
	if !ctx.cr[6].eq {
	pc = 0x828AA5D4; continue 'dispatch;
	}
	// 828AA5D0: 7FEFFB78  mr r15, r31
	ctx.r[15].u64 = ctx.r[31].u64;
	// 828AA5D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA5D8: 809C1494  lwz r4, 0x1494(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AA5DC: 4854942D  bl 0x82df3a08
	ctx.lr = 0x828AA5E0;
	sub_82DF3A08(ctx, base);
	// 828AA5E0: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 828AA5E4: 81E100D4  lwz r15, 0xd4(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 828AA5E8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AA5EC: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA5F0: 386F0144  addi r3, r15, 0x144
	ctx.r[3].s64 = ctx.r[15].s64 + 324;
	// 828AA5F4: 480AD5B5  bl 0x82957ba8
	ctx.lr = 0x828AA5F8;
	sub_82957BA8(ctx, base);
	// 828AA5F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA5FC: 48548E2D  bl 0x82df3428
	ctx.lr = 0x828AA600;
	sub_82DF3428(ctx, base);
	// 828AA600: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828AA604: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA60C: 409A0008  bne cr6, 0x828aa614
	if !ctx.cr[6].eq {
	pc = 0x828AA614; continue 'dispatch;
	}
	// 828AA610: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA614: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA618: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA61C: 808B14E4  lwz r4, 0x14e4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5348 as u32) ) } as u64;
	// 828AA620: 485493E9  bl 0x82df3a08
	ctx.lr = 0x828AA624;
	sub_82DF3A08(ctx, base);
	// 828AA624: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA628: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA62C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AA630: 386F0104  addi r3, r15, 0x104
	ctx.r[3].s64 = ctx.r[15].s64 + 260;
	// 828AA634: 480AD525  bl 0x82957b58
	ctx.lr = 0x828AA638;
	sub_82957B58(ctx, base);
	// 828AA638: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA63C: 48548DED  bl 0x82df3428
	ctx.lr = 0x828AA640;
	sub_82DF3428(ctx, base);
	// 828AA640: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828AA644: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA64C: 409A0008  bne cr6, 0x828aa654
	if !ctx.cr[6].eq {
	pc = 0x828AA654; continue 'dispatch;
	}
	// 828AA650: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA654: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA658: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA65C: 808B14D8  lwz r4, 0x14d8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5336 as u32) ) } as u64;
	// 828AA660: 485493A9  bl 0x82df3a08
	ctx.lr = 0x828AA664;
	sub_82DF3A08(ctx, base);
	// 828AA664: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA668: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA66C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AA670: 386F0098  addi r3, r15, 0x98
	ctx.r[3].s64 = ctx.r[15].s64 + 152;
	// 828AA674: 480AD495  bl 0x82957b08
	ctx.lr = 0x828AA678;
	sub_82957B08(ctx, base);
	// 828AA678: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA67C: 48548DAD  bl 0x82df3428
	ctx.lr = 0x828AA680;
	sub_82DF3428(ctx, base);
	// 828AA680: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828AA684: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA68C: 409A0008  bne cr6, 0x828aa694
	if !ctx.cr[6].eq {
	pc = 0x828AA694; continue 'dispatch;
	}
	// 828AA690: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA694: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA698: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA69C: 808B14DC  lwz r4, 0x14dc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5340 as u32) ) } as u64;
	// 828AA6A0: 48549369  bl 0x82df3a08
	ctx.lr = 0x828AA6A4;
	sub_82DF3A08(ctx, base);
	// 828AA6A4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA6A8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA6AC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AA6B0: 386F00BC  addi r3, r15, 0xbc
	ctx.r[3].s64 = ctx.r[15].s64 + 188;
	// 828AA6B4: 480AD455  bl 0x82957b08
	ctx.lr = 0x828AA6B8;
	sub_82957B08(ctx, base);
	// 828AA6B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA6BC: 48548D6D  bl 0x82df3428
	ctx.lr = 0x828AA6C0;
	sub_82DF3428(ctx, base);
	// 828AA6C0: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828AA6C4: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AA6CC: 409A0008  bne cr6, 0x828aa6d4
	if !ctx.cr[6].eq {
	pc = 0x828AA6D4; continue 'dispatch;
	}
	// 828AA6D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA6D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA6D8: 808E14E0  lwz r4, 0x14e0(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(5344 as u32) ) } as u64;
	// 828AA6DC: 4854932D  bl 0x82df3a08
	ctx.lr = 0x828AA6E0;
	sub_82DF3A08(ctx, base);
	// 828AA6E0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA6E4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AA6E8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA6EC: 386F00E0  addi r3, r15, 0xe0
	ctx.r[3].s64 = ctx.r[15].s64 + 224;
	// 828AA6F0: 480AD419  bl 0x82957b08
	ctx.lr = 0x828AA6F4;
	sub_82957B08(ctx, base);
	// 828AA6F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA6F8: 48548D31  bl 0x82df3428
	ctx.lr = 0x828AA6FC;
	sub_82DF3428(ctx, base);
	// 828AA6FC: 81C100C8  lwz r14, 0xc8(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 828AA700: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA704: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AA708: 409A0008  bne cr6, 0x828aa710
	if !ctx.cr[6].eq {
	pc = 0x828AA710; continue 'dispatch;
	}
	// 828AA70C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA710: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA714: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA718: 808B1490  lwz r4, 0x1490(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5264 as u32) ) } as u64;
	// 828AA71C: 485492ED  bl 0x82df3a08
	ctx.lr = 0x828AA720;
	sub_82DF3A08(ctx, base);
	// 828AA720: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA724: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA728: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AA72C: 386F0058  addi r3, r15, 0x58
	ctx.r[3].s64 = ctx.r[15].s64 + 88;
	// 828AA730: 480AD429  bl 0x82957b58
	ctx.lr = 0x828AA734;
	sub_82957B58(ctx, base);
	// 828AA734: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA738: 48548CF1  bl 0x82df3428
	ctx.lr = 0x828AA73C;
	sub_82DF3428(ctx, base);
	// 828AA73C: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AA740: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA744: 409A0008  bne cr6, 0x828aa74c
	if !ctx.cr[6].eq {
	pc = 0x828AA74C; continue 'dispatch;
	}
	// 828AA748: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA74C: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 828AA750: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AA754: 808B147C  lwz r4, 0x147c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5244 as u32) ) } as u64;
	// 828AA758: 485492B1  bl 0x82df3a08
	ctx.lr = 0x828AA75C;
	sub_82DF3A08(ctx, base);
	// 828AA75C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA760: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA764: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 828AA768: 386F01A8  addi r3, r15, 0x1a8
	ctx.r[3].s64 = ctx.r[15].s64 + 424;
	// 828AA76C: 480AD39D  bl 0x82957b08
	ctx.lr = 0x828AA770;
	sub_82957B08(ctx, base);
	// 828AA770: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AA774: 48548CB5  bl 0x82df3428
	ctx.lr = 0x828AA778;
	sub_82DF3428(ctx, base);
	// 828AA778: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AA77C: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 828AA780: 409A0008  bne cr6, 0x828aa788
	if !ctx.cr[6].eq {
	pc = 0x828AA788; continue 'dispatch;
	}
	// 828AA784: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AA788: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA78C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AA790: 808B14C4  lwz r4, 0x14c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5316 as u32) ) } as u64;
	// 828AA794: 48549275  bl 0x82df3a08
	ctx.lr = 0x828AA798;
	sub_82DF3A08(ctx, base);
	// 828AA798: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 828AA79C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA7A0: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 828AA7A4: 386F01F0  addi r3, r15, 0x1f0
	ctx.r[3].s64 = ctx.r[15].s64 + 496;
	// 828AA7A8: 480AD361  bl 0x82957b08
	ctx.lr = 0x828AA7AC;
	sub_82957B08(ctx, base);
	// 828AA7AC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AA7B0: 48548C79  bl 0x82df3428
	ctx.lr = 0x828AA7B4;
	sub_82DF3428(ctx, base);
	// 828AA7B4: 80F0148C  lwz r7, 0x148c(r16)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(5260 as u32) ) } as u64;
	// 828AA7B8: 81741478  lwz r11, 0x1478(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(5240 as u32) ) } as u64;
	// 828AA7BC: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AA7C0: 81531480  lwz r10, 0x1480(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(5248 as u32) ) } as u64;
	// 828AA7C4: 81311488  lwz r9, 0x1488(r17)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(5256 as u32) ) } as u64;
	// 828AA7C8: 81121484  lwz r8, 0x1484(r18)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(5252 as u32) ) } as u64;
	// 828AA7CC: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 828AA7D0: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 828AA7D4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA7D8: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 828AA7DC: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 828AA7E0: 9101008C  stw r8, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 828AA7E4: 409A0008  bne cr6, 0x828aa7ec
	if !ctx.cr[6].eq {
	pc = 0x828AA7EC; continue 'dispatch;
	}
	// 828AA7E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828AA7EC: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 828AA7F0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA7F4: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828AA7F8: 386F01CC  addi r3, r15, 0x1cc
	ctx.r[3].s64 = ctx.r[15].s64 + 460;
	// 828AA7FC: 480AD28D  bl 0x82957a88
	ctx.lr = 0x828AA800;
	sub_82957A88(ctx, base);
	// 828AA800: 80F814D4  lwz r7, 0x14d4(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(5332 as u32) ) } as u64;
	// 828AA804: 817A14C0  lwz r11, 0x14c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(5312 as u32) ) } as u64;
	// 828AA808: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AA80C: 815714C8  lwz r10, 0x14c8(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(5320 as u32) ) } as u64;
	// 828AA810: 813614D0  lwz r9, 0x14d0(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(5328 as u32) ) } as u64;
	// 828AA814: 811914CC  lwz r8, 0x14cc(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(5324 as u32) ) } as u64;
	// 828AA818: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 828AA81C: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 828AA820: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AA824: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 828AA828: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 828AA82C: 9101008C  stw r8, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 828AA830: 409A0008  bne cr6, 0x828aa838
	if !ctx.cr[6].eq {
	pc = 0x828AA838; continue 'dispatch;
	}
	// 828AA834: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 828AA838: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 828AA83C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA840: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 828AA844: 386F0214  addi r3, r15, 0x214
	ctx.r[3].s64 = ctx.r[15].s64 + 532;
	// 828AA848: 480AD241  bl 0x82957a88
	ctx.lr = 0x828AA84C;
	sub_82957A88(ctx, base);
	// 828AA84C: 832100D0  lwz r25, 0xd0(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 828AA850: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AA854: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AA858: 38A0018B  li r5, 0x18b
	ctx.r[5].s64 = 395;
	// 828AA85C: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 828AA860: 4BA15B79  bl 0x822c03d8
	ctx.lr = 0x828AA864;
	sub_822C03D8(ctx, base);
	// 828AA864: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AA868: 4182001C  beq 0x828aa884
	if ctx.cr[0].eq {
	pc = 0x828AA884; continue 'dispatch;
	}
	// 828AA86C: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AA870: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828AA874: 409A0008  bne cr6, 0x828aa87c
	if !ctx.cr[6].eq {
	pc = 0x828AA87C; continue 'dispatch;
	}
	// 828AA878: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AA87C: 48001605  bl 0x828abe80
	ctx.lr = 0x828AA880;
	sub_828ABE80(ctx, base);
	// 828AA880: 48000008  b 0x828aa888
	pc = 0x828AA888; continue 'dispatch;
	// 828AA884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AA888: 3B5500E4  addi r26, r21, 0xe4
	ctx.r[26].s64 = ctx.r[21].s64 + 228;
	// 828AA88C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA890: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AA894: 4BFFB2BD  bl 0x828a5b50
	ctx.lr = 0x828AA898;
	sub_828A5B50(ctx, base);
	// 828AA898: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AA89C: 4BF418C5  bl 0x827ec160
	ctx.lr = 0x828AA8A0;
	sub_827EC160(ctx, base);
	// 828AA8A0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828AA8A4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AA8A8: 83980000  lwz r28, 0(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA8AC: 48168DD5  bl 0x82a13680
	ctx.lr = 0x828AA8B0;
	sub_82A13680(ctx, base);
	// 828AA8B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA8B4: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 828AA8B8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828AA8BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AA8C0: 4E800421  bctrl
	ctx.lr = 0x828AA8C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AA8C4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AA8C8: 83980000  lwz r28, 0(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA8CC: 48168DBD  bl 0x82a13688
	ctx.lr = 0x828AA8D0;
	sub_82A13688(ctx, base);
	// 828AA8D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA8D4: 817C0014  lwz r11, 0x14(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 828AA8D8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828AA8DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AA8E0: 4E800421  bctrl
	ctx.lr = 0x828AA8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AA8E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AA8E8: 48076A91  bl 0x82921378
	ctx.lr = 0x828AA8EC;
	sub_82921378(ctx, base);
	// 828AA8EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AA8F0: C01B9524  lfs f0, -0x6adc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AA8F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AA8F8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828AA8FC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 828AA900: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AA904: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 828AA908: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828AA90C: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AA910: C1AA959C  lfs f13, -0x6a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AA914: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828AA918: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 828AA91C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AA920: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828AA924: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AA928: 4E800421  bctrl
	ctx.lr = 0x828AA92C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AA92C: 817500FC  lwz r11, 0xfc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(252 as u32) ) } as u64;
	// 828AA930: 3B9500FC  addi r28, r21, 0xfc
	ctx.r[28].s64 = ctx.r[21].s64 + 252;
	// 828AA934: 809500E4  lwz r4, 0xe4(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(228 as u32) ) } as u64;
	// 828AA938: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA93C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AA940: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AA944: 4E800421  bctrl
	ctx.lr = 0x828AA948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AA948: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828AA94C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828AA950: 809B0AF0  lwz r4, 0xaf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828AA954: 485490B5  bl 0x82df3a08
	ctx.lr = 0x828AA958;
	sub_82DF3A08(ctx, base);
	// 828AA958: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA95C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA960: 4BFFD531  bl 0x828a7e90
	ctx.lr = 0x828AA964;
	sub_828A7E90(ctx, base);
	// 828AA964: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AA968: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 828AA96C: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828AA970: 48549099  bl 0x82df3a08
	ctx.lr = 0x828AA974;
	sub_82DF3A08(ctx, base);
	// 828AA974: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA97C: 4BFFD575  bl 0x828a7ef0
	ctx.lr = 0x828AA980;
	sub_828A7EF0(ctx, base);
	// 828AA980: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA984: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AA988: 808B1534  lwz r4, 0x1534(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5428 as u32) ) } as u64;
	// 828AA98C: 4854907D  bl 0x82df3a08
	ctx.lr = 0x828AA990;
	sub_82DF3A08(ctx, base);
	// 828AA990: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA994: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA998: 4BFFD5B9  bl 0x828a7f50
	ctx.lr = 0x828AA99C;
	sub_828A7F50(ctx, base);
	// 828AA99C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AA9A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AA9A4: 808B1538  lwz r4, 0x1538(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5432 as u32) ) } as u64;
	// 828AA9A8: 48549061  bl 0x82df3a08
	ctx.lr = 0x828AA9AC;
	sub_82DF3A08(ctx, base);
	// 828AA9AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA9B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA9B4: 4BFFD5FD  bl 0x828a7fb0
	ctx.lr = 0x828AA9B8;
	sub_828A7FB0(ctx, base);
	// 828AA9B8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AA9BC: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 828AA9C0: 808B0AF8  lwz r4, 0xaf8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2808 as u32) ) } as u64;
	// 828AA9C4: 48549045  bl 0x82df3a08
	ctx.lr = 0x828AA9C8;
	sub_82DF3A08(ctx, base);
	// 828AA9C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA9CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA9D0: 4BFFD4C1  bl 0x828a7e90
	ctx.lr = 0x828AA9D4;
	sub_828A7E90(ctx, base);
	// 828AA9D4: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AA9D8: 386100CC  addi r3, r1, 0xcc
	ctx.r[3].s64 = ctx.r[1].s64 + 204;
	// 828AA9DC: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828AA9E0: 48549029  bl 0x82df3a08
	ctx.lr = 0x828AA9E4;
	sub_82DF3A08(ctx, base);
	// 828AA9E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AA9E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AA9EC: 4BFFD625  bl 0x828a8010
	ctx.lr = 0x828AA9F0;
	sub_828A8010(ctx, base);
	// 828AA9F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AA9F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AA9F8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828AA9FC: 4854900D  bl 0x82df3a08
	ctx.lr = 0x828AAA00;
	sub_82DF3A08(ctx, base);
	// 828AAA00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAA04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA08: 4BFFD669  bl 0x828a8070
	ctx.lr = 0x828AAA0C;
	sub_828A8070(ctx, base);
	// 828AAA0C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAA10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AAA14: 808B1518  lwz r4, 0x1518(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5400 as u32) ) } as u64;
	// 828AAA18: 48548FF1  bl 0x82df3a08
	ctx.lr = 0x828AAA1C;
	sub_82DF3A08(ctx, base);
	// 828AAA1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAA20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA24: 4BFFD6AD  bl 0x828a80d0
	ctx.lr = 0x828AAA28;
	sub_828A80D0(ctx, base);
	// 828AAA28: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAA2C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 828AAA30: 808B151C  lwz r4, 0x151c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5404 as u32) ) } as u64;
	// 828AAA34: 48548FD5  bl 0x82df3a08
	ctx.lr = 0x828AAA38;
	sub_82DF3A08(ctx, base);
	// 828AAA38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAA3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA40: 4BFFD6F1  bl 0x828a8130
	ctx.lr = 0x828AAA44;
	sub_828A8130(ctx, base);
	// 828AAA44: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAA48: 3861022C  addi r3, r1, 0x22c
	ctx.r[3].s64 = ctx.r[1].s64 + 556;
	// 828AAA4C: 808B1520  lwz r4, 0x1520(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5408 as u32) ) } as u64;
	// 828AAA50: 48548FB9  bl 0x82df3a08
	ctx.lr = 0x828AAA54;
	sub_82DF3A08(ctx, base);
	// 828AAA54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAA58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA5C: 4BFFD735  bl 0x828a8190
	ctx.lr = 0x828AAA60;
	sub_828A8190(ctx, base);
	// 828AAA60: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAA64: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 828AAA68: 808B1524  lwz r4, 0x1524(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5412 as u32) ) } as u64;
	// 828AAA6C: 48548F9D  bl 0x82df3a08
	ctx.lr = 0x828AAA70;
	sub_82DF3A08(ctx, base);
	// 828AAA70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAA74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA78: 4BFFD779  bl 0x828a81f0
	ctx.lr = 0x828AAA7C;
	sub_828A81F0(ctx, base);
	// 828AAA7C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAA80: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 828AAA84: 808B1528  lwz r4, 0x1528(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5416 as u32) ) } as u64;
	// 828AAA88: 48548F81  bl 0x82df3a08
	ctx.lr = 0x828AAA8C;
	sub_82DF3A08(ctx, base);
	// 828AAA8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAA90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAA94: 4BFFD7BD  bl 0x828a8250
	ctx.lr = 0x828AAA98;
	sub_828A8250(ctx, base);
	// 828AAA98: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAA9C: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 828AAAA0: 808B152C  lwz r4, 0x152c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5420 as u32) ) } as u64;
	// 828AAAA4: 48548F65  bl 0x82df3a08
	ctx.lr = 0x828AAAA8;
	sub_82DF3A08(ctx, base);
	// 828AAAA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAAAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAAB0: 4BFFD801  bl 0x828a82b0
	ctx.lr = 0x828AAAB4;
	sub_828A82B0(ctx, base);
	// 828AAAB4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAAB8: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 828AAABC: 808B1530  lwz r4, 0x1530(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5424 as u32) ) } as u64;
	// 828AAAC0: 48548F49  bl 0x82df3a08
	ctx.lr = 0x828AAAC4;
	sub_82DF3A08(ctx, base);
	// 828AAAC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAAC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAACC: 4BFFD845  bl 0x828a8310
	ctx.lr = 0x828AAAD0;
	sub_828A8310(ctx, base);
	// 828AAAD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAAD4: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 828AAAD8: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828AAADC: 48548F2D  bl 0x82df3a08
	ctx.lr = 0x828AAAE0;
	sub_82DF3A08(ctx, base);
	// 828AAAE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAAE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAAE8: 4BFFD889  bl 0x828a8370
	ctx.lr = 0x828AAAEC;
	sub_828A8370(ctx, base);
	// 828AAAEC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAAF0: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 828AAAF4: 808B1514  lwz r4, 0x1514(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5396 as u32) ) } as u64;
	// 828AAAF8: 48548F11  bl 0x82df3a08
	ctx.lr = 0x828AAAFC;
	sub_82DF3A08(ctx, base);
	// 828AAAFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAB00: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAB04: 4BFFD8CD  bl 0x828a83d0
	ctx.lr = 0x828AAB08;
	sub_828A83D0(ctx, base);
	// 828AAB08: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AAB0C: 38610224  addi r3, r1, 0x224
	ctx.r[3].s64 = ctx.r[1].s64 + 548;
	// 828AAB10: 808B153C  lwz r4, 0x153c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5436 as u32) ) } as u64;
	// 828AAB14: 48548EF5  bl 0x82df3a08
	ctx.lr = 0x828AAB18;
	sub_82DF3A08(ctx, base);
	// 828AAB18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAB1C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAB20: 4BFFD911  bl 0x828a8430
	ctx.lr = 0x828AAB24;
	sub_828A8430(ctx, base);
	// 828AAB24: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAB28: 386101D4  addi r3, r1, 0x1d4
	ctx.r[3].s64 = ctx.r[1].s64 + 468;
	// 828AAB2C: 808B0B34  lwz r4, 0xb34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828AAB30: 48548ED9  bl 0x82df3a08
	ctx.lr = 0x828AAB34;
	sub_82DF3A08(ctx, base);
	// 828AAB34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAB38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAB3C: 4BFFD955  bl 0x828a8490
	ctx.lr = 0x828AAB40;
	sub_828A8490(ctx, base);
	// 828AAB40: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAB44: 38610234  addi r3, r1, 0x234
	ctx.r[3].s64 = ctx.r[1].s64 + 564;
	// 828AAB48: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828AAB4C: 48548EBD  bl 0x82df3a08
	ctx.lr = 0x828AAB50;
	sub_82DF3A08(ctx, base);
	// 828AAB50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAB54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAB58: 4BFFD999  bl 0x828a84f0
	ctx.lr = 0x828AAB5C;
	sub_828A84F0(ctx, base);
	// 828AAB5C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAB60: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 828AAB64: 808B0B28  lwz r4, 0xb28(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2856 as u32) ) } as u64;
	// 828AAB68: 48548EA1  bl 0x82df3a08
	ctx.lr = 0x828AAB6C;
	sub_82DF3A08(ctx, base);
	// 828AAB6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAB70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAB74: 4BFFD97D  bl 0x828a84f0
	ctx.lr = 0x828AAB78;
	sub_828A84F0(ctx, base);
	// 828AAB78: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAB7C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAB80: 808B0B58  lwz r4, 0xb58(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2904 as u32) ) } as u64;
	// 828AAB84: 48548E85  bl 0x82df3a08
	ctx.lr = 0x828AAB88;
	sub_82DF3A08(ctx, base);
	// 828AAB88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAB8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAB90: 4BFFD9C1  bl 0x828a8550
	ctx.lr = 0x828AAB94;
	sub_828A8550(ctx, base);
	// 828AAB94: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAB98: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828AAB9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AABA0: 388B55E8  addi r4, r11, 0x55e8
	ctx.r[4].s64 = ctx.r[11].s64 + 21992;
	// 828AABA4: 4BFBE505  bl 0x828690a8
	ctx.lr = 0x828AABA8;
	sub_828690A8(ctx, base);
	// 828AABA8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AABAC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AABB0: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AABB4: 808B0B5C  lwz r4, 0xb5c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2908 as u32) ) } as u64;
	// 828AABB8: 48548E51  bl 0x82df3a08
	ctx.lr = 0x828AABBC;
	sub_82DF3A08(ctx, base);
	// 828AABBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AABC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AABC4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AABC8: 485B1591  bl 0x82e5c158
	ctx.lr = 0x828AABCC;
	sub_82E5C158(ctx, base);
	// 828AABCC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AABD0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828AABD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AABD8: 388B4700  addi r4, r11, 0x4700
	ctx.r[4].s64 = ctx.r[11].s64 + 18176;
	// 828AABDC: 4BFBE4CD  bl 0x828690a8
	ctx.lr = 0x828AABE0;
	sub_828690A8(ctx, base);
	// 828AABE0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AABE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AABE8: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AABEC: 808B0B68  lwz r4, 0xb68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2920 as u32) ) } as u64;
	// 828AABF0: 48548E19  bl 0x82df3a08
	ctx.lr = 0x828AABF4;
	sub_82DF3A08(ctx, base);
	// 828AABF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AABF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AABFC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AAC00: 485B1559  bl 0x82e5c158
	ctx.lr = 0x828AAC04;
	sub_82E5C158(ctx, base);
	// 828AAC04: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAC08: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828AAC0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAC10: 388B9EF8  addi r4, r11, -0x6108
	ctx.r[4].s64 = ctx.r[11].s64 + -24840;
	// 828AAC14: 4BFBE495  bl 0x828690a8
	ctx.lr = 0x828AAC18;
	sub_828690A8(ctx, base);
	// 828AAC18: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAC1C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAC20: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AAC24: 808B0B64  lwz r4, 0xb64(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2916 as u32) ) } as u64;
	// 828AAC28: 48548DE1  bl 0x82df3a08
	ctx.lr = 0x828AAC2C;
	sub_82DF3A08(ctx, base);
	// 828AAC2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAC30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAC34: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AAC38: 485B1521  bl 0x82e5c158
	ctx.lr = 0x828AAC3C;
	sub_82E5C158(ctx, base);
	// 828AAC3C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAC40: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828AAC44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAC48: 388B8D88  addi r4, r11, -0x7278
	ctx.r[4].s64 = ctx.r[11].s64 + -29304;
	// 828AAC4C: 4BFBE45D  bl 0x828690a8
	ctx.lr = 0x828AAC50;
	sub_828690A8(ctx, base);
	// 828AAC50: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAC54: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAC58: 808B0B6C  lwz r4, 0xb6c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2924 as u32) ) } as u64;
	// 828AAC5C: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AAC60: 48548DA9  bl 0x82df3a08
	ctx.lr = 0x828AAC64;
	sub_82DF3A08(ctx, base);
	// 828AAC64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAC68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAC6C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AAC70: 485B14E9  bl 0x82e5c158
	ctx.lr = 0x828AAC74;
	sub_82E5C158(ctx, base);
	// 828AAC74: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAC78: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828AAC7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAC80: 388B8420  addi r4, r11, -0x7be0
	ctx.r[4].s64 = ctx.r[11].s64 + -31712;
	// 828AAC84: 4BFBE425  bl 0x828690a8
	ctx.lr = 0x828AAC88;
	sub_828690A8(ctx, base);
	// 828AAC88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAC8C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAC90: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AAC94: 808B0BA8  lwz r4, 0xba8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2984 as u32) ) } as u64;
	// 828AAC98: 48548D71  bl 0x82df3a08
	ctx.lr = 0x828AAC9C;
	sub_82DF3A08(ctx, base);
	// 828AAC9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AACA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AACA4: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AACA8: 485B14B1  bl 0x82e5c158
	ctx.lr = 0x828AACAC;
	sub_82E5C158(ctx, base);
	// 828AACAC: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AACB0: 3D608293  lis r11, -0x7d6d
	ctx.r[11].s64 = -2104295424;
	// 828AACB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AACB8: 388B8648  addi r4, r11, -0x79b8
	ctx.r[4].s64 = ctx.r[11].s64 + -31160;
	// 828AACBC: 4BFBE3ED  bl 0x828690a8
	ctx.lr = 0x828AACC0;
	sub_828690A8(ctx, base);
	// 828AACC0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AACC4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AACC8: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AACCC: 808B0BA4  lwz r4, 0xba4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2980 as u32) ) } as u64;
	// 828AACD0: 48548D39  bl 0x82df3a08
	ctx.lr = 0x828AACD4;
	sub_82DF3A08(ctx, base);
	// 828AACD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AACD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AACDC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AACE0: 485B1479  bl 0x82e5c158
	ctx.lr = 0x828AACE4;
	sub_82E5C158(ctx, base);
	// 828AACE4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AACE8: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828AACEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AACF0: 388B5EB8  addi r4, r11, 0x5eb8
	ctx.r[4].s64 = ctx.r[11].s64 + 24248;
	// 828AACF4: 4BFBE3B5  bl 0x828690a8
	ctx.lr = 0x828AACF8;
	sub_828690A8(ctx, base);
	// 828AACF8: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AACFC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAD00: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AAD04: 808B0BC4  lwz r4, 0xbc4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3012 as u32) ) } as u64;
	// 828AAD08: 48548D01  bl 0x82df3a08
	ctx.lr = 0x828AAD0C;
	sub_82DF3A08(ctx, base);
	// 828AAD0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAD10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAD14: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AAD18: 485B1441  bl 0x82e5c158
	ctx.lr = 0x828AAD1C;
	sub_82E5C158(ctx, base);
	// 828AAD1C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAD20: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828AAD24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAD28: 388B74E8  addi r4, r11, 0x74e8
	ctx.r[4].s64 = ctx.r[11].s64 + 29928;
	// 828AAD2C: 4BFBE37D  bl 0x828690a8
	ctx.lr = 0x828AAD30;
	sub_828690A8(ctx, base);
	// 828AAD30: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAD34: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAD38: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AAD3C: 808B0BC8  lwz r4, 0xbc8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3016 as u32) ) } as u64;
	// 828AAD40: 48548CC9  bl 0x82df3a08
	ctx.lr = 0x828AAD44;
	sub_82DF3A08(ctx, base);
	// 828AAD44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAD48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAD4C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AAD50: 485B1409  bl 0x82e5c158
	ctx.lr = 0x828AAD54;
	sub_82E5C158(ctx, base);
	// 828AAD54: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAD58: 3D608292  lis r11, -0x7d6e
	ctx.r[11].s64 = -2104360960;
	// 828AAD5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAD60: 388B7238  addi r4, r11, 0x7238
	ctx.r[4].s64 = ctx.r[11].s64 + 29240;
	// 828AAD64: 4BFBE345  bl 0x828690a8
	ctx.lr = 0x828AAD68;
	sub_828690A8(ctx, base);
	// 828AAD68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAD6C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAD70: 3B010060  addi r24, r1, 0x60
	ctx.r[24].s64 = ctx.r[1].s64 + 96;
	// 828AAD74: 808B0BCC  lwz r4, 0xbcc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3020 as u32) ) } as u64;
	// 828AAD78: 48548C91  bl 0x82df3a08
	ctx.lr = 0x828AAD7C;
	sub_82DF3A08(ctx, base);
	// 828AAD7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAD80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAD84: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 828AAD88: 485B13D1  bl 0x82e5c158
	ctx.lr = 0x828AAD8C;
	sub_82E5C158(ctx, base);
	// 828AAD8C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AAD90: 809B0AF0  lwz r4, 0xaf0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(2800 as u32) ) } as u64;
	// 828AAD94: 48548C75  bl 0x82df3a08
	ctx.lr = 0x828AAD98;
	sub_82DF3A08(ctx, base);
	// 828AAD98: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AAD9C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AADA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AADA4: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 828AADA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AADAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AADB0: 485B3BB1  bl 0x82e5e960
	ctx.lr = 0x828AADB4;
	sub_82E5E960(ctx, base);
	// 828AADB4: 806101EC  lwz r3, 0x1ec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 828AADB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AADBC: 419A0008  beq cr6, 0x828aadc4
	if ctx.cr[6].eq {
	pc = 0x828AADC4; continue 'dispatch;
	}
	// 828AADC0: 4BA15AD1  bl 0x822c0890
	ctx.lr = 0x828AADC4;
	sub_822C0890(ctx, base);
	// 828AADC4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AADC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AADCC: 38A001CE  li r5, 0x1ce
	ctx.r[5].s64 = 462;
	// 828AADD0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 828AADD4: 4BA15605  bl 0x822c03d8
	ctx.lr = 0x828AADD8;
	sub_822C03D8(ctx, base);
	// 828AADD8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 828AADDC: 41820028  beq 0x828aae04
	if ctx.cr[0].eq {
	pc = 0x828AAE04; continue 'dispatch;
	}
	// 828AADE0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AADE4: 4BF4137D  bl 0x827ec160
	ctx.lr = 0x828AADE8;
	sub_827EC160(ctx, base);
	// 828AADE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AADEC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AADF0: 8081036C  lwz r4, 0x36c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(876 as u32) ) } as u64;
	// 828AADF4: 38AB99A4  addi r5, r11, -0x665c
	ctx.r[5].s64 = ctx.r[11].s64 + -26204;
	// 828AADF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AADFC: 480779C5  bl 0x829227c0
	ctx.lr = 0x828AAE00;
	sub_829227C0(ctx, base);
	// 828AAE00: 48000008  b 0x828aae08
	pc = 0x828AAE08; continue 'dispatch;
	// 828AAE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AAE08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAE0C: 38750370  addi r3, r21, 0x370
	ctx.r[3].s64 = ctx.r[21].s64 + 880;
	// 828AAE10: 4BFBE1A9  bl 0x82868fb8
	ctx.lr = 0x828AAE14;
	sub_82868FB8(ctx, base);
	// 828AAE14: 81750164  lwz r11, 0x164(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(356 as u32) ) } as u64;
	// 828AAE18: 3B950164  addi r28, r21, 0x164
	ctx.r[28].s64 = ctx.r[21].s64 + 356;
	// 828AAE1C: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAE20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAE24: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AAE28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AAE2C: 4E800421  bctrl
	ctx.lr = 0x828AAE30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AAE30: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAE34: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828AAE38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAE3C: 388BE1E0  addi r4, r11, -0x1e20
	ctx.r[4].s64 = ctx.r[11].s64 + -7712;
	// 828AAE40: 4BFBE269  bl 0x828690a8
	ctx.lr = 0x828AAE44;
	sub_828690A8(ctx, base);
	// 828AAE44: 3F60832D  lis r27, -0x7cd3
	ctx.r[27].s64 = -2094202880;
	// 828AAE48: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AAE4C: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828AAE50: 809B0BD8  lwz r4, 0xbd8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828AAE54: 48548BB5  bl 0x82df3a08
	ctx.lr = 0x828AAE58;
	sub_82DF3A08(ctx, base);
	// 828AAE58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAE5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAE60: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828AAE64: 485B12F5  bl 0x82e5c158
	ctx.lr = 0x828AAE68;
	sub_82E5C158(ctx, base);
	// 828AAE68: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 828AAE6C: 3D608294  lis r11, -0x7d6c
	ctx.r[11].s64 = -2104229888;
	// 828AAE70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AAE74: 388BE378  addi r4, r11, -0x1c88
	ctx.r[4].s64 = ctx.r[11].s64 + -7304;
	// 828AAE78: 4BFBE231  bl 0x828690a8
	ctx.lr = 0x828AAE7C;
	sub_828690A8(ctx, base);
	// 828AAE7C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AAE80: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AAE84: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 828AAE88: 808B0BF4  lwz r4, 0xbf4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3060 as u32) ) } as u64;
	// 828AAE8C: 48548B7D  bl 0x82df3a08
	ctx.lr = 0x828AAE90;
	sub_82DF3A08(ctx, base);
	// 828AAE90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AAE94: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AAE98: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828AAE9C: 485B12BD  bl 0x82e5c158
	ctx.lr = 0x828AAEA0;
	sub_82E5C158(ctx, base);
	// 828AAEA0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AAEA4: 809B0BD8  lwz r4, 0xbd8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(3032 as u32) ) } as u64;
	// 828AAEA8: 48548B61  bl 0x82df3a08
	ctx.lr = 0x828AAEAC;
	sub_82DF3A08(ctx, base);
	// 828AAEAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AAEB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AAEB4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AAEB8: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 828AAEBC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AAEC0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AAEC4: 485B3A9D  bl 0x82e5e960
	ctx.lr = 0x828AAEC8;
	sub_82E5E960(ctx, base);
	// 828AAEC8: 806101FC  lwz r3, 0x1fc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(508 as u32) ) } as u64;
	// 828AAECC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAED0: 419A0008  beq cr6, 0x828aaed8
	if ctx.cr[6].eq {
	pc = 0x828AAED8; continue 'dispatch;
	}
	// 828AAED4: 4BA159BD  bl 0x822c0890
	ctx.lr = 0x828AAED8;
	sub_822C0890(ctx, base);
	// 828AAED8: 83610364  lwz r27, 0x364(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(868 as u32) ) } as u64;
	// 828AAEDC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AAEE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AAEE4: 4806311D  bl 0x8290e000
	ctx.lr = 0x828AAEE8;
	sub_8290E000(ctx, base);
	// 828AAEE8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AAEEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AAEF0: 38A001DD  li r5, 0x1dd
	ctx.r[5].s64 = 477;
	// 828AAEF4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828AAEF8: 4BA154E1  bl 0x822c03d8
	ctx.lr = 0x828AAEFC;
	sub_822C03D8(ctx, base);
	// 828AAEFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AAF00: 41820020  beq 0x828aaf20
	if ctx.cr[0].eq {
	pc = 0x828AAF20; continue 'dispatch;
	}
	// 828AAF04: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AAF08: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828AAF0C: 409A0008  bne cr6, 0x828aaf14
	if !ctx.cr[6].eq {
	pc = 0x828AAF14; continue 'dispatch;
	}
	// 828AAF10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AAF14: 48098C85  bl 0x82943b98
	ctx.lr = 0x828AAF18;
	sub_82943B98(ctx, base);
	// 828AAF18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AAF1C: 48000008  b 0x828aaf24
	pc = 0x828AAF24; continue 'dispatch;
	// 828AAF20: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828AAF24: 938100D8  stw r28, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 828AAF28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AAF2C: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 828AAF30: 4BFBBA59  bl 0x82866988
	ctx.lr = 0x828AAF34;
	sub_82866988(ctx, base);
	// 828AAF34: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AAF38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AAF3C: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 828AAF40: 4BA150C1  bl 0x822c0000
	ctx.lr = 0x828AAF44;
	sub_822C0000(ctx, base);
	// 828AAF44: 388100D8  addi r4, r1, 0xd8
	ctx.r[4].s64 = ctx.r[1].s64 + 216;
	// 828AAF48: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 828AAF4C: 4BFBD485  bl 0x828683d0
	ctx.lr = 0x828AAF50;
	sub_828683D0(ctx, base);
	// 828AAF50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AAF54: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AAF58: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AAF5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AAF60: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 828AAF64: 419A0024  beq cr6, 0x828aaf88
	if ctx.cr[6].eq {
	pc = 0x828AAF88; continue 'dispatch;
	}
	// 828AAF68: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AAF6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AAF70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AAF74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AAF78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AAF7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AAF80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AAF84: 4082FFE8  bne 0x828aaf6c
	if !ctx.cr[0].eq {
	pc = 0x828AAF6C; continue 'dispatch;
	}
	// 828AAF88: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 828AAF8C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AAF90: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AAF94: 48060555  bl 0x8290b4e8
	ctx.lr = 0x828AAF98;
	sub_8290B4E8(ctx, base);
	// 828AAF98: 8061020C  lwz r3, 0x20c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(524 as u32) ) } as u64;
	// 828AAF9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAFA0: 419A0008  beq cr6, 0x828aafa8
	if ctx.cr[6].eq {
	pc = 0x828AAFA8; continue 'dispatch;
	}
	// 828AAFA4: 4BA158ED  bl 0x822c0890
	ctx.lr = 0x828AAFA8;
	sub_822C0890(ctx, base);
	// 828AAFA8: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 828AAFAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AAFB0: 419A0008  beq cr6, 0x828aafb8
	if ctx.cr[6].eq {
	pc = 0x828AAFB8; continue 'dispatch;
	}
	// 828AAFB4: 4BA158DD  bl 0x822c0890
	ctx.lr = 0x828AAFB8;
	sub_822C0890(ctx, base);
	// 828AAFB8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AAFBC: C02F0320  lfs f1, 0x320(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(800 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AAFC0: 48063491  bl 0x8290e450
	ctx.lr = 0x828AAFC4;
	sub_8290E450(ctx, base);
	// 828AAFC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AAFC8: 3F808201  lis r28, -0x7dff
	ctx.r[28].s64 = -2113863680;
	// 828AAFCC: C08F0010  lfs f4, 0x10(r15)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(16 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828AAFD0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AAFD4: C06F000C  lfs f3, 0xc(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828AAFD8: C04F0008  lfs f2, 8(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828AAFDC: C02B08A8  lfs f1, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AAFE0: C0BCA2EC  lfs f5, -0x5d14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828AAFE4: 480652C5  bl 0x829102a8
	ctx.lr = 0x828AAFE8;
	sub_829102A8(ctx, base);
	// 828AAFE8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AAFEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AAFF0: 38A001E9  li r5, 0x1e9
	ctx.r[5].s64 = 489;
	// 828AAFF4: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 828AAFF8: 4BA153E1  bl 0x822c03d8
	ctx.lr = 0x828AAFFC;
	sub_822C03D8(ctx, base);
	// 828AAFFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AB000: 41820030  beq 0x828ab030
	if ctx.cr[0].eq {
	pc = 0x828AB030; continue 'dispatch;
	}
	// 828AB004: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AB008: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828AB00C: 409A0008  bne cr6, 0x828ab014
	if !ctx.cr[6].eq {
	pc = 0x828AB014; continue 'dispatch;
	}
	// 828AB010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AB014: C0BCA2EC  lfs f5, -0x5d14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 828AB018: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AB01C: C08F0010  lfs f4, 0x10(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(16 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828AB020: C06F000C  lfs f3, 0xc(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828AB024: C04F0008  lfs f2, 8(r15)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828AB028: 48070B09  bl 0x8291bb30
	ctx.lr = 0x828AB02C;
	sub_8291BB30(ctx, base);
	// 828AB02C: 48000008  b 0x828ab034
	pc = 0x828AB034; continue 'dispatch;
	// 828AB030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AB034: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB038: 38750394  addi r3, r21, 0x394
	ctx.r[3].s64 = ctx.r[21].s64 + 916;
	// 828AB03C: 4BFFC7FD  bl 0x828a7838
	ctx.lr = 0x828AB040;
	sub_828A7838(ctx, base);
	// 828AB040: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB044: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB048: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB04C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB050: 4E800421  bctrl
	ctx.lr = 0x828AB054;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB054: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828AB058: 41820150  beq 0x828ab1a8
	if ctx.cr[0].eq {
	pc = 0x828AB1A8; continue 'dispatch;
	}
	// 828AB05C: 3D60828A  lis r11, -0x7d76
	ctx.r[11].s64 = -2104885248;
	// 828AB060: 93A100A8  stw r29, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[29].u32 ) };
	// 828AB064: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 828AB068: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 828AB06C: 396B50C0  addi r11, r11, 0x50c0
	ctx.r[11].s64 = ctx.r[11].s64 + 20672;
	// 828AB070: 93E10240  stw r31, 0x240(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(576 as u32), ctx.r[31].u32 ) };
	// 828AB074: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828AB078: E8A100A8  ld r5, 0xa8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 828AB07C: E8810080  ld r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 828AB080: 4BFFD6B1  bl 0x828a8730
	ctx.lr = 0x828AB084;
	sub_828A8730(ctx, base);
	// 828AB084: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AB088: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AB08C: 388B9E4C  addi r4, r11, -0x61b4
	ctx.r[4].s64 = ctx.r[11].s64 + -25012;
	// 828AB090: 48548979  bl 0x82df3a08
	ctx.lr = 0x828AB094;
	sub_82DF3A08(ctx, base);
	// 828AB094: 38810240  addi r4, r1, 0x240
	ctx.r[4].s64 = ctx.r[1].s64 + 576;
	// 828AB098: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AB09C: 4BCE0E75  bl 0x8258bf10
	ctx.lr = 0x828AB0A0;
	sub_8258BF10(ctx, base);
	// 828AB0A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AB0A4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 828AB0A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AB0AC: 4830733D  bl 0x82bb23e8
	ctx.lr = 0x828AB0B0;
	sub_82BB23E8(ctx, base);
	// 828AB0B0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AB0B4: 48548375  bl 0x82df3428
	ctx.lr = 0x828AB0B8;
	sub_82DF3428(ctx, base);
	// 828AB0B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AB0BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB0C0: 3B8B9FE8  addi r28, r11, -0x6018
	ctx.r[28].s64 = ctx.r[11].s64 + -24600;
	// 828AB0C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AB0C8: 48548941  bl 0x82df3a08
	ctx.lr = 0x828AB0CC;
	sub_82DF3A08(ctx, base);
	// 828AB0CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AB0D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AB0D4: 48302B8D  bl 0x82badc60
	ctx.lr = 0x828AB0D8;
	sub_82BADC60(ctx, base);
	// 828AB0D8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AB0DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB0E0: 48548349  bl 0x82df3428
	ctx.lr = 0x828AB0E4;
	sub_82DF3428(ctx, base);
	// 828AB0E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AB0E8: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 828AB0EC: 4854891D  bl 0x82df3a08
	ctx.lr = 0x828AB0F0;
	sub_82DF3A08(ctx, base);
	// 828AB0F0: 388100C4  addi r4, r1, 0xc4
	ctx.r[4].s64 = ctx.r[1].s64 + 196;
	// 828AB0F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AB0F8: 48302B69  bl 0x82badc60
	ctx.lr = 0x828AB0FC;
	sub_82BADC60(ctx, base);
	// 828AB0FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AB100: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 828AB104: 48548325  bl 0x82df3428
	ctx.lr = 0x828AB108;
	sub_82DF3428(ctx, base);
	// 828AB108: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AB10C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AB110: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828AB114: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 828AB118: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 828AB11C: C00B94B0  lfs f0, -0x6b50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27472 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AB120: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828AB124: C1AA9534  lfs f13, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AB128: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB12C: D0010100  stfs f0, 0x100(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 828AB130: D0010104  stfs f0, 0x104(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 828AB134: D1A10108  stfs f13, 0x108(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 828AB138: D001010C  stfs f0, 0x10c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 828AB13C: C029D8B0  lfs f1, -0x2750(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10064 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AB140: 480D2239  bl 0x8297d378
	ctx.lr = 0x828AB144;
	sub_8297D378(ctx, base);
	// 828AB144: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AB148: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AB14C: 38A001F8  li r5, 0x1f8
	ctx.r[5].s64 = 504;
	// 828AB150: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 828AB154: 4BA15285  bl 0x822c03d8
	ctx.lr = 0x828AB158;
	sub_822C03D8(ctx, base);
	// 828AB158: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AB15C: 41820018  beq 0x828ab174
	if ctx.cr[0].eq {
	pc = 0x828AB174; continue 'dispatch;
	}
	// 828AB160: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828AB164: FC20C890  fmr f1, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[25].f64;
	// 828AB168: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AB16C: 480D223D  bl 0x8297d3a8
	ctx.lr = 0x828AB170;
	sub_8297D3A8(ctx, base);
	// 828AB170: 48000008  b 0x828ab178
	pc = 0x828AB178; continue 'dispatch;
	// 828AB174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AB178: 81750388  lwz r11, 0x388(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(904 as u32) ) } as u64;
	// 828AB17C: 90750388  stw r3, 0x388(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(904 as u32), ctx.r[3].u32 ) };
	// 828AB180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB184: 419A001C  beq cr6, 0x828ab1a0
	if ctx.cr[6].eq {
	pc = 0x828AB1A0; continue 'dispatch;
	}
	// 828AB188: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB18C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 828AB190: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AB194: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB19C: 4E800421  bctrl
	ctx.lr = 0x828AB1A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB1A0: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 828AB1A4: 4BA1DB15  bl 0x822c8cb8
	ctx.lr = 0x828AB1A8;
	sub_822C8CB8(ctx, base);
	// 828AB1A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AB1AC: 48093DBD  bl 0x8293ef68
	ctx.lr = 0x828AB1B0;
	sub_8293EF68(ctx, base);
	// 828AB1B0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828AB1B4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AB1B8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AB1BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AB1C0: 38A00201  li r5, 0x201
	ctx.r[5].s64 = 513;
	// 828AB1C4: C38B7BC4  lfs f28, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828AB1C8: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 828AB1CC: C00A9C28  lfs f0, -0x63d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AB1D0: D3810060  stfs f28, 0x60(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828AB1D4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828AB1D8: 4BA15201  bl 0x822c03d8
	ctx.lr = 0x828AB1DC;
	sub_822C03D8(ctx, base);
	// 828AB1DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AB1E0: 41820020  beq 0x828ab200
	if ctx.cr[0].eq {
	pc = 0x828AB200; continue 'dispatch;
	}
	// 828AB1E4: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 828AB1E8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828AB1EC: 409A0008  bne cr6, 0x828ab1f4
	if !ctx.cr[6].eq {
	pc = 0x828AB1F4; continue 'dispatch;
	}
	// 828AB1F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AB1F4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828AB1F8: 48094ED9  bl 0x829400d0
	ctx.lr = 0x828AB1FC;
	sub_829400D0(ctx, base);
	// 828AB1FC: 48000008  b 0x828ab204
	pc = 0x828AB204; continue 'dispatch;
	// 828AB200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AB204: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB208: 3875038C  addi r3, r21, 0x38c
	ctx.r[3].s64 = ctx.r[21].s64 + 908;
	// 828AB20C: 4BFBD23D  bl 0x82868448
	ctx.lr = 0x828AB210;
	sub_82868448(ctx, base);
	// 828AB210: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AB214: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AB218: 38A00206  li r5, 0x206
	ctx.r[5].s64 = 518;
	// 828AB21C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 828AB220: 4BA151B9  bl 0x822c03d8
	ctx.lr = 0x828AB224;
	sub_822C03D8(ctx, base);
	// 828AB224: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AB228: 41820010  beq 0x828ab238
	if ctx.cr[0].eq {
	pc = 0x828AB238; continue 'dispatch;
	}
	// 828AB22C: 8081035C  lwz r4, 0x35c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(860 as u32) ) } as u64;
	// 828AB230: 4BBE5EC1  bl 0x824910f0
	ctx.lr = 0x828AB234;
	sub_824910F0(ctx, base);
	// 828AB234: 48000008  b 0x828ab23c
	pc = 0x828AB23C; continue 'dispatch;
	// 828AB238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AB23C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB240: 3875039C  addi r3, r21, 0x39c
	ctx.r[3].s64 = ctx.r[21].s64 + 924;
	// 828AB244: 4BA5F49D  bl 0x8230a6e0
	ctx.lr = 0x828AB248;
	sub_8230A6E0(ctx, base);
	// 828AB248: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AB24C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828AB250: 388B9FE0  addi r4, r11, -0x6020
	ctx.r[4].s64 = ctx.r[11].s64 + -24608;
	// 828AB254: 485487B5  bl 0x82df3a08
	ctx.lr = 0x828AB258;
	sub_82DF3A08(ctx, base);
	// 828AB258: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AB25C: 38610114  addi r3, r1, 0x114
	ctx.r[3].s64 = ctx.r[1].s64 + 276;
	// 828AB260: 3BCB1360  addi r30, r11, 0x1360
	ctx.r[30].s64 = ctx.r[11].s64 + 4960;
	// 828AB264: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB268: 485487A1  bl 0x82df3a08
	ctx.lr = 0x828AB26C;
	sub_82DF3A08(ctx, base);
	// 828AB26C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AB270: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AB274: D3C10120  stfs f30, 0x120(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 828AB278: 3BE00007  li r31, 7
	ctx.r[31].s64 = 7;
	// 828AB27C: D3C10128  stfs f30, 0x128(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 828AB280: D341012C  stfs f26, 0x12c(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 828AB284: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB288: D3C10130  stfs f30, 0x130(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 828AB28C: 93E10118  stw r31, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[31].u32 ) };
	// 828AB290: C32BA100  lfs f25, -0x5f00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24320 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 828AB294: 38899FD4  addi r4, r9, -0x602c
	ctx.r[4].s64 = ctx.r[9].s64 + -24620;
	// 828AB298: C36A6144  lfs f27, 0x6144(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24900 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828AB29C: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 828AB2A0: D321011C  stfs f25, 0x11c(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 828AB2A4: D3610124  stfs f27, 0x124(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 828AB2A8: D3810134  stfs f28, 0x134(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 828AB2AC: D3810138  stfs f28, 0x138(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 828AB2B0: D381013C  stfs f28, 0x13c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 828AB2B4: 48548755  bl 0x82df3a08
	ctx.lr = 0x828AB2B8;
	sub_82DF3A08(ctx, base);
	// 828AB2B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB2BC: 38610144  addi r3, r1, 0x144
	ctx.r[3].s64 = ctx.r[1].s64 + 324;
	// 828AB2C0: 48548749  bl 0x82df3a08
	ctx.lr = 0x828AB2C4;
	sub_82DF3A08(ctx, base);
	// 828AB2C4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828AB2C8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 828AB2CC: D3A10150  stfs f29, 0x150(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 828AB2D0: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828AB2D4: D361014C  stfs f27, 0x14c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 828AB2D8: D3C10158  stfs f30, 0x158(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 828AB2DC: 93E10148  stw r31, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[31].u32 ) };
	// 828AB2E0: D3C1015C  stfs f30, 0x15c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 828AB2E4: 3D008209  lis r8, -0x7df7
	ctx.r[8].s64 = -2113339392;
	// 828AB2E8: C3AB3F00  lfs f29, 0x3f00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16128 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828AB2EC: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 828AB2F0: C00ADAA0  lfs f0, -0x2560(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AB2F4: 38889FC8  addi r4, r8, -0x6038
	ctx.r[4].s64 = ctx.r[8].s64 + -24632;
	// 828AB2F8: C3E99FD0  lfs f31, -0x6030(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24624 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AB2FC: D3A10154  stfs f29, 0x154(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 828AB300: D0010160  stfs f0, 0x160(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 828AB304: D3E10164  stfs f31, 0x164(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 828AB308: D3E10168  stfs f31, 0x168(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), tmp.u32 ) };
	// 828AB30C: D3E1016C  stfs f31, 0x16c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 828AB310: 485486F9  bl 0x82df3a08
	ctx.lr = 0x828AB314;
	sub_82DF3A08(ctx, base);
	// 828AB314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB318: 38610174  addi r3, r1, 0x174
	ctx.r[3].s64 = ctx.r[1].s64 + 372;
	// 828AB31C: 485486ED  bl 0x82df3a08
	ctx.lr = 0x828AB320;
	sub_82DF3A08(ctx, base);
	// 828AB320: D321017C  stfs f25, 0x17c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), tmp.u32 ) };
	// 828AB324: D3C10180  stfs f30, 0x180(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 828AB328: 93E10178  stw r31, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[31].u32 ) };
	// 828AB32C: D3610184  stfs f27, 0x184(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 828AB330: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AB334: D3C10188  stfs f30, 0x188(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 828AB338: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 828AB33C: D341018C  stfs f26, 0x18c(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 828AB340: 388B9FBC  addi r4, r11, -0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + -24644;
	// 828AB344: D3C10190  stfs f30, 0x190(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 828AB348: D3810194  stfs f28, 0x194(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 828AB34C: D3810198  stfs f28, 0x198(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 828AB350: D381019C  stfs f28, 0x19c(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 828AB354: 485486B5  bl 0x82df3a08
	ctx.lr = 0x828AB358;
	sub_82DF3A08(ctx, base);
	// 828AB358: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AB35C: 386101A4  addi r3, r1, 0x1a4
	ctx.r[3].s64 = ctx.r[1].s64 + 420;
	// 828AB360: 485486A9  bl 0x82df3a08
	ctx.lr = 0x828AB364;
	sub_82DF3A08(ctx, base);
	// 828AB364: D36101AC  stfs f27, 0x1ac(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 828AB368: D3A101B4  stfs f29, 0x1b4(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 828AB36C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 828AB370: D3C101B8  stfs f30, 0x1b8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 828AB374: 93E101A8  stw r31, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[31].u32 ) };
	// 828AB378: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828AB37C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AB380: C00B2534  lfs f0, 0x2534(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9524 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AB384: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AB388: C1AA95A0  lfs f13, -0x6a60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AB38C: 3BE10110  addi r31, r1, 0x110
	ctx.r[31].s64 = ctx.r[1].s64 + 272;
	// 828AB390: D3C101BC  stfs f30, 0x1bc(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 828AB394: D3E101C4  stfs f31, 0x1c4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(452 as u32), tmp.u32 ) };
	// 828AB398: D3E101C8  stfs f31, 0x1c8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 828AB39C: D00101B0  stfs f0, 0x1b0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 828AB3A0: D1A101C0  stfs f13, 0x1c0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 828AB3A4: D3E101CC  stfs f31, 0x1cc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 828AB3A8: 4BF41221  bl 0x827ec5c8
	ctx.lr = 0x828AB3AC;
	sub_827EC5C8(ctx, base);
	// 828AB3AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AB3B0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AB3B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AB3B8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 828AB3BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828AB3C0: 4BF41481  bl 0x827ec840
	ctx.lr = 0x828AB3C4;
	sub_827EC840(ctx, base);
	// 828AB3C4: 3BE101D0  addi r31, r1, 0x1d0
	ctx.r[31].s64 = ctx.r[1].s64 + 464;
	// 828AB3C8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 828AB3CC: 3BFFFFD0  addi r31, r31, -0x30
	ctx.r[31].s64 = ctx.r[31].s64 + -48;
	// 828AB3D0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AB3D4: 48548055  bl 0x82df3428
	ctx.lr = 0x828AB3D8;
	sub_82DF3428(ctx, base);
	// 828AB3D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AB3DC: 4854804D  bl 0x82df3428
	ctx.lr = 0x828AB3E0;
	sub_82DF3428(ctx, base);
	// 828AB3E0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828AB3E4: 4080FFE8  bge 0x828ab3cc
	if !ctx.cr[0].lt {
	pc = 0x828AB3CC; continue 'dispatch;
	}
	// 828AB3E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AB3EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 828AB3F0: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 828AB3F4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828AB3F8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AB3FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828AB400: C06B08AC  lfs f3, 0x8ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2220 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828AB404: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AB408: C04ABC10  lfs f2, -0x43f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17392 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828AB40C: C0276218  lfs f1, 0x6218(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AB410: 4805EF11  bl 0x8290a320
	ctx.lr = 0x828AB414;
	sub_8290A320(ctx, base);
	// 828AB414: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AB418: 4BB81159  bl 0x8242c570
	ctx.lr = 0x828AB41C;
	sub_8242C570(ctx, base);
	// 828AB41C: 83C10084  lwz r30, 0x84(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828AB420: 83810080  lwz r28, 0x80(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AB424: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828AB428: 93C100E4  stw r30, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[30].u32 ) };
	// 828AB42C: 938100E0  stw r28, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u32 ) };
	// 828AB430: 419A0024  beq cr6, 0x828ab454
	if ctx.cr[6].eq {
	pc = 0x828AB454; continue 'dispatch;
	}
	// 828AB434: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828AB438: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AB43C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB440: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AB444: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AB448: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB44C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB450: 4082FFE8  bne 0x828ab438
	if !ctx.cr[0].eq {
	pc = 0x828AB438; continue 'dispatch;
	}
	// 828AB454: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828AB458: 80750378  lwz r3, 0x378(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(888 as u32) ) } as u64;
	// 828AB45C: 4BF4CBAD  bl 0x827f8008
	ctx.lr = 0x828AB460;
	sub_827F8008(ctx, base);
	// 828AB460: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 828AB464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB468: 419A0008  beq cr6, 0x828ab470
	if ctx.cr[6].eq {
	pc = 0x828AB470; continue 'dispatch;
	}
	// 828AB46C: 4BA15425  bl 0x822c0890
	ctx.lr = 0x828AB470;
	sub_822C0890(ctx, base);
	// 828AB470: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828AB474: 397C0018  addi r11, r28, 0x18
	ctx.r[11].s64 = ctx.r[28].s64 + 24;
	// 828AB478: 3BF503A4  addi r31, r21, 0x3a4
	ctx.r[31].s64 = ctx.r[21].s64 + 932;
	// 828AB47C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828AB480: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828AB484: 915503A4  stw r10, 0x3a4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(932 as u32), ctx.r[10].u32 ) };
	// 828AB488: 4BA18FD9  bl 0x822c4460
	ctx.lr = 0x828AB48C;
	sub_822C4460(ctx, base);
	// 828AB48C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828AB490: 419A000C  beq cr6, 0x828ab49c
	if ctx.cr[6].eq {
	pc = 0x828AB49C; continue 'dispatch;
	}
	// 828AB494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AB498: 4BA153F9  bl 0x822c0890
	ctx.lr = 0x828AB49C;
	sub_822C0890(ctx, base);
	// 828AB49C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AB4A0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AB4A4: 388B9FA0  addi r4, r11, -0x6060
	ctx.r[4].s64 = ctx.r[11].s64 + -24672;
	// 828AB4A8: 48548561  bl 0x82df3a08
	ctx.lr = 0x828AB4AC;
	sub_82DF3A08(ctx, base);
	// 828AB4AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AB4B0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AB4B4: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 828AB4B8: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 828AB4BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AB4C0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AB4C4: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AB4C8: 4BF40D41  bl 0x827ec208
	ctx.lr = 0x828AB4CC;
	sub_827EC208(ctx, base);
	// 828AB4CC: 907503B0  stw r3, 0x3b0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(944 as u32), ctx.r[3].u32 ) };
	// 828AB4D0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AB4D4: 48547F55  bl 0x82df3428
	ctx.lr = 0x828AB4D8;
	sub_82DF3428(ctx, base);
	// 828AB4D8: 809D03C0  lwz r4, 0x3c0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(960 as u32) ) } as u64;
	// 828AB4DC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828AB4E0: 419A0010  beq cr6, 0x828ab4f0
	if ctx.cr[6].eq {
	pc = 0x828AB4F0; continue 'dispatch;
	}
	// 828AB4E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828AB4E8: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828AB4EC: 4BF40D7D  bl 0x827ec268
	ctx.lr = 0x828AB4F0;
	sub_827EC268(ctx, base);
	// 828AB4F0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 828AB4F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828AB4F8: 4BC5D189  bl 0x82508680
	ctx.lr = 0x828AB4FC;
	sub_82508680(ctx, base);
	// 828AB4FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AB500: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AB504: 388B998C  addi r4, r11, -0x6674
	ctx.r[4].s64 = ctx.r[11].s64 + -26228;
	// 828AB508: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 828AB50C: 4BFFA6B5  bl 0x828a5bc0
	ctx.lr = 0x828AB510;
	sub_828A5BC0(ctx, base);
	// 828AB510: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB514: 916100E8  stw r11, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 828AB518: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB51C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AB520: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 828AB524: 419A0024  beq cr6, 0x828ab548
	if ctx.cr[6].eq {
	pc = 0x828AB548; continue 'dispatch;
	}
	// 828AB528: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AB52C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AB530: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB534: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AB538: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AB53C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AB540: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AB544: 4082FFE8  bne 0x828ab52c
	if !ctx.cr[0].eq {
	pc = 0x828AB52C; continue 'dispatch;
	}
	// 828AB548: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AB54C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 828AB550: 38E100E8  addi r7, r1, 0xe8
	ctx.r[7].s64 = ctx.r[1].s64 + 232;
	// 828AB554: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828AB558: 38A0023A  li r5, 0x23a
	ctx.r[5].s64 = 570;
	// 828AB55C: 38750028  addi r3, r21, 0x28
	ctx.r[3].s64 = ctx.r[21].s64 + 40;
	// 828AB560: 485AD4E1  bl 0x82e58a40
	ctx.lr = 0x828AB564;
	sub_82E58A40(ctx, base);
	// 828AB564: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 828AB568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB56C: 419A0008  beq cr6, 0x828ab574
	if ctx.cr[6].eq {
	pc = 0x828AB574; continue 'dispatch;
	}
	// 828AB570: 4BA15321  bl 0x822c0890
	ctx.lr = 0x828AB574;
	sub_822C0890(ctx, base);
	// 828AB574: 8061021C  lwz r3, 0x21c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(540 as u32) ) } as u64;
	// 828AB578: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB57C: 419A0008  beq cr6, 0x828ab584
	if ctx.cr[6].eq {
	pc = 0x828AB584; continue 'dispatch;
	}
	// 828AB580: 4BA15311  bl 0x822c0890
	ctx.lr = 0x828AB584;
	sub_822C0890(ctx, base);
	// 828AB584: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AB588: 481680F9  bl 0x82a13680
	ctx.lr = 0x828AB58C;
	sub_82A13680(ctx, base);
	// 828AB58C: C0230004  lfs f1, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AB590: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 828AB594: 4805DD25  bl 0x829092b8
	ctx.lr = 0x828AB598;
	sub_829092B8(ctx, base);
	// 828AB598: 38210340  addi r1, r1, 0x340
	ctx.r[1].s64 = ctx.r[1].s64 + 832;
	// 828AB59C: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 828AB5A0: 488FD515  bl 0x831a8ab4
	ctx.lr = 0x828AB5A4;
	sub_831A8A8C(ctx, base);
	// 828AB5A4: 488FCBDC  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB5A8 size=68
    let mut pc: u32 = 0x828AB5A8;
    'dispatch: loop {
        match pc {
            0x828AB5A8 => {
    //   block [0x828AB5A8..0x828AB5EC)
	// 828AB5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB5AC: 488FCBC1  bl 0x831a816c
	ctx.lr = 0x828AB5B0;
	sub_831A8130(ctx, base);
	// 828AB5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB5B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AB5B8: 3BA40010  addi r29, r4, 0x10
	ctx.r[29].s64 = ctx.r[4].s64 + 16;
	// 828AB5BC: 3BE00009  li r31, 9
	ctx.r[31].s64 = 9;
	// 828AB5C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB5C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AB5C8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB5CC: 816B00CC  lwz r11, 0xcc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(204 as u32) ) } as u64;
	// 828AB5D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AB5D4: 4E800421  bctrl
	ctx.lr = 0x828AB5D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AB5D8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 828AB5DC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 828AB5E0: 4082FFE0  bne 0x828ab5c0
	if !ctx.cr[0].eq {
	pc = 0x828AB5C0; continue 'dispatch;
	}
	// 828AB5E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AB5E8: 488FCBD4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AB5F0 size=8
    let mut pc: u32 = 0x828AB5F0;
    'dispatch: loop {
        match pc {
            0x828AB5F0 => {
    //   block [0x828AB5F0..0x828AB5F8)
	// 828AB5F0: 98830027  stb r4, 0x27(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(39 as u32), ctx.r[4].u8 ) };
	// 828AB5F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AB5F8 size=8
    let mut pc: u32 = 0x828AB5F8;
    'dispatch: loop {
        match pc {
            0x828AB5F8 => {
    //   block [0x828AB5F8..0x828AB600)
	// 828AB5F8: 98830026  stb r4, 0x26(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[4].u8 ) };
	// 828AB5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AB600 size=288
    let mut pc: u32 = 0x828AB600;
    'dispatch: loop {
        match pc {
            0x828AB600 => {
    //   block [0x828AB600..0x828AB720)
	// 828AB600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB604: 488FCB61  bl 0x831a8164
	ctx.lr = 0x828AB608;
	sub_831A8130(ctx, base);
	// 828AB608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB60C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AB610: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AB614: 3BEB0B20  addi r31, r11, 0xb20
	ctx.r[31].s64 = ctx.r[11].s64 + 2848;
	// 828AB618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AB61C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828AB620: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828AB624: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828AB628: 4854DF09  bl 0x82df9530
	ctx.lr = 0x828AB62C;
	sub_82DF9530(ctx, base);
	// 828AB62C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AB630: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AB634: 4854DEFD  bl 0x82df9530
	ctx.lr = 0x828AB638;
	sub_82DF9530(ctx, base);
	// 828AB638: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828AB63C: 3BCBEDA8  addi r30, r11, -0x1258
	ctx.r[30].s64 = ctx.r[11].s64 + -4696;
	// 828AB640: 897D0027  lbz r11, 0x27(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(39 as u32) ) } as u64;
	// 828AB644: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AB648: 41820034  beq 0x828ab67c
	if ctx.cr[0].eq {
	pc = 0x828AB67C; continue 'dispatch;
	}
	// 828AB64C: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828AB650: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828AB654: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AB658: 409A0088  bne cr6, 0x828ab6e0
	if !ctx.cr[6].eq {
	pc = 0x828AB6E0; continue 'dispatch;
	}
	// 828AB65C: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828AB660: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB664: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AB668: 419A0068  beq cr6, 0x828ab6d0
	if ctx.cr[6].eq {
	pc = 0x828AB6D0; continue 'dispatch;
	}
	// 828AB66C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AB670: 393E0048  addi r9, r30, 0x48
	ctx.r[9].s64 = ctx.r[30].s64 + 72;
	// 828AB674: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828AB678: 4198FFE8  blt cr6, 0x828ab660
	if ctx.cr[6].lt {
	pc = 0x828AB660; continue 'dispatch;
	}
	// 828AB67C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AB680: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB684: 4854DEAD  bl 0x82df9530
	ctx.lr = 0x828AB688;
	sub_82DF9530(ctx, base);
	// 828AB688: 897D0026  lbz r11, 0x26(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(38 as u32) ) } as u64;
	// 828AB68C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AB690: 41820034  beq 0x828ab6c4
	if ctx.cr[0].eq {
	pc = 0x828AB6C4; continue 'dispatch;
	}
	// 828AB694: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 828AB698: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AB69C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AB6A0: 409A0024  bne cr6, 0x828ab6c4
	if !ctx.cr[6].eq {
	pc = 0x828AB6C4; continue 'dispatch;
	}
	// 828AB6A4: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828AB6A8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB6AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AB6B0: 419A0068  beq cr6, 0x828ab718
	if ctx.cr[6].eq {
	pc = 0x828AB718; continue 'dispatch;
	}
	// 828AB6B4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AB6B8: 393E0048  addi r9, r30, 0x48
	ctx.r[9].s64 = ctx.r[30].s64 + 72;
	// 828AB6BC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828AB6C0: 4198FFE8  blt cr6, 0x828ab6a8
	if ctx.cr[6].lt {
	pc = 0x828AB6A8; continue 'dispatch;
	}
	// 828AB6C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828AB6C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AB6CC: 488FCAE8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
	// 828AB6D0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 828AB6D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828AB6D8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AB6DC: 4BFFFFEC  b 0x828ab6c8
	pc = 0x828AB6C8; continue 'dispatch;
	// 828AB6E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AB6E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828AB6E8: 409AFF94  bne cr6, 0x828ab67c
	if !ctx.cr[6].eq {
	pc = 0x828AB67C; continue 'dispatch;
	}
	// 828AB6EC: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 828AB6F0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB6F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828AB6F8: 419A0018  beq cr6, 0x828ab710
	if ctx.cr[6].eq {
	pc = 0x828AB710; continue 'dispatch;
	}
	// 828AB6FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828AB700: 393E0048  addi r9, r30, 0x48
	ctx.r[9].s64 = ctx.r[30].s64 + 72;
	// 828AB704: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 828AB708: 4198FFE8  blt cr6, 0x828ab6f0
	if ctx.cr[6].lt {
	pc = 0x828AB6F0; continue 'dispatch;
	}
	// 828AB70C: 4BFFFF70  b 0x828ab67c
	pc = 0x828AB67C; continue 'dispatch;
	// 828AB710: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828AB714: 4BFFFFC0  b 0x828ab6d4
	pc = 0x828AB6D4; continue 'dispatch;
	// 828AB718: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 828AB71C: 4BFFFFB8  b 0x828ab6d4
	pc = 0x828AB6D4; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AB720 size=12
    let mut pc: u32 = 0x828AB720;
    'dispatch: loop {
        match pc {
            0x828AB720 => {
    //   block [0x828AB720..0x828AB72C)
	// 828AB720: 8063002C  lwz r3, 0x2c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 828AB724: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AB728: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB72C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AB72C size=8
    let mut pc: u32 = 0x828AB72C;
    'dispatch: loop {
        match pc {
            0x828AB72C => {
    //   block [0x828AB72C..0x828AB734)
	// 828AB72C: 4BA15164  b 0x822c0890
	sub_822C0890(ctx, base);
	return;
	// 828AB730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AB738 size=36
    let mut pc: u32 = 0x828AB738;
    'dispatch: loop {
        match pc {
            0x828AB738 => {
    //   block [0x828AB738..0x828AB75C)
	// 828AB738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AB73C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828AB740: 99630025  stb r11, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 828AB744: 99430024  stb r10, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 828AB748: 99630026  stb r11, 0x26(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 828AB74C: 99630027  stb r11, 0x27(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(39 as u32), ctx.r[11].u8 ) };
	// 828AB750: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 828AB754: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 828AB758: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AB760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AB760 size=1820
    let mut pc: u32 = 0x828AB760;
    'dispatch: loop {
        match pc {
            0x828AB760 => {
    //   block [0x828AB760..0x828ABE7C)
	// 828AB760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AB764: 488FC9D9  bl 0x831a813c
	ctx.lr = 0x828AB768;
	sub_831A8130(ctx, base);
	// 828AB768: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 828AB76C: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AB770: 82CD0000  lwz r22, 0(r13)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AB774: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828AB778: 3AA00014  li r21, 0x14
	ctx.r[21].s64 = 20;
	// 828AB77C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AB780: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 828AB784: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 828AB788: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 828AB78C: 838B6820  lwz r28, 0x6820(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26656 as u32) ) } as u64;
	// 828AB790: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AB794: 7C75B02E  lwzx r3, r21, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 828AB798: 485F4F99  bl 0x82ea0730
	ctx.lr = 0x828AB79C;
	sub_82EA0730(ctx, base);
	// 828AB79C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AB7A0: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828AB7A4: 3A4BBC40  addi r18, r11, -0x43c0
	ctx.r[18].s64 = ctx.r[11].s64 + -17344;
	// 828AB7A8: 396A2B30  addi r11, r10, 0x2b30
	ctx.r[11].s64 = ctx.r[10].s64 + 11056;
	// 828AB7AC: 394100D0  addi r10, r1, 0xd0
	ctx.r[10].s64 = ctx.r[1].s64 + 208;
	// 828AB7B0: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 828AB7B4: 3A200060  li r17, 0x60
	ctx.r[17].s64 = 96;
	// 828AB7B8: 13E090C7  vcmpequd (lvx128) v31, v0, v18
	tmp.u32 = ctx.r[18].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AB7BC: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828AB7C0: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AB7C4: B2230004  sth r17, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[17].u16 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABE80 size=68
    let mut pc: u32 = 0x828ABE80;
    'dispatch: loop {
        match pc {
            0x828ABE80 => {
    //   block [0x828ABE80..0x828ABEC4)
	// 828ABE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABE84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ABE88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ABE8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABE90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ABE94: 4806B045  bl 0x82916ed8
	ctx.lr = 0x828ABE98;
	sub_82916ED8(ctx, base);
	// 828ABE98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ABE9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828ABEA0: 396BA11C  addi r11, r11, -0x5ee4
	ctx.r[11].s64 = ctx.r[11].s64 + -24292;
	// 828ABEA4: 995F00C0  stb r10, 0xc0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u8 ) };
	// 828ABEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ABEAC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ABEB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ABEB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ABEB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ABEBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ABEC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABEC8 size=76
    let mut pc: u32 = 0x828ABEC8;
    'dispatch: loop {
        match pc {
            0x828ABEC8 => {
    //   block [0x828ABEC8..0x828ABF14)
	// 828ABEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ABED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ABED4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABED8: 81640070  lwz r11, 0x70(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(112 as u32) ) } as u64;
	// 828ABEDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ABEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABEE4: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 828ABEE8: 409A0008  bne cr6, 0x828abef0
	if !ctx.cr[6].eq {
	pc = 0x828ABEF0; continue 'dispatch;
	}
	// 828ABEEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ABEF0: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 828ABEF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ABEF8: 4805D761  bl 0x82909658
	ctx.lr = 0x828ABEFC;
	sub_82909658(ctx, base);
	// 828ABEFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ABF00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ABF04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ABF08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ABF0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ABF10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ABF18 size=24
    let mut pc: u32 = 0x828ABF18;
    'dispatch: loop {
        match pc {
            0x828ABF18 => {
    //   block [0x828ABF18..0x828ABF30)
	// 828ABF18: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828ABF1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABF20: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 828ABF24: 409A0008  bne cr6, 0x828abf2c
	if !ctx.cr[6].eq {
	pc = 0x828ABF2C; continue 'dispatch;
	}
	// 828ABF28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828ABF2C: 4BFF71DC  b 0x828a3108
	sub_828A3108(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ABF30 size=8
    let mut pc: u32 = 0x828ABF30;
    'dispatch: loop {
        match pc {
            0x828ABF30 => {
    //   block [0x828ABF30..0x828ABF38)
	// 828ABF30: 886300C0  lbz r3, 0xc0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 828ABF34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ABF38 size=12
    let mut pc: u32 = 0x828ABF38;
    'dispatch: loop {
        match pc {
            0x828ABF38 => {
    //   block [0x828ABF38..0x828ABF44)
	// 828ABF38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828ABF3C: 996300C0  stb r11, 0xc0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[11].u8 ) };
	// 828ABF40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABF48 size=88
    let mut pc: u32 = 0x828ABF48;
    'dispatch: loop {
        match pc {
            0x828ABF48 => {
    //   block [0x828ABF48..0x828ABFA0)
	// 828ABF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ABF50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828ABF54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ABF58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABF5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ABF60: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ABF64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828ABF68: 396BA11C  addi r11, r11, -0x5ee4
	ctx.r[11].s64 = ctx.r[11].s64 + -24292;
	// 828ABF6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ABF70: 4806ABF9  bl 0x82916b68
	ctx.lr = 0x828ABF74;
	sub_82916B68(ctx, base);
	// 828ABF74: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828ABF78: 4182000C  beq 0x828abf84
	if ctx.cr[0].eq {
	pc = 0x828ABF84; continue 'dispatch;
	}
	// 828ABF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ABF80: 4BA142E9  bl 0x822c0268
	ctx.lr = 0x828ABF84;
	sub_822C0268(ctx, base);
	// 828ABF84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ABF88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ABF8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ABF90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ABF94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828ABF98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ABF9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ABFA0 size=28
    let mut pc: u32 = 0x828ABFA0;
    'dispatch: loop {
        match pc {
            0x828ABFA0 => {
    //   block [0x828ABFA0..0x828ABFBC)
	// 828ABFA0: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828ABFA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABFA8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 828ABFAC: 409A0008  bne cr6, 0x828abfb4
	if !ctx.cr[6].eq {
	pc = 0x828ABFB4; continue 'dispatch;
	}
	// 828ABFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ABFB4: 806B0378  lwz r3, 0x378(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(888 as u32) ) } as u64;
	// 828ABFB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ABFC0 size=32
    let mut pc: u32 = 0x828ABFC0;
    'dispatch: loop {
        match pc {
            0x828ABFC0 => {
    //   block [0x828ABFC0..0x828ABFE0)
	// 828ABFC0: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 828ABFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ABFC8: 388BFFF0  addi r4, r11, -0x10
	ctx.r[4].s64 = ctx.r[11].s64 + -16;
	// 828ABFCC: 409A000C  bne cr6, 0x828abfd8
	if !ctx.cr[6].eq {
	pc = 0x828ABFD8; continue 'dispatch;
	}
	// 828ABFD0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828ABFD4: 419A000C  beq cr6, 0x828abfe0
	if ctx.cr[6].eq {
		sub_828ABFE0(ctx, base);
		return;
	}
	// 828ABFD8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 828ABFDC: 48000008  b 0x828abfe4
	sub_828ABFE0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ABFE0 size=12
    let mut pc: u32 = 0x828ABFE0;
    'dispatch: loop {
        match pc {
            0x828ABFE0 => {
    //   block [0x828ABFE0..0x828ABFEC)
	// 828ABFE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ABFE4: 806B0370  lwz r3, 0x370(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(880 as u32) ) } as u64;
	// 828ABFE8: 4BFFF5C0  b 0x828ab5a8
	sub_828AB5A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ABFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ABFF0 size=128
    let mut pc: u32 = 0x828ABFF0;
    'dispatch: loop {
        match pc {
            0x828ABFF0 => {
    //   block [0x828ABFF0..0x828AC070)
	// 828ABFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ABFF4: 488FC179  bl 0x831a816c
	ctx.lr = 0x828ABFF8;
	sub_831A8130(ctx, base);
	// 828ABFF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ABFFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AC000: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AC004: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AC008: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828AC00C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AC010: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828AC014: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 828AC018: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828AC01C: 485463CD  bl 0x82df23e8
	ctx.lr = 0x828AC020;
	sub_82DF23E8(ctx, base);
	// 828AC020: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AC024: 41820018  beq 0x828ac03c
	if ctx.cr[0].eq {
	pc = 0x828AC03C; continue 'dispatch;
	}
	// 828AC028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AC02C: 88BE0000  lbz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC030: 482A69A9  bl 0x82b529d8
	ctx.lr = 0x828AC034;
	sub_82B529D8(ctx, base);
	// 828AC034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC038: 48000008  b 0x828ac040
	pc = 0x828AC040; continue 'dispatch;
	// 828AC03C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828AC040: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828AC044: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828AC048: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AC04C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AC050: 4BF6BD61  bl 0x82817db0
	ctx.lr = 0x828AC054;
	sub_82817DB0(ctx, base);
	// 828AC054: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AC058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AC05C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AC060: 4BA13FA1  bl 0x822c0000
	ctx.lr = 0x828AC064;
	sub_822C0000(ctx, base);
	// 828AC064: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC068: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AC06C: 488FC150  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AC070 size=248
    let mut pc: u32 = 0x828AC070;
    'dispatch: loop {
        match pc {
            0x828AC070 => {
    //   block [0x828AC070..0x828AC168)
	// 828AC070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AC078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AC07C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AC080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC084: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC08C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC090: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AC094: 388BA1B8  addi r4, r11, -0x5e48
	ctx.r[4].s64 = ctx.r[11].s64 + -24136;
	// 828AC098: 48547971  bl 0x82df3a08
	ctx.lr = 0x828AC09C;
	sub_82DF3A08(ctx, base);
	// 828AC09C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828AC0A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AC0A4: 48547265  bl 0x82df3308
	ctx.lr = 0x828AC0A8;
	sub_82DF3308(ctx, base);
	// 828AC0A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AC0AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828AC0B0: 48547379  bl 0x82df3428
	ctx.lr = 0x828AC0B4;
	sub_82DF3428(ctx, base);
	// 828AC0B4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AC0B8: 41820098  beq 0x828ac150
	if ctx.cr[0].eq {
	pc = 0x828AC150; continue 'dispatch;
	}
	// 828AC0BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AC0C0: 3D408207  lis r10, -0x7df9
	ctx.r[10].s64 = -2113470464;
	// 828AC0C4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828AC0C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828AC0CC: 388A6D30  addi r4, r10, 0x6d30
	ctx.r[4].s64 = ctx.r[10].s64 + 27952;
	// 828AC0D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC0D4: 4BFFFF1D  bl 0x828abff0
	ctx.lr = 0x828AC0D8;
	sub_828ABFF0(ctx, base);
	// 828AC0D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC0DC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828AC0E0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC0E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC0E8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828AC0EC: 419A0024  beq cr6, 0x828ac110
	if ctx.cr[6].eq {
	pc = 0x828AC110; continue 'dispatch;
	}
	// 828AC0F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AC0F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AC0F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC0FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AC100: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AC104: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC108: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC10C: 4082FFE8  bne 0x828ac0f4
	if !ctx.cr[0].eq {
	pc = 0x828AC0F4; continue 'dispatch;
	}
	// 828AC110: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AC114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC118: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 828AC11C: 409A0008  bne cr6, 0x828ac124
	if !ctx.cr[6].eq {
	pc = 0x828AC124; continue 'dispatch;
	}
	// 828AC120: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AC124: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC128: 806B0388  lwz r3, 0x388(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(904 as u32) ) } as u64;
	// 828AC12C: 4BF4BF4D  bl 0x827f8078
	ctx.lr = 0x828AC130;
	sub_827F8078(ctx, base);
	// 828AC130: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AC134: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AC138: 419A0008  beq cr6, 0x828ac140
	if ctx.cr[6].eq {
	pc = 0x828AC140; continue 'dispatch;
	}
	// 828AC13C: 4BA14755  bl 0x822c0890
	ctx.lr = 0x828AC140;
	sub_822C0890(ctx, base);
	// 828AC140: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AC144: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AC148: 419A0008  beq cr6, 0x828ac150
	if ctx.cr[6].eq {
	pc = 0x828AC150; continue 'dispatch;
	}
	// 828AC14C: 4BA14745  bl 0x822c0890
	ctx.lr = 0x828AC150;
	sub_822C0890(ctx, base);
	// 828AC150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AC154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AC158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AC15C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AC160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AC164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AC168 size=932
    let mut pc: u32 = 0x828AC168;
    'dispatch: loop {
        match pc {
            0x828AC168 => {
    //   block [0x828AC168..0x828AC50C)
	// 828AC168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC16C: 488FBFF9  bl 0x831a8164
	ctx.lr = 0x828AC170;
	sub_831A8130(ctx, base);
	// 828AC170: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828AC174: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC178: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AC17C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828AC180: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AC184: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828AC188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AC18C: 4BF436C5  bl 0x827ef850
	ctx.lr = 0x828AC190;
	sub_827EF850(ctx, base);
	// 828AC190: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AC194: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AC198: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 828AC19C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AC1A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AC1A4: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AC510 size=12
    let mut pc: u32 = 0x828AC510;
    'dispatch: loop {
        match pc {
            0x828AC510 => {
    //   block [0x828AC510..0x828AC51C)
	// 828AC510: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AC514: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AC518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AC520 size=708
    let mut pc: u32 = 0x828AC520;
    'dispatch: loop {
        match pc {
            0x828AC520 => {
    //   block [0x828AC520..0x828AC7E4)
	// 828AC520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AC528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AC52C: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 828AC530: 488FC545  bl 0x831a8a74
	ctx.lr = 0x828AC534;
	sub_831A8A40(ctx, base);
	// 828AC534: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC538: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828AC53C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AC540: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828AC544: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828AC548: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828AC54C: C1AB7BC4  lfs f13, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AC550: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828AC554: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AC558: C18AD72C  lfs f12, -0x28d4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10452 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828AC55C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828AC560: C169D86C  lfs f11, -0x2794(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828AC564: C148D0F8  lfs f10, -0x2f08(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828AC568: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828AC56C: C1279C28  lfs f9, -0x63d8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25560 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828AC570: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 828AC574: C3A6A1C4  lfs f29, -0x5e3c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828AC578: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 828AC57C: C36B89AC  lfs f27, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 828AC580: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 828AC584: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AC588: C10A9D1C  lfs f8, -0x62e4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828AC58C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC590: C3899524  lfs f28, -0x6adc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828AC594: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AC598: C0087BC8  lfs f0, 0x7bc8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(31688 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AC59C: C3E76150  lfs f31, 0x6150(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24912 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AC5A0: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 828AC5A4: C3C69450  lfs f30, -0x6bb0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828AC5A8: C0EB9648  lfs f7, -0x69b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27064 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 828AC5AC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 828AC5B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AC5B4: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 828AC5B8: D17F000C  stfs f11, 0xc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 828AC5BC: D15F0010  stfs f10, 0x10(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 828AC5C0: D13F0014  stfs f9, 0x14(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 828AC5C4: D3BF0018  stfs f29, 0x18(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 828AC5C8: D37F001C  stfs f27, 0x1c(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 828AC5CC: D11F0020  stfs f8, 0x20(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 828AC5D0: D39F0024  stfs f28, 0x24(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 828AC5D4: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 828AC5D8: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 828AC5DC: D3FF0030  stfs f31, 0x30(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 828AC5E0: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 828AC5E4: D3FF0038  stfs f31, 0x38(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 828AC5E8: D3FF003C  stfs f31, 0x3c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 828AC5EC: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 828AC5F0: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 828AC5F4: D3FF0048  stfs f31, 0x48(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 828AC5F8: D3DF004C  stfs f30, 0x4c(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 828AC5FC: D3DF0050  stfs f30, 0x50(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 828AC600: D0FF0054  stfs f7, 0x54(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 828AC604: 480AA0D5  bl 0x829566d8
	ctx.lr = 0x828AC608;
	sub_829566D8(ctx, base);
	// 828AC608: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 828AC60C: 480AA07D  bl 0x82956688
	ctx.lr = 0x828AC610;
	sub_82956688(ctx, base);
	// 828AC610: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 828AC614: 480AA075  bl 0x82956688
	ctx.lr = 0x828AC618;
	sub_82956688(ctx, base);
	// 828AC618: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 828AC61C: 480AA06D  bl 0x82956688
	ctx.lr = 0x828AC620;
	sub_82956688(ctx, base);
	// 828AC620: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 828AC624: 480AA0B5  bl 0x829566d8
	ctx.lr = 0x828AC628;
	sub_829566D8(ctx, base);
	// 828AC628: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 828AC62C: 480AA0FD  bl 0x82956728
	ctx.lr = 0x828AC630;
	sub_82956728(ctx, base);
	// 828AC630: 387F01A8  addi r3, r31, 0x1a8
	ctx.r[3].s64 = ctx.r[31].s64 + 424;
	// 828AC634: 480AA055  bl 0x82956688
	ctx.lr = 0x828AC638;
	sub_82956688(ctx, base);
	// 828AC638: 387F01CC  addi r3, r31, 0x1cc
	ctx.r[3].s64 = ctx.r[31].s64 + 460;
	// 828AC63C: 480AA04D  bl 0x82956688
	ctx.lr = 0x828AC640;
	sub_82956688(ctx, base);
	// 828AC640: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 828AC644: 480AA045  bl 0x82956688
	ctx.lr = 0x828AC648;
	sub_82956688(ctx, base);
	// 828AC648: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 828AC64C: 480AA03D  bl 0x82956688
	ctx.lr = 0x828AC650;
	sub_82956688(ctx, base);
	// 828AC650: 387F0238  addi r3, r31, 0x238
	ctx.r[3].s64 = ctx.r[31].s64 + 568;
	// 828AC654: 480AB5A5  bl 0x82957bf8
	ctx.lr = 0x828AC658;
	sub_82957BF8(ctx, base);
	// 828AC658: 387F0248  addi r3, r31, 0x248
	ctx.r[3].s64 = ctx.r[31].s64 + 584;
	// 828AC65C: 480AB59D  bl 0x82957bf8
	ctx.lr = 0x828AC660;
	sub_82957BF8(ctx, base);
	// 828AC660: 387F0258  addi r3, r31, 0x258
	ctx.r[3].s64 = ctx.r[31].s64 + 600;
	// 828AC664: 480AB595  bl 0x82957bf8
	ctx.lr = 0x828AC668;
	sub_82957BF8(ctx, base);
	// 828AC668: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 828AC66C: 480AB58D  bl 0x82957bf8
	ctx.lr = 0x828AC670;
	sub_82957BF8(ctx, base);
	// 828AC670: 387F0278  addi r3, r31, 0x278
	ctx.r[3].s64 = ctx.r[31].s64 + 632;
	// 828AC674: 480AB585  bl 0x82957bf8
	ctx.lr = 0x828AC678;
	sub_82957BF8(ctx, base);
	// 828AC678: 387F0288  addi r3, r31, 0x288
	ctx.r[3].s64 = ctx.r[31].s64 + 648;
	// 828AC67C: 480AB57D  bl 0x82957bf8
	ctx.lr = 0x828AC680;
	sub_82957BF8(ctx, base);
	// 828AC680: 387F0298  addi r3, r31, 0x298
	ctx.r[3].s64 = ctx.r[31].s64 + 664;
	// 828AC684: 48096CD5  bl 0x82943358
	ctx.lr = 0x828AC688;
	sub_82943358(ctx, base);
	// 828AC688: 387F02A8  addi r3, r31, 0x2a8
	ctx.r[3].s64 = ctx.r[31].s64 + 680;
	// 828AC68C: 48094DA5  bl 0x82941430
	ctx.lr = 0x828AC690;
	sub_82941430(ctx, base);
	// 828AC690: 387F02C4  addi r3, r31, 0x2c4
	ctx.r[3].s64 = ctx.r[31].s64 + 708;
	// 828AC694: 4809625D  bl 0x829428f0
	ctx.lr = 0x828AC698;
	sub_829428F0(ctx, base);
	// 828AC698: 387F02D4  addi r3, r31, 0x2d4
	ctx.r[3].s64 = ctx.r[31].s64 + 724;
	// 828AC69C: 4BF5D15D  bl 0x828097f8
	ctx.lr = 0x828AC6A0;
	sub_828097F8(ctx, base);
	// 828AC6A0: 387F0304  addi r3, r31, 0x304
	ctx.r[3].s64 = ctx.r[31].s64 + 772;
	// 828AC6A4: 4BF5D0DD  bl 0x82809780
	ctx.lr = 0x828AC6A8;
	sub_82809780(ctx, base);
	// 828AC6A8: 387F0320  addi r3, r31, 0x320
	ctx.r[3].s64 = ctx.r[31].s64 + 800;
	// 828AC6AC: 480AD865  bl 0x82959f10
	ctx.lr = 0x828AC6B0;
	sub_82959F10(ctx, base);
	// 828AC6B0: 387F0398  addi r3, r31, 0x398
	ctx.r[3].s64 = ctx.r[31].s64 + 920;
	// 828AC6B4: 480AE59D  bl 0x8295ac50
	ctx.lr = 0x828AC6B8;
	sub_8295AC50(ctx, base);
	// 828AC6B8: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 828AC6BC: 480AE60D  bl 0x8295acc8
	ctx.lr = 0x828AC6C0;
	sub_8295ACC8(ctx, base);
	// 828AC6C0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AC6C4: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828AC6C8: D37F0310  stfs f27, 0x310(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(784 as u32), tmp.u32 ) };
	// 828AC6CC: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 828AC6D0: D39F02B0  stfs f28, 0x2b0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(688 as u32), tmp.u32 ) };
	// 828AC6D4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 828AC6D8: D3BF02C0  stfs f29, 0x2c0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(704 as u32), tmp.u32 ) };
	// 828AC6DC: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 828AC6E0: D3DF02C8  stfs f30, 0x2c8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), tmp.u32 ) };
	// 828AC6E4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 828AC6E8: C00B959C  lfs f0, -0x6a64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AC6EC: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 828AC6F0: C1AA6218  lfs f13, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AC6F4: C1894C5C  lfs f12, 0x4c5c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(19548 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 828AC6F8: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 828AC6FC: C1687DBC  lfs f11, 0x7dbc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 828AC700: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 828AC704: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 828AC708: C1470A9C  lfs f10, 0xa9c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2716 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 828AC70C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828AC710: C12608A8  lfs f9, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 828AC714: C105BBE8  lfs f8, -0x4418(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-17432 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 828AC718: 915F0238  stw r10, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[10].u32 ) };
	// 828AC71C: D01F030C  stfs f0, 0x30c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(780 as u32), tmp.u32 ) };
	// 828AC720: 913F023C  stw r9, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[9].u32 ) };
	// 828AC724: D1BF029C  stfs f13, 0x29c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 828AC728: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 828AC72C: D19F0298  stfs f12, 0x298(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), tmp.u32 ) };
	// 828AC730: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 828AC734: D17F02A8  stfs f11, 0x2a8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), tmp.u32 ) };
	// 828AC738: 915F0248  stw r10, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[10].u32 ) };
	// 828AC73C: D15F02AC  stfs f10, 0x2ac(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(684 as u32), tmp.u32 ) };
	// 828AC740: 913F024C  stw r9, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[9].u32 ) };
	// 828AC744: D01F02C4  stfs f0, 0x2c4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(708 as u32), tmp.u32 ) };
	// 828AC748: 917F0250  stw r11, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[11].u32 ) };
	// 828AC74C: D3DF02CC  stfs f30, 0x2cc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(716 as u32), tmp.u32 ) };
	// 828AC750: 913F0254  stw r9, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[9].u32 ) };
	// 828AC754: D3DF02D0  stfs f30, 0x2d0(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), tmp.u32 ) };
	// 828AC758: 915F0258  stw r10, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[10].u32 ) };
	// 828AC75C: D3BF02D4  stfs f29, 0x2d4(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(724 as u32), tmp.u32 ) };
	// 828AC760: 913F025C  stw r9, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[9].u32 ) };
	// 828AC764: D01F02D8  stfs f0, 0x2d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(728 as u32), tmp.u32 ) };
	// 828AC768: 917F0260  stw r11, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[11].u32 ) };
	// 828AC76C: D39F02DC  stfs f28, 0x2dc(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(732 as u32), tmp.u32 ) };
	// 828AC770: 917F0264  stw r11, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[11].u32 ) };
	// 828AC774: D13F02E0  stfs f9, 0x2e0(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), tmp.u32 ) };
	// 828AC778: 915F0268  stw r10, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[10].u32 ) };
	// 828AC77C: D3FF02FC  stfs f31, 0x2fc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(764 as u32), tmp.u32 ) };
	// 828AC780: 913F026C  stw r9, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[9].u32 ) };
	// 828AC784: D11F0320  stfs f8, 0x320(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(800 as u32), tmp.u32 ) };
	// 828AC788: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 828AC78C: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 828AC790: 915F0278  stw r10, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[10].u32 ) };
	// 828AC794: 913F027C  stw r9, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[9].u32 ) };
	// 828AC798: 917F0280  stw r11, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[11].u32 ) };
	// 828AC79C: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 828AC7A0: 915F0288  stw r10, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[10].u32 ) };
	// 828AC7A4: 913F028C  stw r9, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[9].u32 ) };
	// 828AC7A8: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 828AC7AC: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 828AC7B0: 915F0304  stw r10, 0x304(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(772 as u32), ctx.r[10].u32 ) };
	// 828AC7B4: 915F0308  stw r10, 0x308(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(776 as u32), ctx.r[10].u32 ) };
	// 828AC7B8: 991F0368  stb r8, 0x368(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), ctx.r[8].u8 ) };
	// 828AC7BC: 991F0378  stb r8, 0x378(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(888 as u32), ctx.r[8].u8 ) };
	// 828AC7C0: 991F0388  stb r8, 0x388(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[8].u8 ) };
	// 828AC7C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AC7C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AC7CC: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 828AC7D0: 488FC2F1  bl 0x831a8ac0
	ctx.lr = 0x828AC7D4;
	sub_831A8A8C(ctx, base);
	// 828AC7D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AC7D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AC7DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AC7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AC7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AC7E8 size=3748
    let mut pc: u32 = 0x828AC7E8;
    'dispatch: loop {
        match pc {
            0x828AC7E8 => {
    //   block [0x828AC7E8..0x828AD68C)
	// 828AC7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AC7EC: 488FB971  bl 0x831a815c
	ctx.lr = 0x828AC7F0;
	sub_831A8130(ctx, base);
	// 828AC7F0: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 828AC7F4: 488FC285  bl 0x831a8a78
	ctx.lr = 0x828AC7F8;
	sub_831A8A40(ctx, base);
	// 828AC7F8: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AC7FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828AC800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AC804: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AC808: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC80C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AC810: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828AC814: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828AC818: 419A0024  beq cr6, 0x828ac83c
	if ctx.cr[6].eq {
	pc = 0x828AC83C; continue 'dispatch;
	}
	// 828AC81C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AC820: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AC824: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC828: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AC82C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AC830: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AC834: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AC838: 4082FFE8  bne 0x828ac820
	if !ctx.cr[0].eq {
	pc = 0x828AC820; continue 'dispatch;
	}
	// 828AC83C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC840: 387F0320  addi r3, r31, 0x320
	ctx.r[3].s64 = ctx.r[31].s64 + 800;
	// 828AC844: 480AE2D5  bl 0x8295ab18
	ctx.lr = 0x828AC848;
	sub_8295AB18(ctx, base);
	// 828AC848: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC84C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC850: 388BAA54  addi r4, r11, -0x55ac
	ctx.r[4].s64 = ctx.r[11].s64 + -21932;
	// 828AC854: 485471B5  bl 0x82df3a08
	ctx.lr = 0x828AC858;
	sub_82DF3A08(ctx, base);
	// 828AC858: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828AC85C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828AC860: 388B44A0  addi r4, r11, 0x44a0
	ctx.r[4].s64 = ctx.r[11].s64 + 17568;
	// 828AC864: 485471A5  bl 0x82df3a08
	ctx.lr = 0x828AC868;
	sub_82DF3A08(ctx, base);
	// 828AC868: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828AC86C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828AC870: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC874: 4BD1DC8D  bl 0x825ca500
	ctx.lr = 0x828AC878;
	sub_825CA500(ctx, base);
	// 828AC878: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AC87C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828AC880: 48546BA9  bl 0x82df3428
	ctx.lr = 0x828AC884;
	sub_82DF3428(ctx, base);
	// 828AC884: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AC888: 48546BA1  bl 0x82df3428
	ctx.lr = 0x828AC88C;
	sub_82DF3428(ctx, base);
	// 828AC88C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC894: 388BAA38  addi r4, r11, -0x55c8
	ctx.r[4].s64 = ctx.r[11].s64 + -21960;
	// 828AC898: 48547171  bl 0x82df3a08
	ctx.lr = 0x828AC89C;
	sub_82DF3A08(ctx, base);
	// 828AC89C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC8A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC8A4: 388BAA14  addi r4, r11, -0x55ec
	ctx.r[4].s64 = ctx.r[11].s64 + -21996;
	// 828AC8A8: 48547161  bl 0x82df3a08
	ctx.lr = 0x828AC8AC;
	sub_82DF3A08(ctx, base);
	// 828AC8AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AC8B0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828AC8B4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828AC8B8: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 828AC8BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC8C0: C3AB964C  lfs f29, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828AC8C4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828AC8C8: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AC8CC: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828AC8D0: C04A89AC  lfs f2, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828AC8D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AC8D8: 4BCF69D1  bl 0x825a32a8
	ctx.lr = 0x828AC8DC;
	sub_825A32A8(ctx, base);
	// 828AC8DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AC8E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC8E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AC8E8: 4BCF4E89  bl 0x825a1770
	ctx.lr = 0x828AC8EC;
	sub_825A1770(ctx, base);
	// 828AC8EC: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 828AC8F0: 48546B39  bl 0x82df3428
	ctx.lr = 0x828AC8F4;
	sub_82DF3428(ctx, base);
	// 828AC8F4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 828AC8F8: 4BA1C3C1  bl 0x822c8cb8
	ctx.lr = 0x828AC8FC;
	sub_822C8CB8(ctx, base);
	// 828AC8FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC900: 48546B29  bl 0x82df3428
	ctx.lr = 0x828AC904;
	sub_82DF3428(ctx, base);
	// 828AC904: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC908: 48546B21  bl 0x82df3428
	ctx.lr = 0x828AC90C;
	sub_82DF3428(ctx, base);
	// 828AC90C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC914: 388BA9F8  addi r4, r11, -0x5608
	ctx.r[4].s64 = ctx.r[11].s64 + -22024;
	// 828AC918: 485470F1  bl 0x82df3a08
	ctx.lr = 0x828AC91C;
	sub_82DF3A08(ctx, base);
	// 828AC91C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC920: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC924: 388BA9E8  addi r4, r11, -0x5618
	ctx.r[4].s64 = ctx.r[11].s64 + -22040;
	// 828AC928: 485470E1  bl 0x82df3a08
	ctx.lr = 0x828AC92C;
	sub_82DF3A08(ctx, base);
	// 828AC92C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AC930: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828AC934: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AC938: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 828AC93C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AC940: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828AC944: C3CB9528  lfs f30, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 828AC948: C38A6218  lfs f28, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 828AC94C: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828AC950: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828AC954: 4BCF6955  bl 0x825a32a8
	ctx.lr = 0x828AC958;
	sub_825A32A8(ctx, base);
	// 828AC958: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AC95C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC960: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC964: 4BCF4E0D  bl 0x825a1770
	ctx.lr = 0x828AC968;
	sub_825A1770(ctx, base);
	// 828AC968: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 828AC96C: 48546ABD  bl 0x82df3428
	ctx.lr = 0x828AC970;
	sub_82DF3428(ctx, base);
	// 828AC970: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828AC974: 4BA1C345  bl 0x822c8cb8
	ctx.lr = 0x828AC978;
	sub_822C8CB8(ctx, base);
	// 828AC978: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC97C: 48546AAD  bl 0x82df3428
	ctx.lr = 0x828AC980;
	sub_82DF3428(ctx, base);
	// 828AC980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC984: 48546AA5  bl 0x82df3428
	ctx.lr = 0x828AC988;
	sub_82DF3428(ctx, base);
	// 828AC988: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC98C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC990: 388BA9D4  addi r4, r11, -0x562c
	ctx.r[4].s64 = ctx.r[11].s64 + -22060;
	// 828AC994: 48547075  bl 0x82df3a08
	ctx.lr = 0x828AC998;
	sub_82DF3A08(ctx, base);
	// 828AC998: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AC99C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC9A0: 388BA9B0  addi r4, r11, -0x5650
	ctx.r[4].s64 = ctx.r[11].s64 + -22096;
	// 828AC9A4: 48547065  bl 0x82df3a08
	ctx.lr = 0x828AC9A8;
	sub_82DF3A08(ctx, base);
	// 828AC9A8: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 828AC9AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AC9B0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AC9B4: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 828AC9B8: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 828AC9BC: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 828AC9C0: 4BCF68E9  bl 0x825a32a8
	ctx.lr = 0x828AC9C4;
	sub_825A32A8(ctx, base);
	// 828AC9C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AC9C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AC9CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AC9D0: 4BCF4DA1  bl 0x825a1770
	ctx.lr = 0x828AC9D4;
	sub_825A1770(ctx, base);
	// 828AC9D4: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 828AC9D8: 48546A51  bl 0x82df3428
	ctx.lr = 0x828AC9DC;
	sub_82DF3428(ctx, base);
	// 828AC9DC: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 828AC9E0: 4BA1C2D9  bl 0x822c8cb8
	ctx.lr = 0x828AC9E4;
	sub_822C8CB8(ctx, base);
	// 828AC9E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AC9E8: 48546A41  bl 0x82df3428
	ctx.lr = 0x828AC9EC;
	sub_82DF3428(ctx, base);
	// 828AC9EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AC9F0: 48546A39  bl 0x82df3428
	ctx.lr = 0x828AC9F4;
	sub_82DF3428(ctx, base);
	// 828AC9F4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AC9F8: 4BD1D2D9  bl 0x825c9cd0
	ctx.lr = 0x828AC9FC;
	sub_825C9CD0(ctx, base);
	// 828AC9FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACA00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACA04: 388BA990  addi r4, r11, -0x5670
	ctx.r[4].s64 = ctx.r[11].s64 + -22128;
	// 828ACA08: 48547001  bl 0x82df3a08
	ctx.lr = 0x828ACA0C;
	sub_82DF3A08(ctx, base);
	// 828ACA0C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACA10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACA14: 388BA984  addi r4, r11, -0x567c
	ctx.r[4].s64 = ctx.r[11].s64 + -22140;
	// 828ACA18: 48546FF1  bl 0x82df3a08
	ctx.lr = 0x828ACA1C;
	sub_82DF3A08(ctx, base);
	// 828ACA1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828ACA20: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828ACA24: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACA28: 4BD1DAD9  bl 0x825ca500
	ctx.lr = 0x828ACA2C;
	sub_825CA500(ctx, base);
	// 828ACA2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ACA30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACA34: 485469F5  bl 0x82df3428
	ctx.lr = 0x828ACA38;
	sub_82DF3428(ctx, base);
	// 828ACA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACA3C: 485469ED  bl 0x82df3428
	ctx.lr = 0x828ACA40;
	sub_82DF3428(ctx, base);
	// 828ACA40: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACA44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACA48: 388BA974  addi r4, r11, -0x568c
	ctx.r[4].s64 = ctx.r[11].s64 + -22156;
	// 828ACA4C: 48546FBD  bl 0x82df3a08
	ctx.lr = 0x828ACA50;
	sub_82DF3A08(ctx, base);
	// 828ACA50: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACA54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACA58: 388BA95C  addi r4, r11, -0x56a4
	ctx.r[4].s64 = ctx.r[11].s64 + -22180;
	// 828ACA5C: 48546FAD  bl 0x82df3a08
	ctx.lr = 0x828ACA60;
	sub_82DF3A08(ctx, base);
	// 828ACA60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828ACA64: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 828ACA68: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828ACA6C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828ACA70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828ACA74: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 828ACA78: C3AB08A8  lfs f29, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828ACA7C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828ACA80: 4BCF6829  bl 0x825a32a8
	ctx.lr = 0x828ACA84;
	sub_825A32A8(ctx, base);
	// 828ACA84: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828ACA88: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACA8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACA90: 4BCF4CE1  bl 0x825a1770
	ctx.lr = 0x828ACA94;
	sub_825A1770(ctx, base);
	// 828ACA94: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 828ACA98: 48546991  bl 0x82df3428
	ctx.lr = 0x828ACA9C;
	sub_82DF3428(ctx, base);
	// 828ACA9C: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 828ACAA0: 4BA1C219  bl 0x822c8cb8
	ctx.lr = 0x828ACAA4;
	sub_822C8CB8(ctx, base);
	// 828ACAA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACAA8: 48546981  bl 0x82df3428
	ctx.lr = 0x828ACAAC;
	sub_82DF3428(ctx, base);
	// 828ACAAC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACAB0: 48546979  bl 0x82df3428
	ctx.lr = 0x828ACAB4;
	sub_82DF3428(ctx, base);
	// 828ACAB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACAB8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACABC: 388BA94C  addi r4, r11, -0x56b4
	ctx.r[4].s64 = ctx.r[11].s64 + -22196;
	// 828ACAC0: 48546F49  bl 0x82df3a08
	ctx.lr = 0x828ACAC4;
	sub_82DF3A08(ctx, base);
	// 828ACAC4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACAC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACACC: 388BA930  addi r4, r11, -0x56d0
	ctx.r[4].s64 = ctx.r[11].s64 + -22224;
	// 828ACAD0: 48546F39  bl 0x82df3a08
	ctx.lr = 0x828ACAD4;
	sub_82DF3A08(ctx, base);
	// 828ACAD4: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 828ACAD8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828ACADC: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828ACAE0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828ACAE4: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828ACAE8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828ACAEC: 4BCF67BD  bl 0x825a32a8
	ctx.lr = 0x828ACAF0;
	sub_825A32A8(ctx, base);
	// 828ACAF0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828ACAF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACAF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACAFC: 4BCF4C75  bl 0x825a1770
	ctx.lr = 0x828ACB00;
	sub_825A1770(ctx, base);
	// 828ACB00: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 828ACB04: 48546925  bl 0x82df3428
	ctx.lr = 0x828ACB08;
	sub_82DF3428(ctx, base);
	// 828ACB08: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 828ACB0C: 4BA1C1AD  bl 0x822c8cb8
	ctx.lr = 0x828ACB10;
	sub_822C8CB8(ctx, base);
	// 828ACB10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACB14: 48546915  bl 0x82df3428
	ctx.lr = 0x828ACB18;
	sub_82DF3428(ctx, base);
	// 828ACB18: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACB1C: 4854690D  bl 0x82df3428
	ctx.lr = 0x828ACB20;
	sub_82DF3428(ctx, base);
	// 828ACB20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACB24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACB28: 388BA91C  addi r4, r11, -0x56e4
	ctx.r[4].s64 = ctx.r[11].s64 + -22244;
	// 828ACB2C: 48546EDD  bl 0x82df3a08
	ctx.lr = 0x828ACB30;
	sub_82DF3A08(ctx, base);
	// 828ACB30: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACB34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACB38: 388BA8FC  addi r4, r11, -0x5704
	ctx.r[4].s64 = ctx.r[11].s64 + -22276;
	// 828ACB3C: 48546ECD  bl 0x82df3a08
	ctx.lr = 0x828ACB40;
	sub_82DF3A08(ctx, base);
	// 828ACB40: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 828ACB44: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828ACB48: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828ACB4C: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 828ACB50: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828ACB54: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828ACB58: 4BCF6751  bl 0x825a32a8
	ctx.lr = 0x828ACB5C;
	sub_825A32A8(ctx, base);
	// 828ACB5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828ACB60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACB64: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACB68: 4BCF4C09  bl 0x825a1770
	ctx.lr = 0x828ACB6C;
	sub_825A1770(ctx, base);
	// 828ACB6C: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 828ACB70: 485468B9  bl 0x82df3428
	ctx.lr = 0x828ACB74;
	sub_82DF3428(ctx, base);
	// 828ACB74: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 828ACB78: 4BA1C141  bl 0x822c8cb8
	ctx.lr = 0x828ACB7C;
	sub_822C8CB8(ctx, base);
	// 828ACB7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACB80: 485468A9  bl 0x82df3428
	ctx.lr = 0x828ACB84;
	sub_82DF3428(ctx, base);
	// 828ACB84: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACB88: 485468A1  bl 0x82df3428
	ctx.lr = 0x828ACB8C;
	sub_82DF3428(ctx, base);
	// 828ACB8C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACB90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACB94: 388BA8EC  addi r4, r11, -0x5714
	ctx.r[4].s64 = ctx.r[11].s64 + -22292;
	// 828ACB98: 48546E71  bl 0x82df3a08
	ctx.lr = 0x828ACB9C;
	sub_82DF3A08(ctx, base);
	// 828ACB9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACBA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACBA4: 3B8BA8D0  addi r28, r11, -0x5730
	ctx.r[28].s64 = ctx.r[11].s64 + -22320;
	// 828ACBA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828ACBAC: 48546E5D  bl 0x82df3a08
	ctx.lr = 0x828ACBB0;
	sub_82DF3A08(ctx, base);
	// 828ACBB0: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 828ACBB4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828ACBB8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828ACBBC: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 828ACBC0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828ACBC4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828ACBC8: 4BCF66E1  bl 0x825a32a8
	ctx.lr = 0x828ACBCC;
	sub_825A32A8(ctx, base);
	// 828ACBCC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828ACBD0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACBD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACBD8: 4BCF4B99  bl 0x825a1770
	ctx.lr = 0x828ACBDC;
	sub_825A1770(ctx, base);
	// 828ACBDC: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 828ACBE0: 48546849  bl 0x82df3428
	ctx.lr = 0x828ACBE4;
	sub_82DF3428(ctx, base);
	// 828ACBE4: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 828ACBE8: 4BA1C0D1  bl 0x822c8cb8
	ctx.lr = 0x828ACBEC;
	sub_822C8CB8(ctx, base);
	// 828ACBEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACBF0: 48546839  bl 0x82df3428
	ctx.lr = 0x828ACBF4;
	sub_82DF3428(ctx, base);
	// 828ACBF4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACBF8: 48546831  bl 0x82df3428
	ctx.lr = 0x828ACBFC;
	sub_82DF3428(ctx, base);
	// 828ACBFC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACC00: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACC04: 388BA8C0  addi r4, r11, -0x5740
	ctx.r[4].s64 = ctx.r[11].s64 + -22336;
	// 828ACC08: 48546E01  bl 0x82df3a08
	ctx.lr = 0x828ACC0C;
	sub_82DF3A08(ctx, base);
	// 828ACC0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828ACC10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACC14: 48546DF5  bl 0x82df3a08
	ctx.lr = 0x828ACC18;
	sub_82DF3A08(ctx, base);
	// 828ACC18: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 828ACC1C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828ACC20: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 828ACC24: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 828ACC28: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 828ACC2C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828ACC30: 4BCF6679  bl 0x825a32a8
	ctx.lr = 0x828ACC34;
	sub_825A32A8(ctx, base);
	// 828ACC34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828ACC38: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACC3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ACC40: 4BCF4B31  bl 0x825a1770
	ctx.lr = 0x828ACC44;
	sub_825A1770(ctx, base);
	// 828ACC44: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 828ACC48: 485467E1  bl 0x82df3428
	ctx.lr = 0x828ACC4C;
	sub_82DF3428(ctx, base);
	// 828ACC4C: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 828ACC50: 4BA1C069  bl 0x822c8cb8
	ctx.lr = 0x828ACC54;
	sub_822C8CB8(ctx, base);
	// 828ACC54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828ACC58: 485467D1  bl 0x82df3428
	ctx.lr = 0x828ACC5C;
	sub_82DF3428(ctx, base);
	// 828ACC5C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828ACC60: 485467C9  bl 0x82df3428
	ctx.lr = 0x828ACC64;
	sub_82DF3428(ctx, base);
	// 828ACC64: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACC68: 4BD1D069  bl 0x825c9cd0
	ctx.lr = 0x828ACC6C;
	sub_825C9CD0(ctx, base);
	// 828ACC6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACC70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACC74: 3B4B9558  addi r26, r11, -0x6aa8
	ctx.r[26].s64 = ctx.r[11].s64 + -27304;
	// 828ACC78: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828ACC7C: 48546D8D  bl 0x82df3a08
	ctx.lr = 0x828ACC80;
	sub_82DF3A08(ctx, base);
	// 828ACC80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACC84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACC88: 388B9A38  addi r4, r11, -0x65c8
	ctx.r[4].s64 = ctx.r[11].s64 + -26056;
	// 828ACC8C: 48546D7D  bl 0x82df3a08
	ctx.lr = 0x828ACC90;
	sub_82DF3A08(ctx, base);
	// 828ACC90: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACC94: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACC9C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828ACCA0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828ACCA4: 419A0024  beq cr6, 0x828accc8
	if ctx.cr[6].eq {
	pc = 0x828ACCC8; continue 'dispatch;
	}
	// 828ACCA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ACCAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ACCB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACCB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ACCB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ACCBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACCC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACCC4: 4082FFE8  bne 0x828accac
	if !ctx.cr[0].eq {
	pc = 0x828ACCAC; continue 'dispatch;
	}
	// 828ACCC8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828ACCCC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ACCD0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACCD4: 387F0238  addi r3, r31, 0x238
	ctx.r[3].s64 = ctx.r[31].s64 + 568;
	// 828ACCD8: 480AAF39  bl 0x82957c10
	ctx.lr = 0x828ACCDC;
	sub_82957C10(ctx, base);
	// 828ACCDC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACCE0: 48546749  bl 0x82df3428
	ctx.lr = 0x828ACCE4;
	sub_82DF3428(ctx, base);
	// 828ACCE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACCE8: 48546741  bl 0x82df3428
	ctx.lr = 0x828ACCEC;
	sub_82DF3428(ctx, base);
	// 828ACCEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACCF4: 3B6BA8B8  addi r27, r11, -0x5748
	ctx.r[27].s64 = ctx.r[11].s64 + -22344;
	// 828ACCF8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828ACCFC: 48546D0D  bl 0x82df3a08
	ctx.lr = 0x828ACD00;
	sub_82DF3A08(ctx, base);
	// 828ACD00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACD04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACD08: 388B9A1C  addi r4, r11, -0x65e4
	ctx.r[4].s64 = ctx.r[11].s64 + -26084;
	// 828ACD0C: 48546CFD  bl 0x82df3a08
	ctx.lr = 0x828ACD10;
	sub_82DF3A08(ctx, base);
	// 828ACD10: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACD14: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACD1C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828ACD20: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828ACD24: 419A0024  beq cr6, 0x828acd48
	if ctx.cr[6].eq {
	pc = 0x828ACD48; continue 'dispatch;
	}
	// 828ACD28: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ACD2C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ACD30: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACD34: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ACD38: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ACD3C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACD40: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACD44: 4082FFE8  bne 0x828acd2c
	if !ctx.cr[0].eq {
	pc = 0x828ACD2C; continue 'dispatch;
	}
	// 828ACD48: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828ACD4C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ACD50: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACD54: 387F0248  addi r3, r31, 0x248
	ctx.r[3].s64 = ctx.r[31].s64 + 584;
	// 828ACD58: 480AAEB9  bl 0x82957c10
	ctx.lr = 0x828ACD5C;
	sub_82957C10(ctx, base);
	// 828ACD5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACD60: 485466C9  bl 0x82df3428
	ctx.lr = 0x828ACD64;
	sub_82DF3428(ctx, base);
	// 828ACD64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACD68: 485466C1  bl 0x82df3428
	ctx.lr = 0x828ACD6C;
	sub_82DF3428(ctx, base);
	// 828ACD6C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACD70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACD74: 388BA8A0  addi r4, r11, -0x5760
	ctx.r[4].s64 = ctx.r[11].s64 + -22368;
	// 828ACD78: 48546C91  bl 0x82df3a08
	ctx.lr = 0x828ACD7C;
	sub_82DF3A08(ctx, base);
	// 828ACD7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACD80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACD84: 388B99FC  addi r4, r11, -0x6604
	ctx.r[4].s64 = ctx.r[11].s64 + -26116;
	// 828ACD88: 48546C81  bl 0x82df3a08
	ctx.lr = 0x828ACD8C;
	sub_82DF3A08(ctx, base);
	// 828ACD8C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACD90: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACD98: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828ACD9C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828ACDA0: 419A0024  beq cr6, 0x828acdc4
	if ctx.cr[6].eq {
	pc = 0x828ACDC4; continue 'dispatch;
	}
	// 828ACDA4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ACDA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ACDAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACDB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ACDB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ACDB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACDBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACDC0: 4082FFE8  bne 0x828acda8
	if !ctx.cr[0].eq {
	pc = 0x828ACDA8; continue 'dispatch;
	}
	// 828ACDC4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828ACDC8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ACDCC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACDD0: 387F0258  addi r3, r31, 0x258
	ctx.r[3].s64 = ctx.r[31].s64 + 600;
	// 828ACDD4: 480AAE3D  bl 0x82957c10
	ctx.lr = 0x828ACDD8;
	sub_82957C10(ctx, base);
	// 828ACDD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACDDC: 4854664D  bl 0x82df3428
	ctx.lr = 0x828ACDE0;
	sub_82DF3428(ctx, base);
	// 828ACDE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACDE4: 48546645  bl 0x82df3428
	ctx.lr = 0x828ACDE8;
	sub_82DF3428(ctx, base);
	// 828ACDE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACDEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACDF0: 388BA88C  addi r4, r11, -0x5774
	ctx.r[4].s64 = ctx.r[11].s64 + -22388;
	// 828ACDF4: 48546C15  bl 0x82df3a08
	ctx.lr = 0x828ACDF8;
	sub_82DF3A08(ctx, base);
	// 828ACDF8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACDFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACE00: 388B99D8  addi r4, r11, -0x6628
	ctx.r[4].s64 = ctx.r[11].s64 + -26152;
	// 828ACE04: 48546C05  bl 0x82df3a08
	ctx.lr = 0x828ACE08;
	sub_82DF3A08(ctx, base);
	// 828ACE08: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACE0C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACE14: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828ACE18: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828ACE1C: 419A0024  beq cr6, 0x828ace40
	if ctx.cr[6].eq {
	pc = 0x828ACE40; continue 'dispatch;
	}
	// 828ACE20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ACE24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ACE28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACE2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ACE30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ACE34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACE38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACE3C: 4082FFE8  bne 0x828ace24
	if !ctx.cr[0].eq {
	pc = 0x828ACE24; continue 'dispatch;
	}
	// 828ACE40: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828ACE44: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ACE48: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACE4C: 387F0268  addi r3, r31, 0x268
	ctx.r[3].s64 = ctx.r[31].s64 + 616;
	// 828ACE50: 480AADC1  bl 0x82957c10
	ctx.lr = 0x828ACE54;
	sub_82957C10(ctx, base);
	// 828ACE54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACE58: 485465D1  bl 0x82df3428
	ctx.lr = 0x828ACE5C;
	sub_82DF3428(ctx, base);
	// 828ACE5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACE60: 485465C9  bl 0x82df3428
	ctx.lr = 0x828ACE64;
	sub_82DF3428(ctx, base);
	// 828ACE64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACE68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACE6C: 3BABA880  addi r29, r11, -0x5780
	ctx.r[29].s64 = ctx.r[11].s64 + -22400;
	// 828ACE70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828ACE74: 48546B95  bl 0x82df3a08
	ctx.lr = 0x828ACE78;
	sub_82DF3A08(ctx, base);
	// 828ACE78: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACE7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACE80: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 828ACE84: 48546B85  bl 0x82df3a08
	ctx.lr = 0x828ACE88;
	sub_82DF3A08(ctx, base);
	// 828ACE88: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACE8C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACE90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACE94: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828ACE98: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828ACE9C: 419A0024  beq cr6, 0x828acec0
	if ctx.cr[6].eq {
	pc = 0x828ACEC0; continue 'dispatch;
	}
	// 828ACEA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ACEA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ACEA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACEAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ACEB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ACEB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACEB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACEBC: 4082FFE8  bne 0x828acea4
	if !ctx.cr[0].eq {
	pc = 0x828ACEA4; continue 'dispatch;
	}
	// 828ACEC0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828ACEC4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ACEC8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACECC: 387F0278  addi r3, r31, 0x278
	ctx.r[3].s64 = ctx.r[31].s64 + 632;
	// 828ACED0: 480AAD41  bl 0x82957c10
	ctx.lr = 0x828ACED4;
	sub_82957C10(ctx, base);
	// 828ACED4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACED8: 48546551  bl 0x82df3428
	ctx.lr = 0x828ACEDC;
	sub_82DF3428(ctx, base);
	// 828ACEDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACEE0: 48546549  bl 0x82df3428
	ctx.lr = 0x828ACEE4;
	sub_82DF3428(ctx, base);
	// 828ACEE4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACEEC: 388BA86C  addi r4, r11, -0x5794
	ctx.r[4].s64 = ctx.r[11].s64 + -22420;
	// 828ACEF0: 48546B19  bl 0x82df3a08
	ctx.lr = 0x828ACEF4;
	sub_82DF3A08(ctx, base);
	// 828ACEF4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACEF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACEFC: 388B99C4  addi r4, r11, -0x663c
	ctx.r[4].s64 = ctx.r[11].s64 + -26172;
	// 828ACF00: 48546B09  bl 0x82df3a08
	ctx.lr = 0x828ACF04;
	sub_82DF3A08(ctx, base);
	// 828ACF04: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828ACF08: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACF0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ACF10: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828ACF14: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828ACF18: 419A0024  beq cr6, 0x828acf3c
	if ctx.cr[6].eq {
	pc = 0x828ACF3C; continue 'dispatch;
	}
	// 828ACF1C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828ACF20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828ACF24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACF28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828ACF2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828ACF30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828ACF34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828ACF38: 4082FFE8  bne 0x828acf20
	if !ctx.cr[0].eq {
	pc = 0x828ACF20; continue 'dispatch;
	}
	// 828ACF3C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828ACF40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828ACF44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828ACF48: 387F0288  addi r3, r31, 0x288
	ctx.r[3].s64 = ctx.r[31].s64 + 648;
	// 828ACF4C: 480AACC5  bl 0x82957c10
	ctx.lr = 0x828ACF50;
	sub_82957C10(ctx, base);
	// 828ACF50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACF54: 485464D5  bl 0x82df3428
	ctx.lr = 0x828ACF58;
	sub_82DF3428(ctx, base);
	// 828ACF58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACF5C: 485464CD  bl 0x82df3428
	ctx.lr = 0x828ACF60;
	sub_82DF3428(ctx, base);
	// 828ACF60: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACF64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACF68: 388BA860  addi r4, r11, -0x57a0
	ctx.r[4].s64 = ctx.r[11].s64 + -22432;
	// 828ACF6C: 48546A9D  bl 0x82df3a08
	ctx.lr = 0x828ACF70;
	sub_82DF3A08(ctx, base);
	// 828ACF70: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACF74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACF78: 388BA84C  addi r4, r11, -0x57b4
	ctx.r[4].s64 = ctx.r[11].s64 + -22452;
	// 828ACF7C: 48546A8D  bl 0x82df3a08
	ctx.lr = 0x828ACF80;
	sub_82DF3A08(ctx, base);
	// 828ACF80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828ACF84: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828ACF88: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACF8C: 4BD1D575  bl 0x825ca500
	ctx.lr = 0x828ACF90;
	sub_825CA500(ctx, base);
	// 828ACF90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828ACF94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACF98: 48546491  bl 0x82df3428
	ctx.lr = 0x828ACF9C;
	sub_82DF3428(ctx, base);
	// 828ACF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACFA0: 48546489  bl 0x82df3428
	ctx.lr = 0x828ACFA4;
	sub_82DF3428(ctx, base);
	// 828ACFA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828ACFA8: 387F02D4  addi r3, r31, 0x2d4
	ctx.r[3].s64 = ctx.r[31].s64 + 724;
	// 828ACFAC: 4BF5CF75  bl 0x82809f20
	ctx.lr = 0x828ACFB0;
	sub_82809F20(ctx, base);
	// 828ACFB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACFB4: 387F02F4  addi r3, r31, 0x2f4
	ctx.r[3].s64 = ctx.r[31].s64 + 756;
	// 828ACFB8: 388BA830  addi r4, r11, -0x57d0
	ctx.r[4].s64 = ctx.r[11].s64 + -22480;
	// 828ACFBC: 485468BD  bl 0x82df3878
	ctx.lr = 0x828ACFC0;
	sub_82DF3878(ctx, base);
	// 828ACFC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828ACFC4: 387F02F8  addi r3, r31, 0x2f8
	ctx.r[3].s64 = ctx.r[31].s64 + 760;
	// 828ACFC8: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 828ACFCC: 485468AD  bl 0x82df3878
	ctx.lr = 0x828ACFD0;
	sub_82DF3878(ctx, base);
	// 828ACFD0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ACFD4: 4BD1CCFD  bl 0x825c9cd0
	ctx.lr = 0x828ACFD8;
	sub_825C9CD0(ctx, base);
	// 828ACFD8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACFDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ACFE0: 3B8BA824  addi r28, r11, -0x57dc
	ctx.r[28].s64 = ctx.r[11].s64 + -22492;
	// 828ACFE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828ACFE8: 48546A21  bl 0x82df3a08
	ctx.lr = 0x828ACFEC;
	sub_82DF3A08(ctx, base);
	// 828ACFEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ACFF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828ACFF4: 388BA80C  addi r4, r11, -0x57f4
	ctx.r[4].s64 = ctx.r[11].s64 + -22516;
	// 828ACFF8: 48546A11  bl 0x82df3a08
	ctx.lr = 0x828ACFFC;
	sub_82DF3A08(ctx, base);
	// 828ACFFC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828AD000: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AD004: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD008: 4BD1D4F9  bl 0x825ca500
	ctx.lr = 0x828AD00C;
	sub_825CA500(ctx, base);
	// 828AD00C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 828AD010: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD014: 48546415  bl 0x82df3428
	ctx.lr = 0x828AD018;
	sub_82DF3428(ctx, base);
	// 828AD018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD01C: 4854640D  bl 0x82df3428
	ctx.lr = 0x828AD020;
	sub_82DF3428(ctx, base);
	// 828AD020: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 828AD024: 387F0304  addi r3, r31, 0x304
	ctx.r[3].s64 = ctx.r[31].s64 + 772;
	// 828AD028: 4BF5D409  bl 0x8280a430
	ctx.lr = 0x828AD02C;
	sub_8280A430(ctx, base);
	// 828AD02C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AD030: 387F0318  addi r3, r31, 0x318
	ctx.r[3].s64 = ctx.r[31].s64 + 792;
	// 828AD034: 388B83F8  addi r4, r11, -0x7c08
	ctx.r[4].s64 = ctx.r[11].s64 + -31752;
	// 828AD038: 48546841  bl 0x82df3878
	ctx.lr = 0x828AD03C;
	sub_82DF3878(ctx, base);
	// 828AD03C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AD040: 387F031C  addi r3, r31, 0x31c
	ctx.r[3].s64 = ctx.r[31].s64 + 796;
	// 828AD044: 388B83D4  addi r4, r11, -0x7c2c
	ctx.r[4].s64 = ctx.r[11].s64 + -31788;
	// 828AD048: 48546831  bl 0x82df3878
	ctx.lr = 0x828AD04C;
	sub_82DF3878(ctx, base);
	// 828AD04C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD050: 4BD1CC81  bl 0x825c9cd0
	ctx.lr = 0x828AD054;
	sub_825C9CD0(ctx, base);
	// 828AD054: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 828AD058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD05C: 388B6980  addi r4, r11, 0x6980
	ctx.r[4].s64 = ctx.r[11].s64 + 27008;
	// 828AD060: 485469A9  bl 0x82df3a08
	ctx.lr = 0x828AD064;
	sub_82DF3A08(ctx, base);
	// 828AD064: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD068: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD06C: 388BA7FC  addi r4, r11, -0x5804
	ctx.r[4].s64 = ctx.r[11].s64 + -22532;
	// 828AD070: 48546999  bl 0x82df3a08
	ctx.lr = 0x828AD074;
	sub_82DF3A08(ctx, base);
	// 828AD074: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD078: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD07C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828AD080: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD084: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD088: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828AD08C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD090: 4E800421  bctrl
	ctx.lr = 0x828AD094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD094: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD098: 48546391  bl 0x82df3428
	ctx.lr = 0x828AD09C;
	sub_82DF3428(ctx, base);
	// 828AD09C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD0A0: 48546389  bl 0x82df3428
	ctx.lr = 0x828AD0A4;
	sub_82DF3428(ctx, base);
	// 828AD0A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AD0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD0AC: 4854695D  bl 0x82df3a08
	ctx.lr = 0x828AD0B0;
	sub_82DF3A08(ctx, base);
	// 828AD0B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD0B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD0B8: 388BA7F4  addi r4, r11, -0x580c
	ctx.r[4].s64 = ctx.r[11].s64 + -22540;
	// 828AD0BC: 4854694D  bl 0x82df3a08
	ctx.lr = 0x828AD0C0;
	sub_82DF3A08(ctx, base);
	// 828AD0C0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD0C4: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD0CC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD0D0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD0D4: 419A0024  beq cr6, 0x828ad0f8
	if ctx.cr[6].eq {
	pc = 0x828AD0F8; continue 'dispatch;
	}
	// 828AD0D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD0DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD0E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD0E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD0E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD0EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD0F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD0F4: 4082FFE8  bne 0x828ad0dc
	if !ctx.cr[0].eq {
	pc = 0x828AD0DC; continue 'dispatch;
	}
	// 828AD0F8: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 828AD0FC: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 828AD100: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD104: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD108: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD10C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD110: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD114: 4E800421  bctrl
	ctx.lr = 0x828AD118;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD118: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD11C: 4854630D  bl 0x82df3428
	ctx.lr = 0x828AD120;
	sub_82DF3428(ctx, base);
	// 828AD120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD124: 48546305  bl 0x82df3428
	ctx.lr = 0x828AD128;
	sub_82DF3428(ctx, base);
	// 828AD128: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD12C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD130: 388BA7E4  addi r4, r11, -0x581c
	ctx.r[4].s64 = ctx.r[11].s64 + -22556;
	// 828AD134: 485468D5  bl 0x82df3a08
	ctx.lr = 0x828AD138;
	sub_82DF3A08(ctx, base);
	// 828AD138: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD13C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD140: 388BA7D4  addi r4, r11, -0x582c
	ctx.r[4].s64 = ctx.r[11].s64 + -22572;
	// 828AD144: 485468C5  bl 0x82df3a08
	ctx.lr = 0x828AD148;
	sub_82DF3A08(ctx, base);
	// 828AD148: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD14C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD154: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD158: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD15C: 419A0024  beq cr6, 0x828ad180
	if ctx.cr[6].eq {
	pc = 0x828AD180; continue 'dispatch;
	}
	// 828AD160: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD16C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD17C: 4082FFE8  bne 0x828ad164
	if !ctx.cr[0].eq {
	pc = 0x828AD164; continue 'dispatch;
	}
	// 828AD180: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 828AD184: 387F01A8  addi r3, r31, 0x1a8
	ctx.r[3].s64 = ctx.r[31].s64 + 424;
	// 828AD188: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD18C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD190: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD194: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD19C: 4E800421  bctrl
	ctx.lr = 0x828AD1A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD1A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD1A4: 48546285  bl 0x82df3428
	ctx.lr = 0x828AD1A8;
	sub_82DF3428(ctx, base);
	// 828AD1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD1AC: 4854627D  bl 0x82df3428
	ctx.lr = 0x828AD1B0;
	sub_82DF3428(ctx, base);
	// 828AD1B0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828AD1B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD1B8: 48546851  bl 0x82df3a08
	ctx.lr = 0x828AD1BC;
	sub_82DF3A08(ctx, base);
	// 828AD1BC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD1C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD1C4: 388BA7C8  addi r4, r11, -0x5838
	ctx.r[4].s64 = ctx.r[11].s64 + -22584;
	// 828AD1C8: 48546841  bl 0x82df3a08
	ctx.lr = 0x828AD1CC;
	sub_82DF3A08(ctx, base);
	// 828AD1CC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD1D0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD1D8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD1DC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD1E0: 419A0024  beq cr6, 0x828ad204
	if ctx.cr[6].eq {
	pc = 0x828AD204; continue 'dispatch;
	}
	// 828AD1E4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD1E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD1EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD1F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD1F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD1F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD1FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD200: 4082FFE8  bne 0x828ad1e8
	if !ctx.cr[0].eq {
	pc = 0x828AD1E8; continue 'dispatch;
	}
	// 828AD204: 817F01CC  lwz r11, 0x1cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 828AD208: 387F01CC  addi r3, r31, 0x1cc
	ctx.r[3].s64 = ctx.r[31].s64 + 460;
	// 828AD20C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD210: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD214: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD218: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD21C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD220: 4E800421  bctrl
	ctx.lr = 0x828AD224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD224: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD228: 48546201  bl 0x82df3428
	ctx.lr = 0x828AD22C;
	sub_82DF3428(ctx, base);
	// 828AD22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD230: 485461F9  bl 0x82df3428
	ctx.lr = 0x828AD234;
	sub_82DF3428(ctx, base);
	// 828AD234: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828AD238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD23C: 485467CD  bl 0x82df3a08
	ctx.lr = 0x828AD240;
	sub_82DF3A08(ctx, base);
	// 828AD240: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD244: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD248: 388BA7BC  addi r4, r11, -0x5844
	ctx.r[4].s64 = ctx.r[11].s64 + -22596;
	// 828AD24C: 485467BD  bl 0x82df3a08
	ctx.lr = 0x828AD250;
	sub_82DF3A08(ctx, base);
	// 828AD250: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD254: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD25C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD260: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD264: 419A0024  beq cr6, 0x828ad288
	if ctx.cr[6].eq {
	pc = 0x828AD288; continue 'dispatch;
	}
	// 828AD268: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD26C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD270: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD274: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD278: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD27C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD280: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD284: 4082FFE8  bne 0x828ad26c
	if !ctx.cr[0].eq {
	pc = 0x828AD26C; continue 'dispatch;
	}
	// 828AD288: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 828AD28C: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 828AD290: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD294: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD298: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD29C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD2A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD2A4: 4E800421  bctrl
	ctx.lr = 0x828AD2A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD2A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD2AC: 4854617D  bl 0x82df3428
	ctx.lr = 0x828AD2B0;
	sub_82DF3428(ctx, base);
	// 828AD2B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD2B4: 48546175  bl 0x82df3428
	ctx.lr = 0x828AD2B8;
	sub_82DF3428(ctx, base);
	// 828AD2B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD2BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD2C0: 388BA7A8  addi r4, r11, -0x5858
	ctx.r[4].s64 = ctx.r[11].s64 + -22616;
	// 828AD2C4: 48546745  bl 0x82df3a08
	ctx.lr = 0x828AD2C8;
	sub_82DF3A08(ctx, base);
	// 828AD2C8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD2CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD2D0: 388BA790  addi r4, r11, -0x5870
	ctx.r[4].s64 = ctx.r[11].s64 + -22640;
	// 828AD2D4: 48546735  bl 0x82df3a08
	ctx.lr = 0x828AD2D8;
	sub_82DF3A08(ctx, base);
	// 828AD2D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD2DC: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD2E4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD2E8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD2EC: 419A0024  beq cr6, 0x828ad310
	if ctx.cr[6].eq {
	pc = 0x828AD310; continue 'dispatch;
	}
	// 828AD2F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD2F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD2F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD2FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD304: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD308: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD30C: 4082FFE8  bne 0x828ad2f4
	if !ctx.cr[0].eq {
	pc = 0x828AD2F4; continue 'dispatch;
	}
	// 828AD310: 817F01F0  lwz r11, 0x1f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(496 as u32) ) } as u64;
	// 828AD314: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 828AD318: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD31C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD320: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD324: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD32C: 4E800421  bctrl
	ctx.lr = 0x828AD330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD334: 485460F5  bl 0x82df3428
	ctx.lr = 0x828AD338;
	sub_82DF3428(ctx, base);
	// 828AD338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD33C: 485460ED  bl 0x82df3428
	ctx.lr = 0x828AD340;
	sub_82DF3428(ctx, base);
	// 828AD340: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AD344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD348: 485466C1  bl 0x82df3a08
	ctx.lr = 0x828AD34C;
	sub_82DF3A08(ctx, base);
	// 828AD34C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD350: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD354: 388BA77C  addi r4, r11, -0x5884
	ctx.r[4].s64 = ctx.r[11].s64 + -22660;
	// 828AD358: 485466B1  bl 0x82df3a08
	ctx.lr = 0x828AD35C;
	sub_82DF3A08(ctx, base);
	// 828AD35C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD360: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD368: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD36C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD370: 419A0024  beq cr6, 0x828ad394
	if ctx.cr[6].eq {
	pc = 0x828AD394; continue 'dispatch;
	}
	// 828AD374: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD378: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD37C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD380: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD384: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD388: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD38C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD390: 4082FFE8  bne 0x828ad378
	if !ctx.cr[0].eq {
	pc = 0x828AD378; continue 'dispatch;
	}
	// 828AD394: 817F0214  lwz r11, 0x214(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 828AD398: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 828AD39C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD3A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD3A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD3A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD3AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD3B0: 4E800421  bctrl
	ctx.lr = 0x828AD3B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD3B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD3B8: 48546071  bl 0x82df3428
	ctx.lr = 0x828AD3BC;
	sub_82DF3428(ctx, base);
	// 828AD3BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD3C0: 48546069  bl 0x82df3428
	ctx.lr = 0x828AD3C4;
	sub_82DF3428(ctx, base);
	// 828AD3C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD3C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD3CC: 388BA764  addi r4, r11, -0x589c
	ctx.r[4].s64 = ctx.r[11].s64 + -22684;
	// 828AD3D0: 48546639  bl 0x82df3a08
	ctx.lr = 0x828AD3D4;
	sub_82DF3A08(ctx, base);
	// 828AD3D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD3D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD3DC: 388BA750  addi r4, r11, -0x58b0
	ctx.r[4].s64 = ctx.r[11].s64 + -22704;
	// 828AD3E0: 48546629  bl 0x82df3a08
	ctx.lr = 0x828AD3E4;
	sub_82DF3A08(ctx, base);
	// 828AD3E4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD3E8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD3EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD3F0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD3F4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD3F8: 419A0024  beq cr6, 0x828ad41c
	if ctx.cr[6].eq {
	pc = 0x828AD41C; continue 'dispatch;
	}
	// 828AD3FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD400: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD404: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD408: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD40C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD410: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD414: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD418: 4082FFE8  bne 0x828ad400
	if !ctx.cr[0].eq {
	pc = 0x828AD400; continue 'dispatch;
	}
	// 828AD41C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 828AD420: 387F0098  addi r3, r31, 0x98
	ctx.r[3].s64 = ctx.r[31].s64 + 152;
	// 828AD424: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD428: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD42C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD430: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD438: 4E800421  bctrl
	ctx.lr = 0x828AD43C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD43C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD440: 48545FE9  bl 0x82df3428
	ctx.lr = 0x828AD444;
	sub_82DF3428(ctx, base);
	// 828AD444: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD448: 48545FE1  bl 0x82df3428
	ctx.lr = 0x828AD44C;
	sub_82DF3428(ctx, base);
	// 828AD44C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD454: 388BA740  addi r4, r11, -0x58c0
	ctx.r[4].s64 = ctx.r[11].s64 + -22720;
	// 828AD458: 485465B1  bl 0x82df3a08
	ctx.lr = 0x828AD45C;
	sub_82DF3A08(ctx, base);
	// 828AD45C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD460: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD464: 388BA730  addi r4, r11, -0x58d0
	ctx.r[4].s64 = ctx.r[11].s64 + -22736;
	// 828AD468: 485465A1  bl 0x82df3a08
	ctx.lr = 0x828AD46C;
	sub_82DF3A08(ctx, base);
	// 828AD46C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD470: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD478: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD47C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD480: 419A0024  beq cr6, 0x828ad4a4
	if ctx.cr[6].eq {
	pc = 0x828AD4A4; continue 'dispatch;
	}
	// 828AD484: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD488: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD48C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD490: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD494: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD498: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD49C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD4A0: 4082FFE8  bne 0x828ad488
	if !ctx.cr[0].eq {
	pc = 0x828AD488; continue 'dispatch;
	}
	// 828AD4A4: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 828AD4A8: 387F00BC  addi r3, r31, 0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + 188;
	// 828AD4AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD4B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD4B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD4B8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD4BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD4C0: 4E800421  bctrl
	ctx.lr = 0x828AD4C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD4C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD4C8: 48545F61  bl 0x82df3428
	ctx.lr = 0x828AD4CC;
	sub_82DF3428(ctx, base);
	// 828AD4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD4D0: 48545F59  bl 0x82df3428
	ctx.lr = 0x828AD4D4;
	sub_82DF3428(ctx, base);
	// 828AD4D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD4D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD4DC: 388BA718  addi r4, r11, -0x58e8
	ctx.r[4].s64 = ctx.r[11].s64 + -22760;
	// 828AD4E0: 48546529  bl 0x82df3a08
	ctx.lr = 0x828AD4E4;
	sub_82DF3A08(ctx, base);
	// 828AD4E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD4E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD4EC: 388BA704  addi r4, r11, -0x58fc
	ctx.r[4].s64 = ctx.r[11].s64 + -22780;
	// 828AD4F0: 48546519  bl 0x82df3a08
	ctx.lr = 0x828AD4F4;
	sub_82DF3A08(ctx, base);
	// 828AD4F4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD4F8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD4FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD500: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD504: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD508: 419A0024  beq cr6, 0x828ad52c
	if ctx.cr[6].eq {
	pc = 0x828AD52C; continue 'dispatch;
	}
	// 828AD50C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD510: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD518: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD51C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD520: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD524: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD528: 4082FFE8  bne 0x828ad510
	if !ctx.cr[0].eq {
	pc = 0x828AD510; continue 'dispatch;
	}
	// 828AD52C: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 828AD530: 387F00E0  addi r3, r31, 0xe0
	ctx.r[3].s64 = ctx.r[31].s64 + 224;
	// 828AD534: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD538: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD53C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD540: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD548: 4E800421  bctrl
	ctx.lr = 0x828AD54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD54C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD550: 48545ED9  bl 0x82df3428
	ctx.lr = 0x828AD554;
	sub_82DF3428(ctx, base);
	// 828AD554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD558: 48545ED1  bl 0x82df3428
	ctx.lr = 0x828AD55C;
	sub_82DF3428(ctx, base);
	// 828AD55C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD564: 388BA6F0  addi r4, r11, -0x5910
	ctx.r[4].s64 = ctx.r[11].s64 + -22800;
	// 828AD568: 485464A1  bl 0x82df3a08
	ctx.lr = 0x828AD56C;
	sub_82DF3A08(ctx, base);
	// 828AD56C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828AD570: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD574: 388B5F08  addi r4, r11, 0x5f08
	ctx.r[4].s64 = ctx.r[11].s64 + 24328;
	// 828AD578: 48546491  bl 0x82df3a08
	ctx.lr = 0x828AD57C;
	sub_82DF3A08(ctx, base);
	// 828AD57C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD580: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 828AD584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD588: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AD58C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828AD590: 419A0024  beq cr6, 0x828ad5b4
	if ctx.cr[6].eq {
	pc = 0x828AD5B4; continue 'dispatch;
	}
	// 828AD594: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD598: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD59C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD5A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD5A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD5A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD5AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD5B0: 4082FFE8  bne 0x828ad598
	if !ctx.cr[0].eq {
	pc = 0x828AD598; continue 'dispatch;
	}
	// 828AD5B4: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 828AD5B8: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 828AD5BC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 828AD5C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828AD5C4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828AD5C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD5CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD5D0: 4E800421  bctrl
	ctx.lr = 0x828AD5D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD5D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AD5D8: 48545E51  bl 0x82df3428
	ctx.lr = 0x828AD5DC;
	sub_82DF3428(ctx, base);
	// 828AD5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD5E0: 48545E49  bl 0x82df3428
	ctx.lr = 0x828AD5E4;
	sub_82DF3428(ctx, base);
	// 828AD5E4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828AD5E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AD5EC: 419A0008  beq cr6, 0x828ad5f4
	if ctx.cr[6].eq {
	pc = 0x828AD5F4; continue 'dispatch;
	}
	// 828AD5F0: 4BA132A1  bl 0x822c0890
	ctx.lr = 0x828AD5F4;
	sub_822C0890(ctx, base);
	// 828AD5F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD5F8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD5FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD600: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828AD604: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828AD608: 419A0024  beq cr6, 0x828ad62c
	if ctx.cr[6].eq {
	pc = 0x828AD62C; continue 'dispatch;
	}
	// 828AD60C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD610: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD614: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD618: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD61C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD620: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD624: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD628: 4082FFE8  bne 0x828ad610
	if !ctx.cr[0].eq {
	pc = 0x828AD610; continue 'dispatch;
	}
	// 828AD62C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AD630: 387F0398  addi r3, r31, 0x398
	ctx.r[3].s64 = ctx.r[31].s64 + 920;
	// 828AD634: 480ADBF5  bl 0x8295b228
	ctx.lr = 0x828AD638;
	sub_8295B228(ctx, base);
	// 828AD638: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AD63C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AD644: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828AD648: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828AD64C: 419A0024  beq cr6, 0x828ad670
	if ctx.cr[6].eq {
	pc = 0x828AD670; continue 'dispatch;
	}
	// 828AD650: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AD654: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AD658: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD65C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AD660: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AD664: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AD668: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AD66C: 4082FFE8  bne 0x828ad654
	if !ctx.cr[0].eq {
	pc = 0x828AD654; continue 'dispatch;
	}
	// 828AD670: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828AD674: 387F03A4  addi r3, r31, 0x3a4
	ctx.r[3].s64 = ctx.r[31].s64 + 932;
	// 828AD678: 480ADB01  bl 0x8295b178
	ctx.lr = 0x828AD67C;
	sub_8295B178(ctx, base);
	// 828AD67C: 382102E0  addi r1, r1, 0x2e0
	ctx.r[1].s64 = ctx.r[1].s64 + 736;
	// 828AD680: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 828AD684: 488FB441  bl 0x831a8ac4
	ctx.lr = 0x828AD688;
	sub_831A8A8C(ctx, base);
	// 828AD688: 488FAB24  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AD690 size=72
    let mut pc: u32 = 0x828AD690;
    'dispatch: loop {
        match pc {
            0x828AD690 => {
    //   block [0x828AD690..0x828AD6D8)
	// 828AD690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD698: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD69C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD6A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD6A4: 485AF285  bl 0x82e5c928
	ctx.lr = 0x828AD6A8;
	sub_82E5C928(ctx, base);
	// 828AD6A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AD6AC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AD6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD6B4: 394AAA9C  addi r10, r10, -0x5564
	ctx.r[10].s64 = ctx.r[10].s64 + -21860;
	// 828AD6B8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AD6BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AD6C0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828AD6C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AD6C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD6CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD6D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD6D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AD6D8 size=100
    let mut pc: u32 = 0x828AD6D8;
    'dispatch: loop {
        match pc {
            0x828AD6D8 => {
    //   block [0x828AD6D8..0x828AD73C)
	// 828AD6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD6E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AD6E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD6E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD6EC: 488A6F15  bl 0x83154600
	ctx.lr = 0x828AD6F0;
	sub_83154600(ctx, base);
	// 828AD6F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AD6F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD6F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AD6FC: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD700: 4BF42151  bl 0x827ef850
	ctx.lr = 0x828AD704;
	sub_827EF850(ctx, base);
	// 828AD704: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828AD708: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 828AD70C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AD710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AD714: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AD718: C02B029C  lfs f1, 0x29c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AD71C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 828AD720: 4E800421  bctrl
	ctx.lr = 0x828AD724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD724: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AD728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD72C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD730: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AD734: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD740 size=60
    let mut pc: u32 = 0x828AD740;
    'dispatch: loop {
        match pc {
            0x828AD740 => {
    //   block [0x828AD740..0x828AD77C)
	// 828AD740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD74C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD754: 4BFFFF3D  bl 0x828ad690
	ctx.lr = 0x828AD758;
	sub_828AD690(ctx, base);
	// 828AD758: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD760: 396BAAC4  addi r11, r11, -0x553c
	ctx.r[11].s64 = ctx.r[11].s64 + -21820;
	// 828AD764: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AD768: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AD76C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AD780 size=168
    let mut pc: u32 = 0x828AD780;
    'dispatch: loop {
        match pc {
            0x828AD780 => {
    //   block [0x828AD780..0x828AD828)
	// 828AD780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD784: 488FA9E5  bl 0x831a8168
	ctx.lr = 0x828AD788;
	sub_831A8130(ctx, base);
	// 828AD788: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD78C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AD790: 488A6E71  bl 0x83154600
	ctx.lr = 0x828AD794;
	sub_83154600(ctx, base);
	// 828AD794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD798: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD79C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AD7A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD7A4: 4E800421  bctrl
	ctx.lr = 0x828AD7A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD7A8: 3FC0832C  lis r30, -0x7cd4
	ctx.r[30].s64 = -2094268416;
	// 828AD7AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AD7B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD7B4: 809E14B4  lwz r4, 0x14b4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828AD7B8: 48546251  bl 0x82df3a08
	ctx.lr = 0x828AD7BC;
	sub_82DF3A08(ctx, base);
	// 828AD7BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AD7C0: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828AD7C4: 4BF3CAE5  bl 0x827ea2a8
	ctx.lr = 0x828AD7C8;
	sub_827EA2A8(ctx, base);
	// 828AD7C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AD7CC: 48545AD5  bl 0x82df32a0
	ctx.lr = 0x828AD7D0;
	sub_82DF32A0(ctx, base);
	// 828AD7D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AD7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD7D8: 48545C51  bl 0x82df3428
	ctx.lr = 0x828AD7DC;
	sub_82DF3428(ctx, base);
	// 828AD7DC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AD7E0: 41820030  beq 0x828ad810
	if ctx.cr[0].eq {
	pc = 0x828AD810; continue 'dispatch;
	}
	// 828AD7E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD7E8: 809E14B4  lwz r4, 0x14b4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828AD7EC: 4854621D  bl 0x82df3a08
	ctx.lr = 0x828AD7F0;
	sub_82DF3A08(ctx, base);
	// 828AD7F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD7F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD7FC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828AD800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD804: 4E800421  bctrl
	ctx.lr = 0x828AD808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD80C: 48545C1D  bl 0x82df3428
	ctx.lr = 0x828AD810;
	sub_82DF3428(ctx, base);
	// 828AD810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD814: 4BFFE705  bl 0x828abf18
	ctx.lr = 0x828AD818;
	sub_828ABF18(ctx, base);
	// 828AD818: C0030024  lfs f0, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AD81C: D01D0064  stfs f0, 0x64(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828AD820: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AD824: 488FA994  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AD828 size=96
    let mut pc: u32 = 0x828AD828;
    'dispatch: loop {
        match pc {
            0x828AD828 => {
    //   block [0x828AD828..0x828AD888)
	// 828AD828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD834: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD83C: 4BFFFE55  bl 0x828ad690
	ctx.lr = 0x828AD840;
	sub_828AD690(ctx, base);
	// 828AD840: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AD844: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828AD848: 396BAAEC  addi r11, r11, -0x5514
	ctx.r[11].s64 = ctx.r[11].s64 + -21780;
	// 828AD84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD850: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AD854: 808A0B30  lwz r4, 0xb30(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828AD858: 485461B1  bl 0x82df3a08
	ctx.lr = 0x828AD85C;
	sub_82DF3A08(ctx, base);
	// 828AD85C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD860: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD864: 485ABE85  bl 0x82e596e8
	ctx.lr = 0x828AD868;
	sub_82E596E8(ctx, base);
	// 828AD868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD86C: 48545BBD  bl 0x82df3428
	ctx.lr = 0x828AD870;
	sub_82DF3428(ctx, base);
	// 828AD870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AD878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AD87C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AD880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AD884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AD888 size=236
    let mut pc: u32 = 0x828AD888;
    'dispatch: loop {
        match pc {
            0x828AD888 => {
    //   block [0x828AD888..0x828AD974)
	// 828AD888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD88C: 488FA8E1  bl 0x831a816c
	ctx.lr = 0x828AD890;
	sub_831A8130(ctx, base);
	// 828AD890: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828AD894: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD898: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AD89C: 488A6D65  bl 0x83154600
	ctx.lr = 0x828AD8A0;
	sub_83154600(ctx, base);
	// 828AD8A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AD8A4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD8A8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AD8AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD8B0: 4E800421  bctrl
	ctx.lr = 0x828AD8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD8B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD8B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AD8BC: 4BFFE65D  bl 0x828abf18
	ctx.lr = 0x828AD8C0;
	sub_828ABF18(ctx, base);
	// 828AD8C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AD8C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD8C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD8CC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 828AD8D0: 419A0010  beq cr6, 0x828ad8e0
	if ctx.cr[6].eq {
	pc = 0x828AD8E0; continue 'dispatch;
	}
	// 828AD8D4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AD8D8: 808B1508  lwz r4, 0x1508(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5384 as u32) ) } as u64;
	// 828AD8DC: 4800000C  b 0x828ad8e8
	pc = 0x828AD8E8; continue 'dispatch;
	// 828AD8E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AD8E4: 808B14B4  lwz r4, 0x14b4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828AD8E8: 48546121  bl 0x82df3a08
	ctx.lr = 0x828AD8EC;
	sub_82DF3A08(ctx, base);
	// 828AD8EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD8F4: 4BF3CBED  bl 0x827ea4e0
	ctx.lr = 0x828AD8F8;
	sub_827EA4E0(ctx, base);
	// 828AD8F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD8FC: 48545B2D  bl 0x82df3428
	ctx.lr = 0x828AD900;
	sub_82DF3428(ctx, base);
	// 828AD900: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AD904: D01E0064  stfs f0, 0x64(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828AD908: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AD90C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD910: 808B14EC  lwz r4, 0x14ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5356 as u32) ) } as u64;
	// 828AD914: 485460F5  bl 0x82df3a08
	ctx.lr = 0x828AD918;
	sub_82DF3A08(ctx, base);
	// 828AD918: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD920: 4BF3CC79  bl 0x827ea598
	ctx.lr = 0x828AD924;
	sub_827EA598(ctx, base);
	// 828AD924: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828AD928: C3EB7BC4  lfs f31, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AD92C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AD930: 4830B141  bl 0x82bb8a70
	ctx.lr = 0x828AD934;
	sub_82BB8A70(ctx, base);
	// 828AD934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD938: 48545AF1  bl 0x82df3428
	ctx.lr = 0x828AD93C;
	sub_82DF3428(ctx, base);
	// 828AD93C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AD940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD944: 808B14F0  lwz r4, 0x14f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5360 as u32) ) } as u64;
	// 828AD948: 485460C1  bl 0x82df3a08
	ctx.lr = 0x828AD94C;
	sub_82DF3A08(ctx, base);
	// 828AD94C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD954: 4BF3CC45  bl 0x827ea598
	ctx.lr = 0x828AD958;
	sub_827EA598(ctx, base);
	// 828AD958: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AD95C: 4830B115  bl 0x82bb8a70
	ctx.lr = 0x828AD960;
	sub_82BB8A70(ctx, base);
	// 828AD960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD964: 48545AC5  bl 0x82df3428
	ctx.lr = 0x828AD968;
	sub_82DF3428(ctx, base);
	// 828AD968: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AD96C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828AD970: 488FA84C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AD978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AD978 size=164
    let mut pc: u32 = 0x828AD978;
    'dispatch: loop {
        match pc {
            0x828AD978 => {
    //   block [0x828AD978..0x828ADA1C)
	// 828AD978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AD97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AD980: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AD984: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828AD988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AD98C: 488A6C75  bl 0x83154600
	ctx.lr = 0x828AD990;
	sub_83154600(ctx, base);
	// 828AD990: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AD994: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AD998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AD99C: 4E800421  bctrl
	ctx.lr = 0x828AD9A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AD9A0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AD9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AD9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD9AC: 808B14EC  lwz r4, 0x14ec(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5356 as u32) ) } as u64;
	// 828AD9B0: 48546059  bl 0x82df3a08
	ctx.lr = 0x828AD9B4;
	sub_82DF3A08(ctx, base);
	// 828AD9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD9B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD9BC: 4BF3CBDD  bl 0x827ea598
	ctx.lr = 0x828AD9C0;
	sub_827EA598(ctx, base);
	// 828AD9C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AD9C4: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AD9C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AD9CC: 4830B0A5  bl 0x82bb8a70
	ctx.lr = 0x828AD9D0;
	sub_82BB8A70(ctx, base);
	// 828AD9D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD9D4: 48545A55  bl 0x82df3428
	ctx.lr = 0x828AD9D8;
	sub_82DF3428(ctx, base);
	// 828AD9D8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AD9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AD9E0: 808B14F0  lwz r4, 0x14f0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5360 as u32) ) } as u64;
	// 828AD9E4: 48546025  bl 0x82df3a08
	ctx.lr = 0x828AD9E8;
	sub_82DF3A08(ctx, base);
	// 828AD9E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AD9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AD9F0: 4BF3CBA9  bl 0x827ea598
	ctx.lr = 0x828AD9F4;
	sub_827EA598(ctx, base);
	// 828AD9F4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AD9F8: 4830B079  bl 0x82bb8a70
	ctx.lr = 0x828AD9FC;
	sub_82BB8A70(ctx, base);
	// 828AD9FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADA00: 48545A29  bl 0x82df3428
	ctx.lr = 0x828ADA04;
	sub_82DF3428(ctx, base);
	// 828ADA04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADA08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADA0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADA10: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828ADA14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADA18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADA20 size=96
    let mut pc: u32 = 0x828ADA20;
    'dispatch: loop {
        match pc {
            0x828ADA20 => {
    //   block [0x828ADA20..0x828ADA80)
	// 828ADA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADA28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADA2C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADA30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADA34: 4BFFFC5D  bl 0x828ad690
	ctx.lr = 0x828ADA38;
	sub_828AD690(ctx, base);
	// 828ADA38: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADA3C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828ADA40: 396BAB14  addi r11, r11, -0x54ec
	ctx.r[11].s64 = ctx.r[11].s64 + -21740;
	// 828ADA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADA48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADA4C: 808A1518  lwz r4, 0x1518(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5400 as u32) ) } as u64;
	// 828ADA50: 48545FB9  bl 0x82df3a08
	ctx.lr = 0x828ADA54;
	sub_82DF3A08(ctx, base);
	// 828ADA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADA58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADA5C: 485ABC8D  bl 0x82e596e8
	ctx.lr = 0x828ADA60;
	sub_82E596E8(ctx, base);
	// 828ADA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADA64: 485459C5  bl 0x82df3428
	ctx.lr = 0x828ADA68;
	sub_82DF3428(ctx, base);
	// 828ADA68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADA6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADA78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADA80 size=96
    let mut pc: u32 = 0x828ADA80;
    'dispatch: loop {
        match pc {
            0x828ADA80 => {
    //   block [0x828ADA80..0x828ADAE0)
	// 828ADA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADA88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADA8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADA90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADA94: 4BFFFBFD  bl 0x828ad690
	ctx.lr = 0x828ADA98;
	sub_828AD690(ctx, base);
	// 828ADA98: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADA9C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828ADAA0: 396BAB3C  addi r11, r11, -0x54c4
	ctx.r[11].s64 = ctx.r[11].s64 + -21700;
	// 828ADAA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADAA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADAAC: 808A151C  lwz r4, 0x151c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5404 as u32) ) } as u64;
	// 828ADAB0: 48545F59  bl 0x82df3a08
	ctx.lr = 0x828ADAB4;
	sub_82DF3A08(ctx, base);
	// 828ADAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADAB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADABC: 485ABC2D  bl 0x82e596e8
	ctx.lr = 0x828ADAC0;
	sub_82E596E8(ctx, base);
	// 828ADAC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADAC4: 48545965  bl 0x82df3428
	ctx.lr = 0x828ADAC8;
	sub_82DF3428(ctx, base);
	// 828ADAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADAD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADAE0 size=40
    let mut pc: u32 = 0x828ADAE0;
    'dispatch: loop {
        match pc {
            0x828ADAE0 => {
    //   block [0x828ADAE0..0x828ADB08)
	// 828ADAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADAE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADAE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADAEC: 488A6B15  bl 0x83154600
	ctx.lr = 0x828ADAF0;
	sub_83154600(ctx, base);
	// 828ADAF0: 4800B1F9  bl 0x828b8ce8
	ctx.lr = 0x828ADAF4;
	sub_828B8CE8(ctx, base);
	// 828ADAF4: 4BFF564D  bl 0x828a3140
	ctx.lr = 0x828ADAF8;
	sub_828A3140(ctx, base);
	// 828ADAF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828ADAFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADB00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADB04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADB08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADB08 size=96
    let mut pc: u32 = 0x828ADB08;
    'dispatch: loop {
        match pc {
            0x828ADB08 => {
    //   block [0x828ADB08..0x828ADB68)
	// 828ADB08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADB0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADB10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADB14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADB18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADB1C: 4BFFFB75  bl 0x828ad690
	ctx.lr = 0x828ADB20;
	sub_828AD690(ctx, base);
	// 828ADB20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADB24: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828ADB28: 396BAB64  addi r11, r11, -0x549c
	ctx.r[11].s64 = ctx.r[11].s64 + -21660;
	// 828ADB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADB30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADB34: 808A1520  lwz r4, 0x1520(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5408 as u32) ) } as u64;
	// 828ADB38: 48545ED1  bl 0x82df3a08
	ctx.lr = 0x828ADB3C;
	sub_82DF3A08(ctx, base);
	// 828ADB3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADB40: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADB44: 485ABBA5  bl 0x82e596e8
	ctx.lr = 0x828ADB48;
	sub_82E596E8(ctx, base);
	// 828ADB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADB4C: 485458DD  bl 0x82df3428
	ctx.lr = 0x828ADB50;
	sub_82DF3428(ctx, base);
	// 828ADB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADB54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADB58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADB5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADB60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADB64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADB68 size=96
    let mut pc: u32 = 0x828ADB68;
    'dispatch: loop {
        match pc {
            0x828ADB68 => {
    //   block [0x828ADB68..0x828ADBC8)
	// 828ADB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADB70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADB74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADB7C: 4BFFFB15  bl 0x828ad690
	ctx.lr = 0x828ADB80;
	sub_828AD690(ctx, base);
	// 828ADB80: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADB84: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828ADB88: 396BAB8C  addi r11, r11, -0x5474
	ctx.r[11].s64 = ctx.r[11].s64 + -21620;
	// 828ADB8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADB90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADB94: 808A1524  lwz r4, 0x1524(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5412 as u32) ) } as u64;
	// 828ADB98: 48545E71  bl 0x82df3a08
	ctx.lr = 0x828ADB9C;
	sub_82DF3A08(ctx, base);
	// 828ADB9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADBA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADBA4: 485ABB45  bl 0x82e596e8
	ctx.lr = 0x828ADBA8;
	sub_82E596E8(ctx, base);
	// 828ADBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADBAC: 4854587D  bl 0x82df3428
	ctx.lr = 0x828ADBB0;
	sub_82DF3428(ctx, base);
	// 828ADBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADBB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADBB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADBBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADBC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADBC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADBC8 size=192
    let mut pc: u32 = 0x828ADBC8;
    'dispatch: loop {
        match pc {
            0x828ADBC8 => {
    //   block [0x828ADBC8..0x828ADC88)
	// 828ADBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADBCC: 488FA59D  bl 0x831a8168
	ctx.lr = 0x828ADBD0;
	sub_831A8130(ctx, base);
	// 828ADBD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADBD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADBD8: 488A6A29  bl 0x83154600
	ctx.lr = 0x828ADBDC;
	sub_83154600(ctx, base);
	// 828ADBDC: 4800B10D  bl 0x828b8ce8
	ctx.lr = 0x828ADBE0;
	sub_828B8CE8(ctx, base);
	// 828ADBE0: 4BFF5561  bl 0x828a3140
	ctx.lr = 0x828ADBE4;
	sub_828A3140(ctx, base);
	// 828ADBE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADBE8: 488A6A19  bl 0x83154600
	ctx.lr = 0x828ADBEC;
	sub_83154600(ctx, base);
	// 828ADBEC: 4800B0FD  bl 0x828b8ce8
	ctx.lr = 0x828ADBF0;
	sub_828B8CE8(ctx, base);
	// 828ADBF0: 816303C4  lwz r11, 0x3c4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(964 as u32) ) } as u64;
	// 828ADBF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADBF8: 419A0088  beq cr6, 0x828adc80
	if ctx.cr[6].eq {
	pc = 0x828ADC80; continue 'dispatch;
	}
	// 828ADBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADC00: 488A6A01  bl 0x83154600
	ctx.lr = 0x828ADC04;
	sub_83154600(ctx, base);
	// 828ADC04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828ADC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADC0C: 488A69F5  bl 0x83154600
	ctx.lr = 0x828ADC10;
	sub_83154600(ctx, base);
	// 828ADC10: 4800B0D9  bl 0x828b8ce8
	ctx.lr = 0x828ADC14;
	sub_828B8CE8(ctx, base);
	// 828ADC14: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828ADC18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADC1C: 4BC618AD  bl 0x8250f4c8
	ctx.lr = 0x828ADC20;
	sub_8250F4C8(ctx, base);
	// 828ADC20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828ADC24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828ADC28: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 828ADC2C: 409A0008  bne cr6, 0x828adc34
	if !ctx.cr[6].eq {
	pc = 0x828ADC34; continue 'dispatch;
	}
	// 828ADC30: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828ADC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADC38: 488A69C9  bl 0x83154600
	ctx.lr = 0x828ADC3C;
	sub_83154600(ctx, base);
	// 828ADC3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828ADC40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828ADC44: 4800B0A5  bl 0x828b8ce8
	ctx.lr = 0x828ADC48;
	sub_828B8CE8(ctx, base);
	// 828ADC48: 83A303C4  lwz r29, 0x3c4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(964 as u32) ) } as u64;
	// 828ADC4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828ADC50: 4800B099  bl 0x828b8ce8
	ctx.lr = 0x828ADC54;
	sub_828B8CE8(ctx, base);
	// 828ADC54: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828ADC58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828ADC5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828ADC60: 4BF3E631  bl 0x827ec290
	ctx.lr = 0x828ADC64;
	sub_827EC290(ctx, base);
	// 828ADC64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADC68: 48544029  bl 0x82df1c90
	ctx.lr = 0x828ADC6C;
	sub_82DF1C90(ctx, base);
	// 828ADC6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADC70: 488A6991  bl 0x83154600
	ctx.lr = 0x828ADC74;
	sub_83154600(ctx, base);
	// 828ADC74: 4800B075  bl 0x828b8ce8
	ctx.lr = 0x828ADC78;
	sub_828B8CE8(ctx, base);
	// 828ADC78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828ADC7C: 916303C4  stw r11, 0x3c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(964 as u32), ctx.r[11].u32 ) };
	// 828ADC80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828ADC84: 488FA534  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADC88 size=96
    let mut pc: u32 = 0x828ADC88;
    'dispatch: loop {
        match pc {
            0x828ADC88 => {
    //   block [0x828ADC88..0x828ADCE8)
	// 828ADC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADC90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADC94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADC98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADC9C: 4BFFF9F5  bl 0x828ad690
	ctx.lr = 0x828ADCA0;
	sub_828AD690(ctx, base);
	// 828ADCA0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADCA4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828ADCA8: 396BABB4  addi r11, r11, -0x544c
	ctx.r[11].s64 = ctx.r[11].s64 + -21580;
	// 828ADCAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADCB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADCB4: 808A152C  lwz r4, 0x152c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5420 as u32) ) } as u64;
	// 828ADCB8: 48545D51  bl 0x82df3a08
	ctx.lr = 0x828ADCBC;
	sub_82DF3A08(ctx, base);
	// 828ADCBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADCC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADCC4: 485ABA25  bl 0x82e596e8
	ctx.lr = 0x828ADCC8;
	sub_82E596E8(ctx, base);
	// 828ADCC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADCCC: 4854575D  bl 0x82df3428
	ctx.lr = 0x828ADCD0;
	sub_82DF3428(ctx, base);
	// 828ADCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADCD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADCD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADCDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADCE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADCE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADCE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADCE8 size=96
    let mut pc: u32 = 0x828ADCE8;
    'dispatch: loop {
        match pc {
            0x828ADCE8 => {
    //   block [0x828ADCE8..0x828ADD48)
	// 828ADCE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADCEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADCF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADCF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADCF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADCFC: 4BFFF995  bl 0x828ad690
	ctx.lr = 0x828ADD00;
	sub_828AD690(ctx, base);
	// 828ADD00: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADD04: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828ADD08: 396BABDC  addi r11, r11, -0x5424
	ctx.r[11].s64 = ctx.r[11].s64 + -21540;
	// 828ADD0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADD10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADD14: 808A0B34  lwz r4, 0xb34(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2868 as u32) ) } as u64;
	// 828ADD18: 48545CF1  bl 0x82df3a08
	ctx.lr = 0x828ADD1C;
	sub_82DF3A08(ctx, base);
	// 828ADD1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADD20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADD24: 485AB9C5  bl 0x82e596e8
	ctx.lr = 0x828ADD28;
	sub_82E596E8(ctx, base);
	// 828ADD28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADD2C: 485456FD  bl 0x82df3428
	ctx.lr = 0x828ADD30;
	sub_82DF3428(ctx, base);
	// 828ADD30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADD34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADD38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADD3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADD40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADD44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADD48 size=96
    let mut pc: u32 = 0x828ADD48;
    'dispatch: loop {
        match pc {
            0x828ADD48 => {
    //   block [0x828ADD48..0x828ADDA8)
	// 828ADD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADD4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADD50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADD54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADD58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADD5C: 4BFFF935  bl 0x828ad690
	ctx.lr = 0x828ADD60;
	sub_828AD690(ctx, base);
	// 828ADD60: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADD64: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828ADD68: 396BAC04  addi r11, r11, -0x53fc
	ctx.r[11].s64 = ctx.r[11].s64 + -21500;
	// 828ADD6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADD70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADD74: 808A0B2C  lwz r4, 0xb2c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828ADD78: 48545C91  bl 0x82df3a08
	ctx.lr = 0x828ADD7C;
	sub_82DF3A08(ctx, base);
	// 828ADD7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADD80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADD84: 485AB965  bl 0x82e596e8
	ctx.lr = 0x828ADD88;
	sub_82E596E8(ctx, base);
	// 828ADD88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADD8C: 4854569D  bl 0x82df3428
	ctx.lr = 0x828ADD90;
	sub_82DF3428(ctx, base);
	// 828ADD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADD94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADD98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADD9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADDA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADDA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADDA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828ADDA8 size=96
    let mut pc: u32 = 0x828ADDA8;
    'dispatch: loop {
        match pc {
            0x828ADDA8 => {
    //   block [0x828ADDA8..0x828ADE08)
	// 828ADDA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADDAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828ADDB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828ADDB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828ADDB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828ADDBC: 4BFFF8D5  bl 0x828ad690
	ctx.lr = 0x828ADDC0;
	sub_828AD690(ctx, base);
	// 828ADDC0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828ADDC4: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828ADDC8: 396BAC2C  addi r11, r11, -0x53d4
	ctx.r[11].s64 = ctx.r[11].s64 + -21460;
	// 828ADDCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADDD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828ADDD4: 808A1530  lwz r4, 0x1530(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5424 as u32) ) } as u64;
	// 828ADDD8: 48545C31  bl 0x82df3a08
	ctx.lr = 0x828ADDDC;
	sub_82DF3A08(ctx, base);
	// 828ADDDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADDE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828ADDE4: 485AB905  bl 0x82e596e8
	ctx.lr = 0x828ADDE8;
	sub_82E596E8(ctx, base);
	// 828ADDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828ADDEC: 4854563D  bl 0x82df3428
	ctx.lr = 0x828ADDF0;
	sub_82DF3428(ctx, base);
	// 828ADDF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828ADDF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828ADDF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828ADDFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828ADE00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828ADE04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828ADE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828ADE08 size=1008
    let mut pc: u32 = 0x828ADE08;
    'dispatch: loop {
        match pc {
            0x828ADE08 => {
    //   block [0x828ADE08..0x828AE1F8)
	// 828ADE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828ADE0C: 488FA351  bl 0x831a815c
	ctx.lr = 0x828ADE10;
	sub_831A8130(ctx, base);
	// 828ADE10: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 828ADE14: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE1F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE1F8 size=196
    let mut pc: u32 = 0x828AE1F8;
    'dispatch: loop {
        match pc {
            0x828AE1F8 => {
    //   block [0x828AE1F8..0x828AE2BC)
	// 828AE1F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE1FC: 488F9F71  bl 0x831a816c
	ctx.lr = 0x828AE200;
	sub_831A8130(ctx, base);
	// 828AE200: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE208: 488A63F9  bl 0x83154600
	ctx.lr = 0x828AE20C;
	sub_83154600(ctx, base);
	// 828AE20C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE210: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AE214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE218: 4E800421  bctrl
	ctx.lr = 0x828AE21C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE21C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AE220: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE228: 808B1494  lwz r4, 0x1494(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5268 as u32) ) } as u64;
	// 828AE22C: 485457DD  bl 0x82df3a08
	ctx.lr = 0x828AE230;
	sub_82DF3A08(ctx, base);
	// 828AE230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE234: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828AE238: 4BF3C071  bl 0x827ea2a8
	ctx.lr = 0x828AE23C;
	sub_827EA2A8(ctx, base);
	// 828AE23C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AE240: 485450C9  bl 0x82df3308
	ctx.lr = 0x828AE244;
	sub_82DF3308(ctx, base);
	// 828AE244: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AE248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE24C: 485451DD  bl 0x82df3428
	ctx.lr = 0x828AE250;
	sub_82DF3428(ctx, base);
	// 828AE250: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE254: 41820060  beq 0x828ae2b4
	if ctx.cr[0].eq {
	pc = 0x828AE2B4; continue 'dispatch;
	}
	// 828AE258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE25C: 4BF3C0B5  bl 0x827ea310
	ctx.lr = 0x828AE260;
	sub_827EA310(ctx, base);
	// 828AE260: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE264: 41820050  beq 0x828ae2b4
	if ctx.cr[0].eq {
	pc = 0x828AE2B4; continue 'dispatch;
	}
	// 828AE268: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AE26C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE270: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828AE274: 48545795  bl 0x82df3a08
	ctx.lr = 0x828AE278;
	sub_82DF3A08(ctx, base);
	// 828AE278: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE280: 48759EA9  bl 0x83008128
	ctx.lr = 0x828AE284;
	sub_83008128(ctx, base);
	// 828AE284: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AE288: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AE28C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AE290: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AE294: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AE298: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AE29C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AE2A0: 485B06C1  bl 0x82e5e960
	ctx.lr = 0x828AE2A4;
	sub_82E5E960(ctx, base);
	// 828AE2A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AE2A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AE2AC: 419A0008  beq cr6, 0x828ae2b4
	if ctx.cr[6].eq {
	pc = 0x828AE2B4; continue 'dispatch;
	}
	// 828AE2B0: 4BA125E1  bl 0x822c0890
	ctx.lr = 0x828AE2B4;
	sub_822C0890(ctx, base);
	// 828AE2B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE2B8: 488F9F04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE2C0 size=168
    let mut pc: u32 = 0x828AE2C0;
    'dispatch: loop {
        match pc {
            0x828AE2C0 => {
    //   block [0x828AE2C0..0x828AE368)
	// 828AE2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE2C4: 488F9EA9  bl 0x831a816c
	ctx.lr = 0x828AE2C8;
	sub_831A8130(ctx, base);
	// 828AE2C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE2CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE2D0: 488A6331  bl 0x83154600
	ctx.lr = 0x828AE2D4;
	sub_83154600(ctx, base);
	// 828AE2D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE2D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AE2DC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AE2E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE2E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE2E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE2EC: 4E800421  bctrl
	ctx.lr = 0x828AE2F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE2F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AE2F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828AE2F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AE2FC: 4BFFDBCD  bl 0x828abec8
	ctx.lr = 0x828AE300;
	sub_828ABEC8(ctx, base);
	// 828AE300: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AE304: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AE308: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 828AE30C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828AE310: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE314: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE368 size=116
    let mut pc: u32 = 0x828AE368;
    'dispatch: loop {
        match pc {
            0x828AE368 => {
    //   block [0x828AE368..0x828AE3DC)
	// 828AE368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE36C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AE370: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AE374: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AE378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE37C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE380: 488A6281  bl 0x83154600
	ctx.lr = 0x828AE384;
	sub_83154600(ctx, base);
	// 828AE384: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE388: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE38C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE394: 4E800421  bctrl
	ctx.lr = 0x828AE398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE398: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828AE39C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828AE3A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE3A4: 995F0064  stb r10, 0x64(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[10].u8 ) };
	// 828AE3A8: C00BD1B8  lfs f0, -0x2e48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11848 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AE3AC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828AE3B0: 480683B9  bl 0x82916768
	ctx.lr = 0x828AE3B4;
	sub_82916768(ctx, base);
	// 828AE3B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AE3B8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828AE3BC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AE3C0: 480609B9  bl 0x8290ed78
	ctx.lr = 0x828AE3C4;
	sub_8290ED78(ctx, base);
	// 828AE3C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AE3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AE3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AE3D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AE3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AE3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE3E0 size=256
    let mut pc: u32 = 0x828AE3E0;
    'dispatch: loop {
        match pc {
            0x828AE3E0 => {
    //   block [0x828AE3E0..0x828AE4E0)
	// 828AE3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE3E4: 488F9D85  bl 0x831a8168
	ctx.lr = 0x828AE3E8;
	sub_831A8130(ctx, base);
	// 828AE3E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE3EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AE3F0: 488A6211  bl 0x83154600
	ctx.lr = 0x828AE3F4;
	sub_83154600(ctx, base);
	// 828AE3F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE3F8: 4800A8F1  bl 0x828b8ce8
	ctx.lr = 0x828AE3FC;
	sub_828B8CE8(ctx, base);
	// 828AE3FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE400: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AE404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE408: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AE40C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE410: 4E800421  bctrl
	ctx.lr = 0x828AE414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE414: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE418: 4BF3BEF1  bl 0x827ea308
	ctx.lr = 0x828AE41C;
	sub_827EA308(ctx, base);
	// 828AE41C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AE420: C00B9FFC  lfs f0, -0x6004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AE424: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828AE428: 4099000C  ble cr6, 0x828ae434
	if !ctx.cr[6].gt {
	pc = 0x828AE434; continue 'dispatch;
	}
	// 828AE42C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AE430: 4BFF6D39  bl 0x828a5168
	ctx.lr = 0x828AE434;
	sub_828A5168(ctx, base);
	// 828AE434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE438: 4BF3BED9  bl 0x827ea310
	ctx.lr = 0x828AE43C;
	sub_827EA310(ctx, base);
	// 828AE43C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE440: 40820014  bne 0x828ae454
	if !ctx.cr[0].eq {
	pc = 0x828AE454; continue 'dispatch;
	}
	// 828AE444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE448: 4BF3BED1  bl 0x827ea318
	ctx.lr = 0x828AE44C;
	sub_827EA318(ctx, base);
	// 828AE44C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE450: 41820088  beq 0x828ae4d8
	if ctx.cr[0].eq {
	pc = 0x828AE4D8; continue 'dispatch;
	}
	// 828AE454: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AE458: C1BC0060  lfs f13, 0x60(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AE45C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AE460: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828AE464: 40980060  bge cr6, 0x828ae4c4
	if !ctx.cr[6].lt {
	pc = 0x828AE4C4; continue 'dispatch;
	}
	// 828AE468: 897C0064  lbz r11, 0x64(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AE46C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AE470: 4082004C  bne 0x828ae4bc
	if !ctx.cr[0].eq {
	pc = 0x828AE4BC; continue 'dispatch;
	}
	// 828AE474: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	// 828AE478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE47C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AE480: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828AE484: 4BF3E145  bl 0x827ec5c8
	ctx.lr = 0x828AE488;
	sub_827EC5C8(ctx, base);
	// 828AE488: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 828AE48C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828AE490: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828AE494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE498: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 828AE49C: 4BC61D55  bl 0x825101f0
	ctx.lr = 0x828AE4A0;
	sub_825101F0(ctx, base);
	// 828AE4A0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828AE4A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AE4A8: 419A0008  beq cr6, 0x828ae4b0
	if ctx.cr[6].eq {
	pc = 0x828AE4B0; continue 'dispatch;
	}
	// 828AE4AC: 4BA123E5  bl 0x822c0890
	ctx.lr = 0x828AE4B0;
	sub_822C0890(ctx, base);
	// 828AE4B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE4B4: 4BFFDB0D  bl 0x828abfc0
	ctx.lr = 0x828AE4B8;
	sub_828ABFC0(ctx, base);
	// 828AE4B8: 9BBC0064  stb r29, 0x64(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[29].u8 ) };
	// 828AE4BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE4C0: 4800A889  bl 0x828b8d48
	ctx.lr = 0x828AE4C4;
	sub_828B8D48(ctx, base);
	// 828AE4C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AE4C8: 485AB2B1  bl 0x82e59778
	ctx.lr = 0x828AE4CC;
	sub_82E59778(ctx, base);
	// 828AE4CC: C01C0060  lfs f0, 0x60(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AE4D0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828AE4D4: D01C0060  stfs f0, 0x60(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828AE4D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE4DC: 488F9CDC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE4E0 size=172
    let mut pc: u32 = 0x828AE4E0;
    'dispatch: loop {
        match pc {
            0x828AE4E0 => {
    //   block [0x828AE4E0..0x828AE58C)
	// 828AE4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AE4E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AE4EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AE4F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828AE4F4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE4F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE4FC: 488A6105  bl 0x83154600
	ctx.lr = 0x828AE500;
	sub_83154600(ctx, base);
	// 828AE500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE504: 485AB265  bl 0x82e59768
	ctx.lr = 0x828AE508;
	sub_82E59768(ctx, base);
	// 828AE508: C01F0064  lfs f0, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AE50C: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828AE510: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AE514: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 828AE518: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828AE51C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AE520: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828AE524: 4098004C  bge cr6, 0x828ae570
	if !ctx.cr[6].lt {
	pc = 0x828AE570; continue 'dispatch;
	}
	// 828AE528: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AE52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE530: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828AE534: 485454D5  bl 0x82df3a08
	ctx.lr = 0x828AE538;
	sub_82DF3A08(ctx, base);
	// 828AE538: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE540: 48759BE9  bl 0x83008128
	ctx.lr = 0x828AE544;
	sub_83008128(ctx, base);
	// 828AE544: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AE548: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AE54C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AE550: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828AE554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AE558: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AE55C: 485B0405  bl 0x82e5e960
	ctx.lr = 0x828AE560;
	sub_82E5E960(ctx, base);
	// 828AE560: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AE564: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AE568: 419A0008  beq cr6, 0x828ae570
	if ctx.cr[6].eq {
	pc = 0x828AE570; continue 'dispatch;
	}
	// 828AE56C: 4BA12325  bl 0x822c0890
	ctx.lr = 0x828AE570;
	sub_822C0890(ctx, base);
	// 828AE570: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE574: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AE578: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AE57C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828AE580: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AE584: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AE588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AE590 size=108
    let mut pc: u32 = 0x828AE590;
    'dispatch: loop {
        match pc {
            0x828AE590 => {
    //   block [0x828AE590..0x828AE5FC)
	// 828AE590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AE598: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AE59C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE5A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE5A4: 4BFFF0ED  bl 0x828ad690
	ctx.lr = 0x828AE5A8;
	sub_828AD690(ctx, base);
	// 828AE5A8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AE5AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AE5B0: 394AAC64  addi r10, r10, -0x539c
	ctx.r[10].s64 = ctx.r[10].s64 + -21404;
	// 828AE5B4: 3D20832C  lis r9, -0x7cd4
	ctx.r[9].s64 = -2094268416;
	// 828AE5B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828AE5BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE5C0: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828AE5C4: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828AE5C8: 80891528  lwz r4, 0x1528(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5416 as u32) ) } as u64;
	// 828AE5CC: 4854543D  bl 0x82df3a08
	ctx.lr = 0x828AE5D0;
	sub_82DF3A08(ctx, base);
	// 828AE5D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE5D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AE5D8: 485AB111  bl 0x82e596e8
	ctx.lr = 0x828AE5DC;
	sub_82E596E8(ctx, base);
	// 828AE5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE5E0: 48544E49  bl 0x82df3428
	ctx.lr = 0x828AE5E4;
	sub_82DF3428(ctx, base);
	// 828AE5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE5E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AE5EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AE5F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AE5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AE5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE600 size=176
    let mut pc: u32 = 0x828AE600;
    'dispatch: loop {
        match pc {
            0x828AE600 => {
    //   block [0x828AE600..0x828AE6B0)
	// 828AE600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE604: 488F9B69  bl 0x831a816c
	ctx.lr = 0x828AE608;
	sub_831A8130(ctx, base);
	// 828AE608: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE60C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE610: 488A5FF1  bl 0x83154600
	ctx.lr = 0x828AE614;
	sub_83154600(ctx, base);
	// 828AE614: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AE618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE61C: 388B147C  addi r4, r11, 0x147c
	ctx.r[4].s64 = ctx.r[11].s64 + 5244;
	// 828AE620: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AE624: 4BFB4A7D  bl 0x828630a0
	ctx.lr = 0x828AE628;
	sub_828630A0(ctx, base);
	// 828AE628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE62C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AE630: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AE638: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AE63C: 419A0024  beq cr6, 0x828ae660
	if ctx.cr[6].eq {
	pc = 0x828AE660; continue 'dispatch;
	}
	// 828AE640: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AE644: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AE648: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE64C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AE650: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AE654: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AE658: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AE65C: 4082FFE8  bne 0x828ae644
	if !ctx.cr[0].eq {
	pc = 0x828AE644; continue 'dispatch;
	}
	// 828AE660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE664: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828AE668: 4BF3F1B9  bl 0x827ed820
	ctx.lr = 0x828AE66C;
	sub_827ED820(ctx, base);
	// 828AE66C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AE670: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AE674: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AE678: 388AAC88  addi r4, r10, -0x5378
	ctx.r[4].s64 = ctx.r[10].s64 + -21368;
	// 828AE67C: 38A000ED  li r5, 0xed
	ctx.r[5].s64 = 237;
	// 828AE680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE684: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AE688: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828AE68C: 4BF414CD  bl 0x827efb58
	ctx.lr = 0x828AE690;
	sub_827EFB58(ctx, base);
	// 828AE690: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AE694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AE698: 419A0008  beq cr6, 0x828ae6a0
	if ctx.cr[6].eq {
	pc = 0x828AE6A0; continue 'dispatch;
	}
	// 828AE69C: 4BA121F5  bl 0x822c0890
	ctx.lr = 0x828AE6A0;
	sub_822C0890(ctx, base);
	// 828AE6A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AE6A4: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AE6A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AE6AC: 488F9B10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AE6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AE6B0 size=1240
    let mut pc: u32 = 0x828AE6B0;
    'dispatch: loop {
        match pc {
            0x828AE6B0 => {
    //   block [0x828AE6B0..0x828AEB88)
	// 828AE6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AE6B4: 488F9AB5  bl 0x831a8168
	ctx.lr = 0x828AE6B8;
	sub_831A8130(ctx, base);
	// 828AE6B8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828AE6BC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AE6C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE6C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AE6C8: 488A5F39  bl 0x83154600
	ctx.lr = 0x828AE6CC;
	sub_83154600(ctx, base);
	// 828AE6CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE6D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE6D4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AE6D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE6DC: 4E800421  bctrl
	ctx.lr = 0x828AE6E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE6E0: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AE6E4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AE6E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828AE6EC: 41980058  blt cr6, 0x828ae744
	if ctx.cr[6].lt {
	pc = 0x828AE744; continue 'dispatch;
	}
	// 828AE6F0: 409A048C  bne cr6, 0x828aeb7c
	if !ctx.cr[6].eq {
	pc = 0x828AEB7C; continue 'dispatch;
	}
	// 828AE6F4: 4BF3BC1D  bl 0x827ea310
	ctx.lr = 0x828AE6F8;
	sub_827EA310(ctx, base);
	// 828AE6F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE6FC: 41820480  beq 0x828aeb7c
	if ctx.cr[0].eq {
	pc = 0x828AEB7C; continue 'dispatch;
	}
	// 828AE700: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AE704: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 828AE708: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828AE70C: 485452FD  bl 0x82df3a08
	ctx.lr = 0x828AE710;
	sub_82DF3A08(ctx, base);
	// 828AE710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AE714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AE718: 48759A11  bl 0x83008128
	ctx.lr = 0x828AE71C;
	sub_83008128(ctx, base);
	// 828AE71C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AE720: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AE724: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828AE728: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AE72C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AE730: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AE734: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AE738: 485B0229  bl 0x82e5e960
	ctx.lr = 0x828AE73C;
	sub_82E5E960(ctx, base);
	// 828AE73C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 828AE740: 48000430  b 0x828aeb70
	pc = 0x828AEB70; continue 'dispatch;
	// 828AE744: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AE748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE74C: 808B147C  lwz r4, 0x147c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5244 as u32) ) } as u64;
	// 828AE750: 485452B9  bl 0x82df3a08
	ctx.lr = 0x828AE754;
	sub_82DF3A08(ctx, base);
	// 828AE754: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AE758: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828AE75C: 4BF3BB4D  bl 0x827ea2a8
	ctx.lr = 0x828AE760;
	sub_827EA2A8(ctx, base);
	// 828AE760: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828AE764: 48544BA5  bl 0x82df3308
	ctx.lr = 0x828AE768;
	sub_82DF3308(ctx, base);
	// 828AE768: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE76C: 41820018  beq 0x828ae784
	if ctx.cr[0].eq {
	pc = 0x828AE784; continue 'dispatch;
	}
	// 828AE770: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AE774: 4BF3BB9D  bl 0x827ea310
	ctx.lr = 0x828AE778;
	sub_827EA310(ctx, base);
	// 828AE778: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AE77C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE780: 40820008  bne 0x828ae788
	if !ctx.cr[0].eq {
	pc = 0x828AE788; continue 'dispatch;
	}
	// 828AE784: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AE788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AE78C: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AE790: 48544C99  bl 0x82df3428
	ctx.lr = 0x828AE794;
	sub_82DF3428(ctx, base);
	// 828AE794: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AE798: 418203E4  beq 0x828aeb7c
	if ctx.cr[0].eq {
	pc = 0x828AEB7C; continue 'dispatch;
	}
	// 828AE79C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AE7A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AE7A4: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AE7A8: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 828AE7AC: 4BF410A5  bl 0x827ef850
	ctx.lr = 0x828AE7B0;
	sub_827EF850(ctx, base);
	// 828AE7B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AE7B4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828AE7B8: 4BF41139  bl 0x827ef8f0
	ctx.lr = 0x828AE7BC;
	sub_827EF8F0(ctx, base);
	// 828AE7BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AE7C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AE7C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AE7C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AE7CC: 4E800421  bctrl
	ctx.lr = 0x828AE7D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AE7D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AE7D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AE7D8: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828AE7DC: 4BFFD6ED  bl 0x828abec8
	ctx.lr = 0x828AE7E0;
	sub_828ABEC8(ctx, base);
	// 828AE7E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AE7E4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AE7E8: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 828AE7EC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 828AE7F0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828AE7F4: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEB88 size=188
    let mut pc: u32 = 0x828AEB88;
    'dispatch: loop {
        match pc {
            0x828AEB88 => {
    //   block [0x828AEB88..0x828AEC44)
	// 828AEB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEB8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AEB90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AEB94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AEB98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEB9C: 488A5A65  bl 0x83154600
	ctx.lr = 0x828AEBA0;
	sub_83154600(ctx, base);
	// 828AEBA0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AEBA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEBA8: 388B1494  addi r4, r11, 0x1494
	ctx.r[4].s64 = ctx.r[11].s64 + 5268;
	// 828AEBAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AEBB0: 4BFB44F1  bl 0x828630a0
	ctx.lr = 0x828AEBB4;
	sub_828630A0(ctx, base);
	// 828AEBB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEBB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AEBBC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AEBC4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AEBC8: 419A0024  beq cr6, 0x828aebec
	if ctx.cr[6].eq {
	pc = 0x828AEBEC; continue 'dispatch;
	}
	// 828AEBCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AEBD0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AEBD4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AEBD8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AEBDC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AEBE0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AEBE4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AEBE8: 4082FFE8  bne 0x828aebd0
	if !ctx.cr[0].eq {
	pc = 0x828AEBD0; continue 'dispatch;
	}
	// 828AEBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEBF0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828AEBF4: 4BF3EC2D  bl 0x827ed820
	ctx.lr = 0x828AEBF8;
	sub_827ED820(ctx, base);
	// 828AEBF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AEBFC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AEC00: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AEC04: 388AAC88  addi r4, r10, -0x5378
	ctx.r[4].s64 = ctx.r[10].s64 + -21368;
	// 828AEC08: 38A00167  li r5, 0x167
	ctx.r[5].s64 = 359;
	// 828AEC0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AEC10: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AEC14: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828AEC18: 4BF40F41  bl 0x827efb58
	ctx.lr = 0x828AEC1C;
	sub_827EFB58(ctx, base);
	// 828AEC1C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AEC20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AEC24: 419A0008  beq cr6, 0x828aec2c
	if ctx.cr[6].eq {
	pc = 0x828AEC2C; continue 'dispatch;
	}
	// 828AEC28: 4BA11C69  bl 0x822c0890
	ctx.lr = 0x828AEC2C;
	sub_822C0890(ctx, base);
	// 828AEC2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AEC30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AEC34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AEC38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AEC3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AEC40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AEC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AEC48 size=188
    let mut pc: u32 = 0x828AEC48;
    'dispatch: loop {
        match pc {
            0x828AEC48 => {
    //   block [0x828AEC48..0x828AED04)
	// 828AEC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AEC4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AEC50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AEC54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AEC58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AEC5C: 488A59A5  bl 0x83154600
	ctx.lr = 0x828AEC60;
	sub_83154600(ctx, base);
	// 828AEC60: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AEC64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AEC68: 388B1490  addi r4, r11, 0x1490
	ctx.r[4].s64 = ctx.r[11].s64 + 5264;
	// 828AEC6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AEC70: 4BFB4431  bl 0x828630a0
	ctx.lr = 0x828AEC74;
	sub_828630A0(ctx, base);
	// 828AEC74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AEC78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AEC7C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AEC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AEC84: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AEC88: 419A0024  beq cr6, 0x828aecac
	if ctx.cr[6].eq {
	pc = 0x828AECAC; continue 'dispatch;
	}
	// 828AEC8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AEC90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AEC94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AEC98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AEC9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AECA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AECA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AECA8: 4082FFE8  bne 0x828aec90
	if !ctx.cr[0].eq {
	pc = 0x828AEC90; continue 'dispatch;
	}
	// 828AECAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AECB0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828AECB4: 4BF3EB6D  bl 0x827ed820
	ctx.lr = 0x828AECB8;
	sub_827ED820(ctx, base);
	// 828AECB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AECBC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AECC0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AECC4: 388AAC88  addi r4, r10, -0x5378
	ctx.r[4].s64 = ctx.r[10].s64 + -21368;
	// 828AECC8: 38A0019D  li r5, 0x19d
	ctx.r[5].s64 = 413;
	// 828AECCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AECD0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AECD4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828AECD8: 4BF40E81  bl 0x827efb58
	ctx.lr = 0x828AECDC;
	sub_827EFB58(ctx, base);
	// 828AECDC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AECE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AECE4: 419A0008  beq cr6, 0x828aecec
	if ctx.cr[6].eq {
	pc = 0x828AECEC; continue 'dispatch;
	}
	// 828AECE8: 4BA11BA9  bl 0x822c0890
	ctx.lr = 0x828AECEC;
	sub_822C0890(ctx, base);
	// 828AECEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AECF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AECF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AECF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AECFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AED00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AED08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828AED08 size=1320
    let mut pc: u32 = 0x828AED08;
    'dispatch: loop {
        match pc {
            0x828AED08 => {
    //   block [0x828AED08..0x828AF230)
	// 828AED08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AED0C: 488F945D  bl 0x831a8168
	ctx.lr = 0x828AED10;
	sub_831A8130(ctx, base);
	// 828AED10: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828AED14: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF230 size=188
    let mut pc: u32 = 0x828AF230;
    'dispatch: loop {
        match pc {
            0x828AF230 => {
    //   block [0x828AF230..0x828AF2EC)
	// 828AF230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF234: 488F8F39  bl 0x831a816c
	ctx.lr = 0x828AF238;
	sub_831A8130(ctx, base);
	// 828AF238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF23C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AF240: 488A53C1  bl 0x83154600
	ctx.lr = 0x828AF244;
	sub_83154600(ctx, base);
	// 828AF244: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AF248: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF24C: 388B14C4  addi r4, r11, 0x14c4
	ctx.r[4].s64 = ctx.r[11].s64 + 5316;
	// 828AF250: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AF254: 4BFB3E4D  bl 0x828630a0
	ctx.lr = 0x828AF258;
	sub_828630A0(ctx, base);
	// 828AF258: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF25C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AF260: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF268: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AF26C: 419A0024  beq cr6, 0x828af290
	if ctx.cr[6].eq {
	pc = 0x828AF290; continue 'dispatch;
	}
	// 828AF270: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AF274: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AF278: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF27C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AF280: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AF284: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AF288: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF28C: 4082FFE8  bne 0x828af274
	if !ctx.cr[0].eq {
	pc = 0x828AF274; continue 'dispatch;
	}
	// 828AF290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF294: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828AF298: 4BF3E589  bl 0x827ed820
	ctx.lr = 0x828AF29C;
	sub_827ED820(ctx, base);
	// 828AF29C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AF2A0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AF2A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AF2A8: 388AAC88  addi r4, r10, -0x5378
	ctx.r[4].s64 = ctx.r[10].s64 + -21368;
	// 828AF2AC: 38A00232  li r5, 0x232
	ctx.r[5].s64 = 562;
	// 828AF2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF2B4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AF2B8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828AF2BC: 4BF4089D  bl 0x827efb58
	ctx.lr = 0x828AF2C0;
	sub_827EFB58(ctx, base);
	// 828AF2C0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AF2C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AF2C8: 419A0008  beq cr6, 0x828af2d0
	if ctx.cr[6].eq {
	pc = 0x828AF2D0; continue 'dispatch;
	}
	// 828AF2CC: 4BA115C5  bl 0x822c0890
	ctx.lr = 0x828AF2D0;
	sub_822C0890(ctx, base);
	// 828AF2D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828AF2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF2D8: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AF2DC: 48009A0D  bl 0x828b8ce8
	ctx.lr = 0x828AF2E0;
	sub_828B8CE8(ctx, base);
	// 828AF2E0: 4BFF4259  bl 0x828a3538
	ctx.lr = 0x828AF2E4;
	sub_828A3538(ctx, base);
	// 828AF2E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AF2E8: 488F8ED4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF2F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF2F0 size=1416
    let mut pc: u32 = 0x828AF2F0;
    'dispatch: loop {
        match pc {
            0x828AF2F0 => {
    //   block [0x828AF2F0..0x828AF878)
	// 828AF2F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF2F4: 488F8E6D  bl 0x831a8160
	ctx.lr = 0x828AF2F8;
	sub_831A8130(ctx, base);
	// 828AF2F8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 828AF2FC: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF300: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AF304: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 828AF308: 488A52F9  bl 0x83154600
	ctx.lr = 0x828AF30C;
	sub_83154600(ctx, base);
	// 828AF30C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF310: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF314: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AF318: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AF31C: 4E800421  bctrl
	ctx.lr = 0x828AF320;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF320: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AF324: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828AF328: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828AF32C: 41980108  blt cr6, 0x828af434
	if ctx.cr[6].lt {
	pc = 0x828AF434; continue 'dispatch;
	}
	// 828AF330: 409A053C  bne cr6, 0x828af86c
	if !ctx.cr[6].eq {
	pc = 0x828AF86C; continue 'dispatch;
	}
	// 828AF334: 4BF3AFD5  bl 0x827ea308
	ctx.lr = 0x828AF338;
	sub_827EA308(ctx, base);
	// 828AF338: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828AF33C: C00B89AC  lfs f0, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AF340: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828AF344: 4099009C  ble cr6, 0x828af3e0
	if !ctx.cr[6].gt {
	pc = 0x828AF3E0; continue 'dispatch;
	}
	// 828AF348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF34C: 488A52B5  bl 0x83154600
	ctx.lr = 0x828AF350;
	sub_83154600(ctx, base);
	// 828AF350: 48009999  bl 0x828b8ce8
	ctx.lr = 0x828AF354;
	sub_828B8CE8(ctx, base);
	// 828AF354: 816303C4  lwz r11, 0x3c4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(964 as u32) ) } as u64;
	// 828AF358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF35C: 419A0084  beq cr6, 0x828af3e0
	if ctx.cr[6].eq {
	pc = 0x828AF3E0; continue 'dispatch;
	}
	// 828AF360: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF364: 488A529D  bl 0x83154600
	ctx.lr = 0x828AF368;
	sub_83154600(ctx, base);
	// 828AF368: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828AF36C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF370: 488A5291  bl 0x83154600
	ctx.lr = 0x828AF374;
	sub_83154600(ctx, base);
	// 828AF374: 48009975  bl 0x828b8ce8
	ctx.lr = 0x828AF378;
	sub_828B8CE8(ctx, base);
	// 828AF378: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828AF37C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828AF380: 4BC60149  bl 0x8250f4c8
	ctx.lr = 0x828AF384;
	sub_8250F4C8(ctx, base);
	// 828AF384: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF38C: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 828AF390: 409A0008  bne cr6, 0x828af398
	if !ctx.cr[6].eq {
	pc = 0x828AF398; continue 'dispatch;
	}
	// 828AF394: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828AF398: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF39C: 488A5265  bl 0x83154600
	ctx.lr = 0x828AF3A0;
	sub_83154600(ctx, base);
	// 828AF3A0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 828AF3A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828AF3A8: 48009941  bl 0x828b8ce8
	ctx.lr = 0x828AF3AC;
	sub_828B8CE8(ctx, base);
	// 828AF3AC: 83A303C4  lwz r29, 0x3c4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(964 as u32) ) } as u64;
	// 828AF3B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828AF3B4: 48009935  bl 0x828b8ce8
	ctx.lr = 0x828AF3B8;
	sub_828B8CE8(ctx, base);
	// 828AF3B8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828AF3BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF3C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828AF3C4: 4BF3CECD  bl 0x827ec290
	ctx.lr = 0x828AF3C8;
	sub_827EC290(ctx, base);
	// 828AF3C8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 828AF3CC: 485428C5  bl 0x82df1c90
	ctx.lr = 0x828AF3D0;
	sub_82DF1C90(ctx, base);
	// 828AF3D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF3D4: 488A522D  bl 0x83154600
	ctx.lr = 0x828AF3D8;
	sub_83154600(ctx, base);
	// 828AF3D8: 48009911  bl 0x828b8ce8
	ctx.lr = 0x828AF3DC;
	sub_828B8CE8(ctx, base);
	// 828AF3DC: 936303C4  stw r27, 0x3c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(964 as u32), ctx.r[27].u32 ) };
	// 828AF3E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AF3E4: 4BF3AF2D  bl 0x827ea310
	ctx.lr = 0x828AF3E8;
	sub_827EA310(ctx, base);
	// 828AF3E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AF3EC: 41820480  beq 0x828af86c
	if ctx.cr[0].eq {
	pc = 0x828AF86C; continue 'dispatch;
	}
	// 828AF3F0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AF3F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 828AF3F8: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828AF3FC: 4854460D  bl 0x82df3a08
	ctx.lr = 0x828AF400;
	sub_82DF3A08(ctx, base);
	// 828AF400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AF408: 48758D21  bl 0x83008128
	ctx.lr = 0x828AF40C;
	sub_83008128(ctx, base);
	// 828AF40C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AF410: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828AF414: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 828AF418: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828AF41C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828AF420: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828AF424: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AF428: 485AF539  bl 0x82e5e960
	ctx.lr = 0x828AF42C;
	sub_82E5E960(ctx, base);
	// 828AF42C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 828AF430: 48000430  b 0x828af860
	pc = 0x828AF860; continue 'dispatch;
	// 828AF434: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AF438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AF43C: 808B14C4  lwz r4, 0x14c4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5316 as u32) ) } as u64;
	// 828AF440: 485445C9  bl 0x82df3a08
	ctx.lr = 0x828AF444;
	sub_82DF3A08(ctx, base);
	// 828AF444: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AF448: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828AF44C: 4BF3AE5D  bl 0x827ea2a8
	ctx.lr = 0x828AF450;
	sub_827EA2A8(ctx, base);
	// 828AF450: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828AF454: 48543EB5  bl 0x82df3308
	ctx.lr = 0x828AF458;
	sub_82DF3308(ctx, base);
	// 828AF458: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AF45C: 41820018  beq 0x828af474
	if ctx.cr[0].eq {
	pc = 0x828AF474; continue 'dispatch;
	}
	// 828AF460: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828AF464: 4BF3AEAD  bl 0x827ea310
	ctx.lr = 0x828AF468;
	sub_827EA310(ctx, base);
	// 828AF468: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AF46C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AF470: 40820008  bne 0x828af478
	if !ctx.cr[0].eq {
	pc = 0x828AF478; continue 'dispatch;
	}
	// 828AF474: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 828AF478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AF47C: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828AF480: 48543FA9  bl 0x82df3428
	ctx.lr = 0x828AF484;
	sub_82DF3428(ctx, base);
	// 828AF484: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828AF488: 418203E4  beq 0x828af86c
	if ctx.cr[0].eq {
	pc = 0x828AF86C; continue 'dispatch;
	}
	// 828AF48C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828AF490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF494: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828AF498: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828AF49C: 4BF403B5  bl 0x827ef850
	ctx.lr = 0x828AF4A0;
	sub_827EF850(ctx, base);
	// 828AF4A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF4A4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 828AF4A8: 4BF40449  bl 0x827ef8f0
	ctx.lr = 0x828AF4AC;
	sub_827EF8F0(ctx, base);
	// 828AF4AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF4B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF4B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AF4BC: 4E800421  bctrl
	ctx.lr = 0x828AF4C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF4C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AF4C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF4C8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 828AF4CC: 4BFFC9FD  bl 0x828abec8
	ctx.lr = 0x828AF4D0;
	sub_828ABEC8(ctx, base);
	// 828AF4D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828AF4D4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AF4D8: 394100F0  addi r10, r1, 0xf0
	ctx.r[10].s64 = ctx.r[1].s64 + 240;
	// 828AF4DC: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 828AF4E0: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 828AF4E4: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF878 size=188
    let mut pc: u32 = 0x828AF878;
    'dispatch: loop {
        match pc {
            0x828AF878 => {
    //   block [0x828AF878..0x828AF934)
	// 828AF878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AF880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AF884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AF888: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF88C: 488A4D75  bl 0x83154600
	ctx.lr = 0x828AF890;
	sub_83154600(ctx, base);
	// 828AF890: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AF894: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF898: 388B14E4  addi r4, r11, 0x14e4
	ctx.r[4].s64 = ctx.r[11].s64 + 5348;
	// 828AF89C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AF8A0: 4BFB3801  bl 0x828630a0
	ctx.lr = 0x828AF8A4;
	sub_828630A0(ctx, base);
	// 828AF8A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF8A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AF8AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF8B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF8B4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AF8B8: 419A0024  beq cr6, 0x828af8dc
	if ctx.cr[6].eq {
	pc = 0x828AF8DC; continue 'dispatch;
	}
	// 828AF8BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AF8C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AF8C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF8C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AF8CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AF8D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AF8D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AF8D8: 4082FFE8  bne 0x828af8c0
	if !ctx.cr[0].eq {
	pc = 0x828AF8C0; continue 'dispatch;
	}
	// 828AF8DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF8E0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828AF8E4: 4BF3DF3D  bl 0x827ed820
	ctx.lr = 0x828AF8E8;
	sub_827ED820(ctx, base);
	// 828AF8E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AF8EC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828AF8F0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AF8F4: 388AAC88  addi r4, r10, -0x5378
	ctx.r[4].s64 = ctx.r[10].s64 + -21368;
	// 828AF8F8: 38A002B9  li r5, 0x2b9
	ctx.r[5].s64 = 697;
	// 828AF8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF900: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828AF904: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828AF908: 4BF40251  bl 0x827efb58
	ctx.lr = 0x828AF90C;
	sub_827EFB58(ctx, base);
	// 828AF90C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AF910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AF914: 419A0008  beq cr6, 0x828af91c
	if ctx.cr[6].eq {
	pc = 0x828AF91C; continue 'dispatch;
	}
	// 828AF918: 4BA10F79  bl 0x822c0890
	ctx.lr = 0x828AF91C;
	sub_822C0890(ctx, base);
	// 828AF91C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828AF920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AF924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AF928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828AF92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AF930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AF938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AF938 size=880
    let mut pc: u32 = 0x828AF938;
    'dispatch: loop {
        match pc {
            0x828AF938 => {
    //   block [0x828AF938..0x828AFCA8)
	// 828AF938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AF93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AF940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828AF944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AF948: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 828AF94C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828AF950: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AF954: 488A4CAD  bl 0x83154600
	ctx.lr = 0x828AF958;
	sub_83154600(ctx, base);
	// 828AF958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AF95C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828AF960: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AF964: 48067435  bl 0x82916d98
	ctx.lr = 0x828AF968;
	sub_82916D98(ctx, base);
	// 828AF968: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF96C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828AF970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AF974: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AF978: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AF97C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AF980: 4E800421  bctrl
	ctx.lr = 0x828AF984;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AF984: 394000E0  li r10, 0xe0
	ctx.r[10].s64 = 224;
	// 828AF988: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828AF98C: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 828AF990: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828AF994: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AF998: 13DE50C7  vcmpequd (lvx128) v30, v30, v10
	tmp.u32 = ctx.r[30].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AFCA8 size=292
    let mut pc: u32 = 0x828AFCA8;
    'dispatch: loop {
        match pc {
            0x828AFCA8 => {
    //   block [0x828AFCA8..0x828AFDCC)
	// 828AFCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFCAC: 488F84C1  bl 0x831a816c
	ctx.lr = 0x828AFCB0;
	sub_831A8130(ctx, base);
	// 828AFCB0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828AFCB4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFCB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828AFCBC: 488A4945  bl 0x83154600
	ctx.lr = 0x828AFCC0;
	sub_83154600(ctx, base);
	// 828AFCC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFCC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFCC8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AFCCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AFCD0: 4E800421  bctrl
	ctx.lr = 0x828AFCD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AFCD4: 4BF3A63D  bl 0x827ea310
	ctx.lr = 0x828AFCD8;
	sub_827EA310(ctx, base);
	// 828AFCD8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828AFCDC: 418200E4  beq 0x828afdc0
	if ctx.cr[0].eq {
	pc = 0x828AFDC0; continue 'dispatch;
	}
	// 828AFCE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFCE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFCE8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 828AFCEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AFCF0: 4E800421  bctrl
	ctx.lr = 0x828AFCF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AFCF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AFCF8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828AFCFC: FF01F800  fcmpu cr6, f1, f31
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[31].f64);
	// 828AFD00: 41990094  bgt cr6, 0x828afd94
	if ctx.cr[6].gt {
	pc = 0x828AFD94; continue 'dispatch;
	}
	// 828AFD04: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AFD08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828AFD0C: 388B14AC  addi r4, r11, 0x14ac
	ctx.r[4].s64 = ctx.r[11].s64 + 5292;
	// 828AFD10: 4BFB3391  bl 0x828630a0
	ctx.lr = 0x828AFD14;
	sub_828630A0(ctx, base);
	// 828AFD14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFD18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828AFD1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828AFD20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828AFD24: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828AFD28: 419A0024  beq cr6, 0x828afd4c
	if ctx.cr[6].eq {
	pc = 0x828AFD4C; continue 'dispatch;
	}
	// 828AFD2C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828AFD30: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828AFD34: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFD38: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828AFD3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828AFD40: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828AFD44: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828AFD48: 4082FFE8  bne 0x828afd30
	if !ctx.cr[0].eq {
	pc = 0x828AFD30; continue 'dispatch;
	}
	// 828AFD4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFD50: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828AFD54: 4BF3DACD  bl 0x827ed820
	ctx.lr = 0x828AFD58;
	sub_827ED820(ctx, base);
	// 828AFD58: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AFD5C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828AFD60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828AFD64: 388BAC88  addi r4, r11, -0x5378
	ctx.r[4].s64 = ctx.r[11].s64 + -21368;
	// 828AFD68: 38A0030D  li r5, 0x30d
	ctx.r[5].s64 = 781;
	// 828AFD6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFD70: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828AFD74: 4BF3FDE5  bl 0x827efb58
	ctx.lr = 0x828AFD78;
	sub_827EFB58(ctx, base);
	// 828AFD78: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828AFD7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828AFD80: 419A0008  beq cr6, 0x828afd88
	if ctx.cr[6].eq {
	pc = 0x828AFD88; continue 'dispatch;
	}
	// 828AFD84: 4BA10B0D  bl 0x822c0890
	ctx.lr = 0x828AFD88;
	sub_822C0890(ctx, base);
	// 828AFD88: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AFD8C: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828AFD90: 4800000C  b 0x828afd9c
	pc = 0x828AFD9C; continue 'dispatch;
	// 828AFD94: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828AFD98: 808B0B24  lwz r4, 0xb24(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828AFD9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFDA0: 48543C69  bl 0x82df3a08
	ctx.lr = 0x828AFDA4;
	sub_82DF3A08(ctx, base);
	// 828AFDA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828AFDA8: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828AFDAC: 488A4855  bl 0x83154600
	ctx.lr = 0x828AFDB0;
	sub_83154600(ctx, base);
	// 828AFDB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828AFDB4: 4BF3F98D  bl 0x827ef740
	ctx.lr = 0x828AFDB8;
	sub_827EF740(ctx, base);
	// 828AFDB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFDBC: 4854366D  bl 0x82df3428
	ctx.lr = 0x828AFDC0;
	sub_82DF3428(ctx, base);
	// 828AFDC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828AFDC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828AFDC8: 488F83F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFDD0 size=96
    let mut pc: u32 = 0x828AFDD0;
    'dispatch: loop {
        match pc {
            0x828AFDD0 => {
    //   block [0x828AFDD0..0x828AFE30)
	// 828AFDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFDD8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFDDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFDE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFDE4: 4BFFD8AD  bl 0x828ad690
	ctx.lr = 0x828AFDE8;
	sub_828AD690(ctx, base);
	// 828AFDE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AFDEC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 828AFDF0: 396BAD18  addi r11, r11, -0x52e8
	ctx.r[11].s64 = ctx.r[11].s64 + -21224;
	// 828AFDF4: 388ACFB0  addi r4, r10, -0x3050
	ctx.r[4].s64 = ctx.r[10].s64 + -12368;
	// 828AFDF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AFDFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFE00: 48543C09  bl 0x82df3a08
	ctx.lr = 0x828AFE04;
	sub_82DF3A08(ctx, base);
	// 828AFE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFE08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AFE0C: 485A98DD  bl 0x82e596e8
	ctx.lr = 0x828AFE10;
	sub_82E596E8(ctx, base);
	// 828AFE10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFE14: 48543615  bl 0x82df3428
	ctx.lr = 0x828AFE18;
	sub_82DF3428(ctx, base);
	// 828AFE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFE1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AFE20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFE24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFE28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFE2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AFE30 size=60
    let mut pc: u32 = 0x828AFE30;
    'dispatch: loop {
        match pc {
            0x828AFE30 => {
    //   block [0x828AFE30..0x828AFE6C)
	// 828AFE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFE38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFE3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFE40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFE44: 488A47BD  bl 0x83154600
	ctx.lr = 0x828AFE48;
	sub_83154600(ctx, base);
	// 828AFE48: 48008EA1  bl 0x828b8ce8
	ctx.lr = 0x828AFE4C;
	sub_828B8CE8(ctx, base);
	// 828AFE4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828AFE50: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828AFE54: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828AFE58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828AFE5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFE60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFE64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFE68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFE70 size=96
    let mut pc: u32 = 0x828AFE70;
    'dispatch: loop {
        match pc {
            0x828AFE70 => {
    //   block [0x828AFE70..0x828AFED0)
	// 828AFE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFE74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFE78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFE7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFE84: 4BFFD80D  bl 0x828ad690
	ctx.lr = 0x828AFE88;
	sub_828AD690(ctx, base);
	// 828AFE88: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AFE8C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828AFE90: 396BAD40  addi r11, r11, -0x52c0
	ctx.r[11].s64 = ctx.r[11].s64 + -21184;
	// 828AFE94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFE98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AFE9C: 808A1514  lwz r4, 0x1514(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5396 as u32) ) } as u64;
	// 828AFEA0: 48543B69  bl 0x82df3a08
	ctx.lr = 0x828AFEA4;
	sub_82DF3A08(ctx, base);
	// 828AFEA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFEA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AFEAC: 485A983D  bl 0x82e596e8
	ctx.lr = 0x828AFEB0;
	sub_82E596E8(ctx, base);
	// 828AFEB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFEB4: 48543575  bl 0x82df3428
	ctx.lr = 0x828AFEB8;
	sub_82DF3428(ctx, base);
	// 828AFEB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFEBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AFEC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFEC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFEC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFED0 size=96
    let mut pc: u32 = 0x828AFED0;
    'dispatch: loop {
        match pc {
            0x828AFED0 => {
    //   block [0x828AFED0..0x828AFF30)
	// 828AFED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFEDC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFEE0: 488A4721  bl 0x83154600
	ctx.lr = 0x828AFEE4;
	sub_83154600(ctx, base);
	// 828AFEE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828AFEE8: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828AFEEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828AFEF0: 4E800421  bctrl
	ctx.lr = 0x828AFEF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828AFEF4: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828AFEF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFEFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFF00: 808B14F4  lwz r4, 0x14f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5364 as u32) ) } as u64;
	// 828AFF04: 48543B05  bl 0x82df3a08
	ctx.lr = 0x828AFF08;
	sub_82DF3A08(ctx, base);
	// 828AFF08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AFF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFF10: 4BF3A5D1  bl 0x827ea4e0
	ctx.lr = 0x828AFF14;
	sub_827EA4E0(ctx, base);
	// 828AFF14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFF18: 48543511  bl 0x82df3428
	ctx.lr = 0x828AFF1C;
	sub_82DF3428(ctx, base);
	// 828AFF1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AFF20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFF24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFF28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFF2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFF30 size=96
    let mut pc: u32 = 0x828AFF30;
    'dispatch: loop {
        match pc {
            0x828AFF30 => {
    //   block [0x828AFF30..0x828AFF90)
	// 828AFF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFF38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFF3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFF40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFF44: 4BFFD74D  bl 0x828ad690
	ctx.lr = 0x828AFF48;
	sub_828AD690(ctx, base);
	// 828AFF48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AFF4C: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828AFF50: 396BAD70  addi r11, r11, -0x5290
	ctx.r[11].s64 = ctx.r[11].s64 + -21136;
	// 828AFF54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFF58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AFF5C: 808A0B08  lwz r4, 0xb08(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828AFF60: 48543AA9  bl 0x82df3a08
	ctx.lr = 0x828AFF64;
	sub_82DF3A08(ctx, base);
	// 828AFF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFF68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AFF6C: 485A977D  bl 0x82e596e8
	ctx.lr = 0x828AFF70;
	sub_82E596E8(ctx, base);
	// 828AFF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFF74: 485434B5  bl 0x82df3428
	ctx.lr = 0x828AFF78;
	sub_82DF3428(ctx, base);
	// 828AFF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFF7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AFF80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFF84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFF88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFF8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828AFF90 size=96
    let mut pc: u32 = 0x828AFF90;
    'dispatch: loop {
        match pc {
            0x828AFF90 => {
    //   block [0x828AFF90..0x828AFFF0)
	// 828AFF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFF94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828AFF98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828AFF9C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828AFFA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828AFFA4: 4BFFD6ED  bl 0x828ad690
	ctx.lr = 0x828AFFA8;
	sub_828AD690(ctx, base);
	// 828AFFA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828AFFAC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828AFFB0: 396BAD98  addi r11, r11, -0x5268
	ctx.r[11].s64 = ctx.r[11].s64 + -21096;
	// 828AFFB4: 388A1F78  addi r4, r10, 0x1f78
	ctx.r[4].s64 = ctx.r[10].s64 + 8056;
	// 828AFFB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828AFFBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFFC0: 48543A49  bl 0x82df3a08
	ctx.lr = 0x828AFFC4;
	sub_82DF3A08(ctx, base);
	// 828AFFC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFFC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828AFFCC: 485A971D  bl 0x82e596e8
	ctx.lr = 0x828AFFD0;
	sub_82E596E8(ctx, base);
	// 828AFFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828AFFD4: 48543455  bl 0x82df3428
	ctx.lr = 0x828AFFD8;
	sub_82DF3428(ctx, base);
	// 828AFFD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828AFFDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828AFFE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828AFFE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828AFFE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828AFFEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828AFFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828AFFF0 size=256
    let mut pc: u32 = 0x828AFFF0;
    'dispatch: loop {
        match pc {
            0x828AFFF0 => {
    //   block [0x828AFFF0..0x828B00F0)
	// 828AFFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828AFFF4: 488F8179  bl 0x831a816c
	ctx.lr = 0x828AFFF8;
	sub_831A8130(ctx, base);
	// 828AFFF8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828AFFFC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0004: 488A45FD  bl 0x83154600
	ctx.lr = 0x828B0008;
	sub_83154600(ctx, base);
	// 828B0008: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B000C: 48008CDD  bl 0x828b8ce8
	ctx.lr = 0x828B0010;
	sub_828B8CE8(ctx, base);
	// 828B0010: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0014: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0018: 485A9761  bl 0x82e59778
	ctx.lr = 0x828B001C;
	sub_82E59778(ctx, base);
	// 828B001C: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B0020: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828B0024: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B0028: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B002C: 4BFFBEED  bl 0x828abf18
	ctx.lr = 0x828B0030;
	sub_828ABF18(ctx, base);
	// 828B0030: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 828B0034: 4805954D  bl 0x82909580
	ctx.lr = 0x828B0038;
	sub_82909580(ctx, base);
	// 828B0038: 4806BDE1  bl 0x8291be18
	ctx.lr = 0x828B003C;
	sub_8291BE18(ctx, base);
	// 828B003C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0040: 41820048  beq 0x828b0088
	if ctx.cr[0].eq {
	pc = 0x828B0088; continue 'dispatch;
	}
	// 828B0044: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B0048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B004C: 388BADBC  addi r4, r11, -0x5244
	ctx.r[4].s64 = ctx.r[11].s64 + -21060;
	// 828B0050: 485439B9  bl 0x82df3a08
	ctx.lr = 0x828B0054;
	sub_82DF3A08(ctx, base);
	// 828B0054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B005C: 487580CD  bl 0x83008128
	ctx.lr = 0x828B0060;
	sub_83008128(ctx, base);
	// 828B0060: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B0064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B0068: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B006C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B0070: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B0074: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B0078: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B007C: 485AE8E5  bl 0x82e5e960
	ctx.lr = 0x828B0080;
	sub_82E5E960(ctx, base);
	// 828B0080: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B0084: 48000054  b 0x828b00d8
	pc = 0x828B00D8; continue 'dispatch;
	// 828B0088: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B008C: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B0090: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B0094: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828B0098: 4098004C  bge cr6, 0x828b00e4
	if !ctx.cr[6].lt {
	pc = 0x828B00E4; continue 'dispatch;
	}
	// 828B009C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B00A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B00A4: 388B1F78  addi r4, r11, 0x1f78
	ctx.r[4].s64 = ctx.r[11].s64 + 8056;
	// 828B00A8: 48543961  bl 0x82df3a08
	ctx.lr = 0x828B00AC;
	sub_82DF3A08(ctx, base);
	// 828B00AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B00B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B00B4: 48758075  bl 0x83008128
	ctx.lr = 0x828B00B8;
	sub_83008128(ctx, base);
	// 828B00B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B00BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B00C0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B00C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B00C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B00CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B00D0: 485AE891  bl 0x82e5e960
	ctx.lr = 0x828B00D4;
	sub_82E5E960(ctx, base);
	// 828B00D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B00D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B00DC: 419A0008  beq cr6, 0x828b00e4
	if ctx.cr[6].eq {
	pc = 0x828B00E4; continue 'dispatch;
	}
	// 828B00E0: 4BA107B1  bl 0x822c0890
	ctx.lr = 0x828B00E4;
	sub_822C0890(ctx, base);
	// 828B00E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B00E8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828B00EC: 488F80D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B00F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B00F0 size=312
    let mut pc: u32 = 0x828B00F0;
    'dispatch: loop {
        match pc {
            0x828B00F0 => {
    //   block [0x828B00F0..0x828B0228)
	// 828B00F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B00F4: 488F8079  bl 0x831a816c
	ctx.lr = 0x828B00F8;
	sub_831A8130(ctx, base);
	// 828B00F8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 828B00FC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828B0100: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B0104: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B010C: 488A44F5  bl 0x83154600
	ctx.lr = 0x828B0110;
	sub_83154600(ctx, base);
	// 828B0110: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0114: 48008BD5  bl 0x828b8ce8
	ctx.lr = 0x828B0118;
	sub_828B8CE8(ctx, base);
	// 828B0118: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B011C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0120: 4BFFBDF9  bl 0x828abf18
	ctx.lr = 0x828B0124;
	sub_828ABF18(ctx, base);
	// 828B0124: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B0128: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 828B012C: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 828B0130: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828B0134: C00A9524  lfs f0, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B0138: C3EB0010  lfs f31, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B013C: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 828B0140: C3AB0008  lfs f29, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 828B0144: 4805943D  bl 0x82909580
	ctx.lr = 0x828B0148;
	sub_82909580(ctx, base);
	// 828B0148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B014C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 828B0150: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 828B0154: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 828B0158: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B015C: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 828B0160: 4806BC79  bl 0x8291bdd8
	ctx.lr = 0x828B0164;
	sub_8291BDD8(ctx, base);
	// 828B0164: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0168: 41820044  beq 0x828b01ac
	if ctx.cr[0].eq {
	pc = 0x828B01AC; continue 'dispatch;
	}
	// 828B016C: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B0170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0174: 808B0B08  lwz r4, 0xb08(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2824 as u32) ) } as u64;
	// 828B0178: 48543891  bl 0x82df3a08
	ctx.lr = 0x828B017C;
	sub_82DF3A08(ctx, base);
	// 828B017C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0184: 48757FA5  bl 0x83008128
	ctx.lr = 0x828B0188;
	sub_83008128(ctx, base);
	// 828B0188: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B018C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0190: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B0194: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B0198: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B019C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B01A0: 485AE7C1  bl 0x82e5e960
	ctx.lr = 0x828B01A4;
	sub_82E5E960(ctx, base);
	// 828B01A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B01A8: 48000060  b 0x828b0208
	pc = 0x828B0208; continue 'dispatch;
	// 828B01AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B01B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B01B4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B01B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B01BC: 4E800421  bctrl
	ctx.lr = 0x828B01C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B01C0: 4BF3A151  bl 0x827ea310
	ctx.lr = 0x828B01C4;
	sub_827EA310(ctx, base);
	// 828B01C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B01C8: 4182004C  beq 0x828b0214
	if ctx.cr[0].eq {
	pc = 0x828B0214; continue 'dispatch;
	}
	// 828B01CC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B01D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B01D4: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828B01D8: 48543831  bl 0x82df3a08
	ctx.lr = 0x828B01DC;
	sub_82DF3A08(ctx, base);
	// 828B01DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B01E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B01E4: 48757F45  bl 0x83008128
	ctx.lr = 0x828B01E8;
	sub_83008128(ctx, base);
	// 828B01E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B01EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B01F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B01F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B01F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B01FC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B0200: 485AE761  bl 0x82e5e960
	ctx.lr = 0x828B0204;
	sub_82E5E960(ctx, base);
	// 828B0204: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B0208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B020C: 419A0008  beq cr6, 0x828b0214
	if ctx.cr[6].eq {
	pc = 0x828B0214; continue 'dispatch;
	}
	// 828B0210: 4BA10681  bl 0x822c0890
	ctx.lr = 0x828B0214;
	sub_822C0890(ctx, base);
	// 828B0214: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828B0218: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 828B021C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 828B0220: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828B0224: 488F7F98  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B0228 size=156
    let mut pc: u32 = 0x828B0228;
    'dispatch: loop {
        match pc {
            0x828B0228 => {
    //   block [0x828B0228..0x828B02C4)
	// 828B0228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B022C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0230: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B0234: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B0238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B023C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0240: 488A43C1  bl 0x83154600
	ctx.lr = 0x828B0244;
	sub_83154600(ctx, base);
	// 828B0244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0248: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B024C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0250: 4E800421  bctrl
	ctx.lr = 0x828B0254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0254: 4BF3A0BD  bl 0x827ea310
	ctx.lr = 0x828B0258;
	sub_827EA310(ctx, base);
	// 828B0258: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B025C: 41820050  beq 0x828b02ac
	if ctx.cr[0].eq {
	pc = 0x828B02AC; continue 'dispatch;
	}
	// 828B0260: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B0264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0268: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828B026C: 4854379D  bl 0x82df3a08
	ctx.lr = 0x828B0270;
	sub_82DF3A08(ctx, base);
	// 828B0270: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0278: 48757EB1  bl 0x83008128
	ctx.lr = 0x828B027C;
	sub_83008128(ctx, base);
	// 828B027C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B0280: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B0284: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0288: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B028C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B0290: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B0294: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B0298: 485AE6C9  bl 0x82e5e960
	ctx.lr = 0x828B029C;
	sub_82E5E960(ctx, base);
	// 828B029C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B02A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B02A4: 419A0008  beq cr6, 0x828b02ac
	if ctx.cr[6].eq {
	pc = 0x828B02AC; continue 'dispatch;
	}
	// 828B02A8: 4BA105E9  bl 0x822c0890
	ctx.lr = 0x828B02AC;
	sub_822C0890(ctx, base);
	// 828B02AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B02B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B02B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B02B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B02BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B02C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B02C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B02C8 size=172
    let mut pc: u32 = 0x828B02C8;
    'dispatch: loop {
        match pc {
            0x828B02C8 => {
    //   block [0x828B02C8..0x828B0374)
	// 828B02C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B02CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B02D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B02D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B02D8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828B02DC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B02E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B02E4: 485A9495  bl 0x82e59778
	ctx.lr = 0x828B02E8;
	sub_82E59778(ctx, base);
	// 828B02E8: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B02EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B02F0: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828B02F4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B02F8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B02FC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828B0300: 40980058  bge cr6, 0x828b0358
	if !ctx.cr[6].lt {
	pc = 0x828B0358; continue 'dispatch;
	}
	// 828B0304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0308: 488A42F9  bl 0x83154600
	ctx.lr = 0x828B030C;
	sub_83154600(ctx, base);
	// 828B030C: 480089DD  bl 0x828b8ce8
	ctx.lr = 0x828B0310;
	sub_828B8CE8(ctx, base);
	// 828B0310: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B0314: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0318: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828B031C: 485436ED  bl 0x82df3a08
	ctx.lr = 0x828B0320;
	sub_82DF3A08(ctx, base);
	// 828B0320: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0328: 48757E01  bl 0x83008128
	ctx.lr = 0x828B032C;
	sub_83008128(ctx, base);
	// 828B032C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B0330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B0334: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B0338: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B033C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B0340: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B0344: 485AE61D  bl 0x82e5e960
	ctx.lr = 0x828B0348;
	sub_82E5E960(ctx, base);
	// 828B0348: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B034C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B0350: 419A0008  beq cr6, 0x828b0358
	if ctx.cr[6].eq {
	pc = 0x828B0358; continue 'dispatch;
	}
	// 828B0354: 4BA1053D  bl 0x822c0890
	ctx.lr = 0x828B0358;
	sub_822C0890(ctx, base);
	// 828B0358: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B035C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B0360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B0364: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 828B0368: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B036C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B0370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B0378 size=192
    let mut pc: u32 = 0x828B0378;
    'dispatch: loop {
        match pc {
            0x828B0378 => {
    //   block [0x828B0378..0x828B0438)
	// 828B0378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B037C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B0384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B0388: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B038C: 488A4275  bl 0x83154600
	ctx.lr = 0x828B0390;
	sub_83154600(ctx, base);
	// 828B0390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0394: 48008955  bl 0x828b8ce8
	ctx.lr = 0x828B0398;
	sub_828B8CE8(ctx, base);
	// 828B0398: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B039C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B03A0: 388B1538  addi r4, r11, 0x1538
	ctx.r[4].s64 = ctx.r[11].s64 + 5432;
	// 828B03A4: 4BFB2CFD  bl 0x828630a0
	ctx.lr = 0x828B03A8;
	sub_828630A0(ctx, base);
	// 828B03A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B03AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B03B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B03B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B03B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B03BC: 419A0024  beq cr6, 0x828b03e0
	if ctx.cr[6].eq {
	pc = 0x828B03E0; continue 'dispatch;
	}
	// 828B03C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B03C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B03C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B03CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B03D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B03D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B03D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B03DC: 4082FFE8  bne 0x828b03c4
	if !ctx.cr[0].eq {
	pc = 0x828B03C4; continue 'dispatch;
	}
	// 828B03E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B03E4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828B03E8: 4BF3D439  bl 0x827ed820
	ctx.lr = 0x828B03EC;
	sub_827ED820(ctx, base);
	// 828B03EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B03F0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B03F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828B03F8: 388AADC8  addi r4, r10, -0x5238
	ctx.r[4].s64 = ctx.r[10].s64 + -21048;
	// 828B03FC: 38A00048  li r5, 0x48
	ctx.r[5].s64 = 72;
	// 828B0400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0404: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B0408: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 828B040C: 4BF3F74D  bl 0x827efb58
	ctx.lr = 0x828B0410;
	sub_827EFB58(ctx, base);
	// 828B0410: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B0414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B0418: 419A0008  beq cr6, 0x828b0420
	if ctx.cr[6].eq {
	pc = 0x828B0420; continue 'dispatch;
	}
	// 828B041C: 4BA10475  bl 0x822c0890
	ctx.lr = 0x828B0420;
	sub_822C0890(ctx, base);
	// 828B0420: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B0424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B0428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B042C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B0430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B0434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B0438 size=324
    let mut pc: u32 = 0x828B0438;
    'dispatch: loop {
        match pc {
            0x828B0438 => {
    //   block [0x828B0438..0x828B057C)
	// 828B0438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B043C: 488F7D31  bl 0x831a816c
	ctx.lr = 0x828B0440;
	sub_831A8130(ctx, base);
	// 828B0440: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0444: 488A41BD  bl 0x83154600
	ctx.lr = 0x828B0448;
	sub_83154600(ctx, base);
	// 828B0448: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B044C: 4800889D  bl 0x828b8ce8
	ctx.lr = 0x828B0450;
	sub_828B8CE8(ctx, base);
	// 828B0450: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B0454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0458: 388B14B0  addi r4, r11, 0x14b0
	ctx.r[4].s64 = ctx.r[11].s64 + 5296;
	// 828B045C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B0460: 4BFB2C41  bl 0x828630a0
	ctx.lr = 0x828B0464;
	sub_828630A0(ctx, base);
	// 828B0464: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0468: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B046C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B0474: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B0478: 419A0024  beq cr6, 0x828b049c
	if ctx.cr[6].eq {
	pc = 0x828B049C; continue 'dispatch;
	}
	// 828B047C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B0480: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B0484: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B0488: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B048C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B0490: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B0494: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B0498: 4082FFE8  bne 0x828b0480
	if !ctx.cr[0].eq {
	pc = 0x828B0480; continue 'dispatch;
	}
	// 828B049C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B04A0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828B04A4: 4BF3D37D  bl 0x827ed820
	ctx.lr = 0x828B04A8;
	sub_827ED820(ctx, base);
	// 828B04A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B04AC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B04B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828B04B4: 388AADC8  addi r4, r10, -0x5238
	ctx.r[4].s64 = ctx.r[10].s64 + -21048;
	// 828B04B8: 38A0012F  li r5, 0x12f
	ctx.r[5].s64 = 303;
	// 828B04BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B04C0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B04C4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828B04C8: 4BF3F691  bl 0x827efb58
	ctx.lr = 0x828B04CC;
	sub_827EFB58(ctx, base);
	// 828B04CC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B04D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B04D4: 419A0008  beq cr6, 0x828b04dc
	if ctx.cr[6].eq {
	pc = 0x828B04DC; continue 'dispatch;
	}
	// 828B04D8: 4BA103B9  bl 0x822c0890
	ctx.lr = 0x828B04DC;
	sub_822C0890(ctx, base);
	// 828B04DC: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828B04E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B04E4: 48059005  bl 0x829094e8
	ctx.lr = 0x828B04E8;
	sub_829094E8(ctx, base);
	// 828B04E8: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 828B04EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B04F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B04F4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B04F8: 409A0008  bne cr6, 0x828b0500
	if !ctx.cr[6].eq {
	pc = 0x828B0500; continue 'dispatch;
	}
	// 828B04FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B0500: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B0504: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828B0508: 4BAE9FF1  bl 0x8239a4f8
	ctx.lr = 0x828B050C;
	sub_8239A4F8(ctx, base);
	// 828B050C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0510: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828B0514: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B051C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828B0520: 419A0024  beq cr6, 0x828b0544
	if ctx.cr[6].eq {
	pc = 0x828B0544; continue 'dispatch;
	}
	// 828B0524: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B0528: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B052C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B0530: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B0534: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B0538: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B053C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B0540: 4082FFE8  bne 0x828b0528
	if !ctx.cr[0].eq {
	pc = 0x828B0528; continue 'dispatch;
	}
	// 828B0544: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B0548: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 828B054C: 394BAD0C  addi r10, r11, -0x52f4
	ctx.r[10].s64 = ctx.r[11].s64 + -21236;
	// 828B0550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0554: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0558: C02BAD0C  lfs f1, -0x52f4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21236 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B055C: C04A0004  lfs f2, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B0560: 4806E651  bl 0x8291ebb0
	ctx.lr = 0x828B0564;
	sub_8291EBB0(ctx, base);
	// 828B0564: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B0568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B056C: 419A0008  beq cr6, 0x828b0574
	if ctx.cr[6].eq {
	pc = 0x828B0574; continue 'dispatch;
	}
	// 828B0570: 4BA10321  bl 0x822c0890
	ctx.lr = 0x828B0574;
	sub_822C0890(ctx, base);
	// 828B0574: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828B0578: 488F7C44  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0580 size=96
    let mut pc: u32 = 0x828B0580;
    'dispatch: loop {
        match pc {
            0x828B0580 => {
    //   block [0x828B0580..0x828B05E0)
	// 828B0580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0588: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B058C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0594: 4BFFD0FD  bl 0x828ad690
	ctx.lr = 0x828B0598;
	sub_828AD690(ctx, base);
	// 828B0598: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B059C: 3D40832C  lis r10, -0x7cd4
	ctx.r[10].s64 = -2094268416;
	// 828B05A0: 396BAE44  addi r11, r11, -0x51bc
	ctx.r[11].s64 = ctx.r[11].s64 + -20924;
	// 828B05A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B05A8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B05AC: 808A153C  lwz r4, 0x153c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5436 as u32) ) } as u64;
	// 828B05B0: 48543459  bl 0x82df3a08
	ctx.lr = 0x828B05B4;
	sub_82DF3A08(ctx, base);
	// 828B05B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B05B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B05BC: 485A912D  bl 0x82e596e8
	ctx.lr = 0x828B05C0;
	sub_82E596E8(ctx, base);
	// 828B05C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B05C4: 48542E65  bl 0x82df3428
	ctx.lr = 0x828B05C8;
	sub_82DF3428(ctx, base);
	// 828B05C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B05CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B05D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B05D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B05D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B05DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B05E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B05E0 size=92
    let mut pc: u32 = 0x828B05E0;
    'dispatch: loop {
        match pc {
            0x828B05E0 => {
    //   block [0x828B05E0..0x828B063C)
	// 828B05E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B05E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B05E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B05EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B05F0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B05F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B05F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B05FC: 808B14B0  lwz r4, 0x14b0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5296 as u32) ) } as u64;
	// 828B0600: 48543409  bl 0x82df3a08
	ctx.lr = 0x828B0604;
	sub_82DF3A08(ctx, base);
	// 828B0604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0608: 488A3FF9  bl 0x83154600
	ctx.lr = 0x828B060C;
	sub_83154600(ctx, base);
	// 828B060C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0610: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B0614: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B0618: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B061C: 4E800421  bctrl
	ctx.lr = 0x828B0620;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0624: 48542E05  bl 0x82df3428
	ctx.lr = 0x828B0628;
	sub_82DF3428(ctx, base);
	// 828B0628: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B062C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B0630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B0634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B0638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B0640 size=108
    let mut pc: u32 = 0x828B0640;
    'dispatch: loop {
        match pc {
            0x828B0640 => {
    //   block [0x828B0640..0x828B06AC)
	// 828B0640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B0648: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B064C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0654: 4BFFD03D  bl 0x828ad690
	ctx.lr = 0x828B0658;
	sub_828AD690(ctx, base);
	// 828B0658: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 828B065C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B0660: 394AAE6C  addi r10, r10, -0x5194
	ctx.r[10].s64 = ctx.r[10].s64 + -20884;
	// 828B0664: 3D20832D  lis r9, -0x7cd3
	ctx.r[9].s64 = -2094202880;
	// 828B0668: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828B066C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0670: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 828B0674: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828B0678: 80890B24  lwz r4, 0xb24(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2852 as u32) ) } as u64;
	// 828B067C: 4854338D  bl 0x82df3a08
	ctx.lr = 0x828B0680;
	sub_82DF3A08(ctx, base);
	// 828B0680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0684: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B0688: 485A9061  bl 0x82e596e8
	ctx.lr = 0x828B068C;
	sub_82E596E8(ctx, base);
	// 828B068C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0690: 48542D99  bl 0x82df3428
	ctx.lr = 0x828B0694;
	sub_82DF3428(ctx, base);
	// 828B0694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B069C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B06A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B06A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B06A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B06B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B06B0 size=880
    let mut pc: u32 = 0x828B06B0;
    'dispatch: loop {
        match pc {
            0x828B06B0 => {
    //   block [0x828B06B0..0x828B0A20)
	// 828B06B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B06B4: 488F7AB5  bl 0x831a8168
	ctx.lr = 0x828B06B8;
	sub_831A8130(ctx, base);
	// 828B06B8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B06BC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B06C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B06C4: 488A3F3D  bl 0x83154600
	ctx.lr = 0x828B06C8;
	sub_83154600(ctx, base);
	// 828B06C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B06CC: 4806609D  bl 0x82916768
	ctx.lr = 0x828B06D0;
	sub_82916768(ctx, base);
	// 828B06D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B06D4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828B06D8: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B06DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B06E0: 4805E699  bl 0x8290ed78
	ctx.lr = 0x828B06E4;
	sub_8290ED78(ctx, base);
	// 828B06E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B06E8: 48066081  bl 0x82916768
	ctx.lr = 0x828B06EC;
	sub_82916768(ctx, base);
	// 828B06EC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 828B06F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B06F4: 4805E685  bl 0x8290ed78
	ctx.lr = 0x828B06F8;
	sub_8290ED78(ctx, base);
	// 828B06F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B06FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0700: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B0704: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0708: 4E800421  bctrl
	ctx.lr = 0x828B070C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B070C: 3FA0832C  lis r29, -0x7cd4
	ctx.r[29].s64 = -2094268416;
	// 828B0710: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B0714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0718: 809D14B4  lwz r4, 0x14b4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828B071C: 485432ED  bl 0x82df3a08
	ctx.lr = 0x828B0720;
	sub_82DF3A08(ctx, base);
	// 828B0720: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B0724: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828B0728: 4BF39B81  bl 0x827ea2a8
	ctx.lr = 0x828B072C;
	sub_827EA2A8(ctx, base);
	// 828B072C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828B0730: 48542B71  bl 0x82df32a0
	ctx.lr = 0x828B0734;
	sub_82DF32A0(ctx, base);
	// 828B0734: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B0738: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B073C: 48542CED  bl 0x82df3428
	ctx.lr = 0x828B0740;
	sub_82DF3428(ctx, base);
	// 828B0740: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0744: 41820030  beq 0x828b0774
	if ctx.cr[0].eq {
	pc = 0x828B0774; continue 'dispatch;
	}
	// 828B0748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B074C: 809D14B4  lwz r4, 0x14b4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(5300 as u32) ) } as u64;
	// 828B0750: 485432B9  bl 0x82df3a08
	ctx.lr = 0x828B0754;
	sub_82DF3A08(ctx, base);
	// 828B0754: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0758: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B075C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0760: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 828B0764: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0768: 4E800421  bctrl
	ctx.lr = 0x828B076C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B076C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0770: 48542CB9  bl 0x82df3428
	ctx.lr = 0x828B0774;
	sub_82DF3428(ctx, base);
	// 828B0774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0778: 48008589  bl 0x828b8d00
	ctx.lr = 0x828B077C;
	sub_828B8D00(ctx, base);
	// 828B077C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 828B0780: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828B0784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0788: C00B7BC4  lfs f0, 0x7bc4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B078C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 828B0790: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B0794: 939E0064  stw r28, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 828B0798: 939E0068  stw r28, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 828B079C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B07A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B07A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B07A8: 4E800421  bctrl
	ctx.lr = 0x828B07AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B07AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B07B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B07B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B07B8: 4BFFB711  bl 0x828abec8
	ctx.lr = 0x828B07BC;
	sub_828ABEC8(ctx, base);
	// 828B07BC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B07C0: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B07C4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828B07C8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B0A20 size=340
    let mut pc: u32 = 0x828B0A20;
    'dispatch: loop {
        match pc {
            0x828B0A20 => {
    //   block [0x828B0A20..0x828B0B74)
	// 828B0A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0A24: 488F7745  bl 0x831a8168
	ctx.lr = 0x828B0A28;
	sub_831A8130(ctx, base);
	// 828B0A28: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B0A2C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0A30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0A34: 488A3BCD  bl 0x83154600
	ctx.lr = 0x828B0A38;
	sub_83154600(ctx, base);
	// 828B0A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0A3C: 480082AD  bl 0x828b8ce8
	ctx.lr = 0x828B0A40;
	sub_828B8CE8(ctx, base);
	// 828B0A40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B0A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0A48: 48065D21  bl 0x82916768
	ctx.lr = 0x828B0A4C;
	sub_82916768(ctx, base);
	// 828B0A4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B0A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0A54: 485A8D25  bl 0x82e59778
	ctx.lr = 0x828B0A58;
	sub_82E59778(ctx, base);
	// 828B0A58: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0A5C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828B0A60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B0A64: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 828B0A68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0A6C: 4E800421  bctrl
	ctx.lr = 0x828B0A70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0A70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B0A74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0A78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B0A7C: 4808F1B5  bl 0x8293fc30
	ctx.lr = 0x828B0A80;
	sub_8293FC30(ctx, base);
	// 828B0A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0A84: 4BFFB495  bl 0x828abf18
	ctx.lr = 0x828B0A88;
	sub_828ABF18(ctx, base);
	// 828B0A88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B0A8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0A90: 4BFF26D1  bl 0x828a3160
	ctx.lr = 0x828B0A94;
	sub_828A3160(ctx, base);
	// 828B0A94: C01C0020  lfs f0, 0x20(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B0A98: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828B0A9C: 40990010  ble cr6, 0x828b0aac
	if !ctx.cr[6].gt {
	pc = 0x828B0AAC; continue 'dispatch;
	}
	// 828B0AA0: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B0AA4: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 828B0AA8: 4800008C  b 0x828b0b34
	pc = 0x828B0B34; continue 'dispatch;
	// 828B0AAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0AB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0AB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0ABC: 4E800421  bctrl
	ctx.lr = 0x828B0AC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0AC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B0AC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0ACC: 4BFFB3FD  bl 0x828abec8
	ctx.lr = 0x828B0AD0;
	sub_828ABEC8(ctx, base);
	// 828B0AD0: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B0AD4: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B0B78 size=712
    let mut pc: u32 = 0x828B0B78;
    'dispatch: loop {
        match pc {
            0x828B0B78 => {
    //   block [0x828B0B78..0x828B0E40)
	// 828B0B78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0B7C: 488F75E9  bl 0x831a8164
	ctx.lr = 0x828B0B80;
	sub_831A8130(ctx, base);
	// 828B0B80: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0B84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0B88: 488A3A79  bl 0x83154600
	ctx.lr = 0x828B0B8C;
	sub_83154600(ctx, base);
	// 828B0B8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B0B90: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0B94: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B0B98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0B9C: 4E800421  bctrl
	ctx.lr = 0x828B0BA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0BA0: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B0BA4: 3BDF0068  addi r30, r31, 0x68
	ctx.r[30].s64 = ctx.r[31].s64 + 104;
	// 828B0BA8: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B0BB0: 40820228  bne 0x828b0dd8
	if !ctx.cr[0].eq {
	pc = 0x828B0DD8; continue 'dispatch;
	}
	// 828B0BB4: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BB8: 40820220  bne 0x828b0dd8
	if !ctx.cr[0].eq {
	pc = 0x828B0DD8; continue 'dispatch;
	}
	// 828B0BBC: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0BC0: 40820218  bne 0x828b0dd8
	if !ctx.cr[0].eq {
	pc = 0x828B0DD8; continue 'dispatch;
	}
	// 828B0BC4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B0BC8: 556ACFFF  rlwinm. r10, r11, 0x19, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BCC: 408201D0  bne 0x828b0d9c
	if !ctx.cr[0].eq {
	pc = 0x828B0D9C; continue 'dispatch;
	}
	// 828B0BD0: 556AC7FF  rlwinm. r10, r11, 0x18, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BD4: 408201C8  bne 0x828b0d9c
	if !ctx.cr[0].eq {
	pc = 0x828B0D9C; continue 'dispatch;
	}
	// 828B0BD8: 556ADFFF  rlwinm. r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BDC: 408201C0  bne 0x828b0d9c
	if !ctx.cr[0].eq {
	pc = 0x828B0D9C; continue 'dispatch;
	}
	// 828B0BE0: 556AD7FF  rlwinm. r10, r11, 0x1a, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BE4: 408201B8  bne 0x828b0d9c
	if !ctx.cr[0].eq {
	pc = 0x828B0D9C; continue 'dispatch;
	}
	// 828B0BE8: 556AEFFF  rlwinm. r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0BEC: 418200A8  beq 0x828b0c94
	if ctx.cr[0].eq {
	pc = 0x828B0C94; continue 'dispatch;
	}
	// 828B0BF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0BF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B0BF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0BFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0C00: 4E800421  bctrl
	ctx.lr = 0x828B0C04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0C04: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B0C08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B0C0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B0C10: 4BFFB2B9  bl 0x828abec8
	ctx.lr = 0x828B0C14;
	sub_828ABEC8(ctx, base);
	// 828B0C14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B0C18: 13E0D8C7  vcmpequd (lvx128) v31, v0, v27
	tmp.u32 = ctx.r[27].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B0C1C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 828B0C20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B0C24: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828B0C28: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B0E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B0E40 size=788
    let mut pc: u32 = 0x828B0E40;
    'dispatch: loop {
        match pc {
            0x828B0E40 => {
    //   block [0x828B0E40..0x828B1154)
	// 828B0E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B0E44: 488F7325  bl 0x831a8168
	ctx.lr = 0x828B0E48;
	sub_831A8130(ctx, base);
	// 828B0E48: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828B0E4C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B0E50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0E54: 488A37AD  bl 0x83154600
	ctx.lr = 0x828B0E58;
	sub_83154600(ctx, base);
	// 828B0E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B0E5C: 4BFFB0BD  bl 0x828abf18
	ctx.lr = 0x828B0E60;
	sub_828ABF18(ctx, base);
	// 828B0E60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B0E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0E68: 4BFFFBB9  bl 0x828b0a20
	ctx.lr = 0x828B0E6C;
	sub_828B0A20(ctx, base);
	// 828B0E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0E70: 4BFFFD09  bl 0x828b0b78
	ctx.lr = 0x828B0E74;
	sub_828B0B78(ctx, base);
	// 828B0E74: 817E0068  lwz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 828B0E78: 3BBE0068  addi r29, r30, 0x68
	ctx.r[29].s64 = ctx.r[30].s64 + 104;
	// 828B0E7C: 556AF7FF  rlwinm. r10, r11, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0E80: 41820040  beq 0x828b0ec0
	if ctx.cr[0].eq {
	pc = 0x828B0EC0; continue 'dispatch;
	}
	// 828B0E84: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B0E88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0E8C: 808B1524  lwz r4, 0x1524(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5412 as u32) ) } as u64;
	// 828B0E90: 48542B79  bl 0x82df3a08
	ctx.lr = 0x828B0E94;
	sub_82DF3A08(ctx, base);
	// 828B0E94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0E98: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828B0E9C: 488A3765  bl 0x83154600
	ctx.lr = 0x828B0EA0;
	sub_83154600(ctx, base);
	// 828B0EA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0EA4: 4BF3E89D  bl 0x827ef740
	ctx.lr = 0x828B0EA8;
	sub_827EF740(ctx, base);
	// 828B0EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0EAC: 4854257D  bl 0x82df3428
	ctx.lr = 0x828B0EB0;
	sub_82DF3428(ctx, base);
	// 828B0EB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0EB4: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 828B0EB8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B0EBC: 4800028C  b 0x828b1148
	pc = 0x828B1148; continue 'dispatch;
	// 828B0EC0: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0EC4: 40820284  bne 0x828b1148
	if !ctx.cr[0].eq {
	pc = 0x828B1148; continue 'dispatch;
	}
	// 828B0EC8: 556AFFFF  rlwinm. r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 828B0ECC: 41820028  beq 0x828b0ef4
	if ctx.cr[0].eq {
	pc = 0x828B0EF4; continue 'dispatch;
	}
	// 828B0ED0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B0ED4: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828B0ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B0EDC: 48542B2D  bl 0x82df3a08
	ctx.lr = 0x828B0EE0;
	sub_82DF3A08(ctx, base);
	// 828B0EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0EE4: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 828B0EE8: 488A3719  bl 0x83154600
	ctx.lr = 0x828B0EEC;
	sub_83154600(ctx, base);
	// 828B0EEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0EF0: 4800024C  b 0x828b113c
	pc = 0x828B113C; continue 'dispatch;
	// 828B0EF4: 556BEFFF  rlwinm. r11, r11, 0x1d, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B0EF8: 41820028  beq 0x828b0f20
	if ctx.cr[0].eq {
	pc = 0x828B0F20; continue 'dispatch;
	}
	// 828B0EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0F00: 48065869  bl 0x82916768
	ctx.lr = 0x828B0F04;
	sub_82916768(ctx, base);
	// 828B0F04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B0F08: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 828B0F0C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B0F10: 4805DE69  bl 0x8290ed78
	ctx.lr = 0x828B0F14;
	sub_8290ED78(ctx, base);
	// 828B0F14: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B0F18: 808B0AFC  lwz r4, 0xafc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828B0F1C: 4BFFFFBC  b 0x828b0ed8
	pc = 0x828B0ED8; continue 'dispatch;
	// 828B0F20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B0F24: 485A8855  bl 0x82e59778
	ctx.lr = 0x828B0F28;
	sub_82E59778(ctx, base);
	// 828B0F28: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B0F2C: EDA00828  fsubs f13, f0, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828B0F30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B0F34: D1BE0060  stfs f13, 0x60(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B0F38: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B0F3C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 828B0F40: 40980208  bge cr6, 0x828b1148
	if !ctx.cr[6].lt {
	pc = 0x828B1148; continue 'dispatch;
	}
	// 828B0F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0F48: 48007DB9  bl 0x828b8d00
	ctx.lr = 0x828B0F4C;
	sub_828B8D00(ctx, base);
	// 828B0F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B0F50: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 828B0F54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B0F58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B0F5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B0F60: 4E800421  bctrl
	ctx.lr = 0x828B0F64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B0F64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B0F68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B0F6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B0F70: 4BFFAF59  bl 0x828abec8
	ctx.lr = 0x828B0F74;
	sub_828ABEC8(ctx, base);
	// 828B0F74: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B0F78: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1158 size=48
    let mut pc: u32 = 0x828B1158;
    'dispatch: loop {
        match pc {
            0x828B1158 => {
    //   block [0x828B1158..0x828B1188)
	// 828B1158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B115C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1160: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1164: 488A349D  bl 0x83154600
	ctx.lr = 0x828B1168;
	sub_83154600(ctx, base);
	// 828B1168: 48007B81  bl 0x828b8ce8
	ctx.lr = 0x828B116C;
	sub_828B8CE8(ctx, base);
	// 828B116C: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 828B1170: 48058419  bl 0x82909588
	ctx.lr = 0x828B1174;
	sub_82909588(ctx, base);
	// 828B1174: 4808F335  bl 0x829404a8
	ctx.lr = 0x828B1178;
	sub_829404A8(ctx, base);
	// 828B1178: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B117C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1184: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1188 size=96
    let mut pc: u32 = 0x828B1188;
    'dispatch: loop {
        match pc {
            0x828B1188 => {
    //   block [0x828B1188..0x828B11E8)
	// 828B1188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B118C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1190: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1194: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B119C: 4BFFC4F5  bl 0x828ad690
	ctx.lr = 0x828B11A0;
	sub_828AD690(ctx, base);
	// 828B11A0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B11A4: 3D40832D  lis r10, -0x7cd3
	ctx.r[10].s64 = -2094202880;
	// 828B11A8: 396BAF10  addi r11, r11, -0x50f0
	ctx.r[11].s64 = ctx.r[11].s64 + -20720;
	// 828B11AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B11B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B11B4: 808A0AFC  lwz r4, 0xafc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2812 as u32) ) } as u64;
	// 828B11B8: 48542851  bl 0x82df3a08
	ctx.lr = 0x828B11BC;
	sub_82DF3A08(ctx, base);
	// 828B11BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B11C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B11C4: 485A8525  bl 0x82e596e8
	ctx.lr = 0x828B11C8;
	sub_82E596E8(ctx, base);
	// 828B11C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B11CC: 4854225D  bl 0x82df3428
	ctx.lr = 0x828B11D0;
	sub_82DF3428(ctx, base);
	// 828B11D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B11D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B11D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B11DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B11E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B11E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B11E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B11E8 size=348
    let mut pc: u32 = 0x828B11E8;
    'dispatch: loop {
        match pc {
            0x828B11E8 => {
    //   block [0x828B11E8..0x828B1344)
	// 828B11E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B11EC: 488F6F81  bl 0x831a816c
	ctx.lr = 0x828B11F0;
	sub_831A8130(ctx, base);
	// 828B11F0: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B11F4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B11F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B11FC: 485A857D  bl 0x82e59778
	ctx.lr = 0x828B1200;
	sub_82E59778(ctx, base);
	// 828B1200: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B1204: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B1208: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828B120C: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B1210: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B1214: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 828B1218: 4098004C  bge cr6, 0x828b1264
	if !ctx.cr[6].lt {
	pc = 0x828B1264; continue 'dispatch;
	}
	// 828B121C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B1220: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1224: 808B1514  lwz r4, 0x1514(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5396 as u32) ) } as u64;
	// 828B1228: 485427E1  bl 0x82df3a08
	ctx.lr = 0x828B122C;
	sub_82DF3A08(ctx, base);
	// 828B122C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1234: 48756EF5  bl 0x83008128
	ctx.lr = 0x828B1238;
	sub_83008128(ctx, base);
	// 828B1238: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B123C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B1240: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1244: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B1248: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B124C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B1250: 485AD711  bl 0x82e5e960
	ctx.lr = 0x828B1254;
	sub_82E5E960(ctx, base);
	// 828B1254: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B1258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B125C: 419A0008  beq cr6, 0x828b1264
	if ctx.cr[6].eq {
	pc = 0x828B1264; continue 'dispatch;
	}
	// 828B1260: 4BA0F631  bl 0x822c0890
	ctx.lr = 0x828B1264;
	sub_822C0890(ctx, base);
	// 828B1264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1268: 488A3399  bl 0x83154600
	ctx.lr = 0x828B126C;
	sub_83154600(ctx, base);
	// 828B126C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1270: 48007A79  bl 0x828b8ce8
	ctx.lr = 0x828B1274;
	sub_828B8CE8(ctx, base);
	// 828B1274: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1278: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B127C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1280: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B1284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1288: 4E800421  bctrl
	ctx.lr = 0x828B128C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B128C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1290: 4BFFAC89  bl 0x828abf18
	ctx.lr = 0x828B1294;
	sub_828ABF18(ctx, base);
	// 828B1294: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 828B1298: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B129C: 480582E5  bl 0x82909580
	ctx.lr = 0x828B12A0;
	sub_82909580(ctx, base);
	// 828B12A0: 4806AB79  bl 0x8291be18
	ctx.lr = 0x828B12A4;
	sub_8291BE18(ctx, base);
	// 828B12A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B12A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B12AC: 4182005C  beq 0x828b1308
	if ctx.cr[0].eq {
	pc = 0x828B1308; continue 'dispatch;
	}
	// 828B12B0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 828B12B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B12B8: 4805DAC1  bl 0x8290ed78
	ctx.lr = 0x828B12BC;
	sub_8290ED78(ctx, base);
	// 828B12BC: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B12C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B12C4: 808B0B30  lwz r4, 0xb30(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2864 as u32) ) } as u64;
	// 828B12C8: 48542741  bl 0x82df3a08
	ctx.lr = 0x828B12CC;
	sub_82DF3A08(ctx, base);
	// 828B12CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B12D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B12D4: 48756E55  bl 0x83008128
	ctx.lr = 0x828B12D8;
	sub_83008128(ctx, base);
	// 828B12D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B12DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B12E0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B12E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B12E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B12EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828B12F0: 485AD671  bl 0x82e5e960
	ctx.lr = 0x828B12F4;
	sub_82E5E960(ctx, base);
	// 828B12F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828B12F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B12FC: 419A003C  beq cr6, 0x828b1338
	if ctx.cr[6].eq {
	pc = 0x828B1338; continue 'dispatch;
	}
	// 828B1300: 4BA0F591  bl 0x822c0890
	ctx.lr = 0x828B1304;
	sub_822C0890(ctx, base);
	// 828B1304: 48000034  b 0x828b1338
	pc = 0x828B1338; continue 'dispatch;
	// 828B1308: 48058281  bl 0x82909588
	ctx.lr = 0x828B130C;
	sub_82909588(ctx, base);
	// 828B130C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B1310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1314: 485A8465  bl 0x82e59778
	ctx.lr = 0x828B1318;
	sub_82E59778(ctx, base);
	// 828B1318: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B131C: 4808EFFD  bl 0x82940318
	ctx.lr = 0x828B1320;
	sub_82940318(ctx, base);
	// 828B1320: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B1324: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828B1328: 4808EEE1  bl 0x82940208
	ctx.lr = 0x828B132C;
	sub_82940208(ctx, base);
	// 828B132C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828B1330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1334: 4BFFAE35  bl 0x828ac168
	ctx.lr = 0x828B1338;
	sub_828AC168(ctx, base);
	// 828B1338: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B133C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 828B1340: 488F6E7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B1348 size=764
    let mut pc: u32 = 0x828B1348;
    'dispatch: loop {
        match pc {
            0x828B1348 => {
    //   block [0x828B1348..0x828B1644)
	// 828B1348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B134C: 488F6E09  bl 0x831a8154
	ctx.lr = 0x828B1350;
	sub_831A8130(ctx, base);
	// 828B1350: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1354: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 828B1358: 488A32A9  bl 0x83154600
	ctx.lr = 0x828B135C;
	sub_83154600(ctx, base);
	// 828B135C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1360: 48007989  bl 0x828b8ce8
	ctx.lr = 0x828B1364;
	sub_828B8CE8(ctx, base);
	// 828B1364: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B1368: 4BFF1DA1  bl 0x828a3108
	ctx.lr = 0x828B136C;
	sub_828A3108(ctx, base);
	// 828B136C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B1370: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828B1374: 388B1508  addi r4, r11, 0x1508
	ctx.r[4].s64 = ctx.r[11].s64 + 5384;
	// 828B1378: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B137C: 4BFB1D25  bl 0x828630a0
	ctx.lr = 0x828B1380;
	sub_828630A0(ctx, base);
	// 828B1380: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1384: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B1388: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B138C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B1390: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B1394: 419A0024  beq cr6, 0x828b13b8
	if ctx.cr[6].eq {
	pc = 0x828B13B8; continue 'dispatch;
	}
	// 828B1398: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828B139C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B13A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B13A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B13A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B13AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B13B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B13B4: 4082FFE8  bne 0x828b139c
	if !ctx.cr[0].eq {
	pc = 0x828B139C; continue 'dispatch;
	}
	// 828B13B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B13BC: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 828B13C0: 4BF3C461  bl 0x827ed820
	ctx.lr = 0x828B13C4;
	sub_827ED820(ctx, base);
	// 828B13C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B13C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B13CC: 3BABAF38  addi r29, r11, -0x50c8
	ctx.r[29].s64 = ctx.r[11].s64 + -20680;
	// 828B13D0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828B13D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B13D8: 38A0004A  li r5, 0x4a
	ctx.r[5].s64 = 74;
	// 828B13DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B13E0: C02A08A4  lfs f1, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B13E4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 828B13E8: 4BF3E771  bl 0x827efb58
	ctx.lr = 0x828B13EC;
	sub_827EFB58(ctx, base);
	// 828B13EC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B13F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B13F4: 419A0008  beq cr6, 0x828b13fc
	if ctx.cr[6].eq {
	pc = 0x828B13FC; continue 'dispatch;
	}
	// 828B13F8: 4BA0F499  bl 0x822c0890
	ctx.lr = 0x828B13FC;
	sub_822C0890(ctx, base);
	// 828B13FC: 3B3E0010  addi r25, r30, 0x10
	ctx.r[25].s64 = ctx.r[30].s64 + 16;
	// 828B1400: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B1404: 48058185  bl 0x82909588
	ctx.lr = 0x828B1408;
	sub_82909588(ctx, base);
	// 828B1408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B140C: 4808F09D  bl 0x829404a8
	ctx.lr = 0x828B1410;
	sub_829404A8(ctx, base);
	// 828B1410: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B1414: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B1418: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 828B141C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 828B1420: 4BA0EFB9  bl 0x822c03d8
	ctx.lr = 0x828B1424;
	sub_822C03D8(ctx, base);
	// 828B1424: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 828B1428: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B142C: 41820018  beq 0x828b1444
	if ctx.cr[0].eq {
	pc = 0x828B1444; continue 'dispatch;
	}
	// 828B1430: 38BB0298  addi r5, r27, 0x298
	ctx.r[5].s64 = ctx.r[27].s64 + 664;
	// 828B1434: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B1438: 48091F51  bl 0x82943388
	ctx.lr = 0x828B143C;
	sub_82943388(ctx, base);
	// 828B143C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B1440: 48000008  b 0x828b1448
	pc = 0x828B1448; continue 'dispatch;
	// 828B1444: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 828B1448: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B144C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1450: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B1454: 4BFC0A65  bl 0x82871eb8
	ctx.lr = 0x828B1458;
	sub_82871EB8(ctx, base);
	// 828B1458: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B145C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1460: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B1464: 4BA0EB9D  bl 0x822c0000
	ctx.lr = 0x828B1468;
	sub_822C0000(ctx, base);
	// 828B1468: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B146C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B1470: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828B1474: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 828B1478: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B147C: 419A0024  beq cr6, 0x828b14a0
	if ctx.cr[6].eq {
	pc = 0x828B14A0; continue 'dispatch;
	}
	// 828B1480: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 828B1484: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B1488: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B148C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B1490: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B1494: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B1498: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B149C: 4082FFE8  bne 0x828b1484
	if !ctx.cr[0].eq {
	pc = 0x828B1484; continue 'dispatch;
	}
	// 828B14A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B14A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B14A8: 4808F009  bl 0x829404b0
	ctx.lr = 0x828B14AC;
	sub_829404B0(ctx, base);
	// 828B14AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B14B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B14B4: 38A00058  li r5, 0x58
	ctx.r[5].s64 = 88;
	// 828B14B8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 828B14BC: 4BA0EF1D  bl 0x822c03d8
	ctx.lr = 0x828B14C0;
	sub_822C03D8(ctx, base);
	// 828B14C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B14C4: 41820018  beq 0x828b14dc
	if ctx.cr[0].eq {
	pc = 0x828B14DC; continue 'dispatch;
	}
	// 828B14C8: 38BB02A8  addi r5, r27, 0x2a8
	ctx.r[5].s64 = ctx.r[27].s64 + 680;
	// 828B14CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B14D0: 48090A39  bl 0x82941f08
	ctx.lr = 0x828B14D4;
	sub_82941F08(ctx, base);
	// 828B14D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B14D8: 48000008  b 0x828b14e0
	pc = 0x828B14E0; continue 'dispatch;
	// 828B14DC: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 828B14E0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B14E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B14E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B14EC: 4BFC18BD  bl 0x82872da8
	ctx.lr = 0x828B14F0;
	sub_82872DA8(ctx, base);
	// 828B14F0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B14F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B14F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B14FC: 4BA0EB05  bl 0x822c0000
	ctx.lr = 0x828B1500;
	sub_822C0000(ctx, base);
	// 828B1500: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B1504: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B1508: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B150C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 828B1510: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B1514: 419A0024  beq cr6, 0x828b1538
	if ctx.cr[6].eq {
	pc = 0x828B1538; continue 'dispatch;
	}
	// 828B1518: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 828B151C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B1520: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B1524: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B1528: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B152C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B1530: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B1534: 4082FFE8  bne 0x828b151c
	if !ctx.cr[0].eq {
	pc = 0x828B151C; continue 'dispatch;
	}
	// 828B1538: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B153C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1540: 4808EF71  bl 0x829404b0
	ctx.lr = 0x828B1544;
	sub_829404B0(ctx, base);
	// 828B1544: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B1548: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B154C: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 828B1550: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 828B1554: 4BA0EE85  bl 0x822c03d8
	ctx.lr = 0x828B1558;
	sub_822C03D8(ctx, base);
	// 828B1558: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B155C: 41820018  beq 0x828b1574
	if ctx.cr[0].eq {
	pc = 0x828B1574; continue 'dispatch;
	}
	// 828B1560: 38BB02C4  addi r5, r27, 0x2c4
	ctx.r[5].s64 = ctx.r[27].s64 + 708;
	// 828B1564: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B1568: 480913B9  bl 0x82942920
	ctx.lr = 0x828B156C;
	sub_82942920(ctx, base);
	// 828B156C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B1570: 48000008  b 0x828b1578
	pc = 0x828B1578; continue 'dispatch;
	// 828B1574: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 828B1578: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828B157C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1580: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B1584: 4BFC09FD  bl 0x82871f80
	ctx.lr = 0x828B1588;
	sub_82871F80(ctx, base);
	// 828B1588: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828B158C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1590: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828B1594: 4BA0EA6D  bl 0x822c0000
	ctx.lr = 0x828B1598;
	sub_822C0000(ctx, base);
	// 828B1598: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B159C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B15A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B15A4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 828B15A8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B15AC: 419A0024  beq cr6, 0x828b15d0
	if ctx.cr[6].eq {
	pc = 0x828B15D0; continue 'dispatch;
	}
	// 828B15B0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 828B15B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828B15B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B15BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828B15C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828B15C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828B15C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828B15CC: 4082FFE8  bne 0x828b15b4
	if !ctx.cr[0].eq {
	pc = 0x828B15B4; continue 'dispatch;
	}
	// 828B15D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B15D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B15D8: 4808EED9  bl 0x829404b0
	ctx.lr = 0x828B15DC;
	sub_829404B0(ctx, base);
	// 828B15DC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828B15E0: 419A000C  beq cr6, 0x828b15ec
	if ctx.cr[6].eq {
	pc = 0x828B15EC; continue 'dispatch;
	}
	// 828B15E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B15E8: 4BA0F2A9  bl 0x822c0890
	ctx.lr = 0x828B15EC;
	sub_822C0890(ctx, base);
	// 828B15EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828B15F0: 419A000C  beq cr6, 0x828b15fc
	if ctx.cr[6].eq {
	pc = 0x828B15FC; continue 'dispatch;
	}
	// 828B15F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B15F8: 4BA0F299  bl 0x822c0890
	ctx.lr = 0x828B15FC;
	sub_822C0890(ctx, base);
	// 828B15FC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 828B1600: 419A000C  beq cr6, 0x828b160c
	if ctx.cr[6].eq {
	pc = 0x828B160C; continue 'dispatch;
	}
	// 828B1604: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828B1608: 4BA0F289  bl 0x822c0890
	ctx.lr = 0x828B160C;
	sub_822C0890(ctx, base);
	// 828B160C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1610: 3FE08209  lis r31, -0x7df7
	ctx.r[31].s64 = -2113339392;
	// 828B1614: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 828B1618: C03FAF08  lfs f1, -0x50f8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-20728 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B161C: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 828B1620: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1624: 4E800421  bctrl
	ctx.lr = 0x828B1628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B1628: C01FAF08  lfs f0, -0x50f8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-20728 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B162C: 9B170064  stb r24, 0x64(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(100 as u32), ctx.r[24].u8 ) };
	// 828B1630: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 828B1634: D0170060  stfs f0, 0x60(r23)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 828B1638: 9B170065  stb r24, 0x65(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(101 as u32), ctx.r[24].u8 ) };
	// 828B163C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B1640: 488F6B64  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1648 size=136
    let mut pc: u32 = 0x828B1648;
    'dispatch: loop {
        match pc {
            0x828B1648 => {
    //   block [0x828B1648..0x828B16D0)
	// 828B1648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B164C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B165C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B1660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1664: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B1668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B166C: 388BAFD0  addi r4, r11, -0x5030
	ctx.r[4].s64 = ctx.r[11].s64 + -20528;
	// 828B1670: 48542399  bl 0x82df3a08
	ctx.lr = 0x828B1674;
	sub_82DF3A08(ctx, base);
	// 828B1674: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828B1678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B167C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1680: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B1684: 4805C7CD  bl 0x8290de50
	ctx.lr = 0x828B1688;
	sub_8290DE50(ctx, base);
	// 828B1688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B168C: 48541D9D  bl 0x82df3428
	ctx.lr = 0x828B1690;
	sub_82DF3428(ctx, base);
	// 828B1690: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B1694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1698: 388BAFB4  addi r4, r11, -0x504c
	ctx.r[4].s64 = ctx.r[11].s64 + -20556;
	// 828B169C: 4854236D  bl 0x82df3a08
	ctx.lr = 0x828B16A0;
	sub_82DF3A08(ctx, base);
	// 828B16A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B16A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B16A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B16AC: 4805C87D  bl 0x8290df28
	ctx.lr = 0x828B16B0;
	sub_8290DF28(ctx, base);
	// 828B16B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B16B4: 48541D75  bl 0x82df3428
	ctx.lr = 0x828B16B8;
	sub_82DF3428(ctx, base);
	// 828B16B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B16BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B16C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B16C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B16C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B16CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B16D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B16D0 size=240
    let mut pc: u32 = 0x828B16D0;
    'dispatch: loop {
        match pc {
            0x828B16D0 => {
    //   block [0x828B16D0..0x828B17C0)
	// 828B16D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B16D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B16D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B16DC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B16E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B16E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B16E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B16EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B16F0: 388BAFEC  addi r4, r11, -0x5014
	ctx.r[4].s64 = ctx.r[11].s64 + -20500;
	// 828B16F4: 48542315  bl 0x82df3a08
	ctx.lr = 0x828B16F8;
	sub_82DF3A08(ctx, base);
	// 828B16F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B16FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1700: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1704: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1708: C02BE830  lfs f1, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B170C: 4805AF75  bl 0x8290c680
	ctx.lr = 0x828B1710;
	sub_8290C680(ctx, base);
	// 828B1710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1714: 48541D15  bl 0x82df3428
	ctx.lr = 0x828B1718;
	sub_82DF3428(ctx, base);
	// 828B1718: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B171C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1720: 388B9FBC  addi r4, r11, -0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + -24644;
	// 828B1724: 485422E5  bl 0x82df3a08
	ctx.lr = 0x828B1728;
	sub_82DF3A08(ctx, base);
	// 828B1728: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B172C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1730: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1734: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1738: C3EBD7BC  lfs f31, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B173C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1740: 4805AF41  bl 0x8290c680
	ctx.lr = 0x828B1744;
	sub_8290C680(ctx, base);
	// 828B1744: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1748: 48541CE1  bl 0x82df3428
	ctx.lr = 0x828B174C;
	sub_82DF3428(ctx, base);
	// 828B174C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B1750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1754: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 828B1758: 485422B1  bl 0x82df3a08
	ctx.lr = 0x828B175C;
	sub_82DF3A08(ctx, base);
	// 828B175C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1760: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1764: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1768: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B176C: 4805AF15  bl 0x8290c680
	ctx.lr = 0x828B1770;
	sub_8290C680(ctx, base);
	// 828B1770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1774: 48541CB5  bl 0x82df3428
	ctx.lr = 0x828B1778;
	sub_82DF3428(ctx, base);
	// 828B1778: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B177C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1780: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828B1784: 48542285  bl 0x82df3a08
	ctx.lr = 0x828B1788;
	sub_82DF3A08(ctx, base);
	// 828B1788: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B178C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1798: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B179C: 4805AEE5  bl 0x8290c680
	ctx.lr = 0x828B17A0;
	sub_8290C680(ctx, base);
	// 828B17A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B17A4: 48541C85  bl 0x82df3428
	ctx.lr = 0x828B17A8;
	sub_82DF3428(ctx, base);
	// 828B17A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B17AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B17B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B17B4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B17B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B17BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B17C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B17C0 size=240
    let mut pc: u32 = 0x828B17C0;
    'dispatch: loop {
        match pc {
            0x828B17C0 => {
    //   block [0x828B17C0..0x828B18B0)
	// 828B17C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B17C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B17C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B17CC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B17D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B17D4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B17D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B17DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B17E0: 388BAFEC  addi r4, r11, -0x5014
	ctx.r[4].s64 = ctx.r[11].s64 + -20500;
	// 828B17E4: 48542225  bl 0x82df3a08
	ctx.lr = 0x828B17E8;
	sub_82DF3A08(ctx, base);
	// 828B17E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B17EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B17F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B17F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B17F8: C02BE830  lfs f1, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B17FC: 4805AF25  bl 0x8290c720
	ctx.lr = 0x828B1800;
	sub_8290C720(ctx, base);
	// 828B1800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1804: 48541C25  bl 0x82df3428
	ctx.lr = 0x828B1808;
	sub_82DF3428(ctx, base);
	// 828B1808: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B180C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1810: 388B9FBC  addi r4, r11, -0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + -24644;
	// 828B1814: 485421F5  bl 0x82df3a08
	ctx.lr = 0x828B1818;
	sub_82DF3A08(ctx, base);
	// 828B1818: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B181C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1820: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1828: C3EBD7BC  lfs f31, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B182C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1830: 4805AEF1  bl 0x8290c720
	ctx.lr = 0x828B1834;
	sub_8290C720(ctx, base);
	// 828B1834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1838: 48541BF1  bl 0x82df3428
	ctx.lr = 0x828B183C;
	sub_82DF3428(ctx, base);
	// 828B183C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B1840: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1844: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 828B1848: 485421C1  bl 0x82df3a08
	ctx.lr = 0x828B184C;
	sub_82DF3A08(ctx, base);
	// 828B184C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1850: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1854: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1858: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B185C: 4805AEC5  bl 0x8290c720
	ctx.lr = 0x828B1860;
	sub_8290C720(ctx, base);
	// 828B1860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1864: 48541BC5  bl 0x82df3428
	ctx.lr = 0x828B1868;
	sub_82DF3428(ctx, base);
	// 828B1868: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B186C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1870: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828B1874: 48542195  bl 0x82df3a08
	ctx.lr = 0x828B1878;
	sub_82DF3A08(ctx, base);
	// 828B1878: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B187C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B1880: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1888: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B188C: 4805AE95  bl 0x8290c720
	ctx.lr = 0x828B1890;
	sub_8290C720(ctx, base);
	// 828B1890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1894: 48541B95  bl 0x82df3428
	ctx.lr = 0x828B1898;
	sub_82DF3428(ctx, base);
	// 828B1898: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B189C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B18A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B18A4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B18A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B18AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B18B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B18B0 size=240
    let mut pc: u32 = 0x828B18B0;
    'dispatch: loop {
        match pc {
            0x828B18B0 => {
    //   block [0x828B18B0..0x828B19A0)
	// 828B18B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B18B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B18B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B18BC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B18C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B18C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B18C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B18CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B18D0: 388BAFEC  addi r4, r11, -0x5014
	ctx.r[4].s64 = ctx.r[11].s64 + -20500;
	// 828B18D4: 48542135  bl 0x82df3a08
	ctx.lr = 0x828B18D8;
	sub_82DF3A08(ctx, base);
	// 828B18D8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B18DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B18E0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B18E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B18E8: C02BE830  lfs f1, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B18EC: 4805AD95  bl 0x8290c680
	ctx.lr = 0x828B18F0;
	sub_8290C680(ctx, base);
	// 828B18F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B18F4: 48541B35  bl 0x82df3428
	ctx.lr = 0x828B18F8;
	sub_82DF3428(ctx, base);
	// 828B18F8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B18FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1900: 388B9FBC  addi r4, r11, -0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + -24644;
	// 828B1904: 48542105  bl 0x82df3a08
	ctx.lr = 0x828B1908;
	sub_82DF3A08(ctx, base);
	// 828B1908: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B190C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1910: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B1914: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1918: C3EBD7BC  lfs f31, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B191C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1920: 4805AD61  bl 0x8290c680
	ctx.lr = 0x828B1924;
	sub_8290C680(ctx, base);
	// 828B1924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1928: 48541B01  bl 0x82df3428
	ctx.lr = 0x828B192C;
	sub_82DF3428(ctx, base);
	// 828B192C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B1930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1934: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 828B1938: 485420D1  bl 0x82df3a08
	ctx.lr = 0x828B193C;
	sub_82DF3A08(ctx, base);
	// 828B193C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1940: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B1944: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1948: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B194C: 4805AD35  bl 0x8290c680
	ctx.lr = 0x828B1950;
	sub_8290C680(ctx, base);
	// 828B1950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1954: 48541AD5  bl 0x82df3428
	ctx.lr = 0x828B1958;
	sub_82DF3428(ctx, base);
	// 828B1958: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B195C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1960: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828B1964: 485420A5  bl 0x82df3a08
	ctx.lr = 0x828B1968;
	sub_82DF3A08(ctx, base);
	// 828B1968: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B196C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B1970: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1978: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B197C: 4805AD05  bl 0x8290c680
	ctx.lr = 0x828B1980;
	sub_8290C680(ctx, base);
	// 828B1980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1984: 48541AA5  bl 0x82df3428
	ctx.lr = 0x828B1988;
	sub_82DF3428(ctx, base);
	// 828B1988: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B198C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1994: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B199C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B19A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B19A0 size=240
    let mut pc: u32 = 0x828B19A0;
    'dispatch: loop {
        match pc {
            0x828B19A0 => {
    //   block [0x828B19A0..0x828B1A90)
	// 828B19A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B19A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B19A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B19AC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 828B19B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B19B4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B19B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B19BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B19C0: 388BAFEC  addi r4, r11, -0x5014
	ctx.r[4].s64 = ctx.r[11].s64 + -20500;
	// 828B19C4: 48542045  bl 0x82df3a08
	ctx.lr = 0x828B19C8;
	sub_82DF3A08(ctx, base);
	// 828B19C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B19CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B19D0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B19D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B19D8: C02BE830  lfs f1, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B19DC: 4805AD45  bl 0x8290c720
	ctx.lr = 0x828B19E0;
	sub_8290C720(ctx, base);
	// 828B19E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B19E4: 48541A45  bl 0x82df3428
	ctx.lr = 0x828B19E8;
	sub_82DF3428(ctx, base);
	// 828B19E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B19EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B19F0: 388B9FBC  addi r4, r11, -0x6044
	ctx.r[4].s64 = ctx.r[11].s64 + -24644;
	// 828B19F4: 48542015  bl 0x82df3a08
	ctx.lr = 0x828B19F8;
	sub_82DF3A08(ctx, base);
	// 828B19F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 828B19FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1A00: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B1A04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1A08: C3EBD7BC  lfs f31, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828B1A0C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1A10: 4805AD11  bl 0x8290c720
	ctx.lr = 0x828B1A14;
	sub_8290C720(ctx, base);
	// 828B1A14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1A18: 48541A11  bl 0x82df3428
	ctx.lr = 0x828B1A1C;
	sub_82DF3428(ctx, base);
	// 828B1A1C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 828B1A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1A24: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 828B1A28: 48541FE1  bl 0x82df3a08
	ctx.lr = 0x828B1A2C;
	sub_82DF3A08(ctx, base);
	// 828B1A2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1A30: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B1A34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828B1A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1A3C: 4805ACE5  bl 0x8290c720
	ctx.lr = 0x828B1A40;
	sub_8290C720(ctx, base);
	// 828B1A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1A44: 485419E5  bl 0x82df3428
	ctx.lr = 0x828B1A48;
	sub_82DF3428(ctx, base);
	// 828B1A48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B1A4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1A50: 388B50D4  addi r4, r11, 0x50d4
	ctx.r[4].s64 = ctx.r[11].s64 + 20692;
	// 828B1A54: 48541FB5  bl 0x82df3a08
	ctx.lr = 0x828B1A58;
	sub_82DF3A08(ctx, base);
	// 828B1A58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B1A5C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 828B1A60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1A68: C02BA2EC  lfs f1, -0x5d14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B1A6C: 4805ACB5  bl 0x8290c720
	ctx.lr = 0x828B1A70;
	sub_8290C720(ctx, base);
	// 828B1A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1A74: 485419B5  bl 0x82df3428
	ctx.lr = 0x828B1A78;
	sub_82DF3428(ctx, base);
	// 828B1A78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1A84: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1A88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1A8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1A90 size=28
    let mut pc: u32 = 0x828B1A90;
    'dispatch: loop {
        match pc {
            0x828B1A90 => {
    //   block [0x828B1A90..0x828B1AAC)
	// 828B1A90: 814303A4  lwz r10, 0x3a4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(932 as u32) ) } as u64;
	// 828B1A94: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B1A98: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B1A9C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1AA0: 1D4A0288  mulli r10, r10, 0x288
	ctx.r[10].s64 = ctx.r[10].s64 * 648;
	// 828B1AA4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B1AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1AB0 size=68
    let mut pc: u32 = 0x828B1AB0;
    'dispatch: loop {
        match pc {
            0x828B1AB0 => {
    //   block [0x828B1AB0..0x828B1AF4)
	// 828B1AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1AB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1AB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1ABC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1AC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1AC4: 48057265  bl 0x82908d28
	ctx.lr = 0x828B1AC8;
	sub_82908D28(ctx, base);
	// 828B1AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1ACC: 4805E87D  bl 0x82910348
	ctx.lr = 0x828B1AD0;
	sub_82910348(ctx, base);
	// 828B1AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1AD4: 4805E8BD  bl 0x82910390
	ctx.lr = 0x828B1AD8;
	sub_82910390(ctx, base);
	// 828B1AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1ADC: 4BC5EAF5  bl 0x825105d0
	ctx.lr = 0x828B1AE0;
	sub_825105D0(ctx, base);
	// 828B1AE0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B1AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1AEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1AF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1AF8 size=84
    let mut pc: u32 = 0x828B1AF8;
    'dispatch: loop {
        match pc {
            0x828B1AF8 => {
    //   block [0x828B1AF8..0x828B1B4C)
	// 828B1AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1B00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1B04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1B08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1B0C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 828B1B10: 409A0014  bne cr6, 0x828b1b24
	if !ctx.cr[6].eq {
	pc = 0x828B1B24; continue 'dispatch;
	}
	// 828B1B14: 48057215  bl 0x82908d28
	ctx.lr = 0x828B1B18;
	sub_82908D28(ctx, base);
	// 828B1B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1B1C: 4BC5EAB5  bl 0x825105d0
	ctx.lr = 0x828B1B20;
	sub_825105D0(ctx, base);
	// 828B1B20: 48000018  b 0x828b1b38
	pc = 0x828B1B38; continue 'dispatch;
	// 828B1B24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1B2C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 828B1B30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1B34: 4E800421  bctrl
	ctx.lr = 0x828B1B38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B1B38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B1B3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1B40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1B44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1B48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1B50 size=136
    let mut pc: u32 = 0x828B1B50;
    'dispatch: loop {
        match pc {
            0x828B1B50 => {
    //   block [0x828B1B50..0x828B1BD8)
	// 828B1B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1B54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1B58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1B5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1B60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1B64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B1B68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1B6C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B1B70: 409A0020  bne cr6, 0x828b1b90
	if !ctx.cr[6].eq {
	pc = 0x828B1B90; continue 'dispatch;
	}
	// 828B1B74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B1B78: 419A0048  beq cr6, 0x828b1bc0
	if ctx.cr[6].eq {
	pc = 0x828B1BC0; continue 'dispatch;
	}
	// 828B1B7C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828B1B80: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B1B84: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828B1B88: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828B1B8C: 48000034  b 0x828b1bc0
	pc = 0x828B1BC0; continue 'dispatch;
	// 828B1B90: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828B1B94: 419A002C  beq cr6, 0x828b1bc0
	if ctx.cr[6].eq {
	pc = 0x828B1BC0; continue 'dispatch;
	}
	// 828B1B98: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B1B9C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1BA0: 388B2118  addi r4, r11, 0x2118
	ctx.r[4].s64 = ctx.r[11].s64 + 8472;
	// 828B1BA4: 488F6555  bl 0x831a80f8
	ctx.lr = 0x828B1BA8;
	sub_831A80F8(ctx, base);
	// 828B1BA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1BAC: 4182000C  beq 0x828b1bb8
	if ctx.cr[0].eq {
	pc = 0x828B1BB8; continue 'dispatch;
	}
	// 828B1BB0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B1BB4: 4800000C  b 0x828b1bc0
	pc = 0x828B1BC0; continue 'dispatch;
	// 828B1BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B1BBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B1BC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1BC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1BC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1BCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1BD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1BD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1BD8 size=136
    let mut pc: u32 = 0x828B1BD8;
    'dispatch: loop {
        match pc {
            0x828B1BD8 => {
    //   block [0x828B1BD8..0x828B1C60)
	// 828B1BD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1BDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1BE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1BE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1BEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B1BF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1BF4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B1BF8: 409A0020  bne cr6, 0x828b1c18
	if !ctx.cr[6].eq {
	pc = 0x828B1C18; continue 'dispatch;
	}
	// 828B1BFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B1C00: 419A0048  beq cr6, 0x828b1c48
	if ctx.cr[6].eq {
	pc = 0x828B1C48; continue 'dispatch;
	}
	// 828B1C04: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 828B1C08: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B1C0C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 828B1C10: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828B1C14: 48000034  b 0x828b1c48
	pc = 0x828B1C48; continue 'dispatch;
	// 828B1C18: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828B1C1C: 419A002C  beq cr6, 0x828b1c48
	if ctx.cr[6].eq {
	pc = 0x828B1C48; continue 'dispatch;
	}
	// 828B1C20: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B1C24: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1C28: 388B21D8  addi r4, r11, 0x21d8
	ctx.r[4].s64 = ctx.r[11].s64 + 8664;
	// 828B1C2C: 488F64CD  bl 0x831a80f8
	ctx.lr = 0x828B1C30;
	sub_831A80F8(ctx, base);
	// 828B1C30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1C34: 4182000C  beq 0x828b1c40
	if ctx.cr[0].eq {
	pc = 0x828B1C40; continue 'dispatch;
	}
	// 828B1C38: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 828B1C3C: 4800000C  b 0x828b1c48
	pc = 0x828B1C48; continue 'dispatch;
	// 828B1C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B1C44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B1C48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1C54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1C58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1C60 size=116
    let mut pc: u32 = 0x828B1C60;
    'dispatch: loop {
        match pc {
            0x828B1C60 => {
    //   block [0x828B1C60..0x828B1CD4)
	// 828B1C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1C68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1C6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1C74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B1C78: 419A0040  beq cr6, 0x828b1cb8
	if ctx.cr[6].eq {
	pc = 0x828B1CB8; continue 'dispatch;
	}
	// 828B1C7C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 828B1C80: 0CDF0000  twi 6, r31, 0
	// 828B1C84: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 828B1C88: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 828B1C8C: 4098002C  bge cr6, 0x828b1cb8
	if !ctx.cr[6].lt {
	pc = 0x828B1CB8; continue 'dispatch;
	}
	// 828B1C90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B1C94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B1C98: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 828B1C9C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828B1CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1CA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B1CA8: 4BA12609  bl 0x822c42b0
	ctx.lr = 0x828B1CAC;
	sub_822C42B0(ctx, base);
	// 828B1CAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B1CB0: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 828B1CB4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828B1CB8: 57E32834  slwi r3, r31, 5
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 828B1CBC: 4BA0EC7D  bl 0x822c0938
	ctx.lr = 0x828B1CC0;
	sub_822C0938(ctx, base);
	// 828B1CC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1CCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1CD8 size=152
    let mut pc: u32 = 0x828B1CD8;
    'dispatch: loop {
        match pc {
            0x828B1CD8 => {
    //   block [0x828B1CD8..0x828B1D70)
	// 828B1CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B1CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1CEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1CF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B1CF4: 4805F52D  bl 0x82911220
	ctx.lr = 0x828B1CF8;
	sub_82911220(ctx, base);
	// 828B1CF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1CFC: 807F0368  lwz r3, 0x368(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(872 as u32) ) } as u64;
	// 828B1D00: 4BF38491  bl 0x827ea190
	ctx.lr = 0x828B1D04;
	sub_827EA190(ctx, base);
	// 828B1D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1D08: 4BF3A459  bl 0x827ec160
	ctx.lr = 0x828B1D0C;
	sub_827EC160(ctx, base);
	// 828B1D0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1D10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B1D14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1D18: 4E800421  bctrl
	ctx.lr = 0x828B1D1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B1D1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B1D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1D24: 4821026D  bl 0x82ac1f90
	ctx.lr = 0x828B1D28;
	sub_82AC1F90(ctx, base);
	// 828B1D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1D2C: 4BF3A435  bl 0x827ec160
	ctx.lr = 0x828B1D30;
	sub_827EC160(ctx, base);
	// 828B1D30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1D34: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828B1D38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1D3C: 4E800421  bctrl
	ctx.lr = 0x828B1D40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B1D40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B1D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1D48: 481F9791  bl 0x82aab4d8
	ctx.lr = 0x828B1D4C;
	sub_82AAB4D8(ctx, base);
	// 828B1D4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1D50: 807F0370  lwz r3, 0x370(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(880 as u32) ) } as u64;
	// 828B1D54: 48070C25  bl 0x82922978
	ctx.lr = 0x828B1D58;
	sub_82922978(ctx, base);
	// 828B1D58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B1D5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B1D60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B1D64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B1D68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B1D6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1D70 size=12
    let mut pc: u32 = 0x828B1D70;
    'dispatch: loop {
        match pc {
            0x828B1D70 => {
    //   block [0x828B1D70..0x828B1D7C)
	// 828B1D70: 80630378  lwz r3, 0x378(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(888 as u32) ) } as u64;
	// 828B1D74: 38840018  addi r4, r4, 0x18
	ctx.r[4].s64 = ctx.r[4].s64 + 24;
	// 828B1D78: 4BF38768  b 0x827ea4e0
	sub_827EA4E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B1D80 size=196
    let mut pc: u32 = 0x828B1D80;
    'dispatch: loop {
        match pc {
            0x828B1D80 => {
    //   block [0x828B1D80..0x828B1E44)
	// 828B1D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1D84: 488F63E9  bl 0x831a816c
	ctx.lr = 0x828B1D88;
	sub_831A8130(ctx, base);
	// 828B1D88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1D8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B1D90: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 828B1D94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1D98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1D9C: 83DD00F4  lwz r30, 0xf4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) } as u64;
	// 828B1DA0: 808B0B2C  lwz r4, 0xb2c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) } as u64;
	// 828B1DA4: 48541C65  bl 0x82df3a08
	ctx.lr = 0x828B1DA8;
	sub_82DF3A08(ctx, base);
	// 828B1DA8: 387D010C  addi r3, r29, 0x10c
	ctx.r[3].s64 = ctx.r[29].s64 + 268;
	// 828B1DAC: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 828B1DB0: 485A8921  bl 0x82e5a6d0
	ctx.lr = 0x828B1DB4;
	sub_82E5A6D0(ctx, base);
	// 828B1DB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B1DB8: 485414E9  bl 0x82df32a0
	ctx.lr = 0x828B1DBC;
	sub_82DF32A0(ctx, base);
	// 828B1DBC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B1DC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1DC4: 48541665  bl 0x82df3428
	ctx.lr = 0x828B1DC8;
	sub_82DF3428(ctx, base);
	// 828B1DC8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1DCC: 41820070  beq 0x828b1e3c
	if ctx.cr[0].eq {
	pc = 0x828B1E3C; continue 'dispatch;
	}
	// 828B1DD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B1DD4: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 828B1DD8: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828B1DDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B1DE0: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 828B1DE4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B1DE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1DEC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B1DF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1DF4: 4E800421  bctrl
	ctx.lr = 0x828B1DF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B1DF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B1DFC: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 828B1E00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B1E04: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1E48 size=8
    let mut pc: u32 = 0x828B1E48;
    'dispatch: loop {
        match pc {
            0x828B1E48 => {
    //   block [0x828B1E48..0x828B1E50)
	// 828B1E48: 80630380  lwz r3, 0x380(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(896 as u32) ) } as u64;
	// 828B1E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1E50 size=208
    let mut pc: u32 = 0x828B1E50;
    'dispatch: loop {
        match pc {
            0x828B1E50 => {
    //   block [0x828B1E50..0x828B1F20)
	// 828B1E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1E54: 488F6319  bl 0x831a816c
	ctx.lr = 0x828B1E58;
	sub_831A8130(ctx, base);
	// 828B1E58: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B1E5C: 81430394  lwz r10, 0x394(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B1E60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B1E64: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 828B1E68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B1E6C: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B1E70: 3889B1AC  addi r4, r9, -0x4e54
	ctx.r[4].s64 = ctx.r[9].s64 + -20052;
	// 828B1E74: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1E78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1E7C: 1D4A0288  mulli r10, r10, 0x288
	ctx.r[10].s64 = ctx.r[10].s64 * 648;
	// 828B1E80: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B1E84: 48541B85  bl 0x82df3a08
	ctx.lr = 0x828B1E88;
	sub_82DF3A08(ctx, base);
	// 828B1E88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1E90: 48541479  bl 0x82df3308
	ctx.lr = 0x828B1E94;
	sub_82DF3308(ctx, base);
	// 828B1E94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B1E98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1E9C: 4854158D  bl 0x82df3428
	ctx.lr = 0x828B1EA0;
	sub_82DF3428(ctx, base);
	// 828B1EA0: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1EA4: 4182000C  beq 0x828b1eb0
	if ctx.cr[0].eq {
	pc = 0x828B1EB0; continue 'dispatch;
	}
	// 828B1EA8: 387E00A8  addi r3, r30, 0xa8
	ctx.r[3].s64 = ctx.r[30].s64 + 168;
	// 828B1EAC: 4800006C  b 0x828b1f18
	pc = 0x828B1F18; continue 'dispatch;
	// 828B1EB0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B1EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1EB8: 388B8A40  addi r4, r11, -0x75c0
	ctx.r[4].s64 = ctx.r[11].s64 + -30144;
	// 828B1EBC: 48541B4D  bl 0x82df3a08
	ctx.lr = 0x828B1EC0;
	sub_82DF3A08(ctx, base);
	// 828B1EC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1EC8: 48541441  bl 0x82df3308
	ctx.lr = 0x828B1ECC;
	sub_82DF3308(ctx, base);
	// 828B1ECC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B1ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1ED4: 48541555  bl 0x82df3428
	ctx.lr = 0x828B1ED8;
	sub_82DF3428(ctx, base);
	// 828B1ED8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1EDC: 4182000C  beq 0x828b1ee8
	if ctx.cr[0].eq {
	pc = 0x828B1EE8; continue 'dispatch;
	}
	// 828B1EE0: 387E00B8  addi r3, r30, 0xb8
	ctx.r[3].s64 = ctx.r[30].s64 + 184;
	// 828B1EE4: 48000034  b 0x828b1f18
	pc = 0x828B1F18; continue 'dispatch;
	// 828B1EE8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B1EEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1EF0: 388BB198  addi r4, r11, -0x4e68
	ctx.r[4].s64 = ctx.r[11].s64 + -20072;
	// 828B1EF4: 48541B15  bl 0x82df3a08
	ctx.lr = 0x828B1EF8;
	sub_82DF3A08(ctx, base);
	// 828B1EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B1EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B1F00: 48541409  bl 0x82df3308
	ctx.lr = 0x828B1F04;
	sub_82DF3308(ctx, base);
	// 828B1F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B1F08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B1F0C: 4854151D  bl 0x82df3428
	ctx.lr = 0x828B1F10;
	sub_82DF3428(ctx, base);
	// 828B1F10: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B1F14: 387E00C8  addi r3, r30, 0xc8
	ctx.r[3].s64 = ctx.r[30].s64 + 200;
	// 828B1F18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828B1F1C: 488F62A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1F20 size=32
    let mut pc: u32 = 0x828B1F20;
    'dispatch: loop {
        match pc {
            0x828B1F20 => {
    //   block [0x828B1F20..0x828B1F40)
	// 828B1F20: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B1F24: 81230394  lwz r9, 0x394(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B1F28: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B1F2C: 394B0030  addi r10, r11, 0x30
	ctx.r[10].s64 = ctx.r[11].s64 + 48;
	// 828B1F30: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F34: 1D6B0288  mulli r11, r11, 0x288
	ctx.r[11].s64 = ctx.r[11].s64 * 648;
	// 828B1F38: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B1F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1F40 size=32
    let mut pc: u32 = 0x828B1F40;
    'dispatch: loop {
        match pc {
            0x828B1F40 => {
    //   block [0x828B1F40..0x828B1F60)
	// 828B1F40: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B1F44: 81230394  lwz r9, 0x394(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B1F48: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B1F4C: 394B0260  addi r10, r11, 0x260
	ctx.r[10].s64 = ctx.r[11].s64 + 608;
	// 828B1F50: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F54: 1D6B0288  mulli r11, r11, 0x288
	ctx.r[11].s64 = ctx.r[11].s64 * 648;
	// 828B1F58: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B1F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1F60 size=32
    let mut pc: u32 = 0x828B1F60;
    'dispatch: loop {
        match pc {
            0x828B1F60 => {
    //   block [0x828B1F60..0x828B1F80)
	// 828B1F60: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B1F64: 81230394  lwz r9, 0x394(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B1F68: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B1F6C: 394B026C  addi r10, r11, 0x26c
	ctx.r[10].s64 = ctx.r[11].s64 + 620;
	// 828B1F70: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F74: 1D6B0288  mulli r11, r11, 0x288
	ctx.r[11].s64 = ctx.r[11].s64 * 648;
	// 828B1F78: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B1F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1F80 size=32
    let mut pc: u32 = 0x828B1F80;
    'dispatch: loop {
        match pc {
            0x828B1F80 => {
    //   block [0x828B1F80..0x828B1FA0)
	// 828B1F80: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B1F84: 81230394  lwz r9, 0x394(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(916 as u32) ) } as u64;
	// 828B1F88: 396BEDF4  addi r11, r11, -0x120c
	ctx.r[11].s64 = ctx.r[11].s64 + -4620;
	// 828B1F8C: 394B027C  addi r10, r11, 0x27c
	ctx.r[10].s64 = ctx.r[11].s64 + 636;
	// 828B1F90: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1F94: 1D6B0288  mulli r11, r11, 0x288
	ctx.r[11].s64 = ctx.r[11].s64 * 648;
	// 828B1F98: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 828B1F9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1FA0 size=20
    let mut pc: u32 = 0x828B1FA0;
    'dispatch: loop {
        match pc {
            0x828B1FA0 => {
    //   block [0x828B1FA0..0x828B1FB4)
	// 828B1FA0: 80630360  lwz r3, 0x360(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(864 as u32) ) } as u64;
	// 828B1FA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1FA8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 828B1FAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1FB0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1FB8 size=20
    let mut pc: u32 = 0x828B1FB8;
    'dispatch: loop {
        match pc {
            0x828B1FB8 => {
    //   block [0x828B1FB8..0x828B1FCC)
	// 828B1FB8: 80630360  lwz r3, 0x360(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(864 as u32) ) } as u64;
	// 828B1FBC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B1FC0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 828B1FC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B1FC8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1FD0 size=24
    let mut pc: u32 = 0x828B1FD0;
    'dispatch: loop {
        match pc {
            0x828B1FD0 => {
    //   block [0x828B1FD0..0x828B1FE8)
	// 828B1FD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B1FD4: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828B1FD8: 409A0008  bne cr6, 0x828b1fe0
	if !ctx.cr[6].eq {
	pc = 0x828B1FE0; continue 'dispatch;
	}
	// 828B1FDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B1FE0: 80630370  lwz r3, 0x370(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(880 as u32) ) } as u64;
	// 828B1FE4: 48006C14  b 0x828b8bf8
	sub_828B8BF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828B1FE8 size=8
    let mut pc: u32 = 0x828B1FE8;
    'dispatch: loop {
        match pc {
            0x828B1FE8 => {
    //   block [0x828B1FE8..0x828B1FF0)
	// 828B1FE8: 806303B0  lwz r3, 0x3b0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(944 as u32) ) } as u64;
	// 828B1FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B1FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B1FF0 size=124
    let mut pc: u32 = 0x828B1FF0;
    'dispatch: loop {
        match pc {
            0x828B1FF0 => {
    //   block [0x828B1FF0..0x828B206C)
	// 828B1FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B1FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B1FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B1FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B2008: 817F03B4  lwz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828B200C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2010: 419A0044  beq cr6, 0x828b2054
	if ctx.cr[6].eq {
	pc = 0x828B2054; continue 'dispatch;
	}
	// 828B2014: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828B2018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B201C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B2020: 4BC5D4A9  bl 0x8250f4c8
	ctx.lr = 0x828B2024;
	sub_8250F4C8(ctx, base);
	// 828B2024: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B202C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828B2030: 409A0008  bne cr6, 0x828b2038
	if !ctx.cr[6].eq {
	pc = 0x828B2038; continue 'dispatch;
	}
	// 828B2034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B2038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B203C: 80BF03B4  lwz r5, 0x3b4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828B2040: 4BF3A251  bl 0x827ec290
	ctx.lr = 0x828B2044;
	sub_827EC290(ctx, base);
	// 828B2044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2048: 4853FC49  bl 0x82df1c90
	ctx.lr = 0x828B204C;
	sub_82DF1C90(ctx, base);
	// 828B204C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2050: 917F03B4  stw r11, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[11].u32 ) };
	// 828B2054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B205C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2070 size=196
    let mut pc: u32 = 0x828B2070;
    'dispatch: loop {
        match pc {
            0x828B2070 => {
    //   block [0x828B2070..0x828B2134)
	// 828B2070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B207C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2088: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B208C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2090: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2094: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2098: 4BA0E8A1  bl 0x822c0938
	ctx.lr = 0x828B209C;
	sub_822C0938(ctx, base);
	// 828B209C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B20A0: 41820028  beq 0x828b20c8
	if ctx.cr[0].eq {
	pc = 0x828B20C8; continue 'dispatch;
	}
	// 828B20A4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B20A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B20AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B20B0: 392BAFF8  addi r9, r11, -0x5008
	ctx.r[9].s64 = ctx.r[11].s64 + -20488;
	// 828B20B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B20B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B20BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B20C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B20C4: 48000008  b 0x828b20cc
	pc = 0x828B20CC; continue 'dispatch;
	// 828B20C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B20CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B20D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B20D4: 409A0044  bne cr6, 0x828b2118
	if !ctx.cr[6].eq {
	pc = 0x828B2118; continue 'dispatch;
	}
	// 828B20D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B20DC: 419A001C  beq cr6, 0x828b20f8
	if ctx.cr[6].eq {
	pc = 0x828B20F8; continue 'dispatch;
	}
	// 828B20E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B20E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B20E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B20EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B20F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B20F4: 4E800421  bctrl
	ctx.lr = 0x828B20F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B20F8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B20FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2104: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2108: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B210C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2110: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2114: 4BA0DEED  bl 0x822c0000
	ctx.lr = 0x828B2118;
	sub_822C0000(ctx, base);
	// 828B2118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B211C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2120: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2124: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2128: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B212C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2138 size=196
    let mut pc: u32 = 0x828B2138;
    'dispatch: loop {
        match pc {
            0x828B2138 => {
    //   block [0x828B2138..0x828B21FC)
	// 828B2138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B213C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B214C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2150: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2154: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2158: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B215C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2160: 4BA0E7D9  bl 0x822c0938
	ctx.lr = 0x828B2164;
	sub_822C0938(ctx, base);
	// 828B2164: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2168: 41820028  beq 0x828b2190
	if ctx.cr[0].eq {
	pc = 0x828B2190; continue 'dispatch;
	}
	// 828B216C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2170: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2178: 392BB00C  addi r9, r11, -0x4ff4
	ctx.r[9].s64 = ctx.r[11].s64 + -20468;
	// 828B217C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2180: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2184: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2188: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B218C: 48000008  b 0x828b2194
	pc = 0x828B2194; continue 'dispatch;
	// 828B2190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2194: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B219C: 409A0044  bne cr6, 0x828b21e0
	if !ctx.cr[6].eq {
	pc = 0x828B21E0; continue 'dispatch;
	}
	// 828B21A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B21A4: 419A001C  beq cr6, 0x828b21c0
	if ctx.cr[6].eq {
	pc = 0x828B21C0; continue 'dispatch;
	}
	// 828B21A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B21AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B21B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B21B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B21B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B21BC: 4E800421  bctrl
	ctx.lr = 0x828B21C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B21C0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B21C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B21C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B21CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B21D0: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B21D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B21D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B21DC: 4BA0DE25  bl 0x822c0000
	ctx.lr = 0x828B21E0;
	sub_822C0000(ctx, base);
	// 828B21E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B21E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B21E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B21EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B21F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B21F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B21F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2200 size=196
    let mut pc: u32 = 0x828B2200;
    'dispatch: loop {
        match pc {
            0x828B2200 => {
    //   block [0x828B2200..0x828B22C4)
	// 828B2200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2208: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B220C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2218: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B221C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2220: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2224: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2228: 4BA0E711  bl 0x822c0938
	ctx.lr = 0x828B222C;
	sub_822C0938(ctx, base);
	// 828B222C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2230: 41820028  beq 0x828b2258
	if ctx.cr[0].eq {
	pc = 0x828B2258; continue 'dispatch;
	}
	// 828B2234: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2238: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B223C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2240: 392BB020  addi r9, r11, -0x4fe0
	ctx.r[9].s64 = ctx.r[11].s64 + -20448;
	// 828B2244: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2248: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B224C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2250: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2254: 48000008  b 0x828b225c
	pc = 0x828B225C; continue 'dispatch;
	// 828B2258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B225C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2264: 409A0044  bne cr6, 0x828b22a8
	if !ctx.cr[6].eq {
	pc = 0x828B22A8; continue 'dispatch;
	}
	// 828B2268: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B226C: 419A001C  beq cr6, 0x828b2288
	if ctx.cr[6].eq {
	pc = 0x828B2288; continue 'dispatch;
	}
	// 828B2270: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2274: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B227C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2284: 4E800421  bctrl
	ctx.lr = 0x828B2288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2288: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B228C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2294: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2298: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B229C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B22A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B22A4: 4BA0DD5D  bl 0x822c0000
	ctx.lr = 0x828B22A8;
	sub_822C0000(ctx, base);
	// 828B22A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B22AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B22B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B22B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B22B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B22BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B22C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B22C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B22C8 size=196
    let mut pc: u32 = 0x828B22C8;
    'dispatch: loop {
        match pc {
            0x828B22C8 => {
    //   block [0x828B22C8..0x828B238C)
	// 828B22C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B22CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B22D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B22D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B22D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B22DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B22E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B22E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B22E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B22EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B22F0: 4BA0E649  bl 0x822c0938
	ctx.lr = 0x828B22F4;
	sub_822C0938(ctx, base);
	// 828B22F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B22F8: 41820028  beq 0x828b2320
	if ctx.cr[0].eq {
	pc = 0x828B2320; continue 'dispatch;
	}
	// 828B22FC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2300: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2304: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2308: 392BB034  addi r9, r11, -0x4fcc
	ctx.r[9].s64 = ctx.r[11].s64 + -20428;
	// 828B230C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2314: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2318: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B231C: 48000008  b 0x828b2324
	pc = 0x828B2324; continue 'dispatch;
	// 828B2320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2324: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B232C: 409A0044  bne cr6, 0x828b2370
	if !ctx.cr[6].eq {
	pc = 0x828B2370; continue 'dispatch;
	}
	// 828B2330: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2334: 419A001C  beq cr6, 0x828b2350
	if ctx.cr[6].eq {
	pc = 0x828B2350; continue 'dispatch;
	}
	// 828B2338: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B233C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2344: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B234C: 4E800421  bctrl
	ctx.lr = 0x828B2350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2350: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2354: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B235C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2360: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2364: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2368: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B236C: 4BA0DC95  bl 0x822c0000
	ctx.lr = 0x828B2370;
	sub_822C0000(ctx, base);
	// 828B2370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B237C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2390 size=196
    let mut pc: u32 = 0x828B2390;
    'dispatch: loop {
        match pc {
            0x828B2390 => {
    //   block [0x828B2390..0x828B2454)
	// 828B2390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2398: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B239C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B23A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B23A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B23A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B23AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B23B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B23B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B23B8: 4BA0E581  bl 0x822c0938
	ctx.lr = 0x828B23BC;
	sub_822C0938(ctx, base);
	// 828B23BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B23C0: 41820028  beq 0x828b23e8
	if ctx.cr[0].eq {
	pc = 0x828B23E8; continue 'dispatch;
	}
	// 828B23C4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B23C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B23CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B23D0: 392BB048  addi r9, r11, -0x4fb8
	ctx.r[9].s64 = ctx.r[11].s64 + -20408;
	// 828B23D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B23D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B23DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B23E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B23E4: 48000008  b 0x828b23ec
	pc = 0x828B23EC; continue 'dispatch;
	// 828B23E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B23EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B23F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B23F4: 409A0044  bne cr6, 0x828b2438
	if !ctx.cr[6].eq {
	pc = 0x828B2438; continue 'dispatch;
	}
	// 828B23F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B23FC: 419A001C  beq cr6, 0x828b2418
	if ctx.cr[6].eq {
	pc = 0x828B2418; continue 'dispatch;
	}
	// 828B2400: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2404: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2408: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B240C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2410: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2414: 4E800421  bctrl
	ctx.lr = 0x828B2418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2418: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B241C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2424: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2428: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B242C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2430: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2434: 4BA0DBCD  bl 0x822c0000
	ctx.lr = 0x828B2438;
	sub_822C0000(ctx, base);
	// 828B2438: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B243C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2448: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B244C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2458 size=196
    let mut pc: u32 = 0x828B2458;
    'dispatch: loop {
        match pc {
            0x828B2458 => {
    //   block [0x828B2458..0x828B251C)
	// 828B2458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B245C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B246C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2474: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2478: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B247C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2480: 4BA0E4B9  bl 0x822c0938
	ctx.lr = 0x828B2484;
	sub_822C0938(ctx, base);
	// 828B2484: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2488: 41820028  beq 0x828b24b0
	if ctx.cr[0].eq {
	pc = 0x828B24B0; continue 'dispatch;
	}
	// 828B248C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2490: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2494: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2498: 392BB05C  addi r9, r11, -0x4fa4
	ctx.r[9].s64 = ctx.r[11].s64 + -20388;
	// 828B249C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B24A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B24A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B24A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B24AC: 48000008  b 0x828b24b4
	pc = 0x828B24B4; continue 'dispatch;
	// 828B24B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B24B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B24B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B24BC: 409A0044  bne cr6, 0x828b2500
	if !ctx.cr[6].eq {
	pc = 0x828B2500; continue 'dispatch;
	}
	// 828B24C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B24C4: 419A001C  beq cr6, 0x828b24e0
	if ctx.cr[6].eq {
	pc = 0x828B24E0; continue 'dispatch;
	}
	// 828B24C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B24CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B24D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B24D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B24D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B24DC: 4E800421  bctrl
	ctx.lr = 0x828B24E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B24E0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B24E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B24E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B24EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B24F0: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B24F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B24F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B24FC: 4BA0DB05  bl 0x822c0000
	ctx.lr = 0x828B2500;
	sub_822C0000(ctx, base);
	// 828B2500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2504: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B250C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2510: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2520 size=196
    let mut pc: u32 = 0x828B2520;
    'dispatch: loop {
        match pc {
            0x828B2520 => {
    //   block [0x828B2520..0x828B25E4)
	// 828B2520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B252C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2534: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B253C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2540: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2544: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2548: 4BA0E3F1  bl 0x822c0938
	ctx.lr = 0x828B254C;
	sub_822C0938(ctx, base);
	// 828B254C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2550: 41820028  beq 0x828b2578
	if ctx.cr[0].eq {
	pc = 0x828B2578; continue 'dispatch;
	}
	// 828B2554: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2558: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B255C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2560: 392BB070  addi r9, r11, -0x4f90
	ctx.r[9].s64 = ctx.r[11].s64 + -20368;
	// 828B2564: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2568: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B256C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2570: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2574: 48000008  b 0x828b257c
	pc = 0x828B257C; continue 'dispatch;
	// 828B2578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B257C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2584: 409A0044  bne cr6, 0x828b25c8
	if !ctx.cr[6].eq {
	pc = 0x828B25C8; continue 'dispatch;
	}
	// 828B2588: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B258C: 419A001C  beq cr6, 0x828b25a8
	if ctx.cr[6].eq {
	pc = 0x828B25A8; continue 'dispatch;
	}
	// 828B2590: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2594: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B259C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B25A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B25A4: 4E800421  bctrl
	ctx.lr = 0x828B25A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B25A8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B25AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B25B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B25B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B25B8: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B25BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B25C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B25C4: 4BA0DA3D  bl 0x822c0000
	ctx.lr = 0x828B25C8;
	sub_822C0000(ctx, base);
	// 828B25C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B25CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B25D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B25D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B25D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B25DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B25E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B25E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B25E8 size=196
    let mut pc: u32 = 0x828B25E8;
    'dispatch: loop {
        match pc {
            0x828B25E8 => {
    //   block [0x828B25E8..0x828B26AC)
	// 828B25E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B25EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B25F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B25F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B25F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B25FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2600: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2604: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2608: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B260C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2610: 4BA0E329  bl 0x822c0938
	ctx.lr = 0x828B2614;
	sub_822C0938(ctx, base);
	// 828B2614: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2618: 41820028  beq 0x828b2640
	if ctx.cr[0].eq {
	pc = 0x828B2640; continue 'dispatch;
	}
	// 828B261C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2620: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2624: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2628: 392BB084  addi r9, r11, -0x4f7c
	ctx.r[9].s64 = ctx.r[11].s64 + -20348;
	// 828B262C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2630: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2634: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2638: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B263C: 48000008  b 0x828b2644
	pc = 0x828B2644; continue 'dispatch;
	// 828B2640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2644: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B264C: 409A0044  bne cr6, 0x828b2690
	if !ctx.cr[6].eq {
	pc = 0x828B2690; continue 'dispatch;
	}
	// 828B2650: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2654: 419A001C  beq cr6, 0x828b2670
	if ctx.cr[6].eq {
	pc = 0x828B2670; continue 'dispatch;
	}
	// 828B2658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B265C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2664: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2668: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B266C: 4E800421  bctrl
	ctx.lr = 0x828B2670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2670: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2674: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B267C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2680: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2684: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2688: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B268C: 4BA0D975  bl 0x822c0000
	ctx.lr = 0x828B2690;
	sub_822C0000(ctx, base);
	// 828B2690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B269C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B26A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B26A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B26A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B26B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B26B0 size=196
    let mut pc: u32 = 0x828B26B0;
    'dispatch: loop {
        match pc {
            0x828B26B0 => {
    //   block [0x828B26B0..0x828B2774)
	// 828B26B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B26B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B26B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B26BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B26C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B26C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B26C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B26CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B26D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B26D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B26D8: 4BA0E261  bl 0x822c0938
	ctx.lr = 0x828B26DC;
	sub_822C0938(ctx, base);
	// 828B26DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B26E0: 41820028  beq 0x828b2708
	if ctx.cr[0].eq {
	pc = 0x828B2708; continue 'dispatch;
	}
	// 828B26E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B26E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B26EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B26F0: 392BB098  addi r9, r11, -0x4f68
	ctx.r[9].s64 = ctx.r[11].s64 + -20328;
	// 828B26F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B26F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B26FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2700: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2704: 48000008  b 0x828b270c
	pc = 0x828B270C; continue 'dispatch;
	// 828B2708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B270C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2714: 409A0044  bne cr6, 0x828b2758
	if !ctx.cr[6].eq {
	pc = 0x828B2758; continue 'dispatch;
	}
	// 828B2718: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B271C: 419A001C  beq cr6, 0x828b2738
	if ctx.cr[6].eq {
	pc = 0x828B2738; continue 'dispatch;
	}
	// 828B2720: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2724: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B272C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2734: 4E800421  bctrl
	ctx.lr = 0x828B2738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2738: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B273C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2744: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2748: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B274C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2750: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2754: 4BA0D8AD  bl 0x822c0000
	ctx.lr = 0x828B2758;
	sub_822C0000(ctx, base);
	// 828B2758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B275C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2768: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B276C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2778 size=196
    let mut pc: u32 = 0x828B2778;
    'dispatch: loop {
        match pc {
            0x828B2778 => {
    //   block [0x828B2778..0x828B283C)
	// 828B2778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B277C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B278C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2794: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2798: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B279C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B27A0: 4BA0E199  bl 0x822c0938
	ctx.lr = 0x828B27A4;
	sub_822C0938(ctx, base);
	// 828B27A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B27A8: 41820028  beq 0x828b27d0
	if ctx.cr[0].eq {
	pc = 0x828B27D0; continue 'dispatch;
	}
	// 828B27AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B27B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B27B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B27B8: 392BB0AC  addi r9, r11, -0x4f54
	ctx.r[9].s64 = ctx.r[11].s64 + -20308;
	// 828B27BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B27C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B27C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B27C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B27CC: 48000008  b 0x828b27d4
	pc = 0x828B27D4; continue 'dispatch;
	// 828B27D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B27D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B27D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B27DC: 409A0044  bne cr6, 0x828b2820
	if !ctx.cr[6].eq {
	pc = 0x828B2820; continue 'dispatch;
	}
	// 828B27E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B27E4: 419A001C  beq cr6, 0x828b2800
	if ctx.cr[6].eq {
	pc = 0x828B2800; continue 'dispatch;
	}
	// 828B27E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B27EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B27F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B27F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B27F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B27FC: 4E800421  bctrl
	ctx.lr = 0x828B2800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2800: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2804: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B280C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2810: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2814: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2818: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B281C: 4BA0D7E5  bl 0x822c0000
	ctx.lr = 0x828B2820;
	sub_822C0000(ctx, base);
	// 828B2820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2828: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B282C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2830: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2834: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2840 size=196
    let mut pc: u32 = 0x828B2840;
    'dispatch: loop {
        match pc {
            0x828B2840 => {
    //   block [0x828B2840..0x828B2904)
	// 828B2840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B284C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2850: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2854: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B285C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2860: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2864: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2868: 4BA0E0D1  bl 0x822c0938
	ctx.lr = 0x828B286C;
	sub_822C0938(ctx, base);
	// 828B286C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2870: 41820028  beq 0x828b2898
	if ctx.cr[0].eq {
	pc = 0x828B2898; continue 'dispatch;
	}
	// 828B2874: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2878: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B287C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2880: 392BB0C0  addi r9, r11, -0x4f40
	ctx.r[9].s64 = ctx.r[11].s64 + -20288;
	// 828B2884: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2888: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B288C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2890: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2894: 48000008  b 0x828b289c
	pc = 0x828B289C; continue 'dispatch;
	// 828B2898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B289C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B28A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B28A4: 409A0044  bne cr6, 0x828b28e8
	if !ctx.cr[6].eq {
	pc = 0x828B28E8; continue 'dispatch;
	}
	// 828B28A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B28AC: 419A001C  beq cr6, 0x828b28c8
	if ctx.cr[6].eq {
	pc = 0x828B28C8; continue 'dispatch;
	}
	// 828B28B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B28B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B28B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B28BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B28C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B28C4: 4E800421  bctrl
	ctx.lr = 0x828B28C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B28C8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B28CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B28D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B28D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B28D8: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B28DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B28E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B28E4: 4BA0D71D  bl 0x822c0000
	ctx.lr = 0x828B28E8;
	sub_822C0000(ctx, base);
	// 828B28E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B28EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B28F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B28F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B28F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B28FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2908 size=196
    let mut pc: u32 = 0x828B2908;
    'dispatch: loop {
        match pc {
            0x828B2908 => {
    //   block [0x828B2908..0x828B29CC)
	// 828B2908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B290C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2910: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2914: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2918: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B291C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2924: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2928: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B292C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2930: 4BA0E009  bl 0x822c0938
	ctx.lr = 0x828B2934;
	sub_822C0938(ctx, base);
	// 828B2934: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2938: 41820028  beq 0x828b2960
	if ctx.cr[0].eq {
	pc = 0x828B2960; continue 'dispatch;
	}
	// 828B293C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2940: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2944: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2948: 392BB0D4  addi r9, r11, -0x4f2c
	ctx.r[9].s64 = ctx.r[11].s64 + -20268;
	// 828B294C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2950: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2954: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2958: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B295C: 48000008  b 0x828b2964
	pc = 0x828B2964; continue 'dispatch;
	// 828B2960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2964: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B296C: 409A0044  bne cr6, 0x828b29b0
	if !ctx.cr[6].eq {
	pc = 0x828B29B0; continue 'dispatch;
	}
	// 828B2970: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2974: 419A001C  beq cr6, 0x828b2990
	if ctx.cr[6].eq {
	pc = 0x828B2990; continue 'dispatch;
	}
	// 828B2978: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B297C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2984: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B298C: 4E800421  bctrl
	ctx.lr = 0x828B2990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2990: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2994: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B299C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B29A0: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B29A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B29A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B29AC: 4BA0D655  bl 0x822c0000
	ctx.lr = 0x828B29B0;
	sub_822C0000(ctx, base);
	// 828B29B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B29B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B29B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B29BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B29C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B29C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B29C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B29D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B29D0 size=196
    let mut pc: u32 = 0x828B29D0;
    'dispatch: loop {
        match pc {
            0x828B29D0 => {
    //   block [0x828B29D0..0x828B2A94)
	// 828B29D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B29D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B29D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B29DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B29E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B29E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B29E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B29EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B29F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B29F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B29F8: 4BA0DF41  bl 0x822c0938
	ctx.lr = 0x828B29FC;
	sub_822C0938(ctx, base);
	// 828B29FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2A00: 41820028  beq 0x828b2a28
	if ctx.cr[0].eq {
	pc = 0x828B2A28; continue 'dispatch;
	}
	// 828B2A04: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2A08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2A0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2A10: 392BB0E8  addi r9, r11, -0x4f18
	ctx.r[9].s64 = ctx.r[11].s64 + -20248;
	// 828B2A14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2A18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2A1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2A20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2A24: 48000008  b 0x828b2a2c
	pc = 0x828B2A2C; continue 'dispatch;
	// 828B2A28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2A2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2A34: 409A0044  bne cr6, 0x828b2a78
	if !ctx.cr[6].eq {
	pc = 0x828B2A78; continue 'dispatch;
	}
	// 828B2A38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2A3C: 419A001C  beq cr6, 0x828b2a58
	if ctx.cr[6].eq {
	pc = 0x828B2A58; continue 'dispatch;
	}
	// 828B2A40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2A44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2A48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2A4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2A50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2A54: 4E800421  bctrl
	ctx.lr = 0x828B2A58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2A58: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2A5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2A64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2A68: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2A6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2A70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2A74: 4BA0D58D  bl 0x822c0000
	ctx.lr = 0x828B2A78;
	sub_822C0000(ctx, base);
	// 828B2A78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2A7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2A88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2A8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2A90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2A98 size=196
    let mut pc: u32 = 0x828B2A98;
    'dispatch: loop {
        match pc {
            0x828B2A98 => {
    //   block [0x828B2A98..0x828B2B5C)
	// 828B2A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2AAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2AB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2AB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2ABC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2AC0: 4BA0DE79  bl 0x822c0938
	ctx.lr = 0x828B2AC4;
	sub_822C0938(ctx, base);
	// 828B2AC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2AC8: 41820028  beq 0x828b2af0
	if ctx.cr[0].eq {
	pc = 0x828B2AF0; continue 'dispatch;
	}
	// 828B2ACC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2AD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2AD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2AD8: 392BB0FC  addi r9, r11, -0x4f04
	ctx.r[9].s64 = ctx.r[11].s64 + -20228;
	// 828B2ADC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2AE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2AE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2AE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2AEC: 48000008  b 0x828b2af4
	pc = 0x828B2AF4; continue 'dispatch;
	// 828B2AF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2AF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2AFC: 409A0044  bne cr6, 0x828b2b40
	if !ctx.cr[6].eq {
	pc = 0x828B2B40; continue 'dispatch;
	}
	// 828B2B00: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2B04: 419A001C  beq cr6, 0x828b2b20
	if ctx.cr[6].eq {
	pc = 0x828B2B20; continue 'dispatch;
	}
	// 828B2B08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2B0C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2B10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2B14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2B18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2B1C: 4E800421  bctrl
	ctx.lr = 0x828B2B20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2B20: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2B24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2B28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2B2C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2B30: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2B34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2B38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2B3C: 4BA0D4C5  bl 0x822c0000
	ctx.lr = 0x828B2B40;
	sub_822C0000(ctx, base);
	// 828B2B40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2B44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2B48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2B4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2B50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2B60 size=196
    let mut pc: u32 = 0x828B2B60;
    'dispatch: loop {
        match pc {
            0x828B2B60 => {
    //   block [0x828B2B60..0x828B2C24)
	// 828B2B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2B68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2B6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2B74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2B78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2B7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2B80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2B84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2B88: 4BA0DDB1  bl 0x822c0938
	ctx.lr = 0x828B2B8C;
	sub_822C0938(ctx, base);
	// 828B2B8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2B90: 41820028  beq 0x828b2bb8
	if ctx.cr[0].eq {
	pc = 0x828B2BB8; continue 'dispatch;
	}
	// 828B2B94: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2B98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2B9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2BA0: 392BB110  addi r9, r11, -0x4ef0
	ctx.r[9].s64 = ctx.r[11].s64 + -20208;
	// 828B2BA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2BA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2BAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2BB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2BB4: 48000008  b 0x828b2bbc
	pc = 0x828B2BBC; continue 'dispatch;
	// 828B2BB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2BBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2BC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2BC4: 409A0044  bne cr6, 0x828b2c08
	if !ctx.cr[6].eq {
	pc = 0x828B2C08; continue 'dispatch;
	}
	// 828B2BC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2BCC: 419A001C  beq cr6, 0x828b2be8
	if ctx.cr[6].eq {
	pc = 0x828B2BE8; continue 'dispatch;
	}
	// 828B2BD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2BD4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2BDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2BE4: 4E800421  bctrl
	ctx.lr = 0x828B2BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2BE8: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2BEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2BF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2BF8: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2BFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2C00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2C04: 4BA0D3FD  bl 0x822c0000
	ctx.lr = 0x828B2C08;
	sub_822C0000(ctx, base);
	// 828B2C08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2C0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2C10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2C14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2C18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2C28 size=196
    let mut pc: u32 = 0x828B2C28;
    'dispatch: loop {
        match pc {
            0x828B2C28 => {
    //   block [0x828B2C28..0x828B2CEC)
	// 828B2C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2C30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2C34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2C38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2C3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2C40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2C44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2C48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2C4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2C50: 4BA0DCE9  bl 0x822c0938
	ctx.lr = 0x828B2C54;
	sub_822C0938(ctx, base);
	// 828B2C54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2C58: 41820028  beq 0x828b2c80
	if ctx.cr[0].eq {
	pc = 0x828B2C80; continue 'dispatch;
	}
	// 828B2C5C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2C60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2C64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2C68: 392BB124  addi r9, r11, -0x4edc
	ctx.r[9].s64 = ctx.r[11].s64 + -20188;
	// 828B2C6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2C70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2C74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2C78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2C7C: 48000008  b 0x828b2c84
	pc = 0x828B2C84; continue 'dispatch;
	// 828B2C80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2C84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2C8C: 409A0044  bne cr6, 0x828b2cd0
	if !ctx.cr[6].eq {
	pc = 0x828B2CD0; continue 'dispatch;
	}
	// 828B2C90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2C94: 419A001C  beq cr6, 0x828b2cb0
	if ctx.cr[6].eq {
	pc = 0x828B2CB0; continue 'dispatch;
	}
	// 828B2C98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2C9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2CA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2CA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2CAC: 4E800421  bctrl
	ctx.lr = 0x828B2CB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2CB0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2CB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2CB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2CBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2CC0: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2CC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2CC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2CCC: 4BA0D335  bl 0x822c0000
	ctx.lr = 0x828B2CD0;
	sub_822C0000(ctx, base);
	// 828B2CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2CD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2CD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2CDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2CE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2CE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2CE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2CF0 size=196
    let mut pc: u32 = 0x828B2CF0;
    'dispatch: loop {
        match pc {
            0x828B2CF0 => {
    //   block [0x828B2CF0..0x828B2DB4)
	// 828B2CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2CF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2CFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2D00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2D04: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2D08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2D0C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2D10: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2D14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2D18: 4BA0DC21  bl 0x822c0938
	ctx.lr = 0x828B2D1C;
	sub_822C0938(ctx, base);
	// 828B2D1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2D20: 41820028  beq 0x828b2d48
	if ctx.cr[0].eq {
	pc = 0x828B2D48; continue 'dispatch;
	}
	// 828B2D24: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2D28: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2D2C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2D30: 392BB138  addi r9, r11, -0x4ec8
	ctx.r[9].s64 = ctx.r[11].s64 + -20168;
	// 828B2D34: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2D38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2D3C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2D40: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2D44: 48000008  b 0x828b2d4c
	pc = 0x828B2D4C; continue 'dispatch;
	// 828B2D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2D4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2D50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2D54: 409A0044  bne cr6, 0x828b2d98
	if !ctx.cr[6].eq {
	pc = 0x828B2D98; continue 'dispatch;
	}
	// 828B2D58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2D5C: 419A001C  beq cr6, 0x828b2d78
	if ctx.cr[6].eq {
	pc = 0x828B2D78; continue 'dispatch;
	}
	// 828B2D60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2D64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2D6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2D74: 4E800421  bctrl
	ctx.lr = 0x828B2D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2D78: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2D7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2D84: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2D88: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2D8C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2D94: 4BA0D26D  bl 0x822c0000
	ctx.lr = 0x828B2D98;
	sub_822C0000(ctx, base);
	// 828B2D98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2D9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2DA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2DA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2DA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2DAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2DB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2DB8 size=196
    let mut pc: u32 = 0x828B2DB8;
    'dispatch: loop {
        match pc {
            0x828B2DB8 => {
    //   block [0x828B2DB8..0x828B2E7C)
	// 828B2DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2DC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2DC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2DC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2DCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2DD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2DD4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2DD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2DDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2DE0: 4BA0DB59  bl 0x822c0938
	ctx.lr = 0x828B2DE4;
	sub_822C0938(ctx, base);
	// 828B2DE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2DE8: 41820028  beq 0x828b2e10
	if ctx.cr[0].eq {
	pc = 0x828B2E10; continue 'dispatch;
	}
	// 828B2DEC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2DF0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2DF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2DF8: 392BB14C  addi r9, r11, -0x4eb4
	ctx.r[9].s64 = ctx.r[11].s64 + -20148;
	// 828B2DFC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2E00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2E04: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2E08: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2E0C: 48000008  b 0x828b2e14
	pc = 0x828B2E14; continue 'dispatch;
	// 828B2E10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2E14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2E1C: 409A0044  bne cr6, 0x828b2e60
	if !ctx.cr[6].eq {
	pc = 0x828B2E60; continue 'dispatch;
	}
	// 828B2E20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2E24: 419A001C  beq cr6, 0x828b2e40
	if ctx.cr[6].eq {
	pc = 0x828B2E40; continue 'dispatch;
	}
	// 828B2E28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2E2C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2E34: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2E38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2E3C: 4E800421  bctrl
	ctx.lr = 0x828B2E40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2E40: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2E44: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2E48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2E4C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2E50: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2E54: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2E58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2E5C: 4BA0D1A5  bl 0x822c0000
	ctx.lr = 0x828B2E60;
	sub_822C0000(ctx, base);
	// 828B2E60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2E64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2E70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2E74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2E80 size=196
    let mut pc: u32 = 0x828B2E80;
    'dispatch: loop {
        match pc {
            0x828B2E80 => {
    //   block [0x828B2E80..0x828B2F44)
	// 828B2E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2E84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2E88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2E8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2E90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2E94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2E98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2E9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2EA0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2EA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2EA8: 4BA0DA91  bl 0x822c0938
	ctx.lr = 0x828B2EAC;
	sub_822C0938(ctx, base);
	// 828B2EAC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2EB0: 41820028  beq 0x828b2ed8
	if ctx.cr[0].eq {
	pc = 0x828B2ED8; continue 'dispatch;
	}
	// 828B2EB4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2EB8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2EBC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2EC0: 392BB160  addi r9, r11, -0x4ea0
	ctx.r[9].s64 = ctx.r[11].s64 + -20128;
	// 828B2EC4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2EC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2ECC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2ED0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2ED4: 48000008  b 0x828b2edc
	pc = 0x828B2EDC; continue 'dispatch;
	// 828B2ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2EDC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2EE4: 409A0044  bne cr6, 0x828b2f28
	if !ctx.cr[6].eq {
	pc = 0x828B2F28; continue 'dispatch;
	}
	// 828B2EE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2EEC: 419A001C  beq cr6, 0x828b2f08
	if ctx.cr[6].eq {
	pc = 0x828B2F08; continue 'dispatch;
	}
	// 828B2EF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2EF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2EFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2F00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2F04: 4E800421  bctrl
	ctx.lr = 0x828B2F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2F08: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2F0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2F14: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2F18: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2F1C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2F20: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2F24: 4BA0D0DD  bl 0x822c0000
	ctx.lr = 0x828B2F28;
	sub_822C0000(ctx, base);
	// 828B2F28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2F2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2F30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2F34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B2F38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B2F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B2F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B2F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B2F48 size=196
    let mut pc: u32 = 0x828B2F48;
    'dispatch: loop {
        match pc {
            0x828B2F48 => {
    //   block [0x828B2F48..0x828B300C)
	// 828B2F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B2F4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B2F50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B2F54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B2F58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B2F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B2F60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2F64: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B2F68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B2F6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2F70: 4BA0D9C9  bl 0x822c0938
	ctx.lr = 0x828B2F74;
	sub_822C0938(ctx, base);
	// 828B2F74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B2F78: 41820028  beq 0x828b2fa0
	if ctx.cr[0].eq {
	pc = 0x828B2FA0; continue 'dispatch;
	}
	// 828B2F7C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B2F80: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B2F84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B2F88: 392BB174  addi r9, r11, -0x4e8c
	ctx.r[9].s64 = ctx.r[11].s64 + -20108;
	// 828B2F8C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B2F90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B2F94: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B2F98: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B2F9C: 48000008  b 0x828b2fa4
	pc = 0x828B2FA4; continue 'dispatch;
	// 828B2FA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B2FA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B2FA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B2FAC: 409A0044  bne cr6, 0x828b2ff0
	if !ctx.cr[6].eq {
	pc = 0x828B2FF0; continue 'dispatch;
	}
	// 828B2FB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B2FB4: 419A001C  beq cr6, 0x828b2fd0
	if ctx.cr[6].eq {
	pc = 0x828B2FD0; continue 'dispatch;
	}
	// 828B2FB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B2FBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B2FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B2FC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B2FC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B2FCC: 4E800421  bctrl
	ctx.lr = 0x828B2FD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B2FD0: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B2FD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B2FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B2FDC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B2FE0: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B2FE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B2FE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B2FEC: 4BA0D015  bl 0x822c0000
	ctx.lr = 0x828B2FF0;
	sub_822C0000(ctx, base);
	// 828B2FF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B2FF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B2FF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B2FFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3000: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B3004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3010 size=196
    let mut pc: u32 = 0x828B3010;
    'dispatch: loop {
        match pc {
            0x828B3010 => {
    //   block [0x828B3010..0x828B30D4)
	// 828B3010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B301C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B3028: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B302C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828B3030: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828B3034: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B3038: 4BA0D901  bl 0x822c0938
	ctx.lr = 0x828B303C;
	sub_822C0938(ctx, base);
	// 828B303C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B3040: 41820028  beq 0x828b3068
	if ctx.cr[0].eq {
	pc = 0x828B3068; continue 'dispatch;
	}
	// 828B3044: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3048: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828B304C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828B3050: 392BB188  addi r9, r11, -0x4e78
	ctx.r[9].s64 = ctx.r[11].s64 + -20088;
	// 828B3054: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828B3058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B305C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828B3060: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828B3064: 48000008  b 0x828b306c
	pc = 0x828B306C; continue 'dispatch;
	// 828B3068: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B306C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B3070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B3074: 409A0044  bne cr6, 0x828b30b8
	if !ctx.cr[6].eq {
	pc = 0x828B30B8; continue 'dispatch;
	}
	// 828B3078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828B307C: 419A001C  beq cr6, 0x828b3098
	if ctx.cr[6].eq {
	pc = 0x828B3098; continue 'dispatch;
	}
	// 828B3080: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3084: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828B3088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B308C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3090: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B3094: 4E800421  bctrl
	ctx.lr = 0x828B3098;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B3098: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B309C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B30A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B30A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828B30A8: 816B1990  lwz r11, 0x1990(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6544 as u32) ) } as u64;
	// 828B30AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828B30B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828B30B4: 4BA0CF4D  bl 0x822c0000
	ctx.lr = 0x828B30B8;
	sub_822C0000(ctx, base);
	// 828B30B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B30BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B30C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B30C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B30C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B30CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B30D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B30D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B30D8 size=172
    let mut pc: u32 = 0x828B30D8;
    'dispatch: loop {
        match pc {
            0x828B30D8 => {
    //   block [0x828B30D8..0x828B3184)
	// 828B30D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B30DC: 488F5089  bl 0x831a8164
	ctx.lr = 0x828B30E0;
	sub_831A8130(ctx, base);
	// 828B30E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B30E4: 3D608337  lis r11, -0x7cc9
	ctx.r[11].s64 = -2093547520;
	// 828B30E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828B30EC: 3BCBEDF4  addi r30, r11, -0x120c
	ctx.r[30].s64 = ctx.r[11].s64 + -4620;
	// 828B30F0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B30F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B30F8: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 828B30FC: 3B6BB1C4  addi r27, r11, -0x4e3c
	ctx.r[27].s64 = ctx.r[11].s64 + -20028;
	// 828B3100: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828B3104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3108: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B310C: 488F59CD  bl 0x831a8ad8
	ctx.lr = 0x828B3110;
	sub_831A8AD8(ctx, base);
	// 828B3110: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B3114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3118: 485408F1  bl 0x82df3a08
	ctx.lr = 0x828B311C;
	sub_82DF3A08(ctx, base);
	// 828B311C: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3120: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828B3124: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B3128: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B312C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 828B3130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B3134: 4E800421  bctrl
	ctx.lr = 0x828B3138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B3138: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B313C: 485402ED  bl 0x82df3428
	ctx.lr = 0x828B3140;
	sub_82DF3428(ctx, base);
	// 828B3140: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828B3144: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3148: 48006091  bl 0x828b91d8
	ctx.lr = 0x828B314C;
	sub_828B91D8(ctx, base);
	// 828B314C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828B3150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3154: 419A0008  beq cr6, 0x828b315c
	if ctx.cr[6].eq {
	pc = 0x828B315C; continue 'dispatch;
	}
	// 828B3158: 4BA0D739  bl 0x822c0890
	ctx.lr = 0x828B315C;
	sub_822C0890(ctx, base);
	// 828B315C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 828B3160: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 828B3164: 3BDE0288  addi r30, r30, 0x288
	ctx.r[30].s64 = ctx.r[30].s64 + 648;
	// 828B3168: 4082FF98  bne 0x828b3100
	if !ctx.cr[0].eq {
	pc = 0x828B3100; continue 'dispatch;
	}
	// 828B316C: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3174: 419A0008  beq cr6, 0x828b317c
	if ctx.cr[6].eq {
	pc = 0x828B317C; continue 'dispatch;
	}
	// 828B3178: 4BA0D719  bl 0x822c0890
	ctx.lr = 0x828B317C;
	sub_822C0890(ctx, base);
	// 828B317C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B3180: 488F5034  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3188 size=108
    let mut pc: u32 = 0x828B3188;
    'dispatch: loop {
        match pc {
            0x828B3188 => {
    //   block [0x828B3188..0x828B31F4)
	// 828B3188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B318C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B3194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B319C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B31A0: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828B31A4: 409A0008  bne cr6, 0x828b31ac
	if !ctx.cr[6].eq {
	pc = 0x828B31AC; continue 'dispatch;
	}
	// 828B31A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B31AC: 83C30370  lwz r30, 0x370(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(880 as u32) ) } as u64;
	// 828B31B0: 38830010  addi r4, r3, 0x10
	ctx.r[4].s64 = ctx.r[3].s64 + 16;
	// 828B31B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B31B8: 4BF39411  bl 0x827ec5c8
	ctx.lr = 0x828B31BC;
	sub_827EC5C8(ctx, base);
	// 828B31BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828B31C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B31C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B31C8: 480057E1  bl 0x828b89a8
	ctx.lr = 0x828B31CC;
	sub_828B89A8(ctx, base);
	// 828B31CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B31D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B31D4: 419A0008  beq cr6, 0x828b31dc
	if ctx.cr[6].eq {
	pc = 0x828B31DC; continue 'dispatch;
	}
	// 828B31D8: 4BA0D6B9  bl 0x822c0890
	ctx.lr = 0x828B31DC;
	sub_822C0890(ctx, base);
	// 828B31DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B31E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B31E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B31E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B31EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B31F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B31F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B31F8 size=284
    let mut pc: u32 = 0x828B31F8;
    'dispatch: loop {
        match pc {
            0x828B31F8 => {
    //   block [0x828B31F8..0x828B3314)
	// 828B31F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B31FC: 488F4F6D  bl 0x831a8168
	ctx.lr = 0x828B3200;
	sub_831A8130(ctx, base);
	// 828B3200: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 828B3204: 488F5875  bl 0x831a8a78
	ctx.lr = 0x828B3208;
	sub_831A8A40(ctx, base);
	// 828B3208: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B320C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3210: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828B3214: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828B3218: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 828B321C: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 828B3220: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828B3224: FFE02090  fmr f31, f4
	ctx.f[31].f64 = ctx.f[4].f64;
	// 828B3228: 817F03B4  lwz r11, 0x3b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828B322C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B3230: 419A0040  beq cr6, 0x828b3270
	if ctx.cr[6].eq {
	pc = 0x828B3270; continue 'dispatch;
	}
	// 828B3234: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828B3238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B323C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B3240: 4BC5C289  bl 0x8250f4c8
	ctx.lr = 0x828B3244;
	sub_8250F4C8(ctx, base);
	// 828B3244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828B324C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 828B3250: 409A0008  bne cr6, 0x828b3258
	if !ctx.cr[6].eq {
	pc = 0x828B3258; continue 'dispatch;
	}
	// 828B3254: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828B3258: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B325C: 80BF03B4  lwz r5, 0x3b4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(948 as u32) ) } as u64;
	// 828B3260: 4BF39031  bl 0x827ec290
	ctx.lr = 0x828B3264;
	sub_827EC290(ctx, base);
	// 828B3264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3268: 4853EA29  bl 0x82df1c90
	ctx.lr = 0x828B326C;
	sub_82DF1C90(ctx, base);
	// 828B326C: 93BF03B4  stw r29, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[29].u32 ) };
	// 828B3270: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828B3274: 4853FF3D  bl 0x82df31b0
	ctx.lr = 0x828B3278;
	sub_82DF31B0(ctx, base);
	// 828B3278: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B327C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B3280: 48540789  bl 0x82df3a08
	ctx.lr = 0x828B3284;
	sub_82DF3A08(ctx, base);
	// 828B3284: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B3288: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828B328C: 388B2318  addi r4, r11, 0x2318
	ctx.r[4].s64 = ctx.r[11].s64 + 8984;
	// 828B3290: 48540779  bl 0x82df3a08
	ctx.lr = 0x828B3294;
	sub_82DF3A08(ctx, base);
	// 828B3294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B3298: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 828B329C: D3C1006C  stfs f30, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828B32A0: D3A10070  stfs f29, 0x70(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B32A4: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 828B32A8: D3810074  stfs f28, 0x74(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828B32AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828B32B0: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828B32B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828B32B8: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B32BC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 828B32C0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828B32C4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828B32C8: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828B32CC: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828B32D0: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828B32D4: 4BF392F5  bl 0x827ec5c8
	ctx.lr = 0x828B32D8;
	sub_827EC5C8(ctx, base);
	// 828B32D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828B32DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B32E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828B32E4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 828B32E8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 828B32EC: 4BF39555  bl 0x827ec840
	ctx.lr = 0x828B32F0;
	sub_827EC840(ctx, base);
	// 828B32F0: 907F03B4  stw r3, 0x3b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(948 as u32), ctx.r[3].u32 ) };
	// 828B32F4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828B32F8: 48540131  bl 0x82df3428
	ctx.lr = 0x828B32FC;
	sub_82DF3428(ctx, base);
	// 828B32FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B3300: 48540129  bl 0x82df3428
	ctx.lr = 0x828B3304;
	sub_82DF3428(ctx, base);
	// 828B3304: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828B3308: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 828B330C: 488F57B9  bl 0x831a8ac4
	ctx.lr = 0x828B3310;
	sub_831A8A8C(ctx, base);
	// 828B3310: 488F4EA8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3318 size=300
    let mut pc: u32 = 0x828B3318;
    'dispatch: loop {
        match pc {
            0x828B3318 => {
    //   block [0x828B3318..0x828B3444)
	// 828B3318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B331C: 488F4E51  bl 0x831a816c
	ctx.lr = 0x828B3320;
	sub_831A8130(ctx, base);
	// 828B3320: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 828B3324: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 828B3328: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B332C: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 828B3330: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 828B3334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B3338: 4BF38E29  bl 0x827ec160
	ctx.lr = 0x828B333C;
	sub_827EC160(ctx, base);
	// 828B333C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B3340: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3344: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B3348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B334C: 4E800421  bctrl
	ctx.lr = 0x828B3350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B3350: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B3354: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B3358: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 828B335C: 480562FD  bl 0x82909658
	ctx.lr = 0x828B3360;
	sub_82909658(ctx, base);
	// 828B3360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828B3364: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 828B3368: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 828B336C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 828B3370: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828B3374: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3448 size=244
    let mut pc: u32 = 0x828B3448;
    'dispatch: loop {
        match pc {
            0x828B3448 => {
    //   block [0x828B3448..0x828B353C)
	// 828B3448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B344C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B3454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3458: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B345C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828B3460: 897E03A0  lbz r11, 0x3a0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(928 as u32) ) } as u64;
	// 828B3464: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B3468: 408200BC  bne 0x828b3524
	if !ctx.cr[0].eq {
	pc = 0x828B3524; continue 'dispatch;
	}
	// 828B346C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B3470: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B3474: 388B3568  addi r4, r11, 0x3568
	ctx.r[4].s64 = ctx.r[11].s64 + 13672;
	// 828B3478: 48540591  bl 0x82df3a08
	ctx.lr = 0x828B347C;
	sub_82DF3A08(ctx, base);
	// 828B347C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828B3480: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828B3484: 388B9EE8  addi r4, r11, -0x6118
	ctx.r[4].s64 = ctx.r[11].s64 + -24856;
	// 828B3488: 48540581  bl 0x82df3a08
	ctx.lr = 0x828B348C;
	sub_82DF3A08(ctx, base);
	// 828B348C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828B3490: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828B3494: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 828B3498: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 828B349C: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 828B34A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828B34A4: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828B34A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828B34AC: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B34B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828B34B4: D0210084  stfs f1, 0x84(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 828B34B8: D0210088  stfs f1, 0x88(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 828B34BC: D021008C  stfs f1, 0x8c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 828B34C0: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 828B34C4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 828B34C8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 828B34CC: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 828B34D0: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 828B34D4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 828B34D8: 4BF39131  bl 0x827ec608
	ctx.lr = 0x828B34DC;
	sub_827EC608(ctx, base);
	// 828B34DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828B34E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B34E4: 38AB9704  addi r5, r11, -0x68fc
	ctx.r[5].s64 = ctx.r[11].s64 + -26876;
	// 828B34E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B34EC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 828B34F0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 828B34F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B34F8: 4E800421  bctrl
	ctx.lr = 0x828B34FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B34FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828B3500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828B3504: 419A0008  beq cr6, 0x828b350c
	if ctx.cr[6].eq {
	pc = 0x828B350C; continue 'dispatch;
	}
	// 828B3508: 4BA0D389  bl 0x822c0890
	ctx.lr = 0x828B350C;
	sub_822C0890(ctx, base);
	// 828B350C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828B3510: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 828B3514: 997E03A0  stb r11, 0x3a0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(928 as u32), ctx.r[11].u8 ) };
	// 828B3518: 4853FF11  bl 0x82df3428
	ctx.lr = 0x828B351C;
	sub_82DF3428(ctx, base);
	// 828B351C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828B3520: 4853FF09  bl 0x82df3428
	ctx.lr = 0x828B3524;
	sub_82DF3428(ctx, base);
	// 828B3524: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828B3528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B352C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3530: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B3534: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3540 size=112
    let mut pc: u32 = 0x828B3540;
    'dispatch: loop {
        match pc {
            0x828B3540 => {
    //   block [0x828B3540..0x828B35B0)
	// 828B3540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3544: 488F4C29  bl 0x831a816c
	ctx.lr = 0x828B3548;
	sub_831A8130(ctx, base);
	// 828B3548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B354C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828B3550: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828B3554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828B3558: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 828B355C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 828B3560: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828B3564: 4853EE85  bl 0x82df23e8
	ctx.lr = 0x828B3568;
	sub_82DF23E8(ctx, base);
	// 828B3568: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B356C: 41820010  beq 0x828b357c
	if ctx.cr[0].eq {
	pc = 0x828B357C; continue 'dispatch;
	}
	// 828B3570: 48006DD1  bl 0x828ba340
	ctx.lr = 0x828B3574;
	sub_828BA340(ctx, base);
	// 828B3574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3578: 48000008  b 0x828b3580
	pc = 0x828B3580; continue 'dispatch;
	// 828B357C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828B3580: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828B3584: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828B3588: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B358C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B3590: 4BFFEBA9  bl 0x828b2138
	ctx.lr = 0x828B3594;
	sub_828B2138(ctx, base);
	// 828B3594: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828B3598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828B359C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828B35A0: 4BA0CA61  bl 0x822c0000
	ctx.lr = 0x828B35A4;
	sub_822C0000(ctx, base);
	// 828B35A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828B35A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B35AC: 488F4C10  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B35B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B35B0 size=116
    let mut pc: u32 = 0x828B35B0;
    'dispatch: loop {
        match pc {
            0x828B35B0 => {
    //   block [0x828B35B0..0x828B3624)
	// 828B35B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B35B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B35B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B35BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B35C0: F8810080  std r4, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[4].u64 ) };
	// 828B35C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B35C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B35CC: F8A10088  std r5, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[5].u64 ) };
	// 828B35D0: F8C10090  std r6, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[6].u64 ) };
	// 828B35D4: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 828B35D8: F8E10098  std r7, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[7].u64 ) };
	// 828B35DC: 4BFFE685  bl 0x828b1c60
	ctx.lr = 0x828B35E0;
	sub_828B1C60(ctx, base);
	// 828B35E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B35E4: 41820028  beq 0x828b360c
	if ctx.cr[0].eq {
	pc = 0x828B360C; continue 'dispatch;
	}
	// 828B35E8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 828B35EC: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 828B35F0: E92B0008  ld r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 828B35F4: E90B0010  ld r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 828B35F8: E96B0018  ld r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 828B35FC: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 828B3600: F9230008  std r9, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 828B3604: F9030010  std r8, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 828B3608: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 828B360C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828B3610: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B3614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B3618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B361C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3628 size=72
    let mut pc: u32 = 0x828B3628;
    'dispatch: loop {
        match pc {
            0x828B3628 => {
    //   block [0x828B3628..0x828B3670)
	// 828B3628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B362C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3630: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B3634: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828B3638: 419A001C  beq cr6, 0x828b3654
	if ctx.cr[6].eq {
	pc = 0x828B3654; continue 'dispatch;
	}
	// 828B363C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B3640: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B3644: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B3648: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B364C: 4BFFE505  bl 0x828b1b50
	ctx.lr = 0x828B3650;
	sub_828B1B50(ctx, base);
	// 828B3650: 48000010  b 0x828b3660
	pc = 0x828B3660; continue 'dispatch;
	// 828B3654: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B3658: 396B2118  addi r11, r11, 0x2118
	ctx.r[11].s64 = ctx.r[11].s64 + 8472;
	// 828B365C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B3660: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B3664: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B3668: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B366C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3670 size=72
    let mut pc: u32 = 0x828B3670;
    'dispatch: loop {
        match pc {
            0x828B3670 => {
    //   block [0x828B3670..0x828B36B8)
	// 828B3670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B3674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3678: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B367C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 828B3680: 419A001C  beq cr6, 0x828b369c
	if ctx.cr[6].eq {
	pc = 0x828B369C; continue 'dispatch;
	}
	// 828B3684: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828B3688: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828B368C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 828B3690: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828B3694: 4BFFE545  bl 0x828b1bd8
	ctx.lr = 0x828B3698;
	sub_828B1BD8(ctx, base);
	// 828B3698: 48000010  b 0x828b36a8
	pc = 0x828B36A8; continue 'dispatch;
	// 828B369C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B36A0: 396B21D8  addi r11, r11, 0x21d8
	ctx.r[11].s64 = ctx.r[11].s64 + 8664;
	// 828B36A4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B36A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828B36AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B36B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B36B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B36B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B36B8 size=176
    let mut pc: u32 = 0x828B36B8;
    'dispatch: loop {
        match pc {
            0x828B36B8 => {
    //   block [0x828B36B8..0x828B3768)
	// 828B36B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B36BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B36C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B36C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B36C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B36CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B36D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B36D4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B36D8: 409A0044  bne cr6, 0x828b371c
	if !ctx.cr[6].eq {
	pc = 0x828B371C; continue 'dispatch;
	}
	// 828B36DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B36E0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B36E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B36E8: 4BFFE579  bl 0x828b1c60
	ctx.lr = 0x828B36EC;
	sub_828B1C60(ctx, base);
	// 828B36EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B36F0: 41820024  beq 0x828b3714
	if ctx.cr[0].eq {
	pc = 0x828B3714; continue 'dispatch;
	}
	// 828B36F4: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 828B36F8: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B36FC: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 828B3700: F9630008  std r11, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828B3704: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 828B3708: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828B370C: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828B3710: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 828B3714: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828B3718: 4800001C  b 0x828b3734
	pc = 0x828B3734; continue 'dispatch;
	// 828B371C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3720: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828B3724: 409A0028  bne cr6, 0x828b374c
	if !ctx.cr[6].eq {
	pc = 0x828B374C; continue 'dispatch;
	}
	// 828B3728: 4BA0CB41  bl 0x822c0268
	ctx.lr = 0x828B372C;
	sub_822C0268(ctx, base);
	// 828B372C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B3730: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B3734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B3738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B373C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B3744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3748: 4E800020  blr
	return;
	// 828B374C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B3750: 388B2288  addi r4, r11, 0x2288
	ctx.r[4].s64 = ctx.r[11].s64 + 8840;
	// 828B3754: 488F49A5  bl 0x831a80f8
	ctx.lr = 0x828B3758;
	sub_831A80F8(ctx, base);
	// 828B3758: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B375C: 4182FFD0  beq 0x828b372c
	if ctx.cr[0].eq {
	pc = 0x828B372C; continue 'dispatch;
	}
	// 828B3760: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3764: 4BFFFFCC  b 0x828b3730
	pc = 0x828B3730; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828B3768 size=176
    let mut pc: u32 = 0x828B3768;
    'dispatch: loop {
        match pc {
            0x828B3768 => {
    //   block [0x828B3768..0x828B3818)
	// 828B3768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B376C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B3774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B377C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828B3784: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 828B3788: 409A0044  bne cr6, 0x828b37cc
	if !ctx.cr[6].eq {
	pc = 0x828B37CC; continue 'dispatch;
	}
	// 828B378C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 828B3790: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3794: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 828B3798: 4BFFE4C9  bl 0x828b1c60
	ctx.lr = 0x828B379C;
	sub_828B1C60(ctx, base);
	// 828B379C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828B37A0: 41820024  beq 0x828b37c4
	if ctx.cr[0].eq {
	pc = 0x828B37C4; continue 'dispatch;
	}
	// 828B37A4: E97F0000  ld r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 828B37A8: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828B37AC: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 828B37B0: F9630008  std r11, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 828B37B4: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 828B37B8: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 828B37BC: E97F0018  ld r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	// 828B37C0: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 828B37C4: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 828B37C8: 4800001C  b 0x828b37e4
	pc = 0x828B37E4; continue 'dispatch;
	// 828B37CC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B37D0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 828B37D4: 409A0028  bne cr6, 0x828b37fc
	if !ctx.cr[6].eq {
	pc = 0x828B37FC; continue 'dispatch;
	}
	// 828B37D8: 4BA0CA91  bl 0x822c0268
	ctx.lr = 0x828B37DC;
	sub_822C0268(ctx, base);
	// 828B37DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828B37E0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828B37E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B37E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B37EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B37F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B37F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B37F8: 4E800020  blr
	return;
	// 828B37FC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 828B3800: 388B2360  addi r4, r11, 0x2360
	ctx.r[4].s64 = ctx.r[11].s64 + 9056;
	// 828B3804: 488F48F5  bl 0x831a80f8
	ctx.lr = 0x828B3808;
	sub_831A80F8(ctx, base);
	// 828B3808: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828B380C: 4182FFD0  beq 0x828b37dc
	if ctx.cr[0].eq {
	pc = 0x828B37DC; continue 'dispatch;
	}
	// 828B3810: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3814: 4BFFFFCC  b 0x828b37e0
	pc = 0x828B37E0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828B3818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828B3818 size=116
    let mut pc: u32 = 0x828B3818;
    'dispatch: loop {
        match pc {
            0x828B3818 => {
    //   block [0x828B3818..0x828B388C)
	// 828B3818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828B381C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828B3820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828B3824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828B3828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828B382C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828B3830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3834: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828B3838: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B383C: 485401CD  bl 0x82df3a08
	ctx.lr = 0x828B3840;
	sub_82DF3A08(ctx, base);
	// 828B3840: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3844: C09F0014  lfs f4, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 828B3848: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828B384C: C07F0010  lfs f3, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 828B3850: C05F000C  lfs f2, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 828B3854: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828B3858: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 828B385C: C03F0008  lfs f1, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828B3860: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828B3864: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828B3868: 4E800421  bctrl
	ctx.lr = 0x828B386C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828B386C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828B3870: 4853FBB9  bl 0x82df3428
	ctx.lr = 0x828B3874;
	sub_82DF3428(ctx, base);
	// 828B3874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828B3878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828B387C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828B3880: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828B3884: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828B3888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


