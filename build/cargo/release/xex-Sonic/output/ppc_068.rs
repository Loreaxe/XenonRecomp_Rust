pub fn sub_826C4AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C4AF8 size=232
    let mut pc: u32 = 0x826C4AF8;
    'dispatch: loop {
        match pc {
            0x826C4AF8 => {
    //   block [0x826C4AF8..0x826C4BE0)
	// 826C4AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4AFC: 48AE365D  bl 0x831a8158
	ctx.lr = 0x826C4B00;
	sub_831A8130(ctx, base);
	// 826C4B00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C4B08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C4B0C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 826C4B10: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 826C4B14: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 826C4B18: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826C4B1C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826C4B20: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826C4B24: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826C4B28: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 826C4B2C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 826C4B30: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 826C4B34: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 826C4B38: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 826C4B3C: 7D585378  mr r24, r10
	ctx.r[24].u64 = ctx.r[10].u64;
	// 826C4B40: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 826C4B44: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 826C4B48: 4872F0B9  bl 0x82df3c00
	ctx.lr = 0x826C4B4C;
	sub_82DF3C00(ctx, base);
	// 826C4B4C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826C4B50: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 826C4B54: 4872F0AD  bl 0x82df3c00
	ctx.lr = 0x826C4B58;
	sub_82DF3C00(ctx, base);
	// 826C4B58: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826C4B5C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826C4B60: 4872F0A1  bl 0x82df3c00
	ctx.lr = 0x826C4B64;
	sub_82DF3C00(ctx, base);
	// 826C4B64: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 826C4B68: 808100F4  lwz r4, 0xf4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 826C4B6C: 4872F095  bl 0x82df3c00
	ctx.lr = 0x826C4B70;
	sub_82DF3C00(ctx, base);
	// 826C4B70: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 826C4B74: 808100FC  lwz r4, 0xfc(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 826C4B78: 4872F089  bl 0x82df3c00
	ctx.lr = 0x826C4B7C;
	sub_82DF3C00(ctx, base);
	// 826C4B7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826C4B80: 419A0030  beq cr6, 0x826c4bb0
	if ctx.cr[6].eq {
	pc = 0x826C4BB0; continue 'dispatch;
	}
	// 826C4B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C4B88: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4B8C: 4872EE7D  bl 0x82df3a08
	ctx.lr = 0x826C4B90;
	sub_82DF3A08(ctx, base);
	// 826C4B90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C4B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C4B98: 4BC2A191  bl 0x822eed28
	ctx.lr = 0x826C4B9C;
	sub_822EED28(ctx, base);
	// 826C4B9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C4BA0: 4872E889  bl 0x82df3428
	ctx.lr = 0x826C4BA4;
	sub_82DF3428(ctx, base);
	// 826C4BA4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826C4BA8: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 826C4BAC: 4082FFD8  bne 0x826c4b84
	if !ctx.cr[0].eq {
	pc = 0x826C4B84; continue 'dispatch;
	}
	// 826C4BB0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 826C4BB4: 419A0020  beq cr6, 0x826c4bd4
	if ctx.cr[6].eq {
	pc = 0x826C4BD4; continue 'dispatch;
	}
	// 826C4BB8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 826C4BBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C4BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C4BC4: 4BDF454D  bl 0x824b9110
	ctx.lr = 0x826C4BC8;
	sub_824B9110(ctx, base);
	// 826C4BC8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826C4BCC: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 826C4BD0: 4082FFEC  bne 0x826c4bbc
	if !ctx.cr[0].eq {
	pc = 0x826C4BBC; continue 'dispatch;
	}
	// 826C4BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C4BD8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826C4BDC: 48AE35CC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C4BE0 size=196
    let mut pc: u32 = 0x826C4BE0;
    'dispatch: loop {
        match pc {
            0x826C4BE0 => {
    //   block [0x826C4BE0..0x826C4CA4)
	// 826C4BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C4BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C4BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C4BF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4BF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C4BF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C4BFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C4C00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C4C04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C4C08: 4BBFBD31  bl 0x822c0938
	ctx.lr = 0x826C4C0C;
	sub_822C0938(ctx, base);
	// 826C4C0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C4C10: 41820028  beq 0x826c4c38
	if ctx.cr[0].eq {
	pc = 0x826C4C38; continue 'dispatch;
	}
	// 826C4C14: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C4C18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C4C1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C4C20: 392B8084  addi r9, r11, -0x7f7c
	ctx.r[9].s64 = ctx.r[11].s64 + -32636;
	// 826C4C24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C4C28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C4C2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C4C30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C4C34: 48000008  b 0x826c4c3c
	pc = 0x826C4C3C; continue 'dispatch;
	// 826C4C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C4C3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C4C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C4C44: 409A0044  bne cr6, 0x826c4c88
	if !ctx.cr[6].eq {
	pc = 0x826C4C88; continue 'dispatch;
	}
	// 826C4C48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C4C4C: 419A001C  beq cr6, 0x826c4c68
	if ctx.cr[6].eq {
	pc = 0x826C4C68; continue 'dispatch;
	}
	// 826C4C50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4C54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C4C58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C4C5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826C4C64: 4E800421  bctrl
	ctx.lr = 0x826C4C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826C4C68: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C4C6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C4C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C4C74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C4C78: 816BC5E8  lwz r11, -0x3a18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14872 as u32) ) } as u64;
	// 826C4C7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C4C80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C4C84: 4BBFB37D  bl 0x822c0000
	ctx.lr = 0x826C4C88;
	sub_822C0000(ctx, base);
	// 826C4C88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C4C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C4C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C4C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C4C98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C4C9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C4CA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C4CA8 size=196
    let mut pc: u32 = 0x826C4CA8;
    'dispatch: loop {
        match pc {
            0x826C4CA8 => {
    //   block [0x826C4CA8..0x826C4D6C)
	// 826C4CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C4CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C4CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C4CB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4CBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C4CC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C4CC4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C4CC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C4CCC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C4CD0: 4BBFBC69  bl 0x822c0938
	ctx.lr = 0x826C4CD4;
	sub_822C0938(ctx, base);
	// 826C4CD4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C4CD8: 41820028  beq 0x826c4d00
	if ctx.cr[0].eq {
	pc = 0x826C4D00; continue 'dispatch;
	}
	// 826C4CDC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C4CE0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C4CE4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C4CE8: 392B80AC  addi r9, r11, -0x7f54
	ctx.r[9].s64 = ctx.r[11].s64 + -32596;
	// 826C4CEC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C4CF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C4CF4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C4CF8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C4CFC: 48000008  b 0x826c4d04
	pc = 0x826C4D04; continue 'dispatch;
	// 826C4D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C4D04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C4D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C4D0C: 409A0044  bne cr6, 0x826c4d50
	if !ctx.cr[6].eq {
	pc = 0x826C4D50; continue 'dispatch;
	}
	// 826C4D10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C4D14: 419A001C  beq cr6, 0x826c4d30
	if ctx.cr[6].eq {
	pc = 0x826C4D30; continue 'dispatch;
	}
	// 826C4D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4D1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C4D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C4D24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826C4D2C: 4E800421  bctrl
	ctx.lr = 0x826C4D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826C4D30: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C4D34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C4D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C4D3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C4D40: 816BC5E8  lwz r11, -0x3a18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14872 as u32) ) } as u64;
	// 826C4D44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C4D48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C4D4C: 4BBFB2B5  bl 0x822c0000
	ctx.lr = 0x826C4D50;
	sub_822C0000(ctx, base);
	// 826C4D50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C4D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C4D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C4D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C4D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C4D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C4D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C4D70 size=228
    let mut pc: u32 = 0x826C4D70;
    'dispatch: loop {
        match pc {
            0x826C4D70 => {
    //   block [0x826C4D70..0x826C4E54)
	// 826C4D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4D74: 48AE33F5  bl 0x831a8168
	ctx.lr = 0x826C4D78;
	sub_831A8130(ctx, base);
	// 826C4D78: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C4D80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826C4D84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C4D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C4D8C: 4BE4A5A5  bl 0x8250f330
	ctx.lr = 0x826C4D90;
	sub_8250F330(ctx, base);
	// 826C4D90: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4D94: 4BE24ABD  bl 0x824e9850
	ctx.lr = 0x826C4D98;
	sub_824E9850(ctx, base);
	// 826C4D98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C4D9C: D0210070  stfs f1, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826C4DA0: 4872CEF1  bl 0x82df1c90
	ctx.lr = 0x826C4DA4;
	sub_82DF1C90(ctx, base);
	// 826C4DA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C4DA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C4DAC: 4BE4A585  bl 0x8250f330
	ctx.lr = 0x826C4DB0;
	sub_8250F330(ctx, base);
	// 826C4DB0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4DB4: 4BE24A9D  bl 0x824e9850
	ctx.lr = 0x826C4DB8;
	sub_824E9850(ctx, base);
	// 826C4DB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C4DBC: D0210074  stfs f1, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826C4DC0: 4872CED1  bl 0x82df1c90
	ctx.lr = 0x826C4DC4;
	sub_82DF1C90(ctx, base);
	// 826C4DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C4DC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C4DCC: 4BE4A565  bl 0x8250f330
	ctx.lr = 0x826C4DD0;
	sub_8250F330(ctx, base);
	// 826C4DD0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4DD4: 4BE24A7D  bl 0x824e9850
	ctx.lr = 0x826C4DD8;
	sub_824E9850(ctx, base);
	// 826C4DD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C4DDC: D0210078  stfs f1, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826C4DE0: 4872CEB1  bl 0x82df1c90
	ctx.lr = 0x826C4DE4;
	sub_82DF1C90(ctx, base);
	// 826C4DE4: 3BDF0118  addi r30, r31, 0x118
	ctx.r[30].s64 = ctx.r[31].s64 + 280;
	// 826C4DE8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 826C4DEC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826C4DF0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C4DF4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C4DF8: 13C0F407  vcmpneb. (lvlx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C4E58 size=88
    let mut pc: u32 = 0x826C4E58;
    'dispatch: loop {
        match pc {
            0x826C4E58 => {
    //   block [0x826C4E58..0x826C4EB0)
	// 826C4E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C4E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C4E64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4E68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C4E6C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 826C4E70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C4E74: 419A0008  beq cr6, 0x826c4e7c
	if ctx.cr[6].eq {
	pc = 0x826C4E7C; continue 'dispatch;
	}
	// 826C4E78: 4BBFBA19  bl 0x822c0890
	ctx.lr = 0x826C4E7C;
	sub_822C0890(ctx, base);
	// 826C4E7C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 826C4E80: 4872E5A9  bl 0x82df3428
	ctx.lr = 0x826C4E84;
	sub_82DF3428(ctx, base);
	// 826C4E84: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C4E88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C4E8C: 419A0008  beq cr6, 0x826c4e94
	if ctx.cr[6].eq {
	pc = 0x826C4E94; continue 'dispatch;
	}
	// 826C4E90: 4BBFBA01  bl 0x822c0890
	ctx.lr = 0x826C4E94;
	sub_822C0890(ctx, base);
	// 826C4E94: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 826C4E98: 4872E591  bl 0x82df3428
	ctx.lr = 0x826C4E9C;
	sub_82DF3428(ctx, base);
	// 826C4E9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C4EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C4EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C4EA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C4EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C4EB0 size=172
    let mut pc: u32 = 0x826C4EB0;
    'dispatch: loop {
        match pc {
            0x826C4EB0 => {
    //   block [0x826C4EB0..0x826C4F5C)
	// 826C4EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4EB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C4EB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C4EBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C4EC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4EC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C4EC8: 807E010C  lwz r3, 0x10c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(268 as u32) ) } as u64;
	// 826C4ECC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C4ED0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C4ED4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826C4ED8: 4E800421  bctrl
	ctx.lr = 0x826C4EDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826C4EDC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826C4EE0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826C4EE4: 815E00F4  lwz r10, 0xf4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 826C4EE8: 39000030  li r8, 0x30
	ctx.r[8].s64 = 48;
	// 826C4EEC: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C4EF0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826C4EF4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826C4EF8: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C4EFC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 826C4F00: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 826C4F04: 13A91C07  vcmpneb. (lvlx128) v29, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C4F08: 13881C07  vcmpneb. (lvlx128) v28, v8, v3
	tmp.u32 = ctx.r[8].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C4F60 size=112
    let mut pc: u32 = 0x826C4F60;
    'dispatch: loop {
        match pc {
            0x826C4F60 => {
    //   block [0x826C4F60..0x826C4FD0)
	// 826C4F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C4F68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C4F6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C4F70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4F74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C4F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C4F7C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826C4F80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C4F84: 4BFFFD25  bl 0x826c4ca8
	ctx.lr = 0x826C4F88;
	sub_826C4CA8(ctx, base);
	// 826C4F88: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826C4F8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C4F90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C4F94: 4BBFB06D  bl 0x822c0000
	ctx.lr = 0x826C4F98;
	sub_822C0000(ctx, base);
	// 826C4F98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C4F9C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C4FA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C4FA4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C4FA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C4FAC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C4FB0: 419A0008  beq cr6, 0x826c4fb8
	if ctx.cr[6].eq {
	pc = 0x826C4FB8; continue 'dispatch;
	}
	// 826C4FB4: 4BBFB8DD  bl 0x822c0890
	ctx.lr = 0x826C4FB8;
	sub_822C0890(ctx, base);
	// 826C4FB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C4FBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C4FC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C4FC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C4FC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C4FCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C4FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C4FD0 size=148
    let mut pc: u32 = 0x826C4FD0;
    'dispatch: loop {
        match pc {
            0x826C4FD0 => {
    //   block [0x826C4FD0..0x826C5064)
	// 826C4FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C4FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C4FD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C4FDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C4FE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C4FE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C4FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C4FEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C4FF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C4FF4: 388B80C4  addi r4, r11, -0x7f3c
	ctx.r[4].s64 = ctx.r[11].s64 + -32572;
	// 826C4FF8: 4872EA11  bl 0x82df3a08
	ctx.lr = 0x826C4FFC;
	sub_82DF3A08(ctx, base);
	// 826C4FFC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C5000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5004: 388B80BC  addi r4, r11, -0x7f44
	ctx.r[4].s64 = ctx.r[11].s64 + -32580;
	// 826C5008: 4872EA01  bl 0x82df3a08
	ctx.lr = 0x826C500C;
	sub_82DF3A08(ctx, base);
	// 826C500C: 38BF0038  addi r5, r31, 0x38
	ctx.r[5].s64 = ctx.r[31].s64 + 56;
	// 826C5010: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826C5014: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C5018: 4BEDE039  bl 0x825a3050
	ctx.lr = 0x826C501C;
	sub_825A3050(ctx, base);
	// 826C501C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826C5020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C5024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C5028: 4BEDD161  bl 0x825a2188
	ctx.lr = 0x826C502C;
	sub_825A2188(ctx, base);
	// 826C502C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826C5030: 4872E3F9  bl 0x82df3428
	ctx.lr = 0x826C5034;
	sub_82DF3428(ctx, base);
	// 826C5034: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C5038: 4BC03C81  bl 0x822c8cb8
	ctx.lr = 0x826C503C;
	sub_822C8CB8(ctx, base);
	// 826C503C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5040: 4872E3E9  bl 0x82df3428
	ctx.lr = 0x826C5044;
	sub_82DF3428(ctx, base);
	// 826C5044: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C5048: 4872E3E1  bl 0x82df3428
	ctx.lr = 0x826C504C;
	sub_82DF3428(ctx, base);
	// 826C504C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826C5050: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C5054: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5058: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C505C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C5060: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5068 size=188
    let mut pc: u32 = 0x826C5068;
    'dispatch: loop {
        match pc {
            0x826C5068 => {
    //   block [0x826C5068..0x826C5124)
	// 826C5068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C506C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5070: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C5074: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5078: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C507C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C5080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C5084: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C5088: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C508C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C5090: 4BBFB8A9  bl 0x822c0938
	ctx.lr = 0x826C5094;
	sub_822C0938(ctx, base);
	// 826C5094: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C5098: 41820028  beq 0x826c50c0
	if ctx.cr[0].eq {
	pc = 0x826C50C0; continue 'dispatch;
	}
	// 826C509C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C50A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C50A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C50A8: 392B8098  addi r9, r11, -0x7f68
	ctx.r[9].s64 = ctx.r[11].s64 + -32616;
	// 826C50AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C50B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C50B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C50B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C50BC: 48000008  b 0x826c50c4
	pc = 0x826C50C4; continue 'dispatch;
	// 826C50C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C50C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C50C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C50CC: 409A003C  bne cr6, 0x826c5108
	if !ctx.cr[6].eq {
	pc = 0x826C5108; continue 'dispatch;
	}
	// 826C50D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C50D4: 419A0014  beq cr6, 0x826c50e8
	if ctx.cr[6].eq {
	pc = 0x826C50E8; continue 'dispatch;
	}
	// 826C50D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C50DC: 4BFFFD7D  bl 0x826c4e58
	ctx.lr = 0x826C50E0;
	sub_826C4E58(ctx, base);
	// 826C50E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C50E4: 4872D2F5  bl 0x82df23d8
	ctx.lr = 0x826C50E8;
	sub_82DF23D8(ctx, base);
	// 826C50E8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C50EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C50F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C50F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C50F8: 816BC5E8  lwz r11, -0x3a18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14872 as u32) ) } as u64;
	// 826C50FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C5100: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C5104: 4BBFAEFD  bl 0x822c0000
	ctx.lr = 0x826C5108;
	sub_822C0000(ctx, base);
	// 826C5108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C510C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C5110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C5114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5118: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C511C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C5120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5128 size=64
    let mut pc: u32 = 0x826C5128;
    'dispatch: loop {
        match pc {
            0x826C5128 => {
    //   block [0x826C5128..0x826C5168)
	// 826C5128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C512C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5134: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5138: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C513C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C5140: 419A0014  beq cr6, 0x826c5154
	if ctx.cr[6].eq {
	pc = 0x826C5154; continue 'dispatch;
	}
	// 826C5144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5148: 4BFFFD11  bl 0x826c4e58
	ctx.lr = 0x826C514C;
	sub_826C4E58(ctx, base);
	// 826C514C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5150: 4872D289  bl 0x82df23d8
	ctx.lr = 0x826C5154;
	sub_82DF23D8(ctx, base);
	// 826C5154: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C5158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C515C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C5164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5168 size=120
    let mut pc: u32 = 0x826C5168;
    'dispatch: loop {
        match pc {
            0x826C5168 => {
    //   block [0x826C5168..0x826C51E0)
	// 826C5168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C516C: 48AE2FFD  bl 0x831a8168
	ctx.lr = 0x826C5170;
	sub_831A8130(ctx, base);
	// 826C5170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5174: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C5178: 83850000  lwz r28, 0(r5)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C517C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 826C5180: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C5184: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5188: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C518C: 419A0044  beq cr6, 0x826c51d0
	if ctx.cr[6].eq {
	pc = 0x826C51D0; continue 'dispatch;
	}
	// 826C5190: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5194: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826C5198: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C519C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C51A0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826C51A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C51A8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C51AC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C51B0: 4BEFFF29  bl 0x825c50d8
	ctx.lr = 0x826C51B4;
	sub_825C50D8(ctx, base);
	// 826C51B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C51B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C51BC: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 826C51C0: 4872CFC9  bl 0x82df2188
	ctx.lr = 0x826C51C4;
	sub_82DF2188(ctx, base);
	// 826C51C4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826C51C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826C51CC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826C51D0: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 826C51D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C51D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826C51DC: 48AE2FDC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C51E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C51E0 size=108
    let mut pc: u32 = 0x826C51E0;
    'dispatch: loop {
        match pc {
            0x826C51E0 => {
    //   block [0x826C51E0..0x826C524C)
	// 826C51E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C51E4: 48AE2F81  bl 0x831a8164
	ctx.lr = 0x826C51E8;
	sub_831A8130(ctx, base);
	// 826C51E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C51EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C51F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826C51F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826C51F8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 826C51FC: 817E00F4  lwz r11, 0xf4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 826C5200: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5204: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C5208: 419A003C  beq cr6, 0x826c5244
	if ctx.cr[6].eq {
	pc = 0x826C5244; continue 'dispatch;
	}
	// 826C520C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826C5210: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826C5214: 48003615  bl 0x826c8828
	ctx.lr = 0x826C5218;
	sub_826C8828(ctx, base);
	// 826C5218: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C521C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826C5220: 48003199  bl 0x826c83b8
	ctx.lr = 0x826C5224;
	sub_826C83B8(ctx, base);
	// 826C5224: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826C5228: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C522C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826C5230: 48003191  bl 0x826c83c0
	ctx.lr = 0x826C5234;
	sub_826C83C0(ctx, base);
	// 826C5234: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C5238: 389E00F0  addi r4, r30, 0xf0
	ctx.r[4].s64 = ctx.r[30].s64 + 240;
	// 826C523C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5240: 4BFFFF29  bl 0x826c5168
	ctx.lr = 0x826C5244;
	sub_826C5168(ctx, base);
	// 826C5244: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826C5248: 48AE2F6C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C5250 size=364
    let mut pc: u32 = 0x826C5250;
    'dispatch: loop {
        match pc {
            0x826C5250 => {
    //   block [0x826C5250..0x826C53BC)
	// 826C5250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5254: 48AE2F11  bl 0x831a8164
	ctx.lr = 0x826C5258;
	sub_831A8130(ctx, base);
	// 826C5258: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C525C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C5260: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 826C5264: 897F011C  lbz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826C5268: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C526C: 40820148  bne 0x826c53b4
	if !ctx.cr[0].eq {
	pc = 0x826C53B4; continue 'dispatch;
	}
	// 826C5270: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826C5274: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5278: 809F0114  lwz r4, 0x114(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826C527C: 4BFFF83D  bl 0x826c4ab8
	ctx.lr = 0x826C5280;
	sub_826C4AB8(ctx, base);
	// 826C5280: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5284: 41820130  beq 0x826c53b4
	if ctx.cr[0].eq {
	pc = 0x826C53B4; continue 'dispatch;
	}
	// 826C5288: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C528C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C5290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C5294: 419A0058  beq cr6, 0x826c52ec
	if ctx.cr[6].eq {
	pc = 0x826C52EC; continue 'dispatch;
	}
	// 826C5298: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826C529C: 3BDB0050  addi r30, r27, 0x50
	ctx.r[30].s64 = ctx.r[27].s64 + 80;
	// 826C52A0: 3B9B0040  addi r28, r27, 0x40
	ctx.r[28].s64 = ctx.r[27].s64 + 64;
	// 826C52A4: C00BD5B8  lfs f0, -0x2a48(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826C52A8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826C52AC: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 826C52B0: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C52B4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826C52B8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826C52BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826C52C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C52C4: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C52C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C53C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C53C0 size=112
    let mut pc: u32 = 0x826C53C0;
    'dispatch: loop {
        match pc {
            0x826C53C0 => {
    //   block [0x826C53C0..0x826C5430)
	// 826C53C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C53C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C53C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C53CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C53D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C53D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C53D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C53DC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826C53E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C53E4: 4BFFFC85  bl 0x826c5068
	ctx.lr = 0x826C53E8;
	sub_826C5068(ctx, base);
	// 826C53E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826C53EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C53F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C53F4: 4BBFAC0D  bl 0x822c0000
	ctx.lr = 0x826C53F8;
	sub_822C0000(ctx, base);
	// 826C53F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C53FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C5400: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C5404: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5408: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C540C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C5410: 419A0008  beq cr6, 0x826c5418
	if ctx.cr[6].eq {
	pc = 0x826C5418; continue 'dispatch;
	}
	// 826C5414: 4BBFB47D  bl 0x822c0890
	ctx.lr = 0x826C5418;
	sub_822C0890(ctx, base);
	// 826C5418: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C541C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C5420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5424: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C5428: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C542C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5430 size=108
    let mut pc: u32 = 0x826C5430;
    'dispatch: loop {
        match pc {
            0x826C5430 => {
    //   block [0x826C5430..0x826C549C)
	// 826C5430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5434: 48AE2D39  bl 0x831a816c
	ctx.lr = 0x826C5438;
	sub_831A8130(ctx, base);
	// 826C5438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C543C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826C5440: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C5444: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C5448: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C544C: 41820038  beq 0x826c5484
	if ctx.cr[0].eq {
	pc = 0x826C5484; continue 'dispatch;
	}
	// 826C5450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5454: 48AE4535  bl 0x831a9988
	ctx.lr = 0x826C5458;
	sub_831A9988(ctx, base);
	// 826C5458: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 826C545C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5460: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 826C5464: 48AE2C95  bl 0x831a80f8
	ctx.lr = 0x826C5468;
	sub_831A80F8(ctx, base);
	// 826C5468: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C546C: 41820018  beq 0x826c5484
	if ctx.cr[0].eq {
	pc = 0x826C5484; continue 'dispatch;
	}
	// 826C5470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5474: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 826C5478: 4BFFFDD9  bl 0x826c5250
	ctx.lr = 0x826C547C;
	sub_826C5250(ctx, base);
	// 826C547C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826C5480: 48000014  b 0x826c5494
	pc = 0x826C5494; continue 'dispatch;
	// 826C5484: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826C5488: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C548C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C5490: 4BE4D189  bl 0x82512618
	ctx.lr = 0x826C5494;
	sub_82512618(ctx, base);
	// 826C5494: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C5498: 48AE2D24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C54A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C54A0 size=96
    let mut pc: u32 = 0x826C54A0;
    'dispatch: loop {
        match pc {
            0x826C54A0 => {
    //   block [0x826C54A0..0x826C5500)
	// 826C54A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C54A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C54A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C54AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C54B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C54B4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 826C54B8: 4872DF71  bl 0x82df3428
	ctx.lr = 0x826C54BC;
	sub_82DF3428(ctx, base);
	// 826C54BC: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 826C54C0: 4872DF69  bl 0x82df3428
	ctx.lr = 0x826C54C4;
	sub_82DF3428(ctx, base);
	// 826C54C4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826C54C8: 4872DF61  bl 0x82df3428
	ctx.lr = 0x826C54CC;
	sub_82DF3428(ctx, base);
	// 826C54CC: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 826C54D0: 4872DF59  bl 0x82df3428
	ctx.lr = 0x826C54D4;
	sub_82DF3428(ctx, base);
	// 826C54D4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 826C54D8: 4872DF51  bl 0x82df3428
	ctx.lr = 0x826C54DC;
	sub_82DF3428(ctx, base);
	// 826C54DC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 826C54E0: 4BDA4B21  bl 0x8246a000
	ctx.lr = 0x826C54E4;
	sub_8246A000(ctx, base);
	// 826C54E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C54E8: 4BD0CF01  bl 0x823d23e8
	ctx.lr = 0x826C54EC;
	sub_823D23E8(ctx, base);
	// 826C54EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C54F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C54F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C54F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C54FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C5500 size=248
    let mut pc: u32 = 0x826C5500;
    'dispatch: loop {
        match pc {
            0x826C5500 => {
    //   block [0x826C5500..0x826C55F8)
	// 826C5500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C550C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C5518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C551C: 4BE4CE15  bl 0x82512330
	ctx.lr = 0x826C5520;
	sub_82512330(ctx, base);
	// 826C5520: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826C5524: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826C5528: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826C552C: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826C5530: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826C5534: 394A813C  addi r10, r10, -0x7ec4
	ctx.r[10].s64 = ctx.r[10].s64 + -32452;
	// 826C5538: 39298128  addi r9, r9, -0x7ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -32472;
	// 826C553C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826C5540: 390880DC  addi r8, r8, -0x7f24
	ctx.r[8].s64 = ctx.r[8].s64 + -32548;
	// 826C5544: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826C5548: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826C554C: 397F00E8  addi r11, r31, 0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + 232;
	// 826C5550: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826C5554: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5558: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826C555C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5560: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C5564: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826C5568: 419A0024  beq cr6, 0x826c558c
	if ctx.cr[6].eq {
	pc = 0x826C558C; continue 'dispatch;
	}
	// 826C556C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826C5570: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C5574: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5578: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C557C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C5580: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C5584: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5588: 4082FFE8  bne 0x826c5570
	if !ctx.cr[0].eq {
	pc = 0x826C5570; continue 'dispatch;
	}
	// 826C558C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 826C5590: 48440701  bl 0x82b05c90
	ctx.lr = 0x826C5594;
	sub_82B05C90(ctx, base);
	// 826C5594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C5598: 907F00F4  stw r3, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[3].u32 ) };
	// 826C559C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C55A0: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826C55A4: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826C55A8: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826C55AC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826C55B0: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826C55B4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826C55B8: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 826C55BC: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826C55C0: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 826C55C4: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 826C55C8: 997F011C  stb r11, 0x11c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u8 ) };
	// 826C55CC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C55D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C55D4: 419A0008  beq cr6, 0x826c55dc
	if ctx.cr[6].eq {
	pc = 0x826C55DC; continue 'dispatch;
	}
	// 826C55D8: 4BBFB2B9  bl 0x822c0890
	ctx.lr = 0x826C55DC;
	sub_822C0890(ctx, base);
	// 826C55DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C55E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C55E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C55E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C55EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C55F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C55F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C55F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C55F8 size=8
    let mut pc: u32 = 0x826C55F8;
    'dispatch: loop {
        match pc {
            0x826C55F8 => {
    //   block [0x826C55F8..0x826C5600)
	// 826C55F8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826C55FC: 480000B4  b 0x826c56b0
	sub_826C56B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C5600 size=8
    let mut pc: u32 = 0x826C5600;
    'dispatch: loop {
        match pc {
            0x826C5600 => {
    //   block [0x826C5600..0x826C5608)
	// 826C5600: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826C5604: 480000AC  b 0x826c56b0
	sub_826C56B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5608 size=164
    let mut pc: u32 = 0x826C5608;
    'dispatch: loop {
        match pc {
            0x826C5608 => {
    //   block [0x826C5608..0x826C56AC)
	// 826C5608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C560C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5618: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C561C: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826C5620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C5624: 419A0008  beq cr6, 0x826c562c
	if ctx.cr[6].eq {
	pc = 0x826C562C; continue 'dispatch;
	}
	// 826C5628: 4BBFB269  bl 0x822c0890
	ctx.lr = 0x826C562C;
	sub_822C0890(ctx, base);
	// 826C562C: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826C5630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C5634: 419A0008  beq cr6, 0x826c563c
	if ctx.cr[6].eq {
	pc = 0x826C563C; continue 'dispatch;
	}
	// 826C5638: 4BBFB259  bl 0x822c0890
	ctx.lr = 0x826C563C;
	sub_822C0890(ctx, base);
	// 826C563C: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826C5640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C5644: 419A0008  beq cr6, 0x826c564c
	if ctx.cr[6].eq {
	pc = 0x826C564C; continue 'dispatch;
	}
	// 826C5648: 4BBFB249  bl 0x822c0890
	ctx.lr = 0x826C564C;
	sub_822C0890(ctx, base);
	// 826C564C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 826C5650: 48140E69  bl 0x828064b8
	ctx.lr = 0x826C5654;
	sub_828064B8(ctx, base);
	// 826C5654: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C5658: 809F00F4  lwz r4, 0xf4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826C565C: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 826C5660: 4872CB29  bl 0x82df2188
	ctx.lr = 0x826C5664;
	sub_82DF2188(ctx, base);
	// 826C5664: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C5668: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826C566C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826C5670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C5674: 419A0008  beq cr6, 0x826c567c
	if ctx.cr[6].eq {
	pc = 0x826C567C; continue 'dispatch;
	}
	// 826C5678: 4BBFB219  bl 0x822c0890
	ctx.lr = 0x826C567C;
	sub_822C0890(ctx, base);
	// 826C567C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C5680: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826C5684: 409A0008  bne cr6, 0x826c568c
	if !ctx.cr[6].eq {
	pc = 0x826C568C; continue 'dispatch;
	}
	// 826C5688: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826C568C: 480E1FCD  bl 0x827a7658
	ctx.lr = 0x826C5690;
	sub_827A7658(ctx, base);
	// 826C5690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5694: 4BC89CBD  bl 0x8234f350
	ctx.lr = 0x826C5698;
	sub_8234F350(ctx, base);
	// 826C5698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C569C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C56A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C56A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C56A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C56B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C56B0 size=76
    let mut pc: u32 = 0x826C56B0;
    'dispatch: loop {
        match pc {
            0x826C56B0 => {
    //   block [0x826C56B0..0x826C56FC)
	// 826C56B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C56B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C56B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C56BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C56C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C56C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C56C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C56CC: 4BFFFF3D  bl 0x826c5608
	ctx.lr = 0x826C56D0;
	sub_826C5608(ctx, base);
	// 826C56D0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C56D4: 4182000C  beq 0x826c56e0
	if ctx.cr[0].eq {
	pc = 0x826C56E0; continue 'dispatch;
	}
	// 826C56D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C56DC: 4872CCFD  bl 0x82df23d8
	ctx.lr = 0x826C56E0;
	sub_82DF23D8(ctx, base);
	// 826C56E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C56E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C56E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C56EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C56F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C56F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C56F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5700 size=96
    let mut pc: u32 = 0x826C5700;
    'dispatch: loop {
        match pc {
            0x826C5700 => {
    //   block [0x826C5700..0x826C5760)
	// 826C5700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C570C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5714: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C5718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C571C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C5720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5724: 388B1104  addi r4, r11, 0x1104
	ctx.r[4].s64 = ctx.r[11].s64 + 4356;
	// 826C5728: 4872E2E1  bl 0x82df3a08
	ctx.lr = 0x826C572C;
	sub_82DF3A08(ctx, base);
	// 826C572C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826C5730: 38BF0114  addi r5, r31, 0x114
	ctx.r[5].s64 = ctx.r[31].s64 + 276;
	// 826C5734: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C573C: 4BFBA245  bl 0x8267f980
	ctx.lr = 0x826C5740;
	sub_8267F980(ctx, base);
	// 826C5740: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5744: 4872DCE5  bl 0x82df3428
	ctx.lr = 0x826C5748;
	sub_82DF3428(ctx, base);
	// 826C5748: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C574C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C5750: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5754: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C5758: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C575C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5760 size=1268
    let mut pc: u32 = 0x826C5760;
    'dispatch: loop {
        match pc {
            0x826C5760 => {
    //   block [0x826C5760..0x826C5C54)
	// 826C5760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5764: 48AE29ED  bl 0x831a8150
	ctx.lr = 0x826C5768;
	sub_831A8130(ctx, base);
	// 826C5768: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C576C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 826C5770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C5774: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 826C5778: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826C577C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826C5780: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 826C5784: 4BE4C255  bl 0x825119d8
	ctx.lr = 0x826C5788;
	sub_825119D8(ctx, base);
	// 826C5788: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826C578C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5790: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826C5794: 4872E275  bl 0x82df3a08
	ctx.lr = 0x826C5798;
	sub_82DF3A08(ctx, base);
	// 826C5798: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C579C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C57A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C57A4: 4BE42FDD  bl 0x82508780
	ctx.lr = 0x826C57A8;
	sub_82508780(ctx, base);
	// 826C57A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C57AC: 4872DC7D  bl 0x82df3428
	ctx.lr = 0x826C57B0;
	sub_82DF3428(ctx, base);
	// 826C57B0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826C57B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C57B8: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 826C57BC: 4872E24D  bl 0x82df3a08
	ctx.lr = 0x826C57C0;
	sub_82DF3A08(ctx, base);
	// 826C57C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C57C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C57C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C57CC: 4BE42FB5  bl 0x82508780
	ctx.lr = 0x826C57D0;
	sub_82508780(ctx, base);
	// 826C57D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C57D4: 4872DC55  bl 0x82df3428
	ctx.lr = 0x826C57D8;
	sub_82DF3428(ctx, base);
	// 826C57D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C57DC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826C57E0: 409A0008  bne cr6, 0x826c57e8
	if !ctx.cr[6].eq {
	pc = 0x826C57E8; continue 'dispatch;
	}
	// 826C57E4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826C57E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C57EC: 4BE42FB5  bl 0x825087a0
	ctx.lr = 0x826C57F0;
	sub_825087A0(ctx, base);
	// 826C57F0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C57F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C57F8: 3B0B8178  addi r24, r11, -0x7e88
	ctx.r[24].s64 = ctx.r[11].s64 + -32392;
	// 826C57FC: 38A00271  li r5, 0x271
	ctx.r[5].s64 = 625;
	// 826C5800: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826C5804: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826C5808: 4872CBE1  bl 0x82df23e8
	ctx.lr = 0x826C580C;
	sub_82DF23E8(ctx, base);
	// 826C580C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C5810: 41820018  beq 0x826c5828
	if ctx.cr[0].eq {
	pc = 0x826C5828; continue 'dispatch;
	}
	// 826C5814: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826C5818: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826C581C: 4874D8D5  bl 0x82e130f0
	ctx.lr = 0x826C5820;
	sub_82E130F0(ctx, base);
	// 826C5820: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5824: 48000008  b 0x826c582c
	pc = 0x826C582C; continue 'dispatch;
	// 826C5828: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826C582C: 387F010C  addi r3, r31, 0x10c
	ctx.r[3].s64 = ctx.r[31].s64 + 268;
	// 826C5830: 4BC1C521  bl 0x822e1d50
	ctx.lr = 0x826C5834;
	sub_822E1D50(ctx, base);
	// 826C5834: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5838: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C583C: 83DF010C  lwz r30, 0x10c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 826C5840: 4BE4C8D9  bl 0x82512118
	ctx.lr = 0x826C5844;
	sub_82512118(ctx, base);
	// 826C5844: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C5848: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C584C: 4874D5E5  bl 0x82e12e30
	ctx.lr = 0x826C5850;
	sub_82E12E30(ctx, base);
	// 826C5850: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826C5854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C5858: 419A0008  beq cr6, 0x826c5860
	if ctx.cr[6].eq {
	pc = 0x826C5860; continue 'dispatch;
	}
	// 826C585C: 4BBFB035  bl 0x822c0890
	ctx.lr = 0x826C5860;
	sub_822C0890(ctx, base);
	// 826C5860: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826C5864: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5868: 48765281  bl 0x82e2aae8
	ctx.lr = 0x826C586C;
	sub_82E2AAE8(ctx, base);
	// 826C586C: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5870: 4BFFF221  bl 0x826c4a90
	ctx.lr = 0x826C5874;
	sub_826C4A90(ctx, base);
	// 826C5874: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826C5878: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 826C587C: 40980170  bge cr6, 0x826c59ec
	if !ctx.cr[6].lt {
	pc = 0x826C59EC; continue 'dispatch;
	}
	// 826C5880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5884: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826C5888: 4BE49C41  bl 0x8250f4c8
	ctx.lr = 0x826C588C;
	sub_8250F4C8(ctx, base);
	// 826C588C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C5894: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826C5898: 409A0008  bne cr6, 0x826c58a0
	if !ctx.cr[6].eq {
	pc = 0x826C58A0; continue 'dispatch;
	}
	// 826C589C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826C58A0: 4BE42C89  bl 0x82508528
	ctx.lr = 0x826C58A4;
	sub_82508528(ctx, base);
	// 826C58A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C58A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C58AC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C58B0: 4BC21959  bl 0x822e7208
	ctx.lr = 0x826C58B4;
	sub_822E7208(ctx, base);
	// 826C58B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826C58B8: 4872C3D9  bl 0x82df1c90
	ctx.lr = 0x826C58BC;
	sub_82DF1C90(ctx, base);
	// 826C58BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C58C0: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C58C4: 4BFFF08D  bl 0x826c4950
	ctx.lr = 0x826C58C8;
	sub_826C4950(ctx, base);
	// 826C58C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826C58CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826C58D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C58D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C58D8: 4BC21AB9  bl 0x822e7390
	ctx.lr = 0x826C58DC;
	sub_822E7390(ctx, base);
	// 826C58DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C58E0: 4872DB49  bl 0x82df3428
	ctx.lr = 0x826C58E4;
	sub_82DF3428(ctx, base);
	// 826C58E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C58E8: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C58EC: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 826C58F0: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826C58F4: 4BEE159D  bl 0x825a6e90
	ctx.lr = 0x826C58F8;
	sub_825A6E90(ctx, base);
	// 826C58F8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826C58FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C5900: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826C5904: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 826C5908: 4BC28DD1  bl 0x822ee6d8
	ctx.lr = 0x826C590C;
	sub_822EE6D8(ctx, base);
	// 826C590C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C5910: 3BDF00FC  addi r30, r31, 0xfc
	ctx.r[30].s64 = ctx.r[31].s64 + 252;
	// 826C5914: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826C5918: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826C591C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5920: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826C5924: 4BBFEB3D  bl 0x822c4460
	ctx.lr = 0x826C5928;
	sub_822C4460(ctx, base);
	// 826C5928: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C592C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C5930: 419A0008  beq cr6, 0x826c5938
	if ctx.cr[6].eq {
	pc = 0x826C5938; continue 'dispatch;
	}
	// 826C5934: 4BBFAF5D  bl 0x822c0890
	ctx.lr = 0x826C5938;
	sub_822C0890(ctx, base);
	// 826C5938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C593C: 4872DAED  bl 0x82df3428
	ctx.lr = 0x826C5940;
	sub_82DF3428(ctx, base);
	// 826C5940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5944: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C5948: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C594C: 4BE4C7CD  bl 0x82512118
	ctx.lr = 0x826C5950;
	sub_82512118(ctx, base);
	// 826C5950: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5954: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C5958: 4BC28609  bl 0x822edf60
	ctx.lr = 0x826C595C;
	sub_822EDF60(ctx, base);
	// 826C595C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C5960: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5964: 4BC1F55D  bl 0x822e4ec0
	ctx.lr = 0x826C5968;
	sub_822E4EC0(ctx, base);
	// 826C5968: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C596C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826C5970: 3CE08335  lis r7, -0x7ccb
	ctx.r[7].s64 = -2093678592;
	// 826C5974: 3CC08335  lis r6, -0x7ccb
	ctx.r[6].s64 = -2093678592;
	// 826C5978: 3CA08335  lis r5, -0x7ccb
	ctx.r[5].s64 = -2093678592;
	// 826C597C: 3C808335  lis r4, -0x7ccb
	ctx.r[4].s64 = -2093678592;
	// 826C5980: 812B6750  lwz r9, 0x6750(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 826C5984: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826C5988: 810A683C  lwz r8, 0x683c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26684 as u32) ) } as u64;
	// 826C598C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C5990: 80E76758  lwz r7, 0x6758(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26456 as u32) ) } as u64;
	// 826C5994: 80C6677C  lwz r6, 0x677c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(26492 as u32) ) } as u64;
	// 826C5998: 80A56768  lwz r5, 0x6768(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(26472 as u32) ) } as u64;
	// 826C599C: 80846754  lwz r4, 0x6754(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(26452 as u32) ) } as u64;
	// 826C59A0: 4BCEA6F9  bl 0x823b0098
	ctx.lr = 0x826C59A4;
	sub_823B0098(ctx, base);
	// 826C59A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826C59A8: E89C0000  ld r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 826C59AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C59B0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 826C59B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826C59B8: 4BDC68D1  bl 0x8248c288
	ctx.lr = 0x826C59BC;
	sub_8248C288(ctx, base);
	// 826C59BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C59C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C59C4: 4BDC99DD  bl 0x8248f3a0
	ctx.lr = 0x826C59C8;
	sub_8248F3A0(ctx, base);
	// 826C59C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C59CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C59D0: 4BE4B371  bl 0x82510d40
	ctx.lr = 0x826C59D4;
	sub_82510D40(ctx, base);
	// 826C59D4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826C59D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C59DC: 419A0008  beq cr6, 0x826c59e4
	if ctx.cr[6].eq {
	pc = 0x826C59E4; continue 'dispatch;
	}
	// 826C59E0: 4BBFAEB1  bl 0x822c0890
	ctx.lr = 0x826C59E4;
	sub_822C0890(ctx, base);
	// 826C59E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C59E8: 4BC21839  bl 0x822e7220
	ctx.lr = 0x826C59EC;
	sub_822E7220(ctx, base);
	// 826C59EC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826C59F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C59F4: 38A00287  li r5, 0x287
	ctx.r[5].s64 = 647;
	// 826C59F8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826C59FC: 4872C9ED  bl 0x82df23e8
	ctx.lr = 0x826C5A00;
	sub_82DF23E8(ctx, base);
	// 826C5A00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C5A04: 4182001C  beq 0x826c5a20
	if ctx.cr[0].eq {
	pc = 0x826C5A20; continue 'dispatch;
	}
	// 826C5A08: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 826C5A0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826C5A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5A14: 48005CFD  bl 0x826cb710
	ctx.lr = 0x826C5A18;
	sub_826CB710(ctx, base);
	// 826C5A18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5A1C: 48000008  b 0x826c5a24
	pc = 0x826C5A24; continue 'dispatch;
	// 826C5A20: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826C5A24: 387F0104  addi r3, r31, 0x104
	ctx.r[3].s64 = ctx.r[31].s64 + 260;
	// 826C5A28: 4BFFF999  bl 0x826c53c0
	ctx.lr = 0x826C5A2C;
	sub_826C53C0(ctx, base);
	// 826C5A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5A30: 809F00E8  lwz r4, 0xe8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5A34: 83DF0104  lwz r30, 0x104(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826C5A38: 4BFFEF51  bl 0x826c4988
	ctx.lr = 0x826C5A3C;
	sub_826C4988(ctx, base);
	// 826C5A3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5A40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C5A44: 48005C1D  bl 0x826cb660
	ctx.lr = 0x826C5A48;
	sub_826CB660(ctx, base);
	// 826C5A48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5A4C: 4872D9DD  bl 0x82df3428
	ctx.lr = 0x826C5A50;
	sub_82DF3428(ctx, base);
	// 826C5A50: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826C5A54: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 826C5A58: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 826C5A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C5A60: 40990034  ble cr6, 0x826c5a94
	if !ctx.cr[6].gt {
	pc = 0x826C5A94; continue 'dispatch;
	}
	// 826C5A64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826C5A68: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5A6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C5A70: 4BFFF049  bl 0x826c4ab8
	ctx.lr = 0x826C5A74;
	sub_826C4AB8(ctx, base);
	// 826C5A74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5A78: 4182000C  beq 0x826c5a84
	if ctx.cr[0].eq {
	pc = 0x826C5A84; continue 'dispatch;
	}
	// 826C5A7C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C5A80: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 826C5A84: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826C5A88: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826C5A8C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C5A90: 4198FFD4  blt cr6, 0x826c5a64
	if ctx.cr[6].lt {
	pc = 0x826C5A64; continue 'dispatch;
	}
	// 826C5A94: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5A98: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 826C5A9C: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 826C5AA0: 4BFFEFC9  bl 0x826c4a68
	ctx.lr = 0x826C5AA4;
	sub_826C4A68(ctx, base);
	// 826C5AA4: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 826C5AA8: 4098019C  bge cr6, 0x826c5c44
	if !ctx.cr[6].lt {
	pc = 0x826C5C44; continue 'dispatch;
	}
	// 826C5AAC: 3B5F00F0  addi r26, r31, 0xf0
	ctx.r[26].s64 = ctx.r[31].s64 + 240;
	// 826C5AB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826C5AB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C5AB8: 38A00299  li r5, 0x299
	ctx.r[5].s64 = 665;
	// 826C5ABC: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 826C5AC0: 4872C929  bl 0x82df23e8
	ctx.lr = 0x826C5AC4;
	sub_82DF23E8(ctx, base);
	// 826C5AC4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826C5AC8: 41820058  beq 0x826c5b20
	if ctx.cr[0].eq {
	pc = 0x826C5B20; continue 'dispatch;
	}
	// 826C5ACC: 839F00E8  lwz r28, 0xe8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5AD0: 632B0001  ori r11, r25, 1
	ctx.r[11].u64 = ctx.r[25].u64 | 1;
	// 826C5AD4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826C5AD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C5ADC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C5AE0: 61790002  ori r25, r11, 2
	ctx.r[25].u64 = ctx.r[11].u64 | 2;
	// 826C5AE4: 4BFFEF15  bl 0x826c49f8
	ctx.lr = 0x826C5AE8;
	sub_826C49F8(ctx, base);
	// 826C5AE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826C5AEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C5AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5AF4: 4BFFEE25  bl 0x826c4918
	ctx.lr = 0x826C5AF8;
	sub_826C4918(ctx, base);
	// 826C5AF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826C5AFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5B00: 4BE4BFE9  bl 0x82511ae8
	ctx.lr = 0x826C5B04;
	sub_82511AE8(ctx, base);
	// 826C5B04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C5B0C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826C5B10: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 826C5B14: 4800290D  bl 0x826c8420
	ctx.lr = 0x826C5B18;
	sub_826C8420(ctx, base);
	// 826C5B18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5B1C: 48000008  b 0x826c5b24
	pc = 0x826C5B24; continue 'dispatch;
	// 826C5B20: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826C5B24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C5B28: 4BFFF439  bl 0x826c4f60
	ctx.lr = 0x826C5B2C;
	sub_826C4F60(ctx, base);
	// 826C5B2C: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5B30: 41820010  beq 0x826c5b40
	if ctx.cr[0].eq {
	pc = 0x826C5B40; continue 'dispatch;
	}
	// 826C5B34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5B38: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5B3C: 4872D8ED  bl 0x82df3428
	ctx.lr = 0x826C5B40;
	sub_82DF3428(ctx, base);
	// 826C5B40: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5B44: 41820010  beq 0x826c5b54
	if ctx.cr[0].eq {
	pc = 0x826C5B54; continue 'dispatch;
	}
	// 826C5B48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C5B4C: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5B50: 4872D8D9  bl 0x82df3428
	ctx.lr = 0x826C5B54;
	sub_82DF3428(ctx, base);
	// 826C5B54: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826C5B58: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C5B5C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C5B60: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 826C5B64: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 826C5B68: 419A0024  beq cr6, 0x826c5b8c
	if ctx.cr[6].eq {
	pc = 0x826C5B8C; continue 'dispatch;
	}
	// 826C5B6C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C5B70: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C5B74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5B78: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C5B7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C5B80: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C5B84: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5B88: 4082FFE8  bne 0x826c5b70
	if !ctx.cr[0].eq {
	pc = 0x826C5B70; continue 'dispatch;
	}
	// 826C5B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5B90: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C5B94: 4BE49935  bl 0x8250f4c8
	ctx.lr = 0x826C5B98;
	sub_8250F4C8(ctx, base);
	// 826C5B98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C5B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C5BA0: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826C5BA4: 409A0008  bne cr6, 0x826c5bac
	if !ctx.cr[6].eq {
	pc = 0x826C5BAC; continue 'dispatch;
	}
	// 826C5BA8: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 826C5BAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5BB0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826C5BB4: 3AC10070  addi r22, r1, 0x70
	ctx.r[22].s64 = ctx.r[1].s64 + 112;
	// 826C5BB8: 4BE49961  bl 0x8250f518
	ctx.lr = 0x826C5BBC;
	sub_8250F518(ctx, base);
	// 826C5BBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C5BC4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 826C5BC8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826C5BCC: 4BE4793D  bl 0x8250d508
	ctx.lr = 0x826C5BD0;
	sub_8250D508(ctx, base);
	// 826C5BD0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C5BD4: 4872C0BD  bl 0x82df1c90
	ctx.lr = 0x826C5BD8;
	sub_82DF1C90(ctx, base);
	// 826C5BD8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826C5BDC: 4872C0B5  bl 0x82df1c90
	ctx.lr = 0x826C5BE0;
	sub_82DF1C90(ctx, base);
	// 826C5BE0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C5BE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C5BE8: 48002C41  bl 0x826c8828
	ctx.lr = 0x826C5BEC;
	sub_826C8828(ctx, base);
	// 826C5BEC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826C5BF0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C5BF4: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5BF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C5BFC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5C00: 48003CD1  bl 0x826c98d0
	ctx.lr = 0x826C5C04;
	sub_826C98D0(ctx, base);
	// 826C5C04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826C5C08: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C5C0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C5C10: 48442711  bl 0x82b08320
	ctx.lr = 0x826C5C14;
	sub_82B08320(ctx, base);
	// 826C5C14: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 826C5C18: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C5C1C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 826C5C20: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 826C5C24: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826C5C28: 4BFFEE41  bl 0x826c4a68
	ctx.lr = 0x826C5C2C;
	sub_826C4A68(ctx, base);
	// 826C5C2C: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 826C5C30: 4198FE80  blt cr6, 0x826c5ab0
	if ctx.cr[6].lt {
	pc = 0x826C5AB0; continue 'dispatch;
	}
	// 826C5C34: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C5C38: 419A000C  beq cr6, 0x826c5c44
	if ctx.cr[6].eq {
	pc = 0x826C5C44; continue 'dispatch;
	}
	// 826C5C3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C5C40: 4BBFAC51  bl 0x822c0890
	ctx.lr = 0x826C5C44;
	sub_822C0890(ctx, base);
	// 826C5C44: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826C5C48: 48764EB9  bl 0x82e2ab00
	ctx.lr = 0x826C5C4C;
	sub_82E2AB00(ctx, base);
	// 826C5C4C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 826C5C50: 48AE2550  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5C58 size=188
    let mut pc: u32 = 0x826C5C58;
    'dispatch: loop {
        match pc {
            0x826C5C58 => {
    //   block [0x826C5C58..0x826C5D14)
	// 826C5C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5C60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C5C64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5C68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5C6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C5C70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C5C74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C5C78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C5C7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C5C80: 4BBFACB9  bl 0x822c0938
	ctx.lr = 0x826C5C84;
	sub_822C0938(ctx, base);
	// 826C5C84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C5C88: 41820028  beq 0x826c5cb0
	if ctx.cr[0].eq {
	pc = 0x826C5CB0; continue 'dispatch;
	}
	// 826C5C8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C5C90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C5C94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C5C98: 392B8070  addi r9, r11, -0x7f90
	ctx.r[9].s64 = ctx.r[11].s64 + -32656;
	// 826C5C9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C5CA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C5CA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C5CA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C5CAC: 48000008  b 0x826c5cb4
	pc = 0x826C5CB4; continue 'dispatch;
	// 826C5CB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C5CB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C5CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C5CBC: 409A003C  bne cr6, 0x826c5cf8
	if !ctx.cr[6].eq {
	pc = 0x826C5CF8; continue 'dispatch;
	}
	// 826C5CC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C5CC4: 419A0014  beq cr6, 0x826c5cd8
	if ctx.cr[6].eq {
	pc = 0x826C5CD8; continue 'dispatch;
	}
	// 826C5CC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5CCC: 4BFFF7D5  bl 0x826c54a0
	ctx.lr = 0x826C5CD0;
	sub_826C54A0(ctx, base);
	// 826C5CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5CD4: 4BBFA595  bl 0x822c0268
	ctx.lr = 0x826C5CD8;
	sub_822C0268(ctx, base);
	// 826C5CD8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C5CDC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C5CE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C5CE4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C5CE8: 816BC5E8  lwz r11, -0x3a18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14872 as u32) ) } as u64;
	// 826C5CEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C5CF0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C5CF4: 4BBFA30D  bl 0x822c0000
	ctx.lr = 0x826C5CF8;
	sub_822C0000(ctx, base);
	// 826C5CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C5CFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C5D00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C5D04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5D08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C5D0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C5D10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C5D18 size=64
    let mut pc: u32 = 0x826C5D18;
    'dispatch: loop {
        match pc {
            0x826C5D18 => {
    //   block [0x826C5D18..0x826C5D58)
	// 826C5D18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5D1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C5D20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C5D24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5D28: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C5D2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C5D30: 419A0014  beq cr6, 0x826c5d44
	if ctx.cr[6].eq {
	pc = 0x826C5D44; continue 'dispatch;
	}
	// 826C5D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5D38: 4BFFF769  bl 0x826c54a0
	ctx.lr = 0x826C5D3C;
	sub_826C54A0(ctx, base);
	// 826C5D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5D40: 4BBFA529  bl 0x822c0268
	ctx.lr = 0x826C5D44;
	sub_822C0268(ctx, base);
	// 826C5D44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C5D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C5D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C5D50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C5D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C5D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C5D58 size=804
    let mut pc: u32 = 0x826C5D58;
    'dispatch: loop {
        match pc {
            0x826C5D58 => {
    //   block [0x826C5D58..0x826C607C)
	// 826C5D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C5D5C: 48AE2405  bl 0x831a8160
	ctx.lr = 0x826C5D60;
	sub_831A8130(ctx, base);
	// 826C5D60: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C5D64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C5D68: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C5D6C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C5D70: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C5D74: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C5D78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C5D7C: 38A00204  li r5, 0x204
	ctx.r[5].s64 = 516;
	// 826C5D80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C5D84: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C5D88: 4BBFA651  bl 0x822c03d8
	ctx.lr = 0x826C5D8C;
	sub_822C03D8(ctx, base);
	// 826C5D8C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C5D90: 41820090  beq 0x826c5e20
	if ctx.cr[0].eq {
	pc = 0x826C5E20; continue 'dispatch;
	}
	// 826C5D94: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C5D98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C5D9C: 808B8218  lwz r4, -0x7de8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32232 as u32) ) } as u64;
	// 826C5DA0: 4872DC69  bl 0x82df3a08
	ctx.lr = 0x826C5DA4;
	sub_82DF3A08(ctx, base);
	// 826C5DA4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C5DA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C5DAC: 3BABC050  addi r29, r11, -0x3fb0
	ctx.r[29].s64 = ctx.r[11].s64 + -16304;
	// 826C5DB0: 809D005C  lwz r4, 0x5c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C5DB4: 4872DC55  bl 0x82df3a08
	ctx.lr = 0x826C5DB8;
	sub_82DF3A08(ctx, base);
	// 826C5DB8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C5DBC: 809D0058  lwz r4, 0x58(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C5DC0: 4872DC49  bl 0x82df3a08
	ctx.lr = 0x826C5DC4;
	sub_82DF3A08(ctx, base);
	// 826C5DC4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C5DC8: 809D0054  lwz r4, 0x54(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C5DCC: 4872DC3D  bl 0x82df3a08
	ctx.lr = 0x826C5DD0;
	sub_82DF3A08(ctx, base);
	// 826C5DD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C5DD4: 809D0050  lwz r4, 0x50(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C5DD8: 4872DC31  bl 0x82df3a08
	ctx.lr = 0x826C5DDC;
	sub_82DF3A08(ctx, base);
	// 826C5DDC: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C5DE0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C5DE4: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C5DE8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C5DEC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C5DF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C5DF4: 38CB7F7C  addi r6, r11, 0x7f7c
	ctx.r[6].s64 = ctx.r[11].s64 + 32636;
	// 826C5DF8: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C5DFC: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C5E00: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C5E04: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C5E08: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 826C5E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5E10: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C5E14: 4BFFECE5  bl 0x826c4af8
	ctx.lr = 0x826C5E18;
	sub_826C4AF8(ctx, base);
	// 826C5E18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C5E1C: 48000008  b 0x826c5e24
	pc = 0x826C5E24; continue 'dispatch;
	// 826C5E20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C5E24: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C5E28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5E2C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C5E30: 4BFFFE29  bl 0x826c5c58
	ctx.lr = 0x826C5E34;
	sub_826C5C58(ctx, base);
	// 826C5E34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C5E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5E3C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C5E40: 4BBFA1C1  bl 0x822c0000
	ctx.lr = 0x826C5E44;
	sub_822C0000(ctx, base);
	// 826C5E44: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5E48: 41820010  beq 0x826c5e58
	if ctx.cr[0].eq {
	pc = 0x826C5E58; continue 'dispatch;
	}
	// 826C5E4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C5E50: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5E54: 4872D5D5  bl 0x82df3428
	ctx.lr = 0x826C5E58;
	sub_82DF3428(ctx, base);
	// 826C5E58: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5E5C: 41820010  beq 0x826c5e6c
	if ctx.cr[0].eq {
	pc = 0x826C5E6C; continue 'dispatch;
	}
	// 826C5E60: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C5E64: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5E68: 4872D5C1  bl 0x82df3428
	ctx.lr = 0x826C5E6C;
	sub_82DF3428(ctx, base);
	// 826C5E6C: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5E70: 41820010  beq 0x826c5e80
	if ctx.cr[0].eq {
	pc = 0x826C5E80; continue 'dispatch;
	}
	// 826C5E74: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C5E78: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5E7C: 4872D5AD  bl 0x82df3428
	ctx.lr = 0x826C5E80;
	sub_82DF3428(ctx, base);
	// 826C5E80: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5E84: 41820010  beq 0x826c5e94
	if ctx.cr[0].eq {
	pc = 0x826C5E94; continue 'dispatch;
	}
	// 826C5E88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C5E8C: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5E90: 4872D599  bl 0x82df3428
	ctx.lr = 0x826C5E94;
	sub_82DF3428(ctx, base);
	// 826C5E94: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C5E98: 41820010  beq 0x826c5ea8
	if ctx.cr[0].eq {
	pc = 0x826C5EA8; continue 'dispatch;
	}
	// 826C5E9C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C5EA0: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C5EA4: 4872D585  bl 0x82df3428
	ctx.lr = 0x826C5EA8;
	sub_82DF3428(ctx, base);
	// 826C5EA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C5EAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C5EB0: 38A00205  li r5, 0x205
	ctx.r[5].s64 = 517;
	// 826C5EB4: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C5EB8: 4872C531  bl 0x82df23e8
	ctx.lr = 0x826C5EBC;
	sub_82DF23E8(ctx, base);
	// 826C5EBC: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C5EC0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C5EC4: 41820048  beq 0x826c5f0c
	if ctx.cr[0].eq {
	pc = 0x826C5F0C; continue 'dispatch;
	}
	// 826C5EC8: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C5ECC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C5ED0: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C5ED4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C5ED8: 419A0024  beq cr6, 0x826c5efc
	if ctx.cr[6].eq {
	pc = 0x826C5EFC; continue 'dispatch;
	}
	// 826C5EDC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C5EE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C5EE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5EE8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C5EEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C5EF0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C5EF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5EF8: 4082FFE8  bne 0x826c5ee0
	if !ctx.cr[0].eq {
	pc = 0x826C5EE0; continue 'dispatch;
	}
	// 826C5EFC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C5F00: 4BFFF601  bl 0x826c5500
	ctx.lr = 0x826C5F04;
	sub_826C5500(ctx, base);
	// 826C5F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C5F08: 48000008  b 0x826c5f10
	pc = 0x826C5F10; continue 'dispatch;
	// 826C5F0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C5F10: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C5F14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5F18: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C5F1C: 4BFFECC5  bl 0x826c4be0
	ctx.lr = 0x826C5F20;
	sub_826C4BE0(ctx, base);
	// 826C5F20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C5F24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C5F28: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C5F2C: 4BBFA0D5  bl 0x822c0000
	ctx.lr = 0x826C5F30;
	sub_822C0000(ctx, base);
	// 826C5F30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C5F34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C5F38: 38A00206  li r5, 0x206
	ctx.r[5].s64 = 518;
	// 826C5F3C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C5F40: 4BBFA499  bl 0x822c03d8
	ctx.lr = 0x826C5F44;
	sub_822C03D8(ctx, base);
	// 826C5F44: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C5F48: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C5F4C: 418200B4  beq 0x826c6000
	if ctx.cr[0].eq {
	pc = 0x826C6000; continue 'dispatch;
	}
	// 826C5F50: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C5F54: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C5F58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C5F5C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C5F60: 409A0008  bne cr6, 0x826c5f68
	if !ctx.cr[6].eq {
	pc = 0x826C5F68; continue 'dispatch;
	}
	// 826C5F64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C5F68: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C5F6C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C5F70: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C5F74: 419A0024  beq cr6, 0x826c5f98
	if ctx.cr[6].eq {
	pc = 0x826C5F98; continue 'dispatch;
	}
	// 826C5F78: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C5F7C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C5F80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5F84: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C5F88: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C5F8C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C5F90: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5F94: 4082FFE8  bne 0x826c5f7c
	if !ctx.cr[0].eq {
	pc = 0x826C5F7C; continue 'dispatch;
	}
	// 826C5F98: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C5F9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C5FA0: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C5FA4: 419A0024  beq cr6, 0x826c5fc8
	if ctx.cr[6].eq {
	pc = 0x826C5FC8; continue 'dispatch;
	}
	// 826C5FA8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C5FAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C5FB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5FB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C5FB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C5FBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C5FC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C5FC4: 4082FFE8  bne 0x826c5fac
	if !ctx.cr[0].eq {
	pc = 0x826C5FAC; continue 'dispatch;
	}
	// 826C5FC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C5FCC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C5FD0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C5FD4: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C5FD8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C5FDC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C5FE0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C5FE4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C5FE8: 480D2F49  bl 0x82798f30
	ctx.lr = 0x826C5FEC;
	sub_82798F30(ctx, base);
	// 826C5FEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C5FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C5FF4: 480D5675  bl 0x8279b668
	ctx.lr = 0x826C5FF8;
	sub_8279B668(ctx, base);
	// 826C5FF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C5FFC: 48000008  b 0x826c6004
	pc = 0x826C6004; continue 'dispatch;
	// 826C6000: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6004: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C6008: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C600C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6010: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6014: 4BED1C3D  bl 0x82597c50
	ctx.lr = 0x826C6018;
	sub_82597C50(ctx, base);
	// 826C6018: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C601C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6024: 4BBF9FDD  bl 0x822c0000
	ctx.lr = 0x826C6028;
	sub_822C0000(ctx, base);
	// 826C6028: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C602C: 41820024  beq 0x826c6050
	if ctx.cr[0].eq {
	pc = 0x826C6050; continue 'dispatch;
	}
	// 826C6030: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C6034: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6038: 419A0008  beq cr6, 0x826c6040
	if ctx.cr[6].eq {
	pc = 0x826C6040; continue 'dispatch;
	}
	// 826C603C: 4BBFA855  bl 0x822c0890
	ctx.lr = 0x826C6040;
	sub_822C0890(ctx, base);
	// 826C6040: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C6044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6048: 419A0008  beq cr6, 0x826c6050
	if ctx.cr[6].eq {
	pc = 0x826C6050; continue 'dispatch;
	}
	// 826C604C: 4BBFA845  bl 0x822c0890
	ctx.lr = 0x826C6050;
	sub_822C0890(ctx, base);
	// 826C6050: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6054: 419A000C  beq cr6, 0x826c6060
	if ctx.cr[6].eq {
	pc = 0x826C6060; continue 'dispatch;
	}
	// 826C6058: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C605C: 4BBFA835  bl 0x822c0890
	ctx.lr = 0x826C6060;
	sub_822C0890(ctx, base);
	// 826C6060: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C6064: 419A000C  beq cr6, 0x826c6070
	if ctx.cr[6].eq {
	pc = 0x826C6070; continue 'dispatch;
	}
	// 826C6068: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C606C: 4BBFA825  bl 0x822c0890
	ctx.lr = 0x826C6070;
	sub_822C0890(ctx, base);
	// 826C6070: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C6074: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C6078: 48AE2138  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C6080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C6080 size=804
    let mut pc: u32 = 0x826C6080;
    'dispatch: loop {
        match pc {
            0x826C6080 => {
    //   block [0x826C6080..0x826C63A4)
	// 826C6080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C6084: 48AE20DD  bl 0x831a8160
	ctx.lr = 0x826C6088;
	sub_831A8130(ctx, base);
	// 826C6088: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C608C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C6090: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C6094: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C6098: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C609C: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C60A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C60A4: 38A0020B  li r5, 0x20b
	ctx.r[5].s64 = 523;
	// 826C60A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C60AC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C60B0: 4BBFA329  bl 0x822c03d8
	ctx.lr = 0x826C60B4;
	sub_822C03D8(ctx, base);
	// 826C60B4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C60B8: 41820090  beq 0x826c6148
	if ctx.cr[0].eq {
	pc = 0x826C6148; continue 'dispatch;
	}
	// 826C60BC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C60C0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C60C4: 808B821C  lwz r4, -0x7de4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32228 as u32) ) } as u64;
	// 826C60C8: 4872D941  bl 0x82df3a08
	ctx.lr = 0x826C60CC;
	sub_82DF3A08(ctx, base);
	// 826C60CC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C60D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C60D4: 3BABC0B0  addi r29, r11, -0x3f50
	ctx.r[29].s64 = ctx.r[11].s64 + -16208;
	// 826C60D8: 809D0058  lwz r4, 0x58(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C60DC: 4872D92D  bl 0x82df3a08
	ctx.lr = 0x826C60E0;
	sub_82DF3A08(ctx, base);
	// 826C60E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C60E4: 809D0054  lwz r4, 0x54(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C60E8: 4872D921  bl 0x82df3a08
	ctx.lr = 0x826C60EC;
	sub_82DF3A08(ctx, base);
	// 826C60EC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C60F0: 809D0050  lwz r4, 0x50(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C60F4: 4872D915  bl 0x82df3a08
	ctx.lr = 0x826C60F8;
	sub_82DF3A08(ctx, base);
	// 826C60F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C60FC: 809D004C  lwz r4, 0x4c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 826C6100: 4872D909  bl 0x82df3a08
	ctx.lr = 0x826C6104;
	sub_82DF3A08(ctx, base);
	// 826C6104: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C6108: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C610C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C6110: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C6114: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C6118: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C611C: 38CB7F90  addi r6, r11, 0x7f90
	ctx.r[6].s64 = ctx.r[11].s64 + 32656;
	// 826C6120: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C6124: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C6128: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C612C: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C6130: 38A00013  li r5, 0x13
	ctx.r[5].s64 = 19;
	// 826C6134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6138: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C613C: 4BFFE9BD  bl 0x826c4af8
	ctx.lr = 0x826C6140;
	sub_826C4AF8(ctx, base);
	// 826C6140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6144: 48000008  b 0x826c614c
	pc = 0x826C614C; continue 'dispatch;
	// 826C6148: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C614C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6154: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6158: 4BFFFB01  bl 0x826c5c58
	ctx.lr = 0x826C615C;
	sub_826C5C58(ctx, base);
	// 826C615C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6164: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6168: 4BBF9E99  bl 0x822c0000
	ctx.lr = 0x826C616C;
	sub_822C0000(ctx, base);
	// 826C616C: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6170: 41820010  beq 0x826c6180
	if ctx.cr[0].eq {
	pc = 0x826C6180; continue 'dispatch;
	}
	// 826C6174: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6178: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C617C: 4872D2AD  bl 0x82df3428
	ctx.lr = 0x826C6180;
	sub_82DF3428(ctx, base);
	// 826C6180: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6184: 41820010  beq 0x826c6194
	if ctx.cr[0].eq {
	pc = 0x826C6194; continue 'dispatch;
	}
	// 826C6188: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C618C: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6190: 4872D299  bl 0x82df3428
	ctx.lr = 0x826C6194;
	sub_82DF3428(ctx, base);
	// 826C6194: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6198: 41820010  beq 0x826c61a8
	if ctx.cr[0].eq {
	pc = 0x826C61A8; continue 'dispatch;
	}
	// 826C619C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C61A0: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C61A4: 4872D285  bl 0x82df3428
	ctx.lr = 0x826C61A8;
	sub_82DF3428(ctx, base);
	// 826C61A8: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C61AC: 41820010  beq 0x826c61bc
	if ctx.cr[0].eq {
	pc = 0x826C61BC; continue 'dispatch;
	}
	// 826C61B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C61B4: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C61B8: 4872D271  bl 0x82df3428
	ctx.lr = 0x826C61BC;
	sub_82DF3428(ctx, base);
	// 826C61BC: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C61C0: 41820010  beq 0x826c61d0
	if ctx.cr[0].eq {
	pc = 0x826C61D0; continue 'dispatch;
	}
	// 826C61C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C61C8: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C61CC: 4872D25D  bl 0x82df3428
	ctx.lr = 0x826C61D0;
	sub_82DF3428(ctx, base);
	// 826C61D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C61D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C61D8: 38A0020C  li r5, 0x20c
	ctx.r[5].s64 = 524;
	// 826C61DC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C61E0: 4872C209  bl 0x82df23e8
	ctx.lr = 0x826C61E4;
	sub_82DF23E8(ctx, base);
	// 826C61E4: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C61E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C61EC: 41820048  beq 0x826c6234
	if ctx.cr[0].eq {
	pc = 0x826C6234; continue 'dispatch;
	}
	// 826C61F0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C61F4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C61F8: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C61FC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C6200: 419A0024  beq cr6, 0x826c6224
	if ctx.cr[6].eq {
	pc = 0x826C6224; continue 'dispatch;
	}
	// 826C6204: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C6208: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C620C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6210: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6214: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6218: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C621C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6220: 4082FFE8  bne 0x826c6208
	if !ctx.cr[0].eq {
	pc = 0x826C6208; continue 'dispatch;
	}
	// 826C6224: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C6228: 4BFFF2D9  bl 0x826c5500
	ctx.lr = 0x826C622C;
	sub_826C5500(ctx, base);
	// 826C622C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6230: 48000008  b 0x826c6238
	pc = 0x826C6238; continue 'dispatch;
	// 826C6234: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6238: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C623C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6240: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6244: 4BFFE99D  bl 0x826c4be0
	ctx.lr = 0x826C6248;
	sub_826C4BE0(ctx, base);
	// 826C6248: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C624C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6250: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6254: 4BBF9DAD  bl 0x822c0000
	ctx.lr = 0x826C6258;
	sub_822C0000(ctx, base);
	// 826C6258: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C625C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6260: 38A0020D  li r5, 0x20d
	ctx.r[5].s64 = 525;
	// 826C6264: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C6268: 4BBFA171  bl 0x822c03d8
	ctx.lr = 0x826C626C;
	sub_822C03D8(ctx, base);
	// 826C626C: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6270: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6274: 418200B4  beq 0x826c6328
	if ctx.cr[0].eq {
	pc = 0x826C6328; continue 'dispatch;
	}
	// 826C6278: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C627C: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C6280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C6284: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C6288: 409A0008  bne cr6, 0x826c6290
	if !ctx.cr[6].eq {
	pc = 0x826C6290; continue 'dispatch;
	}
	// 826C628C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C6290: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C6294: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6298: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C629C: 419A0024  beq cr6, 0x826c62c0
	if ctx.cr[6].eq {
	pc = 0x826C62C0; continue 'dispatch;
	}
	// 826C62A0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C62A4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C62A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C62AC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C62B0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C62B4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C62B8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C62BC: 4082FFE8  bne 0x826c62a4
	if !ctx.cr[0].eq {
	pc = 0x826C62A4; continue 'dispatch;
	}
	// 826C62C0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C62C4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C62C8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C62CC: 419A0024  beq cr6, 0x826c62f0
	if ctx.cr[6].eq {
	pc = 0x826C62F0; continue 'dispatch;
	}
	// 826C62D0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C62D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C62D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C62DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C62E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C62E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C62E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C62EC: 4082FFE8  bne 0x826c62d4
	if !ctx.cr[0].eq {
	pc = 0x826C62D4; continue 'dispatch;
	}
	// 826C62F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C62F4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C62F8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C62FC: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C6300: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C6304: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C6308: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C630C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C6310: 480D2C21  bl 0x82798f30
	ctx.lr = 0x826C6314;
	sub_82798F30(ctx, base);
	// 826C6314: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C6318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C631C: 480D534D  bl 0x8279b668
	ctx.lr = 0x826C6320;
	sub_8279B668(ctx, base);
	// 826C6320: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6324: 48000008  b 0x826c632c
	pc = 0x826C632C; continue 'dispatch;
	// 826C6328: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C632C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C6330: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C6334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6338: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C633C: 4BED1915  bl 0x82597c50
	ctx.lr = 0x826C6340;
	sub_82597C50(ctx, base);
	// 826C6340: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6344: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C634C: 4BBF9CB5  bl 0x822c0000
	ctx.lr = 0x826C6350;
	sub_822C0000(ctx, base);
	// 826C6350: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6354: 41820024  beq 0x826c6378
	if ctx.cr[0].eq {
	pc = 0x826C6378; continue 'dispatch;
	}
	// 826C6358: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C635C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6360: 419A0008  beq cr6, 0x826c6368
	if ctx.cr[6].eq {
	pc = 0x826C6368; continue 'dispatch;
	}
	// 826C6364: 4BBFA52D  bl 0x822c0890
	ctx.lr = 0x826C6368;
	sub_822C0890(ctx, base);
	// 826C6368: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C636C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6370: 419A0008  beq cr6, 0x826c6378
	if ctx.cr[6].eq {
	pc = 0x826C6378; continue 'dispatch;
	}
	// 826C6374: 4BBFA51D  bl 0x822c0890
	ctx.lr = 0x826C6378;
	sub_822C0890(ctx, base);
	// 826C6378: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C637C: 419A000C  beq cr6, 0x826c6388
	if ctx.cr[6].eq {
	pc = 0x826C6388; continue 'dispatch;
	}
	// 826C6380: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C6384: 4BBFA50D  bl 0x822c0890
	ctx.lr = 0x826C6388;
	sub_822C0890(ctx, base);
	// 826C6388: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C638C: 419A000C  beq cr6, 0x826c6398
	if ctx.cr[6].eq {
	pc = 0x826C6398; continue 'dispatch;
	}
	// 826C6390: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C6394: 4BBFA4FD  bl 0x822c0890
	ctx.lr = 0x826C6398;
	sub_822C0890(ctx, base);
	// 826C6398: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C639C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C63A0: 48AE1E10  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C63A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C63A8 size=800
    let mut pc: u32 = 0x826C63A8;
    'dispatch: loop {
        match pc {
            0x826C63A8 => {
    //   block [0x826C63A8..0x826C66C8)
	// 826C63A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C63AC: 48AE1DB5  bl 0x831a8160
	ctx.lr = 0x826C63B0;
	sub_831A8130(ctx, base);
	// 826C63B0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C63B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C63B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C63BC: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C63C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C63C4: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C63C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C63CC: 38A00212  li r5, 0x212
	ctx.r[5].s64 = 530;
	// 826C63D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C63D4: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C63D8: 4BBFA001  bl 0x822c03d8
	ctx.lr = 0x826C63DC;
	sub_822C03D8(ctx, base);
	// 826C63DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C63E0: 4182008C  beq 0x826c646c
	if ctx.cr[0].eq {
	pc = 0x826C646C; continue 'dispatch;
	}
	// 826C63E4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C63E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C63EC: 3BABC110  addi r29, r11, -0x3ef0
	ctx.r[29].s64 = ctx.r[11].s64 + -16112;
	// 826C63F0: 809D0094  lwz r4, 0x94(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C63F4: 4872D615  bl 0x82df3a08
	ctx.lr = 0x826C63F8;
	sub_82DF3A08(ctx, base);
	// 826C63F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C63FC: 809D0090  lwz r4, 0x90(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 826C6400: 4872D609  bl 0x82df3a08
	ctx.lr = 0x826C6404;
	sub_82DF3A08(ctx, base);
	// 826C6404: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C6408: 809D008C  lwz r4, 0x8c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C640C: 4872D5FD  bl 0x82df3a08
	ctx.lr = 0x826C6410;
	sub_82DF3A08(ctx, base);
	// 826C6410: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C6414: 809D0088  lwz r4, 0x88(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 826C6418: 4872D5F1  bl 0x82df3a08
	ctx.lr = 0x826C641C;
	sub_82DF3A08(ctx, base);
	// 826C641C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6420: 809DFFFC  lwz r4, -4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 826C6424: 4872D5E5  bl 0x82df3a08
	ctx.lr = 0x826C6428;
	sub_82DF3A08(ctx, base);
	// 826C6428: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C642C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C6430: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C6434: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C6438: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C643C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C6440: 38CB7FA4  addi r6, r11, 0x7fa4
	ctx.r[6].s64 = ctx.r[11].s64 + 32676;
	// 826C6444: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C6448: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C644C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C6450: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C6454: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 826C6458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C645C: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C6460: 4BFFE699  bl 0x826c4af8
	ctx.lr = 0x826C6464;
	sub_826C4AF8(ctx, base);
	// 826C6464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6468: 48000008  b 0x826c6470
	pc = 0x826C6470; continue 'dispatch;
	// 826C646C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6470: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6474: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6478: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C647C: 4BFFF7DD  bl 0x826c5c58
	ctx.lr = 0x826C6480;
	sub_826C5C58(ctx, base);
	// 826C6480: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6488: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C648C: 4BBF9B75  bl 0x822c0000
	ctx.lr = 0x826C6490;
	sub_822C0000(ctx, base);
	// 826C6490: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6494: 41820010  beq 0x826c64a4
	if ctx.cr[0].eq {
	pc = 0x826C64A4; continue 'dispatch;
	}
	// 826C6498: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C649C: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C64A0: 4872CF89  bl 0x82df3428
	ctx.lr = 0x826C64A4;
	sub_82DF3428(ctx, base);
	// 826C64A4: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C64A8: 41820010  beq 0x826c64b8
	if ctx.cr[0].eq {
	pc = 0x826C64B8; continue 'dispatch;
	}
	// 826C64AC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C64B0: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C64B4: 4872CF75  bl 0x82df3428
	ctx.lr = 0x826C64B8;
	sub_82DF3428(ctx, base);
	// 826C64B8: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C64BC: 41820010  beq 0x826c64cc
	if ctx.cr[0].eq {
	pc = 0x826C64CC; continue 'dispatch;
	}
	// 826C64C0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C64C4: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C64C8: 4872CF61  bl 0x82df3428
	ctx.lr = 0x826C64CC;
	sub_82DF3428(ctx, base);
	// 826C64CC: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C64D0: 41820010  beq 0x826c64e0
	if ctx.cr[0].eq {
	pc = 0x826C64E0; continue 'dispatch;
	}
	// 826C64D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C64D8: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C64DC: 4872CF4D  bl 0x82df3428
	ctx.lr = 0x826C64E0;
	sub_82DF3428(ctx, base);
	// 826C64E0: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C64E4: 41820010  beq 0x826c64f4
	if ctx.cr[0].eq {
	pc = 0x826C64F4; continue 'dispatch;
	}
	// 826C64E8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C64EC: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C64F0: 4872CF39  bl 0x82df3428
	ctx.lr = 0x826C64F4;
	sub_82DF3428(ctx, base);
	// 826C64F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C64F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C64FC: 38A00213  li r5, 0x213
	ctx.r[5].s64 = 531;
	// 826C6500: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C6504: 4872BEE5  bl 0x82df23e8
	ctx.lr = 0x826C6508;
	sub_82DF23E8(ctx, base);
	// 826C6508: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C650C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C6510: 41820048  beq 0x826c6558
	if ctx.cr[0].eq {
	pc = 0x826C6558; continue 'dispatch;
	}
	// 826C6514: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6518: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C651C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C6520: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C6524: 419A0024  beq cr6, 0x826c6548
	if ctx.cr[6].eq {
	pc = 0x826C6548; continue 'dispatch;
	}
	// 826C6528: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C652C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C6530: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6534: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6538: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C653C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6540: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6544: 4082FFE8  bne 0x826c652c
	if !ctx.cr[0].eq {
	pc = 0x826C652C; continue 'dispatch;
	}
	// 826C6548: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C654C: 4BFFEFB5  bl 0x826c5500
	ctx.lr = 0x826C6550;
	sub_826C5500(ctx, base);
	// 826C6550: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6554: 48000008  b 0x826c655c
	pc = 0x826C655C; continue 'dispatch;
	// 826C6558: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C655C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6564: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6568: 4BFFE679  bl 0x826c4be0
	ctx.lr = 0x826C656C;
	sub_826C4BE0(ctx, base);
	// 826C656C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6570: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6574: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6578: 4BBF9A89  bl 0x822c0000
	ctx.lr = 0x826C657C;
	sub_822C0000(ctx, base);
	// 826C657C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6580: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6584: 38A00214  li r5, 0x214
	ctx.r[5].s64 = 532;
	// 826C6588: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C658C: 4BBF9E4D  bl 0x822c03d8
	ctx.lr = 0x826C6590;
	sub_822C03D8(ctx, base);
	// 826C6590: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6594: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6598: 418200B4  beq 0x826c664c
	if ctx.cr[0].eq {
	pc = 0x826C664C; continue 'dispatch;
	}
	// 826C659C: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C65A0: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C65A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C65A8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C65AC: 409A0008  bne cr6, 0x826c65b4
	if !ctx.cr[6].eq {
	pc = 0x826C65B4; continue 'dispatch;
	}
	// 826C65B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C65B4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C65B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C65BC: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C65C0: 419A0024  beq cr6, 0x826c65e4
	if ctx.cr[6].eq {
	pc = 0x826C65E4; continue 'dispatch;
	}
	// 826C65C4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C65C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C65CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C65D0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C65D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C65D8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C65DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C65E0: 4082FFE8  bne 0x826c65c8
	if !ctx.cr[0].eq {
	pc = 0x826C65C8; continue 'dispatch;
	}
	// 826C65E4: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C65E8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C65EC: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C65F0: 419A0024  beq cr6, 0x826c6614
	if ctx.cr[6].eq {
	pc = 0x826C6614; continue 'dispatch;
	}
	// 826C65F4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C65F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C65FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6600: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6604: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6608: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C660C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6610: 4082FFE8  bne 0x826c65f8
	if !ctx.cr[0].eq {
	pc = 0x826C65F8; continue 'dispatch;
	}
	// 826C6614: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C6618: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C661C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C6620: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C6624: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C6628: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C662C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C6630: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C6634: 480D28FD  bl 0x82798f30
	ctx.lr = 0x826C6638;
	sub_82798F30(ctx, base);
	// 826C6638: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C663C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6640: 480D5029  bl 0x8279b668
	ctx.lr = 0x826C6644;
	sub_8279B668(ctx, base);
	// 826C6644: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6648: 48000008  b 0x826c6650
	pc = 0x826C6650; continue 'dispatch;
	// 826C664C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6650: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C6654: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C6658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C665C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6660: 4BED15F1  bl 0x82597c50
	ctx.lr = 0x826C6664;
	sub_82597C50(ctx, base);
	// 826C6664: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C666C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6670: 4BBF9991  bl 0x822c0000
	ctx.lr = 0x826C6674;
	sub_822C0000(ctx, base);
	// 826C6674: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6678: 41820024  beq 0x826c669c
	if ctx.cr[0].eq {
	pc = 0x826C669C; continue 'dispatch;
	}
	// 826C667C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C6680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6684: 419A0008  beq cr6, 0x826c668c
	if ctx.cr[6].eq {
	pc = 0x826C668C; continue 'dispatch;
	}
	// 826C6688: 4BBFA209  bl 0x822c0890
	ctx.lr = 0x826C668C;
	sub_822C0890(ctx, base);
	// 826C668C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C6690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6694: 419A0008  beq cr6, 0x826c669c
	if ctx.cr[6].eq {
	pc = 0x826C669C; continue 'dispatch;
	}
	// 826C6698: 4BBFA1F9  bl 0x822c0890
	ctx.lr = 0x826C669C;
	sub_822C0890(ctx, base);
	// 826C669C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C66A0: 419A000C  beq cr6, 0x826c66ac
	if ctx.cr[6].eq {
	pc = 0x826C66AC; continue 'dispatch;
	}
	// 826C66A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C66A8: 4BBFA1E9  bl 0x822c0890
	ctx.lr = 0x826C66AC;
	sub_822C0890(ctx, base);
	// 826C66AC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C66B0: 419A000C  beq cr6, 0x826c66bc
	if ctx.cr[6].eq {
	pc = 0x826C66BC; continue 'dispatch;
	}
	// 826C66B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C66B8: 4BBFA1D9  bl 0x822c0890
	ctx.lr = 0x826C66BC;
	sub_822C0890(ctx, base);
	// 826C66BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C66C0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C66C4: 48AE1AEC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C66C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C66C8 size=800
    let mut pc: u32 = 0x826C66C8;
    'dispatch: loop {
        match pc {
            0x826C66C8 => {
    //   block [0x826C66C8..0x826C69E8)
	// 826C66C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C66CC: 48AE1A95  bl 0x831a8160
	ctx.lr = 0x826C66D0;
	sub_831A8130(ctx, base);
	// 826C66D0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C66D4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C66D8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C66DC: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C66E0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C66E4: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C66E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C66EC: 38A00219  li r5, 0x219
	ctx.r[5].s64 = 537;
	// 826C66F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C66F4: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C66F8: 4BBF9CE1  bl 0x822c03d8
	ctx.lr = 0x826C66FC;
	sub_822C03D8(ctx, base);
	// 826C66FC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6700: 4182008C  beq 0x826c678c
	if ctx.cr[0].eq {
	pc = 0x826C678C; continue 'dispatch;
	}
	// 826C6704: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C6708: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C670C: 3BABC1A8  addi r29, r11, -0x3e58
	ctx.r[29].s64 = ctx.r[11].s64 + -15960;
	// 826C6710: 809D0098  lwz r4, 0x98(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 826C6714: 4872D2F5  bl 0x82df3a08
	ctx.lr = 0x826C6718;
	sub_82DF3A08(ctx, base);
	// 826C6718: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C671C: 809D0094  lwz r4, 0x94(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C6720: 4872D2E9  bl 0x82df3a08
	ctx.lr = 0x826C6724;
	sub_82DF3A08(ctx, base);
	// 826C6724: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C6728: 809D0090  lwz r4, 0x90(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 826C672C: 4872D2DD  bl 0x82df3a08
	ctx.lr = 0x826C6730;
	sub_82DF3A08(ctx, base);
	// 826C6730: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C6734: 809D008C  lwz r4, 0x8c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C6738: 4872D2D1  bl 0x82df3a08
	ctx.lr = 0x826C673C;
	sub_82DF3A08(ctx, base);
	// 826C673C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6740: 809D0088  lwz r4, 0x88(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 826C6744: 4872D2C5  bl 0x82df3a08
	ctx.lr = 0x826C6748;
	sub_82DF3A08(ctx, base);
	// 826C6748: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C674C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C6750: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C6754: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C6758: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C675C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C6760: 38CB7FB8  addi r6, r11, 0x7fb8
	ctx.r[6].s64 = ctx.r[11].s64 + 32696;
	// 826C6764: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C6768: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C676C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C6770: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C6774: 38A00022  li r5, 0x22
	ctx.r[5].s64 = 34;
	// 826C6778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C677C: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C6780: 4BFFE379  bl 0x826c4af8
	ctx.lr = 0x826C6784;
	sub_826C4AF8(ctx, base);
	// 826C6784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6788: 48000008  b 0x826c6790
	pc = 0x826C6790; continue 'dispatch;
	// 826C678C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6790: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6794: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6798: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C679C: 4BFFF4BD  bl 0x826c5c58
	ctx.lr = 0x826C67A0;
	sub_826C5C58(ctx, base);
	// 826C67A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C67A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C67A8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C67AC: 4BBF9855  bl 0x822c0000
	ctx.lr = 0x826C67B0;
	sub_822C0000(ctx, base);
	// 826C67B0: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C67B4: 41820010  beq 0x826c67c4
	if ctx.cr[0].eq {
	pc = 0x826C67C4; continue 'dispatch;
	}
	// 826C67B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C67BC: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C67C0: 4872CC69  bl 0x82df3428
	ctx.lr = 0x826C67C4;
	sub_82DF3428(ctx, base);
	// 826C67C4: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C67C8: 41820010  beq 0x826c67d8
	if ctx.cr[0].eq {
	pc = 0x826C67D8; continue 'dispatch;
	}
	// 826C67CC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C67D0: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C67D4: 4872CC55  bl 0x82df3428
	ctx.lr = 0x826C67D8;
	sub_82DF3428(ctx, base);
	// 826C67D8: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C67DC: 41820010  beq 0x826c67ec
	if ctx.cr[0].eq {
	pc = 0x826C67EC; continue 'dispatch;
	}
	// 826C67E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C67E4: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C67E8: 4872CC41  bl 0x82df3428
	ctx.lr = 0x826C67EC;
	sub_82DF3428(ctx, base);
	// 826C67EC: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C67F0: 41820010  beq 0x826c6800
	if ctx.cr[0].eq {
	pc = 0x826C6800; continue 'dispatch;
	}
	// 826C67F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C67F8: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C67FC: 4872CC2D  bl 0x82df3428
	ctx.lr = 0x826C6800;
	sub_82DF3428(ctx, base);
	// 826C6800: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6804: 41820010  beq 0x826c6814
	if ctx.cr[0].eq {
	pc = 0x826C6814; continue 'dispatch;
	}
	// 826C6808: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C680C: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6810: 4872CC19  bl 0x82df3428
	ctx.lr = 0x826C6814;
	sub_82DF3428(ctx, base);
	// 826C6814: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6818: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C681C: 38A0021A  li r5, 0x21a
	ctx.r[5].s64 = 538;
	// 826C6820: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C6824: 4872BBC5  bl 0x82df23e8
	ctx.lr = 0x826C6828;
	sub_82DF23E8(ctx, base);
	// 826C6828: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C682C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C6830: 41820048  beq 0x826c6878
	if ctx.cr[0].eq {
	pc = 0x826C6878; continue 'dispatch;
	}
	// 826C6834: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6838: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C683C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C6840: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C6844: 419A0024  beq cr6, 0x826c6868
	if ctx.cr[6].eq {
	pc = 0x826C6868; continue 'dispatch;
	}
	// 826C6848: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C684C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C6850: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6854: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6858: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C685C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6860: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6864: 4082FFE8  bne 0x826c684c
	if !ctx.cr[0].eq {
	pc = 0x826C684C; continue 'dispatch;
	}
	// 826C6868: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C686C: 4BFFEC95  bl 0x826c5500
	ctx.lr = 0x826C6870;
	sub_826C5500(ctx, base);
	// 826C6870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6874: 48000008  b 0x826c687c
	pc = 0x826C687C; continue 'dispatch;
	// 826C6878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C687C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6884: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6888: 4BFFE359  bl 0x826c4be0
	ctx.lr = 0x826C688C;
	sub_826C4BE0(ctx, base);
	// 826C688C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6890: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6894: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6898: 4BBF9769  bl 0x822c0000
	ctx.lr = 0x826C689C;
	sub_822C0000(ctx, base);
	// 826C689C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C68A0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C68A4: 38A0021B  li r5, 0x21b
	ctx.r[5].s64 = 539;
	// 826C68A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C68AC: 4BBF9B2D  bl 0x822c03d8
	ctx.lr = 0x826C68B0;
	sub_822C03D8(ctx, base);
	// 826C68B0: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C68B4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C68B8: 418200B4  beq 0x826c696c
	if ctx.cr[0].eq {
	pc = 0x826C696C; continue 'dispatch;
	}
	// 826C68BC: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C68C0: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C68C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C68C8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C68CC: 409A0008  bne cr6, 0x826c68d4
	if !ctx.cr[6].eq {
	pc = 0x826C68D4; continue 'dispatch;
	}
	// 826C68D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C68D4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C68D8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C68DC: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C68E0: 419A0024  beq cr6, 0x826c6904
	if ctx.cr[6].eq {
	pc = 0x826C6904; continue 'dispatch;
	}
	// 826C68E4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C68E8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C68EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C68F0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C68F4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C68F8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C68FC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6900: 4082FFE8  bne 0x826c68e8
	if !ctx.cr[0].eq {
	pc = 0x826C68E8; continue 'dispatch;
	}
	// 826C6904: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C6908: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C690C: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C6910: 419A0024  beq cr6, 0x826c6934
	if ctx.cr[6].eq {
	pc = 0x826C6934; continue 'dispatch;
	}
	// 826C6914: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C6918: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C691C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6920: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6924: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6928: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C692C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6930: 4082FFE8  bne 0x826c6918
	if !ctx.cr[0].eq {
	pc = 0x826C6918; continue 'dispatch;
	}
	// 826C6934: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C6938: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C693C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C6940: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C6944: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C6948: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C694C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C6950: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C6954: 480D25DD  bl 0x82798f30
	ctx.lr = 0x826C6958;
	sub_82798F30(ctx, base);
	// 826C6958: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C695C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6960: 480D4D09  bl 0x8279b668
	ctx.lr = 0x826C6964;
	sub_8279B668(ctx, base);
	// 826C6964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6968: 48000008  b 0x826c6970
	pc = 0x826C6970; continue 'dispatch;
	// 826C696C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6970: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C6974: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C6978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C697C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6980: 4BED12D1  bl 0x82597c50
	ctx.lr = 0x826C6984;
	sub_82597C50(ctx, base);
	// 826C6984: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C698C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6990: 4BBF9671  bl 0x822c0000
	ctx.lr = 0x826C6994;
	sub_822C0000(ctx, base);
	// 826C6994: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6998: 41820024  beq 0x826c69bc
	if ctx.cr[0].eq {
	pc = 0x826C69BC; continue 'dispatch;
	}
	// 826C699C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C69A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C69A4: 419A0008  beq cr6, 0x826c69ac
	if ctx.cr[6].eq {
	pc = 0x826C69AC; continue 'dispatch;
	}
	// 826C69A8: 4BBF9EE9  bl 0x822c0890
	ctx.lr = 0x826C69AC;
	sub_822C0890(ctx, base);
	// 826C69AC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C69B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C69B4: 419A0008  beq cr6, 0x826c69bc
	if ctx.cr[6].eq {
	pc = 0x826C69BC; continue 'dispatch;
	}
	// 826C69B8: 4BBF9ED9  bl 0x822c0890
	ctx.lr = 0x826C69BC;
	sub_822C0890(ctx, base);
	// 826C69BC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C69C0: 419A000C  beq cr6, 0x826c69cc
	if ctx.cr[6].eq {
	pc = 0x826C69CC; continue 'dispatch;
	}
	// 826C69C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C69C8: 4BBF9EC9  bl 0x822c0890
	ctx.lr = 0x826C69CC;
	sub_822C0890(ctx, base);
	// 826C69CC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C69D0: 419A000C  beq cr6, 0x826c69dc
	if ctx.cr[6].eq {
	pc = 0x826C69DC; continue 'dispatch;
	}
	// 826C69D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C69D8: 4BBF9EB9  bl 0x822c0890
	ctx.lr = 0x826C69DC;
	sub_822C0890(ctx, base);
	// 826C69DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C69E0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C69E4: 48AE17CC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C69E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C69E8 size=800
    let mut pc: u32 = 0x826C69E8;
    'dispatch: loop {
        match pc {
            0x826C69E8 => {
    //   block [0x826C69E8..0x826C6D08)
	// 826C69E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C69EC: 48AE1775  bl 0x831a8160
	ctx.lr = 0x826C69F0;
	sub_831A8130(ctx, base);
	// 826C69F0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C69F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C69F8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C69FC: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C6A00: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C6A04: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C6A08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6A0C: 38A00220  li r5, 0x220
	ctx.r[5].s64 = 544;
	// 826C6A10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6A14: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C6A18: 4BBF99C1  bl 0x822c03d8
	ctx.lr = 0x826C6A1C;
	sub_822C03D8(ctx, base);
	// 826C6A1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6A20: 4182008C  beq 0x826c6aac
	if ctx.cr[0].eq {
	pc = 0x826C6AAC; continue 'dispatch;
	}
	// 826C6A24: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C6A28: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C6A2C: 3BABC248  addi r29, r11, -0x3db8
	ctx.r[29].s64 = ctx.r[11].s64 + -15800;
	// 826C6A30: 809D0074  lwz r4, 0x74(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 826C6A34: 4872CFD5  bl 0x82df3a08
	ctx.lr = 0x826C6A38;
	sub_82DF3A08(ctx, base);
	// 826C6A38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C6A3C: 809D0070  lwz r4, 0x70(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 826C6A40: 4872CFC9  bl 0x82df3a08
	ctx.lr = 0x826C6A44;
	sub_82DF3A08(ctx, base);
	// 826C6A44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C6A48: 809D006C  lwz r4, 0x6c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 826C6A4C: 4872CFBD  bl 0x82df3a08
	ctx.lr = 0x826C6A50;
	sub_82DF3A08(ctx, base);
	// 826C6A50: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C6A54: 809D0068  lwz r4, 0x68(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 826C6A58: 4872CFB1  bl 0x82df3a08
	ctx.lr = 0x826C6A5C;
	sub_82DF3A08(ctx, base);
	// 826C6A5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6A60: 809DFFFC  lwz r4, -4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 826C6A64: 4872CFA5  bl 0x82df3a08
	ctx.lr = 0x826C6A68;
	sub_82DF3A08(ctx, base);
	// 826C6A68: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C6A6C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C6A70: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C6A74: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C6A78: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C6A7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C6A80: 38CB7FCC  addi r6, r11, 0x7fcc
	ctx.r[6].s64 = ctx.r[11].s64 + 32716;
	// 826C6A84: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C6A88: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C6A8C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C6A90: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C6A94: 38A0001A  li r5, 0x1a
	ctx.r[5].s64 = 26;
	// 826C6A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6A9C: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C6AA0: 4BFFE059  bl 0x826c4af8
	ctx.lr = 0x826C6AA4;
	sub_826C4AF8(ctx, base);
	// 826C6AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6AA8: 48000008  b 0x826c6ab0
	pc = 0x826C6AB0; continue 'dispatch;
	// 826C6AAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6AB0: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6AB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6AB8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6ABC: 4BFFF19D  bl 0x826c5c58
	ctx.lr = 0x826C6AC0;
	sub_826C5C58(ctx, base);
	// 826C6AC0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6AC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6AC8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6ACC: 4BBF9535  bl 0x822c0000
	ctx.lr = 0x826C6AD0;
	sub_822C0000(ctx, base);
	// 826C6AD0: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6AD4: 41820010  beq 0x826c6ae4
	if ctx.cr[0].eq {
	pc = 0x826C6AE4; continue 'dispatch;
	}
	// 826C6AD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6ADC: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6AE0: 4872C949  bl 0x82df3428
	ctx.lr = 0x826C6AE4;
	sub_82DF3428(ctx, base);
	// 826C6AE4: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6AE8: 41820010  beq 0x826c6af8
	if ctx.cr[0].eq {
	pc = 0x826C6AF8; continue 'dispatch;
	}
	// 826C6AEC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C6AF0: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6AF4: 4872C935  bl 0x82df3428
	ctx.lr = 0x826C6AF8;
	sub_82DF3428(ctx, base);
	// 826C6AF8: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6AFC: 41820010  beq 0x826c6b0c
	if ctx.cr[0].eq {
	pc = 0x826C6B0C; continue 'dispatch;
	}
	// 826C6B00: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C6B04: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6B08: 4872C921  bl 0x82df3428
	ctx.lr = 0x826C6B0C;
	sub_82DF3428(ctx, base);
	// 826C6B0C: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6B10: 41820010  beq 0x826c6b20
	if ctx.cr[0].eq {
	pc = 0x826C6B20; continue 'dispatch;
	}
	// 826C6B14: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C6B18: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6B1C: 4872C90D  bl 0x82df3428
	ctx.lr = 0x826C6B20;
	sub_82DF3428(ctx, base);
	// 826C6B20: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6B24: 41820010  beq 0x826c6b34
	if ctx.cr[0].eq {
	pc = 0x826C6B34; continue 'dispatch;
	}
	// 826C6B28: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C6B2C: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6B30: 4872C8F9  bl 0x82df3428
	ctx.lr = 0x826C6B34;
	sub_82DF3428(ctx, base);
	// 826C6B34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6B38: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6B3C: 38A00221  li r5, 0x221
	ctx.r[5].s64 = 545;
	// 826C6B40: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C6B44: 4872B8A5  bl 0x82df23e8
	ctx.lr = 0x826C6B48;
	sub_82DF23E8(ctx, base);
	// 826C6B48: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6B4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C6B50: 41820048  beq 0x826c6b98
	if ctx.cr[0].eq {
	pc = 0x826C6B98; continue 'dispatch;
	}
	// 826C6B54: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6B58: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C6B5C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C6B60: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C6B64: 419A0024  beq cr6, 0x826c6b88
	if ctx.cr[6].eq {
	pc = 0x826C6B88; continue 'dispatch;
	}
	// 826C6B68: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C6B6C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C6B70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6B74: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6B78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6B7C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6B80: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6B84: 4082FFE8  bne 0x826c6b6c
	if !ctx.cr[0].eq {
	pc = 0x826C6B6C; continue 'dispatch;
	}
	// 826C6B88: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C6B8C: 4BFFE975  bl 0x826c5500
	ctx.lr = 0x826C6B90;
	sub_826C5500(ctx, base);
	// 826C6B90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6B94: 48000008  b 0x826c6b9c
	pc = 0x826C6B9C; continue 'dispatch;
	// 826C6B98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6B9C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6BA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6BA4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6BA8: 4BFFE039  bl 0x826c4be0
	ctx.lr = 0x826C6BAC;
	sub_826C4BE0(ctx, base);
	// 826C6BAC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6BB4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6BB8: 4BBF9449  bl 0x822c0000
	ctx.lr = 0x826C6BBC;
	sub_822C0000(ctx, base);
	// 826C6BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6BC0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6BC4: 38A00222  li r5, 0x222
	ctx.r[5].s64 = 546;
	// 826C6BC8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C6BCC: 4BBF980D  bl 0x822c03d8
	ctx.lr = 0x826C6BD0;
	sub_822C03D8(ctx, base);
	// 826C6BD0: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6BD4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6BD8: 418200B4  beq 0x826c6c8c
	if ctx.cr[0].eq {
	pc = 0x826C6C8C; continue 'dispatch;
	}
	// 826C6BDC: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6BE0: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C6BE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C6BE8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C6BEC: 409A0008  bne cr6, 0x826c6bf4
	if !ctx.cr[6].eq {
	pc = 0x826C6BF4; continue 'dispatch;
	}
	// 826C6BF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C6BF4: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C6BF8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6BFC: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C6C00: 419A0024  beq cr6, 0x826c6c24
	if ctx.cr[6].eq {
	pc = 0x826C6C24; continue 'dispatch;
	}
	// 826C6C04: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C6C08: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C6C0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6C10: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C6C14: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C6C18: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6C1C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6C20: 4082FFE8  bne 0x826c6c08
	if !ctx.cr[0].eq {
	pc = 0x826C6C08; continue 'dispatch;
	}
	// 826C6C24: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C6C28: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6C2C: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C6C30: 419A0024  beq cr6, 0x826c6c54
	if ctx.cr[6].eq {
	pc = 0x826C6C54; continue 'dispatch;
	}
	// 826C6C34: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C6C38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C6C3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6C40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6C44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6C48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6C4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6C50: 4082FFE8  bne 0x826c6c38
	if !ctx.cr[0].eq {
	pc = 0x826C6C38; continue 'dispatch;
	}
	// 826C6C54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C6C58: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C6C5C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C6C60: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C6C64: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C6C68: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C6C6C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C6C70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C6C74: 480D22BD  bl 0x82798f30
	ctx.lr = 0x826C6C78;
	sub_82798F30(ctx, base);
	// 826C6C78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C6C7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6C80: 480D49E9  bl 0x8279b668
	ctx.lr = 0x826C6C84;
	sub_8279B668(ctx, base);
	// 826C6C84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6C88: 48000008  b 0x826c6c90
	pc = 0x826C6C90; continue 'dispatch;
	// 826C6C8C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6C90: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C6C94: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C6C98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6C9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6CA0: 4BED0FB1  bl 0x82597c50
	ctx.lr = 0x826C6CA4;
	sub_82597C50(ctx, base);
	// 826C6CA4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6CA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6CB0: 4BBF9351  bl 0x822c0000
	ctx.lr = 0x826C6CB4;
	sub_822C0000(ctx, base);
	// 826C6CB4: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6CB8: 41820024  beq 0x826c6cdc
	if ctx.cr[0].eq {
	pc = 0x826C6CDC; continue 'dispatch;
	}
	// 826C6CBC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C6CC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6CC4: 419A0008  beq cr6, 0x826c6ccc
	if ctx.cr[6].eq {
	pc = 0x826C6CCC; continue 'dispatch;
	}
	// 826C6CC8: 4BBF9BC9  bl 0x822c0890
	ctx.lr = 0x826C6CCC;
	sub_822C0890(ctx, base);
	// 826C6CCC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C6CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6CD4: 419A0008  beq cr6, 0x826c6cdc
	if ctx.cr[6].eq {
	pc = 0x826C6CDC; continue 'dispatch;
	}
	// 826C6CD8: 4BBF9BB9  bl 0x822c0890
	ctx.lr = 0x826C6CDC;
	sub_822C0890(ctx, base);
	// 826C6CDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6CE0: 419A000C  beq cr6, 0x826c6cec
	if ctx.cr[6].eq {
	pc = 0x826C6CEC; continue 'dispatch;
	}
	// 826C6CE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C6CE8: 4BBF9BA9  bl 0x822c0890
	ctx.lr = 0x826C6CEC;
	sub_822C0890(ctx, base);
	// 826C6CEC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C6CF0: 419A000C  beq cr6, 0x826c6cfc
	if ctx.cr[6].eq {
	pc = 0x826C6CFC; continue 'dispatch;
	}
	// 826C6CF4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C6CF8: 4BBF9B99  bl 0x822c0890
	ctx.lr = 0x826C6CFC;
	sub_822C0890(ctx, base);
	// 826C6CFC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C6D00: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C6D04: 48AE14AC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C6D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C6D08 size=800
    let mut pc: u32 = 0x826C6D08;
    'dispatch: loop {
        match pc {
            0x826C6D08 => {
    //   block [0x826C6D08..0x826C7028)
	// 826C6D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C6D0C: 48AE1455  bl 0x831a8160
	ctx.lr = 0x826C6D10;
	sub_831A8130(ctx, base);
	// 826C6D10: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C6D14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C6D18: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C6D1C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C6D20: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C6D24: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C6D28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6D2C: 38A00227  li r5, 0x227
	ctx.r[5].s64 = 551;
	// 826C6D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6D34: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C6D38: 4BBF96A1  bl 0x822c03d8
	ctx.lr = 0x826C6D3C;
	sub_822C03D8(ctx, base);
	// 826C6D3C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6D40: 4182008C  beq 0x826c6dcc
	if ctx.cr[0].eq {
	pc = 0x826C6DCC; continue 'dispatch;
	}
	// 826C6D44: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C6D48: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C6D4C: 3BABC2C0  addi r29, r11, -0x3d40
	ctx.r[29].s64 = ctx.r[11].s64 + -15680;
	// 826C6D50: 809D008C  lwz r4, 0x8c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C6D54: 4872CCB5  bl 0x82df3a08
	ctx.lr = 0x826C6D58;
	sub_82DF3A08(ctx, base);
	// 826C6D58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C6D5C: 809D0088  lwz r4, 0x88(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 826C6D60: 4872CCA9  bl 0x82df3a08
	ctx.lr = 0x826C6D64;
	sub_82DF3A08(ctx, base);
	// 826C6D64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C6D68: 809D0084  lwz r4, 0x84(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6D6C: 4872CC9D  bl 0x82df3a08
	ctx.lr = 0x826C6D70;
	sub_82DF3A08(ctx, base);
	// 826C6D70: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C6D74: 809D0080  lwz r4, 0x80(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6D78: 4872CC91  bl 0x82df3a08
	ctx.lr = 0x826C6D7C;
	sub_82DF3A08(ctx, base);
	// 826C6D7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6D80: 809D007C  lwz r4, 0x7c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) } as u64;
	// 826C6D84: 4872CC85  bl 0x82df3a08
	ctx.lr = 0x826C6D88;
	sub_82DF3A08(ctx, base);
	// 826C6D88: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C6D8C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C6D90: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C6D94: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C6D98: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C6D9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C6DA0: 38CB7FE0  addi r6, r11, 0x7fe0
	ctx.r[6].s64 = ctx.r[11].s64 + 32736;
	// 826C6DA4: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C6DA8: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C6DAC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C6DB0: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C6DB4: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 826C6DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6DBC: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C6DC0: 4BFFDD39  bl 0x826c4af8
	ctx.lr = 0x826C6DC4;
	sub_826C4AF8(ctx, base);
	// 826C6DC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6DC8: 48000008  b 0x826c6dd0
	pc = 0x826C6DD0; continue 'dispatch;
	// 826C6DCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6DD0: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6DD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6DD8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6DDC: 4BFFEE7D  bl 0x826c5c58
	ctx.lr = 0x826C6DE0;
	sub_826C5C58(ctx, base);
	// 826C6DE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6DE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6DE8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6DEC: 4BBF9215  bl 0x822c0000
	ctx.lr = 0x826C6DF0;
	sub_822C0000(ctx, base);
	// 826C6DF0: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6DF4: 41820010  beq 0x826c6e04
	if ctx.cr[0].eq {
	pc = 0x826C6E04; continue 'dispatch;
	}
	// 826C6DF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C6DFC: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6E00: 4872C629  bl 0x82df3428
	ctx.lr = 0x826C6E04;
	sub_82DF3428(ctx, base);
	// 826C6E04: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6E08: 41820010  beq 0x826c6e18
	if ctx.cr[0].eq {
	pc = 0x826C6E18; continue 'dispatch;
	}
	// 826C6E0C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C6E10: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6E14: 4872C615  bl 0x82df3428
	ctx.lr = 0x826C6E18;
	sub_82DF3428(ctx, base);
	// 826C6E18: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6E1C: 41820010  beq 0x826c6e2c
	if ctx.cr[0].eq {
	pc = 0x826C6E2C; continue 'dispatch;
	}
	// 826C6E20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C6E24: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6E28: 4872C601  bl 0x82df3428
	ctx.lr = 0x826C6E2C;
	sub_82DF3428(ctx, base);
	// 826C6E2C: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6E30: 41820010  beq 0x826c6e40
	if ctx.cr[0].eq {
	pc = 0x826C6E40; continue 'dispatch;
	}
	// 826C6E34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C6E38: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6E3C: 4872C5ED  bl 0x82df3428
	ctx.lr = 0x826C6E40;
	sub_82DF3428(ctx, base);
	// 826C6E40: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6E44: 41820010  beq 0x826c6e54
	if ctx.cr[0].eq {
	pc = 0x826C6E54; continue 'dispatch;
	}
	// 826C6E48: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C6E4C: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C6E50: 4872C5D9  bl 0x82df3428
	ctx.lr = 0x826C6E54;
	sub_82DF3428(ctx, base);
	// 826C6E54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6E58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6E5C: 38A00228  li r5, 0x228
	ctx.r[5].s64 = 552;
	// 826C6E60: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C6E64: 4872B585  bl 0x82df23e8
	ctx.lr = 0x826C6E68;
	sub_82DF23E8(ctx, base);
	// 826C6E68: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6E6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C6E70: 41820048  beq 0x826c6eb8
	if ctx.cr[0].eq {
	pc = 0x826C6EB8; continue 'dispatch;
	}
	// 826C6E74: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6E78: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C6E7C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C6E80: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C6E84: 419A0024  beq cr6, 0x826c6ea8
	if ctx.cr[6].eq {
	pc = 0x826C6EA8; continue 'dispatch;
	}
	// 826C6E88: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C6E8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C6E90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6E94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6E98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6E9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6EA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6EA4: 4082FFE8  bne 0x826c6e8c
	if !ctx.cr[0].eq {
	pc = 0x826C6E8C; continue 'dispatch;
	}
	// 826C6EA8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C6EAC: 4BFFE655  bl 0x826c5500
	ctx.lr = 0x826C6EB0;
	sub_826C5500(ctx, base);
	// 826C6EB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6EB4: 48000008  b 0x826c6ebc
	pc = 0x826C6EBC; continue 'dispatch;
	// 826C6EB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6EBC: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C6EC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6EC4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6EC8: 4BFFDD19  bl 0x826c4be0
	ctx.lr = 0x826C6ECC;
	sub_826C4BE0(ctx, base);
	// 826C6ECC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6ED4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C6ED8: 4BBF9129  bl 0x822c0000
	ctx.lr = 0x826C6EDC;
	sub_822C0000(ctx, base);
	// 826C6EDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C6EE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C6EE4: 38A00229  li r5, 0x229
	ctx.r[5].s64 = 553;
	// 826C6EE8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C6EEC: 4BBF94ED  bl 0x822c03d8
	ctx.lr = 0x826C6EF0;
	sub_822C03D8(ctx, base);
	// 826C6EF0: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C6EF4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C6EF8: 418200B4  beq 0x826c6fac
	if ctx.cr[0].eq {
	pc = 0x826C6FAC; continue 'dispatch;
	}
	// 826C6EFC: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C6F00: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C6F04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C6F08: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C6F0C: 409A0008  bne cr6, 0x826c6f14
	if !ctx.cr[6].eq {
	pc = 0x826C6F14; continue 'dispatch;
	}
	// 826C6F10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C6F14: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C6F18: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6F1C: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C6F20: 419A0024  beq cr6, 0x826c6f44
	if ctx.cr[6].eq {
	pc = 0x826C6F44; continue 'dispatch;
	}
	// 826C6F24: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C6F28: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C6F2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6F30: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C6F34: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C6F38: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6F3C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6F40: 4082FFE8  bne 0x826c6f28
	if !ctx.cr[0].eq {
	pc = 0x826C6F28; continue 'dispatch;
	}
	// 826C6F44: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C6F48: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C6F4C: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C6F50: 419A0024  beq cr6, 0x826c6f74
	if ctx.cr[6].eq {
	pc = 0x826C6F74; continue 'dispatch;
	}
	// 826C6F54: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C6F58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C6F5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6F60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C6F64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C6F68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C6F6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C6F70: 4082FFE8  bne 0x826c6f58
	if !ctx.cr[0].eq {
	pc = 0x826C6F58; continue 'dispatch;
	}
	// 826C6F74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C6F78: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C6F7C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C6F80: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C6F84: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C6F88: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C6F8C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C6F90: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C6F94: 480D1F9D  bl 0x82798f30
	ctx.lr = 0x826C6F98;
	sub_82798F30(ctx, base);
	// 826C6F98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C6F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C6FA0: 480D46C9  bl 0x8279b668
	ctx.lr = 0x826C6FA4;
	sub_8279B668(ctx, base);
	// 826C6FA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C6FA8: 48000008  b 0x826c6fb0
	pc = 0x826C6FB0; continue 'dispatch;
	// 826C6FAC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C6FB0: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C6FB4: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C6FB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6FBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6FC0: 4BED0C91  bl 0x82597c50
	ctx.lr = 0x826C6FC4;
	sub_82597C50(ctx, base);
	// 826C6FC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C6FC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C6FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C6FD0: 4BBF9031  bl 0x822c0000
	ctx.lr = 0x826C6FD4;
	sub_822C0000(ctx, base);
	// 826C6FD4: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C6FD8: 41820024  beq 0x826c6ffc
	if ctx.cr[0].eq {
	pc = 0x826C6FFC; continue 'dispatch;
	}
	// 826C6FDC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C6FE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6FE4: 419A0008  beq cr6, 0x826c6fec
	if ctx.cr[6].eq {
	pc = 0x826C6FEC; continue 'dispatch;
	}
	// 826C6FE8: 4BBF98A9  bl 0x822c0890
	ctx.lr = 0x826C6FEC;
	sub_822C0890(ctx, base);
	// 826C6FEC: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C6FF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C6FF4: 419A0008  beq cr6, 0x826c6ffc
	if ctx.cr[6].eq {
	pc = 0x826C6FFC; continue 'dispatch;
	}
	// 826C6FF8: 4BBF9899  bl 0x822c0890
	ctx.lr = 0x826C6FFC;
	sub_822C0890(ctx, base);
	// 826C6FFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7000: 419A000C  beq cr6, 0x826c700c
	if ctx.cr[6].eq {
	pc = 0x826C700C; continue 'dispatch;
	}
	// 826C7004: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C7008: 4BBF9889  bl 0x822c0890
	ctx.lr = 0x826C700C;
	sub_822C0890(ctx, base);
	// 826C700C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7010: 419A000C  beq cr6, 0x826c701c
	if ctx.cr[6].eq {
	pc = 0x826C701C; continue 'dispatch;
	}
	// 826C7014: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C7018: 4BBF9879  bl 0x822c0890
	ctx.lr = 0x826C701C;
	sub_822C0890(ctx, base);
	// 826C701C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C7020: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C7024: 48AE118C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C7028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C7028 size=800
    let mut pc: u32 = 0x826C7028;
    'dispatch: loop {
        match pc {
            0x826C7028 => {
    //   block [0x826C7028..0x826C7348)
	// 826C7028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C702C: 48AE1135  bl 0x831a8160
	ctx.lr = 0x826C7030;
	sub_831A8130(ctx, base);
	// 826C7030: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C7034: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C7038: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C703C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C7040: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C7044: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C7048: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C704C: 38A0022E  li r5, 0x22e
	ctx.r[5].s64 = 558;
	// 826C7050: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7054: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C7058: 4BBF9381  bl 0x822c03d8
	ctx.lr = 0x826C705C;
	sub_822C03D8(ctx, base);
	// 826C705C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7060: 4182008C  beq 0x826c70ec
	if ctx.cr[0].eq {
	pc = 0x826C70EC; continue 'dispatch;
	}
	// 826C7064: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C7068: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C706C: 3BABC350  addi r29, r11, -0x3cb0
	ctx.r[29].s64 = ctx.r[11].s64 + -15536;
	// 826C7070: 809D0060  lwz r4, 0x60(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C7074: 4872C995  bl 0x82df3a08
	ctx.lr = 0x826C7078;
	sub_82DF3A08(ctx, base);
	// 826C7078: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C707C: 809D005C  lwz r4, 0x5c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C7080: 4872C989  bl 0x82df3a08
	ctx.lr = 0x826C7084;
	sub_82DF3A08(ctx, base);
	// 826C7084: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7088: 809D0058  lwz r4, 0x58(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C708C: 4872C97D  bl 0x82df3a08
	ctx.lr = 0x826C7090;
	sub_82DF3A08(ctx, base);
	// 826C7090: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7094: 809D0054  lwz r4, 0x54(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C7098: 4872C971  bl 0x82df3a08
	ctx.lr = 0x826C709C;
	sub_82DF3A08(ctx, base);
	// 826C709C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C70A0: 809D0050  lwz r4, 0x50(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C70A4: 4872C965  bl 0x82df3a08
	ctx.lr = 0x826C70A8;
	sub_82DF3A08(ctx, base);
	// 826C70A8: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C70AC: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C70B0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826C70B4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C70B8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C70BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C70C0: 38CB7FF4  addi r6, r11, 0x7ff4
	ctx.r[6].s64 = ctx.r[11].s64 + 32756;
	// 826C70C4: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C70C8: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C70CC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C70D0: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C70D4: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 826C70D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C70DC: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C70E0: 4BFFDA19  bl 0x826c4af8
	ctx.lr = 0x826C70E4;
	sub_826C4AF8(ctx, base);
	// 826C70E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C70E8: 48000008  b 0x826c70f0
	pc = 0x826C70F0; continue 'dispatch;
	// 826C70EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C70F0: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C70F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C70F8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C70FC: 4BFFEB5D  bl 0x826c5c58
	ctx.lr = 0x826C7100;
	sub_826C5C58(ctx, base);
	// 826C7100: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7108: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C710C: 4BBF8EF5  bl 0x822c0000
	ctx.lr = 0x826C7110;
	sub_822C0000(ctx, base);
	// 826C7110: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7114: 41820010  beq 0x826c7124
	if ctx.cr[0].eq {
	pc = 0x826C7124; continue 'dispatch;
	}
	// 826C7118: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C711C: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7120: 4872C309  bl 0x82df3428
	ctx.lr = 0x826C7124;
	sub_82DF3428(ctx, base);
	// 826C7124: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7128: 41820010  beq 0x826c7138
	if ctx.cr[0].eq {
	pc = 0x826C7138; continue 'dispatch;
	}
	// 826C712C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7130: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7134: 4872C2F5  bl 0x82df3428
	ctx.lr = 0x826C7138;
	sub_82DF3428(ctx, base);
	// 826C7138: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C713C: 41820010  beq 0x826c714c
	if ctx.cr[0].eq {
	pc = 0x826C714C; continue 'dispatch;
	}
	// 826C7140: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7144: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7148: 4872C2E1  bl 0x82df3428
	ctx.lr = 0x826C714C;
	sub_82DF3428(ctx, base);
	// 826C714C: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7150: 41820010  beq 0x826c7160
	if ctx.cr[0].eq {
	pc = 0x826C7160; continue 'dispatch;
	}
	// 826C7154: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C7158: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C715C: 4872C2CD  bl 0x82df3428
	ctx.lr = 0x826C7160;
	sub_82DF3428(ctx, base);
	// 826C7160: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7164: 41820010  beq 0x826c7174
	if ctx.cr[0].eq {
	pc = 0x826C7174; continue 'dispatch;
	}
	// 826C7168: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C716C: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7170: 4872C2B9  bl 0x82df3428
	ctx.lr = 0x826C7174;
	sub_82DF3428(ctx, base);
	// 826C7174: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7178: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C717C: 38A0022F  li r5, 0x22f
	ctx.r[5].s64 = 559;
	// 826C7180: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C7184: 4872B265  bl 0x82df23e8
	ctx.lr = 0x826C7188;
	sub_82DF23E8(ctx, base);
	// 826C7188: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C718C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C7190: 41820048  beq 0x826c71d8
	if ctx.cr[0].eq {
	pc = 0x826C71D8; continue 'dispatch;
	}
	// 826C7194: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7198: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C719C: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C71A0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C71A4: 419A0024  beq cr6, 0x826c71c8
	if ctx.cr[6].eq {
	pc = 0x826C71C8; continue 'dispatch;
	}
	// 826C71A8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C71AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C71B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C71B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C71B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C71BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C71C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C71C4: 4082FFE8  bne 0x826c71ac
	if !ctx.cr[0].eq {
	pc = 0x826C71AC; continue 'dispatch;
	}
	// 826C71C8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C71CC: 4BFFE335  bl 0x826c5500
	ctx.lr = 0x826C71D0;
	sub_826C5500(ctx, base);
	// 826C71D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C71D4: 48000008  b 0x826c71dc
	pc = 0x826C71DC; continue 'dispatch;
	// 826C71D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C71DC: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C71E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C71E4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C71E8: 4BFFD9F9  bl 0x826c4be0
	ctx.lr = 0x826C71EC;
	sub_826C4BE0(ctx, base);
	// 826C71EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C71F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C71F4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C71F8: 4BBF8E09  bl 0x822c0000
	ctx.lr = 0x826C71FC;
	sub_822C0000(ctx, base);
	// 826C71FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7200: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7204: 38A00230  li r5, 0x230
	ctx.r[5].s64 = 560;
	// 826C7208: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C720C: 4BBF91CD  bl 0x822c03d8
	ctx.lr = 0x826C7210;
	sub_822C03D8(ctx, base);
	// 826C7210: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7214: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7218: 418200B4  beq 0x826c72cc
	if ctx.cr[0].eq {
	pc = 0x826C72CC; continue 'dispatch;
	}
	// 826C721C: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7220: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C7224: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C7228: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C722C: 409A0008  bne cr6, 0x826c7234
	if !ctx.cr[6].eq {
	pc = 0x826C7234; continue 'dispatch;
	}
	// 826C7230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C7234: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C7238: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C723C: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C7240: 419A0024  beq cr6, 0x826c7264
	if ctx.cr[6].eq {
	pc = 0x826C7264; continue 'dispatch;
	}
	// 826C7244: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7248: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C724C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7250: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C7254: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C7258: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C725C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7260: 4082FFE8  bne 0x826c7248
	if !ctx.cr[0].eq {
	pc = 0x826C7248; continue 'dispatch;
	}
	// 826C7264: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C7268: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C726C: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C7270: 419A0024  beq cr6, 0x826c7294
	if ctx.cr[6].eq {
	pc = 0x826C7294; continue 'dispatch;
	}
	// 826C7274: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7278: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C727C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7280: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C7284: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C7288: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C728C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7290: 4082FFE8  bne 0x826c7278
	if !ctx.cr[0].eq {
	pc = 0x826C7278; continue 'dispatch;
	}
	// 826C7294: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C7298: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C729C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C72A0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C72A4: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C72A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C72AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C72B0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C72B4: 480D1C7D  bl 0x82798f30
	ctx.lr = 0x826C72B8;
	sub_82798F30(ctx, base);
	// 826C72B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C72BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C72C0: 480D43A9  bl 0x8279b668
	ctx.lr = 0x826C72C4;
	sub_8279B668(ctx, base);
	// 826C72C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C72C8: 48000008  b 0x826c72d0
	pc = 0x826C72D0; continue 'dispatch;
	// 826C72CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C72D0: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C72D4: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C72D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C72DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C72E0: 4BED0971  bl 0x82597c50
	ctx.lr = 0x826C72E4;
	sub_82597C50(ctx, base);
	// 826C72E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C72E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C72EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C72F0: 4BBF8D11  bl 0x822c0000
	ctx.lr = 0x826C72F4;
	sub_822C0000(ctx, base);
	// 826C72F4: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C72F8: 41820024  beq 0x826c731c
	if ctx.cr[0].eq {
	pc = 0x826C731C; continue 'dispatch;
	}
	// 826C72FC: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C7300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7304: 419A0008  beq cr6, 0x826c730c
	if ctx.cr[6].eq {
	pc = 0x826C730C; continue 'dispatch;
	}
	// 826C7308: 4BBF9589  bl 0x822c0890
	ctx.lr = 0x826C730C;
	sub_822C0890(ctx, base);
	// 826C730C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C7310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7314: 419A0008  beq cr6, 0x826c731c
	if ctx.cr[6].eq {
	pc = 0x826C731C; continue 'dispatch;
	}
	// 826C7318: 4BBF9579  bl 0x822c0890
	ctx.lr = 0x826C731C;
	sub_822C0890(ctx, base);
	// 826C731C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7320: 419A000C  beq cr6, 0x826c732c
	if ctx.cr[6].eq {
	pc = 0x826C732C; continue 'dispatch;
	}
	// 826C7324: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C7328: 4BBF9569  bl 0x822c0890
	ctx.lr = 0x826C732C;
	sub_822C0890(ctx, base);
	// 826C732C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7330: 419A000C  beq cr6, 0x826c733c
	if ctx.cr[6].eq {
	pc = 0x826C733C; continue 'dispatch;
	}
	// 826C7334: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C7338: 4BBF9559  bl 0x822c0890
	ctx.lr = 0x826C733C;
	sub_822C0890(ctx, base);
	// 826C733C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C7340: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C7344: 48AE0E6C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C7348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C7348 size=804
    let mut pc: u32 = 0x826C7348;
    'dispatch: loop {
        match pc {
            0x826C7348 => {
    //   block [0x826C7348..0x826C766C)
	// 826C7348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C734C: 48AE0E15  bl 0x831a8160
	ctx.lr = 0x826C7350;
	sub_831A8130(ctx, base);
	// 826C7350: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C7354: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C7358: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C735C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C7360: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C7364: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C7368: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C736C: 38A00235  li r5, 0x235
	ctx.r[5].s64 = 565;
	// 826C7370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7374: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C7378: 4BBF9061  bl 0x822c03d8
	ctx.lr = 0x826C737C;
	sub_822C03D8(ctx, base);
	// 826C737C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7380: 41820090  beq 0x826c7410
	if ctx.cr[0].eq {
	pc = 0x826C7410; continue 'dispatch;
	}
	// 826C7384: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C7388: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C738C: 808B8220  lwz r4, -0x7de0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32224 as u32) ) } as u64;
	// 826C7390: 4872C679  bl 0x82df3a08
	ctx.lr = 0x826C7394;
	sub_82DF3A08(ctx, base);
	// 826C7394: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C7398: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C739C: 3BABC3B8  addi r29, r11, -0x3c48
	ctx.r[29].s64 = ctx.r[11].s64 + -15432;
	// 826C73A0: 809D0054  lwz r4, 0x54(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C73A4: 4872C665  bl 0x82df3a08
	ctx.lr = 0x826C73A8;
	sub_82DF3A08(ctx, base);
	// 826C73A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C73AC: 809D0050  lwz r4, 0x50(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C73B0: 4872C659  bl 0x82df3a08
	ctx.lr = 0x826C73B4;
	sub_82DF3A08(ctx, base);
	// 826C73B4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C73B8: 809D004C  lwz r4, 0x4c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) } as u64;
	// 826C73BC: 4872C64D  bl 0x82df3a08
	ctx.lr = 0x826C73C0;
	sub_82DF3A08(ctx, base);
	// 826C73C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C73C4: 809DFFFC  lwz r4, -4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 826C73C8: 4872C641  bl 0x82df3a08
	ctx.lr = 0x826C73CC;
	sub_82DF3A08(ctx, base);
	// 826C73CC: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C73D0: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C73D4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C73D8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C73DC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C73E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C73E4: 38CB8008  addi r6, r11, -0x7ff8
	ctx.r[6].s64 = ctx.r[11].s64 + -32760;
	// 826C73E8: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C73EC: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C73F0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C73F4: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C73F8: 38A00013  li r5, 0x13
	ctx.r[5].s64 = 19;
	// 826C73FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C7400: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C7404: 4BFFD6F5  bl 0x826c4af8
	ctx.lr = 0x826C7408;
	sub_826C4AF8(ctx, base);
	// 826C7408: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C740C: 48000008  b 0x826c7414
	pc = 0x826C7414; continue 'dispatch;
	// 826C7410: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7414: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C741C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7420: 4BFFE839  bl 0x826c5c58
	ctx.lr = 0x826C7424;
	sub_826C5C58(ctx, base);
	// 826C7424: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C742C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7430: 4BBF8BD1  bl 0x822c0000
	ctx.lr = 0x826C7434;
	sub_822C0000(ctx, base);
	// 826C7434: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7438: 41820010  beq 0x826c7448
	if ctx.cr[0].eq {
	pc = 0x826C7448; continue 'dispatch;
	}
	// 826C743C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C7440: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7444: 4872BFE5  bl 0x82df3428
	ctx.lr = 0x826C7448;
	sub_82DF3428(ctx, base);
	// 826C7448: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C744C: 41820010  beq 0x826c745c
	if ctx.cr[0].eq {
	pc = 0x826C745C; continue 'dispatch;
	}
	// 826C7450: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7454: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7458: 4872BFD1  bl 0x82df3428
	ctx.lr = 0x826C745C;
	sub_82DF3428(ctx, base);
	// 826C745C: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7460: 41820010  beq 0x826c7470
	if ctx.cr[0].eq {
	pc = 0x826C7470; continue 'dispatch;
	}
	// 826C7464: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7468: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C746C: 4872BFBD  bl 0x82df3428
	ctx.lr = 0x826C7470;
	sub_82DF3428(ctx, base);
	// 826C7470: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7474: 41820010  beq 0x826c7484
	if ctx.cr[0].eq {
	pc = 0x826C7484; continue 'dispatch;
	}
	// 826C7478: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C747C: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7480: 4872BFA9  bl 0x82df3428
	ctx.lr = 0x826C7484;
	sub_82DF3428(ctx, base);
	// 826C7484: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7488: 41820010  beq 0x826c7498
	if ctx.cr[0].eq {
	pc = 0x826C7498; continue 'dispatch;
	}
	// 826C748C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C7490: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7494: 4872BF95  bl 0x82df3428
	ctx.lr = 0x826C7498;
	sub_82DF3428(ctx, base);
	// 826C7498: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C749C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C74A0: 38A00236  li r5, 0x236
	ctx.r[5].s64 = 566;
	// 826C74A4: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C74A8: 4872AF41  bl 0x82df23e8
	ctx.lr = 0x826C74AC;
	sub_82DF23E8(ctx, base);
	// 826C74AC: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C74B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C74B4: 41820048  beq 0x826c74fc
	if ctx.cr[0].eq {
	pc = 0x826C74FC; continue 'dispatch;
	}
	// 826C74B8: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C74BC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C74C0: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C74C4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C74C8: 419A0024  beq cr6, 0x826c74ec
	if ctx.cr[6].eq {
	pc = 0x826C74EC; continue 'dispatch;
	}
	// 826C74CC: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C74D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C74D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C74D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C74DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C74E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C74E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C74E8: 4082FFE8  bne 0x826c74d0
	if !ctx.cr[0].eq {
	pc = 0x826C74D0; continue 'dispatch;
	}
	// 826C74EC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C74F0: 4BFFE011  bl 0x826c5500
	ctx.lr = 0x826C74F4;
	sub_826C5500(ctx, base);
	// 826C74F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C74F8: 48000008  b 0x826c7500
	pc = 0x826C7500; continue 'dispatch;
	// 826C74FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7500: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7508: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C750C: 4BFFD6D5  bl 0x826c4be0
	ctx.lr = 0x826C7510;
	sub_826C4BE0(ctx, base);
	// 826C7510: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7518: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C751C: 4BBF8AE5  bl 0x822c0000
	ctx.lr = 0x826C7520;
	sub_822C0000(ctx, base);
	// 826C7520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7524: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7528: 38A00237  li r5, 0x237
	ctx.r[5].s64 = 567;
	// 826C752C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C7530: 4BBF8EA9  bl 0x822c03d8
	ctx.lr = 0x826C7534;
	sub_822C03D8(ctx, base);
	// 826C7534: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7538: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C753C: 418200B4  beq 0x826c75f0
	if ctx.cr[0].eq {
	pc = 0x826C75F0; continue 'dispatch;
	}
	// 826C7540: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7544: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C7548: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C754C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C7550: 409A0008  bne cr6, 0x826c7558
	if !ctx.cr[6].eq {
	pc = 0x826C7558; continue 'dispatch;
	}
	// 826C7554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C7558: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C755C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7560: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C7564: 419A0024  beq cr6, 0x826c7588
	if ctx.cr[6].eq {
	pc = 0x826C7588; continue 'dispatch;
	}
	// 826C7568: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C756C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C7570: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7574: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C7578: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C757C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7580: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7584: 4082FFE8  bne 0x826c756c
	if !ctx.cr[0].eq {
	pc = 0x826C756C; continue 'dispatch;
	}
	// 826C7588: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C758C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7590: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C7594: 419A0024  beq cr6, 0x826c75b8
	if ctx.cr[6].eq {
	pc = 0x826C75B8; continue 'dispatch;
	}
	// 826C7598: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C759C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C75A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C75A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C75A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C75AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C75B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C75B4: 4082FFE8  bne 0x826c759c
	if !ctx.cr[0].eq {
	pc = 0x826C759C; continue 'dispatch;
	}
	// 826C75B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C75BC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C75C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C75C4: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C75C8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C75CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C75D0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C75D4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C75D8: 480D1959  bl 0x82798f30
	ctx.lr = 0x826C75DC;
	sub_82798F30(ctx, base);
	// 826C75DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C75E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C75E4: 480D4085  bl 0x8279b668
	ctx.lr = 0x826C75E8;
	sub_8279B668(ctx, base);
	// 826C75E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C75EC: 48000008  b 0x826c75f4
	pc = 0x826C75F4; continue 'dispatch;
	// 826C75F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C75F4: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C75F8: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C75FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C7604: 4BED064D  bl 0x82597c50
	ctx.lr = 0x826C7608;
	sub_82597C50(ctx, base);
	// 826C7608: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C760C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C7614: 4BBF89ED  bl 0x822c0000
	ctx.lr = 0x826C7618;
	sub_822C0000(ctx, base);
	// 826C7618: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C761C: 41820024  beq 0x826c7640
	if ctx.cr[0].eq {
	pc = 0x826C7640; continue 'dispatch;
	}
	// 826C7620: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C7624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7628: 419A0008  beq cr6, 0x826c7630
	if ctx.cr[6].eq {
	pc = 0x826C7630; continue 'dispatch;
	}
	// 826C762C: 4BBF9265  bl 0x822c0890
	ctx.lr = 0x826C7630;
	sub_822C0890(ctx, base);
	// 826C7630: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C7634: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7638: 419A0008  beq cr6, 0x826c7640
	if ctx.cr[6].eq {
	pc = 0x826C7640; continue 'dispatch;
	}
	// 826C763C: 4BBF9255  bl 0x822c0890
	ctx.lr = 0x826C7640;
	sub_822C0890(ctx, base);
	// 826C7640: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7644: 419A000C  beq cr6, 0x826c7650
	if ctx.cr[6].eq {
	pc = 0x826C7650; continue 'dispatch;
	}
	// 826C7648: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C764C: 4BBF9245  bl 0x822c0890
	ctx.lr = 0x826C7650;
	sub_822C0890(ctx, base);
	// 826C7650: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7654: 419A000C  beq cr6, 0x826c7660
	if ctx.cr[6].eq {
	pc = 0x826C7660; continue 'dispatch;
	}
	// 826C7658: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C765C: 4BBF9235  bl 0x822c0890
	ctx.lr = 0x826C7660;
	sub_822C0890(ctx, base);
	// 826C7660: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C7664: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C7668: 48AE0B48  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C7670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C7670 size=804
    let mut pc: u32 = 0x826C7670;
    'dispatch: loop {
        match pc {
            0x826C7670 => {
    //   block [0x826C7670..0x826C7994)
	// 826C7670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C7674: 48AE0AED  bl 0x831a8160
	ctx.lr = 0x826C7678;
	sub_831A8130(ctx, base);
	// 826C7678: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C767C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C7680: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C7684: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C7688: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C768C: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C7690: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7694: 38A0023C  li r5, 0x23c
	ctx.r[5].s64 = 572;
	// 826C7698: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C769C: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C76A0: 4BBF8D39  bl 0x822c03d8
	ctx.lr = 0x826C76A4;
	sub_822C03D8(ctx, base);
	// 826C76A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C76A8: 41820090  beq 0x826c7738
	if ctx.cr[0].eq {
	pc = 0x826C7738; continue 'dispatch;
	}
	// 826C76AC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C76B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C76B4: 808B8224  lwz r4, -0x7ddc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32220 as u32) ) } as u64;
	// 826C76B8: 4872C351  bl 0x82df3a08
	ctx.lr = 0x826C76BC;
	sub_82DF3A08(ctx, base);
	// 826C76BC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C76C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C76C4: 3BABC410  addi r29, r11, -0x3bf0
	ctx.r[29].s64 = ctx.r[11].s64 + -15344;
	// 826C76C8: 809D005C  lwz r4, 0x5c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C76CC: 4872C33D  bl 0x82df3a08
	ctx.lr = 0x826C76D0;
	sub_82DF3A08(ctx, base);
	// 826C76D0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C76D4: 809D0058  lwz r4, 0x58(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C76D8: 4872C331  bl 0x82df3a08
	ctx.lr = 0x826C76DC;
	sub_82DF3A08(ctx, base);
	// 826C76DC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C76E0: 809D0054  lwz r4, 0x54(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C76E4: 4872C325  bl 0x82df3a08
	ctx.lr = 0x826C76E8;
	sub_82DF3A08(ctx, base);
	// 826C76E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C76EC: 809D0050  lwz r4, 0x50(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C76F0: 4872C319  bl 0x82df3a08
	ctx.lr = 0x826C76F4;
	sub_82DF3A08(ctx, base);
	// 826C76F4: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C76F8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C76FC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C7700: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C7704: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C7708: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C770C: 38CB801C  addi r6, r11, -0x7fe4
	ctx.r[6].s64 = ctx.r[11].s64 + -32740;
	// 826C7710: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C7714: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C7718: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C771C: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C7720: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 826C7724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C7728: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C772C: 4BFFD3CD  bl 0x826c4af8
	ctx.lr = 0x826C7730;
	sub_826C4AF8(ctx, base);
	// 826C7730: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7734: 48000008  b 0x826c773c
	pc = 0x826C773C; continue 'dispatch;
	// 826C7738: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C773C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7744: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7748: 4BFFE511  bl 0x826c5c58
	ctx.lr = 0x826C774C;
	sub_826C5C58(ctx, base);
	// 826C774C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7754: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7758: 4BBF88A9  bl 0x822c0000
	ctx.lr = 0x826C775C;
	sub_822C0000(ctx, base);
	// 826C775C: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7760: 41820010  beq 0x826c7770
	if ctx.cr[0].eq {
	pc = 0x826C7770; continue 'dispatch;
	}
	// 826C7764: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C7768: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C776C: 4872BCBD  bl 0x82df3428
	ctx.lr = 0x826C7770;
	sub_82DF3428(ctx, base);
	// 826C7770: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7774: 41820010  beq 0x826c7784
	if ctx.cr[0].eq {
	pc = 0x826C7784; continue 'dispatch;
	}
	// 826C7778: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C777C: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7780: 4872BCA9  bl 0x82df3428
	ctx.lr = 0x826C7784;
	sub_82DF3428(ctx, base);
	// 826C7784: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7788: 41820010  beq 0x826c7798
	if ctx.cr[0].eq {
	pc = 0x826C7798; continue 'dispatch;
	}
	// 826C778C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7790: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7794: 4872BC95  bl 0x82df3428
	ctx.lr = 0x826C7798;
	sub_82DF3428(ctx, base);
	// 826C7798: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C779C: 41820010  beq 0x826c77ac
	if ctx.cr[0].eq {
	pc = 0x826C77AC; continue 'dispatch;
	}
	// 826C77A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C77A4: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C77A8: 4872BC81  bl 0x82df3428
	ctx.lr = 0x826C77AC;
	sub_82DF3428(ctx, base);
	// 826C77AC: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C77B0: 41820010  beq 0x826c77c0
	if ctx.cr[0].eq {
	pc = 0x826C77C0; continue 'dispatch;
	}
	// 826C77B4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C77B8: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C77BC: 4872BC6D  bl 0x82df3428
	ctx.lr = 0x826C77C0;
	sub_82DF3428(ctx, base);
	// 826C77C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C77C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C77C8: 38A0023D  li r5, 0x23d
	ctx.r[5].s64 = 573;
	// 826C77CC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C77D0: 4872AC19  bl 0x82df23e8
	ctx.lr = 0x826C77D4;
	sub_82DF23E8(ctx, base);
	// 826C77D4: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C77D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C77DC: 41820048  beq 0x826c7824
	if ctx.cr[0].eq {
	pc = 0x826C7824; continue 'dispatch;
	}
	// 826C77E0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C77E4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C77E8: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C77EC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C77F0: 419A0024  beq cr6, 0x826c7814
	if ctx.cr[6].eq {
	pc = 0x826C7814; continue 'dispatch;
	}
	// 826C77F4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C77F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C77FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7800: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C7804: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C7808: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C780C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7810: 4082FFE8  bne 0x826c77f8
	if !ctx.cr[0].eq {
	pc = 0x826C77F8; continue 'dispatch;
	}
	// 826C7814: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C7818: 4BFFDCE9  bl 0x826c5500
	ctx.lr = 0x826C781C;
	sub_826C5500(ctx, base);
	// 826C781C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7820: 48000008  b 0x826c7828
	pc = 0x826C7828; continue 'dispatch;
	// 826C7824: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7828: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C782C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7830: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7834: 4BFFD3AD  bl 0x826c4be0
	ctx.lr = 0x826C7838;
	sub_826C4BE0(ctx, base);
	// 826C7838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C783C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7840: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7844: 4BBF87BD  bl 0x822c0000
	ctx.lr = 0x826C7848;
	sub_822C0000(ctx, base);
	// 826C7848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C784C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7850: 38A0023E  li r5, 0x23e
	ctx.r[5].s64 = 574;
	// 826C7854: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C7858: 4BBF8B81  bl 0x822c03d8
	ctx.lr = 0x826C785C;
	sub_822C03D8(ctx, base);
	// 826C785C: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7860: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7864: 418200B4  beq 0x826c7918
	if ctx.cr[0].eq {
	pc = 0x826C7918; continue 'dispatch;
	}
	// 826C7868: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C786C: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C7870: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C7874: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C7878: 409A0008  bne cr6, 0x826c7880
	if !ctx.cr[6].eq {
	pc = 0x826C7880; continue 'dispatch;
	}
	// 826C787C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C7880: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C7884: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7888: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C788C: 419A0024  beq cr6, 0x826c78b0
	if ctx.cr[6].eq {
	pc = 0x826C78B0; continue 'dispatch;
	}
	// 826C7890: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7894: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C7898: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C789C: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C78A0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C78A4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C78A8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C78AC: 4082FFE8  bne 0x826c7894
	if !ctx.cr[0].eq {
	pc = 0x826C7894; continue 'dispatch;
	}
	// 826C78B0: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C78B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C78B8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C78BC: 419A0024  beq cr6, 0x826c78e0
	if ctx.cr[6].eq {
	pc = 0x826C78E0; continue 'dispatch;
	}
	// 826C78C0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C78C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C78C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C78CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C78D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C78D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C78D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C78DC: 4082FFE8  bne 0x826c78c4
	if !ctx.cr[0].eq {
	pc = 0x826C78C4; continue 'dispatch;
	}
	// 826C78E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C78E4: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C78E8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C78EC: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C78F0: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C78F4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C78F8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C78FC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C7900: 480D1631  bl 0x82798f30
	ctx.lr = 0x826C7904;
	sub_82798F30(ctx, base);
	// 826C7904: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C7908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C790C: 480D3D5D  bl 0x8279b668
	ctx.lr = 0x826C7910;
	sub_8279B668(ctx, base);
	// 826C7910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7914: 48000008  b 0x826c791c
	pc = 0x826C791C; continue 'dispatch;
	// 826C7918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C791C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C7920: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C7924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C792C: 4BED0325  bl 0x82597c50
	ctx.lr = 0x826C7930;
	sub_82597C50(ctx, base);
	// 826C7930: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7934: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C793C: 4BBF86C5  bl 0x822c0000
	ctx.lr = 0x826C7940;
	sub_822C0000(ctx, base);
	// 826C7940: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7944: 41820024  beq 0x826c7968
	if ctx.cr[0].eq {
	pc = 0x826C7968; continue 'dispatch;
	}
	// 826C7948: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C794C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7950: 419A0008  beq cr6, 0x826c7958
	if ctx.cr[6].eq {
	pc = 0x826C7958; continue 'dispatch;
	}
	// 826C7954: 4BBF8F3D  bl 0x822c0890
	ctx.lr = 0x826C7958;
	sub_822C0890(ctx, base);
	// 826C7958: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C795C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7960: 419A0008  beq cr6, 0x826c7968
	if ctx.cr[6].eq {
	pc = 0x826C7968; continue 'dispatch;
	}
	// 826C7964: 4BBF8F2D  bl 0x822c0890
	ctx.lr = 0x826C7968;
	sub_822C0890(ctx, base);
	// 826C7968: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C796C: 419A000C  beq cr6, 0x826c7978
	if ctx.cr[6].eq {
	pc = 0x826C7978; continue 'dispatch;
	}
	// 826C7970: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C7974: 4BBF8F1D  bl 0x822c0890
	ctx.lr = 0x826C7978;
	sub_822C0890(ctx, base);
	// 826C7978: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C797C: 419A000C  beq cr6, 0x826c7988
	if ctx.cr[6].eq {
	pc = 0x826C7988; continue 'dispatch;
	}
	// 826C7980: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C7984: 4BBF8F0D  bl 0x822c0890
	ctx.lr = 0x826C7988;
	sub_822C0890(ctx, base);
	// 826C7988: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C798C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C7990: 48AE0820  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C7998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C7998 size=804
    let mut pc: u32 = 0x826C7998;
    'dispatch: loop {
        match pc {
            0x826C7998 => {
    //   block [0x826C7998..0x826C7CBC)
	// 826C7998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C799C: 48AE07C5  bl 0x831a8160
	ctx.lr = 0x826C79A0;
	sub_831A8130(ctx, base);
	// 826C79A0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C79A4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C79A8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C79AC: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C79B0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C79B4: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C79B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C79BC: 38A00243  li r5, 0x243
	ctx.r[5].s64 = 579;
	// 826C79C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C79C4: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C79C8: 4BBF8A11  bl 0x822c03d8
	ctx.lr = 0x826C79CC;
	sub_822C03D8(ctx, base);
	// 826C79CC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C79D0: 41820090  beq 0x826c7a60
	if ctx.cr[0].eq {
	pc = 0x826C7A60; continue 'dispatch;
	}
	// 826C79D4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C79D8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C79DC: 808B8228  lwz r4, -0x7dd8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32216 as u32) ) } as u64;
	// 826C79E0: 4872C029  bl 0x82df3a08
	ctx.lr = 0x826C79E4;
	sub_82DF3A08(ctx, base);
	// 826C79E4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C79E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C79EC: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 826C79F0: 809D0070  lwz r4, 0x70(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) } as u64;
	// 826C79F4: 4872C015  bl 0x82df3a08
	ctx.lr = 0x826C79F8;
	sub_82DF3A08(ctx, base);
	// 826C79F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C79FC: 809D006C  lwz r4, 0x6c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 826C7A00: 4872C009  bl 0x82df3a08
	ctx.lr = 0x826C7A04;
	sub_82DF3A08(ctx, base);
	// 826C7A04: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7A08: 809D0068  lwz r4, 0x68(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 826C7A0C: 4872BFFD  bl 0x82df3a08
	ctx.lr = 0x826C7A10;
	sub_82DF3A08(ctx, base);
	// 826C7A10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C7A14: 809D0064  lwz r4, 0x64(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 826C7A18: 4872BFF1  bl 0x82df3a08
	ctx.lr = 0x826C7A1C;
	sub_82DF3A08(ctx, base);
	// 826C7A1C: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C7A20: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C7A24: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C7A28: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C7A2C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C7A30: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C7A34: 38CB8030  addi r6, r11, -0x7fd0
	ctx.r[6].s64 = ctx.r[11].s64 + -32720;
	// 826C7A38: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C7A3C: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C7A40: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C7A44: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C7A48: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 826C7A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C7A50: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C7A54: 4BFFD0A5  bl 0x826c4af8
	ctx.lr = 0x826C7A58;
	sub_826C4AF8(ctx, base);
	// 826C7A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7A5C: 48000008  b 0x826c7a64
	pc = 0x826C7A64; continue 'dispatch;
	// 826C7A60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7A64: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7A68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7A6C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7A70: 4BFFE1E9  bl 0x826c5c58
	ctx.lr = 0x826C7A74;
	sub_826C5C58(ctx, base);
	// 826C7A74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7A78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7A7C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7A80: 4BBF8581  bl 0x822c0000
	ctx.lr = 0x826C7A84;
	sub_822C0000(ctx, base);
	// 826C7A84: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7A88: 41820010  beq 0x826c7a98
	if ctx.cr[0].eq {
	pc = 0x826C7A98; continue 'dispatch;
	}
	// 826C7A8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C7A90: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7A94: 4872B995  bl 0x82df3428
	ctx.lr = 0x826C7A98;
	sub_82DF3428(ctx, base);
	// 826C7A98: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7A9C: 41820010  beq 0x826c7aac
	if ctx.cr[0].eq {
	pc = 0x826C7AAC; continue 'dispatch;
	}
	// 826C7AA0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7AA4: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7AA8: 4872B981  bl 0x82df3428
	ctx.lr = 0x826C7AAC;
	sub_82DF3428(ctx, base);
	// 826C7AAC: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7AB0: 41820010  beq 0x826c7ac0
	if ctx.cr[0].eq {
	pc = 0x826C7AC0; continue 'dispatch;
	}
	// 826C7AB4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7AB8: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7ABC: 4872B96D  bl 0x82df3428
	ctx.lr = 0x826C7AC0;
	sub_82DF3428(ctx, base);
	// 826C7AC0: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7AC4: 41820010  beq 0x826c7ad4
	if ctx.cr[0].eq {
	pc = 0x826C7AD4; continue 'dispatch;
	}
	// 826C7AC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C7ACC: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7AD0: 4872B959  bl 0x82df3428
	ctx.lr = 0x826C7AD4;
	sub_82DF3428(ctx, base);
	// 826C7AD4: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7AD8: 41820010  beq 0x826c7ae8
	if ctx.cr[0].eq {
	pc = 0x826C7AE8; continue 'dispatch;
	}
	// 826C7ADC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C7AE0: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7AE4: 4872B945  bl 0x82df3428
	ctx.lr = 0x826C7AE8;
	sub_82DF3428(ctx, base);
	// 826C7AE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7AEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7AF0: 38A00244  li r5, 0x244
	ctx.r[5].s64 = 580;
	// 826C7AF4: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C7AF8: 4872A8F1  bl 0x82df23e8
	ctx.lr = 0x826C7AFC;
	sub_82DF23E8(ctx, base);
	// 826C7AFC: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7B00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C7B04: 41820048  beq 0x826c7b4c
	if ctx.cr[0].eq {
	pc = 0x826C7B4C; continue 'dispatch;
	}
	// 826C7B08: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7B0C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7B10: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C7B14: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C7B18: 419A0024  beq cr6, 0x826c7b3c
	if ctx.cr[6].eq {
	pc = 0x826C7B3C; continue 'dispatch;
	}
	// 826C7B1C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C7B20: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C7B24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7B28: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C7B2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C7B30: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7B34: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7B38: 4082FFE8  bne 0x826c7b20
	if !ctx.cr[0].eq {
	pc = 0x826C7B20; continue 'dispatch;
	}
	// 826C7B3C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C7B40: 4BFFD9C1  bl 0x826c5500
	ctx.lr = 0x826C7B44;
	sub_826C5500(ctx, base);
	// 826C7B44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7B48: 48000008  b 0x826c7b50
	pc = 0x826C7B50; continue 'dispatch;
	// 826C7B4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7B50: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7B54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7B58: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7B5C: 4BFFD085  bl 0x826c4be0
	ctx.lr = 0x826C7B60;
	sub_826C4BE0(ctx, base);
	// 826C7B60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7B64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7B68: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7B6C: 4BBF8495  bl 0x822c0000
	ctx.lr = 0x826C7B70;
	sub_822C0000(ctx, base);
	// 826C7B70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7B74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7B78: 38A00245  li r5, 0x245
	ctx.r[5].s64 = 581;
	// 826C7B7C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C7B80: 4BBF8859  bl 0x822c03d8
	ctx.lr = 0x826C7B84;
	sub_822C03D8(ctx, base);
	// 826C7B84: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7B88: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7B8C: 418200B4  beq 0x826c7c40
	if ctx.cr[0].eq {
	pc = 0x826C7C40; continue 'dispatch;
	}
	// 826C7B90: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7B94: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C7B98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C7B9C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C7BA0: 409A0008  bne cr6, 0x826c7ba8
	if !ctx.cr[6].eq {
	pc = 0x826C7BA8; continue 'dispatch;
	}
	// 826C7BA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C7BA8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C7BAC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7BB0: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C7BB4: 419A0024  beq cr6, 0x826c7bd8
	if ctx.cr[6].eq {
	pc = 0x826C7BD8; continue 'dispatch;
	}
	// 826C7BB8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7BBC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C7BC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7BC4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C7BC8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C7BCC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7BD0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7BD4: 4082FFE8  bne 0x826c7bbc
	if !ctx.cr[0].eq {
	pc = 0x826C7BBC; continue 'dispatch;
	}
	// 826C7BD8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C7BDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7BE0: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C7BE4: 419A0024  beq cr6, 0x826c7c08
	if ctx.cr[6].eq {
	pc = 0x826C7C08; continue 'dispatch;
	}
	// 826C7BE8: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7BEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C7BF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7BF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C7BF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C7BFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7C00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7C04: 4082FFE8  bne 0x826c7bec
	if !ctx.cr[0].eq {
	pc = 0x826C7BEC; continue 'dispatch;
	}
	// 826C7C08: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C7C0C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C7C10: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C7C14: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C7C18: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C7C1C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C7C20: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C7C24: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C7C28: 480D1309  bl 0x82798f30
	ctx.lr = 0x826C7C2C;
	sub_82798F30(ctx, base);
	// 826C7C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C7C30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C7C34: 480D3A35  bl 0x8279b668
	ctx.lr = 0x826C7C38;
	sub_8279B668(ctx, base);
	// 826C7C38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7C3C: 48000008  b 0x826c7c44
	pc = 0x826C7C44; continue 'dispatch;
	// 826C7C40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7C44: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C7C48: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C7C4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7C50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C7C54: 4BECFFFD  bl 0x82597c50
	ctx.lr = 0x826C7C58;
	sub_82597C50(ctx, base);
	// 826C7C58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7C5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7C60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C7C64: 4BBF839D  bl 0x822c0000
	ctx.lr = 0x826C7C68;
	sub_822C0000(ctx, base);
	// 826C7C68: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7C6C: 41820024  beq 0x826c7c90
	if ctx.cr[0].eq {
	pc = 0x826C7C90; continue 'dispatch;
	}
	// 826C7C70: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C7C74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7C78: 419A0008  beq cr6, 0x826c7c80
	if ctx.cr[6].eq {
	pc = 0x826C7C80; continue 'dispatch;
	}
	// 826C7C7C: 4BBF8C15  bl 0x822c0890
	ctx.lr = 0x826C7C80;
	sub_822C0890(ctx, base);
	// 826C7C80: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C7C84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7C88: 419A0008  beq cr6, 0x826c7c90
	if ctx.cr[6].eq {
	pc = 0x826C7C90; continue 'dispatch;
	}
	// 826C7C8C: 4BBF8C05  bl 0x822c0890
	ctx.lr = 0x826C7C90;
	sub_822C0890(ctx, base);
	// 826C7C90: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7C94: 419A000C  beq cr6, 0x826c7ca0
	if ctx.cr[6].eq {
	pc = 0x826C7CA0; continue 'dispatch;
	}
	// 826C7C98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C7C9C: 4BBF8BF5  bl 0x822c0890
	ctx.lr = 0x826C7CA0;
	sub_822C0890(ctx, base);
	// 826C7CA0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7CA4: 419A000C  beq cr6, 0x826c7cb0
	if ctx.cr[6].eq {
	pc = 0x826C7CB0; continue 'dispatch;
	}
	// 826C7CA8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C7CAC: 4BBF8BE5  bl 0x822c0890
	ctx.lr = 0x826C7CB0;
	sub_822C0890(ctx, base);
	// 826C7CB0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C7CB4: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C7CB8: 48AE04F8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C7CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C7CC0 size=804
    let mut pc: u32 = 0x826C7CC0;
    'dispatch: loop {
        match pc {
            0x826C7CC0 => {
    //   block [0x826C7CC0..0x826C7FE4)
	// 826C7CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C7CC4: 48AE049D  bl 0x831a8160
	ctx.lr = 0x826C7CC8;
	sub_831A8130(ctx, base);
	// 826C7CC8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C7CCC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C7CD0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C7CD4: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C7CD8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C7CDC: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C7CE0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7CE4: 38A0024A  li r5, 0x24a
	ctx.r[5].s64 = 586;
	// 826C7CE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7CEC: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C7CF0: 4BBF86E9  bl 0x822c03d8
	ctx.lr = 0x826C7CF4;
	sub_822C03D8(ctx, base);
	// 826C7CF4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7CF8: 41820090  beq 0x826c7d88
	if ctx.cr[0].eq {
	pc = 0x826C7D88; continue 'dispatch;
	}
	// 826C7CFC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C7D00: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C7D04: 808B822C  lwz r4, -0x7dd4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32212 as u32) ) } as u64;
	// 826C7D08: 4872BD01  bl 0x82df3a08
	ctx.lr = 0x826C7D0C;
	sub_82DF3A08(ctx, base);
	// 826C7D0C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C7D10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C7D14: 3BABC4E8  addi r29, r11, -0x3b18
	ctx.r[29].s64 = ctx.r[11].s64 + -15128;
	// 826C7D18: 809D0094  lwz r4, 0x94(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C7D1C: 4872BCED  bl 0x82df3a08
	ctx.lr = 0x826C7D20;
	sub_82DF3A08(ctx, base);
	// 826C7D20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7D24: 809D0090  lwz r4, 0x90(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(144 as u32) ) } as u64;
	// 826C7D28: 4872BCE1  bl 0x82df3a08
	ctx.lr = 0x826C7D2C;
	sub_82DF3A08(ctx, base);
	// 826C7D2C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7D30: 809D008C  lwz r4, 0x8c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C7D34: 4872BCD5  bl 0x82df3a08
	ctx.lr = 0x826C7D38;
	sub_82DF3A08(ctx, base);
	// 826C7D38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C7D3C: 809DFFFC  lwz r4, -4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) } as u64;
	// 826C7D40: 4872BCC9  bl 0x82df3a08
	ctx.lr = 0x826C7D44;
	sub_82DF3A08(ctx, base);
	// 826C7D44: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C7D48: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C7D4C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C7D50: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C7D54: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C7D58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C7D5C: 38CB8044  addi r6, r11, -0x7fbc
	ctx.r[6].s64 = ctx.r[11].s64 + -32700;
	// 826C7D60: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C7D64: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C7D68: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C7D6C: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C7D70: 38A00023  li r5, 0x23
	ctx.r[5].s64 = 35;
	// 826C7D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C7D78: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C7D7C: 4BFFCD7D  bl 0x826c4af8
	ctx.lr = 0x826C7D80;
	sub_826C4AF8(ctx, base);
	// 826C7D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7D84: 48000008  b 0x826c7d8c
	pc = 0x826C7D8C; continue 'dispatch;
	// 826C7D88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7D8C: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7D90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7D94: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7D98: 4BFFDEC1  bl 0x826c5c58
	ctx.lr = 0x826C7D9C;
	sub_826C5C58(ctx, base);
	// 826C7D9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7DA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7DA4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7DA8: 4BBF8259  bl 0x822c0000
	ctx.lr = 0x826C7DAC;
	sub_822C0000(ctx, base);
	// 826C7DAC: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7DB0: 41820010  beq 0x826c7dc0
	if ctx.cr[0].eq {
	pc = 0x826C7DC0; continue 'dispatch;
	}
	// 826C7DB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C7DB8: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7DBC: 4872B66D  bl 0x82df3428
	ctx.lr = 0x826C7DC0;
	sub_82DF3428(ctx, base);
	// 826C7DC0: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7DC4: 41820010  beq 0x826c7dd4
	if ctx.cr[0].eq {
	pc = 0x826C7DD4; continue 'dispatch;
	}
	// 826C7DC8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C7DCC: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7DD0: 4872B659  bl 0x82df3428
	ctx.lr = 0x826C7DD4;
	sub_82DF3428(ctx, base);
	// 826C7DD4: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7DD8: 41820010  beq 0x826c7de8
	if ctx.cr[0].eq {
	pc = 0x826C7DE8; continue 'dispatch;
	}
	// 826C7DDC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C7DE0: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7DE4: 4872B645  bl 0x82df3428
	ctx.lr = 0x826C7DE8;
	sub_82DF3428(ctx, base);
	// 826C7DE8: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7DEC: 41820010  beq 0x826c7dfc
	if ctx.cr[0].eq {
	pc = 0x826C7DFC; continue 'dispatch;
	}
	// 826C7DF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C7DF4: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7DF8: 4872B631  bl 0x82df3428
	ctx.lr = 0x826C7DFC;
	sub_82DF3428(ctx, base);
	// 826C7DFC: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7E00: 41820010  beq 0x826c7e10
	if ctx.cr[0].eq {
	pc = 0x826C7E10; continue 'dispatch;
	}
	// 826C7E04: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C7E08: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C7E0C: 4872B61D  bl 0x82df3428
	ctx.lr = 0x826C7E10;
	sub_82DF3428(ctx, base);
	// 826C7E10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7E14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7E18: 38A0024B  li r5, 0x24b
	ctx.r[5].s64 = 587;
	// 826C7E1C: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C7E20: 4872A5C9  bl 0x82df23e8
	ctx.lr = 0x826C7E24;
	sub_82DF23E8(ctx, base);
	// 826C7E24: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7E28: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C7E2C: 41820048  beq 0x826c7e74
	if ctx.cr[0].eq {
	pc = 0x826C7E74; continue 'dispatch;
	}
	// 826C7E30: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7E34: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7E38: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C7E3C: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C7E40: 419A0024  beq cr6, 0x826c7e64
	if ctx.cr[6].eq {
	pc = 0x826C7E64; continue 'dispatch;
	}
	// 826C7E44: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C7E48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C7E4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7E50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C7E54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C7E58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7E5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7E60: 4082FFE8  bne 0x826c7e48
	if !ctx.cr[0].eq {
	pc = 0x826C7E48; continue 'dispatch;
	}
	// 826C7E64: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C7E68: 4BFFD699  bl 0x826c5500
	ctx.lr = 0x826C7E6C;
	sub_826C5500(ctx, base);
	// 826C7E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7E70: 48000008  b 0x826c7e78
	pc = 0x826C7E78; continue 'dispatch;
	// 826C7E74: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7E78: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C7E7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7E80: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7E84: 4BFFCD5D  bl 0x826c4be0
	ctx.lr = 0x826C7E88;
	sub_826C4BE0(ctx, base);
	// 826C7E88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7E90: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C7E94: 4BBF816D  bl 0x822c0000
	ctx.lr = 0x826C7E98;
	sub_822C0000(ctx, base);
	// 826C7E98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C7E9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C7EA0: 38A0024C  li r5, 0x24c
	ctx.r[5].s64 = 588;
	// 826C7EA4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C7EA8: 4BBF8531  bl 0x822c03d8
	ctx.lr = 0x826C7EAC;
	sub_822C03D8(ctx, base);
	// 826C7EAC: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C7EB0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C7EB4: 418200B4  beq 0x826c7f68
	if ctx.cr[0].eq {
	pc = 0x826C7F68; continue 'dispatch;
	}
	// 826C7EB8: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C7EBC: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C7EC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C7EC4: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C7EC8: 409A0008  bne cr6, 0x826c7ed0
	if !ctx.cr[6].eq {
	pc = 0x826C7ED0; continue 'dispatch;
	}
	// 826C7ECC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C7ED0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C7ED4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7ED8: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C7EDC: 419A0024  beq cr6, 0x826c7f00
	if ctx.cr[6].eq {
	pc = 0x826C7F00; continue 'dispatch;
	}
	// 826C7EE0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7EE4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C7EE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7EEC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C7EF0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C7EF4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7EF8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7EFC: 4082FFE8  bne 0x826c7ee4
	if !ctx.cr[0].eq {
	pc = 0x826C7EE4; continue 'dispatch;
	}
	// 826C7F00: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C7F04: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7F08: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C7F0C: 419A0024  beq cr6, 0x826c7f30
	if ctx.cr[6].eq {
	pc = 0x826C7F30; continue 'dispatch;
	}
	// 826C7F10: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C7F14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C7F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7F1C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C7F20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C7F24: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C7F28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C7F2C: 4082FFE8  bne 0x826c7f14
	if !ctx.cr[0].eq {
	pc = 0x826C7F14; continue 'dispatch;
	}
	// 826C7F30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C7F34: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C7F38: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C7F3C: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C7F40: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C7F44: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C7F48: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C7F4C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C7F50: 480D0FE1  bl 0x82798f30
	ctx.lr = 0x826C7F54;
	sub_82798F30(ctx, base);
	// 826C7F54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C7F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C7F5C: 480D370D  bl 0x8279b668
	ctx.lr = 0x826C7F60;
	sub_8279B668(ctx, base);
	// 826C7F60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C7F64: 48000008  b 0x826c7f6c
	pc = 0x826C7F6C; continue 'dispatch;
	// 826C7F68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C7F6C: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C7F70: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C7F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C7F7C: 4BECFCD5  bl 0x82597c50
	ctx.lr = 0x826C7F80;
	sub_82597C50(ctx, base);
	// 826C7F80: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C7F84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C7F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C7F8C: 4BBF8075  bl 0x822c0000
	ctx.lr = 0x826C7F90;
	sub_822C0000(ctx, base);
	// 826C7F90: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C7F94: 41820024  beq 0x826c7fb8
	if ctx.cr[0].eq {
	pc = 0x826C7FB8; continue 'dispatch;
	}
	// 826C7F98: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C7F9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7FA0: 419A0008  beq cr6, 0x826c7fa8
	if ctx.cr[6].eq {
	pc = 0x826C7FA8; continue 'dispatch;
	}
	// 826C7FA4: 4BBF88ED  bl 0x822c0890
	ctx.lr = 0x826C7FA8;
	sub_822C0890(ctx, base);
	// 826C7FA8: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C7FAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C7FB0: 419A0008  beq cr6, 0x826c7fb8
	if ctx.cr[6].eq {
	pc = 0x826C7FB8; continue 'dispatch;
	}
	// 826C7FB4: 4BBF88DD  bl 0x822c0890
	ctx.lr = 0x826C7FB8;
	sub_822C0890(ctx, base);
	// 826C7FB8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C7FBC: 419A000C  beq cr6, 0x826c7fc8
	if ctx.cr[6].eq {
	pc = 0x826C7FC8; continue 'dispatch;
	}
	// 826C7FC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C7FC4: 4BBF88CD  bl 0x822c0890
	ctx.lr = 0x826C7FC8;
	sub_822C0890(ctx, base);
	// 826C7FC8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C7FCC: 419A000C  beq cr6, 0x826c7fd8
	if ctx.cr[6].eq {
	pc = 0x826C7FD8; continue 'dispatch;
	}
	// 826C7FD0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C7FD4: 4BBF88BD  bl 0x822c0890
	ctx.lr = 0x826C7FD8;
	sub_822C0890(ctx, base);
	// 826C7FD8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C7FDC: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C7FE0: 48AE01D0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C7FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C7FE8 size=804
    let mut pc: u32 = 0x826C7FE8;
    'dispatch: loop {
        match pc {
            0x826C7FE8 => {
    //   block [0x826C7FE8..0x826C830C)
	// 826C7FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C7FEC: 48AE0175  bl 0x831a8160
	ctx.lr = 0x826C7FF0;
	sub_831A8130(ctx, base);
	// 826C7FF0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C7FF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C7FF8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C7FFC: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 826C8000: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 826C8004: 3BCB8178  addi r30, r11, -0x7e88
	ctx.r[30].s64 = ctx.r[11].s64 + -32392;
	// 826C8008: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C800C: 38A00251  li r5, 0x251
	ctx.r[5].s64 = 593;
	// 826C8010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C8014: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 826C8018: 4BBF83C1  bl 0x822c03d8
	ctx.lr = 0x826C801C;
	sub_822C03D8(ctx, base);
	// 826C801C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C8020: 41820090  beq 0x826c80b0
	if ctx.cr[0].eq {
	pc = 0x826C80B0; continue 'dispatch;
	}
	// 826C8024: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826C8028: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C802C: 808B8230  lwz r4, -0x7dd0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32208 as u32) ) } as u64;
	// 826C8030: 4872B9D9  bl 0x82df3a08
	ctx.lr = 0x826C8034;
	sub_82DF3A08(ctx, base);
	// 826C8034: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C8038: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C803C: 3BABC580  addi r29, r11, -0x3a80
	ctx.r[29].s64 = ctx.r[11].s64 + -14976;
	// 826C8040: 809D0064  lwz r4, 0x64(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 826C8044: 4872B9C5  bl 0x82df3a08
	ctx.lr = 0x826C8048;
	sub_82DF3A08(ctx, base);
	// 826C8048: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C804C: 809D0060  lwz r4, 0x60(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C8050: 4872B9B9  bl 0x82df3a08
	ctx.lr = 0x826C8054;
	sub_82DF3A08(ctx, base);
	// 826C8054: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C8058: 809D005C  lwz r4, 0x5c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C805C: 4872B9AD  bl 0x82df3a08
	ctx.lr = 0x826C8060;
	sub_82DF3A08(ctx, base);
	// 826C8060: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C8064: 809D0058  lwz r4, 0x58(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C8068: 4872B9A1  bl 0x82df3a08
	ctx.lr = 0x826C806C;
	sub_82DF3A08(ctx, base);
	// 826C806C: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 826C8070: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 826C8074: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8078: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 826C807C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 826C8080: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C8084: 38CB8058  addi r6, r11, -0x7fa8
	ctx.r[6].s64 = ctx.r[11].s64 + -32680;
	// 826C8088: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 826C808C: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 826C8090: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826C8094: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826C8098: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 826C809C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C80A0: 3BA0001F  li r29, 0x1f
	ctx.r[29].s64 = 31;
	// 826C80A4: 4BFFCA55  bl 0x826c4af8
	ctx.lr = 0x826C80A8;
	sub_826C4AF8(ctx, base);
	// 826C80A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C80AC: 48000008  b 0x826c80b4
	pc = 0x826C80B4; continue 'dispatch;
	// 826C80B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C80B4: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C80B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C80BC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C80C0: 4BFFDB99  bl 0x826c5c58
	ctx.lr = 0x826C80C4;
	sub_826C5C58(ctx, base);
	// 826C80C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C80C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C80CC: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C80D0: 4BBF7F31  bl 0x822c0000
	ctx.lr = 0x826C80D4;
	sub_822C0000(ctx, base);
	// 826C80D4: 57AB06F7  rlwinm. r11, r29, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C80D8: 41820010  beq 0x826c80e8
	if ctx.cr[0].eq {
	pc = 0x826C80E8; continue 'dispatch;
	}
	// 826C80DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C80E0: 57BD0734  rlwinm r29, r29, 0, 0x1c, 0x1a
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C80E4: 4872B345  bl 0x82df3428
	ctx.lr = 0x826C80E8;
	sub_82DF3428(ctx, base);
	// 826C80E8: 57AB0739  rlwinm. r11, r29, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C80EC: 41820010  beq 0x826c80fc
	if ctx.cr[0].eq {
	pc = 0x826C80FC; continue 'dispatch;
	}
	// 826C80F0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 826C80F4: 57BD0776  rlwinm r29, r29, 0, 0x1d, 0x1b
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C80F8: 4872B331  bl 0x82df3428
	ctx.lr = 0x826C80FC;
	sub_82DF3428(ctx, base);
	// 826C80FC: 57AB077B  rlwinm. r11, r29, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C8100: 41820010  beq 0x826c8110
	if ctx.cr[0].eq {
	pc = 0x826C8110; continue 'dispatch;
	}
	// 826C8104: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C8108: 57BD07B8  rlwinm r29, r29, 0, 0x1e, 0x1c
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C810C: 4872B31D  bl 0x82df3428
	ctx.lr = 0x826C8110;
	sub_82DF3428(ctx, base);
	// 826C8110: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C8114: 41820010  beq 0x826c8124
	if ctx.cr[0].eq {
	pc = 0x826C8124; continue 'dispatch;
	}
	// 826C8118: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C811C: 57BD07FA  rlwinm r29, r29, 0, 0x1f, 0x1d
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C8120: 4872B309  bl 0x82df3428
	ctx.lr = 0x826C8124;
	sub_82DF3428(ctx, base);
	// 826C8124: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C8128: 41820010  beq 0x826c8138
	if ctx.cr[0].eq {
	pc = 0x826C8138; continue 'dispatch;
	}
	// 826C812C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C8130: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C8134: 4872B2F5  bl 0x82df3428
	ctx.lr = 0x826C8138;
	sub_82DF3428(ctx, base);
	// 826C8138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C813C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8140: 38A00252  li r5, 0x252
	ctx.r[5].s64 = 594;
	// 826C8144: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 826C8148: 4872A2A1  bl 0x82df23e8
	ctx.lr = 0x826C814C;
	sub_82DF23E8(ctx, base);
	// 826C814C: 83610084  lwz r27, 0x84(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C8150: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C8154: 41820048  beq 0x826c819c
	if ctx.cr[0].eq {
	pc = 0x826C819C; continue 'dispatch;
	}
	// 826C8158: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C815C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C8160: 93610084  stw r27, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 826C8164: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 826C8168: 419A0024  beq cr6, 0x826c818c
	if ctx.cr[6].eq {
	pc = 0x826C818C; continue 'dispatch;
	}
	// 826C816C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C8170: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8174: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8178: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C817C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C8180: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8184: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8188: 4082FFE8  bne 0x826c8170
	if !ctx.cr[0].eq {
	pc = 0x826C8170; continue 'dispatch;
	}
	// 826C818C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826C8190: 4BFFD371  bl 0x826c5500
	ctx.lr = 0x826C8194;
	sub_826C5500(ctx, base);
	// 826C8194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8198: 48000008  b 0x826c81a0
	pc = 0x826C81A0; continue 'dispatch;
	// 826C819C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C81A0: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 826C81A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C81A8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C81AC: 4BFFCA35  bl 0x826c4be0
	ctx.lr = 0x826C81B0;
	sub_826C4BE0(ctx, base);
	// 826C81B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C81B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C81B8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 826C81BC: 4BBF7E45  bl 0x822c0000
	ctx.lr = 0x826C81C0;
	sub_822C0000(ctx, base);
	// 826C81C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C81C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C81C8: 38A00253  li r5, 0x253
	ctx.r[5].s64 = 595;
	// 826C81CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C81D0: 4BBF8209  bl 0x822c03d8
	ctx.lr = 0x826C81D4;
	sub_822C03D8(ctx, base);
	// 826C81D4: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C81D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C81DC: 418200B4  beq 0x826c8290
	if ctx.cr[0].eq {
	pc = 0x826C8290; continue 'dispatch;
	}
	// 826C81E0: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826C81E4: 63BD0020  ori r29, r29, 0x20
	ctx.r[29].u64 = ctx.r[29].u64 | 32;
	// 826C81E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C81EC: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826C81F0: 409A0008  bne cr6, 0x826c81f8
	if !ctx.cr[6].eq {
	pc = 0x826C81F8; continue 'dispatch;
	}
	// 826C81F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C81F8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826C81FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C8200: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 826C8204: 419A0024  beq cr6, 0x826c8228
	if ctx.cr[6].eq {
	pc = 0x826C8228; continue 'dispatch;
	}
	// 826C8208: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C820C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C8210: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8214: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C8218: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C821C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8220: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8224: 4082FFE8  bne 0x826c820c
	if !ctx.cr[0].eq {
	pc = 0x826C820C; continue 'dispatch;
	}
	// 826C8228: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C822C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C8230: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 826C8234: 419A0024  beq cr6, 0x826c8258
	if ctx.cr[6].eq {
	pc = 0x826C8258; continue 'dispatch;
	}
	// 826C8238: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826C823C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8240: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8244: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C8248: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C824C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8250: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8254: 4082FFE8  bne 0x826c823c
	if !ctx.cr[0].eq {
	pc = 0x826C823C; continue 'dispatch;
	}
	// 826C8258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C825C: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C8260: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826C8264: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C8268: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C826C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826C8270: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C8274: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826C8278: 480D0CB9  bl 0x82798f30
	ctx.lr = 0x826C827C;
	sub_82798F30(ctx, base);
	// 826C827C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C8280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8284: 480D33E5  bl 0x8279b668
	ctx.lr = 0x826C8288;
	sub_8279B668(ctx, base);
	// 826C8288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C828C: 48000008  b 0x826c8294
	pc = 0x826C8294; continue 'dispatch;
	// 826C8290: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C8294: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C8298: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 826C829C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C82A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C82A4: 4BECF9AD  bl 0x82597c50
	ctx.lr = 0x826C82A8;
	sub_82597C50(ctx, base);
	// 826C82A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C82AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C82B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C82B4: 4BBF7D4D  bl 0x822c0000
	ctx.lr = 0x826C82B8;
	sub_822C0000(ctx, base);
	// 826C82B8: 57AB06B5  rlwinm. r11, r29, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C82BC: 41820024  beq 0x826c82e0
	if ctx.cr[0].eq {
	pc = 0x826C82E0; continue 'dispatch;
	}
	// 826C82C0: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826C82C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C82C8: 419A0008  beq cr6, 0x826c82d0
	if ctx.cr[6].eq {
	pc = 0x826C82D0; continue 'dispatch;
	}
	// 826C82CC: 4BBF85C5  bl 0x822c0890
	ctx.lr = 0x826C82D0;
	sub_822C0890(ctx, base);
	// 826C82D0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826C82D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C82D8: 419A0008  beq cr6, 0x826c82e0
	if ctx.cr[6].eq {
	pc = 0x826C82E0; continue 'dispatch;
	}
	// 826C82DC: 4BBF85B5  bl 0x822c0890
	ctx.lr = 0x826C82E0;
	sub_822C0890(ctx, base);
	// 826C82E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826C82E4: 419A000C  beq cr6, 0x826c82f0
	if ctx.cr[6].eq {
	pc = 0x826C82F0; continue 'dispatch;
	}
	// 826C82E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C82EC: 4BBF85A5  bl 0x822c0890
	ctx.lr = 0x826C82F0;
	sub_822C0890(ctx, base);
	// 826C82F0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C82F4: 419A000C  beq cr6, 0x826c8300
	if ctx.cr[6].eq {
	pc = 0x826C8300; continue 'dispatch;
	}
	// 826C82F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C82FC: 4BBF8595  bl 0x822c0890
	ctx.lr = 0x826C8300;
	sub_822C0890(ctx, base);
	// 826C8300: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826C8304: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826C8308: 48ADFEA8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C8310 size=144
    let mut pc: u32 = 0x826C8310;
    'dispatch: loop {
        match pc {
            0x826C8310 => {
    //   block [0x826C8310..0x826C83A0)
	// 826C8310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8314: 48ADFE55  bl 0x831a8168
	ctx.lr = 0x826C8318;
	sub_831A8130(ctx, base);
	// 826C8318: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C831C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8320: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826C8324: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 826C8328: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826C832C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826C8330: 4BE4B511  bl 0x82513840
	ctx.lr = 0x826C8334;
	sub_82513840(ctx, base);
	// 826C8334: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C8338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C833C: 808B66F4  lwz r4, 0x66f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26356 as u32) ) } as u64;
	// 826C8340: 4BE4B161  bl 0x825134a0
	ctx.lr = 0x826C8344;
	sub_825134A0(ctx, base);
	// 826C8344: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826C8348: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 826C834C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C8350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8354: 4BE4BF1D  bl 0x82514270
	ctx.lr = 0x826C8358;
	sub_82514270(ctx, base);
	// 826C8358: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826C835C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8360: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826C8364: 4872B6A5  bl 0x82df3a08
	ctx.lr = 0x826C8368;
	sub_82DF3A08(ctx, base);
	// 826C8368: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C836C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C8370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8374: 4BE4040D  bl 0x82508780
	ctx.lr = 0x826C8378;
	sub_82508780(ctx, base);
	// 826C8378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C837C: 4872B0AD  bl 0x82df3428
	ctx.lr = 0x826C8380;
	sub_82DF3428(ctx, base);
	// 826C8380: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C8384: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826C8388: 409A0008  bne cr6, 0x826c8390
	if !ctx.cr[6].eq {
	pc = 0x826C8390; continue 'dispatch;
	}
	// 826C838C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826C8390: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8394: 4BE4040D  bl 0x825087a0
	ctx.lr = 0x826C8398;
	sub_825087A0(ctx, base);
	// 826C8398: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826C839C: 48ADFE1C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C83A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C83A0 size=12
    let mut pc: u32 = 0x826C83A0;
    'dispatch: loop {
        match pc {
            0x826C83A0 => {
    //   block [0x826C83A0..0x826C83AC)
	// 826C83A0: 89630174  lbz r11, 0x174(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(372 as u32) ) } as u64;
	// 826C83A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C83A8: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C83AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C83AC size=8
    let mut pc: u32 = 0x826C83AC;
    'dispatch: loop {
        match pc {
            0x826C83AC => {
    //   block [0x826C83AC..0x826C83B4)
	// 826C83AC: 4BE4B174  b 0x82513520
	sub_82513520(ctx, base);
	return;
	// 826C83B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C83B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C83B8 size=4
    let mut pc: u32 = 0x826C83B8;
    'dispatch: loop {
        match pc {
            0x826C83B8 => {
    //   block [0x826C83B8..0x826C83BC)
	// 826C83B8: 4BE4B2A8  b 0x82513660
	sub_82513660(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C83C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C83C0 size=96
    let mut pc: u32 = 0x826C83C0;
    'dispatch: loop {
        match pc {
            0x826C83C0 => {
    //   block [0x826C83C0..0x826C8420)
	// 826C83C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C83C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C83C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C83CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C83D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C83D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C83D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C83DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C83E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826C83E4: 480EE1F5  bl 0x827b65d8
	ctx.lr = 0x826C83E8;
	sub_827B65D8(ctx, base);
	// 826C83E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C83EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C83F0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C83F4: 4BC24C3D  bl 0x822ed030
	ctx.lr = 0x826C83F8;
	sub_822ED030(ctx, base);
	// 826C83F8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C83FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C8400: 419A0008  beq cr6, 0x826c8408
	if ctx.cr[6].eq {
	pc = 0x826C8408; continue 'dispatch;
	}
	// 826C8404: 4BBF848D  bl 0x822c0890
	ctx.lr = 0x826C8408;
	sub_822C0890(ctx, base);
	// 826C8408: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C840C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C8410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C8414: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C8418: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C841C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C8420 size=164
    let mut pc: u32 = 0x826C8420;
    'dispatch: loop {
        match pc {
            0x826C8420 => {
    //   block [0x826C8420..0x826C84C4)
	// 826C8420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8424: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C8428: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C842C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C8430: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8434: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826C8438: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 826C843C: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 826C8440: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 826C8444: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826C8448: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 826C844C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C8450: 808A7058  lwz r4, 0x7058(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826C8454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8458: 4BE4B689  bl 0x82513ae0
	ctx.lr = 0x826C845C;
	sub_82513AE0(ctx, base);
	// 826C845C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8460: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826C8464: 396B81E0  addi r11, r11, -0x7e20
	ctx.r[11].s64 = ctx.r[11].s64 + -32288;
	// 826C8468: 39200160  li r9, 0x160
	ctx.r[9].s64 = 352;
	// 826C846C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826C8470: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C8474: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 826C8478: 394A81CC  addi r10, r10, -0x7e34
	ctx.r[10].s64 = ctx.r[10].s64 + -32308;
	// 826C847C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8480: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826C8484: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C8488: C00808A4  lfs f0, 0x8a4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826C848C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8490: C1A708A8  lfs f13, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C84C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C84C8 size=8
    let mut pc: u32 = 0x826C84C8;
    'dispatch: loop {
        match pc {
            0x826C84C8 => {
    //   block [0x826C84C8..0x826C84D0)
	// 826C84C8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826C84CC: 48000004  b 0x826c84d0
	sub_826C84D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C84D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C84D0 size=96
    let mut pc: u32 = 0x826C84D0;
    'dispatch: loop {
        match pc {
            0x826C84D0 => {
    //   block [0x826C84D0..0x826C8530)
	// 826C84D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C84D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C84D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C84DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C84E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C84E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C84E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C84EC: 807F0180  lwz r3, 0x180(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 826C84F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C84F4: 419A0008  beq cr6, 0x826c84fc
	if ctx.cr[6].eq {
	pc = 0x826C84FC; continue 'dispatch;
	}
	// 826C84F8: 4BBF8399  bl 0x822c0890
	ctx.lr = 0x826C84FC;
	sub_822C0890(ctx, base);
	// 826C84FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8500: 4BE4B1C9  bl 0x825136c8
	ctx.lr = 0x826C8504;
	sub_825136C8(ctx, base);
	// 826C8504: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C8508: 4182000C  beq 0x826c8514
	if ctx.cr[0].eq {
	pc = 0x826C8514; continue 'dispatch;
	}
	// 826C850C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8510: 48729EC9  bl 0x82df23d8
	ctx.lr = 0x826C8514;
	sub_82DF23D8(ctx, base);
	// 826C8514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C851C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C8520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C8524: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C8528: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C852C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C8530 size=432
    let mut pc: u32 = 0x826C8530;
    'dispatch: loop {
        match pc {
            0x826C8530 => {
    //   block [0x826C8530..0x826C86E0)
	// 826C8530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C8538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C853C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C8540: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826C8544: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826C8548: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C854C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8550: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C8554: 897F0174  lbz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 826C8558: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C855C: 40820164  bne 0x826c86c0
	if !ctx.cr[0].eq {
	pc = 0x826C86C0; continue 'dispatch;
	}
	// 826C8560: C01F0170  lfs f0, 0x170(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826C8564: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826C8568: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826C856C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826C8570: D1BF0170  stfs f13, 0x170(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), tmp.u32 ) };
	// 826C8574: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826C8578: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826C857C: 40990144  ble cr6, 0x826c86c0
	if !ctx.cr[6].gt {
	pc = 0x826C86C0; continue 'dispatch;
	}
	// 826C8580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8584: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C8588: 4BE46F91  bl 0x8250f518
	ctx.lr = 0x826C858C;
	sub_8250F518(ctx, base);
	// 826C858C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8594: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 826C8598: 409A0008  bne cr6, 0x826c85a0
	if !ctx.cr[6].eq {
	pc = 0x826C85A0; continue 'dispatch;
	}
	// 826C859C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826C85A0: 4BE5FF91  bl 0x82528530
	ctx.lr = 0x826C85A4;
	sub_82528530(ctx, base);
	// 826C85A4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826C85A8: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 826C85AC: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C85B0: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 826C85B4: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 826C85B8: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 826C85BC: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C85C0: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 826C85C4: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 826C85C8: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C85CC: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C85D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C86E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C86E0 size=72
    let mut pc: u32 = 0x826C86E0;
    'dispatch: loop {
        match pc {
            0x826C86E0 => {
    //   block [0x826C86E0..0x826C8728)
	// 826C86E0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C86E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826C86E8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 826C86EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C86F0: 419A005C  beq cr6, 0x826c874c
	if ctx.cr[6].eq {
		sub_826C874C(ctx, base);
		return;
	}
	// 826C86F4: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 826C86F8: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 826C86FC: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 826C8700: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826C8704: 41980048  blt cr6, 0x826c874c
	if ctx.cr[6].lt {
		sub_826C874C(ctx, base);
		return;
	}
	// 826C8708: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 826C870C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8710: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 826C8714: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826C8718: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 826C871C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8720: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826C8724: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C8728 size=36
    let mut pc: u32 = 0x826C8728;
    'dispatch: loop {
        match pc {
            0x826C8728 => {
    //   block [0x826C8728..0x826C874C)
	// 826C8728: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826C872C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8730: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8734: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C8738: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C873C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8740: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8744: 4082FFE8  bne 0x826c872c
	if !ctx.cr[0].eq {
	pc = 0x826C872C; continue 'dispatch;
	}
	// 826C8748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C874C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C874C size=64
    let mut pc: u32 = 0x826C874C;
    'dispatch: loop {
        match pc {
            0x826C874C => {
    //   block [0x826C874C..0x826C878C)
	// 826C874C: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 826C8750: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C8754: 419A005C  beq cr6, 0x826c87b0
	if ctx.cr[6].eq {
		sub_826C87B0(ctx, base);
		return;
	}
	// 826C8758: 812B0048  lwz r9, 0x48(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 826C875C: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 826C8760: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 826C8764: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826C8768: 41980048  blt cr6, 0x826c87b0
	if ctx.cr[6].lt {
		sub_826C87B0(ctx, base);
		return;
	}
	// 826C876C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 826C8770: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8774: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 826C8778: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826C877C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 826C8780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8784: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826C8788: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C878C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C878C size=36
    let mut pc: u32 = 0x826C878C;
    'dispatch: loop {
        match pc {
            0x826C878C => {
    //   block [0x826C878C..0x826C87B0)
	// 826C878C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826C8790: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8794: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8798: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C879C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C87A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C87A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C87A8: 4082FFE8  bne 0x826c8790
	if !ctx.cr[0].eq {
	pc = 0x826C8790; continue 'dispatch;
	}
	// 826C87AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C87B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C87B0 size=64
    let mut pc: u32 = 0x826C87B0;
    'dispatch: loop {
        match pc {
            0x826C87B0 => {
    //   block [0x826C87B0..0x826C87F0)
	// 826C87B0: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 826C87B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C87B8: 419A005C  beq cr6, 0x826c8814
	if ctx.cr[6].eq {
		sub_826C8814(ctx, base);
		return;
	}
	// 826C87BC: 812B0038  lwz r9, 0x38(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826C87C0: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 826C87C4: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 826C87C8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826C87CC: 41980048  blt cr6, 0x826c8814
	if ctx.cr[6].lt {
		sub_826C8814(ctx, base);
		return;
	}
	// 826C87D0: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 826C87D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C87D8: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 826C87DC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826C87E0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 826C87E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C87E8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826C87EC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C87F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C87F0 size=36
    let mut pc: u32 = 0x826C87F0;
    'dispatch: loop {
        match pc {
            0x826C87F0 => {
    //   block [0x826C87F0..0x826C8814)
	// 826C87F0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826C87F4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C87F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C87FC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C8800: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C8804: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8808: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C880C: 4082FFE8  bne 0x826c87f4
	if !ctx.cr[0].eq {
	pc = 0x826C87F4; continue 'dispatch;
	}
	// 826C8810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8814(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C8814 size=16
    let mut pc: u32 = 0x826C8814;
    'dispatch: loop {
        match pc {
            0x826C8814 => {
    //   block [0x826C8814..0x826C8824)
	// 826C8814: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8818: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C881C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826C8820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C8828 size=572
    let mut pc: u32 = 0x826C8828;
    'dispatch: loop {
        match pc {
            0x826C8828 => {
    //   block [0x826C8828..0x826C8A64)
	// 826C8828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C882C: 48ADF93D  bl 0x831a8168
	ctx.lr = 0x826C8830;
	sub_831A8130(ctx, base);
	// 826C8830: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8838: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826C883C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 826C8840: 895F0174  lbz r10, 0x174(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 826C8844: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C8848: 419A0214  beq cr6, 0x826c8a5c
	if ctx.cr[6].eq {
	pc = 0x826C8A5C; continue 'dispatch;
	}
	// 826C884C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8854: 419A002C  beq cr6, 0x826c8880
	if ctx.cr[6].eq {
	pc = 0x826C8880; continue 'dispatch;
	}
	// 826C8858: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C885C: 480EDD7D  bl 0x827b65d8
	ctx.lr = 0x826C8860;
	sub_827B65D8(ctx, base);
	// 826C8860: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C8864: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8868: 4BC251D1  bl 0x822eda38
	ctx.lr = 0x826C886C;
	sub_822EDA38(ctx, base);
	// 826C886C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826C8870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C8874: 419A01E4  beq cr6, 0x826c8a58
	if ctx.cr[6].eq {
	pc = 0x826C8A58; continue 'dispatch;
	}
	// 826C8878: 4BBF8019  bl 0x822c0890
	ctx.lr = 0x826C887C;
	sub_822C0890(ctx, base);
	// 826C887C: 480001DC  b 0x826c8a58
	pc = 0x826C8A58; continue 'dispatch;
	// 826C8880: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826C8884: 480EDD55  bl 0x827b65d8
	ctx.lr = 0x826C8888;
	sub_827B65D8(ctx, base);
	// 826C8888: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826C888C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8890: 4BC251A9  bl 0x822eda38
	ctx.lr = 0x826C8894;
	sub_822EDA38(ctx, base);
	// 826C8894: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826C8898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C889C: 419A0008  beq cr6, 0x826c88a4
	if ctx.cr[6].eq {
	pc = 0x826C88A4; continue 'dispatch;
	}
	// 826C88A0: 4BBF7FF1  bl 0x822c0890
	ctx.lr = 0x826C88A4;
	sub_822C0890(ctx, base);
	// 826C88A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C88A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826C88AC: 4BE46C1D  bl 0x8250f4c8
	ctx.lr = 0x826C88B0;
	sub_8250F4C8(ctx, base);
	// 826C88B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C88B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C88B8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826C88BC: 409A0008  bne cr6, 0x826c88c4
	if !ctx.cr[6].eq {
	pc = 0x826C88C4; continue 'dispatch;
	}
	// 826C88C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826C88C4: 4BE3FC65  bl 0x82508528
	ctx.lr = 0x826C88C8;
	sub_82508528(ctx, base);
	// 826C88C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C88CC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826C88D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C88D4: 48762215  bl 0x82e2aae8
	ctx.lr = 0x826C88D8;
	sub_82E2AAE8(ctx, base);
	// 826C88D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826C88DC: 487293B5  bl 0x82df1c90
	ctx.lr = 0x826C88E0;
	sub_82DF1C90(ctx, base);
	// 826C88E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C88E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C88E8: 4BE4B169  bl 0x82513a50
	ctx.lr = 0x826C88EC;
	sub_82513A50(ctx, base);
	// 826C88EC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C88F0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826C88F4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826C88F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C88FC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826C8900: 4BE478F1  bl 0x825101f0
	ctx.lr = 0x826C8904;
	sub_825101F0(ctx, base);
	// 826C8904: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826C8908: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C890C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826C8910: 4BFFFDD1  bl 0x826c86e0
	ctx.lr = 0x826C8914;
	sub_826C86E0(ctx, base);
	// 826C8914: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826C8918: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826C891C: 419A0114  beq cr6, 0x826c8a30
	if ctx.cr[6].eq {
	pc = 0x826C8A30; continue 'dispatch;
	}
	// 826C8920: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8924: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8928: 388B8208  addi r4, r11, -0x7df8
	ctx.r[4].s64 = ctx.r[11].s64 + -32248;
	// 826C892C: 38A0007C  li r5, 0x7c
	ctx.r[5].s64 = 124;
	// 826C8930: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 826C8934: 48729AB5  bl 0x82df23e8
	ctx.lr = 0x826C8938;
	sub_82DF23E8(ctx, base);
	// 826C8938: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C893C: 41820010  beq 0x826c894c
	if ctx.cr[0].eq {
	pc = 0x826C894C; continue 'dispatch;
	}
	// 826C8940: 4BF34631  bl 0x825fcf70
	ctx.lr = 0x826C8944;
	sub_825FCF70(ctx, base);
	// 826C8944: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C8948: 48000008  b 0x826c8950
	pc = 0x826C8950; continue 'dispatch;
	// 826C894C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826C8950: 3BDF017C  addi r30, r31, 0x17c
	ctx.r[30].s64 = ctx.r[31].s64 + 380;
	// 826C8954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8958: 4BF32EA1  bl 0x825fb7f8
	ctx.lr = 0x826C895C;
	sub_825FB7F8(ctx, base);
	// 826C895C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826C8960: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C8964: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C8968: 4874DED9  bl 0x82e16840
	ctx.lr = 0x826C896C;
	sub_82E16840(ctx, base);
	// 826C896C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C8970: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 826C8974: 4874E9ED  bl 0x82e17360
	ctx.lr = 0x826C8978;
	sub_82E17360(ctx, base);
	// 826C8978: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826C897C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8980: 3BCBAC50  addi r30, r11, -0x53b0
	ctx.r[30].s64 = ctx.r[11].s64 + -21424;
	// 826C8984: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C8988: 83BF017C  lwz r29, 0x17c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 826C898C: 48730BA5  bl 0x82df9530
	ctx.lr = 0x826C8990;
	sub_82DF9530(ctx, base);
	// 826C8990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C8994: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826C8998: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C899C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C89A0: 4874EDA9  bl 0x82e17748
	ctx.lr = 0x826C89A4;
	sub_82E17748(ctx, base);
	// 826C89A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C89A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C89AC: 83DF017C  lwz r30, 0x17c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 826C89B0: 48730B81  bl 0x82df9530
	ctx.lr = 0x826C89B4;
	sub_82DF9530(ctx, base);
	// 826C89B4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826C89B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C89BC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 826C89C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C89C4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C89C8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C89CC: 4874E15D  bl 0x82e16b28
	ctx.lr = 0x826C89D0;
	sub_82E16B28(ctx, base);
	// 826C89D0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C89D4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C89D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C89DC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826C89E0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826C89E4: 419A0024  beq cr6, 0x826c8a08
	if ctx.cr[6].eq {
	pc = 0x826C8A08; continue 'dispatch;
	}
	// 826C89E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826C89EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C89F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C89F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C89F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C89FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8A00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8A04: 4082FFE8  bne 0x826c89ec
	if !ctx.cr[0].eq {
	pc = 0x826C89EC; continue 'dispatch;
	}
	// 826C8A08: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C8A0C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826C8A10: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826C8A14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8A18: 808B705C  lwz r4, 0x705c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28764 as u32) ) } as u64;
	// 826C8A1C: 4BE47FDD  bl 0x825109f8
	ctx.lr = 0x826C8A20;
	sub_825109F8(ctx, base);
	// 826C8A20: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826C8A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C8A28: 419A0008  beq cr6, 0x826c8a30
	if ctx.cr[6].eq {
	pc = 0x826C8A30; continue 'dispatch;
	}
	// 826C8A2C: 4BBF7E65  bl 0x822c0890
	ctx.lr = 0x826C8A30;
	sub_822C0890(ctx, base);
	// 826C8A30: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826C8A34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C8A38: 419A0008  beq cr6, 0x826c8a40
	if ctx.cr[6].eq {
	pc = 0x826C8A40; continue 'dispatch;
	}
	// 826C8A3C: 4BBF7E55  bl 0x822c0890
	ctx.lr = 0x826C8A40;
	sub_822C0890(ctx, base);
	// 826C8A40: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C8A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C8A48: 419A0008  beq cr6, 0x826c8a50
	if ctx.cr[6].eq {
	pc = 0x826C8A50; continue 'dispatch;
	}
	// 826C8A4C: 4BBF7E45  bl 0x822c0890
	ctx.lr = 0x826C8A50;
	sub_822C0890(ctx, base);
	// 826C8A50: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826C8A54: 487620AD  bl 0x82e2ab00
	ctx.lr = 0x826C8A58;
	sub_82E2AB00(ctx, base);
	// 826C8A58: 9B9F0174  stb r28, 0x174(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[28].u8 ) };
	// 826C8A5C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826C8A60: 48ADF758  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C8A68 size=8
    let mut pc: u32 = 0x826C8A68;
    'dispatch: loop {
        match pc {
            0x826C8A68 => {
    //   block [0x826C8A68..0x826C8A70)
	// 826C8A68: 90830140  stw r4, 0x140(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), ctx.r[4].u32 ) };
	// 826C8A6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C8A70 size=20
    let mut pc: u32 = 0x826C8A70;
    'dispatch: loop {
        match pc {
            0x826C8A70 => {
    //   block [0x826C8A70..0x826C8A84)
	// 826C8A70: 89430144  lbz r10, 0x144(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(324 as u32) ) } as u64;
	// 826C8A74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8A78: 91630140  stw r11, 0x140(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 826C8A7C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C8A80: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8A84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C8A84 size=8
    let mut pc: u32 = 0x826C8A84;
    'dispatch: loop {
        match pc {
            0x826C8A84 => {
    //   block [0x826C8A84..0x826C8A8C)
	// 826C8A84: 99630144  stb r11, 0x144(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), ctx.r[11].u8 ) };
	// 826C8A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C8A90 size=196
    let mut pc: u32 = 0x826C8A90;
    'dispatch: loop {
        match pc {
            0x826C8A90 => {
    //   block [0x826C8A90..0x826C8B54)
	// 826C8A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C8A98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C8A9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C8AA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8AA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C8AA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8AAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C8AB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C8AB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C8AB8: 4BBF7E81  bl 0x822c0938
	ctx.lr = 0x826C8ABC;
	sub_822C0938(ctx, base);
	// 826C8ABC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C8AC0: 41820028  beq 0x826c8ae8
	if ctx.cr[0].eq {
	pc = 0x826C8AE8; continue 'dispatch;
	}
	// 826C8AC4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8AC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C8ACC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C8AD0: 392B8304  addi r9, r11, -0x7cfc
	ctx.r[9].s64 = ctx.r[11].s64 + -31996;
	// 826C8AD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C8AD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C8ADC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C8AE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C8AE4: 48000008  b 0x826c8aec
	pc = 0x826C8AEC; continue 'dispatch;
	// 826C8AE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8AEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C8AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8AF4: 409A0044  bne cr6, 0x826c8b38
	if !ctx.cr[6].eq {
	pc = 0x826C8B38; continue 'dispatch;
	}
	// 826C8AF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C8AFC: 419A001C  beq cr6, 0x826c8b18
	if ctx.cr[6].eq {
	pc = 0x826C8B18; continue 'dispatch;
	}
	// 826C8B00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8B04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C8B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8B0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826C8B14: 4E800421  bctrl
	ctx.lr = 0x826C8B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826C8B18: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C8B1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C8B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8B24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C8B28: 816BC7A0  lwz r11, -0x3860(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14432 as u32) ) } as u64;
	// 826C8B2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C8B30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C8B34: 4BBF74CD  bl 0x822c0000
	ctx.lr = 0x826C8B38;
	sub_822C0000(ctx, base);
	// 826C8B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8B3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C8B40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C8B44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C8B48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C8B4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C8B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C8B58 size=196
    let mut pc: u32 = 0x826C8B58;
    'dispatch: loop {
        match pc {
            0x826C8B58 => {
    //   block [0x826C8B58..0x826C8C1C)
	// 826C8B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8B5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C8B60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C8B64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C8B68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8B6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C8B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8B74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C8B78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C8B7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C8B80: 4BBF7DB9  bl 0x822c0938
	ctx.lr = 0x826C8B84;
	sub_822C0938(ctx, base);
	// 826C8B84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C8B88: 41820028  beq 0x826c8bb0
	if ctx.cr[0].eq {
	pc = 0x826C8BB0; continue 'dispatch;
	}
	// 826C8B8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8B90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C8B94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C8B98: 392B8318  addi r9, r11, -0x7ce8
	ctx.r[9].s64 = ctx.r[11].s64 + -31976;
	// 826C8B9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C8BA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C8BA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C8BA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C8BAC: 48000008  b 0x826c8bb4
	pc = 0x826C8BB4; continue 'dispatch;
	// 826C8BB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C8BB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C8BB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8BBC: 409A0044  bne cr6, 0x826c8c00
	if !ctx.cr[6].eq {
	pc = 0x826C8C00; continue 'dispatch;
	}
	// 826C8BC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C8BC4: 419A001C  beq cr6, 0x826c8be0
	if ctx.cr[6].eq {
	pc = 0x826C8BE0; continue 'dispatch;
	}
	// 826C8BC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8BCC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C8BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8BD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8BD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826C8BDC: 4E800421  bctrl
	ctx.lr = 0x826C8BE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826C8BE0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C8BE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C8BE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8BEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C8BF0: 816BC7A0  lwz r11, -0x3860(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14432 as u32) ) } as u64;
	// 826C8BF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C8BF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C8BFC: 4BBF7405  bl 0x822c0000
	ctx.lr = 0x826C8C00;
	sub_822C0000(ctx, base);
	// 826C8C00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C8C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C8C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C8C10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C8C14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C8C18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C8C20 size=660
    let mut pc: u32 = 0x826C8C20;
    'dispatch: loop {
        match pc {
            0x826C8C20 => {
    //   block [0x826C8C20..0x826C8EB4)
	// 826C8C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8C24: 48ADF535  bl 0x831a8158
	ctx.lr = 0x826C8C28;
	sub_831A8130(ctx, base);
	// 826C8C28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8C2C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826C8C30: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826C8C34: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 826C8C38: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 826C8C3C: 4BFCDE1D  bl 0x82696a58
	ctx.lr = 0x826C8C40;
	sub_82696A58(ctx, base);
	// 826C8C40: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8C44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8C48: 3B4B8368  addi r26, r11, -0x7c98
	ctx.r[26].s64 = ctx.r[11].s64 + -31896;
	// 826C8C4C: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 826C8C50: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826C8C54: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C8C58: 4BBF7781  bl 0x822c03d8
	ctx.lr = 0x826C8C5C;
	sub_822C03D8(ctx, base);
	// 826C8C5C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C8C60: 41820034  beq 0x826c8c94
	if ctx.cr[0].eq {
	pc = 0x826C8C94; continue 'dispatch;
	}
	// 826C8C64: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8C68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8C6C: 388B834C  addi r4, r11, -0x7cb4
	ctx.r[4].s64 = ctx.r[11].s64 + -31924;
	// 826C8C70: 4872AD99  bl 0x82df3a08
	ctx.lr = 0x826C8C74;
	sub_82DF3A08(ctx, base);
	// 826C8C74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8C78: 38BB0050  addi r5, r27, 0x50
	ctx.r[5].s64 = ctx.r[27].s64 + 80;
	// 826C8C7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C8C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8C84: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826C8C88: 4BEE3789  bl 0x825ac410
	ctx.lr = 0x826C8C8C;
	sub_825AC410(ctx, base);
	// 826C8C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8C90: 48000008  b 0x826c8c98
	pc = 0x826C8C98; continue 'dispatch;
	// 826C8C94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C8C98: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826C8C9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8CA0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826C8CA4: 4BE2A715  bl 0x824f33b8
	ctx.lr = 0x826C8CA8;
	sub_824F33B8(ctx, base);
	// 826C8CA8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C8CAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8CB0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826C8CB4: 4BBF734D  bl 0x822c0000
	ctx.lr = 0x826C8CB8;
	sub_822C0000(ctx, base);
	// 826C8CB8: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C8CBC: 41820010  beq 0x826c8ccc
	if ctx.cr[0].eq {
	pc = 0x826C8CCC; continue 'dispatch;
	}
	// 826C8CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8CC4: 57BD003C  rlwinm r29, r29, 0, 0, 0x1e
	ctx.r[29].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 826C8CC8: 4872A761  bl 0x82df3428
	ctx.lr = 0x826C8CCC;
	sub_82DF3428(ctx, base);
	// 826C8CCC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C8CD0: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C8CD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C8CD8: 3BCBC768  addi r30, r11, -0x3898
	ctx.r[30].s64 = ctx.r[11].s64 + -14488;
	// 826C8CDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8CE0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8CE4: 4872AD25  bl 0x82df3a08
	ctx.lr = 0x826C8CE8;
	sub_82DF3A08(ctx, base);
	// 826C8CE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826C8CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8CF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C8CF4: 4BEE30CD  bl 0x825abdc0
	ctx.lr = 0x826C8CF8;
	sub_825ABDC0(ctx, base);
	// 826C8CF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8CFC: 4872A72D  bl 0x82df3428
	ctx.lr = 0x826C8D00;
	sub_82DF3428(ctx, base);
	// 826C8D00: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826C8D04: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 826C8D08: 2B1F0006  cmplwi cr6, r31, 6
	ctx.cr[6].compare_u32(ctx.r[31].u32, 6 as u32, &mut ctx.xer);
	// 826C8D0C: 4198FFD0  blt cr6, 0x826c8cdc
	if ctx.cr[6].lt {
	pc = 0x826C8CDC; continue 'dispatch;
	}
	// 826C8D10: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8D18: 388B833C  addi r4, r11, -0x7cc4
	ctx.r[4].s64 = ctx.r[11].s64 + -31940;
	// 826C8D1C: 4872ACED  bl 0x82df3a08
	ctx.lr = 0x826C8D20;
	sub_82DF3A08(ctx, base);
	// 826C8D20: 8321005C  lwz r25, 0x5c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C8D24: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 826C8D28: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826C8D2C: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 826C8D30: 419A0024  beq cr6, 0x826c8d54
	if ctx.cr[6].eq {
	pc = 0x826C8D54; continue 'dispatch;
	}
	// 826C8D34: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 826C8D38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8D3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8D40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C8D44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C8D48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8D4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8D50: 4082FFE8  bne 0x826c8d38
	if !ctx.cr[0].eq {
	pc = 0x826C8D38; continue 'dispatch;
	}
	// 826C8D54: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826C8D58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C8D5C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826C8D60: 4BED93B1  bl 0x825a2110
	ctx.lr = 0x826C8D64;
	sub_825A2110(ctx, base);
	// 826C8D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8D68: 4872A6C1  bl 0x82df3428
	ctx.lr = 0x826C8D6C;
	sub_82DF3428(ctx, base);
	// 826C8D6C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826C8D70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8D74: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 826C8D78: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C8D7C: 4BBF765D  bl 0x822c03d8
	ctx.lr = 0x826C8D80;
	sub_822C03D8(ctx, base);
	// 826C8D80: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C8D84: 41820034  beq 0x826c8db8
	if ctx.cr[0].eq {
	pc = 0x826C8DB8; continue 'dispatch;
	}
	// 826C8D88: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8D90: 388B8330  addi r4, r11, -0x7cd0
	ctx.r[4].s64 = ctx.r[11].s64 + -31952;
	// 826C8D94: 4872AC75  bl 0x82df3a08
	ctx.lr = 0x826C8D98;
	sub_82DF3A08(ctx, base);
	// 826C8D98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8D9C: 38BB0054  addi r5, r27, 0x54
	ctx.r[5].s64 = ctx.r[27].s64 + 84;
	// 826C8DA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C8DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8DA8: 63BD0002  ori r29, r29, 2
	ctx.r[29].u64 = ctx.r[29].u64 | 2;
	// 826C8DAC: 4BEE3665  bl 0x825ac410
	ctx.lr = 0x826C8DB0;
	sub_825AC410(ctx, base);
	// 826C8DB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8DB4: 48000008  b 0x826c8dbc
	pc = 0x826C8DBC; continue 'dispatch;
	// 826C8DB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C8DBC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826C8DC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8DC4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826C8DC8: 4BE2A5F1  bl 0x824f33b8
	ctx.lr = 0x826C8DCC;
	sub_824F33B8(ctx, base);
	// 826C8DCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C8DD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8DD4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826C8DD8: 4BBF7229  bl 0x822c0000
	ctx.lr = 0x826C8DDC;
	sub_822C0000(ctx, base);
	// 826C8DDC: 57AB07BD  rlwinm. r11, r29, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C8DE0: 4182000C  beq 0x826c8dec
	if ctx.cr[0].eq {
	pc = 0x826C8DEC; continue 'dispatch;
	}
	// 826C8DE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8DE8: 4872A641  bl 0x82df3428
	ctx.lr = 0x826C8DEC;
	sub_82DF3428(ctx, base);
	// 826C8DEC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C8DF0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C8DF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C8DF8: 3BCBC780  addi r30, r11, -0x3880
	ctx.r[30].s64 = ctx.r[11].s64 + -14464;
	// 826C8DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8E00: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C8E04: 4872AC05  bl 0x82df3a08
	ctx.lr = 0x826C8E08;
	sub_82DF3A08(ctx, base);
	// 826C8E08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826C8E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8E10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C8E14: 4BEE2FAD  bl 0x825abdc0
	ctx.lr = 0x826C8E18;
	sub_825ABDC0(ctx, base);
	// 826C8E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8E1C: 4872A60D  bl 0x82df3428
	ctx.lr = 0x826C8E20;
	sub_82DF3428(ctx, base);
	// 826C8E20: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826C8E24: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 826C8E28: 2B1F0008  cmplwi cr6, r31, 8
	ctx.cr[6].compare_u32(ctx.r[31].u32, 8 as u32, &mut ctx.xer);
	// 826C8E2C: 4198FFD0  blt cr6, 0x826c8dfc
	if ctx.cr[6].lt {
	pc = 0x826C8DFC; continue 'dispatch;
	}
	// 826C8E30: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8E34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8E38: 388B8328  addi r4, r11, -0x7cd8
	ctx.r[4].s64 = ctx.r[11].s64 + -31960;
	// 826C8E3C: 4872ABCD  bl 0x82df3a08
	ctx.lr = 0x826C8E40;
	sub_82DF3A08(ctx, base);
	// 826C8E40: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C8E44: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826C8E48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C8E4C: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 826C8E50: 419A0024  beq cr6, 0x826c8e74
	if ctx.cr[6].eq {
	pc = 0x826C8E74; continue 'dispatch;
	}
	// 826C8E54: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826C8E58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8E5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8E60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C8E64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C8E68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8E6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8E70: 4082FFE8  bne 0x826c8e58
	if !ctx.cr[0].eq {
	pc = 0x826C8E58; continue 'dispatch;
	}
	// 826C8E74: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826C8E78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C8E7C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826C8E80: 4BED9291  bl 0x825a2110
	ctx.lr = 0x826C8E84;
	sub_825A2110(ctx, base);
	// 826C8E84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C8E88: 4872A5A1  bl 0x82df3428
	ctx.lr = 0x826C8E8C;
	sub_82DF3428(ctx, base);
	// 826C8E8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C8E90: 419A000C  beq cr6, 0x826c8e9c
	if ctx.cr[6].eq {
	pc = 0x826C8E9C; continue 'dispatch;
	}
	// 826C8E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8E98: 4BBF79F9  bl 0x822c0890
	ctx.lr = 0x826C8E9C;
	sub_822C0890(ctx, base);
	// 826C8E9C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826C8EA0: 419A000C  beq cr6, 0x826c8eac
	if ctx.cr[6].eq {
	pc = 0x826C8EAC; continue 'dispatch;
	}
	// 826C8EA4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826C8EA8: 4BBF79E9  bl 0x822c0890
	ctx.lr = 0x826C8EAC;
	sub_822C0890(ctx, base);
	// 826C8EAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826C8EB0: 48ADF2F8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C8EB8 size=124
    let mut pc: u32 = 0x826C8EB8;
    'dispatch: loop {
        match pc {
            0x826C8EB8 => {
    //   block [0x826C8EB8..0x826C8F34)
	// 826C8EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8EBC: 48ADF2B1  bl 0x831a816c
	ctx.lr = 0x826C8EC0;
	sub_831A8130(ctx, base);
	// 826C8EC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8EC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826C8EC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C8ECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C8ED0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826C8ED4: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826C8ED8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826C8EDC: 4872950D  bl 0x82df23e8
	ctx.lr = 0x826C8EE0;
	sub_82DF23E8(ctx, base);
	// 826C8EE0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C8EE4: 4182001C  beq 0x826c8f00
	if ctx.cr[0].eq {
	pc = 0x826C8F00; continue 'dispatch;
	}
	// 826C8EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C8EEC: 48790795  bl 0x82e59680
	ctx.lr = 0x826C8EF0;
	sub_82E59680(ctx, base);
	// 826C8EF0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8EF4: 396B82FC  addi r11, r11, -0x7d04
	ctx.r[11].s64 = ctx.r[11].s64 + -32004;
	// 826C8EF8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C8EFC: 48000008  b 0x826c8f04
	pc = 0x826C8F04; continue 'dispatch;
	// 826C8F00: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C8F04: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C8F08: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826C8F0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8F14: 4BFFFC45  bl 0x826c8b58
	ctx.lr = 0x826C8F18;
	sub_826C8B58(ctx, base);
	// 826C8F18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C8F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C8F20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C8F24: 4BBF70DD  bl 0x822c0000
	ctx.lr = 0x826C8F28;
	sub_822C0000(ctx, base);
	// 826C8F28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C8F2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C8F30: 48ADF28C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C8F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C8F38 size=968
    let mut pc: u32 = 0x826C8F38;
    'dispatch: loop {
        match pc {
            0x826C8F38 => {
    //   block [0x826C8F38..0x826C9300)
	// 826C8F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C8F3C: 48ADF229  bl 0x831a8164
	ctx.lr = 0x826C8F40;
	sub_831A8130(ctx, base);
	// 826C8F40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C8F44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C8F48: 817F0140  lwz r11, 0x140(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C8F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8F50: 419A03A8  beq cr6, 0x826c92f8
	if ctx.cr[6].eq {
	pc = 0x826C92F8; continue 'dispatch;
	}
	// 826C8F54: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826C8F58: 4BDB4589  bl 0x8247d4e0
	ctx.lr = 0x826C8F5C;
	sub_8247D4E0(ctx, base);
	// 826C8F5C: 8361008C  lwz r27, 0x8c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C8F60: 83C10088  lwz r30, 0x88(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 826C8F64: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C8F68: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 826C8F6C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826C8F70: 419A0024  beq cr6, 0x826c8f94
	if ctx.cr[6].eq {
	pc = 0x826C8F94; continue 'dispatch;
	}
	// 826C8F74: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826C8F78: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C8F7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8F80: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C8F84: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C8F88: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C8F8C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C8F90: 4082FFE8  bne 0x826c8f78
	if !ctx.cr[0].eq {
	pc = 0x826C8F78; continue 'dispatch;
	}
	// 826C8F94: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C8F98: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C8F9C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 826C8FA0: 3B8B8368  addi r28, r11, -0x7c98
	ctx.r[28].s64 = ctx.r[11].s64 + -31896;
	// 826C8FA4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826C8FA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C8FAC: 38A00088  li r5, 0x88
	ctx.r[5].s64 = 136;
	// 826C8FB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C8FB4: 4878E035  bl 0x82e56fe8
	ctx.lr = 0x826C8FB8;
	sub_82E56FE8(ctx, base);
	// 826C8FB8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C8FBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C8FC0: 419A0008  beq cr6, 0x826c8fc8
	if ctx.cr[6].eq {
	pc = 0x826C8FC8; continue 'dispatch;
	}
	// 826C8FC4: 4BBF78CD  bl 0x822c0890
	ctx.lr = 0x826C8FC8;
	sub_822C0890(ctx, base);
	// 826C8FC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826C8FCC: 4BFFFEED  bl 0x826c8eb8
	ctx.lr = 0x826C8FD0;
	sub_826C8EB8(ctx, base);
	// 826C8FD0: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 826C8FD4: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 826C8FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C8FDC: 419A0058  beq cr6, 0x826c9034
	if ctx.cr[6].eq {
	pc = 0x826C9034; continue 'dispatch;
	}
	// 826C8FE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826C8FE4: 419A0050  beq cr6, 0x826c9034
	if ctx.cr[6].eq {
	pc = 0x826C9034; continue 'dispatch;
	}
	// 826C8FE8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826C8FEC: 409A000C  bne cr6, 0x826c8ff8
	if !ctx.cr[6].eq {
	pc = 0x826C8FF8; continue 'dispatch;
	}
	// 826C8FF0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 826C8FF4: 48000040  b 0x826c9034
	pc = 0x826C9034; continue 'dispatch;
	// 826C8FF8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 826C8FFC: 409A000C  bne cr6, 0x826c9008
	if !ctx.cr[6].eq {
	pc = 0x826C9008; continue 'dispatch;
	}
	// 826C9000: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826C9004: 48000030  b 0x826c9034
	pc = 0x826C9034; continue 'dispatch;
	// 826C9008: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 826C900C: 419A0028  beq cr6, 0x826c9034
	if ctx.cr[6].eq {
	pc = 0x826C9034; continue 'dispatch;
	}
	// 826C9010: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 826C9014: 419A0020  beq cr6, 0x826c9034
	if ctx.cr[6].eq {
	pc = 0x826C9034; continue 'dispatch;
	}
	// 826C9018: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 826C901C: 409A000C  bne cr6, 0x826c9028
	if !ctx.cr[6].eq {
	pc = 0x826C9028; continue 'dispatch;
	}
	// 826C9020: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 826C9024: 48000010  b 0x826c9034
	pc = 0x826C9034; continue 'dispatch;
	// 826C9028: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 826C902C: 409A000C  bne cr6, 0x826c9038
	if !ctx.cr[6].eq {
	pc = 0x826C9038; continue 'dispatch;
	}
	// 826C9030: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 826C9034: 916A0018  stw r11, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 826C9038: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 826C903C: 83C1008C  lwz r30, 0x8c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826C9040: 2F0B0023  cmpwi cr6, r11, 0x23
	ctx.cr[6].compare_i32(ctx.r[11].s32, 35, &mut ctx.xer);
	// 826C9044: 409A0068  bne cr6, 0x826c90ac
	if !ctx.cr[6].eq {
	pc = 0x826C90AC; continue 'dispatch;
	}
	// 826C9048: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826C904C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826C9050: 409A0288  bne cr6, 0x826c92d8
	if !ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C9054: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826C9058: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C905C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826C9060: 419A0024  beq cr6, 0x826c9084
	if ctx.cr[6].eq {
	pc = 0x826C9084; continue 'dispatch;
	}
	// 826C9064: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C9068: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C906C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9070: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9074: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9078: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C907C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9080: 4082FFE8  bne 0x826c9068
	if !ctx.cr[0].eq {
	pc = 0x826C9068; continue 'dispatch;
	}
	// 826C9084: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C9088: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C908C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C9090: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826C9094: 38A0009F  li r5, 0x9f
	ctx.r[5].s64 = 159;
	// 826C9098: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C909C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C90A0: 4878F9A1  bl 0x82e58a40
	ctx.lr = 0x826C90A4;
	sub_82E58A40(ctx, base);
	// 826C90A4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C90A8: 48000224  b 0x826c92cc
	pc = 0x826C92CC; continue 'dispatch;
	// 826C90AC: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 826C90B0: 409A0068  bne cr6, 0x826c9118
	if !ctx.cr[6].eq {
	pc = 0x826C9118; continue 'dispatch;
	}
	// 826C90B4: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826C90B8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 826C90BC: 409A021C  bne cr6, 0x826c92d8
	if !ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C90C0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826C90C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C90C8: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 826C90CC: 419A0024  beq cr6, 0x826c90f0
	if ctx.cr[6].eq {
	pc = 0x826C90F0; continue 'dispatch;
	}
	// 826C90D0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C90D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C90D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C90DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C90E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C90E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C90E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C90EC: 4082FFE8  bne 0x826c90d4
	if !ctx.cr[0].eq {
	pc = 0x826C90D4; continue 'dispatch;
	}
	// 826C90F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C90F4: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C90F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C90FC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826C9100: 38A000A2  li r5, 0xa2
	ctx.r[5].s64 = 162;
	// 826C9104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9108: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C910C: 4878F935  bl 0x82e58a40
	ctx.lr = 0x826C9110;
	sub_82E58A40(ctx, base);
	// 826C9110: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826C9114: 480001B8  b 0x826c92cc
	pc = 0x826C92CC; continue 'dispatch;
	// 826C9118: 2F0B0025  cmpwi cr6, r11, 0x25
	ctx.cr[6].compare_i32(ctx.r[11].s32, 37, &mut ctx.xer);
	// 826C911C: 409A0068  bne cr6, 0x826c9184
	if !ctx.cr[6].eq {
	pc = 0x826C9184; continue 'dispatch;
	}
	// 826C9120: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826C9124: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 826C9128: 409A01B0  bne cr6, 0x826c92d8
	if !ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C912C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 826C9130: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C9134: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 826C9138: 419A0024  beq cr6, 0x826c915c
	if ctx.cr[6].eq {
	pc = 0x826C915C; continue 'dispatch;
	}
	// 826C913C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C9140: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9144: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9148: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C914C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9150: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C9154: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9158: 4082FFE8  bne 0x826c9140
	if !ctx.cr[0].eq {
	pc = 0x826C9140; continue 'dispatch;
	}
	// 826C915C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C9160: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C9164: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C9168: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 826C916C: 38A000A5  li r5, 0xa5
	ctx.r[5].s64 = 165;
	// 826C9170: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9174: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C9178: 4878F8C9  bl 0x82e58a40
	ctx.lr = 0x826C917C;
	sub_82E58A40(ctx, base);
	// 826C917C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826C9180: 4800014C  b 0x826c92cc
	pc = 0x826C92CC; continue 'dispatch;
	// 826C9184: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 826C9188: 409A0068  bne cr6, 0x826c91f0
	if !ctx.cr[6].eq {
	pc = 0x826C91F0; continue 'dispatch;
	}
	// 826C918C: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826C9190: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 826C9194: 409A0144  bne cr6, 0x826c92d8
	if !ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C9198: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826C919C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C91A0: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 826C91A4: 419A0024  beq cr6, 0x826c91c8
	if ctx.cr[6].eq {
	pc = 0x826C91C8; continue 'dispatch;
	}
	// 826C91A8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C91AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C91B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C91B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C91B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C91BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C91C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C91C4: 4082FFE8  bne 0x826c91ac
	if !ctx.cr[0].eq {
	pc = 0x826C91AC; continue 'dispatch;
	}
	// 826C91C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C91CC: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C91D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C91D4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 826C91D8: 38A000A8  li r5, 0xa8
	ctx.r[5].s64 = 168;
	// 826C91DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C91E0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C91E4: 4878F85D  bl 0x82e58a40
	ctx.lr = 0x826C91E8;
	sub_82E58A40(ctx, base);
	// 826C91E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826C91EC: 480000E0  b 0x826c92cc
	pc = 0x826C92CC; continue 'dispatch;
	// 826C91F0: 2F0B000F  cmpwi cr6, r11, 0xf
	ctx.cr[6].compare_i32(ctx.r[11].s32, 15, &mut ctx.xer);
	// 826C91F4: 419A0078  beq cr6, 0x826c926c
	if ctx.cr[6].eq {
	pc = 0x826C926C; continue 'dispatch;
	}
	// 826C91F8: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 826C91FC: 419A0070  beq cr6, 0x826c926c
	if ctx.cr[6].eq {
	pc = 0x826C926C; continue 'dispatch;
	}
	// 826C9200: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826C9204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C9208: 419A000C  beq cr6, 0x826c9214
	if ctx.cr[6].eq {
	pc = 0x826C9214; continue 'dispatch;
	}
	// 826C920C: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 826C9210: 409A00C8  bne cr6, 0x826c92d8
	if !ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C9214: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 826C9218: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C921C: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 826C9220: 419A0024  beq cr6, 0x826c9244
	if ctx.cr[6].eq {
	pc = 0x826C9244; continue 'dispatch;
	}
	// 826C9224: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C9228: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C922C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9230: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9234: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9238: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C923C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9240: 4082FFE8  bne 0x826c9228
	if !ctx.cr[0].eq {
	pc = 0x826C9228; continue 'dispatch;
	}
	// 826C9244: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C9248: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C924C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C9250: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 826C9254: 38A000AE  li r5, 0xae
	ctx.r[5].s64 = 174;
	// 826C9258: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C925C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C9260: 4878F7E1  bl 0x82e58a40
	ctx.lr = 0x826C9264;
	sub_82E58A40(ctx, base);
	// 826C9264: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826C9268: 48000064  b 0x826c92cc
	pc = 0x826C92CC; continue 'dispatch;
	// 826C926C: 817F0138  lwz r11, 0x138(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) } as u64;
	// 826C9270: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 826C9274: 409A0064  bne cr6, 0x826c92d8
	if !ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C9278: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 826C927C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C9280: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 826C9284: 419A0024  beq cr6, 0x826c92a8
	if ctx.cr[6].eq {
	pc = 0x826C92A8; continue 'dispatch;
	}
	// 826C9288: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C928C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9290: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9294: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9298: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C929C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C92A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C92A4: 4082FFE8  bne 0x826c928c
	if !ctx.cr[0].eq {
	pc = 0x826C928C; continue 'dispatch;
	}
	// 826C92A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C92AC: 80DF0140  lwz r6, 0x140(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826C92B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C92B4: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 826C92B8: 38A000AB  li r5, 0xab
	ctx.r[5].s64 = 171;
	// 826C92BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C92C0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C92C4: 4878F77D  bl 0x82e58a40
	ctx.lr = 0x826C92C8;
	sub_82E58A40(ctx, base);
	// 826C92C8: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826C92CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C92D0: 419A0008  beq cr6, 0x826c92d8
	if ctx.cr[6].eq {
	pc = 0x826C92D8; continue 'dispatch;
	}
	// 826C92D4: 4BBF75BD  bl 0x822c0890
	ctx.lr = 0x826C92D8;
	sub_822C0890(ctx, base);
	// 826C92D8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C92DC: 419A000C  beq cr6, 0x826c92e8
	if ctx.cr[6].eq {
	pc = 0x826C92E8; continue 'dispatch;
	}
	// 826C92E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C92E4: 4BBF75AD  bl 0x822c0890
	ctx.lr = 0x826C92E8;
	sub_822C0890(ctx, base);
	// 826C92E8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826C92EC: 419A000C  beq cr6, 0x826c92f8
	if ctx.cr[6].eq {
	pc = 0x826C92F8; continue 'dispatch;
	}
	// 826C92F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826C92F4: 4BBF759D  bl 0x822c0890
	ctx.lr = 0x826C92F8;
	sub_822C0890(ctx, base);
	// 826C92F8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 826C92FC: 48ADEEB8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C9300 size=224
    let mut pc: u32 = 0x826C9300;
    'dispatch: loop {
        match pc {
            0x826C9300 => {
    //   block [0x826C9300..0x826C93E0)
	// 826C9300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9304: 48ADEE69  bl 0x831a816c
	ctx.lr = 0x826C9308;
	sub_831A8130(ctx, base);
	// 826C9308: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C930C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C9310: 4BFCCFC9  bl 0x826962d8
	ctx.lr = 0x826C9314;
	sub_826962D8(ctx, base);
	// 826C9314: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9318: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826C931C: 396B844C  addi r11, r11, -0x7bb4
	ctx.r[11].s64 = ctx.r[11].s64 + -31668;
	// 826C9320: 394A8438  addi r10, r10, -0x7bc8
	ctx.r[10].s64 = ctx.r[10].s64 + -31688;
	// 826C9324: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826C9328: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C932C: 915D0028  stw r10, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826C9330: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C9334: 392983EC  addi r9, r9, -0x7c14
	ctx.r[9].s64 = ctx.r[9].s64 + -31764;
	// 826C9338: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 826C933C: 93FD0138  stw r31, 0x138(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(312 as u32), ctx.r[31].u32 ) };
	// 826C9340: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 826C9344: 93FD0140  stw r31, 0x140(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(320 as u32), ctx.r[31].u32 ) };
	// 826C9348: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 826C934C: 913D00E8  stw r9, 0xe8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 826C9350: 917D013C  stw r11, 0x13c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 826C9354: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9358: 9BFD0144  stb r31, 0x144(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(324 as u32), ctx.r[31].u8 ) };
	// 826C935C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C9360: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 826C9364: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 826C9368: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 826C936C: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 826C9370: 4BFCBF21  bl 0x82695290
	ctx.lr = 0x826C9374;
	sub_82695290(ctx, base);
	// 826C9374: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 826C9378: 9BE10055  stb r31, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[31].u8 ) };
	// 826C937C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9380: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 826C9384: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826C9388: 9BE10056  stb r31, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[31].u8 ) };
	// 826C938C: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 826C9390: 4BFCBF29  bl 0x826952b8
	ctx.lr = 0x826C9394;
	sub_826952B8(ctx, base);
	// 826C9394: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9398: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C939C: 4BFCBF45  bl 0x826952e0
	ctx.lr = 0x826C93A0;
	sub_826952E0(ctx, base);
	// 826C93A0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C93A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C93A8: 388B83C8  addi r4, r11, -0x7c38
	ctx.r[4].s64 = ctx.r[11].s64 + -31800;
	// 826C93AC: 4BBFFF45  bl 0x822c92f0
	ctx.lr = 0x826C93B0;
	sub_822C92F0(ctx, base);
	// 826C93B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C93B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826C93B8: 4BFCDDD9  bl 0x82697190
	ctx.lr = 0x826C93BC;
	sub_82697190(ctx, base);
	// 826C93BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826C93C0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C93C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C93C8: 4BBFFA69  bl 0x822c8e30
	ctx.lr = 0x826C93CC;
	sub_822C8E30(ctx, base);
	// 826C93CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C93D0: 48392FF9  bl 0x82a5c3c8
	ctx.lr = 0x826C93D4;
	sub_82A5C3C8(ctx, base);
	// 826C93D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C93D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826C93DC: 48ADEDE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C93E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C93E0 size=8
    let mut pc: u32 = 0x826C93E0;
    'dispatch: loop {
        match pc {
            0x826C93E0 => {
    //   block [0x826C93E0..0x826C93E8)
	// 826C93E0: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 826C93E4: 48000004  b 0x826c93e8
	sub_826C93E8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C93E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C93E8 size=76
    let mut pc: u32 = 0x826C93E8;
    'dispatch: loop {
        match pc {
            0x826C93E8 => {
    //   block [0x826C93E8..0x826C9434)
	// 826C93E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C93EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C93F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C93F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C93F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C93FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C9404: 4BF53E4D  bl 0x8261d250
	ctx.lr = 0x826C9408;
	sub_8261D250(ctx, base);
	// 826C9408: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C940C: 4182000C  beq 0x826c9418
	if ctx.cr[0].eq {
	pc = 0x826C9418; continue 'dispatch;
	}
	// 826C9410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9414: 48728FC5  bl 0x82df23d8
	ctx.lr = 0x826C9418;
	sub_82DF23D8(ctx, base);
	// 826C9418: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C941C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C9420: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C9424: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C9428: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C942C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C9430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C9438 size=400
    let mut pc: u32 = 0x826C9438;
    'dispatch: loop {
        match pc {
            0x826C9438 => {
    //   block [0x826C9438..0x826C95C8)
	// 826C9438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C943C: 48ADED2D  bl 0x831a8168
	ctx.lr = 0x826C9440;
	sub_831A8130(ctx, base);
	// 826C9440: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9444: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9448: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826C944C: 3BCB8368  addi r30, r11, -0x7c98
	ctx.r[30].s64 = ctx.r[11].s64 + -31896;
	// 826C9450: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9454: 38A00054  li r5, 0x54
	ctx.r[5].s64 = 84;
	// 826C9458: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C945C: 38600148  li r3, 0x148
	ctx.r[3].s64 = 328;
	// 826C9460: 48728F89  bl 0x82df23e8
	ctx.lr = 0x826C9464;
	sub_82DF23E8(ctx, base);
	// 826C9464: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9468: 41820010  beq 0x826c9478
	if ctx.cr[0].eq {
	pc = 0x826C9478; continue 'dispatch;
	}
	// 826C946C: 4BFFFE95  bl 0x826c9300
	ctx.lr = 0x826C9470;
	sub_826C9300(ctx, base);
	// 826C9470: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9474: 48000008  b 0x826c947c
	pc = 0x826C947C; continue 'dispatch;
	// 826C9478: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C947C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826C9480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9484: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9488: 4BFFF609  bl 0x826c8a90
	ctx.lr = 0x826C948C;
	sub_826C8A90(ctx, base);
	// 826C948C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C9490: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9494: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9498: 4BBF6B69  bl 0x822c0000
	ctx.lr = 0x826C949C;
	sub_822C0000(ctx, base);
	// 826C949C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C94A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C94A4: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 826C94A8: 409A0008  bne cr6, 0x826c94b0
	if !ctx.cr[6].eq {
	pc = 0x826C94B0; continue 'dispatch;
	}
	// 826C94AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C94B0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C94B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826C94B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826C94BC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 826C94C0: 419A0024  beq cr6, 0x826c94e4
	if ctx.cr[6].eq {
	pc = 0x826C94E4; continue 'dispatch;
	}
	// 826C94C4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826C94C8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826C94CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C94D0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826C94D4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826C94D8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C94DC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C94E0: 4082FFE8  bne 0x826c94c8
	if !ctx.cr[0].eq {
	pc = 0x826C94C8; continue 'dispatch;
	}
	// 826C94E4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826C94E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826C94EC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826C94F0: 419A0024  beq cr6, 0x826c9514
	if ctx.cr[6].eq {
	pc = 0x826C9514; continue 'dispatch;
	}
	// 826C94F4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826C94F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C94FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9500: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9504: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9508: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C950C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9510: 4082FFE8  bne 0x826c94f8
	if !ctx.cr[0].eq {
	pc = 0x826C94F8; continue 'dispatch;
	}
	// 826C9514: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826C9518: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826C951C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826C9520: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826C9524: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826C9528: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826C952C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826C9530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C9534: 480CF9FD  bl 0x82798f30
	ctx.lr = 0x826C9538;
	sub_82798F30(ctx, base);
	// 826C9538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C953C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9540: 38A00056  li r5, 0x56
	ctx.r[5].s64 = 86;
	// 826C9544: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C9548: 4BBF6E91  bl 0x822c03d8
	ctx.lr = 0x826C954C;
	sub_822C03D8(ctx, base);
	// 826C954C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9550: 41820014  beq 0x826c9564
	if ctx.cr[0].eq {
	pc = 0x826C9564; continue 'dispatch;
	}
	// 826C9554: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826C9558: 480D2111  bl 0x8279b668
	ctx.lr = 0x826C955C;
	sub_8279B668(ctx, base);
	// 826C955C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9560: 48000008  b 0x826c9568
	pc = 0x826C9568; continue 'dispatch;
	// 826C9564: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C9568: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C956C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 826C9570: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C9578: 4BECE6D9  bl 0x82597c50
	ctx.lr = 0x826C957C;
	sub_82597C50(ctx, base);
	// 826C957C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C9580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C9588: 4BBF6A79  bl 0x822c0000
	ctx.lr = 0x826C958C;
	sub_822C0000(ctx, base);
	// 826C958C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826C9590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C9594: 419A0008  beq cr6, 0x826c959c
	if ctx.cr[6].eq {
	pc = 0x826C959C; continue 'dispatch;
	}
	// 826C9598: 4BBF72F9  bl 0x822c0890
	ctx.lr = 0x826C959C;
	sub_822C0890(ctx, base);
	// 826C959C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826C95A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C95A4: 419A0008  beq cr6, 0x826c95ac
	if ctx.cr[6].eq {
	pc = 0x826C95AC; continue 'dispatch;
	}
	// 826C95A8: 4BBF72E9  bl 0x822c0890
	ctx.lr = 0x826C95AC;
	sub_822C0890(ctx, base);
	// 826C95AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826C95B0: 419A000C  beq cr6, 0x826c95bc
	if ctx.cr[6].eq {
	pc = 0x826C95BC; continue 'dispatch;
	}
	// 826C95B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C95B8: 4BBF72D9  bl 0x822c0890
	ctx.lr = 0x826C95BC;
	sub_822C0890(ctx, base);
	// 826C95BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C95C0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826C95C4: 48ADEBF4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C95C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826C95C8 size=8
    let mut pc: u32 = 0x826C95C8;
    'dispatch: loop {
        match pc {
            0x826C95C8 => {
    //   block [0x826C95C8..0x826C95D0)
	// 826C95C8: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 826C95CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C95D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C95D0 size=60
    let mut pc: u32 = 0x826C95D0;
    'dispatch: loop {
        match pc {
            0x826C95D0 => {
    //   block [0x826C95D0..0x826C960C)
	// 826C95D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C95D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C95D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C95DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C95E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C95E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C95E8: 487B3E69  bl 0x82e7d450
	ctx.lr = 0x826C95EC;
	sub_82E7D450(ctx, base);
	// 826C95EC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 826C95F0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C9610 size=100
    let mut pc: u32 = 0x826C9610;
    'dispatch: loop {
        match pc {
            0x826C9610 => {
    //   block [0x826C9610..0x826C9674)
	// 826C9610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9614: 48ADEB59  bl 0x831a816c
	ctx.lr = 0x826C9618;
	sub_831A8130(ctx, base);
	// 826C9618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C961C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C9620: 897E004C  lbz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 826C9624: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9628: 40820044  bne 0x826c966c
	if !ctx.cr[0].eq {
	pc = 0x826C966C; continue 'dispatch;
	}
	// 826C962C: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C9630: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9634: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C9638: 419A002C  beq cr6, 0x826c9664
	if ctx.cr[6].eq {
	pc = 0x826C9664; continue 'dispatch;
	}
	// 826C963C: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 826C9640: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826C9644: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826C9648: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 826C964C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9650: 4BE47509  bl 0x82510b58
	ctx.lr = 0x826C9654;
	sub_82510B58(ctx, base);
	// 826C9654: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C9658: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C965C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C9660: 409AFFE0  bne cr6, 0x826c9640
	if !ctx.cr[6].eq {
	pc = 0x826C9640; continue 'dispatch;
	}
	// 826C9664: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826C9668: 997E004C  stb r11, 0x4c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u8 ) };
	// 826C966C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C9670: 48ADEB4C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C9678 size=100
    let mut pc: u32 = 0x826C9678;
    'dispatch: loop {
        match pc {
            0x826C9678 => {
    //   block [0x826C9678..0x826C96DC)
	// 826C9678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C967C: 48ADEAF1  bl 0x831a816c
	ctx.lr = 0x826C9680;
	sub_831A8130(ctx, base);
	// 826C9680: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9684: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C9688: 897E004C  lbz r11, 0x4c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 826C968C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9690: 41820044  beq 0x826c96d4
	if ctx.cr[0].eq {
	pc = 0x826C96D4; continue 'dispatch;
	}
	// 826C9694: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C9698: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C969C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C96A0: 419A002C  beq cr6, 0x826c96cc
	if ctx.cr[6].eq {
	pc = 0x826C96CC; continue 'dispatch;
	}
	// 826C96A4: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 826C96A8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826C96AC: 809D7058  lwz r4, 0x7058(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826C96B0: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 826C96B4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C96B8: 4BE46B39  bl 0x825101f0
	ctx.lr = 0x826C96BC;
	sub_825101F0(ctx, base);
	// 826C96BC: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C96C0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C96C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C96C8: 409AFFE0  bne cr6, 0x826c96a8
	if !ctx.cr[6].eq {
	pc = 0x826C96A8; continue 'dispatch;
	}
	// 826C96CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C96D0: 997E004C  stb r11, 0x4c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u8 ) };
	// 826C96D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C96D8: 48ADEAE4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C96E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C96E0 size=240
    let mut pc: u32 = 0x826C96E0;
    'dispatch: loop {
        match pc {
            0x826C96E0 => {
    //   block [0x826C96E0..0x826C97D0)
	// 826C96E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C96E4: 48ADEA85  bl 0x831a8168
	ctx.lr = 0x826C96E8;
	sub_831A8130(ctx, base);
	// 826C96E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C96EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C96F0: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C96F4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C96F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826C96FC: 4BE45DCD  bl 0x8250f4c8
	ctx.lr = 0x826C9700;
	sub_8250F4C8(ctx, base);
	// 826C9700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C9708: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826C970C: 409A0008  bne cr6, 0x826c9714
	if !ctx.cr[6].eq {
	pc = 0x826C9714; continue 'dispatch;
	}
	// 826C9710: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826C9714: 4BE3EE15  bl 0x82508528
	ctx.lr = 0x826C9718;
	sub_82508528(ctx, base);
	// 826C9718: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C971C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C9720: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9724: 487613C5  bl 0x82e2aae8
	ctx.lr = 0x826C9728;
	sub_82E2AAE8(ctx, base);
	// 826C9728: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C972C: 48728565  bl 0x82df1c90
	ctx.lr = 0x826C9730;
	sub_82DF1C90(ctx, base);
	// 826C9730: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9734: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826C9738: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C973C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C9740: 48765731  bl 0x82e2ee70
	ctx.lr = 0x826C9744;
	sub_82E2EE70(ctx, base);
	// 826C9744: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C974C: 388B84B0  addi r4, r11, -0x7b50
	ctx.r[4].s64 = ctx.r[11].s64 + -31568;
	// 826C9750: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 826C9754: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826C9758: 48728C91  bl 0x82df23e8
	ctx.lr = 0x826C975C;
	sub_82DF23E8(ctx, base);
	// 826C975C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9760: 41820014  beq 0x826c9774
	if ctx.cr[0].eq {
	pc = 0x826C9774; continue 'dispatch;
	}
	// 826C9764: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826C9768: 4874D129  bl 0x82e16890
	ctx.lr = 0x826C976C;
	sub_82E16890(ctx, base);
	// 826C976C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9770: 48000008  b 0x826c9778
	pc = 0x826C9778; continue 'dispatch;
	// 826C9774: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C9778: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C977C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826C9780: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9784: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C9788: 4BC8F931  bl 0x823590b8
	ctx.lr = 0x826C978C;
	sub_823590B8(ctx, base);
	// 826C978C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C9790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C9798: 4BBF6869  bl 0x822c0000
	ctx.lr = 0x826C979C;
	sub_822C0000(ctx, base);
	// 826C979C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C97A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C97A4: 419A0008  beq cr6, 0x826c97ac
	if ctx.cr[6].eq {
	pc = 0x826C97AC; continue 'dispatch;
	}
	// 826C97A8: 4BBF70E9  bl 0x822c0890
	ctx.lr = 0x826C97AC;
	sub_822C0890(ctx, base);
	// 826C97AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C97B0: 48761351  bl 0x82e2ab00
	ctx.lr = 0x826C97B4;
	sub_82E2AB00(ctx, base);
	// 826C97B4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C97B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C97BC: 419A0008  beq cr6, 0x826c97c4
	if ctx.cr[6].eq {
	pc = 0x826C97C4; continue 'dispatch;
	}
	// 826C97C0: 4BBF70D1  bl 0x822c0890
	ctx.lr = 0x826C97C4;
	sub_822C0890(ctx, base);
	// 826C97C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C97C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826C97CC: 48ADE9EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C97D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C97D0 size=188
    let mut pc: u32 = 0x826C97D0;
    'dispatch: loop {
        match pc {
            0x826C97D0 => {
    //   block [0x826C97D0..0x826C988C)
	// 826C97D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C97D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C97D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C97DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C97E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C97E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826C97E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C97EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826C97F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C97F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C97F8: 4BBF7141  bl 0x822c0938
	ctx.lr = 0x826C97FC;
	sub_822C0938(ctx, base);
	// 826C97FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9800: 41820028  beq 0x826c9828
	if ctx.cr[0].eq {
	pc = 0x826C9828; continue 'dispatch;
	}
	// 826C9804: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9808: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826C980C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826C9810: 392B849C  addi r9, r11, -0x7b64
	ctx.r[9].s64 = ctx.r[11].s64 + -31588;
	// 826C9814: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C9818: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C981C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826C9820: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826C9824: 48000008  b 0x826c982c
	pc = 0x826C982C; continue 'dispatch;
	// 826C9828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826C982C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C9830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C9834: 409A003C  bne cr6, 0x826c9870
	if !ctx.cr[6].eq {
	pc = 0x826C9870; continue 'dispatch;
	}
	// 826C9838: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C983C: 419A0014  beq cr6, 0x826c9850
	if ctx.cr[6].eq {
	pc = 0x826C9850; continue 'dispatch;
	}
	// 826C9840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9844: 48729BE5  bl 0x82df3428
	ctx.lr = 0x826C9848;
	sub_82DF3428(ctx, base);
	// 826C9848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C984C: 4BBF6A1D  bl 0x822c0268
	ctx.lr = 0x826C9850;
	sub_822C0268(ctx, base);
	// 826C9850: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826C9854: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C9858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C985C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826C9860: 816BC878  lwz r11, -0x3788(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14216 as u32) ) } as u64;
	// 826C9864: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826C9868: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C986C: 4BBF6795  bl 0x822c0000
	ctx.lr = 0x826C9870;
	sub_822C0000(ctx, base);
	// 826C9870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C9874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C9878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C987C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C9880: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C9884: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C9888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C9890 size=64
    let mut pc: u32 = 0x826C9890;
    'dispatch: loop {
        match pc {
            0x826C9890 => {
    //   block [0x826C9890..0x826C98D0)
	// 826C9890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C9898: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C989C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C98A0: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C98A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C98A8: 419A0014  beq cr6, 0x826c98bc
	if ctx.cr[6].eq {
	pc = 0x826C98BC; continue 'dispatch;
	}
	// 826C98AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C98B0: 48729B79  bl 0x82df3428
	ctx.lr = 0x826C98B4;
	sub_82DF3428(ctx, base);
	// 826C98B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C98B8: 4BBF69B1  bl 0x822c0268
	ctx.lr = 0x826C98BC;
	sub_822C0268(ctx, base);
	// 826C98BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C98C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C98C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C98C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C98CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C98D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C98D0 size=148
    let mut pc: u32 = 0x826C98D0;
    'dispatch: loop {
        match pc {
            0x826C98D0 => {
    //   block [0x826C98D0..0x826C9964)
	// 826C98D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C98D4: 48ADE899  bl 0x831a816c
	ctx.lr = 0x826C98D8;
	sub_831A8130(ctx, base);
	// 826C98D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C98DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C98E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C98E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826C98E8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826C98EC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826C98F0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 826C98F4: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 826C98F8: 388A08B0  addi r4, r10, 0x8b0
	ctx.r[4].s64 = ctx.r[10].s64 + 2224;
	// 826C98FC: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 826C9900: 487287C9  bl 0x82df20c8
	ctx.lr = 0x826C9904;
	sub_82DF20C8(ctx, base);
	// 826C9904: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9908: 41820008  beq 0x826c9910
	if ctx.cr[0].eq {
	pc = 0x826C9910; continue 'dispatch;
	}
	// 826C990C: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826C9910: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C9914: 41820008  beq 0x826c991c
	if ctx.cr[0].eq {
	pc = 0x826C991C; continue 'dispatch;
	}
	// 826C9918: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826C991C: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826C9920: 4182003C  beq 0x826c995c
	if ctx.cr[0].eq {
	pc = 0x826C995C; continue 'dispatch;
	}
	// 826C9924: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9928: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826C992C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826C9934: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C9938: 419A0024  beq cr6, 0x826c995c
	if ctx.cr[6].eq {
	pc = 0x826C995C; continue 'dispatch;
	}
	// 826C993C: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 826C9940: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9944: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9948: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C994C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9950: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C9954: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9958: 4082FFE8  bne 0x826c9940
	if !ctx.cr[0].eq {
	pc = 0x826C9940; continue 'dispatch;
	}
	// 826C995C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C9960: 48ADE85C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C9968 size=132
    let mut pc: u32 = 0x826C9968;
    'dispatch: loop {
        match pc {
            0x826C9968 => {
    //   block [0x826C9968..0x826C99EC)
	// 826C9968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C996C: 48ADE7FD  bl 0x831a8168
	ctx.lr = 0x826C9970;
	sub_831A8130(ctx, base);
	// 826C9970: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9974: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 826C9978: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826C997C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826C9980: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 826C9984: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 826C9988: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826C998C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9990: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 826C9994: 419A004C  beq cr6, 0x826c99e0
	if ctx.cr[6].eq {
	pc = 0x826C99E0; continue 'dispatch;
	}
	// 826C9998: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826C999C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C99A0: 4BD6B3A1  bl 0x82434d40
	ctx.lr = 0x826C99A4;
	sub_82434D40(ctx, base);
	// 826C99A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C99A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C99AC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 826C99B0: 4099001C  ble cr6, 0x826c99cc
	if !ctx.cr[6].gt {
	pc = 0x826C99CC; continue 'dispatch;
	}
	// 826C99B4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826C99B8: 4BD6B389  bl 0x82434d40
	ctx.lr = 0x826C99BC;
	sub_82434D40(ctx, base);
	// 826C99BC: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826C99C0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 826C99C4: 409AFFD4  bne cr6, 0x826c9998
	if !ctx.cr[6].eq {
	pc = 0x826C9998; continue 'dispatch;
	}
	// 826C99C8: 48000018  b 0x826c99e0
	pc = 0x826C99E0; continue 'dispatch;
	// 826C99CC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826C99D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826C99D4: 4BD6B36D  bl 0x82434d40
	ctx.lr = 0x826C99D8;
	sub_82434D40(ctx, base);
	// 826C99D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C99DC: 838B000C  lwz r28, 0xc(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826C99E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826C99E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826C99E8: 48ADE7D0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C99F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C99F0 size=112
    let mut pc: u32 = 0x826C99F0;
    'dispatch: loop {
        match pc {
            0x826C99F0 => {
    //   block [0x826C99F0..0x826C9A60)
	// 826C99F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C99F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C99F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826C99FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C9A00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9A04: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C9A08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9A0C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826C9A10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9A14: 4BFFFDBD  bl 0x826c97d0
	ctx.lr = 0x826C9A18;
	sub_826C97D0(ctx, base);
	// 826C9A18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826C9A1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C9A20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9A24: 4BBF65DD  bl 0x822c0000
	ctx.lr = 0x826C9A28;
	sub_822C0000(ctx, base);
	// 826C9A28: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C9A2C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C9A30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826C9A34: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C9A3C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826C9A40: 419A0008  beq cr6, 0x826c9a48
	if ctx.cr[6].eq {
	pc = 0x826C9A48; continue 'dispatch;
	}
	// 826C9A44: 4BBF6E4D  bl 0x822c0890
	ctx.lr = 0x826C9A48;
	sub_822C0890(ctx, base);
	// 826C9A48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826C9A4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C9A50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C9A54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826C9A58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C9A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C9A60 size=124
    let mut pc: u32 = 0x826C9A60;
    'dispatch: loop {
        match pc {
            0x826C9A60 => {
    //   block [0x826C9A60..0x826C9ADC)
	// 826C9A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9A64: 48ADE709  bl 0x831a816c
	ctx.lr = 0x826C9A68;
	sub_831A8130(ctx, base);
	// 826C9A68: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826C9A6C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826C9A70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9A74: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9A78: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826C9A7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C9A80: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826C9A84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C9A88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9A8C: 388B84B0  addi r4, r11, -0x7b50
	ctx.r[4].s64 = ctx.r[11].s64 + -31568;
	// 826C9A90: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 826C9A94: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C9A98: 4BBF6941  bl 0x822c03d8
	ctx.lr = 0x826C9A9C;
	sub_822C03D8(ctx, base);
	// 826C9A9C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C9AA0: 41820020  beq 0x826c9ac0
	if ctx.cr[0].eq {
	pc = 0x826C9AC0; continue 'dispatch;
	}
	// 826C9AA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C9AA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9AAC: 4872A155  bl 0x82df3c00
	ctx.lr = 0x826C9AB0;
	sub_82DF3C00(ctx, base);
	// 826C9AB0: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 826C9AB4: D3DF0008  stfs f30, 8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 826C9AB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9ABC: 48000008  b 0x826c9ac4
	pc = 0x826C9AC4; continue 'dispatch;
	// 826C9AC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826C9AC4: 387D0024  addi r3, r29, 0x24
	ctx.r[3].s64 = ctx.r[29].s64 + 36;
	// 826C9AC8: 4BFFFF29  bl 0x826c99f0
	ctx.lr = 0x826C9ACC;
	sub_826C99F0(ctx, base);
	// 826C9ACC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826C9AD0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826C9AD4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826C9AD8: 48ADE6E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C9AE0 size=124
    let mut pc: u32 = 0x826C9AE0;
    'dispatch: loop {
        match pc {
            0x826C9AE0 => {
    //   block [0x826C9AE0..0x826C9B5C)
	// 826C9AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9AE4: 48ADE689  bl 0x831a816c
	ctx.lr = 0x826C9AE8;
	sub_831A8130(ctx, base);
	// 826C9AE8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826C9AEC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826C9AF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9AF4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9AF8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826C9AFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C9B00: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826C9B04: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826C9B08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9B0C: 388B84B0  addi r4, r11, -0x7b50
	ctx.r[4].s64 = ctx.r[11].s64 + -31568;
	// 826C9B10: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 826C9B14: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C9B18: 4BBF68C1  bl 0x822c03d8
	ctx.lr = 0x826C9B1C;
	sub_822C03D8(ctx, base);
	// 826C9B1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C9B20: 41820020  beq 0x826c9b40
	if ctx.cr[0].eq {
	pc = 0x826C9B40; continue 'dispatch;
	}
	// 826C9B24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C9B28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9B2C: 4872A0D5  bl 0x82df3c00
	ctx.lr = 0x826C9B30;
	sub_82DF3C00(ctx, base);
	// 826C9B30: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 826C9B34: D3DF0008  stfs f30, 8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 826C9B38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9B3C: 48000008  b 0x826c9b44
	pc = 0x826C9B44; continue 'dispatch;
	// 826C9B40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826C9B44: 387D002C  addi r3, r29, 0x2c
	ctx.r[3].s64 = ctx.r[29].s64 + 44;
	// 826C9B48: 4BFFFEA9  bl 0x826c99f0
	ctx.lr = 0x826C9B4C;
	sub_826C99F0(ctx, base);
	// 826C9B4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826C9B50: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826C9B54: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826C9B58: 48ADE664  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826C9B60 size=68
    let mut pc: u32 = 0x826C9B60;
    'dispatch: loop {
        match pc {
            0x826C9B60 => {
    //   block [0x826C9B60..0x826C9BA4)
	// 826C9B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826C9B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826C9B6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9B70: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826C9B74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9B78: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826C9B7C: 4BFFFAFD  bl 0x826c9678
	ctx.lr = 0x826C9B80;
	sub_826C9678(ctx, base);
	// 826C9B80: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 826C9B84: 4813C935  bl 0x828064b8
	ctx.lr = 0x826C9B88;
	sub_828064B8(ctx, base);
	// 826C9B88: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 826C9B8C: 4813C92D  bl 0x828064b8
	ctx.lr = 0x826C9B90;
	sub_828064B8(ctx, base);
	// 826C9B90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826C9B94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826C9B98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826C9B9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826C9BA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C9BA8 size=276
    let mut pc: u32 = 0x826C9BA8;
    'dispatch: loop {
        match pc {
            0x826C9BA8 => {
    //   block [0x826C9BA8..0x826C9CBC)
	// 826C9BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9BAC: 48ADE5BD  bl 0x831a8168
	ctx.lr = 0x826C9BB0;
	sub_831A8130(ctx, base);
	// 826C9BB0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 826C9BB4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 826C9BB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9BBC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9BC0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826C9BC4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826C9BC8: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826C9BCC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826C9BD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826C9BD4: 938100BC  stw r28, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[28].u32 ) };
	// 826C9BD8: 388B84B0  addi r4, r11, -0x7b50
	ctx.r[4].s64 = ctx.r[11].s64 + -31568;
	// 826C9BDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9BE0: 38A0004D  li r5, 0x4d
	ctx.r[5].s64 = 77;
	// 826C9BE4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826C9BE8: 4BBF67F1  bl 0x822c03d8
	ctx.lr = 0x826C9BEC;
	sub_822C03D8(ctx, base);
	// 826C9BEC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826C9BF0: 4182001C  beq 0x826c9c0c
	if ctx.cr[0].eq {
	pc = 0x826C9C0C; continue 'dispatch;
	}
	// 826C9BF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826C9BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9BFC: 4872A005  bl 0x82df3c00
	ctx.lr = 0x826C9C00;
	sub_82DF3C00(ctx, base);
	// 826C9C00: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 826C9C04: D3DF0008  stfs f30, 8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 826C9C08: 48000008  b 0x826c9c10
	pc = 0x826C9C10; continue 'dispatch;
	// 826C9C0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826C9C10: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826C9C14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9C18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9C1C: 4BFFFBB5  bl 0x826c97d0
	ctx.lr = 0x826C9C20;
	sub_826C97D0(ctx, base);
	// 826C9C20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826C9C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9C28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9C2C: 4BBF63D5  bl 0x822c0000
	ctx.lr = 0x826C9C30;
	sub_822C0000(ctx, base);
	// 826C9C30: 38A100BC  addi r5, r1, 0xbc
	ctx.r[5].s64 = ctx.r[1].s64 + 188;
	// 826C9C34: 389D0034  addi r4, r29, 0x34
	ctx.r[4].s64 = ctx.r[29].s64 + 52;
	// 826C9C38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C9C3C: 4BE86D1D  bl 0x82550958
	ctx.lr = 0x826C9C40;
	sub_82550958(ctx, base);
	// 826C9C40: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C9C44: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C9C48: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826C9C4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C9C50: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826C9C54: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826C9C58: 419A0024  beq cr6, 0x826c9c7c
	if ctx.cr[6].eq {
	pc = 0x826C9C7C; continue 'dispatch;
	}
	// 826C9C5C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826C9C60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9C64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9C68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9C6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9C70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C9C74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9C78: 4082FFE8  bne 0x826c9c60
	if !ctx.cr[0].eq {
	pc = 0x826C9C60; continue 'dispatch;
	}
	// 826C9C7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826C9C80: 389D0040  addi r4, r29, 0x40
	ctx.r[4].s64 = ctx.r[29].s64 + 64;
	// 826C9C84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826C9C88: 48106259  bl 0x827cfee0
	ctx.lr = 0x826C9C8C;
	sub_827CFEE0(ctx, base);
	// 826C9C8C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C9C90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C9C94: 419A0008  beq cr6, 0x826c9c9c
	if ctx.cr[6].eq {
	pc = 0x826C9C9C; continue 'dispatch;
	}
	// 826C9C98: 4BBF6BF9  bl 0x822c0890
	ctx.lr = 0x826C9C9C;
	sub_822C0890(ctx, base);
	// 826C9C9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826C9CA0: 419A000C  beq cr6, 0x826c9cac
	if ctx.cr[6].eq {
	pc = 0x826C9CAC; continue 'dispatch;
	}
	// 826C9CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9CA8: 4BBF6BE9  bl 0x822c0890
	ctx.lr = 0x826C9CAC;
	sub_822C0890(ctx, base);
	// 826C9CAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826C9CB0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826C9CB4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826C9CB8: 48ADE500  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826C9CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826C9CC0 size=1644
    let mut pc: u32 = 0x826C9CC0;
    'dispatch: loop {
        match pc {
            0x826C9CC0 => {
    //   block [0x826C9CC0..0x826CA32C)
	// 826C9CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826C9CC4: 48ADE481  bl 0x831a8144
	ctx.lr = 0x826C9CC8;
	sub_831A8130(ctx, base);
	// 826C9CC8: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 826C9CCC: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826C9CD0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826C9CD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826C9CD8: 3ACB84B0  addi r22, r11, -0x7b50
	ctx.r[22].s64 = ctx.r[11].s64 + -31568;
	// 826C9CDC: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 826C9CE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826C9CE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9CE8: 92A10070  stw r21, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[21].u32 ) };
	// 826C9CEC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826C9CF0: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826C9CF4: 38A0008C  li r5, 0x8c
	ctx.r[5].s64 = 140;
	// 826C9CF8: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826C9CFC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826C9D00: 92A10074  stw r21, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[21].u32 ) };
	// 826C9D04: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 826C9D08: 92A10054  stw r21, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u32 ) };
	// 826C9D0C: 487286DD  bl 0x82df23e8
	ctx.lr = 0x826C9D10;
	sub_82DF23E8(ctx, base);
	// 826C9D10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826C9D14: 41820018  beq 0x826c9d2c
	if ctx.cr[0].eq {
	pc = 0x826C9D2C; continue 'dispatch;
	}
	// 826C9D18: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826C9D1C: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826C9D20: 487493D1  bl 0x82e130f0
	ctx.lr = 0x826C9D24;
	sub_82E130F0(ctx, base);
	// 826C9D24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826C9D28: 48000008  b 0x826c9d30
	pc = 0x826C9D30; continue 'dispatch;
	// 826C9D2C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826C9D30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826C9D34: 4BC1801D  bl 0x822e1d50
	ctx.lr = 0x826C9D38;
	sub_822E1D50(ctx, base);
	// 826C9D38: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9D3C: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826C9D40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826C9D44: 487490ED  bl 0x82e12e30
	ctx.lr = 0x826C9D48;
	sub_82E12E30(ctx, base);
	// 826C9D48: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826C9D4C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 826C9D50: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C9D54: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826C9D58: 419A0024  beq cr6, 0x826c9d7c
	if ctx.cr[6].eq {
	pc = 0x826C9D7C; continue 'dispatch;
	}
	// 826C9D5C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C9D60: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9D64: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9D68: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9D6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9D70: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C9D74: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9D78: 4082FFE8  bne 0x826c9d60
	if !ctx.cr[0].eq {
	pc = 0x826C9D60; continue 'dispatch;
	}
	// 826C9D7C: 839F0054  lwz r28, 0x54(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 826C9D80: 3AFF0050  addi r23, r31, 0x50
	ctx.r[23].s64 = ctx.r[31].s64 + 80;
	// 826C9D84: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826C9D88: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826C9D8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C9D90: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9D94: 4BFFFB3D  bl 0x826c98d0
	ctx.lr = 0x826C9D98;
	sub_826C98D0(ctx, base);
	// 826C9D98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826C9D9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C9DA0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826C9DA4: 4843E57D  bl 0x82b08320
	ctx.lr = 0x826C9DA8;
	sub_82B08320(ctx, base);
	// 826C9DA8: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 826C9DAC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9DB0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C9DB4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 826C9DB8: 419A000C  beq cr6, 0x826c9dc4
	if ctx.cr[6].eq {
	pc = 0x826C9DC4; continue 'dispatch;
	}
	// 826C9DBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826C9DC0: 4BBF6AD1  bl 0x822c0890
	ctx.lr = 0x826C9DC4;
	sub_822C0890(ctx, base);
	// 826C9DC4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 826C9DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C9DCC: 419A00F4  beq cr6, 0x826c9ec0
	if ctx.cr[6].eq {
	pc = 0x826C9EC0; continue 'dispatch;
	}
	// 826C9DD0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 826C9DD4: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 826C9DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826C9DDC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826C9DE0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826C9DE4: 419A0024  beq cr6, 0x826c9e08
	if ctx.cr[6].eq {
	pc = 0x826C9E08; continue 'dispatch;
	}
	// 826C9DE8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826C9DEC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9DF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9DF4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9DF8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9DFC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C9E00: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9E04: 4082FFE8  bne 0x826c9dec
	if !ctx.cr[0].eq {
	pc = 0x826C9DEC; continue 'dispatch;
	}
	// 826C9E08: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826C9E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826C9E10: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826C9E14: 4BFFF8CD  bl 0x826c96e0
	ctx.lr = 0x826C9E18;
	sub_826C96E0(ctx, base);
	// 826C9E18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826C9E1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826C9E20: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826C9E24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826C9E28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826C9E2C: 4BBFA635  bl 0x822c4460
	ctx.lr = 0x826C9E30;
	sub_822C4460(ctx, base);
	// 826C9E30: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826C9E34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826C9E38: 419A0008  beq cr6, 0x826c9e40
	if ctx.cr[6].eq {
	pc = 0x826C9E40; continue 'dispatch;
	}
	// 826C9E3C: 4BBF6A55  bl 0x822c0890
	ctx.lr = 0x826C9E40;
	sub_822C0890(ctx, base);
	// 826C9E40: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 826C9E44: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826C9E48: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 826C9E4C: 419A0024  beq cr6, 0x826c9e70
	if ctx.cr[6].eq {
	pc = 0x826C9E70; continue 'dispatch;
	}
	// 826C9E50: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826C9E54: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826C9E58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9E5C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826C9E60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826C9E64: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826C9E68: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826C9E6C: 4082FFE8  bne 0x826c9e54
	if !ctx.cr[0].eq {
	pc = 0x826C9E54; continue 'dispatch;
	}
	// 826C9E70: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826C9E74: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826C9E78: 4874B239  bl 0x82e150b0
	ctx.lr = 0x826C9E7C;
	sub_82E150B0(ctx, base);
	// 826C9E7C: 3BBF005C  addi r29, r31, 0x5c
	ctx.r[29].s64 = ctx.r[31].s64 + 92;
	// 826C9E80: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826C9E84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9E88: 839F0060  lwz r28, 0x60(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 826C9E8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826C9E90: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9E94: 4BFFFA3D  bl 0x826c98d0
	ctx.lr = 0x826C9E98;
	sub_826C98D0(ctx, base);
	// 826C9E98: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826C9E9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826C9EA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826C9EA4: 4843E47D  bl 0x82b08320
	ctx.lr = 0x826C9EA8;
	sub_82B08320(ctx, base);
	// 826C9EA8: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 826C9EAC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826C9EB0: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 826C9EB4: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 826C9EB8: C3EB0008  lfs f31, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826C9EBC: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826C9EC0: 837F0020  lwz r27, 0x20(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 826C9EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826C9EC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826C9ECC: 4BFFFA9D  bl 0x826c9968
	ctx.lr = 0x826C9ED0;
	sub_826C9968(ctx, base);
	// 826C9ED0: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 826C9ED4: 3B3F0040  addi r25, r31, 0x40
	ctx.r[25].s64 = ctx.r[31].s64 + 64;
	// 826C9ED8: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826C9EDC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826C9EE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826C9EE4: 48254FE5  bl 0x8291eec8
	ctx.lr = 0x826C9EE8;
	sub_8291EEC8(ctx, base);
	// 826C9EE8: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 826C9EEC: 3B000010  li r24, 0x10
	ctx.r[24].s64 = 16;
	// 826C9EF0: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826C9EF4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826C9EF8: 419A022C  beq cr6, 0x826ca124
	if ctx.cr[6].eq {
	pc = 0x826CA124; continue 'dispatch;
	}
	// 826C9EFC: 3B5F005C  addi r26, r31, 0x5c
	ctx.r[26].s64 = ctx.r[31].s64 + 92;
	// 826C9F00: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 826C9F04: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826C9F08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826C9F0C: 38A0009D  li r5, 0x9d
	ctx.r[5].s64 = 157;
	// 826C9F10: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826C9F14: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826C9F18: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 826C9F1C: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826C9F20: 487284C9  bl 0x82df23e8
	ctx.lr = 0x826C9F24;
	sub_82DF23E8(ctx, base);
	// 826C9F24: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826C9F28: 41820040  beq 0x826c9f68
	if ctx.cr[0].eq {
	pc = 0x826C9F68; continue 'dispatch;
	}
	// 826C9F2C: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 826C9F30: 13FFC0C7  vcmpequd (lvx128) v31, v31, v24
	tmp.u32 = ctx.r[31].u32 + ctx.r[24].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826C9F34: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 826C9F38: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826C9F3C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826C9F40: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA330 size=88
    let mut pc: u32 = 0x826CA330;
    'dispatch: loop {
        match pc {
            0x826CA330 => {
    //   block [0x826CA330..0x826CA388)
	// 826CA330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA33C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CA348: 8BDF004C  lbz r30, 0x4c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 826CA34C: 4BFFF815  bl 0x826c9b60
	ctx.lr = 0x826CA350;
	sub_826C9B60(ctx, base);
	// 826CA350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA354: 4BFFF96D  bl 0x826c9cc0
	ctx.lr = 0x826CA358;
	sub_826C9CC0(ctx, base);
	// 826CA358: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CA35C: 41820014  beq 0x826ca370
	if ctx.cr[0].eq {
	pc = 0x826CA370; continue 'dispatch;
	}
	// 826CA360: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826CA364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA368: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826CA36C: 4BFFF2A5  bl 0x826c9610
	ctx.lr = 0x826CA370;
	sub_826C9610(ctx, base);
	// 826CA370: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CA374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA37C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CA380: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CA388 size=228
    let mut pc: u32 = 0x826CA388;
    'dispatch: loop {
        match pc {
            0x826CA388 => {
    //   block [0x826CA388..0x826CA46C)
	// 826CA388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA390: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA394: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA39C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CA3A0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 826CA3A4: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 826CA3A8: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CA3AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826CA3B0: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CA3B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CA3B8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826CA3BC: 419A0024  beq cr6, 0x826ca3e0
	if ctx.cr[6].eq {
	pc = 0x826CA3E0; continue 'dispatch;
	}
	// 826CA3C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CA3C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CA3C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CA3CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CA3D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CA3D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CA3D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CA3DC: 4082FFE8  bne 0x826ca3c4
	if !ctx.cr[0].eq {
	pc = 0x826CA3C4; continue 'dispatch;
	}
	// 826CA3E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CA3E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CA3E8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826CA3EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826CA3F0: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 826CA3F4: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CA3F8: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CA3FC: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 826CA400: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 826CA404: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826CA408: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 826CA40C: 913F0020  stw r9, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 826CA410: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 826CA414: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 826CA418: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 826CA41C: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 826CA420: 4BD6ABF1  bl 0x82435010
	ctx.lr = 0x826CA424;
	sub_82435010(ctx, base);
	// 826CA424: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 826CA428: 480D17D1  bl 0x8279bbf8
	ctx.lr = 0x826CA42C;
	sub_8279BBF8(ctx, base);
	// 826CA42C: 9BDF004C  stb r30, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u8 ) };
	// 826CA430: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 826CA434: 4843B85D  bl 0x82b05c90
	ctx.lr = 0x826CA438;
	sub_82B05C90(ctx, base);
	// 826CA438: 907F0054  stw r3, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 826CA43C: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 826CA440: 387F005C  addi r3, r31, 0x5c
	ctx.r[3].s64 = ctx.r[31].s64 + 92;
	// 826CA444: 4843B84D  bl 0x82b05c90
	ctx.lr = 0x826CA448;
	sub_82B05C90(ctx, base);
	// 826CA448: 907F0060  stw r3, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 826CA44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA450: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 826CA454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CA458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA45C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA460: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CA464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA470 size=136
    let mut pc: u32 = 0x826CA470;
    'dispatch: loop {
        match pc {
            0x826CA470 => {
    //   block [0x826CA470..0x826CA4F8)
	// 826CA470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA47C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA484: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CA488: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CA48C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 826CA490: 409A0020  bne cr6, 0x826ca4b0
	if !ctx.cr[6].eq {
	pc = 0x826CA4B0; continue 'dispatch;
	}
	// 826CA494: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CA498: 419A0048  beq cr6, 0x826ca4e0
	if ctx.cr[6].eq {
	pc = 0x826CA4E0; continue 'dispatch;
	}
	// 826CA49C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826CA4A0: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 826CA4A4: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 826CA4A8: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 826CA4AC: 48000034  b 0x826ca4e0
	pc = 0x826CA4E0; continue 'dispatch;
	// 826CA4B0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 826CA4B4: 419A002C  beq cr6, 0x826ca4e0
	if ctx.cr[6].eq {
	pc = 0x826CA4E0; continue 'dispatch;
	}
	// 826CA4B8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CA4BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CA4C0: 388BC8E0  addi r4, r11, -0x3720
	ctx.r[4].s64 = ctx.r[11].s64 + -14112;
	// 826CA4C4: 48ADDC35  bl 0x831a80f8
	ctx.lr = 0x826CA4C8;
	sub_831A80F8(ctx, base);
	// 826CA4C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CA4CC: 4182000C  beq 0x826ca4d8
	if ctx.cr[0].eq {
	pc = 0x826CA4D8; continue 'dispatch;
	}
	// 826CA4D0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826CA4D4: 4800000C  b 0x826ca4e0
	pc = 0x826CA4E0; continue 'dispatch;
	// 826CA4D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CA4DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CA4E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CA4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA4EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CA4F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA4F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CA4F8 size=116
    let mut pc: u32 = 0x826CA4F8;
    'dispatch: loop {
        match pc {
            0x826CA4F8 => {
    //   block [0x826CA4F8..0x826CA56C)
	// 826CA4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA4FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA500: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA504: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA50C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CA510: 4BE461F9  bl 0x82510708
	ctx.lr = 0x826CA514;
	sub_82510708(ctx, base);
	// 826CA514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CA518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA51C: 4BE44FAD  bl 0x8250f4c8
	ctx.lr = 0x826CA520;
	sub_8250F4C8(ctx, base);
	// 826CA520: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CA524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CA528: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CA52C: 409A0008  bne cr6, 0x826ca534
	if !ctx.cr[6].eq {
	pc = 0x826CA534; continue 'dispatch;
	}
	// 826CA530: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826CA534: 83DF00E8  lwz r30, 0xe8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CA538: 4BE3DFE1  bl 0x82508518
	ctx.lr = 0x826CA53C;
	sub_82508518(ctx, base);
	// 826CA53C: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CA540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CA544: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 826CA548: 48001EC1  bl 0x826cc408
	ctx.lr = 0x826CA54C;
	sub_826CC408(ctx, base);
	// 826CA54C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA550: 48727741  bl 0x82df1c90
	ctx.lr = 0x826CA554;
	sub_82DF1C90(ctx, base);
	// 826CA554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CA558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CA564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CA570 size=8
    let mut pc: u32 = 0x826CA570;
    'dispatch: loop {
        match pc {
            0x826CA570 => {
    //   block [0x826CA570..0x826CA578)
	// 826CA570: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CA574: 48001D44  b 0x826cc2b8
	sub_826CC2B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CA578 size=28
    let mut pc: u32 = 0x826CA578;
    'dispatch: loop {
        match pc {
            0x826CA578 => {
    //   block [0x826CA578..0x826CA594)
	// 826CA578: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826CA57C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 826CA580: 419A0014  beq cr6, 0x826ca594
	if ctx.cr[6].eq {
		sub_826CA594(ctx, base);
		return;
	}
	// 826CA584: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 826CA588: 409A0014  bne cr6, 0x826ca59c
	if !ctx.cr[6].eq {
		sub_826CA594(ctx, base);
		return;
	}
	// 826CA58C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826CA590: 48000008  b 0x826ca598
	sub_826CA594(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA594(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CA594 size=20
    let mut pc: u32 = 0x826CA594;
    'dispatch: loop {
        match pc {
            0x826CA594 => {
    //   block [0x826CA594..0x826CA5A8)
	// 826CA594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CA598: 996300F0  stb r11, 0xf0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[11].u8 ) };
	// 826CA59C: 888300F0  lbz r4, 0xf0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) } as u64;
	// 826CA5A0: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CA5A4: 48001D1C  b 0x826cc2c0
	sub_826CC2C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA5A8 size=72
    let mut pc: u32 = 0x826CA5A8;
    'dispatch: loop {
        match pc {
            0x826CA5A8 => {
    //   block [0x826CA5A8..0x826CA5F0)
	// 826CA5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA5AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA5B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA5B4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 826CA5B8: 419A001C  beq cr6, 0x826ca5d4
	if ctx.cr[6].eq {
	pc = 0x826CA5D4; continue 'dispatch;
	}
	// 826CA5BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CA5C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826CA5C4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 826CA5C8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CA5CC: 4BFFFEA5  bl 0x826ca470
	ctx.lr = 0x826CA5D0;
	sub_826CA470(ctx, base);
	// 826CA5D0: 48000010  b 0x826ca5e0
	pc = 0x826CA5E0; continue 'dispatch;
	// 826CA5D4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CA5D8: 396BC8E0  addi r11, r11, -0x3720
	ctx.r[11].s64 = ctx.r[11].s64 + -14112;
	// 826CA5DC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CA5E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CA5E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA5E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA5EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA5F0 size=96
    let mut pc: u32 = 0x826CA5F0;
    'dispatch: loop {
        match pc {
            0x826CA5F0 => {
    //   block [0x826CA5F0..0x826CA650)
	// 826CA5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA5F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA5F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA5FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA600: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CA604: 4BE47D2D  bl 0x82512330
	ctx.lr = 0x826CA608;
	sub_82512330(ctx, base);
	// 826CA608: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CA60C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CA610: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826CA614: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CA618: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826CA61C: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826CA620: 394A8584  addi r10, r10, -0x7a7c
	ctx.r[10].s64 = ctx.r[10].s64 + -31356;
	// 826CA624: 39298570  addi r9, r9, -0x7a90
	ctx.r[9].s64 = ctx.r[9].s64 + -31376;
	// 826CA628: 39688524  addi r11, r8, -0x7adc
	ctx.r[11].s64 = ctx.r[8].s64 + -31452;
	// 826CA62C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826CA630: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826CA634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA638: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826CA63C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CA640: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA644: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA648: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA64C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CA650 size=128
    let mut pc: u32 = 0x826CA650;
    'dispatch: loop {
        match pc {
            0x826CA650 => {
    //   block [0x826CA650..0x826CA6D0)
	// 826CA650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA654: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA658: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA65C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CA664: 4BFFFF8D  bl 0x826ca5f0
	ctx.lr = 0x826CA668;
	sub_826CA5F0(ctx, base);
	// 826CA668: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CA66C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CA670: 396B8624  addi r11, r11, -0x79dc
	ctx.r[11].s64 = ctx.r[11].s64 + -31196;
	// 826CA674: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CA678: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826CA67C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CA680: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 826CA684: 394A8610  addi r10, r10, -0x79f0
	ctx.r[10].s64 = ctx.r[10].s64 + -31216;
	// 826CA688: 392985C4  addi r9, r9, -0x7a3c
	ctx.r[9].s64 = ctx.r[9].s64 + -31292;
	// 826CA68C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CA690: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826CA694: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826CA698: C008A2EC  lfs f0, -0x5d14(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-23828 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CA69C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826CA6A0: C1A708A4  lfs f13, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CA6A4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826CA6A8: D01F00F4  stfs f0, 0xf4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 826CA6AC: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 826CA6B0: 997F00F0  stb r11, 0xf0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u8 ) };
	// 826CA6B4: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 826CA6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA6BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CA6C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA6C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA6C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA6CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CA6D0 size=8
    let mut pc: u32 = 0x826CA6D0;
    'dispatch: loop {
        match pc {
            0x826CA6D0 => {
    //   block [0x826CA6D0..0x826CA6D8)
	// 826CA6D0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826CA6D4: 4BF4F784  b 0x82619e58
	sub_82619E58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA6D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CA6D8 size=520
    let mut pc: u32 = 0x826CA6D8;
    'dispatch: loop {
        match pc {
            0x826CA6D8 => {
    //   block [0x826CA6D8..0x826CA8E0)
	// 826CA6D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA6DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA6E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA6E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA6E8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826CA6EC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826CA6F0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CA6F4: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA6F8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CA6FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CA700: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CA704: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA708: 388BD300  addi r4, r11, -0x2d00
	ctx.r[4].s64 = ctx.r[11].s64 + -11520;
	// 826CA70C: 487292FD  bl 0x82df3a08
	ctx.lr = 0x826CA710;
	sub_82DF3A08(ctx, base);
	// 826CA710: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CA714: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA718: 388B1CE0  addi r4, r11, 0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + 7392;
	// 826CA71C: 487292ED  bl 0x82df3a08
	ctx.lr = 0x826CA720;
	sub_82DF3A08(ctx, base);
	// 826CA720: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CA724: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826CA728: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826CA72C: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 826CA730: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CA734: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CA738: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826CA73C: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CA740: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CA744: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826CA748: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CA74C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826CA750: 4BED8B59  bl 0x825a32a8
	ctx.lr = 0x826CA754;
	sub_825A32A8(ctx, base);
	// 826CA754: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CA758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CA75C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CA760: 4BED7011  bl 0x825a1770
	ctx.lr = 0x826CA764;
	sub_825A1770(ctx, base);
	// 826CA764: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826CA768: 48728CC1  bl 0x82df3428
	ctx.lr = 0x826CA76C;
	sub_82DF3428(ctx, base);
	// 826CA76C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826CA770: 4BBFE549  bl 0x822c8cb8
	ctx.lr = 0x826CA774;
	sub_822C8CB8(ctx, base);
	// 826CA774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA778: 48728CB1  bl 0x82df3428
	ctx.lr = 0x826CA77C;
	sub_82DF3428(ctx, base);
	// 826CA77C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA780: 48728CA9  bl 0x82df3428
	ctx.lr = 0x826CA784;
	sub_82DF3428(ctx, base);
	// 826CA784: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CA788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA78C: 388BD2F8  addi r4, r11, -0x2d08
	ctx.r[4].s64 = ctx.r[11].s64 + -11528;
	// 826CA790: 48729279  bl 0x82df3a08
	ctx.lr = 0x826CA794;
	sub_82DF3A08(ctx, base);
	// 826CA794: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CA798: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA79C: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 826CA7A0: 48729269  bl 0x82df3a08
	ctx.lr = 0x826CA7A4;
	sub_82DF3A08(ctx, base);
	// 826CA7A4: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 826CA7A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CA7AC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CA7B0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826CA7B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CA7B8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826CA7BC: 4BED8AED  bl 0x825a32a8
	ctx.lr = 0x826CA7C0;
	sub_825A32A8(ctx, base);
	// 826CA7C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CA7C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CA7C8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CA7CC: 4BED6FA5  bl 0x825a1770
	ctx.lr = 0x826CA7D0;
	sub_825A1770(ctx, base);
	// 826CA7D0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826CA7D4: 48728C55  bl 0x82df3428
	ctx.lr = 0x826CA7D8;
	sub_82DF3428(ctx, base);
	// 826CA7D8: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826CA7DC: 4BBFE4DD  bl 0x822c8cb8
	ctx.lr = 0x826CA7E0;
	sub_822C8CB8(ctx, base);
	// 826CA7E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA7E4: 48728C45  bl 0x82df3428
	ctx.lr = 0x826CA7E8;
	sub_82DF3428(ctx, base);
	// 826CA7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA7EC: 48728C3D  bl 0x82df3428
	ctx.lr = 0x826CA7F0;
	sub_82DF3428(ctx, base);
	// 826CA7F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CA7F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA7F8: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826CA7FC: 4872920D  bl 0x82df3a08
	ctx.lr = 0x826CA800;
	sub_82DF3A08(ctx, base);
	// 826CA800: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CA804: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA808: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826CA80C: 487291FD  bl 0x82df3a08
	ctx.lr = 0x826CA810;
	sub_82DF3A08(ctx, base);
	// 826CA810: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 826CA814: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CA818: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CA81C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826CA820: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CA824: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826CA828: 4BED8A81  bl 0x825a32a8
	ctx.lr = 0x826CA82C;
	sub_825A32A8(ctx, base);
	// 826CA82C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CA830: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CA834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CA838: 4BED6F39  bl 0x825a1770
	ctx.lr = 0x826CA83C;
	sub_825A1770(ctx, base);
	// 826CA83C: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826CA840: 48728BE9  bl 0x82df3428
	ctx.lr = 0x826CA844;
	sub_82DF3428(ctx, base);
	// 826CA844: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826CA848: 4BBFE471  bl 0x822c8cb8
	ctx.lr = 0x826CA84C;
	sub_822C8CB8(ctx, base);
	// 826CA84C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA850: 48728BD9  bl 0x82df3428
	ctx.lr = 0x826CA854;
	sub_82DF3428(ctx, base);
	// 826CA854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA858: 48728BD1  bl 0x82df3428
	ctx.lr = 0x826CA85C;
	sub_82DF3428(ctx, base);
	// 826CA85C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CA860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA864: 388B8674  addi r4, r11, -0x798c
	ctx.r[4].s64 = ctx.r[11].s64 + -31116;
	// 826CA868: 487291A1  bl 0x82df3a08
	ctx.lr = 0x826CA86C;
	sub_82DF3A08(ctx, base);
	// 826CA86C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CA870: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA874: 388B866C  addi r4, r11, -0x7994
	ctx.r[4].s64 = ctx.r[11].s64 + -31124;
	// 826CA878: 48729191  bl 0x82df3a08
	ctx.lr = 0x826CA87C;
	sub_82DF3A08(ctx, base);
	// 826CA87C: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 826CA880: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CA884: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CA888: 4BED87C9  bl 0x825a3050
	ctx.lr = 0x826CA88C;
	sub_825A3050(ctx, base);
	// 826CA88C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CA890: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CA894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CA898: 4BED78F1  bl 0x825a2188
	ctx.lr = 0x826CA89C;
	sub_825A2188(ctx, base);
	// 826CA89C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CA8A0: 48728B89  bl 0x82df3428
	ctx.lr = 0x826CA8A4;
	sub_82DF3428(ctx, base);
	// 826CA8A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826CA8A8: 4BBFE411  bl 0x822c8cb8
	ctx.lr = 0x826CA8AC;
	sub_822C8CB8(ctx, base);
	// 826CA8AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CA8B0: 48728B79  bl 0x82df3428
	ctx.lr = 0x826CA8B4;
	sub_82DF3428(ctx, base);
	// 826CA8B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA8B8: 48728B71  bl 0x82df3428
	ctx.lr = 0x826CA8BC;
	sub_82DF3428(ctx, base);
	// 826CA8BC: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 826CA8C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA8C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA8C8: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826CA8CC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826CA8D0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826CA8D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CA8D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA8E0 size=196
    let mut pc: u32 = 0x826CA8E0;
    'dispatch: loop {
        match pc {
            0x826CA8E0 => {
    //   block [0x826CA8E0..0x826CA9A4)
	// 826CA8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA8F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA8F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CA8F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CA8FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826CA900: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CA904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CA908: 4BBF6031  bl 0x822c0938
	ctx.lr = 0x826CA90C;
	sub_822C0938(ctx, base);
	// 826CA90C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CA910: 41820028  beq 0x826ca938
	if ctx.cr[0].eq {
	pc = 0x826CA938; continue 'dispatch;
	}
	// 826CA914: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CA918: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826CA91C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826CA920: 392B850C  addi r9, r11, -0x7af4
	ctx.r[9].s64 = ctx.r[11].s64 + -31476;
	// 826CA924: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826CA928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CA92C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826CA930: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826CA934: 48000008  b 0x826ca93c
	pc = 0x826CA93C; continue 'dispatch;
	// 826CA938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CA93C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CA940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CA944: 409A0044  bne cr6, 0x826ca988
	if !ctx.cr[6].eq {
	pc = 0x826CA988; continue 'dispatch;
	}
	// 826CA948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CA94C: 419A001C  beq cr6, 0x826ca968
	if ctx.cr[6].eq {
	pc = 0x826CA968; continue 'dispatch;
	}
	// 826CA950: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 826CA954: 4BBFE365  bl 0x822c8cb8
	ctx.lr = 0x826CA958;
	sub_822C8CB8(ctx, base);
	// 826CA958: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 826CA95C: 4BBFE35D  bl 0x822c8cb8
	ctx.lr = 0x826CA960;
	sub_822C8CB8(ctx, base);
	// 826CA960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA964: 48727A75  bl 0x82df23d8
	ctx.lr = 0x826CA968;
	sub_82DF23D8(ctx, base);
	// 826CA968: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CA96C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CA970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CA974: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826CA978: 816BC8DC  lwz r11, -0x3724(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-14116 as u32) ) } as u64;
	// 826CA97C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CA980: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CA984: 4BBF567D  bl 0x822c0000
	ctx.lr = 0x826CA988;
	sub_822C0000(ctx, base);
	// 826CA988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CA98C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CA990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA998: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CA99C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA9A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA9A8 size=72
    let mut pc: u32 = 0x826CA9A8;
    'dispatch: loop {
        match pc {
            0x826CA9A8 => {
    //   block [0x826CA9A8..0x826CA9F0)
	// 826CA9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA9B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CA9B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CA9B8: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CA9BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CA9C0: 419A001C  beq cr6, 0x826ca9dc
	if ctx.cr[6].eq {
	pc = 0x826CA9DC; continue 'dispatch;
	}
	// 826CA9C4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 826CA9C8: 4BBFE2F1  bl 0x822c8cb8
	ctx.lr = 0x826CA9CC;
	sub_822C8CB8(ctx, base);
	// 826CA9CC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 826CA9D0: 4BBFE2E9  bl 0x822c8cb8
	ctx.lr = 0x826CA9D4;
	sub_822C8CB8(ctx, base);
	// 826CA9D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CA9D8: 48727A01  bl 0x82df23d8
	ctx.lr = 0x826CA9DC;
	sub_82DF23D8(ctx, base);
	// 826CA9DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CA9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CA9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CA9E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CA9EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CA9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CA9F0 size=112
    let mut pc: u32 = 0x826CA9F0;
    'dispatch: loop {
        match pc {
            0x826CA9F0 => {
    //   block [0x826CA9F0..0x826CAA60)
	// 826CA9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CA9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CA9F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CA9FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CAA00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAA04: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CAA08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CAA0C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826CAA10: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CAA14: 4BFFFECD  bl 0x826ca8e0
	ctx.lr = 0x826CAA18;
	sub_826CA8E0(ctx, base);
	// 826CAA18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CAA1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CAA20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CAA24: 4BBF55DD  bl 0x822c0000
	ctx.lr = 0x826CAA28;
	sub_822C0000(ctx, base);
	// 826CAA28: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CAA2C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CAA30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CAA34: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CAA38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CAA3C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826CAA40: 419A0008  beq cr6, 0x826caa48
	if ctx.cr[6].eq {
	pc = 0x826CAA48; continue 'dispatch;
	}
	// 826CAA44: 4BBF5E4D  bl 0x822c0890
	ctx.lr = 0x826CAA48;
	sub_822C0890(ctx, base);
	// 826CAA48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CAA4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CAA50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CAA54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CAA58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CAA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CAA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CAA60 size=128
    let mut pc: u32 = 0x826CAA60;
    'dispatch: loop {
        match pc {
            0x826CAA60 => {
    //   block [0x826CAA60..0x826CAAE0)
	// 826CAA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CAA64: 48ADD709  bl 0x831a816c
	ctx.lr = 0x826CAA68;
	sub_831A8130(ctx, base);
	// 826CAA68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAA6C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826CAA70: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826CAA74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CAA78: 3BEB8234  addi r31, r11, -0x7dcc
	ctx.r[31].s64 = ctx.r[11].s64 + -32204;
	// 826CAA7C: 816A823C  lwz r11, -0x7dc4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32196 as u32) ) } as u64;
	// 826CAA80: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826CAA84: 40820024  bne 0x826caaa8
	if !ctx.cr[0].eq {
	pc = 0x826CAAA8; continue 'dispatch;
	}
	// 826CAA88: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 826CAA8C: 3D00826D  lis r8, -0x7d93
	ctx.r[8].s64 = -2106785792;
	// 826CAA90: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826CAA94: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 826CAA98: 3908A5A8  addi r8, r8, -0x5a58
	ctx.r[8].s64 = ctx.r[8].s64 + -23128;
	// 826CAA9C: 916A823C  stw r11, -0x7dc4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32196 as u32), ctx.r[11].u32 ) };
	// 826CAAA0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826CAAA4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826CAAA8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CAAAC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CAAB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CAAB4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 826CAAB8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 826CAABC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CAAC0: 4BF89B01  bl 0x826545c0
	ctx.lr = 0x826CAAC4;
	sub_826545C0(ctx, base);
	// 826CAAC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CAAC8: 4182000C  beq 0x826caad4
	if ctx.cr[0].eq {
	pc = 0x826CAAD4; continue 'dispatch;
	}
	// 826CAACC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CAAD0: 48000008  b 0x826caad8
	pc = 0x826CAAD8; continue 'dispatch;
	// 826CAAD4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826CAAD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CAADC: 48ADD6E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CAAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CAAE0 size=268
    let mut pc: u32 = 0x826CAAE0;
    'dispatch: loop {
        match pc {
            0x826CAAE0 => {
    //   block [0x826CAAE0..0x826CABEC)
	// 826CAAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CAAE4: 48ADD689  bl 0x831a816c
	ctx.lr = 0x826CAAE8;
	sub_831A8130(ctx, base);
	// 826CAAE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAAEC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CAAF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CAAF4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826CAAF8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 826CAAFC: 4BE46EDD  bl 0x825119d8
	ctx.lr = 0x826CAB00;
	sub_825119D8(ctx, base);
	// 826CAB00: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CAB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CAB08: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826CAB0C: 48728EFD  bl 0x82df3a08
	ctx.lr = 0x826CAB10;
	sub_82DF3A08(ctx, base);
	// 826CAB10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CAB14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CAB18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAB1C: 4BE3DC65  bl 0x82508780
	ctx.lr = 0x826CAB20;
	sub_82508780(ctx, base);
	// 826CAB20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CAB24: 48728905  bl 0x82df3428
	ctx.lr = 0x826CAB28;
	sub_82DF3428(ctx, base);
	// 826CAB28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CAB2C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826CAB30: 409A0008  bne cr6, 0x826cab38
	if !ctx.cr[6].eq {
	pc = 0x826CAB38; continue 'dispatch;
	}
	// 826CAB34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CAB38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAB3C: 4BE3DC65  bl 0x825087a0
	ctx.lr = 0x826CAB40;
	sub_825087A0(ctx, base);
	// 826CAB40: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CAB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CAB48: 388B8690  addi r4, r11, -0x7970
	ctx.r[4].s64 = ctx.r[11].s64 + -31088;
	// 826CAB4C: 38A0003D  li r5, 0x3d
	ctx.r[5].s64 = 61;
	// 826CAB50: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 826CAB54: 48727895  bl 0x82df23e8
	ctx.lr = 0x826CAB58;
	sub_82DF23E8(ctx, base);
	// 826CAB58: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826CAB5C: 4182004C  beq 0x826caba8
	if ctx.cr[0].eq {
	pc = 0x826CABA8; continue 'dispatch;
	}
	// 826CAB60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAB64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CAB68: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826CAB6C: 4BE4495D  bl 0x8250f4c8
	ctx.lr = 0x826CAB70;
	sub_8250F4C8(ctx, base);
	// 826CAB70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CAB74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CAB78: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CAB7C: 409A0008  bne cr6, 0x826cab84
	if !ctx.cr[6].eq {
	pc = 0x826CAB84; continue 'dispatch;
	}
	// 826CAB80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826CAB84: 4BE3D995  bl 0x82508518
	ctx.lr = 0x826CAB88;
	sub_82508518(ctx, base);
	// 826CAB88: C01F00FC  lfs f0, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CAB8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAB90: EC61002A  fadds f3, f1, f0
	ctx.f[3].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 826CAB94: C05F00F8  lfs f2, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CAB98: C03F00F4  lfs f1, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CAB9C: 480017A5  bl 0x826cc340
	ctx.lr = 0x826CABA0;
	sub_826CC340(ctx, base);
	// 826CABA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CABA4: 48000008  b 0x826cabac
	pc = 0x826CABAC; continue 'dispatch;
	// 826CABA8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CABAC: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 826CABB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CABB4: 4BFFFE3D  bl 0x826ca9f0
	ctx.lr = 0x826CABB8;
	sub_826CA9F0(ctx, base);
	// 826CABB8: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CABBC: 4182000C  beq 0x826cabc8
	if ctx.cr[0].eq {
	pc = 0x826CABC8; continue 'dispatch;
	}
	// 826CABC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CABC4: 487270CD  bl 0x82df1c90
	ctx.lr = 0x826CABC8;
	sub_82DF1C90(ctx, base);
	// 826CABC8: 889F00F0  lbz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826CABCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CABD0: 480016F1  bl 0x826cc2c0
	ctx.lr = 0x826CABD4;
	sub_826CC2C0(ctx, base);
	// 826CABD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CABD8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CABDC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CABE0: 48001829  bl 0x826cc408
	ctx.lr = 0x826CABE4;
	sub_826CC408(ctx, base);
	// 826CABE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CABE8: 48ADD5D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CABF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CABF0 size=168
    let mut pc: u32 = 0x826CABF0;
    'dispatch: loop {
        match pc {
            0x826CABF0 => {
    //   block [0x826CABF0..0x826CAC98)
	// 826CABF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CABF4: 48ADD579  bl 0x831a816c
	ctx.lr = 0x826CABF8;
	sub_831A8130(ctx, base);
	// 826CABF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CABFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CAC00: 3BDFFF1C  addi r30, r31, -0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + -228;
	// 826CAC04: 83BFFF1C  lwz r29, -0xe4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-228 as u32) ) } as u64;
	// 826CAC08: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CAC0C: 480016AD  bl 0x826cc2b8
	ctx.lr = 0x826CAC10;
	sub_826CC2B8(ctx, base);
	// 826CAC10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CAC14: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 826CAC18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAC1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CAC20: 4E800421  bctrl
	ctx.lr = 0x826CAC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CAC24: 3D608290  lis r11, -0x7d70
	ctx.r[11].s64 = -2104492032;
	// 826CAC28: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CAC2C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 826CAC30: 396B40C8  addi r11, r11, 0x40c8
	ctx.r[11].s64 = ctx.r[11].s64 + 16584;
	// 826CAC34: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826CAC38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CAC3C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 826CAC40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826CAC44: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826CAC48: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826CAC4C: 4BFFFE15  bl 0x826caa60
	ctx.lr = 0x826CAC50;
	sub_826CAA60(ctx, base);
	// 826CAC50: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CAC54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CAC58: 48001741  bl 0x826cc398
	ctx.lr = 0x826CAC5C;
	sub_826CC398(ctx, base);
	// 826CAC5C: 3D6082B4  lis r11, -0x7d4c
	ctx.r[11].s64 = -2102132736;
	// 826CAC60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CAC64: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 826CAC68: 396BD898  addi r11, r11, -0x2768
	ctx.r[11].s64 = ctx.r[11].s64 + -10088;
	// 826CAC6C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 826CAC70: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 826CAC74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826CAC78: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826CAC7C: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 826CAC80: 4BFFFDE1  bl 0x826caa60
	ctx.lr = 0x826CAC84;
	sub_826CAA60(ctx, base);
	// 826CAC84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CAC88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CAC8C: 48001745  bl 0x826cc3d0
	ctx.lr = 0x826CAC90;
	sub_826CC3D0(ctx, base);
	// 826CAC90: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826CAC94: 48ADD528  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CAC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CAC98 size=96
    let mut pc: u32 = 0x826CAC98;
    'dispatch: loop {
        match pc {
            0x826CAC98 => {
    //   block [0x826CAC98..0x826CACF8)
	// 826CAC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CAC9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CACA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CACA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CACA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CACAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CACB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CACB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CACB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CACBC: 388B866C  addi r4, r11, -0x7994
	ctx.r[4].s64 = ctx.r[11].s64 + -31124;
	// 826CACC0: 48728D49  bl 0x82df3a08
	ctx.lr = 0x826CACC4;
	sub_82DF3A08(ctx, base);
	// 826CACC4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826CACC8: 38BF00F0  addi r5, r31, 0xf0
	ctx.r[5].s64 = ctx.r[31].s64 + 240;
	// 826CACCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CACD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CACD4: 4BF2D3B5  bl 0x825f8088
	ctx.lr = 0x826CACD8;
	sub_825F8088(ctx, base);
	// 826CACD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CACDC: 4872874D  bl 0x82df3428
	ctx.lr = 0x826CACE0;
	sub_82DF3428(ctx, base);
	// 826CACE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CACE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CACE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CACEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CACF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CACF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CACF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CACF8 size=164
    let mut pc: u32 = 0x826CACF8;
    'dispatch: loop {
        match pc {
            0x826CACF8 => {
    //   block [0x826CACF8..0x826CAD9C)
	// 826CACF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CACFC: 48ADD46D  bl 0x831a8168
	ctx.lr = 0x826CAD00;
	sub_831A8130(ctx, base);
	// 826CAD00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAD04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826CAD08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CAD0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CAD10: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826CAD14: 41820038  beq 0x826cad4c
	if ctx.cr[0].eq {
	pc = 0x826CAD4C; continue 'dispatch;
	}
	// 826CAD18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CAD1C: 48ADEC6D  bl 0x831a9988
	ctx.lr = 0x826CAD20;
	sub_831A9988(ctx, base);
	// 826CAD20: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CAD24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CAD28: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826CAD2C: 48ADD3CD  bl 0x831a80f8
	ctx.lr = 0x826CAD30;
	sub_831A80F8(ctx, base);
	// 826CAD30: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CAD34: 41820018  beq 0x826cad4c
	if ctx.cr[0].eq {
	pc = 0x826CAD4C; continue 'dispatch;
	}
	// 826CAD38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAD3C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826CAD40: 4801B141  bl 0x826e5e80
	ctx.lr = 0x826CAD44;
	sub_826E5E80(ctx, base);
	// 826CAD44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826CAD48: 4800004C  b 0x826cad94
	pc = 0x826CAD94; continue 'dispatch;
	// 826CAD4C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826CAD50: 419A0034  beq cr6, 0x826cad84
	if ctx.cr[6].eq {
	pc = 0x826CAD84; continue 'dispatch;
	}
	// 826CAD54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CAD58: 48ADEC31  bl 0x831a9988
	ctx.lr = 0x826CAD5C;
	sub_831A9988(ctx, base);
	// 826CAD5C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CAD60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CAD64: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826CAD68: 48ADD391  bl 0x831a80f8
	ctx.lr = 0x826CAD6C;
	sub_831A80F8(ctx, base);
	// 826CAD6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CAD70: 41820014  beq 0x826cad84
	if ctx.cr[0].eq {
	pc = 0x826CAD84; continue 'dispatch;
	}
	// 826CAD74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAD78: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826CAD7C: 4BFFF7FD  bl 0x826ca578
	ctx.lr = 0x826CAD80;
	sub_826CA578(ctx, base);
	// 826CAD80: 4BFFFFC4  b 0x826cad44
	pc = 0x826CAD44; continue 'dispatch;
	// 826CAD84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826CAD88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAD8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAD90: 4BE47889  bl 0x82512618
	ctx.lr = 0x826CAD94;
	sub_82512618(ctx, base);
	// 826CAD94: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CAD98: 48ADD420  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CADA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CADA0 size=128
    let mut pc: u32 = 0x826CADA0;
    'dispatch: loop {
        match pc {
            0x826CADA0 => {
    //   block [0x826CADA0..0x826CAE20)
	// 826CADA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CADA4: 48ADD3C5  bl 0x831a8168
	ctx.lr = 0x826CADA8;
	sub_831A8130(ctx, base);
	// 826CADA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CADAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CADB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CADB4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 826CADB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CADBC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826CADC0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 826CADC4: 4BC1C445  bl 0x822e7208
	ctx.lr = 0x826CADC8;
	sub_822E7208(ctx, base);
	// 826CADC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CADCC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826CADD0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826CADD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CADD8: 4BC1C5B9  bl 0x822e7390
	ctx.lr = 0x826CADDC;
	sub_822E7390(ctx, base);
	// 826CADDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CADE0: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 826CADE4: 409A0008  bne cr6, 0x826cadec
	if !ctx.cr[6].eq {
	pc = 0x826CADEC; continue 'dispatch;
	}
	// 826CADE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CADEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826CADF0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CADF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CADF8: 4BC238E1  bl 0x822ee6d8
	ctx.lr = 0x826CADFC;
	sub_822EE6D8(ctx, base);
	// 826CADFC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CAE00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CAE04: 419A0008  beq cr6, 0x826cae0c
	if ctx.cr[6].eq {
	pc = 0x826CAE0C; continue 'dispatch;
	}
	// 826CAE08: 4BBF5A89  bl 0x822c0890
	ctx.lr = 0x826CAE0C;
	sub_822C0890(ctx, base);
	// 826CAE0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CAE10: 4BC1C411  bl 0x822e7220
	ctx.lr = 0x826CAE14;
	sub_822E7220(ctx, base);
	// 826CAE14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAE18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826CAE1C: 48ADD39C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CAE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CAE20 size=176
    let mut pc: u32 = 0x826CAE20;
    'dispatch: loop {
        match pc {
            0x826CAE20 => {
    //   block [0x826CAE20..0x826CAED0)
	// 826CAE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CAE24: 48ADD349  bl 0x831a816c
	ctx.lr = 0x826CAE28;
	sub_831A8130(ctx, base);
	// 826CAE28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAE2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826CAE30: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 826CAE34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CAE38: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 826CAE3C: 4875FCAD  bl 0x82e2aae8
	ctx.lr = 0x826CAE40;
	sub_82E2AAE8(ctx, base);
	// 826CAE40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CAE44: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CAE48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826CAE4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CAE50: 48764021  bl 0x82e2ee70
	ctx.lr = 0x826CAE54;
	sub_82E2EE70(ctx, base);
	// 826CAE54: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CAE58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CAE5C: 388B86E0  addi r4, r11, -0x7920
	ctx.r[4].s64 = ctx.r[11].s64 + -31008;
	// 826CAE60: 38A00029  li r5, 0x29
	ctx.r[5].s64 = 41;
	// 826CAE64: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826CAE68: 48727581  bl 0x82df23e8
	ctx.lr = 0x826CAE6C;
	sub_82DF23E8(ctx, base);
	// 826CAE6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CAE70: 41820014  beq 0x826cae84
	if ctx.cr[0].eq {
	pc = 0x826CAE84; continue 'dispatch;
	}
	// 826CAE74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CAE78: 4874BA19  bl 0x82e16890
	ctx.lr = 0x826CAE7C;
	sub_82E16890(ctx, base);
	// 826CAE7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CAE80: 48000008  b 0x826cae88
	pc = 0x826CAE88; continue 'dispatch;
	// 826CAE84: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CAE88: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CAE8C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826CAE90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAE94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAE98: 4BC8E221  bl 0x823590b8
	ctx.lr = 0x826CAE9C;
	sub_823590B8(ctx, base);
	// 826CAE9C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CAEA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CAEA8: 4BBF5159  bl 0x822c0000
	ctx.lr = 0x826CAEAC;
	sub_822C0000(ctx, base);
	// 826CAEAC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CAEB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CAEB4: 419A0008  beq cr6, 0x826caebc
	if ctx.cr[6].eq {
	pc = 0x826CAEBC; continue 'dispatch;
	}
	// 826CAEB8: 4BBF59D9  bl 0x822c0890
	ctx.lr = 0x826CAEBC;
	sub_822C0890(ctx, base);
	// 826CAEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CAEC0: 4875FC41  bl 0x82e2ab00
	ctx.lr = 0x826CAEC4;
	sub_82E2AB00(ctx, base);
	// 826CAEC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CAEC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CAECC: 48ADD2F0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CAED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CAED0 size=196
    let mut pc: u32 = 0x826CAED0;
    'dispatch: loop {
        match pc {
            0x826CAED0 => {
    //   block [0x826CAED0..0x826CAF94)
	// 826CAED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CAED4: 48ADD289  bl 0x831a815c
	ctx.lr = 0x826CAED8;
	sub_831A8130(ctx, base);
	// 826CAED8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAEDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826CAEE0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CAEE4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826CAEE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826CAEEC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826CAEF0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 826CAEF4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 826CAEF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CAEFC: 388B86E0  addi r4, r11, -0x7920
	ctx.r[4].s64 = ctx.r[11].s64 + -31008;
	// 826CAF00: 38A0003E  li r5, 0x3e
	ctx.r[5].s64 = 62;
	// 826CAF04: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 826CAF08: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 826CAF0C: 487274DD  bl 0x82df23e8
	ctx.lr = 0x826CAF10;
	sub_82DF23E8(ctx, base);
	// 826CAF10: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826CAF14: 4182002C  beq 0x826caf40
	if ctx.cr[0].eq {
	pc = 0x826CAF40; continue 'dispatch;
	}
	// 826CAF18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826CAF1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CAF20: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826CAF24: 4BE445A5  bl 0x8250f4c8
	ctx.lr = 0x826CAF28;
	sub_8250F4C8(ctx, base);
	// 826CAF28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CAF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CAF30: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826CAF34: 484E8CCD  bl 0x82bb3c00
	ctx.lr = 0x826CAF38;
	sub_82BB3C00(ctx, base);
	// 826CAF38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CAF3C: 48000008  b 0x826caf44
	pc = 0x826CAF44; continue 'dispatch;
	// 826CAF40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CAF44: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CAF48: 3B9D0004  addi r28, r29, 4
	ctx.r[28].s64 = ctx.r[29].s64 + 4;
	// 826CAF4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAF50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CAF54: 4BC8E22D  bl 0x82359180
	ctx.lr = 0x826CAF58;
	sub_82359180(ctx, base);
	// 826CAF58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CAF5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CAF60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CAF64: 4BBF509D  bl 0x822c0000
	ctx.lr = 0x826CAF68;
	sub_822C0000(ctx, base);
	// 826CAF68: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CAF6C: 4182000C  beq 0x826caf78
	if ctx.cr[0].eq {
	pc = 0x826CAF78; continue 'dispatch;
	}
	// 826CAF70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CAF74: 48726D1D  bl 0x82df1c90
	ctx.lr = 0x826CAF78;
	sub_82DF1C90(ctx, base);
	// 826CAF78: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 826CAF7C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CAF80: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CAF84: 484E9FDD  bl 0x82bb4f60
	ctx.lr = 0x826CAF88;
	sub_82BB4F60(ctx, base);
	// 826CAF88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CAF8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826CAF90: 48ADD21C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CAF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CAF98 size=208
    let mut pc: u32 = 0x826CAF98;
    'dispatch: loop {
        match pc {
            0x826CAF98 => {
    //   block [0x826CAF98..0x826CB068)
	// 826CAF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CAF9C: 48ADD1CD  bl 0x831a8168
	ctx.lr = 0x826CAFA0;
	sub_831A8130(ctx, base);
	// 826CAFA0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 826CAFA4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CAFA8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826CAFAC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CAFB0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CAFB4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CAFB8: 419A00A4  beq cr6, 0x826cb05c
	if ctx.cr[6].eq {
	pc = 0x826CB05C; continue 'dispatch;
	}
	// 826CAFBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CAFC0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CAFC4: 3BA30028  addi r29, r3, 0x28
	ctx.r[29].s64 = ctx.r[3].s64 + 40;
	// 826CAFC8: 3BCB86E0  addi r30, r11, -0x7920
	ctx.r[30].s64 = ctx.r[11].s64 + -31008;
	// 826CAFCC: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CAFD0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CAFD4: 4BD08935  bl 0x823d3908
	ctx.lr = 0x826CAFD8;
	sub_823D3908(ctx, base);
	// 826CAFD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CAFDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826CAFE0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CAFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CAFE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CAFEC: 419A0024  beq cr6, 0x826cb010
	if ctx.cr[6].eq {
	pc = 0x826CB010; continue 'dispatch;
	}
	// 826CAFF0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CAFF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CAFF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CAFFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB000: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB004: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB008: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB00C: 4082FFE8  bne 0x826caff4
	if !ctx.cr[0].eq {
	pc = 0x826CAFF4; continue 'dispatch;
	}
	// 826CB010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB014: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826CB018: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826CB01C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CB020: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 826CB024: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CB028: 4878DA19  bl 0x82e58a40
	ctx.lr = 0x826CB02C;
	sub_82E58A40(ctx, base);
	// 826CB02C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CB030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB034: 419A0008  beq cr6, 0x826cb03c
	if ctx.cr[6].eq {
	pc = 0x826CB03C; continue 'dispatch;
	}
	// 826CB038: 4BBF5859  bl 0x822c0890
	ctx.lr = 0x826CB03C;
	sub_822C0890(ctx, base);
	// 826CB03C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CB040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB044: 419A0008  beq cr6, 0x826cb04c
	if ctx.cr[6].eq {
	pc = 0x826CB04C; continue 'dispatch;
	}
	// 826CB048: 4BBF5849  bl 0x822c0890
	ctx.lr = 0x826CB04C;
	sub_822C0890(ctx, base);
	// 826CB04C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB050: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB054: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CB058: 409AFF78  bne cr6, 0x826cafd0
	if !ctx.cr[6].eq {
	pc = 0x826CAFD0; continue 'dispatch;
	}
	// 826CB05C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826CB060: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826CB064: 48ADD154  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CB068 size=688
    let mut pc: u32 = 0x826CB068;
    'dispatch: loop {
        match pc {
            0x826CB068 => {
    //   block [0x826CB068..0x826CB318)
	// 826CB068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB06C: 48ADD0F9  bl 0x831a8164
	ctx.lr = 0x826CB070;
	sub_831A8130(ctx, base);
	// 826CB070: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826CB074: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CB078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CB07C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CB080: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826CB084: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CB088: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB08C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CB090: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826CB094: 4BE44435  bl 0x8250f4c8
	ctx.lr = 0x826CB098;
	sub_8250F4C8(ctx, base);
	// 826CB098: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB09C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB0A0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 826CB0A4: 409A0008  bne cr6, 0x826cb0ac
	if !ctx.cr[6].eq {
	pc = 0x826CB0AC; continue 'dispatch;
	}
	// 826CB0A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CB0AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CB0B0: 4BE3F589  bl 0x8250a638
	ctx.lr = 0x826CB0B4;
	sub_8250A638(ctx, base);
	// 826CB0B4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CB0B8: 48726BD9  bl 0x82df1c90
	ctx.lr = 0x826CB0BC;
	sub_82DF1C90(ctx, base);
	// 826CB0BC: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826CB0C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 826CB0C4: 419A0230  beq cr6, 0x826cb2f4
	if ctx.cr[6].eq {
	pc = 0x826CB2F4; continue 'dispatch;
	}
	// 826CB0C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CB0CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CB0D0: 480F5F39  bl 0x827c1008
	ctx.lr = 0x826CB0D4;
	sub_827C1008(ctx, base);
	// 826CB0D4: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB0D8: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB0DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826CB0E0: 419A0024  beq cr6, 0x826cb104
	if ctx.cr[6].eq {
	pc = 0x826CB104; continue 'dispatch;
	}
	// 826CB0E4: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826CB0E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CB0EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB0F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB0F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB0F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB0FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB100: 4082FFE8  bne 0x826cb0e8
	if !ctx.cr[0].eq {
	pc = 0x826CB0E8; continue 'dispatch;
	}
	// 826CB104: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826CB108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB10C: 419A0008  beq cr6, 0x826cb114
	if ctx.cr[6].eq {
	pc = 0x826CB114; continue 'dispatch;
	}
	// 826CB110: 4BBF5781  bl 0x822c0890
	ctx.lr = 0x826CB114;
	sub_822C0890(ctx, base);
	// 826CB114: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CB118: 419A01CC  beq cr6, 0x826cb2e4
	if ctx.cr[6].eq {
	pc = 0x826CB2E4; continue 'dispatch;
	}
	// 826CB11C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826CB120: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826CB124: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 826CB128: 419A0024  beq cr6, 0x826cb14c
	if ctx.cr[6].eq {
	pc = 0x826CB14C; continue 'dispatch;
	}
	// 826CB12C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826CB130: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CB134: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB138: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB13C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB140: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB144: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB148: 4082FFE8  bne 0x826cb130
	if !ctx.cr[0].eq {
	pc = 0x826CB130; continue 'dispatch;
	}
	// 826CB14C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB150: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CB154: 4BE44375  bl 0x8250f4c8
	ctx.lr = 0x826CB158;
	sub_8250F4C8(ctx, base);
	// 826CB158: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB15C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB160: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 826CB164: 409A0008  bne cr6, 0x826cb16c
	if !ctx.cr[6].eq {
	pc = 0x826CB16C; continue 'dispatch;
	}
	// 826CB168: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CB16C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB170: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826CB174: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 826CB178: 4BE443A1  bl 0x8250f518
	ctx.lr = 0x826CB17C;
	sub_8250F518(ctx, base);
	// 826CB17C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CB180: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CB184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB188: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 826CB18C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826CB190: 4BE42401  bl 0x8250d590
	ctx.lr = 0x826CB194;
	sub_8250D590(ctx, base);
	// 826CB194: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CB198: 48726AF9  bl 0x82df1c90
	ctx.lr = 0x826CB19C;
	sub_82DF1C90(ctx, base);
	// 826CB19C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826CB1A0: 48726AF1  bl 0x82df1c90
	ctx.lr = 0x826CB1A4;
	sub_82DF1C90(ctx, base);
	// 826CB1A4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CB1A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CB1AC: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 826CB1B0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826CB1B4: 487B0B15  bl 0x82e7bcc8
	ctx.lr = 0x826CB1B8;
	sub_82E7BCC8(ctx, base);
	// 826CB1B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CB1BC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826CB1C0: 487B1C49  bl 0x82e7ce08
	ctx.lr = 0x826CB1C4;
	sub_82E7CE08(ctx, base);
	// 826CB1C4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826CB1C8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826CB1CC: 4BCA990D  bl 0x82374ad8
	ctx.lr = 0x826CB1D0;
	sub_82374AD8(ctx, base);
	// 826CB1D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB1D4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826CB1D8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB1E0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826CB1E4: 419A0024  beq cr6, 0x826cb208
	if ctx.cr[6].eq {
	pc = 0x826CB208; continue 'dispatch;
	}
	// 826CB1E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CB1EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CB1F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB1F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB1F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB1FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB200: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB204: 4082FFE8  bne 0x826cb1ec
	if !ctx.cr[0].eq {
	pc = 0x826CB1EC; continue 'dispatch;
	}
	// 826CB208: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CB20C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CB210: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CB214: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 826CB218: 3BCB86E0  addi r30, r11, -0x7920
	ctx.r[30].s64 = ctx.r[11].s64 + -31008;
	// 826CB21C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 826CB220: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB224: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CB228: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 826CB22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB230: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CB234: 4878D80D  bl 0x82e58a40
	ctx.lr = 0x826CB238;
	sub_82E58A40(ctx, base);
	// 826CB238: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826CB23C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB240: 419A0008  beq cr6, 0x826cb248
	if ctx.cr[6].eq {
	pc = 0x826CB248; continue 'dispatch;
	}
	// 826CB244: 4BBF564D  bl 0x822c0890
	ctx.lr = 0x826CB248;
	sub_822C0890(ctx, base);
	// 826CB248: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826CB24C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB250: 419A0008  beq cr6, 0x826cb258
	if ctx.cr[6].eq {
	pc = 0x826CB258; continue 'dispatch;
	}
	// 826CB254: 4BBF563D  bl 0x822c0890
	ctx.lr = 0x826CB258;
	sub_822C0890(ctx, base);
	// 826CB258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826CB25C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826CB260: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826CB264: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826CB268: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826CB26C: 4BED0D25  bl 0x8259bf90
	ctx.lr = 0x826CB270;
	sub_8259BF90(ctx, base);
	// 826CB270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB274: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826CB278: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB27C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB280: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 826CB284: 419A0024  beq cr6, 0x826cb2a8
	if ctx.cr[6].eq {
	pc = 0x826CB2A8; continue 'dispatch;
	}
	// 826CB288: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CB28C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CB290: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB294: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB298: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB29C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB2A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB2A4: 4082FFE8  bne 0x826cb28c
	if !ctx.cr[0].eq {
	pc = 0x826CB28C; continue 'dispatch;
	}
	// 826CB2A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB2AC: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CB2B0: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 826CB2B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CB2B8: 38A0007A  li r5, 0x7a
	ctx.r[5].s64 = 122;
	// 826CB2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB2C0: 4878D781  bl 0x82e58a40
	ctx.lr = 0x826CB2C4;
	sub_82E58A40(ctx, base);
	// 826CB2C4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826CB2C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB2CC: 419A0008  beq cr6, 0x826cb2d4
	if ctx.cr[6].eq {
	pc = 0x826CB2D4; continue 'dispatch;
	}
	// 826CB2D0: 4BBF55C1  bl 0x822c0890
	ctx.lr = 0x826CB2D4;
	sub_822C0890(ctx, base);
	// 826CB2D4: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826CB2D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB2DC: 419A0008  beq cr6, 0x826cb2e4
	if ctx.cr[6].eq {
	pc = 0x826CB2E4; continue 'dispatch;
	}
	// 826CB2E0: 4BBF55B1  bl 0x822c0890
	ctx.lr = 0x826CB2E4;
	sub_822C0890(ctx, base);
	// 826CB2E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826CB2E8: 419A000C  beq cr6, 0x826cb2f4
	if ctx.cr[6].eq {
	pc = 0x826CB2F4; continue 'dispatch;
	}
	// 826CB2EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CB2F0: 4BBF55A1  bl 0x822c0890
	ctx.lr = 0x826CB2F4;
	sub_822C0890(ctx, base);
	// 826CB2F4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826CB2F8: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CB2FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB300: 419A0008  beq cr6, 0x826cb308
	if ctx.cr[6].eq {
	pc = 0x826CB308; continue 'dispatch;
	}
	// 826CB304: 4BBF558D  bl 0x822c0890
	ctx.lr = 0x826CB308;
	sub_822C0890(ctx, base);
	// 826CB308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB30C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826CB310: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826CB314: 48ADCEA0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CB318 size=100
    let mut pc: u32 = 0x826CB318;
    'dispatch: loop {
        match pc {
            0x826CB318 => {
    //   block [0x826CB318..0x826CB37C)
	// 826CB318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB31C: 48ADCE49  bl 0x831a8164
	ctx.lr = 0x826CB320;
	sub_831A8130(ctx, base);
	// 826CB320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CB324: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826CB328: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CB32C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 826CB330: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826CB334: 48000038  b 0x826cb36c
	pc = 0x826CB36C; continue 'dispatch;
	// 826CB338: 38DF0008  addi r6, r31, 8
	ctx.r[6].s64 = ctx.r[31].s64 + 8;
	// 826CB33C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB340: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB344: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CB348: 4BE8E9B9  bl 0x82559d00
	ctx.lr = 0x826CB34C;
	sub_82559D00(ctx, base);
	// 826CB34C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826CB350: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CB354: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CB358: 484FEAA1  bl 0x82bc9df8
	ctx.lr = 0x826CB35C;
	sub_82BC9DF8(ctx, base);
	// 826CB35C: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 826CB360: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB364: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 826CB368: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB36C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 826CB370: 409AFFC8  bne cr6, 0x826cb338
	if !ctx.cr[6].eq {
	pc = 0x826CB338; continue 'dispatch;
	}
	// 826CB374: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CB378: 48ADCE3C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CB380 size=100
    let mut pc: u32 = 0x826CB380;
    'dispatch: loop {
        match pc {
            0x826CB380 => {
    //   block [0x826CB380..0x826CB3E4)
	// 826CB380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CB388: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CB38C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CB390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CB394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CB398: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CB39C: 4BD9B13D  bl 0x824664d8
	ctx.lr = 0x826CB3A0;
	sub_824664D8(ctx, base);
	// 826CB3A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CB3A4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CB3A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826CB3AC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826CB3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB3B4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826CB3B8: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB3BC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB3C0: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB3C4: 4BFFFF55  bl 0x826cb318
	ctx.lr = 0x826CB3C8;
	sub_826CB318(ctx, base);
	// 826CB3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB3CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CB3D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CB3D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CB3D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CB3DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CB3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CB3E8 size=628
    let mut pc: u32 = 0x826CB3E8;
    'dispatch: loop {
        match pc {
            0x826CB3E8 => {
    //   block [0x826CB3E8..0x826CB65C)
	// 826CB3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB3EC: 48ADCD59  bl 0x831a8144
	ctx.lr = 0x826CB3F0;
	sub_831A8130(ctx, base);
	// 826CB3F0: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 826CB3F4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CB3F8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 826CB3FC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CB400: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 826CB404: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 826CB408: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 826CB40C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 826CB410: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 826CB414: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 826CB418: 4BD9B0C1  bl 0x824664d8
	ctx.lr = 0x826CB41C;
	sub_824664D8(ctx, base);
	// 826CB41C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CB420: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 826CB424: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CB428: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 826CB42C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826CB430: 92C10090  stw r22, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 826CB434: 4BC0694D  bl 0x822d1d80
	ctx.lr = 0x826CB438;
	sub_822D1D80(ctx, base);
	// 826CB438: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CB43C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826CB440: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826CB444: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CB448: 4BC06AC1  bl 0x822d1f08
	ctx.lr = 0x826CB44C;
	sub_822D1F08(ctx, base);
	// 826CB44C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826CB450: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB454: 409A0014  bne cr6, 0x826cb468
	if !ctx.cr[6].eq {
	pc = 0x826CB468; continue 'dispatch;
	}
	// 826CB458: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826CB45C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826CB460: 4BFFFF21  bl 0x826cb380
	ctx.lr = 0x826CB464;
	sub_826CB380(ctx, base);
	// 826CB464: 480001B8  b 0x826cb61c
	pc = 0x826CB61C; continue 'dispatch;
	// 826CB468: 48733379  bl 0x82dfe7e0
	ctx.lr = 0x826CB46C;
	sub_82DFE7E0(ctx, base);
	// 826CB46C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CB470: 546A063F  clrlwi. r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826CB474: 3AAB86E0  addi r21, r11, -0x7920
	ctx.r[21].s64 = ctx.r[11].s64 + -31008;
	// 826CB478: 40820060  bne 0x826cb4d8
	if !ctx.cr[0].eq {
	pc = 0x826CB4D8; continue 'dispatch;
	}
	// 826CB47C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CB480: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826CB484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB488: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 826CB48C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826CB490: 419A0024  beq cr6, 0x826cb4b4
	if ctx.cr[6].eq {
	pc = 0x826CB4B4; continue 'dispatch;
	}
	// 826CB494: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CB498: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CB49C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB4A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB4A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB4A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB4AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB4B0: 4082FFE8  bne 0x826cb498
	if !ctx.cr[0].eq {
	pc = 0x826CB498; continue 'dispatch;
	}
	// 826CB4B4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CB4B8: 4BE1F5D1  bl 0x824eaa88
	ctx.lr = 0x826CB4BC;
	sub_824EAA88(ctx, base);
	// 826CB4BC: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 826CB4C0: 38C00051  li r6, 0x51
	ctx.r[6].s64 = 81;
	// 826CB4C4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB4C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CB4CC: 484EECB5  bl 0x82bba180
	ctx.lr = 0x826CB4D0;
	sub_82BBA180(ctx, base);
	// 826CB4D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CB4D4: 487267BD  bl 0x82df1c90
	ctx.lr = 0x826CB4D8;
	sub_82DF1C90(ctx, base);
	// 826CB4D8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826CB4DC: 4BC03F0D  bl 0x822cf3e8
	ctx.lr = 0x826CB4E0;
	sub_822CF3E8(ctx, base);
	// 826CB4E0: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 826CB4E4: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 826CB4E8: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826CB4EC: 7EDFB378  mr r31, r22
	ctx.r[31].u64 = ctx.r[22].u64;
	// 826CB4F0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826CB4F4: 4182010C  beq 0x826cb600
	if ctx.cr[0].eq {
	pc = 0x826CB600; continue 'dispatch;
	}
	// 826CB4F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CB4FC: 3F408335  lis r26, -0x7ccb
	ctx.r[26].s64 = -2093678592;
	// 826CB500: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CB504: 48000008  b 0x826cb50c
	pc = 0x826CB50C; continue 'dispatch;
	// 826CB508: 83C1008C  lwz r30, 0x8c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826CB50C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826CB510: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CB514: 38A00056  li r5, 0x56
	ctx.r[5].s64 = 86;
	// 826CB518: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826CB51C: 48726ECD  bl 0x82df23e8
	ctx.lr = 0x826CB520;
	sub_82DF23E8(ctx, base);
	// 826CB520: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CB524: 41820028  beq 0x826cb54c
	if ctx.cr[0].eq {
	pc = 0x826CB54C; continue 'dispatch;
	}
	// 826CB528: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 826CB52C: 80DA6824  lwz r6, 0x6824(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826CB530: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 826CB534: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CB538: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CB53C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826CB540: 4BC16621  bl 0x822e1b60
	ctx.lr = 0x826CB544;
	sub_822E1B60(ctx, base);
	// 826CB544: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CB548: 48000008  b 0x826cb550
	pc = 0x826CB550; continue 'dispatch;
	// 826CB54C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826CB550: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CB554: 48006F0D  bl 0x826d2460
	ctx.lr = 0x826CB558;
	sub_826D2460(ctx, base);
	// 826CB558: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826CB55C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 826CB560: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826CB564: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CB568: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 826CB56C: 419A0024  beq cr6, 0x826cb590
	if ctx.cr[6].eq {
	pc = 0x826CB590; continue 'dispatch;
	}
	// 826CB570: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826CB574: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CB578: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB57C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CB580: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CB584: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CB588: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CB58C: 4082FFE8  bne 0x826cb574
	if !ctx.cr[0].eq {
	pc = 0x826CB574; continue 'dispatch;
	}
	// 826CB590: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826CB594: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CB598: 3A610070  addi r19, r1, 0x70
	ctx.r[19].s64 = ctx.r[1].s64 + 112;
	// 826CB59C: 4BE43F7D  bl 0x8250f518
	ctx.lr = 0x826CB5A0;
	sub_8250F518(ctx, base);
	// 826CB5A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CB5A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CB5A8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826CB5AC: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 826CB5B0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 826CB5B4: 4BE41FDD  bl 0x8250d590
	ctx.lr = 0x826CB5B8;
	sub_8250D590(ctx, base);
	// 826CB5B8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CB5BC: 487266D5  bl 0x82df1c90
	ctx.lr = 0x826CB5C0;
	sub_82DF1C90(ctx, base);
	// 826CB5C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CB5C4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826CB5C8: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB5CC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CB5D0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 826CB5D4: 4BE8E72D  bl 0x82559d00
	ctx.lr = 0x826CB5D8;
	sub_82559D00(ctx, base);
	// 826CB5D8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 826CB5DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CB5E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CB5E4: 484FE815  bl 0x82bc9df8
	ctx.lr = 0x826CB5E8;
	sub_82BC9DF8(ctx, base);
	// 826CB5E8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826CB5EC: 927E0000  stw r19, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 826CB5F0: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB5F4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 826CB5F8: 926B0000  stw r19, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 826CB5FC: 4198FF0C  blt cr6, 0x826cb508
	if ctx.cr[6].lt {
	pc = 0x826CB508; continue 'dispatch;
	}
	// 826CB600: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826CB604: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826CB608: 4BFFFD79  bl 0x826cb380
	ctx.lr = 0x826CB60C;
	sub_826CB380(ctx, base);
	// 826CB60C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CB610: 419A000C  beq cr6, 0x826cb61c
	if ctx.cr[6].eq {
	pc = 0x826CB61C; continue 'dispatch;
	}
	// 826CB614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CB618: 4BBF5279  bl 0x822c0890
	ctx.lr = 0x826CB61C;
	sub_822C0890(ctx, base);
	// 826CB61C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CB620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB624: 419A0008  beq cr6, 0x826cb62c
	if ctx.cr[6].eq {
	pc = 0x826CB62C; continue 'dispatch;
	}
	// 826CB628: 4BBF5269  bl 0x822c0890
	ctx.lr = 0x826CB62C;
	sub_822C0890(ctx, base);
	// 826CB62C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826CB630: 4BC06769  bl 0x822d1d98
	ctx.lr = 0x826CB634;
	sub_822D1D98(ctx, base);
	// 826CB634: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CB638: 4BD5D049  bl 0x82428680
	ctx.lr = 0x826CB63C;
	sub_82428680(ctx, base);
	// 826CB63C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826CB640: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826CB644: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 826CB648: 48726B41  bl 0x82df2188
	ctx.lr = 0x826CB64C;
	sub_82DF2188(ctx, base);
	// 826CB64C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826CB650: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 826CB654: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 826CB658: 48ADCB3C  b 0x831a8194
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CB660 size=8
    let mut pc: u32 = 0x826CB660;
    'dispatch: loop {
        match pc {
            0x826CB660 => {
    //   block [0x826CB660..0x826CB668)
	// 826CB660: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 826CB664: 4872856C  b 0x82df3bd0
	sub_82DF3BD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CB668 size=168
    let mut pc: u32 = 0x826CB668;
    'dispatch: loop {
        match pc {
            0x826CB668 => {
    //   block [0x826CB668..0x826CB710)
	// 826CB668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB66C: 48ADCAFD  bl 0x831a8168
	ctx.lr = 0x826CB670;
	sub_831A8130(ctx, base);
	// 826CB670: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CB674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CB678: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826CB67C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 826CB680: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB684: 419A0038  beq cr6, 0x826cb6bc
	if ctx.cr[6].eq {
	pc = 0x826CB6BC; continue 'dispatch;
	}
	// 826CB688: 4847B521  bl 0x82b46ba8
	ctx.lr = 0x826CB68C;
	sub_82B46BA8(ctx, base);
	// 826CB68C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 826CB690: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 826CB694: 48727B1D  bl 0x82df31b0
	ctx.lr = 0x826CB698;
	sub_82DF31B0(ctx, base);
	// 826CB698: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CB69C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CB6A0: 4847B221  bl 0x82b468c0
	ctx.lr = 0x826CB6A4;
	sub_82B468C0(ctx, base);
	// 826CB6A4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 826CB6A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CB6AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB6B0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826CB6B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CB6B8: 4E800421  bctrl
	ctx.lr = 0x826CB6BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CB6BC: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826CB6C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826CB6C4: 419A0044  beq cr6, 0x826cb708
	if ctx.cr[6].eq {
	pc = 0x826CB708; continue 'dispatch;
	}
	// 826CB6C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CB6CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CB6D0: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 826CB6D4: 487B0905  bl 0x82e7bfd8
	ctx.lr = 0x826CB6D8;
	sub_82E7BFD8(ctx, base);
	// 826CB6D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826CB6DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CB6E0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB6E4: 4BE43DE5  bl 0x8250f4c8
	ctx.lr = 0x826CB6E8;
	sub_8250F4C8(ctx, base);
	// 826CB6E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CB6EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CB6F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CB6F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826CB6F8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 826CB6FC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826CB700: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CB704: 48103A4D  bl 0x827cf150
	ctx.lr = 0x826CB708;
	sub_827CF150(ctx, base);
	// 826CB708: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826CB70C: 48ADCAAC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CB710 size=360
    let mut pc: u32 = 0x826CB710;
    'dispatch: loop {
        match pc {
            0x826CB710 => {
    //   block [0x826CB710..0x826CB878)
	// 826CB710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB714: 48ADCA39  bl 0x831a814c
	ctx.lr = 0x826CB718;
	sub_831A8130(ctx, base);
	// 826CB718: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CB71C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CB720: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CB724: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826CB728: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 826CB72C: 3B3F0004  addi r25, r31, 4
	ctx.r[25].s64 = ctx.r[31].s64 + 4;
	// 826CB730: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 826CB734: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 826CB738: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 826CB73C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826CB740: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 826CB744: 487279AD  bl 0x82df30f0
	ctx.lr = 0x826CB748;
	sub_82DF30F0(ctx, base);
	// 826CB748: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 826CB74C: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 826CB750: 3ADF0010  addi r22, r31, 0x10
	ctx.r[22].s64 = ctx.r[31].s64 + 16;
	// 826CB754: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 826CB758: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826CB75C: 48727995  bl 0x82df30f0
	ctx.lr = 0x826CB760;
	sub_82DF30F0(ctx, base);
	// 826CB760: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 826CB764: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 826CB768: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CB76C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CB770: 388B8770  addi r4, r11, -0x7890
	ctx.r[4].s64 = ctx.r[11].s64 + -30864;
	// 826CB774: 38A00026  li r5, 0x26
	ctx.r[5].s64 = 38;
	// 826CB778: 386000A8  li r3, 0xa8
	ctx.r[3].s64 = 168;
	// 826CB77C: 3B5F0014  addi r26, r31, 0x14
	ctx.r[26].s64 = ctx.r[31].s64 + 20;
	// 826CB780: 48726C69  bl 0x82df23e8
	ctx.lr = 0x826CB784;
	sub_82DF23E8(ctx, base);
	// 826CB784: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 826CB788: 41820038  beq 0x826cb7c0
	if ctx.cr[0].eq {
	pc = 0x826CB7C0; continue 'dispatch;
	}
	// 826CB78C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826CB790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CB794: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 826CB798: 4BE43D31  bl 0x8250f4c8
	ctx.lr = 0x826CB79C;
	sub_8250F4C8(ctx, base);
	// 826CB79C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB7A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB7A4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 826CB7A8: 409A0008  bne cr6, 0x826cb7b0
	if !ctx.cr[6].eq {
	pc = 0x826CB7B0; continue 'dispatch;
	}
	// 826CB7AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CB7B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826CB7B4: 48104D9D  bl 0x827d0550
	ctx.lr = 0x826CB7B8;
	sub_827D0550(ctx, base);
	// 826CB7B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CB7BC: 48000008  b 0x826cb7c4
	pc = 0x826CB7C4; continue 'dispatch;
	// 826CB7C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CB7C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CB7C8: 4BFA6369  bl 0x82671b30
	ctx.lr = 0x826CB7CC;
	sub_82671B30(ctx, base);
	// 826CB7CC: 570B07FF  clrlwi. r11, r24, 0x1f
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CB7D0: 4182000C  beq 0x826cb7dc
	if ctx.cr[0].eq {
	pc = 0x826CB7DC; continue 'dispatch;
	}
	// 826CB7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CB7D8: 487264B9  bl 0x82df1c90
	ctx.lr = 0x826CB7DC;
	sub_82DF1C90(ctx, base);
	// 826CB7DC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CB7E0: 56EA103A  slwi r10, r23, 2
	ctx.r[10].u32 = ctx.r[23].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CB7E4: 3BCBC9F4  addi r30, r11, -0x360c
	ctx.r[30].s64 = ctx.r[11].s64 + -13836;
	// 826CB7E8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826CB7EC: 7C8AF02E  lwzx r4, r10, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826CB7F0: 48728089  bl 0x82df3878
	ctx.lr = 0x826CB7F4;
	sub_82DF3878(ctx, base);
	// 826CB7F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826CB7F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CB7FC: 4BE43CCD  bl 0x8250f4c8
	ctx.lr = 0x826CB800;
	sub_8250F4C8(ctx, base);
	// 826CB800: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CB808: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 826CB80C: 409A0008  bne cr6, 0x826cb814
	if !ctx.cr[6].eq {
	pc = 0x826CB814; continue 'dispatch;
	}
	// 826CB810: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CB814: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826CB818: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826CB81C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 826CB820: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CB824: 4847B67D  bl 0x82b46ea0
	ctx.lr = 0x826CB828;
	sub_82B46EA0(ctx, base);
	// 826CB828: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CB82C: 387A0004  addi r3, r26, 4
	ctx.r[3].s64 = ctx.r[26].s64 + 4;
	// 826CB830: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826CB834: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB838: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CB83C: 4BBF8C25  bl 0x822c4460
	ctx.lr = 0x826CB840;
	sub_822C4460(ctx, base);
	// 826CB840: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CB844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CB848: 419A0008  beq cr6, 0x826cb850
	if ctx.cr[6].eq {
	pc = 0x826CB850; continue 'dispatch;
	}
	// 826CB84C: 4BBF5045  bl 0x822c0890
	ctx.lr = 0x826CB850;
	sub_822C0890(ctx, base);
	// 826CB850: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CB854: 4872643D  bl 0x82df1c90
	ctx.lr = 0x826CB858;
	sub_82DF1C90(ctx, base);
	// 826CB858: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 826CB85C: 56AA103A  slwi r10, r21, 2
	ctx.r[10].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CB860: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826CB864: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826CB868: 48728011  bl 0x82df3878
	ctx.lr = 0x826CB86C;
	sub_82DF3878(ctx, base);
	// 826CB86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CB870: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826CB874: 48ADC928  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB878 size=8
    let mut pc: u32 = 0x826CB878;
    'dispatch: loop {
        match pc {
            0x826CB878 => {
    //   block [0x826CB878..0x826CB880)
	// 826CB878: D0230010  stfs f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 826CB87C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB880 size=20
    let mut pc: u32 = 0x826CB880;
    'dispatch: loop {
        match pc {
            0x826CB880 => {
    //   block [0x826CB880..0x826CB894)
	// 826CB880: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CB884: C0230010  lfs f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CB888: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CB88C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CB890: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB898 size=84
    let mut pc: u32 = 0x826CB898;
    'dispatch: loop {
        match pc {
            0x826CB898 => {
    //   block [0x826CB898..0x826CB8EC)
	// 826CB898: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 826CB89C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CB8A0: 3CC08206  lis r6, -0x7dfa
	ctx.r[6].s64 = -2113536000;
	// 826CB8A4: 38AB6880  addi r5, r11, 0x6880
	ctx.r[5].s64 = ctx.r[11].s64 + 26752;
	// 826CB8A8: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 826CB8AC: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826CB8B0: C00708A4  lfs f0, 0x8a4(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CB8B4: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826CB8B8: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 826CB8BC: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 826CB8C0: 38E687CC  addi r7, r6, -0x7834
	ctx.r[7].s64 = ctx.r[6].s64 + -30772;
	// 826CB8C4: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 826CB8C8: 13E82C07  vcmpneb. (lvlx128) v31, v8, v5
	tmp.u32 = ctx.r[8].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB8CC: 13C92C07  vcmpneb. (lvlx128) v30, v9, v5
	tmp.u32 = ctx.r[9].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB8D0: 13AA2C07  vcmpneb. (lvlx128) v29, v10, v5
	tmp.u32 = ctx.r[10].u32 + ctx.r[5].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB8D4: 13802C07  vcmpneb. (lvlx128) v28, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB8F0 size=52
    let mut pc: u32 = 0x826CB8F0;
    'dispatch: loop {
        match pc {
            0x826CB8F0 => {
    //   block [0x826CB8F0..0x826CB924)
	// 826CB8F0: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 826CB8F4: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 826CB8F8: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826CB8FC: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826CB900: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB904: 13C85C07  vcmpneb. (lvlx128) v30, v8, v11
	tmp.u32 = ctx.r[8].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB908: 13A95C07  vcmpneb. (lvlx128) v29, v9, v11
	tmp.u32 = ctx.r[9].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB90C: 138A5C07  vcmpneb. (lvlx128) v28, v10, v11
	tmp.u32 = ctx.r[10].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB928 size=52
    let mut pc: u32 = 0x826CB928;
    'dispatch: loop {
        match pc {
            0x826CB928 => {
    //   block [0x826CB928..0x826CB95C)
	// 826CB928: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 826CB92C: 13E02407  vcmpneb. (lvlx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB930: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826CB934: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826CB938: 39630020  addi r11, r3, 0x20
	ctx.r[11].s64 = ctx.r[3].s64 + 32;
	// 826CB93C: 13C82407  vcmpneb. (lvlx128) v30, v8, v4
	tmp.u32 = ctx.r[8].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB940: 13A92407  vcmpneb. (lvlx128) v29, v9, v4
	tmp.u32 = ctx.r[9].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CB944: 138A2407  vcmpneb. (lvlx128) v28, v10, v4
	tmp.u32 = ctx.r[10].u32 + ctx.r[4].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB960 size=20
    let mut pc: u32 = 0x826CB960;
    'dispatch: loop {
        match pc {
            0x826CB960 => {
    //   block [0x826CB960..0x826CB974)
	// 826CB960: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CB964: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 826CB968: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CB96C: FF020800  fcmpu cr6, f2, f1
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[1].f64);
	// 826CB970: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB974(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CB974 size=8
    let mut pc: u32 = 0x826CB974;
    'dispatch: loop {
        match pc {
            0x826CB974 => {
    //   block [0x826CB974..0x826CB97C)
	// 826CB974: FF030800  fcmpu cr6, f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[1].f64);
	// 826CB978: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB97C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB97C size=72
    let mut pc: u32 = 0x826CB97C;
    'dispatch: loop {
        match pc {
            0x826CB97C => {
    //   block [0x826CB97C..0x826CB9C4)
	// 826CB97C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CB980: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CB984: EC030032  fmuls f0, f3, f0
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CB988: ED80202A  fadds f12, f0, f4
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64;
	// 826CB98C: ED6D6024  fdivs f11, f13, f12
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 826CB990: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 826CB994: D961FFF0  stfd f11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[11].u64 ) };
	// 826CB998: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 826CB99C: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 826CB9A0: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 826CB9A4: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CB9A8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 826CB9AC: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 826CB9B0: EDAB6B3C  fnmsubs f13, f11, f12, f13
	ctx.f[13].f64 = -(((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 826CB9B4: FF0D2000  fcmpu cr6, f13, f4
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[4].f64);
	// 826CB9B8: 4098000C  bge cr6, 0x826cb9c4
	if !ctx.cr[6].lt {
		sub_826CB9C4(ctx, base);
		return;
	}
	// 826CB9BC: FC201050  fneg f1, f2
	ctx.f[1].u64 = ctx.f[2].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CB9C0: 4800001C  b 0x826cb9dc
	sub_826CB9C4(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB9C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CB9C4 size=32
    let mut pc: u32 = 0x826CB9C4;
    'dispatch: loop {
        match pc {
            0x826CB9C4 => {
    //   block [0x826CB9C4..0x826CB9E4)
	// 826CB9C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826CB9C8: ED8D2028  fsubs f12, f13, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 826CB9CC: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CB9D0: EDA20372  fmuls f13, f2, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 826CB9D4: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 826CB9D8: EC201338  fmsubs f1, f0, f12, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[2].f64) as f32) as f64);
	// 826CB9DC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CB9E0: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB9E4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CB9E4 size=8
    let mut pc: u32 = 0x826CB9E4;
    'dispatch: loop {
        match pc {
            0x826CB9E4 => {
    //   block [0x826CB9E4..0x826CB9EC)
	// 826CB9E4: FC200850  fneg f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CB9E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CB9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CB9F0 size=240
    let mut pc: u32 = 0x826CB9F0;
    'dispatch: loop {
        match pc {
            0x826CB9F0 => {
    //   block [0x826CB9F0..0x826CBAE0)
	// 826CB9F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CB9F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CB9F8: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 826CB9FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CBA00: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 826CBA04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CBA08: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CBA0C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 826CBA10: 419A00B8  beq cr6, 0x826cbac8
	if ctx.cr[6].eq {
	pc = 0x826CBAC8; continue 'dispatch;
	}
	// 826CBA14: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 826CBA18: 419A00B0  beq cr6, 0x826cbac8
	if ctx.cr[6].eq {
	pc = 0x826CBAC8; continue 'dispatch;
	}
	// 826CBA1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CBA20: C1AB9450  lfs f13, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CBA24: EC030372  fmuls f0, f3, f13
	ctx.f[0].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 826CBA28: ED80202A  fadds f12, f0, f4
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64;
	// 826CBA2C: EDA00B7A  fmadds f13, f0, f13, f1
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 826CBA30: ED6D6024  fdivs f11, f13, f12
	ctx.f[11].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 826CBA34: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 826CBA38: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 826CBA3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CBA40: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 826CBA44: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 826CBA48: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CBA4C: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826CBA50: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 826CBA54: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 826CBA58: EDAB6B3C  fnmsubs f13, f11, f12, f13
	ctx.f[13].f64 = -(((ctx.f[11].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 826CBA5C: FF0D2000  fcmpu cr6, f13, f4
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[4].f64);
	// 826CBA60: 40980018  bge cr6, 0x826cba78
	if !ctx.cr[6].lt {
	pc = 0x826CBA78; continue 'dispatch;
	}
	// 826CBA64: 4082000C  bne 0x826cba70
	if !ctx.cr[0].eq {
	pc = 0x826CBA70; continue 'dispatch;
	}
	// 826CBA68: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CBA6C: 48000060  b 0x826cbacc
	pc = 0x826CBACC; continue 'dispatch;
	// 826CBA70: FC20F850  fneg f1, f31
	ctx.f[1].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CBA74: 48000058  b 0x826cbacc
	pc = 0x826CBACC; continue 'dispatch;
	// 826CBA78: EDAD2028  fsubs f13, f13, f4
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[4].f64) as f32) as f64);
	// 826CBA7C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826CBA80: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826CBA84: 4082001C  bne 0x826cbaa0
	if !ctx.cr[0].eq {
	pc = 0x826CBAA0; continue 'dispatch;
	}
	// 826CBA88: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CBA8C: C18A9524  lfs f12, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826CBA90: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 826CBA94: EC001824  fdivs f0, f0, f3
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[3].f64) as f32) as f64;
	// 826CBA98: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826CBA9C: 4800001C  b 0x826cbab8
	pc = 0x826CBAB8; continue 'dispatch;
	// 826CBAA0: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 826CBAA4: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CBAA8: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CBAAC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826CBAB0: EC001824  fdivs f0, f0, f3
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[3].f64) as f32) as f64;
	// 826CBAB4: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 826CBAB8: 48ADD3F1  bl 0x831a8ea8
	ctx.lr = 0x826CBABC;
	sub_831A8EA8(ctx, base);
	// 826CBABC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CBAC0: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CBAC4: 48000008  b 0x826cbacc
	pc = 0x826CBACC; continue 'dispatch;
	// 826CBAC8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 826CBACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CBAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CBAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CBAD8: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CBADC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CBAE0 size=208
    let mut pc: u32 = 0x826CBAE0;
    'dispatch: loop {
        match pc {
            0x826CBAE0 => {
    //   block [0x826CBAE0..0x826CBBB0)
	// 826CBAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CBAE4: 48ADC689  bl 0x831a816c
	ctx.lr = 0x826CBAE8;
	sub_831A8130(ctx, base);
	// 826CBAE8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 826CBAEC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826CBAF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CBAF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CBAF8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CBAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CBB00: FF031000  fcmpu cr6, f3, f2
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[2].f64);
	// 826CBB04: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CBB08: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826CBB0C: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CBB10: 4199000C  bgt cr6, 0x826cbb1c
	if ctx.cr[6].gt {
	pc = 0x826CBB1C; continue 'dispatch;
	}
	// 826CBB14: EFE21828  fsubs f31, f2, f3
	ctx.f[31].f64 = (((ctx.f[2].f64 - ctx.f[3].f64) as f32) as f64);
	// 826CBB18: 4800002C  b 0x826cbb44
	pc = 0x826CBB44; continue 'dispatch;
	// 826CBB1C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CBB20: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 826CBB24: C84BE3A0  lfd f2, -0x1c60(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-7264 as u32) ) };
	// 826CBB28: 48ADECE9  bl 0x831aa810
	ctx.lr = 0x826CBB2C;
	sub_831AA810(ctx, base);
	// 826CBB2C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CBB30: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 826CBB34: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 826CBB38: 41980008  blt cr6, 0x826cbb40
	if ctx.cr[6].lt {
	pc = 0x826CBB40; continue 'dispatch;
	}
	// 826CBB3C: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 826CBB40: FFFFF7EE  fsel f31, f31, f31, f30
	ctx.f[31].f64 = if ctx.f[31].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[30].f64 };
	// 826CBB44: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CBB48: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CBB4C: 48ADD27D  bl 0x831a8dc8
	ctx.lr = 0x826CBB50;
	sub_831A8DC8(ctx, base);
	// 826CBB50: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CBB54: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CBB58: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826CBB5C: EC2C07F2  fmuls f1, f12, f31
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CBB60: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CBB64: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 826CBB68: 48ADD261  bl 0x831a8dc8
	ctx.lr = 0x826CBB6C;
	sub_831A8DC8(ctx, base);
	// 826CBB6C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CBB70: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CBB74: C19D0008  lfs f12, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826CBB78: EC2C07F2  fmuls f1, f12, f31
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CBB7C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CBB80: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 826CBB84: 48ADD245  bl 0x831a8dc8
	ctx.lr = 0x826CBB88;
	sub_831A8DC8(ctx, base);
	// 826CBB88: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CBB8C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CBB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CBB94: D3DF000C  stfs f30, 0xc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 826CBB98: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CBB9C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 826CBBA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CBBA4: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826CBBA8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826CBBAC: 48ADC610  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CBBB0 size=404
    let mut pc: u32 = 0x826CBBB0;
    'dispatch: loop {
        match pc {
            0x826CBBB0 => {
    //   block [0x826CBBB0..0x826CBD44)
	// 826CBBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CBBB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CBBB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CBBBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CBBC0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826CBBC4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826CBBC8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CBBCC: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CBD48 size=104
    let mut pc: u32 = 0x826CBD48;
    'dispatch: loop {
        match pc {
            0x826CBD48 => {
    //   block [0x826CBD48..0x826CBDB0)
	// 826CBD48: 13A018C7  vcmpequd (lvx128) v29, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x826CBDB0 size=84
    let mut pc: u32 = 0x826CBDB0;
    'dispatch: loop {
        match pc {
            0x826CBDB0 => {
    //   block [0x826CBDB0..0x826CBE04)
	// 826CBDB0: 138028C7  vcmpequd (lvx128) v28, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CBDB4: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CBE08 size=104
    let mut pc: u32 = 0x826CBE08;
    'dispatch: loop {
        match pc {
            0x826CBE08 => {
    //   block [0x826CBE08..0x826CBE70)
	// 826CBE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CBE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CBE10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CBE14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CBE18: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 826CBE1C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 826CBE20: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 826CBE24: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 826CBE28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CBE2C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 826CBE30: 4BFFFF19  bl 0x826cbd48
	ctx.lr = 0x826CBE34;
	sub_826CBD48(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CBE70 size=4
    let mut pc: u32 = 0x826CBE70;
    'dispatch: loop {
        match pc {
            0x826CBE70 => {
    //   block [0x826CBE70..0x826CBE74)
	// 826CBE70: 4BE47E40  b 0x82513cb0
	sub_82513CB0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CBE78 size=76
    let mut pc: u32 = 0x826CBE78;
    'dispatch: loop {
        match pc {
            0x826CBE78 => {
    //   block [0x826CBE78..0x826CBEC4)
	// 826CBE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CBE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CBE80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CBE84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CBE88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CBE8C: C0240000  lfs f1, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CBE90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CBE94: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 826CBE98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CBE9C: 4E800421  bctrl
	ctx.lr = 0x826CBEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CBEA0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CBEA4: 4182000C  beq 0x826cbeb0
	if ctx.cr[0].eq {
	pc = 0x826CBEB0; continue 'dispatch;
	}
	// 826CBEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CBEAC: 4BE44725  bl 0x825105d0
	ctx.lr = 0x826CBEB0;
	sub_825105D0(ctx, base);
	// 826CBEB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CBEB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CBEB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CBEBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CBEC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CBEC8 size=164
    let mut pc: u32 = 0x826CBEC8;
    'dispatch: loop {
        match pc {
            0x826CBEC8 => {
    //   block [0x826CBEC8..0x826CBF6C)
	// 826CBEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CBECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CBED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CBED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CBED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CBEDC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826CBEE0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826CBEE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CBEE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CBEEC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826CBEF0: 4BE47BF1  bl 0x82513ae0
	ctx.lr = 0x826CBEF4;
	sub_82513AE0(ctx, base);
	// 826CBEF4: 3CE08206  lis r7, -0x7dfa
	ctx.r[7].s64 = -2113536000;
	// 826CBEF8: 3CC08206  lis r6, -0x7dfa
	ctx.r[6].s64 = -2113536000;
	// 826CBEFC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 826CBF00: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 826CBF04: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826CBF08: 397F0160  addi r11, r31, 0x160
	ctx.r[11].s64 = ctx.r[31].s64 + 352;
	// 826CBF0C: 38E787F4  addi r7, r7, -0x780c
	ctx.r[7].s64 = ctx.r[7].s64 + -30732;
	// 826CBF10: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 826CBF14: 38C687E0  addi r6, r6, -0x7820
	ctx.r[6].s64 = ctx.r[6].s64 + -30752;
	// 826CBF18: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 826CBF1C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826CBF20: 90DF0028  stw r6, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[6].u32 ) };
	// 826CBF24: 13E8F407  vcmpneb. (lvlx128) v31, v8, v30
	tmp.u32 = ctx.r[8].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CBF28: 13C9F407  vcmpneb. (lvlx128) v30, v9, v30
	tmp.u32 = ctx.r[9].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CBF2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CBF30: 13AAF407  vcmpneb. (lvlx128) v29, v10, v30
	tmp.u32 = ctx.r[10].u32 + ctx.r[30].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CBF34: 1380F407  vcmpneb. (lvlx128) v28, v0, v30
	tmp.u32 = ctx.r[30].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CBF38: C00508A4  lfs f0, 0x8a4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CBF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CBF70 size=148
    let mut pc: u32 = 0x826CBF70;
    'dispatch: loop {
        match pc {
            0x826CBF70 => {
    //   block [0x826CBF70..0x826CC004)
	// 826CBF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CBF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CBF78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CBF7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CBF80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CBF84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CBF88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CBF8C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 826CBF90: 895F01A4  lbz r10, 0x1a4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826CBF94: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CBF98: 419A0054  beq cr6, 0x826cbfec
	if ctx.cr[6].eq {
	pc = 0x826CBFEC; continue 'dispatch;
	}
	// 826CBF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CBFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CBFA4: 419A0020  beq cr6, 0x826cbfc4
	if ctx.cr[6].eq {
	pc = 0x826CBFC4; continue 'dispatch;
	}
	// 826CBFA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CBFAC: 480EA62D  bl 0x827b65d8
	ctx.lr = 0x826CBFB0;
	sub_827B65D8(ctx, base);
	// 826CBFB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CBFB4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CBFB8: 4BC21A81  bl 0x822eda38
	ctx.lr = 0x826CBFBC;
	sub_822EDA38(ctx, base);
	// 826CBFBC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CBFC0: 4800001C  b 0x826cbfdc
	pc = 0x826CBFDC; continue 'dispatch;
	// 826CBFC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CBFC8: 480EA611  bl 0x827b65d8
	ctx.lr = 0x826CBFCC;
	sub_827B65D8(ctx, base);
	// 826CBFCC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826CBFD0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CBFD4: 4BC21A65  bl 0x822eda38
	ctx.lr = 0x826CBFD8;
	sub_822EDA38(ctx, base);
	// 826CBFD8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CBFDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CBFE0: 419A0008  beq cr6, 0x826cbfe8
	if ctx.cr[6].eq {
	pc = 0x826CBFE8; continue 'dispatch;
	}
	// 826CBFE4: 4BBF48AD  bl 0x822c0890
	ctx.lr = 0x826CBFE8;
	sub_822C0890(ctx, base);
	// 826CBFE8: 9BDF01A4  stb r30, 0x1a4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[30].u8 ) };
	// 826CBFEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CBFF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CBFF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CBFF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CBFFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC008 size=508
    let mut pc: u32 = 0x826CC008;
    'dispatch: loop {
        match pc {
            0x826CC008 => {
    //   block [0x826CC008..0x826CC204)
	// 826CC008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC00C: 48ADC161  bl 0x831a816c
	ctx.lr = 0x826CC010;
	sub_831A8130(ctx, base);
	// 826CC010: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 826CC014: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC018: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC01C: 897F01A4  lbz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 826CC020: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CC024: 408201D0  bne 0x826cc1f4
	if !ctx.cr[0].eq {
	pc = 0x826CC1F4; continue 'dispatch;
	}
	// 826CC028: C01F01A0  lfs f0, 0x1a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CC02C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CC030: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 826CC034: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 826CC038: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 826CC03C: 38AB6910  addi r5, r11, 0x6910
	ctx.r[5].s64 = ctx.r[11].s64 + 26896;
	// 826CC040: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CC044: 487AFC85  bl 0x82e7bcc8
	ctx.lr = 0x826CC048;
	sub_82E7BCC8(ctx, base);
	// 826CC048: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CC04C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CC050: 480EA589  bl 0x827b65d8
	ctx.lr = 0x826CC054;
	sub_827B65D8(ctx, base);
	// 826CC054: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CC058: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826CC05C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CC060: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CC064: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826CC068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CC06C: 4E800421  bctrl
	ctx.lr = 0x826CC070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CC070: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826CC074: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC208 size=176
    let mut pc: u32 = 0x826CC208;
    'dispatch: loop {
        match pc {
            0x826CC208 => {
    //   block [0x826CC208..0x826CC2B8)
	// 826CC208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC218: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC21C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC220: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826CC224: 4BE4804D  bl 0x82514270
	ctx.lr = 0x826CC228;
	sub_82514270(ctx, base);
	// 826CC228: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CC22C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CC230: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826CC234: 487277D5  bl 0x82df3a08
	ctx.lr = 0x826CC238;
	sub_82DF3A08(ctx, base);
	// 826CC238: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CC23C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CC240: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CC244: 4BE3C53D  bl 0x82508780
	ctx.lr = 0x826CC248;
	sub_82508780(ctx, base);
	// 826CC248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CC24C: 487271DD  bl 0x82df3428
	ctx.lr = 0x826CC250;
	sub_82DF3428(ctx, base);
	// 826CC250: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CC254: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CC258: 480EA381  bl 0x827b65d8
	ctx.lr = 0x826CC25C;
	sub_827B65D8(ctx, base);
	// 826CC25C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826CC260: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CC264: 808B66F4  lwz r4, 0x66f4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26356 as u32) ) } as u64;
	// 826CC268: 4BDC3139  bl 0x8248f3a0
	ctx.lr = 0x826CC26C;
	sub_8248F3A0(ctx, base);
	// 826CC26C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CC270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CC274: 419A0008  beq cr6, 0x826cc27c
	if ctx.cr[6].eq {
	pc = 0x826CC27C; continue 'dispatch;
	}
	// 826CC278: 4BBF4619  bl 0x822c0890
	ctx.lr = 0x826CC27C;
	sub_822C0890(ctx, base);
	// 826CC27C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CC280: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826CC284: 409A0008  bne cr6, 0x826cc28c
	if !ctx.cr[6].eq {
	pc = 0x826CC28C; continue 'dispatch;
	}
	// 826CC288: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CC28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CC290: 4BE3C511  bl 0x825087a0
	ctx.lr = 0x826CC294;
	sub_825087A0(ctx, base);
	// 826CC294: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 826CC298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC29C: 4BE47285  bl 0x82513520
	ctx.lr = 0x826CC2A0;
	sub_82513520(ctx, base);
	// 826CC2A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CC2A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC2A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC2AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CC2B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CC2B8 size=8
    let mut pc: u32 = 0x826CC2B8;
    'dispatch: loop {
        match pc {
            0x826CC2B8 => {
    //   block [0x826CC2B8..0x826CC2C0)
	// 826CC2B8: 88630000  lbz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CC2BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CC2C0 size=8
    let mut pc: u32 = 0x826CC2C0;
    'dispatch: loop {
        match pc {
            0x826CC2C0 => {
    //   block [0x826CC2C0..0x826CC2C8)
	// 826CC2C0: 98830001  stb r4, 1(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 826CC2C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC2C8 size=120
    let mut pc: u32 = 0x826CC2C8;
    'dispatch: loop {
        match pc {
            0x826CC2C8 => {
    //   block [0x826CC2C8..0x826CC340)
	// 826CC2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC2D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC2D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC2D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC2DC: 897F0001  lbz r11, 1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1 as u32) ) } as u64;
	// 826CC2E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CC2E4: 4182000C  beq 0x826cc2f0
	if ctx.cr[0].eq {
	pc = 0x826CC2F0; continue 'dispatch;
	}
	// 826CC2E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826CC2EC: 48000040  b 0x826cc32c
	pc = 0x826CC32C; continue 'dispatch;
	// 826CC2F0: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CC2F4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826CC2F8: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CC2FC: EC40682A  fadds f2, f0, f13
	ctx.f[2].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826CC300: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CC304: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 826CC308: 4099FFE0  ble cr6, 0x826cc2e8
	if !ctx.cr[6].gt {
	pc = 0x826CC2E8; continue 'dispatch;
	}
	// 826CC30C: 48ADE505  bl 0x831aa810
	ctx.lr = 0x826CC310;
	sub_831AA810(ctx, base);
	// 826CC310: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CC314: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CC318: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826CC31C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826CC320: 41980008  blt cr6, 0x826cc328
	if ctx.cr[6].lt {
	pc = 0x826CC328; continue 'dispatch;
	}
	// 826CC324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CC328: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 826CC32C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CC330: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC334: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC338: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC33C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC340 size=84
    let mut pc: u32 = 0x826CC340;
    'dispatch: loop {
        match pc {
            0x826CC340 => {
    //   block [0x826CC340..0x826CC394)
	// 826CC340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC34C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC354: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CC358: D03F0004  stfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 826CC35C: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 826CC360: D05F0008  stfs f2, 8(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 826CC364: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 826CC368: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 826CC36C: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 826CC370: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826CC374: 4BFFFF55  bl 0x826cc2c8
	ctx.lr = 0x826CC378;
	sub_826CC2C8(ctx, base);
	// 826CC378: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 826CC37C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC380: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CC384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC38C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC398 size=56
    let mut pc: u32 = 0x826CC398;
    'dispatch: loop {
        match pc {
            0x826CC398 => {
    //   block [0x826CC398..0x826CC3D0)
	// 826CC398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC3A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC3A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC3A8: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 826CC3AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CC3B0: 4BDA4D19  bl 0x824710c8
	ctx.lr = 0x826CC3B4;
	sub_824710C8(ctx, base);
	// 826CC3B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC3B8: 4BBFC901  bl 0x822c8cb8
	ctx.lr = 0x826CC3BC;
	sub_822C8CB8(ctx, base);
	// 826CC3BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CC3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC3C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC3D0 size=56
    let mut pc: u32 = 0x826CC3D0;
    'dispatch: loop {
        match pc {
            0x826CC3D0 => {
    //   block [0x826CC3D0..0x826CC408)
	// 826CC3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC3D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC3DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC3E0: 38630030  addi r3, r3, 0x30
	ctx.r[3].s64 = ctx.r[3].s64 + 48;
	// 826CC3E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CC3E8: 4BDA4CE1  bl 0x824710c8
	ctx.lr = 0x826CC3EC;
	sub_824710C8(ctx, base);
	// 826CC3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC3F0: 4BBFC8C9  bl 0x822c8cb8
	ctx.lr = 0x826CC3F4;
	sub_822C8CB8(ctx, base);
	// 826CC3F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CC3F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC3FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC400: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC408 size=132
    let mut pc: u32 = 0x826CC408;
    'dispatch: loop {
        match pc {
            0x826CC408 => {
    //   block [0x826CC408..0x826CC48C)
	// 826CC408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC40C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC420: 4BFFFEA9  bl 0x826cc2c8
	ctx.lr = 0x826CC424;
	sub_826CC2C8(ctx, base);
	// 826CC424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CC428: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CC42C: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 826CC430: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826CC434: 419A0040  beq cr6, 0x826cc474
	if ctx.cr[6].eq {
	pc = 0x826CC474; continue 'dispatch;
	}
	// 826CC438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CC43C: 419A0010  beq cr6, 0x826cc44c
	if ctx.cr[6].eq {
	pc = 0x826CC44C; continue 'dispatch;
	}
	// 826CC440: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 826CC444: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 826CC448: 4800000C  b 0x826cc454
	pc = 0x826CC454; continue 'dispatch;
	// 826CC44C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 826CC450: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 826CC454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CC458: 419A0018  beq cr6, 0x826cc470
	if ctx.cr[6].eq {
	pc = 0x826CC470; continue 'dispatch;
	}
	// 826CC45C: 3D60822C  lis r11, -0x7dd4
	ctx.r[11].s64 = -2111045632;
	// 826CC460: 396B0000  addi r11, r11, 0
	ctx.r[11].s64 = ctx.r[11].s64 + 0;
	// 826CC464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CC468: 419A0008  beq cr6, 0x826cc470
	if ctx.cr[6].eq {
	pc = 0x826CC470; continue 'dispatch;
	}
	// 826CC46C: 4BD87215  bl 0x82453680
	ctx.lr = 0x826CC470;
	sub_82453680(ctx, base);
	// 826CC470: 9BDF0000  stb r30, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 826CC474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CC478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC47C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CC484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC490 size=132
    let mut pc: u32 = 0x826CC490;
    'dispatch: loop {
        match pc {
            0x826CC490 => {
    //   block [0x826CC490..0x826CC514)
	// 826CC490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC494: 48ADBCD5  bl 0x831a8168
	ctx.lr = 0x826CC498;
	sub_831A8130(ctx, base);
	// 826CC498: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 826CC49C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 826CC4A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC4A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC4A8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CC4AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826CC4B0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826CC4B4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 826CC4B8: 4BFFF3E1  bl 0x826cb898
	ctx.lr = 0x826CC4BC;
	sub_826CB898(ctx, base);
	// 826CC4BC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CC4C0: 3BDF0060  addi r30, r31, 0x60
	ctx.r[30].s64 = ctx.r[31].s64 + 96;
	// 826CC4C4: 396B8824  addi r11, r11, -0x77dc
	ctx.r[11].s64 = ctx.r[11].s64 + -30684;
	// 826CC4C8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826CC4CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CC4D0: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CC4D4: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC518 size=92
    let mut pc: u32 = 0x826CC518;
    'dispatch: loop {
        match pc {
            0x826CC518 => {
    //   block [0x826CC518..0x826CC574)
	// 826CC518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC51C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC52C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC530: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CC534: 387F0078  addi r3, r31, 0x78
	ctx.r[3].s64 = ctx.r[31].s64 + 120;
	// 826CC538: 4BBFC781  bl 0x822c8cb8
	ctx.lr = 0x826CC53C;
	sub_822C8CB8(ctx, base);
	// 826CC53C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CC540: 57CA07FF  clrlwi. r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826CC544: 396B87CC  addi r11, r11, -0x7834
	ctx.r[11].s64 = ctx.r[11].s64 + -30772;
	// 826CC548: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CC54C: 4182000C  beq 0x826cc558
	if ctx.cr[0].eq {
	pc = 0x826CC558; continue 'dispatch;
	}
	// 826CC550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC554: 48725E85  bl 0x82df23d8
	ctx.lr = 0x826CC558;
	sub_82DF23D8(ctx, base);
	// 826CC558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC55C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CC560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CC56C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC578 size=264
    let mut pc: u32 = 0x826CC578;
    'dispatch: loop {
        match pc {
            0x826CC578 => {
    //   block [0x826CC578..0x826CC680)
	// 826CC578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC580: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC584: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC588: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CC58C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC590: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC594: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CC598: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826CC59C: C05F0070  lfs f2, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CC5A0: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CC5A4: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 826CC5A8: 41990014  bgt cr6, 0x826cc5bc
	if ctx.cr[6].gt {
	pc = 0x826CC5BC; continue 'dispatch;
	}
	// 826CC5AC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CC5B0: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826CC5B4: 4BFFF375  bl 0x826cb928
	ctx.lr = 0x826CC5B8;
	sub_826CB928(ctx, base);
	// 826CC5B8: 480000AC  b 0x826cc664
	pc = 0x826CC664; continue 'dispatch;
	// 826CC5BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CC5C0: 48ADE251  bl 0x831aa810
	ctx.lr = 0x826CC5C4;
	sub_831AA810(ctx, base);
	// 826CC5C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CC5C8: C1BF0070  lfs f13, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CC5CC: FD800818  frsp f12, f1
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 826CC5D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 826CC5D4: C17F0074  lfs f11, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826CC5D8: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 826CC5DC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 826CC5E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CC5E4: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CC5E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CC5EC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 826CC5F0: 13FF48C7  vcmpequd (lvx128) v31, v31, v9
	tmp.u32 = ctx.r[31].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CC5F4: EDA00332  fmuls f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 826CC5F8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CC5FC: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 826CC600: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826CC604: 13C05407  vcmpneb. (lvlx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC680 size=136
    let mut pc: u32 = 0x826CC680;
    'dispatch: loop {
        match pc {
            0x826CC680 => {
    //   block [0x826CC680..0x826CC708)
	// 826CC680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC688: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC68C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC690: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826CC694: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826CC698: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CC69C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC6A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC6A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CC6A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CC6AC: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826CC6B0: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 826CC6B4: 4BFFF1E5  bl 0x826cb898
	ctx.lr = 0x826CC6B8;
	sub_826CB898(ctx, base);
	// 826CC6B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CC6BC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 826CC6C0: 396B8830  addi r11, r11, -0x77d0
	ctx.r[11].s64 = ctx.r[11].s64 + -30672;
	// 826CC6C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CC6C8: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC708 size=116
    let mut pc: u32 = 0x826CC708;
    'dispatch: loop {
        match pc {
            0x826CC708 => {
    //   block [0x826CC708..0x826CC77C)
	// 826CC708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC70C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC710: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC714: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC71C: C09F0078  lfs f4, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 826CC720: C07F0070  lfs f3, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826CC724: C05F0074  lfs f2, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CC728: 4BFFF2C9  bl 0x826cb9f0
	ctx.lr = 0x826CC72C;
	sub_826CB9F0(ctx, base);
	// 826CC72C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CC730: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826CC734: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 826CC738: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 826CC73C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CC740: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CC744: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC780 size=136
    let mut pc: u32 = 0x826CC780;
    'dispatch: loop {
        match pc {
            0x826CC780 => {
    //   block [0x826CC780..0x826CC808)
	// 826CC780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC78C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC790: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826CC794: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826CC798: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CC79C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC7A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CC7A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CC7AC: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 826CC7B0: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 826CC7B4: 4BFFF0E5  bl 0x826cb898
	ctx.lr = 0x826CC7B8;
	sub_826CB898(ctx, base);
	// 826CC7B8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CC7BC: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 826CC7C0: 396B883C  addi r11, r11, -0x77c4
	ctx.r[11].s64 = ctx.r[11].s64 + -30660;
	// 826CC7C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CC7C8: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC808 size=68
    let mut pc: u32 = 0x826CC808;
    'dispatch: loop {
        match pc {
            0x826CC808 => {
    //   block [0x826CC808..0x826CC84C)
	// 826CC808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC814: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC818: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC81C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CC820: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826CC824: 396B87CC  addi r11, r11, -0x7834
	ctx.r[11].s64 = ctx.r[11].s64 + -30772;
	// 826CC828: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CC82C: 41820008  beq 0x826cc834
	if ctx.cr[0].eq {
	pc = 0x826CC834; continue 'dispatch;
	}
	// 826CC830: 48725BA9  bl 0x82df23d8
	ctx.lr = 0x826CC834;
	sub_82DF23D8(ctx, base);
	// 826CC834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CC838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CC83C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC850 size=116
    let mut pc: u32 = 0x826CC850;
    'dispatch: loop {
        match pc {
            0x826CC850 => {
    //   block [0x826CC850..0x826CC8C4)
	// 826CC850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC858: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC85C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC864: C09F0078  lfs f4, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 826CC868: C07F0070  lfs f3, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826CC86C: C05F0074  lfs f2, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CC870: 4BFFF0F1  bl 0x826cb960
	ctx.lr = 0x826CC874;
	sub_826CB960(ctx, base);
	// 826CC874: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CC878: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826CC87C: 39400060  li r10, 0x60
	ctx.r[10].s64 = 96;
	// 826CC880: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 826CC884: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CC888: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CC88C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC8C8 size=72
    let mut pc: u32 = 0x826CC8C8;
    'dispatch: loop {
        match pc {
            0x826CC8C8 => {
    //   block [0x826CC8C8..0x826CC910)
	// 826CC8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC8D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC8D4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC8D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC8DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CC8E0: C07F0024  lfs f3, 0x24(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826CC8E4: C05F0020  lfs f2, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CC8E8: C03F001C  lfs f1, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CC8EC: 487AF685  bl 0x82e7bf70
	ctx.lr = 0x826CC8F0;
	sub_82E7BF70(ctx, base);
	// 826CC8F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CC8F4: 807F003C  lwz r3, 0x3c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 826CC8F8: 48746969  bl 0x82e13260
	ctx.lr = 0x826CC8FC;
	sub_82E13260(ctx, base);
	// 826CC8FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826CC900: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CC904: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CC908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CC90C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CC910 size=192
    let mut pc: u32 = 0x826CC910;
    'dispatch: loop {
        match pc {
            0x826CC910 => {
    //   block [0x826CC910..0x826CC9D0)
	// 826CC910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC91C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC920: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CC928: 817F00F0  lwz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826CC92C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CC930: 419A0088  beq cr6, 0x826cc9b8
	if ctx.cr[6].eq {
	pc = 0x826CC9B8; continue 'dispatch;
	}
	// 826CC934: 809F00F8  lwz r4, 0xf8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826CC938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CC93C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CC940: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826CC944: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CC948: 4E800421  bctrl
	ctx.lr = 0x826CC94C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CC94C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CC950: 3BDF0130  addi r30, r31, 0x130
	ctx.r[30].s64 = ctx.r[31].s64 + 304;
	// 826CC954: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826CC958: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826CC95C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CC960: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CC964: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CC9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CC9D0 size=196
    let mut pc: u32 = 0x826CC9D0;
    'dispatch: loop {
        match pc {
            0x826CC9D0 => {
    //   block [0x826CC9D0..0x826CCA94)
	// 826CC9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CC9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CC9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CC9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CC9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CC9E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CC9E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CC9EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826CC9F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CC9F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CC9F8: 4BBF3F41  bl 0x822c0938
	ctx.lr = 0x826CC9FC;
	sub_822C0938(ctx, base);
	// 826CC9FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CCA00: 41820028  beq 0x826cca28
	if ctx.cr[0].eq {
	pc = 0x826CCA28; continue 'dispatch;
	}
	// 826CCA04: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CCA08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826CCA0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826CCA10: 392B8848  addi r9, r11, -0x77b8
	ctx.r[9].s64 = ctx.r[11].s64 + -30648;
	// 826CCA14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826CCA18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CCA1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826CCA20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826CCA24: 48000008  b 0x826cca2c
	pc = 0x826CCA2C; continue 'dispatch;
	// 826CCA28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CCA2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CCA30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CCA34: 409A0044  bne cr6, 0x826cca78
	if !ctx.cr[6].eq {
	pc = 0x826CCA78; continue 'dispatch;
	}
	// 826CCA38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CCA3C: 419A001C  beq cr6, 0x826cca58
	if ctx.cr[6].eq {
	pc = 0x826CCA58; continue 'dispatch;
	}
	// 826CCA40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CCA44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CCA48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCA4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CCA50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CCA54: 4E800421  bctrl
	ctx.lr = 0x826CCA58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CCA58: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CCA5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CCA60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CCA64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826CCA68: 816BCB24  lwz r11, -0x34dc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13532 as u32) ) } as u64;
	// 826CCA6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CCA70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CCA74: 4BBF358D  bl 0x822c0000
	ctx.lr = 0x826CCA78;
	sub_822C0000(ctx, base);
	// 826CCA78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CCA7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CCA80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CCA84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CCA88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CCA8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CCA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CCA98 size=68
    let mut pc: u32 = 0x826CCA98;
    'dispatch: loop {
        match pc {
            0x826CCA98 => {
    //   block [0x826CCA98..0x826CCADC)
	// 826CCA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CCA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CCAA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CCAA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CCAA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCAAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CCAB0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 826CCAB4: 396B087C  addi r11, r11, 0x87c
	ctx.r[11].s64 = ctx.r[11].s64 + 2172;
	// 826CCAB8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CCABC: 41820008  beq 0x826ccac4
	if ctx.cr[0].eq {
	pc = 0x826CCAC4; continue 'dispatch;
	}
	// 826CCAC0: 4BBF37A9  bl 0x822c0268
	ctx.lr = 0x826CCAC4;
	sub_822C0268(ctx, base);
	// 826CCAC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCAC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CCACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CCAD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CCAD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CCAD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CCAE0 size=208
    let mut pc: u32 = 0x826CCAE0;
    'dispatch: loop {
        match pc {
            0x826CCAE0 => {
    //   block [0x826CCAE0..0x826CCBB0)
	// 826CCAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CCAE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CCAE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CCAEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CCAF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CCAF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CCAF8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826CCAFC: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826CCB00: 38AABA80  addi r5, r10, -0x4580
	ctx.r[5].s64 = ctx.r[10].s64 + -17792;
	// 826CCB04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CCB08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCB0C: 4BE45755  bl 0x82512260
	ctx.lr = 0x826CCB10;
	sub_82512260(ctx, base);
	// 826CCB10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CCB14: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CCB18: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826CCB1C: 394A88BC  addi r10, r10, -0x7744
	ctx.r[10].s64 = ctx.r[10].s64 + -30532;
	// 826CCB20: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CCB24: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826CCB28: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826CCB2C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826CCB30: 392988A8  addi r9, r9, -0x7758
	ctx.r[9].s64 = ctx.r[9].s64 + -30552;
	// 826CCB34: 3908885C  addi r8, r8, -0x77a4
	ctx.r[8].s64 = ctx.r[8].s64 + -30628;
	// 826CCB38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CCB3C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826CCB40: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826CCB44: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826CCB48: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826CCB4C: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 826CCB50: 394ACB30  addi r10, r10, -0x34d0
	ctx.r[10].s64 = ctx.r[10].s64 + -13520;
	// 826CCB54: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826CCB58: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826CCB5C: 39000130  li r8, 0x130
	ctx.r[8].s64 = 304;
	// 826CCB60: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826CCB64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCB68: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826CCB6C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826CCB70: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CCBB0 size=8
    let mut pc: u32 = 0x826CCBB0;
    'dispatch: loop {
        match pc {
            0x826CCBB0 => {
    //   block [0x826CCBB0..0x826CCBB8)
	// 826CCBB0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826CCBB4: 480000D4  b 0x826ccc88
	sub_826CCC88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CCBB8 size=8
    let mut pc: u32 = 0x826CCBB8;
    'dispatch: loop {
        match pc {
            0x826CCBB8 => {
    //   block [0x826CCBB8..0x826CCBC0)
	// 826CCBB8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826CCBBC: 480000CC  b 0x826ccc88
	sub_826CCC88(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CCBC0 size=200
    let mut pc: u32 = 0x826CCBC0;
    'dispatch: loop {
        match pc {
            0x826CCBC0 => {
    //   block [0x826CCBC0..0x826CCC88)
	// 826CCBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CCBC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CCBC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CCBCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CCBD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CCBD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCBD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CCBDC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CCBE0: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CCBE4: 396B88BC  addi r11, r11, -0x7744
	ctx.r[11].s64 = ctx.r[11].s64 + -30532;
	// 826CCBE8: 394A88A8  addi r10, r10, -0x7758
	ctx.r[10].s64 = ctx.r[10].s64 + -30552;
	// 826CCBEC: 3929885C  addi r9, r9, -0x77a4
	ctx.r[9].s64 = ctx.r[9].s64 + -30628;
	// 826CCBF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CCBF4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826CCBF8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 826CCBFC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826CCC00: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826CCC04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCC08: 419A0008  beq cr6, 0x826ccc10
	if ctx.cr[6].eq {
	pc = 0x826CCC10; continue 'dispatch;
	}
	// 826CCC0C: 4BBF3C85  bl 0x822c0890
	ctx.lr = 0x826CCC10;
	sub_822C0890(ctx, base);
	// 826CCC10: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826CCC14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCC18: 419A0008  beq cr6, 0x826ccc20
	if ctx.cr[6].eq {
	pc = 0x826CCC20; continue 'dispatch;
	}
	// 826CCC1C: 4BBF3C75  bl 0x822c0890
	ctx.lr = 0x826CCC20;
	sub_822C0890(ctx, base);
	// 826CCC20: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826CCC24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCC28: 419A0008  beq cr6, 0x826ccc30
	if ctx.cr[6].eq {
	pc = 0x826CCC30; continue 'dispatch;
	}
	// 826CCC2C: 4BBF3C65  bl 0x822c0890
	ctx.lr = 0x826CCC30;
	sub_822C0890(ctx, base);
	// 826CCC30: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826CCC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCC38: 419A0008  beq cr6, 0x826ccc40
	if ctx.cr[6].eq {
	pc = 0x826CCC40; continue 'dispatch;
	}
	// 826CCC3C: 4BBF3C55  bl 0x822c0890
	ctx.lr = 0x826CCC40;
	sub_822C0890(ctx, base);
	// 826CCC40: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 826CCC44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCC48: 419A0008  beq cr6, 0x826ccc50
	if ctx.cr[6].eq {
	pc = 0x826CCC50; continue 'dispatch;
	}
	// 826CCC4C: 4BBF3C45  bl 0x822c0890
	ctx.lr = 0x826CCC50;
	sub_822C0890(ctx, base);
	// 826CCC50: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 826CCC54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCC58: 419A0008  beq cr6, 0x826ccc60
	if ctx.cr[6].eq {
	pc = 0x826CCC60; continue 'dispatch;
	}
	// 826CCC5C: 4BBF3C35  bl 0x822c0890
	ctx.lr = 0x826CCC60;
	sub_822C0890(ctx, base);
	// 826CCC60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CCC64: 480DA9F5  bl 0x827a7658
	ctx.lr = 0x826CCC68;
	sub_827A7658(ctx, base);
	// 826CCC68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCC6C: 4BC826E5  bl 0x8234f350
	ctx.lr = 0x826CCC70;
	sub_8234F350(ctx, base);
	// 826CCC70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CCC74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CCC78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CCC7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CCC80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CCC84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CCC88 size=76
    let mut pc: u32 = 0x826CCC88;
    'dispatch: loop {
        match pc {
            0x826CCC88 => {
    //   block [0x826CCC88..0x826CCCD4)
	// 826CCC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CCC8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CCC90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CCC94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CCC98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CCC9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCCA0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CCCA4: 4BFFFF1D  bl 0x826ccbc0
	ctx.lr = 0x826CCCA8;
	sub_826CCBC0(ctx, base);
	// 826CCCA8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CCCAC: 4182000C  beq 0x826cccb8
	if ctx.cr[0].eq {
	pc = 0x826CCCB8; continue 'dispatch;
	}
	// 826CCCB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCCB4: 48725725  bl 0x82df23d8
	ctx.lr = 0x826CCCB8;
	sub_82DF23D8(ctx, base);
	// 826CCCB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCCBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CCCC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CCCC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CCCC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CCCCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CCCD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CCCD8 size=424
    let mut pc: u32 = 0x826CCCD8;
    'dispatch: loop {
        match pc {
            0x826CCCD8 => {
    //   block [0x826CCCD8..0x826CCE80)
	// 826CCCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CCCDC: 48ADB489  bl 0x831a8164
	ctx.lr = 0x826CCCE0;
	sub_831A8130(ctx, base);
	// 826CCCE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CCCE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CCCE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826CCCEC: 3BCB88F8  addi r30, r11, -0x7708
	ctx.r[30].s64 = ctx.r[11].s64 + -30472;
	// 826CCCF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826CCCF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CCCF8: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 826CCCFC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826CCD00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CCD04: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 826CCD08: 487256E1  bl 0x82df23e8
	ctx.lr = 0x826CCD0C;
	sub_82DF23E8(ctx, base);
	// 826CCD0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CCD10: 41820010  beq 0x826ccd20
	if ctx.cr[0].eq {
	pc = 0x826CCD20; continue 'dispatch;
	}
	// 826CCD14: 4BFFFDCD  bl 0x826ccae0
	ctx.lr = 0x826CCD18;
	sub_826CCAE0(ctx, base);
	// 826CCD18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCD1C: 48000008  b 0x826ccd24
	pc = 0x826CCD24; continue 'dispatch;
	// 826CCD20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CCD24: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826CCD28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CCD2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CCD30: 4BFFFCA1  bl 0x826cc9d0
	ctx.lr = 0x826CCD34;
	sub_826CC9D0(ctx, base);
	// 826CCD34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CCD38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CCD3C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CCD40: 4BBF32C1  bl 0x822c0000
	ctx.lr = 0x826CCD44;
	sub_822C0000(ctx, base);
	// 826CCD44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CCD48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CCD4C: 38A00031  li r5, 0x31
	ctx.r[5].s64 = 49;
	// 826CCD50: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826CCD54: 4BBF3685  bl 0x822c03d8
	ctx.lr = 0x826CCD58;
	sub_822C03D8(ctx, base);
	// 826CCD58: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CCD5C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826CCD60: 418200B4  beq 0x826cce14
	if ctx.cr[0].eq {
	pc = 0x826CCE14; continue 'dispatch;
	}
	// 826CCD64: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CCD68: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826CCD6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826CCD70: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826CCD74: 409A0008  bne cr6, 0x826ccd7c
	if !ctx.cr[6].eq {
	pc = 0x826CCD7C; continue 'dispatch;
	}
	// 826CCD78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CCD7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826CCD80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CCD84: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826CCD88: 419A0024  beq cr6, 0x826ccdac
	if ctx.cr[6].eq {
	pc = 0x826CCDAC; continue 'dispatch;
	}
	// 826CCD8C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826CCD90: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826CCD94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CCD98: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826CCD9C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826CCDA0: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CCDA4: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CCDA8: 4082FFE8  bne 0x826ccd90
	if !ctx.cr[0].eq {
	pc = 0x826CCD90; continue 'dispatch;
	}
	// 826CCDAC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826CCDB0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CCDB4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826CCDB8: 419A0024  beq cr6, 0x826ccddc
	if ctx.cr[6].eq {
	pc = 0x826CCDDC; continue 'dispatch;
	}
	// 826CCDBC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826CCDC0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CCDC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CCDC8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CCDCC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CCDD0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CCDD4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CCDD8: 4082FFE8  bne 0x826ccdc0
	if !ctx.cr[0].eq {
	pc = 0x826CCDC0; continue 'dispatch;
	}
	// 826CCDDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CCDE0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826CCDE4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826CCDE8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826CCDEC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826CCDF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CCDF4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CCDF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CCDFC: 480CC135  bl 0x82798f30
	ctx.lr = 0x826CCE00;
	sub_82798F30(ctx, base);
	// 826CCE00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CCE04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CCE08: 480CE861  bl 0x8279b668
	ctx.lr = 0x826CCE0C;
	sub_8279B668(ctx, base);
	// 826CCE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCE10: 48000008  b 0x826cce18
	pc = 0x826CCE18; continue 'dispatch;
	// 826CCE14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CCE18: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CCE1C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826CCE20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CCE24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CCE28: 4BECAE29  bl 0x82597c50
	ctx.lr = 0x826CCE2C;
	sub_82597C50(ctx, base);
	// 826CCE2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CCE30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CCE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CCE38: 4BBF31C9  bl 0x822c0000
	ctx.lr = 0x826CCE3C;
	sub_822C0000(ctx, base);
	// 826CCE3C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CCE40: 41820024  beq 0x826cce64
	if ctx.cr[0].eq {
	pc = 0x826CCE64; continue 'dispatch;
	}
	// 826CCE44: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826CCE48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCE4C: 419A0008  beq cr6, 0x826cce54
	if ctx.cr[6].eq {
	pc = 0x826CCE54; continue 'dispatch;
	}
	// 826CCE50: 4BBF3A41  bl 0x822c0890
	ctx.lr = 0x826CCE54;
	sub_822C0890(ctx, base);
	// 826CCE54: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826CCE58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCE5C: 419A0008  beq cr6, 0x826cce64
	if ctx.cr[6].eq {
	pc = 0x826CCE64; continue 'dispatch;
	}
	// 826CCE60: 4BBF3A31  bl 0x822c0890
	ctx.lr = 0x826CCE64;
	sub_822C0890(ctx, base);
	// 826CCE64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CCE68: 419A000C  beq cr6, 0x826cce74
	if ctx.cr[6].eq {
	pc = 0x826CCE74; continue 'dispatch;
	}
	// 826CCE6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CCE70: 4BBF3A21  bl 0x822c0890
	ctx.lr = 0x826CCE74;
	sub_822C0890(ctx, base);
	// 826CCE74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826CCE78: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826CCE7C: 48ADB338  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CCE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CCE80 size=2080
    let mut pc: u32 = 0x826CCE80;
    'dispatch: loop {
        match pc {
            0x826CCE80 => {
    //   block [0x826CCE80..0x826CD6A0)
	// 826CCE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CCE84: 48ADB2C5  bl 0x831a8148
	ctx.lr = 0x826CCE88;
	sub_831A8130(ctx, base);
	// 826CCE88: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 826CCE8C: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 826CCE90: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CCE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CCE98: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 826CCE9C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826CCEA0: 4BE44B39  bl 0x825119d8
	ctx.lr = 0x826CCEA4;
	sub_825119D8(ctx, base);
	// 826CCEA4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CCEA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CCEAC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826CCEB0: 48726B59  bl 0x82df3a08
	ctx.lr = 0x826CCEB4;
	sub_82DF3A08(ctx, base);
	// 826CCEB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CCEB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CCEBC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 826CCEC0: 4BE3B8C1  bl 0x82508780
	ctx.lr = 0x826CCEC4;
	sub_82508780(ctx, base);
	// 826CCEC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CCEC8: 48726561  bl 0x82df3428
	ctx.lr = 0x826CCECC;
	sub_82DF3428(ctx, base);
	// 826CCECC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CCED0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826CCED4: 409A0008  bne cr6, 0x826ccedc
	if !ctx.cr[6].eq {
	pc = 0x826CCEDC; continue 'dispatch;
	}
	// 826CCED8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CCEDC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 826CCEE0: 4BE3B8C1  bl 0x825087a0
	ctx.lr = 0x826CCEE4;
	sub_825087A0(ctx, base);
	// 826CCEE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CCEE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CCEEC: 3B4B88F8  addi r26, r11, -0x7708
	ctx.r[26].s64 = ctx.r[11].s64 + -30472;
	// 826CCEF0: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 826CCEF4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CCEF8: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826CCEFC: 487254ED  bl 0x82df23e8
	ctx.lr = 0x826CCF00;
	sub_82DF23E8(ctx, base);
	// 826CCF00: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CCF04: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CCF08: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 826CCF0C: 41820014  beq 0x826ccf20
	if ctx.cr[0].eq {
	pc = 0x826CCF20; continue 'dispatch;
	}
	// 826CCF10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CCF14: 487461DD  bl 0x82e130f0
	ctx.lr = 0x826CCF18;
	sub_82E130F0(ctx, base);
	// 826CCF18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CCF1C: 48000008  b 0x826ccf24
	pc = 0x826CCF24; continue 'dispatch;
	// 826CCF20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CCF24: 3BDF0110  addi r30, r31, 0x110
	ctx.r[30].s64 = ctx.r[31].s64 + 272;
	// 826CCF28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CCF2C: 4BC14E25  bl 0x822e1d50
	ctx.lr = 0x826CCF30;
	sub_822E1D50(ctx, base);
	// 826CCF30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CCF34: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CCF38: 837F0110  lwz r27, 0x110(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826CCF3C: 4BE451DD  bl 0x82512118
	ctx.lr = 0x826CCF40;
	sub_82512118(ctx, base);
	// 826CCF40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826CCF44: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CCF48: 48745EE9  bl 0x82e12e30
	ctx.lr = 0x826CCF4C;
	sub_82E12E30(ctx, base);
	// 826CCF4C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826CCF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CCF54: 419A0008  beq cr6, 0x826ccf5c
	if ctx.cr[6].eq {
	pc = 0x826CCF5C; continue 'dispatch;
	}
	// 826CCF58: 4BBF3939  bl 0x822c0890
	ctx.lr = 0x826CCF5C;
	sub_822C0890(ctx, base);
	// 826CCF5C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CCF60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CCF64: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 826CCF68: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 826CCF6C: 4872547D  bl 0x82df23e8
	ctx.lr = 0x826CCF70;
	sub_82DF23E8(ctx, base);
	// 826CCF70: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CCF74: 41820010  beq 0x826ccf84
	if ctx.cr[0].eq {
	pc = 0x826CCF84; continue 'dispatch;
	}
	// 826CCF78: 4BEBDD21  bl 0x8258ac98
	ctx.lr = 0x826CCF7C;
	sub_8258AC98(ctx, base);
	// 826CCF7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CCF80: 48000008  b 0x826ccf88
	pc = 0x826CCF88; continue 'dispatch;
	// 826CCF84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CCF88: 3B3F0118  addi r25, r31, 0x118
	ctx.r[25].s64 = ctx.r[31].s64 + 280;
	// 826CCF8C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826CCF90: 4BD06899  bl 0x823d3828
	ctx.lr = 0x826CCF94;
	sub_823D3828(ctx, base);
	// 826CCF94: 809F0118  lwz r4, 0x118(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826CCF98: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CCF9C: 48745E95  bl 0x82e12e30
	ctx.lr = 0x826CCFA0;
	sub_82E12E30(ctx, base);
	// 826CCFA0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CCFA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CCFA8: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 826CCFAC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826CCFB0: 48725439  bl 0x82df23e8
	ctx.lr = 0x826CCFB4;
	sub_82DF23E8(ctx, base);
	// 826CCFB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CCFB8: 41820014  beq 0x826ccfcc
	if ctx.cr[0].eq {
	pc = 0x826CCFCC; continue 'dispatch;
	}
	// 826CCFBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CCFC0: 48746131  bl 0x82e130f0
	ctx.lr = 0x826CCFC4;
	sub_82E130F0(ctx, base);
	// 826CCFC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CCFC8: 48000008  b 0x826ccfd0
	pc = 0x826CCFD0; continue 'dispatch;
	// 826CCFCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CCFD0: 3B1F0120  addi r24, r31, 0x120
	ctx.r[24].s64 = ctx.r[31].s64 + 288;
	// 826CCFD4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826CCFD8: 4BC14D79  bl 0x822e1d50
	ctx.lr = 0x826CCFDC;
	sub_822E1D50(ctx, base);
	// 826CCFDC: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 826CCFE0: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CCFE4: 48745E4D  bl 0x82e12e30
	ctx.lr = 0x826CCFE8;
	sub_82E12E30(ctx, base);
	// 826CCFE8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CCFEC: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CCFF0: 4875DAF9  bl 0x82e2aae8
	ctx.lr = 0x826CCFF4;
	sub_82E2AAE8(ctx, base);
	// 826CCFF4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CCFF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CCFFC: 808BCB20  lwz r4, -0x34e0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13536 as u32) ) } as u64;
	// 826CD000: 48726A09  bl 0x82df3a08
	ctx.lr = 0x826CD004;
	sub_82DF3A08(ctx, base);
	// 826CD004: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CD008: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CD00C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826CD010: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CD014: 48761E5D  bl 0x82e2ee70
	ctx.lr = 0x826CD018;
	sub_82E2EE70(ctx, base);
	// 826CD018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CD01C: 4872640D  bl 0x82df3428
	ctx.lr = 0x826CD020;
	sub_82DF3428(ctx, base);
	// 826CD020: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826CD024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CD028: 419A006C  beq cr6, 0x826cd094
	if ctx.cr[6].eq {
	pc = 0x826CD094; continue 'dispatch;
	}
	// 826CD02C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CD030: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CD034: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 826CD038: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826CD03C: 487253AD  bl 0x82df23e8
	ctx.lr = 0x826CD040;
	sub_82DF23E8(ctx, base);
	// 826CD040: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CD044: 41820014  beq 0x826cd058
	if ctx.cr[0].eq {
	pc = 0x826CD058; continue 'dispatch;
	}
	// 826CD048: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826CD04C: 48749845  bl 0x82e16890
	ctx.lr = 0x826CD050;
	sub_82E16890(ctx, base);
	// 826CD050: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CD054: 48000008  b 0x826cd05c
	pc = 0x826CD05C; continue 'dispatch;
	// 826CD058: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CD05C: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 826CD060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CD064: 4BC9030D  bl 0x8235d370
	ctx.lr = 0x826CD068;
	sub_8235D370(ctx, base);
	// 826CD068: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 826CD06C: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826CD070: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 826CD074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CD078: 4E800421  bctrl
	ctx.lr = 0x826CD07C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CD07C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826CD080: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826CD084: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CD088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD08C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826CD090: 4BE43AC9  bl 0x82510b58
	ctx.lr = 0x826CD094;
	sub_82510B58(ctx, base);
	// 826CD094: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826CD098: 487FF951  bl 0x82ecc9e8
	ctx.lr = 0x826CD09C;
	sub_82ECC9E8(ctx, base);
	// 826CD09C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 826CD0A0: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CD0A4: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 826CD0A8: 99610180  stb r11, 0x180(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u8 ) };
	// 826CD0AC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826CD0B0: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826CD0B4: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826CD0B8: 487D3679  bl 0x82ea0730
	ctx.lr = 0x826CD0BC;
	sub_82EA0730(ctx, base);
	// 826CD0BC: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 826CD0C0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826CD0C4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 826CD0C8: C1BF0100  lfs f13, 0x100(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CD0CC: C19F0104  lfs f12, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826CD0D0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826CD0D4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826CD0D8: C01F0108  lfs f0, 0x108(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CD0DC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826CD0E0: C02AF614  lfs f1, -0x9ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CD0E4: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 826CD0E8: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826CD0EC: C3E99450  lfs f31, -0x6bb0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CD0F0: ED6007F2  fmuls f11, f0, f31
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CD0F4: C00808A8  lfs f0, 0x8a8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CD0F8: ED8C07F2  fmuls f12, f12, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CD0FC: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826CD100: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 826CD104: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826CD108: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826CD10C: D1610068  stfs f11, 0x68(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826CD110: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CD6A0 size=96
    let mut pc: u32 = 0x826CD6A0;
    'dispatch: loop {
        match pc {
            0x826CD6A0 => {
    //   block [0x826CD6A0..0x826CD700)
	// 826CD6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CD6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CD6A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CD6AC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CD6B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CD6B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CD6B8: 814B0110  lwz r10, 0x110(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) } as u64;
	// 826CD6BC: C00B010C  lfs f0, 0x10c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CD6C0: 83EB0104  lwz r31, 0x104(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 826CD6C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826CD6C8: 409A0010  bne cr6, 0x826cd6d8
	if !ctx.cr[6].eq {
	pc = 0x826CD6D8; continue 'dispatch;
	}
	// 826CD6CC: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826CD6D0: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CD6D4: 48000008  b 0x826cd6dc
	pc = 0x826CD6DC; continue 'dispatch;
	// 826CD6D8: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 826CD6DC: 487AF30D  bl 0x82e7c9e8
	ctx.lr = 0x826CD6E0;
	sub_82E7C9E8(ctx, base);
	// 826CD6E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CD6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD6E8: 48745B79  bl 0x82e13260
	ctx.lr = 0x826CD6EC;
	sub_82E13260(ctx, base);
	// 826CD6EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826CD6F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CD6F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CD6F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CD6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CD700 size=104
    let mut pc: u32 = 0x826CD700;
    'dispatch: loop {
        match pc {
            0x826CD700 => {
    //   block [0x826CD700..0x826CD768)
	// 826CD700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CD704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CD708: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CD70C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CD710: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CD714: 4BE42FF5  bl 0x82510708
	ctx.lr = 0x826CD718;
	sub_82510708(ctx, base);
	// 826CD718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CD71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CD720: 4BE41DA9  bl 0x8250f4c8
	ctx.lr = 0x826CD724;
	sub_8250F4C8(ctx, base);
	// 826CD724: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CD728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CD72C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CD730: 409A0008  bne cr6, 0x826cd738
	if !ctx.cr[6].eq {
	pc = 0x826CD738; continue 'dispatch;
	}
	// 826CD734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826CD738: 4BE3ADE1  bl 0x82508518
	ctx.lr = 0x826CD73C;
	sub_82508518(ctx, base);
	// 826CD73C: C01F0114  lfs f0, 0x114(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CD740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD744: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 826CD748: 4BFFFF59  bl 0x826cd6a0
	ctx.lr = 0x826CD74C;
	sub_826CD6A0(ctx, base);
	// 826CD74C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CD750: 48724541  bl 0x82df1c90
	ctx.lr = 0x826CD754;
	sub_82DF1C90(ctx, base);
	// 826CD754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CD758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CD75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CD760: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CD764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CD768 size=196
    let mut pc: u32 = 0x826CD768;
    'dispatch: loop {
        match pc {
            0x826CD768 => {
    //   block [0x826CD768..0x826CD82C)
	// 826CD768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CD76C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CD770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CD774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CD778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CD77C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CD780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CD784: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826CD788: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CD78C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CD790: 4BBF31A9  bl 0x822c0938
	ctx.lr = 0x826CD794;
	sub_822C0938(ctx, base);
	// 826CD794: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CD798: 41820028  beq 0x826cd7c0
	if ctx.cr[0].eq {
	pc = 0x826CD7C0; continue 'dispatch;
	}
	// 826CD79C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CD7A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826CD7A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826CD7A8: 392B8A08  addi r9, r11, -0x75f8
	ctx.r[9].s64 = ctx.r[11].s64 + -30200;
	// 826CD7AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826CD7B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CD7B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826CD7B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826CD7BC: 48000008  b 0x826cd7c4
	pc = 0x826CD7C4; continue 'dispatch;
	// 826CD7C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CD7C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CD7C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CD7CC: 409A0044  bne cr6, 0x826cd810
	if !ctx.cr[6].eq {
	pc = 0x826CD810; continue 'dispatch;
	}
	// 826CD7D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CD7D4: 419A001C  beq cr6, 0x826cd7f0
	if ctx.cr[6].eq {
	pc = 0x826CD7F0; continue 'dispatch;
	}
	// 826CD7D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CD7DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CD7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD7E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CD7E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CD7EC: 4E800421  bctrl
	ctx.lr = 0x826CD7F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CD7F0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CD7F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CD7F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CD7FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826CD800: 816BCBC8  lwz r11, -0x3438(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13368 as u32) ) } as u64;
	// 826CD804: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CD808: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CD80C: 4BBF27F5  bl 0x822c0000
	ctx.lr = 0x826CD810;
	sub_822C0000(ctx, base);
	// 826CD810: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CD814: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CD818: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CD81C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CD820: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CD824: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CD828: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CD830 size=168
    let mut pc: u32 = 0x826CD830;
    'dispatch: loop {
        match pc {
            0x826CD830 => {
    //   block [0x826CD830..0x826CD8D8)
	// 826CD830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CD834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CD838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CD83C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CD840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CD844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CD848: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CD84C: 4BE44AE5  bl 0x82512330
	ctx.lr = 0x826CD850;
	sub_82512330(ctx, base);
	// 826CD850: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CD854: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CD858: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 826CD85C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CD860: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 826CD864: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 826CD868: 394A8A7C  addi r10, r10, -0x7584
	ctx.r[10].s64 = ctx.r[10].s64 + -30084;
	// 826CD86C: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 826CD870: 39298A68  addi r9, r9, -0x7598
	ctx.r[9].s64 = ctx.r[9].s64 + -30104;
	// 826CD874: 39088A1C  addi r8, r8, -0x75e4
	ctx.r[8].s64 = ctx.r[8].s64 + -30180;
	// 826CD878: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826CD87C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CD880: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 826CD884: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 826CD888: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CD88C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826CD890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD894: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826CD898: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826CD89C: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826CD8A0: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826CD8A4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CD8A8: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826CD8AC: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826CD8B0: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826CD8B4: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 826CD8B8: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 826CD8BC: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826CD8C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CD8C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CD8C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CD8CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CD8D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CD8D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CD8D8 size=8
    let mut pc: u32 = 0x826CD8D8;
    'dispatch: loop {
        match pc {
            0x826CD8D8 => {
    //   block [0x826CD8D8..0x826CD8E0)
	// 826CD8D8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826CD8DC: 48000124  b 0x826cda00
	sub_826CDA00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CD8E0 size=8
    let mut pc: u32 = 0x826CD8E0;
    'dispatch: loop {
        match pc {
            0x826CD8E0 => {
    //   block [0x826CD8E0..0x826CD8E8)
	// 826CD8E0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826CD8E4: 4800011C  b 0x826cda00
	sub_826CDA00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CD8E8 size=168
    let mut pc: u32 = 0x826CD8E8;
    'dispatch: loop {
        match pc {
            0x826CD8E8 => {
    //   block [0x826CD8E8..0x826CD990)
	// 826CD8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CD8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CD8F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CD8F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CD8F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CD8FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CD900: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CD904: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CD908: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CD90C: 396B8A7C  addi r11, r11, -0x7584
	ctx.r[11].s64 = ctx.r[11].s64 + -30084;
	// 826CD910: 394A8A68  addi r10, r10, -0x7598
	ctx.r[10].s64 = ctx.r[10].s64 + -30104;
	// 826CD914: 39298A1C  addi r9, r9, -0x75e4
	ctx.r[9].s64 = ctx.r[9].s64 + -30180;
	// 826CD918: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CD91C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826CD920: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 826CD924: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826CD928: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826CD92C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CD930: 419A0008  beq cr6, 0x826cd938
	if ctx.cr[6].eq {
	pc = 0x826CD938; continue 'dispatch;
	}
	// 826CD934: 4BBF2F5D  bl 0x822c0890
	ctx.lr = 0x826CD938;
	sub_822C0890(ctx, base);
	// 826CD938: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826CD93C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CD940: 419A0008  beq cr6, 0x826cd948
	if ctx.cr[6].eq {
	pc = 0x826CD948; continue 'dispatch;
	}
	// 826CD944: 4BBF2F4D  bl 0x822c0890
	ctx.lr = 0x826CD948;
	sub_822C0890(ctx, base);
	// 826CD948: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 826CD94C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CD950: 419A0008  beq cr6, 0x826cd958
	if ctx.cr[6].eq {
	pc = 0x826CD958; continue 'dispatch;
	}
	// 826CD954: 4BBF2F3D  bl 0x822c0890
	ctx.lr = 0x826CD958;
	sub_822C0890(ctx, base);
	// 826CD958: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826CD95C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CD960: 419A0008  beq cr6, 0x826cd968
	if ctx.cr[6].eq {
	pc = 0x826CD968; continue 'dispatch;
	}
	// 826CD964: 4BBF2F2D  bl 0x822c0890
	ctx.lr = 0x826CD968;
	sub_822C0890(ctx, base);
	// 826CD968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CD96C: 480D9CED  bl 0x827a7658
	ctx.lr = 0x826CD970;
	sub_827A7658(ctx, base);
	// 826CD970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD974: 4BC819DD  bl 0x8234f350
	ctx.lr = 0x826CD978;
	sub_8234F350(ctx, base);
	// 826CD978: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CD97C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CD980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CD984: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CD988: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CD98C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CD990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CD990 size=108
    let mut pc: u32 = 0x826CD990;
    'dispatch: loop {
        match pc {
            0x826CD990 => {
    //   block [0x826CD990..0x826CD9FC)
	// 826CD990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CD994: 48ADA7D9  bl 0x831a816c
	ctx.lr = 0x826CD998;
	sub_831A8130(ctx, base);
	// 826CD998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CD99C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826CD9A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826CD9A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CD9A8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CD9AC: 41820038  beq 0x826cd9e4
	if ctx.cr[0].eq {
	pc = 0x826CD9E4; continue 'dispatch;
	}
	// 826CD9B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CD9B4: 48ADBFD5  bl 0x831a9988
	ctx.lr = 0x826CD9B8;
	sub_831A9988(ctx, base);
	// 826CD9B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826CD9BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CD9C0: 386B3A70  addi r3, r11, 0x3a70
	ctx.r[3].s64 = ctx.r[11].s64 + 14960;
	// 826CD9C4: 48ADA735  bl 0x831a80f8
	ctx.lr = 0x826CD9C8;
	sub_831A80F8(ctx, base);
	// 826CD9C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CD9CC: 41820018  beq 0x826cd9e4
	if ctx.cr[0].eq {
	pc = 0x826CD9E4; continue 'dispatch;
	}
	// 826CD9D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CD9D4: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 826CD9D8: 4BFCAC91  bl 0x82698668
	ctx.lr = 0x826CD9DC;
	sub_82698668(ctx, base);
	// 826CD9DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826CD9E0: 48000014  b 0x826cd9f4
	pc = 0x826CD9F4; continue 'dispatch;
	// 826CD9E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CD9E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CD9EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CD9F0: 4BE44C29  bl 0x82512618
	ctx.lr = 0x826CD9F4;
	sub_82512618(ctx, base);
	// 826CD9F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CD9F8: 48ADA7C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CDA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CDA00 size=76
    let mut pc: u32 = 0x826CDA00;
    'dispatch: loop {
        match pc {
            0x826CDA00 => {
    //   block [0x826CDA00..0x826CDA4C)
	// 826CDA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CDA04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CDA08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CDA0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CDA10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CDA14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CDA18: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CDA1C: 4BFFFECD  bl 0x826cd8e8
	ctx.lr = 0x826CDA20;
	sub_826CD8E8(ctx, base);
	// 826CDA20: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CDA24: 4182000C  beq 0x826cda30
	if ctx.cr[0].eq {
	pc = 0x826CDA30; continue 'dispatch;
	}
	// 826CDA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CDA2C: 487249AD  bl 0x82df23d8
	ctx.lr = 0x826CDA30;
	sub_82DF23D8(ctx, base);
	// 826CDA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CDA34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CDA38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CDA3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CDA40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CDA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CDA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CDA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CDA50 size=416
    let mut pc: u32 = 0x826CDA50;
    'dispatch: loop {
        match pc {
            0x826CDA50 => {
    //   block [0x826CDA50..0x826CDBF0)
	// 826CDA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CDA54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CDA58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CDA5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CDA60: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826CDA64: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CDA68: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CDA6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CDA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CDA74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CDA78: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CDA7C: 388B2BF0  addi r4, r11, 0x2bf0
	ctx.r[4].s64 = ctx.r[11].s64 + 11248;
	// 826CDA80: 48725F89  bl 0x82df3a08
	ctx.lr = 0x826CDA84;
	sub_82DF3A08(ctx, base);
	// 826CDA84: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CDA88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDA8C: 388BD2C0  addi r4, r11, -0x2d40
	ctx.r[4].s64 = ctx.r[11].s64 + -11584;
	// 826CDA90: 48725F79  bl 0x82df3a08
	ctx.lr = 0x826CDA94;
	sub_82DF3A08(ctx, base);
	// 826CDA94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CDA98: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826CDA9C: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826CDAA0: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 826CDAA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CDAA8: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CDAAC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CDAB0: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CDAB4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CDAB8: C04A6218  lfs f2, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CDABC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826CDAC0: 4BEDFFF9  bl 0x825adab8
	ctx.lr = 0x826CDAC4;
	sub_825ADAB8(ctx, base);
	// 826CDAC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CDAC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CDACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDAD0: 4BED3B81  bl 0x825a1650
	ctx.lr = 0x826CDAD4;
	sub_825A1650(ctx, base);
	// 826CDAD4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826CDAD8: 48725951  bl 0x82df3428
	ctx.lr = 0x826CDADC;
	sub_82DF3428(ctx, base);
	// 826CDADC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CDAE0: 4BBFB1D9  bl 0x822c8cb8
	ctx.lr = 0x826CDAE4;
	sub_822C8CB8(ctx, base);
	// 826CDAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDAE8: 48725941  bl 0x82df3428
	ctx.lr = 0x826CDAEC;
	sub_82DF3428(ctx, base);
	// 826CDAEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CDAF0: 48725939  bl 0x82df3428
	ctx.lr = 0x826CDAF4;
	sub_82DF3428(ctx, base);
	// 826CDAF4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CDAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDAFC: 388B8ACC  addi r4, r11, -0x7534
	ctx.r[4].s64 = ctx.r[11].s64 + -30004;
	// 826CDB00: 48725F09  bl 0x82df3a08
	ctx.lr = 0x826CDB04;
	sub_82DF3A08(ctx, base);
	// 826CDB04: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CDB08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CDB0C: 388B8AB8  addi r4, r11, -0x7548
	ctx.r[4].s64 = ctx.r[11].s64 + -30024;
	// 826CDB10: 48725EF9  bl 0x82df3a08
	ctx.lr = 0x826CDB14;
	sub_82DF3A08(ctx, base);
	// 826CDB14: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826CDB18: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826CDB1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CDB20: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 826CDB24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDB28: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826CDB2C: 4BEE0065  bl 0x825adb90
	ctx.lr = 0x826CDB30;
	sub_825ADB90(ctx, base);
	// 826CDB30: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CDB34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CDB38: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CDB3C: 4BED427D  bl 0x825a1db8
	ctx.lr = 0x826CDB40;
	sub_825A1DB8(ctx, base);
	// 826CDB40: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826CDB44: 487258E5  bl 0x82df3428
	ctx.lr = 0x826CDB48;
	sub_82DF3428(ctx, base);
	// 826CDB48: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826CDB4C: 4BBFB16D  bl 0x822c8cb8
	ctx.lr = 0x826CDB50;
	sub_822C8CB8(ctx, base);
	// 826CDB50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CDB54: 487258D5  bl 0x82df3428
	ctx.lr = 0x826CDB58;
	sub_82DF3428(ctx, base);
	// 826CDB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDB5C: 487258CD  bl 0x82df3428
	ctx.lr = 0x826CDB60;
	sub_82DF3428(ctx, base);
	// 826CDB60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CDB64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDB68: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826CDB6C: 48725E9D  bl 0x82df3a08
	ctx.lr = 0x826CDB70;
	sub_82DF3A08(ctx, base);
	// 826CDB70: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CDB74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CDB78: 388BA13C  addi r4, r11, -0x5ec4
	ctx.r[4].s64 = ctx.r[11].s64 + -24260;
	// 826CDB7C: 48725E8D  bl 0x82df3a08
	ctx.lr = 0x826CDB80;
	sub_82DF3A08(ctx, base);
	// 826CDB80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CDB84: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 826CDB88: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CDB8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDB90: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826CDB94: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826CDB98: C04B9584  lfs f2, -0x6a7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CDB9C: 4BEDFF1D  bl 0x825adab8
	ctx.lr = 0x826CDBA0;
	sub_825ADAB8(ctx, base);
	// 826CDBA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CDBA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CDBA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CDBAC: 4BED3AA5  bl 0x825a1650
	ctx.lr = 0x826CDBB0;
	sub_825A1650(ctx, base);
	// 826CDBB0: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826CDBB4: 48725875  bl 0x82df3428
	ctx.lr = 0x826CDBB8;
	sub_82DF3428(ctx, base);
	// 826CDBB8: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826CDBBC: 4BBFB0FD  bl 0x822c8cb8
	ctx.lr = 0x826CDBC0;
	sub_822C8CB8(ctx, base);
	// 826CDBC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CDBC4: 48725865  bl 0x82df3428
	ctx.lr = 0x826CDBC8;
	sub_82DF3428(ctx, base);
	// 826CDBC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDBCC: 4872585D  bl 0x82df3428
	ctx.lr = 0x826CDBD0;
	sub_82DF3428(ctx, base);
	// 826CDBD0: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 826CDBD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CDBD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CDBDC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826CDBE0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826CDBE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CDBE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CDBEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CDBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CDBF0 size=1740
    let mut pc: u32 = 0x826CDBF0;
    'dispatch: loop {
        match pc {
            0x826CDBF0 => {
    //   block [0x826CDBF0..0x826CE2BC)
	// 826CDBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CDBF4: 48ADA559  bl 0x831a814c
	ctx.lr = 0x826CDBF8;
	sub_831A8130(ctx, base);
	// 826CDBF8: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 826CDBFC: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CDC00: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 826CDC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CDC08: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 826CDC0C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 826CDC10: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826CDC14: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 826CDC18: 4BE43DC1  bl 0x825119d8
	ctx.lr = 0x826CDC1C;
	sub_825119D8(ctx, base);
	// 826CDC1C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CDC20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDC24: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826CDC28: 48725DE1  bl 0x82df3a08
	ctx.lr = 0x826CDC2C;
	sub_82DF3A08(ctx, base);
	// 826CDC2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CDC30: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826CDC34: 4BE41895  bl 0x8250f4c8
	ctx.lr = 0x826CDC38;
	sub_8250F4C8(ctx, base);
	// 826CDC38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDC40: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CDC44: 409A0008  bne cr6, 0x826cdc4c
	if !ctx.cr[6].eq {
	pc = 0x826CDC4C; continue 'dispatch;
	}
	// 826CDC48: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826CDC4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CDC50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDC54: 4BE3AB2D  bl 0x82508780
	ctx.lr = 0x826CDC58;
	sub_82508780(ctx, base);
	// 826CDC58: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826CDC5C: 48724035  bl 0x82df1c90
	ctx.lr = 0x826CDC60;
	sub_82DF1C90(ctx, base);
	// 826CDC60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDC64: 487257C5  bl 0x82df3428
	ctx.lr = 0x826CDC68;
	sub_82DF3428(ctx, base);
	// 826CDC68: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826CDC6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDC70: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 826CDC74: 48725D95  bl 0x82df3a08
	ctx.lr = 0x826CDC78;
	sub_82DF3A08(ctx, base);
	// 826CDC78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CDC7C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826CDC80: 4BE41849  bl 0x8250f4c8
	ctx.lr = 0x826CDC84;
	sub_8250F4C8(ctx, base);
	// 826CDC84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDC88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDC8C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CDC90: 409A0008  bne cr6, 0x826cdc98
	if !ctx.cr[6].eq {
	pc = 0x826CDC98; continue 'dispatch;
	}
	// 826CDC94: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826CDC98: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CDC9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDCA0: 4BE3AAE1  bl 0x82508780
	ctx.lr = 0x826CDCA4;
	sub_82508780(ctx, base);
	// 826CDCA4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826CDCA8: 48723FE9  bl 0x82df1c90
	ctx.lr = 0x826CDCAC;
	sub_82DF1C90(ctx, base);
	// 826CDCAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDCB0: 48725779  bl 0x82df3428
	ctx.lr = 0x826CDCB4;
	sub_82DF3428(ctx, base);
	// 826CDCB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CDCB8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826CDCBC: 409A0008  bne cr6, 0x826cdcc4
	if !ctx.cr[6].eq {
	pc = 0x826CDCC4; continue 'dispatch;
	}
	// 826CDCC0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826CDCC4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826CDCC8: 4BE3AAD9  bl 0x825087a0
	ctx.lr = 0x826CDCCC;
	sub_825087A0(ctx, base);
	// 826CDCCC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CDCD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CDCD4: 3B2B8AF0  addi r25, r11, -0x7510
	ctx.r[25].s64 = ctx.r[11].s64 + -29968;
	// 826CDCD8: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 826CDCDC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826CDCE0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826CDCE4: 48724705  bl 0x82df23e8
	ctx.lr = 0x826CDCE8;
	sub_82DF23E8(ctx, base);
	// 826CDCE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CDCEC: 41820018  beq 0x826cdd04
	if ctx.cr[0].eq {
	pc = 0x826CDD04; continue 'dispatch;
	}
	// 826CDCF0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CDCF4: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 826CDCF8: 487453F9  bl 0x82e130f0
	ctx.lr = 0x826CDCFC;
	sub_82E130F0(ctx, base);
	// 826CDCFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CDD00: 48000008  b 0x826cdd08
	pc = 0x826CDD08; continue 'dispatch;
	// 826CDD04: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826CDD08: 3B5F0104  addi r26, r31, 0x104
	ctx.r[26].s64 = ctx.r[31].s64 + 260;
	// 826CDD0C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826CDD10: 4BC14041  bl 0x822e1d50
	ctx.lr = 0x826CDD14;
	sub_822E1D50(ctx, base);
	// 826CDD14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CDD18: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826CDD1C: 83DF0104  lwz r30, 0x104(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826CDD20: 4BE443F9  bl 0x82512118
	ctx.lr = 0x826CDD24;
	sub_82512118(ctx, base);
	// 826CDD24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CDD28: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDD2C: 48745105  bl 0x82e12e30
	ctx.lr = 0x826CDD30;
	sub_82E12E30(ctx, base);
	// 826CDD30: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 826CDD34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CDD38: 419A0008  beq cr6, 0x826cdd40
	if ctx.cr[6].eq {
	pc = 0x826CDD40; continue 'dispatch;
	}
	// 826CDD3C: 4BBF2B55  bl 0x822c0890
	ctx.lr = 0x826CDD40;
	sub_822C0890(ctx, base);
	// 826CDD40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CDD44: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDD48: 4875CDA1  bl 0x82e2aae8
	ctx.lr = 0x826CDD4C;
	sub_82E2AAE8(ctx, base);
	// 826CDD4C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CDD50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDD54: 3BABCBA4  addi r29, r11, -0x345c
	ctx.r[29].s64 = ctx.r[11].s64 + -13404;
	// 826CDD58: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CDD5C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826CDD60: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 826CDD64: 48725CA5  bl 0x82df3a08
	ctx.lr = 0x826CDD68;
	sub_82DF3A08(ctx, base);
	// 826CDD68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CDD6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CDD70: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826CDD74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CDD78: 487610F9  bl 0x82e2ee70
	ctx.lr = 0x826CDD7C;
	sub_82E2EE70(ctx, base);
	// 826CDD7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDD80: 487256A9  bl 0x82df3428
	ctx.lr = 0x826CDD84;
	sub_82DF3428(ctx, base);
	// 826CDD84: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826CDD88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDD8C: 419A00B0  beq cr6, 0x826cde3c
	if ctx.cr[6].eq {
	pc = 0x826CDE3C; continue 'dispatch;
	}
	// 826CDD90: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826CDD94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CDD98: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 826CDD9C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826CDDA0: 48724649  bl 0x82df23e8
	ctx.lr = 0x826CDDA4;
	sub_82DF23E8(ctx, base);
	// 826CDDA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CDDA8: 41820014  beq 0x826cddbc
	if ctx.cr[0].eq {
	pc = 0x826CDDBC; continue 'dispatch;
	}
	// 826CDDAC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CDDB0: 48748AE1  bl 0x82e16890
	ctx.lr = 0x826CDDB4;
	sub_82E16890(ctx, base);
	// 826CDDB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CDDB8: 48000008  b 0x826cddc0
	pc = 0x826CDDC0; continue 'dispatch;
	// 826CDDBC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826CDDC0: 3BDF00EC  addi r30, r31, 0xec
	ctx.r[30].s64 = ctx.r[31].s64 + 236;
	// 826CDDC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CDDC8: 4BC8F5A9  bl 0x8235d370
	ctx.lr = 0x826CDDCC;
	sub_8235D370(ctx, base);
	// 826CDDCC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CDDD0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDDD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CDDDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CDDE0: 419A0024  beq cr6, 0x826cde04
	if ctx.cr[6].eq {
	pc = 0x826CDE04; continue 'dispatch;
	}
	// 826CDDE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CDDE8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CDDEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CDDF0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CDDF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CDDF8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CDDFC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CDE00: 4082FFE8  bne 0x826cdde8
	if !ctx.cr[0].eq {
	pc = 0x826CDDE8; continue 'dispatch;
	}
	// 826CDE04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDE08: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDE0C: 487472A5  bl 0x82e150b0
	ctx.lr = 0x826CDE10;
	sub_82E150B0(ctx, base);
	// 826CDE10: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 826CDE14: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 826CDE18: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 826CDE1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CDE20: 4E800421  bctrl
	ctx.lr = 0x826CDE24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CDE24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826CDE28: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826CDE2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CDE30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CDE34: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826CDE38: 4BE42D21  bl 0x82510b58
	ctx.lr = 0x826CDE3C;
	sub_82510B58(ctx, base);
	// 826CDE3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CDE40: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826CDE44: 4BE41685  bl 0x8250f4c8
	ctx.lr = 0x826CDE48;
	sub_8250F4C8(ctx, base);
	// 826CDE48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDE4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDE50: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CDE54: 409A0008  bne cr6, 0x826cde5c
	if !ctx.cr[6].eq {
	pc = 0x826CDE5C; continue 'dispatch;
	}
	// 826CDE58: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826CDE5C: 4BE3A6CD  bl 0x82508528
	ctx.lr = 0x826CDE60;
	sub_82508528(ctx, base);
	// 826CDE60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CDE64: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CDE68: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDE6C: 4BC1939D  bl 0x822e7208
	ctx.lr = 0x826CDE70;
	sub_822E7208(ctx, base);
	// 826CDE70: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826CDE74: 48723E1D  bl 0x82df1c90
	ctx.lr = 0x826CDE78;
	sub_82DF1C90(ctx, base);
	// 826CDE78: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CDE7C: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 826CDE80: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CDE84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDE88: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826CDE8C: 48725B7D  bl 0x82df3a08
	ctx.lr = 0x826CDE90;
	sub_82DF3A08(ctx, base);
	// 826CDE90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CDE94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CDE98: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826CDE9C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826CDEA0: 4BC194F1  bl 0x822e7390
	ctx.lr = 0x826CDEA4;
	sub_822E7390(ctx, base);
	// 826CDEA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDEA8: 48725581  bl 0x82df3428
	ctx.lr = 0x826CDEAC;
	sub_82DF3428(ctx, base);
	// 826CDEAC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826CDEB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDEB4: 419A03CC  beq cr6, 0x826ce280
	if ctx.cr[6].eq {
	pc = 0x826CE280; continue 'dispatch;
	}
	// 826CDEB8: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CDEBC: 395D000C  addi r10, r29, 0xc
	ctx.r[10].s64 = ctx.r[29].s64 + 12;
	// 826CDEC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDEC4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826CDEC8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826CDECC: 48725B3D  bl 0x82df3a08
	ctx.lr = 0x826CDED0;
	sub_82DF3A08(ctx, base);
	// 826CDED0: 38DF0028  addi r6, r31, 0x28
	ctx.r[6].s64 = ctx.r[31].s64 + 40;
	// 826CDED4: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826CDED8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CDEDC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826CDEE0: 4BC207F9  bl 0x822ee6d8
	ctx.lr = 0x826CDEE4;
	sub_822EE6D8(ctx, base);
	// 826CDEE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CDEE8: 3BDF00F4  addi r30, r31, 0xf4
	ctx.r[30].s64 = ctx.r[31].s64 + 244;
	// 826CDEEC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826CDEF0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826CDEF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDEF8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826CDEFC: 4BBF6565  bl 0x822c4460
	ctx.lr = 0x826CDF00;
	sub_822C4460(ctx, base);
	// 826CDF00: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826CDF04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CDF08: 419A0008  beq cr6, 0x826cdf10
	if ctx.cr[6].eq {
	pc = 0x826CDF10; continue 'dispatch;
	}
	// 826CDF0C: 4BBF2985  bl 0x822c0890
	ctx.lr = 0x826CDF10;
	sub_822C0890(ctx, base);
	// 826CDF10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDF14: 48725515  bl 0x82df3428
	ctx.lr = 0x826CDF18;
	sub_82DF3428(ctx, base);
	// 826CDF18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDF1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDF20: 419A0360  beq cr6, 0x826ce280
	if ctx.cr[6].eq {
	pc = 0x826CE280; continue 'dispatch;
	}
	// 826CDF24: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CDF28: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CDF30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CDF34: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CDF38: 419A0024  beq cr6, 0x826cdf5c
	if ctx.cr[6].eq {
	pc = 0x826CDF5C; continue 'dispatch;
	}
	// 826CDF3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CDF40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CDF44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CDF48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CDF4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CDF50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CDF54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CDF58: 4082FFE8  bne 0x826cdf40
	if !ctx.cr[0].eq {
	pc = 0x826CDF40; continue 'dispatch;
	}
	// 826CDF5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CDF60: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDF64: 4BC1FFFD  bl 0x822edf60
	ctx.lr = 0x826CDF68;
	sub_822EDF60(ctx, base);
	// 826CDF68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CDF6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CDF70: 4BE42DD1  bl 0x82510d40
	ctx.lr = 0x826CDF74;
	sub_82510D40(ctx, base);
	// 826CDF74: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826CDF78: 3880200E  li r4, 0x200e
	ctx.r[4].s64 = 8206;
	// 826CDF7C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDF80: 4BDC1231  bl 0x8248f1b0
	ctx.lr = 0x826CDF84;
	sub_8248F1B0(ctx, base);
	// 826CDF84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CDF88: 393D0018  addi r9, r29, 0x18
	ctx.r[9].s64 = ctx.r[29].s64 + 24;
	// 826CDF8C: 394B9BC9  addi r10, r11, -0x6437
	ctx.r[10].s64 = ctx.r[11].s64 + -25655;
	// 826CDF90: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CDF94: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826CDF98: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 826CDF9C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDFA0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDFA4: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 826CDFA8: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 826CDFAC: 41820014  beq 0x826cdfc0
	if ctx.cr[0].eq {
	pc = 0x826CDFC0; continue 'dispatch;
	}
	// 826CDFB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 826CDFB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CDFB8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826CDFBC: 419AFFE0  beq cr6, 0x826cdf9c
	if ctx.cr[6].eq {
	pc = 0x826CDF9C; continue 'dispatch;
	}
	// 826CDFC0: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 826CDFC4: 4182021C  beq 0x826ce1e0
	if ctx.cr[0].eq {
	pc = 0x826CE1E0; continue 'dispatch;
	}
	// 826CDFC8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CDFCC: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CDFD0: 4BC03DB1  bl 0x822d1d80
	ctx.lr = 0x826CDFD4;
	sub_822D1D80(ctx, base);
	// 826CDFD4: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 826CDFD8: 397D0018  addi r11, r29, 0x18
	ctx.r[11].s64 = ctx.r[29].s64 + 24;
	// 826CDFDC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CDFE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CDFE4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826CDFE8: 48725A21  bl 0x82df3a08
	ctx.lr = 0x826CDFEC;
	sub_82DF3A08(ctx, base);
	// 826CDFEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CDFF0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CDFF4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826CDFF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826CDFFC: 4BC03F0D  bl 0x822d1f08
	ctx.lr = 0x826CE000;
	sub_822D1F08(ctx, base);
	// 826CE000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE004: 48725425  bl 0x82df3428
	ctx.lr = 0x826CE008;
	sub_82DF3428(ctx, base);
	// 826CE008: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826CE00C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE010: 419A006C  beq cr6, 0x826ce07c
	if ctx.cr[6].eq {
	pc = 0x826CE07C; continue 'dispatch;
	}
	// 826CE014: 487307CD  bl 0x82dfe7e0
	ctx.lr = 0x826CE018;
	sub_82DFE7E0(ctx, base);
	// 826CE018: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CE01C: 40820060  bne 0x826ce07c
	if !ctx.cr[0].eq {
	pc = 0x826CE07C; continue 'dispatch;
	}
	// 826CE020: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CE024: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826CE028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CE02C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CE030: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CE034: 419A0024  beq cr6, 0x826ce058
	if ctx.cr[6].eq {
	pc = 0x826CE058; continue 'dispatch;
	}
	// 826CE038: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CE03C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CE040: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE044: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CE048: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CE04C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CE050: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE054: 4082FFE8  bne 0x826ce03c
	if !ctx.cr[0].eq {
	pc = 0x826CE03C; continue 'dispatch;
	}
	// 826CE058: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826CE05C: 4BE1CA2D  bl 0x824eaa88
	ctx.lr = 0x826CE060;
	sub_824EAA88(ctx, base);
	// 826CE060: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 826CE064: 38C0009B  li r6, 0x9b
	ctx.r[6].s64 = 155;
	// 826CE068: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CE06C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE070: 484EC111  bl 0x82bba180
	ctx.lr = 0x826CE074;
	sub_82BBA180(ctx, base);
	// 826CE074: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826CE078: 48723C19  bl 0x82df1c90
	ctx.lr = 0x826CE07C;
	sub_82DF1C90(ctx, base);
	// 826CE07C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826CE080: 4BC01369  bl 0x822cf3e8
	ctx.lr = 0x826CE084;
	sub_822CF3E8(ctx, base);
	// 826CE084: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826CE088: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 826CE08C: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 826CE090: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 826CE094: 41820134  beq 0x826ce1c8
	if ctx.cr[0].eq {
	pc = 0x826CE1C8; continue 'dispatch;
	}
	// 826CE098: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CE09C: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 826CE0A0: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CE0A4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826CE0A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CE0AC: 38A000A0  li r5, 0xa0
	ctx.r[5].s64 = 160;
	// 826CE0B0: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826CE0B4: 48724335  bl 0x82df23e8
	ctx.lr = 0x826CE0B8;
	sub_82DF23E8(ctx, base);
	// 826CE0B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CE0BC: 41820064  beq 0x826ce120
	if ctx.cr[0].eq {
	pc = 0x826CE120; continue 'dispatch;
	}
	// 826CE0C0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826CE0C4: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CE0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CE0CC: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 826CE0D0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 826CE0D4: 419A0024  beq cr6, 0x826ce0f8
	if ctx.cr[6].eq {
	pc = 0x826CE0F8; continue 'dispatch;
	}
	// 826CE0D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826CE0DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CE0E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE0E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CE0E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CE0EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CE0F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE0F4: 4082FFE8  bne 0x826ce0dc
	if !ctx.cr[0].eq {
	pc = 0x826CE0DC; continue 'dispatch;
	}
	// 826CE0F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826CE0FC: 80DB6824  lwz r6, 0x6824(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826CE100: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 826CE104: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE108: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CE10C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826CE110: 63180001  ori r24, r24, 1
	ctx.r[24].u64 = ctx.r[24].u64 | 1;
	// 826CE114: 4BC13A4D  bl 0x822e1b60
	ctx.lr = 0x826CE118;
	sub_822E1B60(ctx, base);
	// 826CE118: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE11C: 48000008  b 0x826ce124
	pc = 0x826CE124; continue 'dispatch;
	// 826CE120: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826CE124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE128: 48004339  bl 0x826d2460
	ctx.lr = 0x826CE12C;
	sub_826D2460(ctx, base);
	// 826CE12C: 570B07FF  clrlwi. r11, r24, 0x1f
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CE130: 41820018  beq 0x826ce148
	if ctx.cr[0].eq {
	pc = 0x826CE148; continue 'dispatch;
	}
	// 826CE134: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826CE138: 5718003C  rlwinm r24, r24, 0, 0, 0x1e
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 826CE13C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE140: 419A0008  beq cr6, 0x826ce148
	if ctx.cr[6].eq {
	pc = 0x826CE148; continue 'dispatch;
	}
	// 826CE144: 4BBF274D  bl 0x822c0890
	ctx.lr = 0x826CE148;
	sub_822C0890(ctx, base);
	// 826CE148: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CE14C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CE150: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CE154: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 826CE158: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 826CE15C: 419A0024  beq cr6, 0x826ce180
	if ctx.cr[6].eq {
	pc = 0x826CE180; continue 'dispatch;
	}
	// 826CE160: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826CE164: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CE168: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE16C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CE170: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CE174: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CE178: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE17C: 4082FFE8  bne 0x826ce164
	if !ctx.cr[0].eq {
	pc = 0x826CE164; continue 'dispatch;
	}
	// 826CE180: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE184: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826CE188: 3AA10090  addi r21, r1, 0x90
	ctx.r[21].s64 = ctx.r[1].s64 + 144;
	// 826CE18C: 4BE4138D  bl 0x8250f518
	ctx.lr = 0x826CE190;
	sub_8250F518(ctx, base);
	// 826CE190: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE194: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826CE198: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 826CE19C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826CE1A0: 4BE3F369  bl 0x8250d508
	ctx.lr = 0x826CE1A4;
	sub_8250D508(ctx, base);
	// 826CE1A4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826CE1A8: 48723AE9  bl 0x82df1c90
	ctx.lr = 0x826CE1AC;
	sub_82DF1C90(ctx, base);
	// 826CE1AC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 826CE1B0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 826CE1B4: 4198FEF0  blt cr6, 0x826ce0a4
	if ctx.cr[6].lt {
	pc = 0x826CE0A4; continue 'dispatch;
	}
	// 826CE1B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CE1BC: 419A000C  beq cr6, 0x826ce1c8
	if ctx.cr[6].eq {
	pc = 0x826CE1C8; continue 'dispatch;
	}
	// 826CE1C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CE1C4: 4BBF26CD  bl 0x822c0890
	ctx.lr = 0x826CE1C8;
	sub_822C0890(ctx, base);
	// 826CE1C8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826CE1CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE1D0: 419A0008  beq cr6, 0x826ce1d8
	if ctx.cr[6].eq {
	pc = 0x826CE1D8; continue 'dispatch;
	}
	// 826CE1D4: 4BBF26BD  bl 0x822c0890
	ctx.lr = 0x826CE1D8;
	sub_822C0890(ctx, base);
	// 826CE1D8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826CE1DC: 4BC03BBD  bl 0x822d1d98
	ctx.lr = 0x826CE1E0;
	sub_822D1D98(ctx, base);
	// 826CE1E0: C01F010C  lfs f0, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE1E4: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826CE1E8: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 826CE1EC: C00BDFB0  lfs f0, -0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE1F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826CE1F4: 40980050  bge cr6, 0x826ce244
	if !ctx.cr[6].lt {
	pc = 0x826CE244; continue 'dispatch;
	}
	// 826CE1F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CE1FC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CE200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE204: 38AA8AD8  addi r5, r10, -0x7528
	ctx.r[5].s64 = ctx.r[10].s64 + -29992;
	// 826CE208: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826CE20C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 826CE210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CE214: 4E800421  bctrl
	ctx.lr = 0x826CE218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CE218: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CE21C: 395F00FC  addi r10, r31, 0xfc
	ctx.r[10].s64 = ctx.r[31].s64 + 252;
	// 826CE220: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826CE224: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826CE228: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CE22C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826CE230: 4BBF6231  bl 0x822c4460
	ctx.lr = 0x826CE234;
	sub_822C4460(ctx, base);
	// 826CE234: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 826CE238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE23C: 419A0008  beq cr6, 0x826ce244
	if ctx.cr[6].eq {
	pc = 0x826CE244; continue 'dispatch;
	}
	// 826CE240: 4BBF2651  bl 0x822c0890
	ctx.lr = 0x826CE244;
	sub_822C0890(ctx, base);
	// 826CE244: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE248: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826CE24C: 4BE4127D  bl 0x8250f4c8
	ctx.lr = 0x826CE250;
	sub_8250F4C8(ctx, base);
	// 826CE250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CE254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CE258: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CE25C: 409A0008  bne cr6, 0x826ce264
	if !ctx.cr[6].eq {
	pc = 0x826CE264; continue 'dispatch;
	}
	// 826CE260: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826CE264: 4BE3A2B5  bl 0x82508518
	ctx.lr = 0x826CE268;
	sub_82508518(ctx, base);
	// 826CE268: C01F0114  lfs f0, 0x114(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE26C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE270: EC21002A  fadds f1, f1, f0
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 826CE274: 4BFFF42D  bl 0x826cd6a0
	ctx.lr = 0x826CE278;
	sub_826CD6A0(ctx, base);
	// 826CE278: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 826CE27C: 48723A15  bl 0x82df1c90
	ctx.lr = 0x826CE280;
	sub_82DF1C90(ctx, base);
	// 826CE280: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826CE284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE288: 419A0008  beq cr6, 0x826ce290
	if ctx.cr[6].eq {
	pc = 0x826CE290; continue 'dispatch;
	}
	// 826CE28C: 4BBF2605  bl 0x822c0890
	ctx.lr = 0x826CE290;
	sub_822C0890(ctx, base);
	// 826CE290: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CE294: 4BC18F8D  bl 0x822e7220
	ctx.lr = 0x826CE298;
	sub_822E7220(ctx, base);
	// 826CE298: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826CE29C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE2A0: 419A0008  beq cr6, 0x826ce2a8
	if ctx.cr[6].eq {
	pc = 0x826CE2A8; continue 'dispatch;
	}
	// 826CE2A4: 4BBF25ED  bl 0x822c0890
	ctx.lr = 0x826CE2A8;
	sub_822C0890(ctx, base);
	// 826CE2A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CE2AC: 4875C855  bl 0x82e2ab00
	ctx.lr = 0x826CE2B0;
	sub_82E2AB00(ctx, base);
	// 826CE2B0: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 826CE2B4: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 826CE2B8: 48AD9EE4  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE2C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CE2C0 size=432
    let mut pc: u32 = 0x826CE2C0;
    'dispatch: loop {
        match pc {
            0x826CE2C0 => {
    //   block [0x826CE2C0..0x826CE470)
	// 826CE2C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE2C4: 48AD9EA1  bl 0x831a8164
	ctx.lr = 0x826CE2C8;
	sub_831A8130(ctx, base);
	// 826CE2C8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE2CC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE2D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826CE2D4: 3BCB8AF0  addi r30, r11, -0x7510
	ctx.r[30].s64 = ctx.r[11].s64 + -29968;
	// 826CE2D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CE2DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826CE2E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CE2E4: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 826CE2E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826CE2EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CE2F0: 38600118  li r3, 0x118
	ctx.r[3].s64 = 280;
	// 826CE2F4: 487240F5  bl 0x82df23e8
	ctx.lr = 0x826CE2F8;
	sub_82DF23E8(ctx, base);
	// 826CE2F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CE2FC: 41820014  beq 0x826ce310
	if ctx.cr[0].eq {
	pc = 0x826CE310; continue 'dispatch;
	}
	// 826CE300: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE304: 4BFFF52D  bl 0x826cd830
	ctx.lr = 0x826CE308;
	sub_826CD830(ctx, base);
	// 826CE308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CE30C: 48000008  b 0x826ce314
	pc = 0x826CE314; continue 'dispatch;
	// 826CE310: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CE314: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826CE318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE31C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CE320: 4BFFF449  bl 0x826cd768
	ctx.lr = 0x826CE324;
	sub_826CD768(ctx, base);
	// 826CE324: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CE328: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE32C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CE330: 4BBF1CD1  bl 0x822c0000
	ctx.lr = 0x826CE334;
	sub_822C0000(ctx, base);
	// 826CE334: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826CE338: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CE33C: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 826CE340: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826CE344: 4BBF2095  bl 0x822c03d8
	ctx.lr = 0x826CE348;
	sub_822C03D8(ctx, base);
	// 826CE348: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826CE34C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826CE350: 418200B4  beq 0x826ce404
	if ctx.cr[0].eq {
	pc = 0x826CE404; continue 'dispatch;
	}
	// 826CE354: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CE358: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826CE35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826CE360: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826CE364: 409A0008  bne cr6, 0x826ce36c
	if !ctx.cr[6].eq {
	pc = 0x826CE36C; continue 'dispatch;
	}
	// 826CE368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CE36C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826CE370: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CE374: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826CE378: 419A0024  beq cr6, 0x826ce39c
	if ctx.cr[6].eq {
	pc = 0x826CE39C; continue 'dispatch;
	}
	// 826CE37C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826CE380: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826CE384: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE388: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826CE38C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826CE390: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CE394: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE398: 4082FFE8  bne 0x826ce380
	if !ctx.cr[0].eq {
	pc = 0x826CE380; continue 'dispatch;
	}
	// 826CE39C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826CE3A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CE3A4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826CE3A8: 419A0024  beq cr6, 0x826ce3cc
	if ctx.cr[6].eq {
	pc = 0x826CE3CC; continue 'dispatch;
	}
	// 826CE3AC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826CE3B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CE3B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE3B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CE3BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CE3C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CE3C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CE3C8: 4082FFE8  bne 0x826ce3b0
	if !ctx.cr[0].eq {
	pc = 0x826CE3B0; continue 'dispatch;
	}
	// 826CE3CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CE3D0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826CE3D4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826CE3D8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826CE3DC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826CE3E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CE3E4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CE3E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CE3EC: 480CAB45  bl 0x82798f30
	ctx.lr = 0x826CE3F0;
	sub_82798F30(ctx, base);
	// 826CE3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE3F8: 480CD271  bl 0x8279b668
	ctx.lr = 0x826CE3FC;
	sub_8279B668(ctx, base);
	// 826CE3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CE400: 48000008  b 0x826ce408
	pc = 0x826CE408; continue 'dispatch;
	// 826CE404: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826CE408: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CE40C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826CE410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CE418: 4BEC9839  bl 0x82597c50
	ctx.lr = 0x826CE41C;
	sub_82597C50(ctx, base);
	// 826CE41C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CE420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CE424: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CE428: 4BBF1BD9  bl 0x822c0000
	ctx.lr = 0x826CE42C;
	sub_822C0000(ctx, base);
	// 826CE42C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CE430: 41820024  beq 0x826ce454
	if ctx.cr[0].eq {
	pc = 0x826CE454; continue 'dispatch;
	}
	// 826CE434: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826CE438: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE43C: 419A0008  beq cr6, 0x826ce444
	if ctx.cr[6].eq {
	pc = 0x826CE444; continue 'dispatch;
	}
	// 826CE440: 4BBF2451  bl 0x822c0890
	ctx.lr = 0x826CE444;
	sub_822C0890(ctx, base);
	// 826CE444: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826CE448: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CE44C: 419A0008  beq cr6, 0x826ce454
	if ctx.cr[6].eq {
	pc = 0x826CE454; continue 'dispatch;
	}
	// 826CE450: 4BBF2441  bl 0x822c0890
	ctx.lr = 0x826CE454;
	sub_822C0890(ctx, base);
	// 826CE454: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CE458: 419A000C  beq cr6, 0x826ce464
	if ctx.cr[6].eq {
	pc = 0x826CE464; continue 'dispatch;
	}
	// 826CE45C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CE460: 4BBF2431  bl 0x822c0890
	ctx.lr = 0x826CE464;
	sub_822C0890(ctx, base);
	// 826CE464: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826CE468: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826CE46C: 48AD9D48  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CE470 size=52
    let mut pc: u32 = 0x826CE470;
    'dispatch: loop {
        match pc {
            0x826CE470 => {
    //   block [0x826CE470..0x826CE4A4)
	// 826CE470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CE478: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CE47C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE480: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CE484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CE488: 4BFFFE39  bl 0x826ce2c0
	ctx.lr = 0x826CE48C;
	sub_826CE2C0(ctx, base);
	// 826CE48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE490: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CE494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CE498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CE49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CE4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CE4A8 size=52
    let mut pc: u32 = 0x826CE4A8;
    'dispatch: loop {
        match pc {
            0x826CE4A8 => {
    //   block [0x826CE4A8..0x826CE4DC)
	// 826CE4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CE4B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CE4B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE4B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CE4BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CE4C0: 4BFFFE01  bl 0x826ce2c0
	ctx.lr = 0x826CE4C4;
	sub_826CE2C0(ctx, base);
	// 826CE4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE4C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CE4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CE4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CE4D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CE4D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CE4E0 size=52
    let mut pc: u32 = 0x826CE4E0;
    'dispatch: loop {
        match pc {
            0x826CE4E0 => {
    //   block [0x826CE4E0..0x826CE514)
	// 826CE4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CE4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CE4EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE4F0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826CE4F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CE4F8: 4BFFFDC9  bl 0x826ce2c0
	ctx.lr = 0x826CE4FC;
	sub_826CE2C0(ctx, base);
	// 826CE4FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE500: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CE504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CE508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CE50C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CE510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CE518 size=456
    let mut pc: u32 = 0x826CE518;
    'dispatch: loop {
        match pc {
            0x826CE518 => {
    //   block [0x826CE518..0x826CE6E0)
	// 826CE518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE51C: 48AD9C41  bl 0x831a815c
	ctx.lr = 0x826CE520;
	sub_831A8130(ctx, base);
	// 826CE520: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE524: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CE528: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CE52C: 4BFD696D  bl 0x826a4e98
	ctx.lr = 0x826CE530;
	sub_826A4E98(ctx, base);
	// 826CE530: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE538: 3BAB8CCC  addi r29, r11, -0x7334
	ctx.r[29].s64 = ctx.r[11].s64 + -29492;
	// 826CE53C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE540: 487254C9  bl 0x82df3a08
	ctx.lr = 0x826CE544;
	sub_82DF3A08(ctx, base);
	// 826CE544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE548: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826CE54C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE550: 4BED3039  bl 0x825a1588
	ctx.lr = 0x826CE554;
	sub_825A1588(ctx, base);
	// 826CE554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE558: 48724ED1  bl 0x82df3428
	ctx.lr = 0x826CE55C;
	sub_82DF3428(ctx, base);
	// 826CE55C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE564: 3B8B8CC0  addi r28, r11, -0x7340
	ctx.r[28].s64 = ctx.r[11].s64 + -29504;
	// 826CE568: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826CE56C: 4872549D  bl 0x82df3a08
	ctx.lr = 0x826CE570;
	sub_82DF3A08(ctx, base);
	// 826CE570: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE574: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826CE578: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE57C: 4BED300D  bl 0x825a1588
	ctx.lr = 0x826CE580;
	sub_825A1588(ctx, base);
	// 826CE580: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE584: 48724EA5  bl 0x82df3428
	ctx.lr = 0x826CE588;
	sub_82DF3428(ctx, base);
	// 826CE588: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE58C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE590: 3B6B8CB0  addi r27, r11, -0x7350
	ctx.r[27].s64 = ctx.r[11].s64 + -29520;
	// 826CE594: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826CE598: 48725471  bl 0x82df3a08
	ctx.lr = 0x826CE59C;
	sub_82DF3A08(ctx, base);
	// 826CE59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE5A0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826CE5A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE5A8: 4BED2FE1  bl 0x825a1588
	ctx.lr = 0x826CE5AC;
	sub_825A1588(ctx, base);
	// 826CE5AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE5B0: 48724E79  bl 0x82df3428
	ctx.lr = 0x826CE5B4;
	sub_82DF3428(ctx, base);
	// 826CE5B4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE5B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE5BC: 3B4B8CA4  addi r26, r11, -0x735c
	ctx.r[26].s64 = ctx.r[11].s64 + -29532;
	// 826CE5C0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CE5C4: 48725445  bl 0x82df3a08
	ctx.lr = 0x826CE5C8;
	sub_82DF3A08(ctx, base);
	// 826CE5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE5CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826CE5D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE5D4: 4BED2FB5  bl 0x825a1588
	ctx.lr = 0x826CE5D8;
	sub_825A1588(ctx, base);
	// 826CE5D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE5DC: 48724E4D  bl 0x82df3428
	ctx.lr = 0x826CE5E0;
	sub_82DF3428(ctx, base);
	// 826CE5E0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE5E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE5E8: 3B2B8C94  addi r25, r11, -0x736c
	ctx.r[25].s64 = ctx.r[11].s64 + -29548;
	// 826CE5EC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826CE5F0: 48725419  bl 0x82df3a08
	ctx.lr = 0x826CE5F4;
	sub_82DF3A08(ctx, base);
	// 826CE5F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826CE5F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE5FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE600: 4BED2F89  bl 0x825a1588
	ctx.lr = 0x826CE604;
	sub_825A1588(ctx, base);
	// 826CE604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE608: 48724E21  bl 0x82df3428
	ctx.lr = 0x826CE60C;
	sub_82DF3428(ctx, base);
	// 826CE60C: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 826CE610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CE614: 419A0028  beq cr6, 0x826ce63c
	if ctx.cr[6].eq {
	pc = 0x826CE63C; continue 'dispatch;
	}
	// 826CE618: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE620: 487253E9  bl 0x82df3a08
	ctx.lr = 0x826CE624;
	sub_82DF3A08(ctx, base);
	// 826CE624: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826CE628: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE630: 4BED2F59  bl 0x825a1588
	ctx.lr = 0x826CE634;
	sub_825A1588(ctx, base);
	// 826CE634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE638: 48724DF1  bl 0x82df3428
	ctx.lr = 0x826CE63C;
	sub_82DF3428(ctx, base);
	// 826CE63C: 817E0210  lwz r11, 0x210(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(528 as u32) ) } as u64;
	// 826CE640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CE644: 419A0094  beq cr6, 0x826ce6d8
	if ctx.cr[6].eq {
	pc = 0x826CE6D8; continue 'dispatch;
	}
	// 826CE648: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826CE64C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE650: 487253B9  bl 0x82df3a08
	ctx.lr = 0x826CE654;
	sub_82DF3A08(ctx, base);
	// 826CE654: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826CE658: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE660: 4BED2F29  bl 0x825a1588
	ctx.lr = 0x826CE664;
	sub_825A1588(ctx, base);
	// 826CE664: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE668: 48724DC1  bl 0x82df3428
	ctx.lr = 0x826CE66C;
	sub_82DF3428(ctx, base);
	// 826CE66C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826CE670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE674: 48725395  bl 0x82df3a08
	ctx.lr = 0x826CE678;
	sub_82DF3A08(ctx, base);
	// 826CE678: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826CE67C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE684: 4BED2F05  bl 0x825a1588
	ctx.lr = 0x826CE688;
	sub_825A1588(ctx, base);
	// 826CE688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE68C: 48724D9D  bl 0x82df3428
	ctx.lr = 0x826CE690;
	sub_82DF3428(ctx, base);
	// 826CE690: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826CE694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE698: 48725371  bl 0x82df3a08
	ctx.lr = 0x826CE69C;
	sub_82DF3A08(ctx, base);
	// 826CE69C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826CE6A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE6A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE6A8: 4BED2EE1  bl 0x825a1588
	ctx.lr = 0x826CE6AC;
	sub_825A1588(ctx, base);
	// 826CE6AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE6B0: 48724D79  bl 0x82df3428
	ctx.lr = 0x826CE6B4;
	sub_82DF3428(ctx, base);
	// 826CE6B4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826CE6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE6BC: 4872534D  bl 0x82df3a08
	ctx.lr = 0x826CE6C0;
	sub_82DF3A08(ctx, base);
	// 826CE6C0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826CE6C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CE6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CE6CC: 4BED2EBD  bl 0x825a1588
	ctx.lr = 0x826CE6D0;
	sub_825A1588(ctx, base);
	// 826CE6D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE6D4: 48724D55  bl 0x82df3428
	ctx.lr = 0x826CE6D8;
	sub_82DF3428(ctx, base);
	// 826CE6D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826CE6DC: 48AD9AD0  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CE6E0 size=12
    let mut pc: u32 = 0x826CE6E0;
    'dispatch: loop {
        match pc {
            0x826CE6E0 => {
    //   block [0x826CE6E0..0x826CE6EC)
	// 826CE6E0: 816301CC  lwz r11, 0x1cc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(460 as u32) ) } as u64;
	// 826CE6E4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CE6E8: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE6EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CE6EC size=12
    let mut pc: u32 = 0x826CE6EC;
    'dispatch: loop {
        match pc {
            0x826CE6EC => {
    //   block [0x826CE6EC..0x826CE6F8)
	// 826CE6EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826CE6F0: 996301D0  stb r11, 0x1d0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(464 as u32), ctx.r[11].u8 ) };
	// 826CE6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CE6F8 size=12
    let mut pc: u32 = 0x826CE6F8;
    'dispatch: loop {
        match pc {
            0x826CE6F8 => {
    //   block [0x826CE6F8..0x826CE704)
	// 826CE6F8: 816301CC  lwz r11, 0x1cc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(460 as u32) ) } as u64;
	// 826CE6FC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CE700: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE704(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CE704 size=12
    let mut pc: u32 = 0x826CE704;
    'dispatch: loop {
        match pc {
            0x826CE704 => {
    //   block [0x826CE704..0x826CE710)
	// 826CE704: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CE708: 996301D0  stb r11, 0x1d0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(464 as u32), ctx.r[11].u8 ) };
	// 826CE70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CE710 size=4
    let mut pc: u32 = 0x826CE710;
    'dispatch: loop {
        match pc {
            0x826CE710 => {
    //   block [0x826CE710..0x826CE714)
	// 826CE710: 4BFD34F0  b 0x826a1c00
	sub_826A1C00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CE718 size=136
    let mut pc: u32 = 0x826CE718;
    'dispatch: loop {
        match pc {
            0x826CE718 => {
    //   block [0x826CE718..0x826CE7A0)
	// 826CE718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE71C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CE720: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CE724: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CE728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE72C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CE730: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CE734: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 826CE738: 409A0020  bne cr6, 0x826ce758
	if !ctx.cr[6].eq {
	pc = 0x826CE758; continue 'dispatch;
	}
	// 826CE73C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CE740: 419A0048  beq cr6, 0x826ce788
	if ctx.cr[6].eq {
	pc = 0x826CE788; continue 'dispatch;
	}
	// 826CE744: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 826CE748: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 826CE74C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 826CE750: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 826CE754: 48000034  b 0x826ce788
	pc = 0x826CE788; continue 'dispatch;
	// 826CE758: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 826CE75C: 419A002C  beq cr6, 0x826ce788
	if ctx.cr[6].eq {
	pc = 0x826CE788; continue 'dispatch;
	}
	// 826CE760: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CE764: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CE768: 388BCCB8  addi r4, r11, -0x3348
	ctx.r[4].s64 = ctx.r[11].s64 + -13128;
	// 826CE76C: 48AD998D  bl 0x831a80f8
	ctx.lr = 0x826CE770;
	sub_831A80F8(ctx, base);
	// 826CE770: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CE774: 4182000C  beq 0x826ce780
	if ctx.cr[0].eq {
	pc = 0x826CE780; continue 'dispatch;
	}
	// 826CE778: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 826CE77C: 4800000C  b 0x826ce788
	pc = 0x826CE788; continue 'dispatch;
	// 826CE780: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CE784: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CE788: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CE78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CE790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CE794: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CE798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CE79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CE7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CE7A0 size=848
    let mut pc: u32 = 0x826CE7A0;
    'dispatch: loop {
        match pc {
            0x826CE7A0 => {
    //   block [0x826CE7A0..0x826CEAF0)
	// 826CE7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CE7A4: 48AD99C1  bl 0x831a8164
	ctx.lr = 0x826CE7A8;
	sub_831A8130(ctx, base);
	// 826CE7A8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 826CE7AC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826CE7B0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CE7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CE7B8: 83DF0228  lwz r30, 0x228(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 826CE7BC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826CE7C0: 419A0320  beq cr6, 0x826ceae0
	if ctx.cr[6].eq {
	pc = 0x826CEAE0; continue 'dispatch;
	}
	// 826CE7C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CE7C8: C01F01D8  lfs f0, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE7CC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826CE7D0: C1BF02FC  lfs f13, 0x2fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(764 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CE7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE7D8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CE7DC: C3CA9450  lfs f30, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CE7E0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CE7E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE7E8: EC406FBA  fmadds f2, f0, f30, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 826CE7EC: 487AD82D  bl 0x82e7c018
	ctx.lr = 0x826CE7F0;
	sub_82E7C018(ctx, base);
	// 826CE7F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE7F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CE7F8: 48744A69  bl 0x82e13260
	ctx.lr = 0x826CE7FC;
	sub_82E13260(ctx, base);
	// 826CE7FC: C01F0300  lfs f0, 0x300(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE804: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CE808: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE80C: EC4007B2  fmuls f2, f0, f30
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 826CE810: 83DF0230  lwz r30, 0x230(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826CE814: 487AD805  bl 0x82e7c018
	ctx.lr = 0x826CE818;
	sub_82E7C018(ctx, base);
	// 826CE818: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CE820: 48744A41  bl 0x82e13260
	ctx.lr = 0x826CE824;
	sub_82E13260(ctx, base);
	// 826CE824: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CE828: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CE82C: C01F0300  lfs f0, 0x300(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE830: 3BCB8C5C  addi r30, r11, -0x73a4
	ctx.r[30].s64 = ctx.r[11].s64 + -29604;
	// 826CE834: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CE838: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CE83C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE840: 397EFFF8  addi r11, r30, -8
	ctx.r[11].s64 = ctx.r[30].s64 + -8;
	// 826CE844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE848: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CE84C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CE850: 83BF0238  lwz r29, 0x238(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 826CE854: EC406FBC  fnmsubs f2, f0, f30, f13
	ctx.f[2].f64 = -(((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 826CE858: 487AD7C1  bl 0x82e7c018
	ctx.lr = 0x826CE85C;
	sub_82E7C018(ctx, base);
	// 826CE85C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE860: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CE864: 487449FD  bl 0x82e13260
	ctx.lr = 0x826CE868;
	sub_82E13260(ctx, base);
	// 826CE868: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CE86C: 807F0240  lwz r3, 0x240(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 826CE870: 3BAB6880  addi r29, r11, 0x6880
	ctx.r[29].s64 = ctx.r[11].s64 + 26752;
	// 826CE874: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE878: 487449E9  bl 0x82e13260
	ctx.lr = 0x826CE87C;
	sub_82E13260(ctx, base);
	// 826CE87C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE880: 807F0248  lwz r3, 0x248(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 826CE884: 487449DD  bl 0x82e13260
	ctx.lr = 0x826CE888;
	sub_82E13260(ctx, base);
	// 826CE888: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE88C: 807F0250  lwz r3, 0x250(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 826CE890: 487449D1  bl 0x82e13260
	ctx.lr = 0x826CE894;
	sub_82E13260(ctx, base);
	// 826CE894: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE898: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 826CE89C: 487449C5  bl 0x82e13260
	ctx.lr = 0x826CE8A0;
	sub_82E13260(ctx, base);
	// 826CE8A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE8A4: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 826CE8A8: 487449B9  bl 0x82e13260
	ctx.lr = 0x826CE8AC;
	sub_82E13260(ctx, base);
	// 826CE8AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CE8B0: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 826CE8B4: 487449AD  bl 0x82e13260
	ctx.lr = 0x826CE8B8;
	sub_82E13260(ctx, base);
	// 826CE8B8: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CE8BC: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 826CE8C0: 813F02EC  lwz r9, 0x2ec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 826CE8C4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CE8C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CE8CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 826CE8D0: 7FCA5C2E  lfsx f30, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CE8D4: 40990084  ble cr6, 0x826ce958
	if !ctx.cr[6].gt {
	pc = 0x826CE958; continue 'dispatch;
	}
	// 826CE8D8: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 826CE8DC: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CE8E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE8E4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CE8E8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CE8EC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE8F0: 7F8A582E  lwzx r28, r10, r11
	ctx.r[28].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826CE8F4: 487AD725  bl 0x82e7c018
	ctx.lr = 0x826CE8F8;
	sub_82E7C018(ctx, base);
	// 826CE8F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE8FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CE900: 48744961  bl 0x82e13260
	ctx.lr = 0x826CE904;
	sub_82E13260(ctx, base);
	// 826CE904: 817F02E8  lwz r11, 0x2e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CE908: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826CE90C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826CE910: 409A0024  bne cr6, 0x826ce934
	if !ctx.cr[6].eq {
	pc = 0x826CE934; continue 'dispatch;
	}
	// 826CE914: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 826CE918: 393E0020  addi r9, r30, 0x20
	ctx.r[9].s64 = ctx.r[30].s64 + 32;
	// 826CE91C: 391E0010  addi r8, r30, 0x10
	ctx.r[8].s64 = ctx.r[30].s64 + 16;
	// 826CE920: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE924: 7DAB4C2E  lfsx f13, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CE928: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826CE92C: 7DAB442E  lfsx f13, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CE930: 48000010  b 0x826ce940
	pc = 0x826CE940; continue 'dispatch;
	// 826CE934: 395E0010  addi r10, r30, 0x10
	ctx.r[10].s64 = ctx.r[30].s64 + 16;
	// 826CE938: 7C0BF42E  lfsx f0, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE93C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CE940: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826CE944: 817F02EC  lwz r11, 0x2ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 826CE948: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 826CE94C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CE950: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 826CE954: 4198FF84  blt cr6, 0x826ce8d8
	if ctx.cr[6].lt {
	pc = 0x826CE8D8; continue 'dispatch;
	}
	// 826CE958: 817F02E8  lwz r11, 0x2e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CE95C: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 826CE960: 813F02EC  lwz r9, 0x2ec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 826CE964: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826CE968: 37A9FFFF  addic. r29, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826CE96C: 7FCB542E  lfsx f30, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CE970: 40810058  ble 0x826ce9c8
	if !ctx.cr[0].gt {
	pc = 0x826CE9C8; continue 'dispatch;
	}
	// 826CE974: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826CE978: 817F0294  lwz r11, 0x294(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(660 as u32) ) } as u64;
	// 826CE97C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE980: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CE984: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CE988: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE98C: 7F6BE02E  lwzx r27, r11, r28
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826CE990: 487AD689  bl 0x82e7c018
	ctx.lr = 0x826CE994;
	sub_82E7C018(ctx, base);
	// 826CE994: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CE998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826CE99C: 487448C5  bl 0x82e13260
	ctx.lr = 0x826CE9A0;
	sub_82E13260(ctx, base);
	// 826CE9A0: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CE9A4: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 826CE9A8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CE9AC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826CE9B0: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 826CE9B4: 7C0AF42E  lfsx f0, r10, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CE9B8: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CE9BC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826CE9C0: EFC0F02A  fadds f30, f0, f30
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 826CE9C4: 4082FFB4  bne 0x826ce978
	if !ctx.cr[0].eq {
	pc = 0x826CE978; continue 'dispatch;
	}
	// 826CE9C8: 817F02F0  lwz r11, 0x2f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 826CE9CC: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 826CE9D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CE9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CE9D8: 40990094  ble cr6, 0x826cea6c
	if !ctx.cr[6].gt {
	pc = 0x826CEA6C; continue 'dispatch;
	}
	// 826CE9DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826CE9E0: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 826CE9E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CE9E8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CE9EC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CE9F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CE9F4: 7F7C582E  lwzx r27, r28, r11
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826CE9F8: 487AD621  bl 0x82e7c018
	ctx.lr = 0x826CE9FC;
	sub_82E7C018(ctx, base);
	// 826CE9FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CEA00: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826CEA04: 4874485D  bl 0x82e13260
	ctx.lr = 0x826CEA08;
	sub_82E13260(ctx, base);
	// 826CEA08: 817F02F0  lwz r11, 0x2f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 826CEA0C: 394BFFFE  addi r10, r11, -2
	ctx.r[10].s64 = ctx.r[11].s64 + -2;
	// 826CEA10: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826CEA14: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CEA18: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CEA1C: 409A002C  bne cr6, 0x826cea48
	if !ctx.cr[6].eq {
	pc = 0x826CEA48; continue 'dispatch;
	}
	// 826CEA20: 393E0020  addi r9, r30, 0x20
	ctx.r[9].s64 = ctx.r[30].s64 + 32;
	// 826CEA24: 391E0008  addi r8, r30, 8
	ctx.r[8].s64 = ctx.r[30].s64 + 8;
	// 826CEA28: 38FE0010  addi r7, r30, 0x10
	ctx.r[7].s64 = ctx.r[30].s64 + 16;
	// 826CEA2C: 7C0A4C2E  lfsx f0, r10, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEA30: 7DAA442E  lfsx f13, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CEA34: 7D8A3C2E  lfsx f12, r10, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826CEA38: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826CEA3C: EDBE6028  fsubs f13, f30, f12
	ctx.f[13].f64 = (((ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 826CEA40: EFC0682A  fadds f30, f0, f13
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826CEA44: 48000018  b 0x826cea5c
	pc = 0x826CEA5C; continue 'dispatch;
	// 826CEA48: 393E0010  addi r9, r30, 0x10
	ctx.r[9].s64 = ctx.r[30].s64 + 16;
	// 826CEA4C: 7C0AF42E  lfsx f0, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEA50: 7DAA4C2E  lfsx f13, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CEA54: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826CEA58: EFDE0028  fsubs f30, f30, f0
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826CEA5C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 826CEA60: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 826CEA64: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826CEA68: 4198FF78  blt cr6, 0x826ce9e0
	if ctx.cr[6].lt {
	pc = 0x826CE9E0; continue 'dispatch;
	}
	// 826CEA6C: 817F02E8  lwz r11, 0x2e8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CEA70: 395E0010  addi r10, r30, 0x10
	ctx.r[10].s64 = ctx.r[30].s64 + 16;
	// 826CEA74: 813F02F0  lwz r9, 0x2f0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 826CEA78: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826CEA7C: 37A9FFFF  addic. r29, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826CEA80: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEA84: FFC00050  fneg f30, f0
	ctx.f[30].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CEA88: 40810058  ble 0x826ceae0
	if !ctx.cr[0].gt {
	pc = 0x826CEAE0; continue 'dispatch;
	}
	// 826CEA8C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826CEA90: 817F02A4  lwz r11, 0x2a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 826CEA94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEA98: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CEA9C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CEAA0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CEAA4: 7F7C582E  lwzx r27, r28, r11
	ctx.r[27].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826CEAA8: 487AD571  bl 0x82e7c018
	ctx.lr = 0x826CEAAC;
	sub_82E7C018(ctx, base);
	// 826CEAAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CEAB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826CEAB4: 487447AD  bl 0x82e13260
	ctx.lr = 0x826CEAB8;
	sub_82E13260(ctx, base);
	// 826CEAB8: 815F02E8  lwz r10, 0x2e8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(744 as u32) ) } as u64;
	// 826CEABC: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 826CEAC0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826CEAC4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826CEAC8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 826CEACC: 7C0AF42E  lfsx f0, r10, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEAD0: 7DAA5C2E  lfsx f13, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CEAD4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826CEAD8: EFDE0028  fsubs f30, f30, f0
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826CEADC: 4082FFB4  bne 0x826cea90
	if !ctx.cr[0].eq {
	pc = 0x826CEA90; continue 'dispatch;
	}
	// 826CEAE0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826CEAE4: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826CEAE8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826CEAEC: 48AD96C8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CEAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CEAF0 size=320
    let mut pc: u32 = 0x826CEAF0;
    'dispatch: loop {
        match pc {
            0x826CEAF0 => {
    //   block [0x826CEAF0..0x826CEC30)
	// 826CEAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CEAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CEAF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CEAFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CEB00: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826CEB04: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826CEB08: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CEB0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CEB10: 817F02F4  lwz r11, 0x2f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(756 as u32) ) } as u64;
	// 826CEB14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CEB18: 419A00F8  beq cr6, 0x826cec10
	if ctx.cr[6].eq {
	pc = 0x826CEC10; continue 'dispatch;
	}
	// 826CEB1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CEB20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEB24: 4BE409A5  bl 0x8250f4c8
	ctx.lr = 0x826CEB28;
	sub_8250F4C8(ctx, base);
	// 826CEB28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CEB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CEB30: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CEB34: 409A0008  bne cr6, 0x826ceb3c
	if !ctx.cr[6].eq {
	pc = 0x826CEB3C; continue 'dispatch;
	}
	// 826CEB38: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826CEB3C: 4BE399DD  bl 0x82508518
	ctx.lr = 0x826CEB40;
	sub_82508518(ctx, base);
	// 826CEB40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEB44: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CEB48: 48723149  bl 0x82df1c90
	ctx.lr = 0x826CEB4C;
	sub_82DF1C90(ctx, base);
	// 826CEB4C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CEB50: C1BF0308  lfs f13, 0x308(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CEB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CEB58: C09F0310  lfs f4, 0x310(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 826CEB5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CEB60: C07F0304  lfs f3, 0x304(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(772 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826CEB64: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEB68: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CEB6C: 4BFFCE85  bl 0x826cb9f0
	ctx.lr = 0x826CEB70;
	sub_826CB9F0(ctx, base);
	// 826CEB70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CEB74: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 826CEB78: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 826CEB7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CEB80: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CEB84: 419A0038  beq cr6, 0x826cebbc
	if ctx.cr[6].eq {
	pc = 0x826CEBBC; continue 'dispatch;
	}
	// 826CEB88: 815F0278  lwz r10, 0x278(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 826CEB8C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826CEB90: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CEB94: 41820028  beq 0x826cebbc
	if ctx.cr[0].eq {
	pc = 0x826CEBBC; continue 'dispatch;
	}
	// 826CEB98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CEB9C: 83DF0240  lwz r30, 0x240(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) } as u64;
	// 826CEBA0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CEBA4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CEBA8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CEBAC: 487AD46D  bl 0x82e7c018
	ctx.lr = 0x826CEBB0;
	sub_82E7C018(ctx, base);
	// 826CEBB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CEBB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CEBB8: 487446A9  bl 0x82e13260
	ctx.lr = 0x826CEBBC;
	sub_82E13260(ctx, base);
	// 826CEBBC: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 826CEBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CEBC4: 419A004C  beq cr6, 0x826cec10
	if ctx.cr[6].eq {
	pc = 0x826CEC10; continue 'dispatch;
	}
	// 826CEBC8: 815F0288  lwz r10, 0x288(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 826CEBCC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826CEBD0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CEBD4: 4182003C  beq 0x826cec10
	if ctx.cr[0].eq {
	pc = 0x826CEC10; continue 'dispatch;
	}
	// 826CEBD8: 817F02F4  lwz r11, 0x2f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(756 as u32) ) } as u64;
	// 826CEBDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CEBE0: 83FF0248  lwz r31, 0x248(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 826CEBE4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CEBE8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826CEBEC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CEBF0: 409A000C  bne cr6, 0x826cebfc
	if !ctx.cr[6].eq {
	pc = 0x826CEBFC; continue 'dispatch;
	}
	// 826CEBF4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CEBF8: 48000008  b 0x826cec00
	pc = 0x826CEC00; continue 'dispatch;
	// 826CEBFC: FC40F050  fneg f2, f30
	ctx.f[2].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 826CEC00: 487AD419  bl 0x82e7c018
	ctx.lr = 0x826CEC04;
	sub_82E7C018(ctx, base);
	// 826CEC04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CEC08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CEC0C: 48744655  bl 0x82e13260
	ctx.lr = 0x826CEC10;
	sub_82E13260(ctx, base);
	// 826CEC10: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826CEC14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CEC18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CEC1C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826CEC20: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826CEC24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CEC28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CEC2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CEC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CEC30 size=184
    let mut pc: u32 = 0x826CEC30;
    'dispatch: loop {
        match pc {
            0x826CEC30 => {
    //   block [0x826CEC30..0x826CECE8)
	// 826CEC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CEC34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CEC38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CEC3C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 826CEC40: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CEC44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CEC48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEC4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CEC50: 4BE40879  bl 0x8250f4c8
	ctx.lr = 0x826CEC54;
	sub_8250F4C8(ctx, base);
	// 826CEC54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CEC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CEC5C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826CEC60: 409A0008  bne cr6, 0x826cec68
	if !ctx.cr[6].eq {
	pc = 0x826CEC68; continue 'dispatch;
	}
	// 826CEC64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826CEC68: 4BE398B1  bl 0x82508518
	ctx.lr = 0x826CEC6C;
	sub_82508518(ctx, base);
	// 826CEC6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEC70: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826CEC74: 4872301D  bl 0x82df1c90
	ctx.lr = 0x826CEC78;
	sub_82DF1C90(ctx, base);
	// 826CEC78: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CEC7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CEC80: C00B8C50  lfs f0, -0x73b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-29616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEC84: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CEC88: 487ADD61  bl 0x82e7c9e8
	ctx.lr = 0x826CEC8C;
	sub_82E7C9E8(ctx, base);
	// 826CEC8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CEC90: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826CEC94: C00B3474  lfs f0, 0x3474(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(13428 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CEC98: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 826CEC9C: 487ADD4D  bl 0x82e7c9e8
	ctx.lr = 0x826CECA0;
	sub_82E7C9E8(ctx, base);
	// 826CECA0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CECA4: 807F0250  lwz r3, 0x250(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 826CECA8: 487445B9  bl 0x82e13260
	ctx.lr = 0x826CECAC;
	sub_82E13260(ctx, base);
	// 826CECAC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826CECB0: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 826CECB4: 487445AD  bl 0x82e13260
	ctx.lr = 0x826CECB8;
	sub_82E13260(ctx, base);
	// 826CECB8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CECBC: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 826CECC0: 487445A1  bl 0x82e13260
	ctx.lr = 0x826CECC4;
	sub_82E13260(ctx, base);
	// 826CECC4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826CECC8: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 826CECCC: 48744595  bl 0x82e13260
	ctx.lr = 0x826CECD0;
	sub_82E13260(ctx, base);
	// 826CECD0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 826CECD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CECD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CECDC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CECE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CECE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CECE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CECE8 size=280
    let mut pc: u32 = 0x826CECE8;
    'dispatch: loop {
        match pc {
            0x826CECE8 => {
    //   block [0x826CECE8..0x826CEE00)
	// 826CECE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CECEC: 48AD947D  bl 0x831a8168
	ctx.lr = 0x826CECF0;
	sub_831A8130(ctx, base);
	// 826CECF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CECF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CECF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826CECFC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826CED00: 817F02EC  lwz r11, 0x2ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 826CED04: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826CED08: 419800F0  blt cr6, 0x826cedf8
	if ctx.cr[6].lt {
	pc = 0x826CEDF8; continue 'dispatch;
	}
	// 826CED0C: 817F0274  lwz r11, 0x274(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 826CED10: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826CED14: 3B8A6910  addi r28, r10, 0x6910
	ctx.r[28].s64 = ctx.r[10].s64 + 26896;
	// 826CED18: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CED1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CED20: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CED24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CED28: 4E800421  bctrl
	ctx.lr = 0x826CED2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CED2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CED30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CED34: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826CED38: 487ACF91  bl 0x82e7bcc8
	ctx.lr = 0x826CED3C;
	sub_82E7BCC8(ctx, base);
	// 826CED3C: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CEE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CEE00 size=292
    let mut pc: u32 = 0x826CEE00;
    'dispatch: loop {
        match pc {
            0x826CEE00 => {
    //   block [0x826CEE00..0x826CEF24)
	// 826CEE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CEE04: 48AD9365  bl 0x831a8168
	ctx.lr = 0x826CEE08;
	sub_831A8130(ctx, base);
	// 826CEE08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CEE0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CEE10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CEE14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826CEE18: 817F02F0  lwz r11, 0x2f0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 826CEE1C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826CEE20: 419800FC  blt cr6, 0x826cef1c
	if ctx.cr[6].lt {
	pc = 0x826CEF1C; continue 'dispatch;
	}
	// 826CEE24: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 826CEE28: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826CEE2C: 3B8A6910  addi r28, r10, 0x6910
	ctx.r[28].s64 = ctx.r[10].s64 + 26896;
	// 826CEE30: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CEE34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CEE38: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CEE3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CEE40: 4E800421  bctrl
	ctx.lr = 0x826CEE44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CEE44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CEE48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEE4C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826CEE50: 487ACE79  bl 0x82e7bcc8
	ctx.lr = 0x826CEE54;
	sub_82E7BCC8(ctx, base);
	// 826CEE54: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CEF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CEF28 size=196
    let mut pc: u32 = 0x826CEF28;
    'dispatch: loop {
        match pc {
            0x826CEF28 => {
    //   block [0x826CEF28..0x826CEFEC)
	// 826CEF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CEF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CEF30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CEF34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CEF38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CEF3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CEF40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CEF44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826CEF48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CEF4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CEF50: 4BBF19E9  bl 0x822c0938
	ctx.lr = 0x826CEF54;
	sub_822C0938(ctx, base);
	// 826CEF54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CEF58: 41820028  beq 0x826cef80
	if ctx.cr[0].eq {
	pc = 0x826CEF80; continue 'dispatch;
	}
	// 826CEF5C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CEF60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826CEF64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826CEF68: 392B8CE0  addi r9, r11, -0x7320
	ctx.r[9].s64 = ctx.r[11].s64 + -29472;
	// 826CEF6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826CEF70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826CEF74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826CEF78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826CEF7C: 48000008  b 0x826cef84
	pc = 0x826CEF84; continue 'dispatch;
	// 826CEF80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826CEF84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CEF88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826CEF8C: 409A0044  bne cr6, 0x826cefd0
	if !ctx.cr[6].eq {
	pc = 0x826CEFD0; continue 'dispatch;
	}
	// 826CEF90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CEF94: 419A001C  beq cr6, 0x826cefb0
	if ctx.cr[6].eq {
	pc = 0x826CEFB0; continue 'dispatch;
	}
	// 826CEF98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CEF9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CEFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CEFA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CEFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CEFAC: 4E800421  bctrl
	ctx.lr = 0x826CEFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CEFB0: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CEFB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826CEFB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CEFBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826CEFC0: 816BCC60  lwz r11, -0x33a0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13216 as u32) ) } as u64;
	// 826CEFC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826CEFC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826CEFCC: 4BBF1035  bl 0x822c0000
	ctx.lr = 0x826CEFD0;
	sub_822C0000(ctx, base);
	// 826CEFD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CEFD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CEFD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CEFDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CEFE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826CEFE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CEFE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CEFF0 size=320
    let mut pc: u32 = 0x826CEFF0;
    'dispatch: loop {
        match pc {
            0x826CEFF0 => {
    //   block [0x826CEFF0..0x826CF130)
	// 826CEFF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CEFF4: 48AD9175  bl 0x831a8168
	ctx.lr = 0x826CEFF8;
	sub_831A8130(ctx, base);
	// 826CEFF8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CEFFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CF000: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826CF004: 4BFD328D  bl 0x826a2290
	ctx.lr = 0x826CF008;
	sub_826A2290(ctx, base);
	// 826CF008: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826CF00C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826CF010: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826CF014: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF018: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826CF01C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CF020: 4E800421  bctrl
	ctx.lr = 0x826CF024;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CF024: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF028: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CF02C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CF030: 487ACC99  bl 0x82e7bcc8
	ctx.lr = 0x826CF034;
	sub_82E7BCC8(ctx, base);
	// 826CF034: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CF038: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826CF03C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826CF040: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CF044: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826CF048: 839F0220  lwz r28, 0x220(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 826CF04C: 487ACF8D  bl 0x82e7bfd8
	ctx.lr = 0x826CF050;
	sub_82E7BFD8(ctx, base);
	// 826CF050: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF054: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CF058: 48744209  bl 0x82e13260
	ctx.lr = 0x826CF05C;
	sub_82E13260(ctx, base);
	// 826CF05C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF060: 4BFFFA91  bl 0x826ceaf0
	ctx.lr = 0x826CF064;
	sub_826CEAF0(ctx, base);
	// 826CF064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF068: 4BFFFBC9  bl 0x826cec30
	ctx.lr = 0x826CF06C;
	sub_826CEC30(ctx, base);
	// 826CF06C: 897F02B4  lbz r11, 0x2b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(692 as u32) ) } as u64;
	// 826CF070: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826CF074: 4182004C  beq 0x826cf0c0
	if ctx.cr[0].eq {
	pc = 0x826CF0C0; continue 'dispatch;
	}
	// 826CF078: 807F0228  lwz r3, 0x228(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 826CF07C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF080: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CF084: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CF088: 4E800421  bctrl
	ctx.lr = 0x826CF08C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CF08C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF090: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CF094: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CF098: 487ACC31  bl 0x82e7bcc8
	ctx.lr = 0x826CF09C;
	sub_82E7BCC8(ctx, base);
	// 826CF09C: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 826CF0A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CF0A4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 826CF0A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826CF0AC: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 826CF0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF0B4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 826CF0B8: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 826CF0BC: 4BFD22AD  bl 0x826a1368
	ctx.lr = 0x826CF0C0;
	sub_826A1368(ctx, base);
	// 826CF0C0: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 826CF0C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF0C8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CF0CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CF0D0: 4E800421  bctrl
	ctx.lr = 0x826CF0D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CF0D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF0D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CF0DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826CF0E0: 487ACBE9  bl 0x82e7bcc8
	ctx.lr = 0x826CF0E4;
	sub_82E7BCC8(ctx, base);
	// 826CF0E4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826CF0E8: 397F02C0  addi r11, r31, 0x2c0
	ctx.r[11].s64 = ctx.r[31].s64 + 704;
	// 826CF0EC: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826CF0F0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826CF0F4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826CF0F8: 38E002D0  li r7, 0x2d0
	ctx.r[7].s64 = 720;
	// 826CF0FC: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CF100: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CF130 size=932
    let mut pc: u32 = 0x826CF130;
    'dispatch: loop {
        match pc {
            0x826CF130 => {
    //   block [0x826CF130..0x826CF4D4)
	// 826CF130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF134: 48AD9031  bl 0x831a8164
	ctx.lr = 0x826CF138;
	sub_831A8130(ctx, base);
	// 826CF138: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826CF13C: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF140: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CF144: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826CF148: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 826CF14C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826CF150: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 826CF154: 3BEA6910  addi r31, r10, 0x6910
	ctx.r[31].s64 = ctx.r[10].s64 + 26896;
	// 826CF158: 807D01BC  lwz r3, 0x1bc(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(444 as u32) ) } as u64;
	// 826CF15C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF160: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CF164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CF168: 4E800421  bctrl
	ctx.lr = 0x826CF16C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CF16C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF170: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CF174: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CF178: 487ACB51  bl 0x82e7bcc8
	ctx.lr = 0x826CF17C;
	sub_82E7BCC8(ctx, base);
	// 826CF17C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CF180: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826CF184: C05D01D8  lfs f2, 0x1d8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CF188: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CF18C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CF190: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826CF194: 839D01BC  lwz r28, 0x1bc(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(444 as u32) ) } as u64;
	// 826CF198: 487ACE81  bl 0x82e7c018
	ctx.lr = 0x826CF19C;
	sub_82E7C018(ctx, base);
	// 826CF19C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF1A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826CF1A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CF1A8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826CF1AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826CF1B0: 4E800421  bctrl
	ctx.lr = 0x826CF1B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826CF1B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF1B8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826CF1BC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826CF1C0: 4BBF5741  bl 0x822c4900
	ctx.lr = 0x826CF1C4;
	sub_822C4900(ctx, base);
	// 826CF1C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826CF1C8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826CF1CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CF1D0: 487ACAF9  bl 0x82e7bcc8
	ctx.lr = 0x826CF1D4;
	sub_82E7BCC8(ctx, base);
	// 826CF1D4: 817D02EC  lwz r11, 0x2ec(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(748 as u32) ) } as u64;
	// 826CF1D8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826CF1DC: 41980018  blt cr6, 0x826cf1f4
	if ctx.cr[6].lt {
	pc = 0x826CF1F4; continue 'dispatch;
	}
	// 826CF1E0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 826CF1E4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826CF1E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826CF1EC: 4BFFFAFD  bl 0x826cece8
	ctx.lr = 0x826CF1F0;
	sub_826CECE8(ctx, base);
	// 826CF1F0: 4800001C  b 0x826cf20c
	pc = 0x826CF20C; continue 'dispatch;
	// 826CF1F4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 826CF1F8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 826CF1FC: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 826CF200: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CF4D8 size=72
    let mut pc: u32 = 0x826CF4D8;
    'dispatch: loop {
        match pc {
            0x826CF4D8 => {
    //   block [0x826CF4D8..0x826CF520)
	// 826CF4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CF4E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF4E4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 826CF4E8: 419A001C  beq cr6, 0x826cf504
	if ctx.cr[6].eq {
	pc = 0x826CF504; continue 'dispatch;
	}
	// 826CF4EC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CF4F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826CF4F4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 826CF4F8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CF4FC: 4BFFF21D  bl 0x826ce718
	ctx.lr = 0x826CF500;
	sub_826CE718(ctx, base);
	// 826CF500: 48000010  b 0x826cf510
	pc = 0x826CF510; continue 'dispatch;
	// 826CF504: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CF508: 396BCCB8  addi r11, r11, -0x3348
	ctx.r[11].s64 = ctx.r[11].s64 + -13128;
	// 826CF50C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CF510: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826CF514: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CF518: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CF51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CF520 size=160
    let mut pc: u32 = 0x826CF520;
    'dispatch: loop {
        match pc {
            0x826CF520 => {
    //   block [0x826CF520..0x826CF5C0)
	// 826CF520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CF528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CF52C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CF534: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826CF538: 419A0074  beq cr6, 0x826cf5ac
	if ctx.cr[6].eq {
	pc = 0x826CF5AC; continue 'dispatch;
	}
	// 826CF53C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CF540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CF544: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826CF548: 487244C1  bl 0x82df3a08
	ctx.lr = 0x826CF54C;
	sub_82DF3A08(ctx, base);
	// 826CF54C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CF550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CF554: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826CF558: 487244B1  bl 0x82df3a08
	ctx.lr = 0x826CF55C;
	sub_82DF3A08(ctx, base);
	// 826CF55C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826CF560: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826CF564: 38ABCC5C  addi r5, r11, -0x33a4
	ctx.r[5].s64 = ctx.r[11].s64 + -13220;
	// 826CF568: 38E003E8  li r7, 0x3e8
	ctx.r[7].s64 = 1000;
	// 826CF56C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CF570: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CF574: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826CF578: 4BED3EA1  bl 0x825a3418
	ctx.lr = 0x826CF57C;
	sub_825A3418(ctx, base);
	// 826CF57C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CF580: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CF584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF588: 4BED2951  bl 0x825a1ed8
	ctx.lr = 0x826CF58C;
	sub_825A1ED8(ctx, base);
	// 826CF58C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826CF590: 48723E99  bl 0x82df3428
	ctx.lr = 0x826CF594;
	sub_82DF3428(ctx, base);
	// 826CF594: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826CF598: 4BBF9721  bl 0x822c8cb8
	ctx.lr = 0x826CF59C;
	sub_822C8CB8(ctx, base);
	// 826CF59C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CF5A0: 48723E89  bl 0x82df3428
	ctx.lr = 0x826CF5A4;
	sub_82DF3428(ctx, base);
	// 826CF5A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CF5A8: 48723E81  bl 0x82df3428
	ctx.lr = 0x826CF5AC;
	sub_82DF3428(ctx, base);
	// 826CF5AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826CF5B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826CF5B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826CF5B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826CF5BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CF5C0 size=244
    let mut pc: u32 = 0x826CF5C0;
    'dispatch: loop {
        match pc {
            0x826CF5C0 => {
    //   block [0x826CF5C0..0x826CF6B4)
	// 826CF5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826CF5C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826CF5CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826CF5D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CF5D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CF5DC: 4BE4250D  bl 0x82511ae8
	ctx.lr = 0x826CF5E0;
	sub_82511AE8(ctx, base);
	// 826CF5E0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826CF5E4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826CF5E8: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826CF5EC: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826CF5F0: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 826CF5F4: 38AACC5C  addi r5, r10, -0x33a4
	ctx.r[5].s64 = ctx.r[10].s64 + -13220;
	// 826CF5F8: 38898614  addi r4, r9, -0x79ec
	ctx.r[4].s64 = ctx.r[9].s64 + -31212;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CF6B8 size=164
    let mut pc: u32 = 0x826CF6B8;
    'dispatch: loop {
        match pc {
            0x826CF6B8 => {
    //   block [0x826CF6B8..0x826CF75C)
	// 826CF6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF6BC: 48AD8AAD  bl 0x831a8168
	ctx.lr = 0x826CF6C0;
	sub_831A8130(ctx, base);
	// 826CF6C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF6C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826CF6C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CF6CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826CF6D0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826CF6D4: 41820038  beq 0x826cf70c
	if ctx.cr[0].eq {
	pc = 0x826CF70C; continue 'dispatch;
	}
	// 826CF6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF6DC: 48ADA2AD  bl 0x831a9988
	ctx.lr = 0x826CF6E0;
	sub_831A9988(ctx, base);
	// 826CF6E0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826CF6E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF6E8: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 826CF6EC: 48AD8A0D  bl 0x831a80f8
	ctx.lr = 0x826CF6F0;
	sub_831A80F8(ctx, base);
	// 826CF6F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CF6F4: 41820018  beq 0x826cf70c
	if ctx.cr[0].eq {
	pc = 0x826CF70C; continue 'dispatch;
	}
	// 826CF6F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CF6FC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826CF700: 4BFFFA31  bl 0x826cf130
	ctx.lr = 0x826CF704;
	sub_826CF130(ctx, base);
	// 826CF704: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826CF708: 4800004C  b 0x826cf754
	pc = 0x826CF754; continue 'dispatch;
	// 826CF70C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826CF710: 419A0034  beq cr6, 0x826cf744
	if ctx.cr[6].eq {
	pc = 0x826CF744; continue 'dispatch;
	}
	// 826CF714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF718: 48ADA271  bl 0x831a9988
	ctx.lr = 0x826CF71C;
	sub_831A9988(ctx, base);
	// 826CF71C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826CF720: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CF724: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826CF728: 48AD89D1  bl 0x831a80f8
	ctx.lr = 0x826CF72C;
	sub_831A80F8(ctx, base);
	// 826CF72C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CF730: 41820014  beq 0x826cf744
	if ctx.cr[0].eq {
	pc = 0x826CF744; continue 'dispatch;
	}
	// 826CF734: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CF738: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826CF73C: 4BFFFE85  bl 0x826cf5c0
	ctx.lr = 0x826CF740;
	sub_826CF5C0(ctx, base);
	// 826CF740: 4BFFFFC4  b 0x826cf704
	pc = 0x826CF704; continue 'dispatch;
	// 826CF744: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826CF748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826CF74C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CF750: 4BFD2361  bl 0x826a1ab0
	ctx.lr = 0x826CF754;
	sub_826A1AB0(ctx, base);
	// 826CF754: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CF758: 48AD8A60  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CF760 size=128
    let mut pc: u32 = 0x826CF760;
    'dispatch: loop {
        match pc {
            0x826CF760 => {
    //   block [0x826CF760..0x826CF7E0)
	// 826CF760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF764: 48AD8A09  bl 0x831a816c
	ctx.lr = 0x826CF768;
	sub_831A8130(ctx, base);
	// 826CF768: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF76C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826CF770: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826CF774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CF778: 3BEB8240  addi r31, r11, -0x7dc0
	ctx.r[31].s64 = ctx.r[11].s64 + -32192;
	// 826CF77C: 816A8248  lwz r11, -0x7db8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32184 as u32) ) } as u64;
	// 826CF780: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826CF784: 40820024  bne 0x826cf7a8
	if !ctx.cr[0].eq {
	pc = 0x826CF7A8; continue 'dispatch;
	}
	// 826CF788: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 826CF78C: 3D00826D  lis r8, -0x7d93
	ctx.r[8].s64 = -2106785792;
	// 826CF790: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826CF794: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 826CF798: 3908F4D8  addi r8, r8, -0xb28
	ctx.r[8].s64 = ctx.r[8].s64 + -2856;
	// 826CF79C: 916A8248  stw r11, -0x7db8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32184 as u32), ctx.r[11].u32 ) };
	// 826CF7A0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826CF7A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826CF7A8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CF7AC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CF7B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF7B4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 826CF7B8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 826CF7BC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CF7C0: 4BF84E01  bl 0x826545c0
	ctx.lr = 0x826CF7C4;
	sub_826545C0(ctx, base);
	// 826CF7C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CF7C8: 4182000C  beq 0x826cf7d4
	if ctx.cr[0].eq {
	pc = 0x826CF7D4; continue 'dispatch;
	}
	// 826CF7CC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CF7D0: 48000008  b 0x826cf7d8
	pc = 0x826CF7D8; continue 'dispatch;
	// 826CF7D4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826CF7D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CF7DC: 48AD89E0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CF7E0 size=128
    let mut pc: u32 = 0x826CF7E0;
    'dispatch: loop {
        match pc {
            0x826CF7E0 => {
    //   block [0x826CF7E0..0x826CF860)
	// 826CF7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF7E4: 48AD8989  bl 0x831a816c
	ctx.lr = 0x826CF7E8;
	sub_831A8130(ctx, base);
	// 826CF7E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF7EC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826CF7F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826CF7F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826CF7F8: 3BEB824C  addi r31, r11, -0x7db4
	ctx.r[31].s64 = ctx.r[11].s64 + -32180;
	// 826CF7FC: 816A8254  lwz r11, -0x7dac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-32172 as u32) ) } as u64;
	// 826CF800: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826CF804: 40820024  bne 0x826cf828
	if !ctx.cr[0].eq {
	pc = 0x826CF828; continue 'dispatch;
	}
	// 826CF808: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 826CF80C: 3D00826D  lis r8, -0x7d93
	ctx.r[8].s64 = -2106785792;
	// 826CF810: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 826CF814: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 826CF818: 3908F4D8  addi r8, r8, -0xb28
	ctx.r[8].s64 = ctx.r[8].s64 + -2856;
	// 826CF81C: 916A8254  stw r11, -0x7dac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-32172 as u32), ctx.r[11].u32 ) };
	// 826CF820: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 826CF824: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 826CF828: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 826CF82C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CF830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF834: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 826CF838: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 826CF83C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826CF840: 4BF84D81  bl 0x826545c0
	ctx.lr = 0x826CF844;
	sub_826545C0(ctx, base);
	// 826CF844: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CF848: 4182000C  beq 0x826cf854
	if ctx.cr[0].eq {
	pc = 0x826CF854; continue 'dispatch;
	}
	// 826CF84C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826CF850: 48000008  b 0x826cf858
	pc = 0x826CF858; continue 'dispatch;
	// 826CF854: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 826CF858: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826CF85C: 48AD8960  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826CF860 size=324
    let mut pc: u32 = 0x826CF860;
    'dispatch: loop {
        match pc {
            0x826CF860 => {
    //   block [0x826CF860..0x826CF9A4)
	// 826CF860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF864: 48AD8909  bl 0x831a816c
	ctx.lr = 0x826CF868;
	sub_831A8130(ctx, base);
	// 826CF868: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF86C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CF870: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CF874: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CF878: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826CF87C: 396B8DB4  addi r11, r11, -0x724c
	ctx.r[11].s64 = ctx.r[11].s64 + -29260;
	// 826CF880: 394A8DA0  addi r10, r10, -0x7260
	ctx.r[10].s64 = ctx.r[10].s64 + -29280;
	// 826CF884: 39298D54  addi r9, r9, -0x72ac
	ctx.r[9].s64 = ctx.r[9].s64 + -29356;
	// 826CF888: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826CF88C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826CF890: 387F02A0  addi r3, r31, 0x2a0
	ctx.r[3].s64 = ctx.r[31].s64 + 672;
	// 826CF894: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826CF898: 4BDE1A09  bl 0x824b12a0
	ctx.lr = 0x826CF89C;
	sub_824B12A0(ctx, base);
	// 826CF89C: 387F0290  addi r3, r31, 0x290
	ctx.r[3].s64 = ctx.r[31].s64 + 656;
	// 826CF8A0: 4BDE1A01  bl 0x824b12a0
	ctx.lr = 0x826CF8A4;
	sub_824B12A0(ctx, base);
	// 826CF8A4: 387F0280  addi r3, r31, 0x280
	ctx.r[3].s64 = ctx.r[31].s64 + 640;
	// 826CF8A8: 4BDE19F9  bl 0x824b12a0
	ctx.lr = 0x826CF8AC;
	sub_824B12A0(ctx, base);
	// 826CF8AC: 3BDF0270  addi r30, r31, 0x270
	ctx.r[30].s64 = ctx.r[31].s64 + 624;
	// 826CF8B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CF8B4: 4BDE19ED  bl 0x824b12a0
	ctx.lr = 0x826CF8B8;
	sub_824B12A0(ctx, base);
	// 826CF8B8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826CF8BC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 826CF8C0: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826CF8C4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF8CC: 419A0008  beq cr6, 0x826cf8d4
	if ctx.cr[6].eq {
	pc = 0x826CF8D4; continue 'dispatch;
	}
	// 826CF8D0: 4BBF0FC1  bl 0x822c0890
	ctx.lr = 0x826CF8D4;
	sub_822C0890(ctx, base);
	// 826CF8D4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826CF8D8: 4080FFE8  bge 0x826cf8c0
	if !ctx.cr[0].lt {
	pc = 0x826CF8C0; continue 'dispatch;
	}
	// 826CF8DC: 397F0260  addi r11, r31, 0x260
	ctx.r[11].s64 = ctx.r[31].s64 + 608;
	// 826CF8E0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 826CF8E4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 826CF8E8: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 826CF8EC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826CF8F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF8F4: 419A0008  beq cr6, 0x826cf8fc
	if ctx.cr[6].eq {
	pc = 0x826CF8FC; continue 'dispatch;
	}
	// 826CF8F8: 4BBF0F99  bl 0x822c0890
	ctx.lr = 0x826CF8FC;
	sub_822C0890(ctx, base);
	// 826CF8FC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826CF900: 4080FFE8  bge 0x826cf8e8
	if !ctx.cr[0].lt {
	pc = 0x826CF8E8; continue 'dispatch;
	}
	// 826CF904: 807F024C  lwz r3, 0x24c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 826CF908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF90C: 419A0008  beq cr6, 0x826cf914
	if ctx.cr[6].eq {
	pc = 0x826CF914; continue 'dispatch;
	}
	// 826CF910: 4BBF0F81  bl 0x822c0890
	ctx.lr = 0x826CF914;
	sub_822C0890(ctx, base);
	// 826CF914: 807F0244  lwz r3, 0x244(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 826CF918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF91C: 419A0008  beq cr6, 0x826cf924
	if ctx.cr[6].eq {
	pc = 0x826CF924; continue 'dispatch;
	}
	// 826CF920: 4BBF0F71  bl 0x822c0890
	ctx.lr = 0x826CF924;
	sub_822C0890(ctx, base);
	// 826CF924: 807F023C  lwz r3, 0x23c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 826CF928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF92C: 419A0008  beq cr6, 0x826cf934
	if ctx.cr[6].eq {
	pc = 0x826CF934; continue 'dispatch;
	}
	// 826CF930: 4BBF0F61  bl 0x822c0890
	ctx.lr = 0x826CF934;
	sub_822C0890(ctx, base);
	// 826CF934: 807F0234  lwz r3, 0x234(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 826CF938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF93C: 419A0008  beq cr6, 0x826cf944
	if ctx.cr[6].eq {
	pc = 0x826CF944; continue 'dispatch;
	}
	// 826CF940: 4BBF0F51  bl 0x822c0890
	ctx.lr = 0x826CF944;
	sub_822C0890(ctx, base);
	// 826CF944: 807F022C  lwz r3, 0x22c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826CF948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF94C: 419A0008  beq cr6, 0x826cf954
	if ctx.cr[6].eq {
	pc = 0x826CF954; continue 'dispatch;
	}
	// 826CF950: 4BBF0F41  bl 0x822c0890
	ctx.lr = 0x826CF954;
	sub_822C0890(ctx, base);
	// 826CF954: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826CF958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF95C: 419A0008  beq cr6, 0x826cf964
	if ctx.cr[6].eq {
	pc = 0x826CF964; continue 'dispatch;
	}
	// 826CF960: 4BBF0F31  bl 0x822c0890
	ctx.lr = 0x826CF964;
	sub_822C0890(ctx, base);
	// 826CF964: 387F0210  addi r3, r31, 0x210
	ctx.r[3].s64 = ctx.r[31].s64 + 528;
	// 826CF968: 4BD9A699  bl 0x8246a000
	ctx.lr = 0x826CF96C;
	sub_8246A000(ctx, base);
	// 826CF96C: 807F020C  lwz r3, 0x20c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 826CF970: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF974: 419A0008  beq cr6, 0x826cf97c
	if ctx.cr[6].eq {
	pc = 0x826CF97C; continue 'dispatch;
	}
	// 826CF978: 4BBF0F19  bl 0x822c0890
	ctx.lr = 0x826CF97C;
	sub_822C0890(ctx, base);
	// 826CF97C: 807F0204  lwz r3, 0x204(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) } as u64;
	// 826CF980: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826CF984: 419A0008  beq cr6, 0x826cf98c
	if ctx.cr[6].eq {
	pc = 0x826CF98C; continue 'dispatch;
	}
	// 826CF988: 4BBF0F09  bl 0x822c0890
	ctx.lr = 0x826CF98C;
	sub_822C0890(ctx, base);
	// 826CF98C: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 826CF990: 4BDE1911  bl 0x824b12a0
	ctx.lr = 0x826CF994;
	sub_824B12A0(ctx, base);
	// 826CF994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826CF998: 4BFD23F1  bl 0x826a1d88
	ctx.lr = 0x826CF99C;
	sub_826A1D88(ctx, base);
	// 826CF99C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826CF9A0: 48AD881C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CF9A8 size=8
    let mut pc: u32 = 0x826CF9A8;
    'dispatch: loop {
        match pc {
            0x826CF9A8 => {
    //   block [0x826CF9A8..0x826CF9B0)
	// 826CF9A8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826CF9AC: 48000834  b 0x826d01e0
	sub_826D01E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826CF9B0 size=8
    let mut pc: u32 = 0x826CF9B0;
    'dispatch: loop {
        match pc {
            0x826CF9B0 => {
    //   block [0x826CF9B0..0x826CF9B8)
	// 826CF9B0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826CF9B4: 4800082C  b 0x826d01e0
	sub_826D01E0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826CF9B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826CF9B8 size=1672
    let mut pc: u32 = 0x826CF9B8;
    'dispatch: loop {
        match pc {
            0x826CF9B8 => {
    //   block [0x826CF9B8..0x826D0040)
	// 826CF9B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826CF9BC: 48AD87A5  bl 0x831a8160
	ctx.lr = 0x826CF9C0;
	sub_831A8130(ctx, base);
	// 826CF9C0: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 826CF9C4: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 826CF9C8: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 826CF9CC: 9421FCA0  stwu r1, -0x360(r1)
	ea = ctx.r[1].u32.wrapping_add(-864 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826CF9D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826CF9D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826CF9D8: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 826CF9DC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 826CF9E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826CF9E4: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 826CF9E8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 826CF9EC: 4BFD24DD  bl 0x826a1ec8
	ctx.lr = 0x826CF9F0;
	sub_826A1EC8(ctx, base);
	// 826CF9F0: 3D60826A  lis r11, -0x7d96
	ctx.r[11].s64 = -2106982400;
	// 826CF9F4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826CF9F8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CF9FC: 396B1358  addi r11, r11, 0x1358
	ctx.r[11].s64 = ctx.r[11].s64 + 4952;
	// 826CFA00: 388A8F04  addi r4, r10, -0x70fc
	ctx.r[4].s64 = ctx.r[10].s64 + -28924;
	// 826CFA04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFA08: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826CFA0C: 48723FFD  bl 0x82df3a08
	ctx.lr = 0x826CFA10;
	sub_82DF3A08(ctx, base);
	// 826CFA10: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFA14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFA18: 388B8EF4  addi r4, r11, -0x710c
	ctx.r[4].s64 = ctx.r[11].s64 + -28940;
	// 826CFA1C: 48723FED  bl 0x82df3a08
	ctx.lr = 0x826CFA20;
	sub_82DF3A08(ctx, base);
	// 826CFA20: 3B7FFF1C  addi r27, r31, -0xe4
	ctx.r[27].s64 = ctx.r[31].s64 + -228;
	// 826CFA24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CFA28: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 826CFA2C: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 826CFA30: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 826CFA34: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 826CFA38: 4BFFFD29  bl 0x826cf760
	ctx.lr = 0x826CFA3C;
	sub_826CF760(ctx, base);
	// 826CFA3C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826CFA40: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826CFA44: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826CFA48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CFA4C: 38BF0204  addi r5, r31, 0x204
	ctx.r[5].s64 = ctx.r[31].s64 + 516;
	// 826CFA50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFA54: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 826CFA58: 4BED3AB9  bl 0x825a3510
	ctx.lr = 0x826CFA5C;
	sub_825A3510(ctx, base);
	// 826CFA5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFA60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFA64: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFA68: 4BED2471  bl 0x825a1ed8
	ctx.lr = 0x826CFA6C;
	sub_825A1ED8(ctx, base);
	// 826CFA6C: 38610248  addi r3, r1, 0x248
	ctx.r[3].s64 = ctx.r[1].s64 + 584;
	// 826CFA70: 487239B9  bl 0x82df3428
	ctx.lr = 0x826CFA74;
	sub_82DF3428(ctx, base);
	// 826CFA74: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 826CFA78: 4BBF9241  bl 0x822c8cb8
	ctx.lr = 0x826CFA7C;
	sub_822C8CB8(ctx, base);
	// 826CFA7C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFA80: 487239A9  bl 0x82df3428
	ctx.lr = 0x826CFA84;
	sub_82DF3428(ctx, base);
	// 826CFA84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFA88: 487239A1  bl 0x82df3428
	ctx.lr = 0x826CFA8C;
	sub_82DF3428(ctx, base);
	// 826CFA8C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFA90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFA94: 388B8EE8  addi r4, r11, -0x7118
	ctx.r[4].s64 = ctx.r[11].s64 + -28952;
	// 826CFA98: 48723F71  bl 0x82df3a08
	ctx.lr = 0x826CFA9C;
	sub_82DF3A08(ctx, base);
	// 826CFA9C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFAA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFAA4: 388B8EDC  addi r4, r11, -0x7124
	ctx.r[4].s64 = ctx.r[11].s64 + -28964;
	// 826CFAA8: 48723F61  bl 0x82df3a08
	ctx.lr = 0x826CFAAC;
	sub_82DF3A08(ctx, base);
	// 826CFAAC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826CFAB0: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 826CFAB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CFAB8: 38BF0208  addi r5, r31, 0x208
	ctx.r[5].s64 = ctx.r[31].s64 + 520;
	// 826CFABC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFAC0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826CFAC4: 4BED3955  bl 0x825a3418
	ctx.lr = 0x826CFAC8;
	sub_825A3418(ctx, base);
	// 826CFAC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFAD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFAD4: 4BED2405  bl 0x825a1ed8
	ctx.lr = 0x826CFAD8;
	sub_825A1ED8(ctx, base);
	// 826CFAD8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826CFADC: 4872394D  bl 0x82df3428
	ctx.lr = 0x826CFAE0;
	sub_82DF3428(ctx, base);
	// 826CFAE0: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826CFAE4: 4BBF91D5  bl 0x822c8cb8
	ctx.lr = 0x826CFAE8;
	sub_822C8CB8(ctx, base);
	// 826CFAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFAEC: 4872393D  bl 0x82df3428
	ctx.lr = 0x826CFAF0;
	sub_82DF3428(ctx, base);
	// 826CFAF0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFAF4: 48723935  bl 0x82df3428
	ctx.lr = 0x826CFAF8;
	sub_82DF3428(ctx, base);
	// 826CFAF8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFAFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFB00: 388B8ED0  addi r4, r11, -0x7130
	ctx.r[4].s64 = ctx.r[11].s64 + -28976;
	// 826CFB04: 48723F05  bl 0x82df3a08
	ctx.lr = 0x826CFB08;
	sub_82DF3A08(ctx, base);
	// 826CFB08: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFB10: 388B8EC4  addi r4, r11, -0x713c
	ctx.r[4].s64 = ctx.r[11].s64 + -28988;
	// 826CFB14: 48723EF5  bl 0x82df3a08
	ctx.lr = 0x826CFB18;
	sub_82DF3A08(ctx, base);
	// 826CFB18: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826CFB1C: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 826CFB20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CFB24: 38BF020C  addi r5, r31, 0x20c
	ctx.r[5].s64 = ctx.r[31].s64 + 524;
	// 826CFB28: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFB2C: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 826CFB30: 4BED38E9  bl 0x825a3418
	ctx.lr = 0x826CFB34;
	sub_825A3418(ctx, base);
	// 826CFB34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFB38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFB3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFB40: 4BED2399  bl 0x825a1ed8
	ctx.lr = 0x826CFB44;
	sub_825A1ED8(ctx, base);
	// 826CFB44: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 826CFB48: 487238E1  bl 0x82df3428
	ctx.lr = 0x826CFB4C;
	sub_82DF3428(ctx, base);
	// 826CFB4C: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 826CFB50: 4BBF9169  bl 0x822c8cb8
	ctx.lr = 0x826CFB54;
	sub_822C8CB8(ctx, base);
	// 826CFB54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFB58: 487238D1  bl 0x82df3428
	ctx.lr = 0x826CFB5C;
	sub_82DF3428(ctx, base);
	// 826CFB5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFB60: 487238C9  bl 0x82df3428
	ctx.lr = 0x826CFB64;
	sub_82DF3428(ctx, base);
	// 826CFB64: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFB68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CFB6C: 388B8CF0  addi r4, r11, -0x7310
	ctx.r[4].s64 = ctx.r[11].s64 + -29456;
	// 826CFB70: 38A000D2  li r5, 0xd2
	ctx.r[5].s64 = 210;
	// 826CFB74: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826CFB78: 4BBF0861  bl 0x822c03d8
	ctx.lr = 0x826CFB7C;
	sub_822C03D8(ctx, base);
	// 826CFB7C: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 826CFB80: 41820034  beq 0x826cfbb4
	if ctx.cr[0].eq {
	pc = 0x826CFBB4; continue 'dispatch;
	}
	// 826CFB84: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFB88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFB8C: 388B8EB4  addi r4, r11, -0x714c
	ctx.r[4].s64 = ctx.r[11].s64 + -29004;
	// 826CFB90: 48723E79  bl 0x82df3a08
	ctx.lr = 0x826CFB94;
	sub_82DF3A08(ctx, base);
	// 826CFB94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826CFB98: 38BF0210  addi r5, r31, 0x210
	ctx.r[5].s64 = ctx.r[31].s64 + 528;
	// 826CFB9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFBA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826CFBA4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 826CFBA8: 4BEDC869  bl 0x825ac410
	ctx.lr = 0x826CFBAC;
	sub_825AC410(ctx, base);
	// 826CFBAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826CFBB0: 48000008  b 0x826cfbb8
	pc = 0x826CFBB8; continue 'dispatch;
	// 826CFBB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826CFBB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826CFBBC: 4BEE283D  bl 0x825b23f8
	ctx.lr = 0x826CFBC0;
	sub_825B23F8(ctx, base);
	// 826CFBC0: 574B07FF  clrlwi. r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826CFBC4: 4182000C  beq 0x826cfbd0
	if ctx.cr[0].eq {
	pc = 0x826CFBD0; continue 'dispatch;
	}
	// 826CFBC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFBCC: 4872385D  bl 0x82df3428
	ctx.lr = 0x826CFBD0;
	sub_82DF3428(ctx, base);
	// 826CFBD0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826CFBD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFBD8: 388BC578  addi r4, r11, -0x3a88
	ctx.r[4].s64 = ctx.r[11].s64 + -14984;
	// 826CFBDC: 48723E2D  bl 0x82df3a08
	ctx.lr = 0x826CFBE0;
	sub_82DF3A08(ctx, base);
	// 826CFBE0: 83410070  lwz r26, 0x70(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826CFBE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CFBE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826CFBEC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826CFBF0: 4BEDC1D1  bl 0x825abdc0
	ctx.lr = 0x826CFBF4;
	sub_825ABDC0(ctx, base);
	// 826CFBF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFBF8: 48723831  bl 0x82df3428
	ctx.lr = 0x826CFBFC;
	sub_82DF3428(ctx, base);
	// 826CFBFC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFC00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFC04: 388B8EA8  addi r4, r11, -0x7158
	ctx.r[4].s64 = ctx.r[11].s64 + -29016;
	// 826CFC08: 48723E01  bl 0x82df3a08
	ctx.lr = 0x826CFC0C;
	sub_82DF3A08(ctx, base);
	// 826CFC0C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CFC10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826CFC14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826CFC18: 4BEDC1A9  bl 0x825abdc0
	ctx.lr = 0x826CFC1C;
	sub_825ABDC0(ctx, base);
	// 826CFC1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFC20: 48723809  bl 0x82df3428
	ctx.lr = 0x826CFC24;
	sub_82DF3428(ctx, base);
	// 826CFC24: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFC28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFC2C: 388B8E9C  addi r4, r11, -0x7164
	ctx.r[4].s64 = ctx.r[11].s64 + -29028;
	// 826CFC30: 48723DD9  bl 0x82df3a08
	ctx.lr = 0x826CFC34;
	sub_82DF3A08(ctx, base);
	// 826CFC34: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826CFC38: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826CFC3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826CFC40: 4BEDC181  bl 0x825abdc0
	ctx.lr = 0x826CFC44;
	sub_825ABDC0(ctx, base);
	// 826CFC44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFC48: 487237E1  bl 0x82df3428
	ctx.lr = 0x826CFC4C;
	sub_82DF3428(ctx, base);
	// 826CFC4C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFC50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFC54: 388B8E8C  addi r4, r11, -0x7174
	ctx.r[4].s64 = ctx.r[11].s64 + -29044;
	// 826CFC58: 48723DB1  bl 0x82df3a08
	ctx.lr = 0x826CFC5C;
	sub_82DF3A08(ctx, base);
	// 826CFC5C: 83810074  lwz r28, 0x74(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826CFC60: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 826CFC64: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826CFC68: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 826CFC6C: 419A0024  beq cr6, 0x826cfc90
	if ctx.cr[6].eq {
	pc = 0x826CFC90; continue 'dispatch;
	}
	// 826CFC70: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 826CFC74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826CFC78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CFC7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826CFC80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826CFC84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826CFC88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826CFC8C: 4082FFE8  bne 0x826cfc74
	if !ctx.cr[0].eq {
	pc = 0x826CFC74; continue 'dispatch;
	}
	// 826CFC90: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826CFC94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFC98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFC9C: 4BED2475  bl 0x825a2110
	ctx.lr = 0x826CFCA0;
	sub_825A2110(ctx, base);
	// 826CFCA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFCA4: 48723785  bl 0x82df3428
	ctx.lr = 0x826CFCA8;
	sub_82DF3428(ctx, base);
	// 826CFCA8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFCAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFCB0: 388B8E74  addi r4, r11, -0x718c
	ctx.r[4].s64 = ctx.r[11].s64 + -29068;
	// 826CFCB4: 48723D55  bl 0x82df3a08
	ctx.lr = 0x826CFCB8;
	sub_82DF3A08(ctx, base);
	// 826CFCB8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFCBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFCC0: 388B8CCC  addi r4, r11, -0x7334
	ctx.r[4].s64 = ctx.r[11].s64 + -29492;
	// 826CFCC4: 48723D45  bl 0x82df3a08
	ctx.lr = 0x826CFCC8;
	sub_82DF3A08(ctx, base);
	// 826CFCC8: 38BF0214  addi r5, r31, 0x214
	ctx.r[5].s64 = ctx.r[31].s64 + 532;
	// 826CFCCC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFCD0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826CFCD4: 4BED337D  bl 0x825a3050
	ctx.lr = 0x826CFCD8;
	sub_825A3050(ctx, base);
	// 826CFCD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFCDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFCE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFCE4: 4BED24A5  bl 0x825a2188
	ctx.lr = 0x826CFCE8;
	sub_825A2188(ctx, base);
	// 826CFCE8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826CFCEC: 4872373D  bl 0x82df3428
	ctx.lr = 0x826CFCF0;
	sub_82DF3428(ctx, base);
	// 826CFCF0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826CFCF4: 4BBF8FC5  bl 0x822c8cb8
	ctx.lr = 0x826CFCF8;
	sub_822C8CB8(ctx, base);
	// 826CFCF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFCFC: 4872372D  bl 0x82df3428
	ctx.lr = 0x826CFD00;
	sub_82DF3428(ctx, base);
	// 826CFD00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFD04: 48723725  bl 0x82df3428
	ctx.lr = 0x826CFD08;
	sub_82DF3428(ctx, base);
	// 826CFD08: 3D60826D  lis r11, -0x7d93
	ctx.r[11].s64 = -2106785792;
	// 826CFD0C: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CFD10: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826CFD14: 396BE7A0  addi r11, r11, -0x1860
	ctx.r[11].s64 = ctx.r[11].s64 + -6240;
	// 826CFD18: 388A8E5C  addi r4, r10, -0x71a4
	ctx.r[4].s64 = ctx.r[10].s64 + -29092;
	// 826CFD1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFD20: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826CFD24: 48723CE5  bl 0x82df3a08
	ctx.lr = 0x826CFD28;
	sub_82DF3A08(ctx, base);
	// 826CFD28: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFD30: 388B8E4C  addi r4, r11, -0x71b4
	ctx.r[4].s64 = ctx.r[11].s64 + -29108;
	// 826CFD34: 48723CD5  bl 0x82df3a08
	ctx.lr = 0x826CFD38;
	sub_82DF3A08(ctx, base);
	// 826CFD38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CFD3C: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 826CFD40: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 826CFD44: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 826CFD48: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 826CFD4C: 4BFFFA95  bl 0x826cf7e0
	ctx.lr = 0x826CFD50;
	sub_826CF7E0(ctx, base);
	// 826CFD50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CFD54: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826CFD58: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826CFD5C: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826CFD60: 38BF0218  addi r5, r31, 0x218
	ctx.r[5].s64 = ctx.r[31].s64 + 536;
	// 826CFD64: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826CFD68: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFD6C: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CFD70: 38610290  addi r3, r1, 0x290
	ctx.r[3].s64 = ctx.r[1].s64 + 656;
	// 826CFD74: C0280790  lfs f1, 0x790(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(1936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826CFD78: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CFD7C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CFD80: 4BED34A9  bl 0x825a3228
	ctx.lr = 0x826CFD84;
	sub_825A3228(ctx, base);
	// 826CFD84: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFD88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFD8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFD90: 4BED19E1  bl 0x825a1770
	ctx.lr = 0x826CFD94;
	sub_825A1770(ctx, base);
	// 826CFD94: 907F01CC  stw r3, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[3].u32 ) };
	// 826CFD98: 386102C8  addi r3, r1, 0x2c8
	ctx.r[3].s64 = ctx.r[1].s64 + 712;
	// 826CFD9C: 4872368D  bl 0x82df3428
	ctx.lr = 0x826CFDA0;
	sub_82DF3428(ctx, base);
	// 826CFDA0: 386102A8  addi r3, r1, 0x2a8
	ctx.r[3].s64 = ctx.r[1].s64 + 680;
	// 826CFDA4: 4BBF8F15  bl 0x822c8cb8
	ctx.lr = 0x826CFDA8;
	sub_822C8CB8(ctx, base);
	// 826CFDA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFDAC: 4872367D  bl 0x82df3428
	ctx.lr = 0x826CFDB0;
	sub_82DF3428(ctx, base);
	// 826CFDB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFDB4: 48723675  bl 0x82df3428
	ctx.lr = 0x826CFDB8;
	sub_82DF3428(ctx, base);
	// 826CFDB8: 3D60826D  lis r11, -0x7d93
	ctx.r[11].s64 = -2106785792;
	// 826CFDBC: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826CFDC0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826CFDC4: 396BE7A0  addi r11, r11, -0x1860
	ctx.r[11].s64 = ctx.r[11].s64 + -6240;
	// 826CFDC8: 388A8E3C  addi r4, r10, -0x71c4
	ctx.r[4].s64 = ctx.r[10].s64 + -29124;
	// 826CFDCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFDD0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826CFDD4: 48723C35  bl 0x82df3a08
	ctx.lr = 0x826CFDD8;
	sub_82DF3A08(ctx, base);
	// 826CFDD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFDDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFDE0: 388B8E30  addi r4, r11, -0x71d0
	ctx.r[4].s64 = ctx.r[11].s64 + -29136;
	// 826CFDE4: 48723C25  bl 0x82df3a08
	ctx.lr = 0x826CFDE8;
	sub_82DF3A08(ctx, base);
	// 826CFDE8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826CFDEC: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 826CFDF0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 826CFDF4: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 826CFDF8: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 826CFDFC: 4BFFF9E5  bl 0x826cf7e0
	ctx.lr = 0x826CFE00;
	sub_826CF7E0(ctx, base);
	// 826CFE00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826CFE04: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CFE08: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 826CFE0C: 38BF021C  addi r5, r31, 0x21c
	ctx.r[5].s64 = ctx.r[31].s64 + 540;
	// 826CFE10: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFE14: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826CFE18: C3AB964C  lfs f29, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826CFE1C: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 826CFE20: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826CFE24: 4BED3405  bl 0x825a3228
	ctx.lr = 0x826CFE28;
	sub_825A3228(ctx, base);
	// 826CFE28: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFE2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFE34: 4BED193D  bl 0x825a1770
	ctx.lr = 0x826CFE38;
	sub_825A1770(ctx, base);
	// 826CFE38: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826CFE3C: 487235ED  bl 0x82df3428
	ctx.lr = 0x826CFE40;
	sub_82DF3428(ctx, base);
	// 826CFE40: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826CFE44: 4BBF8E75  bl 0x822c8cb8
	ctx.lr = 0x826CFE48;
	sub_822C8CB8(ctx, base);
	// 826CFE48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFE4C: 487235DD  bl 0x82df3428
	ctx.lr = 0x826CFE50;
	sub_82DF3428(ctx, base);
	// 826CFE50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFE54: 487235D5  bl 0x82df3428
	ctx.lr = 0x826CFE58;
	sub_82DF3428(ctx, base);
	// 826CFE58: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFE5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFE60: 388B8E24  addi r4, r11, -0x71dc
	ctx.r[4].s64 = ctx.r[11].s64 + -29148;
	// 826CFE64: 48723BA5  bl 0x82df3a08
	ctx.lr = 0x826CFE68;
	sub_82DF3A08(ctx, base);
	// 826CFE68: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFE6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFE70: 388B8CC0  addi r4, r11, -0x7340
	ctx.r[4].s64 = ctx.r[11].s64 + -29504;
	// 826CFE74: 48723B95  bl 0x82df3a08
	ctx.lr = 0x826CFE78;
	sub_82DF3A08(ctx, base);
	// 826CFE78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826CFE7C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826CFE80: 38BF0220  addi r5, r31, 0x220
	ctx.r[5].s64 = ctx.r[31].s64 + 544;
	// 826CFE84: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFE88: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CFE8C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 826CFE90: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826CFE94: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826CFE98: 4BED3411  bl 0x825a32a8
	ctx.lr = 0x826CFE9C;
	sub_825A32A8(ctx, base);
	// 826CFE9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFEA0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFEA8: 4BED18C9  bl 0x825a1770
	ctx.lr = 0x826CFEAC;
	sub_825A1770(ctx, base);
	// 826CFEAC: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 826CFEB0: 48723579  bl 0x82df3428
	ctx.lr = 0x826CFEB4;
	sub_82DF3428(ctx, base);
	// 826CFEB4: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826CFEB8: 4BBF8E01  bl 0x822c8cb8
	ctx.lr = 0x826CFEBC;
	sub_822C8CB8(ctx, base);
	// 826CFEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFEC0: 48723569  bl 0x82df3428
	ctx.lr = 0x826CFEC4;
	sub_82DF3428(ctx, base);
	// 826CFEC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFEC8: 48723561  bl 0x82df3428
	ctx.lr = 0x826CFECC;
	sub_82DF3428(ctx, base);
	// 826CFECC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFED0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFED4: 388B8E14  addi r4, r11, -0x71ec
	ctx.r[4].s64 = ctx.r[11].s64 + -29164;
	// 826CFED8: 48723B31  bl 0x82df3a08
	ctx.lr = 0x826CFEDC;
	sub_82DF3A08(ctx, base);
	// 826CFEDC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFEE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFEE4: 388B8CB0  addi r4, r11, -0x7350
	ctx.r[4].s64 = ctx.r[11].s64 + -29520;
	// 826CFEE8: 48723B21  bl 0x82df3a08
	ctx.lr = 0x826CFEEC;
	sub_82DF3A08(ctx, base);
	// 826CFEEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826CFEF0: 38BF0224  addi r5, r31, 0x224
	ctx.r[5].s64 = ctx.r[31].s64 + 548;
	// 826CFEF4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CFEF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFEFC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826CFF00: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 826CFF04: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CFF08: 4BED33A1  bl 0x825a32a8
	ctx.lr = 0x826CFF0C;
	sub_825A32A8(ctx, base);
	// 826CFF0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFF10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFF14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFF18: 4BED1859  bl 0x825a1770
	ctx.lr = 0x826CFF1C;
	sub_825A1770(ctx, base);
	// 826CFF1C: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 826CFF20: 48723509  bl 0x82df3428
	ctx.lr = 0x826CFF24;
	sub_82DF3428(ctx, base);
	// 826CFF24: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 826CFF28: 4BBF8D91  bl 0x822c8cb8
	ctx.lr = 0x826CFF2C;
	sub_822C8CB8(ctx, base);
	// 826CFF2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFF30: 487234F9  bl 0x82df3428
	ctx.lr = 0x826CFF34;
	sub_82DF3428(ctx, base);
	// 826CFF34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFF38: 487234F1  bl 0x82df3428
	ctx.lr = 0x826CFF3C;
	sub_82DF3428(ctx, base);
	// 826CFF3C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFF40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFF44: 388B8E08  addi r4, r11, -0x71f8
	ctx.r[4].s64 = ctx.r[11].s64 + -29176;
	// 826CFF48: 48723AC1  bl 0x82df3a08
	ctx.lr = 0x826CFF4C;
	sub_82DF3A08(ctx, base);
	// 826CFF4C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFF50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFF54: 388B8CA4  addi r4, r11, -0x735c
	ctx.r[4].s64 = ctx.r[11].s64 + -29532;
	// 826CFF58: 48723AB1  bl 0x82df3a08
	ctx.lr = 0x826CFF5C;
	sub_82DF3A08(ctx, base);
	// 826CFF5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 826CFF60: 38BF0228  addi r5, r31, 0x228
	ctx.r[5].s64 = ctx.r[31].s64 + 552;
	// 826CFF64: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826CFF68: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFF6C: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826CFF70: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 826CFF74: C04B89AC  lfs f2, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CFF78: 4BED3331  bl 0x825a32a8
	ctx.lr = 0x826CFF7C;
	sub_825A32A8(ctx, base);
	// 826CFF7C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFF80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFF84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFF88: 4BED17E9  bl 0x825a1770
	ctx.lr = 0x826CFF8C;
	sub_825A1770(ctx, base);
	// 826CFF8C: 38610288  addi r3, r1, 0x288
	ctx.r[3].s64 = ctx.r[1].s64 + 648;
	// 826CFF90: 48723499  bl 0x82df3428
	ctx.lr = 0x826CFF94;
	sub_82DF3428(ctx, base);
	// 826CFF94: 38610268  addi r3, r1, 0x268
	ctx.r[3].s64 = ctx.r[1].s64 + 616;
	// 826CFF98: 4BBF8D21  bl 0x822c8cb8
	ctx.lr = 0x826CFF9C;
	sub_822C8CB8(ctx, base);
	// 826CFF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFFA0: 48723489  bl 0x82df3428
	ctx.lr = 0x826CFFA4;
	sub_82DF3428(ctx, base);
	// 826CFFA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFFA8: 48723481  bl 0x82df3428
	ctx.lr = 0x826CFFAC;
	sub_82DF3428(ctx, base);
	// 826CFFAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFFB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826CFFB4: 388B8DF8  addi r4, r11, -0x7208
	ctx.r[4].s64 = ctx.r[11].s64 + -29192;
	// 826CFFB8: 48723A51  bl 0x82df3a08
	ctx.lr = 0x826CFFBC;
	sub_82DF3A08(ctx, base);
	// 826CFFBC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826CFFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826CFFC4: 388B8C94  addi r4, r11, -0x736c
	ctx.r[4].s64 = ctx.r[11].s64 + -29548;
	// 826CFFC8: 48723A41  bl 0x82df3a08
	ctx.lr = 0x826CFFCC;
	sub_82DF3A08(ctx, base);
	// 826CFFCC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 826CFFD0: 38BF022C  addi r5, r31, 0x22c
	ctx.r[5].s64 = ctx.r[31].s64 + 556;
	// 826CFFD4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 826CFFD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826CFFDC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826CFFE0: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 826CFFE4: C04B9A8C  lfs f2, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826CFFE8: 4BED32C1  bl 0x825a32a8
	ctx.lr = 0x826CFFEC;
	sub_825A32A8(ctx, base);
	// 826CFFEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826CFFF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826CFFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826CFFF8: 4BED1779  bl 0x825a1770
	ctx.lr = 0x826CFFFC;
	sub_825A1770(ctx, base);
	// 826CFFFC: 38610308  addi r3, r1, 0x308
	ctx.r[3].s64 = ctx.r[1].s64 + 776;
	// 826D0000: 48723429  bl 0x82df3428
	ctx.lr = 0x826D0004;
	sub_82DF3428(ctx, base);
	// 826D0004: 386102E8  addi r3, r1, 0x2e8
	ctx.r[3].s64 = ctx.r[1].s64 + 744;
	// 826D0008: 4BBF8CB1  bl 0x822c8cb8
	ctx.lr = 0x826D000C;
	sub_822C8CB8(ctx, base);
	// 826D000C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D0010: 48723419  bl 0x82df3428
	ctx.lr = 0x826D0014;
	sub_82DF3428(ctx, base);
	// 826D0014: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D0018: 48723411  bl 0x82df3428
	ctx.lr = 0x826D001C;
	sub_82DF3428(ctx, base);
	// 826D001C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 826D0020: 419A000C  beq cr6, 0x826d002c
	if ctx.cr[6].eq {
	pc = 0x826D002C; continue 'dispatch;
	}
	// 826D0024: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D0028: 4BBF0869  bl 0x822c0890
	ctx.lr = 0x826D002C;
	sub_822C0890(ctx, base);
	// 826D002C: 38210360  addi r1, r1, 0x360
	ctx.r[1].s64 = ctx.r[1].s64 + 864;
	// 826D0030: CBA1FFB0  lfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 826D0034: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 826D0038: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826D003C: 48AD8174  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D0040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D0040 size=412
    let mut pc: u32 = 0x826D0040;
    'dispatch: loop {
        match pc {
            0x826D0040 => {
    //   block [0x826D0040..0x826D01DC)
	// 826D0040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D0044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D0048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D004C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D0050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D0054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D0058: 4BFD2159  bl 0x826a21b0
	ctx.lr = 0x826D005C;
	sub_826A21B0(ctx, base);
	// 826D005C: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D0060: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826D0064: 396B8DB4  addi r11, r11, -0x724c
	ctx.r[11].s64 = ctx.r[11].s64 + -29260;
	// 826D0068: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826D006C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D0070: 394A8DA0  addi r10, r10, -0x7260
	ctx.r[10].s64 = ctx.r[10].s64 + -29280;
	// 826D0074: 39298D54  addi r9, r9, -0x72ac
	ctx.r[9].s64 = ctx.r[9].s64 + -29356;
	// 826D0078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D007C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826D0080: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826D0084: 395F0250  addi r10, r31, 0x250
	ctx.r[10].s64 = ctx.r[31].s64 + 592;
	// 826D0088: 917F01F4  stw r11, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 826D008C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826D0090: 917F01F8  stw r11, 0x1f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 826D0094: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 826D0098: 917F0200  stw r11, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 826D009C: 917F0204  stw r11, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[11].u32 ) };
	// 826D00A0: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 826D00A4: 917F020C  stw r11, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 826D00A8: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 826D00AC: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 826D00B0: 917F021C  stw r11, 0x21c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u32 ) };
	// 826D00B4: 917F0220  stw r11, 0x220(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[11].u32 ) };
	// 826D00B8: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 826D00BC: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 826D00C0: 917F022C  stw r11, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[11].u32 ) };
	// 826D00C4: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 826D00C8: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 826D00CC: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 826D00D0: 917F023C  stw r11, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[11].u32 ) };
	// 826D00D4: 917F0240  stw r11, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[11].u32 ) };
	// 826D00D8: 917F0244  stw r11, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 826D00DC: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 826D00E0: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 826D00E4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D00E8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826D00EC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826D00F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826D00F4: 4080FFF0  bge 0x826d00e4
	if !ctx.cr[0].lt {
	pc = 0x826D00E4; continue 'dispatch;
	}
	// 826D00F8: 395F0260  addi r10, r31, 0x260
	ctx.r[10].s64 = ctx.r[31].s64 + 608;
	// 826D00FC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826D0100: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D0104: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826D0108: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 826D010C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 826D0110: 4080FFF0  bge 0x826d0100
	if !ctx.cr[0].lt {
	pc = 0x826D0100; continue 'dispatch;
	}
	// 826D0114: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 826D0118: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 826D011C: 917F0278  stw r11, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 826D0120: 392002C0  li r9, 0x2c0
	ctx.r[9].s64 = 704;
	// 826D0124: 390A6910  addi r8, r10, 0x6910
	ctx.r[8].s64 = ctx.r[10].s64 + 26896;
	// 826D0128: 917F027C  stw r11, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[11].u32 ) };
	// 826D012C: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 826D0130: 38E002D0  li r7, 0x2d0
	ctx.r[7].s64 = 720;
	// 826D0134: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 826D0138: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 826D013C: 917F028C  stw r11, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[11].u32 ) };
	// 826D0140: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 826D0144: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 826D0148: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 826D014C: 917F0298  stw r11, 0x298(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), ctx.r[11].u32 ) };
	// 826D0150: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 826D0154: 917F029C  stw r11, 0x29c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), ctx.r[11].u32 ) };
	// 826D0158: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826D015C: 917F02A4  stw r11, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 826D0160: C00608A4  lfs f0, 0x8a4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D0164: 917F02A8  stw r11, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[11].u32 ) };
	// 826D0168: C185A1C4  lfs f12, -0x5e3c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826D016C: 917F02AC  stw r11, 0x2ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(684 as u32), ctx.r[11].u32 ) };
	// 826D0170: C1A408A8  lfs f13, 0x8a8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D0174: 917F02B0  stw r11, 0x2b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(688 as u32), ctx.r[11].u32 ) };
	// 826D0178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D017C: 997F02B4  stb r11, 0x2b4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(692 as u32), ctx.r[11].u8 ) };
	// 826D0180: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D01E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D01E0 size=76
    let mut pc: u32 = 0x826D01E0;
    'dispatch: loop {
        match pc {
            0x826D01E0 => {
    //   block [0x826D01E0..0x826D022C)
	// 826D01E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D01E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D01E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D01EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D01F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D01F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D01F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826D01FC: 4BFFF665  bl 0x826cf860
	ctx.lr = 0x826D0200;
	sub_826CF860(ctx, base);
	// 826D0200: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D0204: 4182000C  beq 0x826d0210
	if ctx.cr[0].eq {
	pc = 0x826D0210; continue 'dispatch;
	}
	// 826D0208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D020C: 487221CD  bl 0x82df23d8
	ctx.lr = 0x826D0210;
	sub_82DF23D8(ctx, base);
	// 826D0210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D0214: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D0218: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D021C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D0220: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D0224: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D0228: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D0230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D0230 size=3240
    let mut pc: u32 = 0x826D0230;
    'dispatch: loop {
        match pc {
            0x826D0230 => {
    //   block [0x826D0230..0x826D0ED8)
	// 826D0230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D0234: 48AD7F19  bl 0x831a814c
	ctx.lr = 0x826D0238;
	sub_831A8130(ctx, base);
	// 826D0238: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 826D023C: 48AD883D  bl 0x831a8a78
	ctx.lr = 0x826D0240;
	sub_831A8A40(ctx, base);
	// 826D0240: 9421FD20  stwu r1, -0x2e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-736 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D0244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D0248: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826D024C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 826D0250: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D0254: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826D0258: 811F02EC  lwz r8, 0x2ec(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D025C: 3B000006  li r24, 6
	ctx.r[24].s64 = 6;
	// 826D0260: C3E908A4  lfs f31, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826D0264: 3AA00060  li r21, 0x60
	ctx.r[21].s64 = 96;
	// 826D0268: C3A79524  lfs f29, -0x6adc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826D026C: 3B200200  li r25, 0x200
	ctx.r[25].s64 = 512;
	// 826D0270: 3EE08335  lis r23, -0x7ccb
	ctx.r[23].s64 = -2093678592;
	// 826D0274: 3EC08332  lis r22, -0x7cce
	ctx.r[22].s64 = -2093875200;
	// 826D0278: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 826D027C: 3BCB8C8C  addi r30, r11, -0x7374
	ctx.r[30].s64 = ctx.r[11].s64 + -29556;
	// 826D0280: 3B6A8CF0  addi r27, r10, -0x7310
	ctx.r[27].s64 = ctx.r[10].s64 + -29456;
	// 826D0284: 41980234  blt cr6, 0x826d04b8
	if ctx.cr[6].lt {
	pc = 0x826D04B8; continue 'dispatch;
	}
	// 826D0288: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 826D028C: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 826D0290: 4BFFEA59  bl 0x826cece8
	ctx.lr = 0x826D0294;
	sub_826CECE8(ctx, base);
	// 826D0294: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 826D0298: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D0ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D0ED8 size=432
    let mut pc: u32 = 0x826D0ED8;
    'dispatch: loop {
        match pc {
            0x826D0ED8 => {
    //   block [0x826D0ED8..0x826D1088)
	// 826D0ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D0EDC: 48AD7289  bl 0x831a8164
	ctx.lr = 0x826D0EE0;
	sub_831A8130(ctx, base);
	// 826D0EE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D0EE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D0EE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826D0EEC: 3BCB8CF0  addi r30, r11, -0x7310
	ctx.r[30].s64 = ctx.r[11].s64 + -29456;
	// 826D0EF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826D0EF4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826D0EF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D0EFC: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 826D0F00: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826D0F04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D0F08: 38600320  li r3, 0x320
	ctx.r[3].s64 = 800;
	// 826D0F0C: 487214DD  bl 0x82df23e8
	ctx.lr = 0x826D0F10;
	sub_82DF23E8(ctx, base);
	// 826D0F10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D0F14: 41820014  beq 0x826d0f28
	if ctx.cr[0].eq {
	pc = 0x826D0F28; continue 'dispatch;
	}
	// 826D0F18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D0F1C: 4BFFF125  bl 0x826d0040
	ctx.lr = 0x826D0F20;
	sub_826D0040(ctx, base);
	// 826D0F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D0F24: 48000008  b 0x826d0f2c
	pc = 0x826D0F2C; continue 'dispatch;
	// 826D0F28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826D0F2C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826D0F30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D0F34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D0F38: 4BFFDFF1  bl 0x826cef28
	ctx.lr = 0x826D0F3C;
	sub_826CEF28(ctx, base);
	// 826D0F3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D0F40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D0F44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D0F48: 4BBEF0B9  bl 0x822c0000
	ctx.lr = 0x826D0F4C;
	sub_822C0000(ctx, base);
	// 826D0F4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D0F50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D0F54: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 826D0F58: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826D0F5C: 4BBEF47D  bl 0x822c03d8
	ctx.lr = 0x826D0F60;
	sub_822C03D8(ctx, base);
	// 826D0F60: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826D0F64: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D0F68: 418200B4  beq 0x826d101c
	if ctx.cr[0].eq {
	pc = 0x826D101C; continue 'dispatch;
	}
	// 826D0F6C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D0F70: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826D0F74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826D0F78: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826D0F7C: 409A0008  bne cr6, 0x826d0f84
	if !ctx.cr[6].eq {
	pc = 0x826D0F84; continue 'dispatch;
	}
	// 826D0F80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D0F84: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826D0F88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826D0F8C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826D0F90: 419A0024  beq cr6, 0x826d0fb4
	if ctx.cr[6].eq {
	pc = 0x826D0FB4; continue 'dispatch;
	}
	// 826D0F94: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826D0F98: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826D0F9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D0FA0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826D0FA4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826D0FA8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D0FAC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D0FB0: 4082FFE8  bne 0x826d0f98
	if !ctx.cr[0].eq {
	pc = 0x826D0F98; continue 'dispatch;
	}
	// 826D0FB4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826D0FB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826D0FBC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826D0FC0: 419A0024  beq cr6, 0x826d0fe4
	if ctx.cr[6].eq {
	pc = 0x826D0FE4; continue 'dispatch;
	}
	// 826D0FC4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826D0FC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D0FCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D0FD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D0FD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D0FD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D0FDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D0FE0: 4082FFE8  bne 0x826d0fc8
	if !ctx.cr[0].eq {
	pc = 0x826D0FC8; continue 'dispatch;
	}
	// 826D0FE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D0FE8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826D0FEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826D0FF0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826D0FF4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D0FF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D0FFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D1000: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826D1004: 480C7F2D  bl 0x82798f30
	ctx.lr = 0x826D1008;
	sub_82798F30(ctx, base);
	// 826D1008: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D100C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1010: 480CA659  bl 0x8279b668
	ctx.lr = 0x826D1014;
	sub_8279B668(ctx, base);
	// 826D1014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1018: 48000008  b 0x826d1020
	pc = 0x826D1020; continue 'dispatch;
	// 826D101C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826D1020: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826D1024: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826D1028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D102C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D1030: 4BEC6C21  bl 0x82597c50
	ctx.lr = 0x826D1034;
	sub_82597C50(ctx, base);
	// 826D1034: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D1038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D103C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D1040: 4BBEEFC1  bl 0x822c0000
	ctx.lr = 0x826D1044;
	sub_822C0000(ctx, base);
	// 826D1044: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D1048: 41820024  beq 0x826d106c
	if ctx.cr[0].eq {
	pc = 0x826D106C; continue 'dispatch;
	}
	// 826D104C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826D1050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1054: 419A0008  beq cr6, 0x826d105c
	if ctx.cr[6].eq {
	pc = 0x826D105C; continue 'dispatch;
	}
	// 826D1058: 4BBEF839  bl 0x822c0890
	ctx.lr = 0x826D105C;
	sub_822C0890(ctx, base);
	// 826D105C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826D1060: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1064: 419A0008  beq cr6, 0x826d106c
	if ctx.cr[6].eq {
	pc = 0x826D106C; continue 'dispatch;
	}
	// 826D1068: 4BBEF829  bl 0x822c0890
	ctx.lr = 0x826D106C;
	sub_822C0890(ctx, base);
	// 826D106C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826D1070: 419A000C  beq cr6, 0x826d107c
	if ctx.cr[6].eq {
	pc = 0x826D107C; continue 'dispatch;
	}
	// 826D1074: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D1078: 4BBEF819  bl 0x822c0890
	ctx.lr = 0x826D107C;
	sub_822C0890(ctx, base);
	// 826D107C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826D1080: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826D1084: 48AD7130  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1088 size=52
    let mut pc: u32 = 0x826D1088;
    'dispatch: loop {
        match pc {
            0x826D1088 => {
    //   block [0x826D1088..0x826D10BC)
	// 826D1088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D108C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1090: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1094: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1098: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826D109C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D10A0: 4BFFFE39  bl 0x826d0ed8
	ctx.lr = 0x826D10A4;
	sub_826D0ED8(ctx, base);
	// 826D10A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D10A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D10AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D10B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D10B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D10B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D10C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D10C0 size=52
    let mut pc: u32 = 0x826D10C0;
    'dispatch: loop {
        match pc {
            0x826D10C0 => {
    //   block [0x826D10C0..0x826D10F4)
	// 826D10C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D10C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D10C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D10CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D10D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D10D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D10D8: 4BFFFE01  bl 0x826d0ed8
	ctx.lr = 0x826D10DC;
	sub_826D0ED8(ctx, base);
	// 826D10DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D10E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D10E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D10E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D10EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D10F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D10F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D10F8 size=52
    let mut pc: u32 = 0x826D10F8;
    'dispatch: loop {
        match pc {
            0x826D10F8 => {
    //   block [0x826D10F8..0x826D112C)
	// 826D10F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D10FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1104: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1108: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 826D110C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1110: 4BFFFDC9  bl 0x826d0ed8
	ctx.lr = 0x826D1114;
	sub_826D0ED8(ctx, base);
	// 826D1114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1118: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D111C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1120: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1124: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1128: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1130 size=52
    let mut pc: u32 = 0x826D1130;
    'dispatch: loop {
        match pc {
            0x826D1130 => {
    //   block [0x826D1130..0x826D1164)
	// 826D1130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1138: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D113C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1140: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 826D1144: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1148: 4BFFFD91  bl 0x826d0ed8
	ctx.lr = 0x826D114C;
	sub_826D0ED8(ctx, base);
	// 826D114C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1150: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D1154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D115C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1168 size=52
    let mut pc: u32 = 0x826D1168;
    'dispatch: loop {
        match pc {
            0x826D1168 => {
    //   block [0x826D1168..0x826D119C)
	// 826D1168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D116C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1178: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 826D117C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1180: 4BFFFD59  bl 0x826d0ed8
	ctx.lr = 0x826D1184;
	sub_826D0ED8(ctx, base);
	// 826D1184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1188: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D118C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1190: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D11A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D11A0 size=52
    let mut pc: u32 = 0x826D11A0;
    'dispatch: loop {
        match pc {
            0x826D11A0 => {
    //   block [0x826D11A0..0x826D11D4)
	// 826D11A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D11A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D11A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D11AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D11B0: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 826D11B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D11B8: 4BFFFD21  bl 0x826d0ed8
	ctx.lr = 0x826D11BC;
	sub_826D0ED8(ctx, base);
	// 826D11BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D11C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D11C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D11C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D11CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D11D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D11D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D11D8 size=52
    let mut pc: u32 = 0x826D11D8;
    'dispatch: loop {
        match pc {
            0x826D11D8 => {
    //   block [0x826D11D8..0x826D120C)
	// 826D11D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D11DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D11E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D11E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D11E8: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826D11EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D11F0: 4BFFFCE9  bl 0x826d0ed8
	ctx.lr = 0x826D11F4;
	sub_826D0ED8(ctx, base);
	// 826D11F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D11F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D11FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1210 size=52
    let mut pc: u32 = 0x826D1210;
    'dispatch: loop {
        match pc {
            0x826D1210 => {
    //   block [0x826D1210..0x826D1244)
	// 826D1210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D121C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1220: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 826D1224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1228: 4BFFFCB1  bl 0x826d0ed8
	ctx.lr = 0x826D122C;
	sub_826D0ED8(ctx, base);
	// 826D122C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1230: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D1234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D123C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1248 size=52
    let mut pc: u32 = 0x826D1248;
    'dispatch: loop {
        match pc {
            0x826D1248 => {
    //   block [0x826D1248..0x826D127C)
	// 826D1248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D124C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1250: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1254: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1258: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 826D125C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1260: 4BFFFC79  bl 0x826d0ed8
	ctx.lr = 0x826D1264;
	sub_826D0ED8(ctx, base);
	// 826D1264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D126C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1280 size=3012
    let mut pc: u32 = 0x826D1280;
    'dispatch: loop {
        match pc {
            0x826D1280 => {
    //   block [0x826D1280..0x826D1E44)
	// 826D1280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1284: 48AD6EAD  bl 0x831a8130
	ctx.lr = 0x826D1288;
	sub_831A8130(ctx, base);
	// 826D1288: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D128C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826D1290: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826D1294: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826D1298: 4BE3E231  bl 0x8250f4c8
	ctx.lr = 0x826D129C;
	sub_8250F4C8(ctx, base);
	// 826D129C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D12A0: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 826D12A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D12A8: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 826D12AC: 409A0008  bne cr6, 0x826d12b4
	if !ctx.cr[6].eq {
	pc = 0x826D12B4; continue 'dispatch;
	}
	// 826D12B0: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D12B4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826D12B8: 487209D9  bl 0x82df1c90
	ctx.lr = 0x826D12BC;
	sub_82DF1C90(ctx, base);
	// 826D12BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D12C0: 419A0B7C  beq cr6, 0x826d1e3c
	if ctx.cr[6].eq {
	pc = 0x826D1E3C; continue 'dispatch;
	}
	// 826D12C4: 83DC01F4  lwz r30, 0x1f4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(500 as u32) ) } as u64;
	// 826D12C8: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 826D12CC: 817C01F8  lwz r11, 0x1f8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(504 as u32) ) } as u64;
	// 826D12D0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D12D4: 419A0058  beq cr6, 0x826d132c
	if ctx.cr[6].eq {
	pc = 0x826D132C; continue 'dispatch;
	}
	// 826D12D8: 3BFC01F0  addi r31, r28, 0x1f0
	ctx.r[31].s64 = ctx.r[28].s64 + 496;
	// 826D12DC: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 826D12E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D12E4: 809B7058  lwz r4, 0x7058(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826D12E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826D12EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D12F0: 4BE3EF01  bl 0x825101f0
	ctx.lr = 0x826D12F4;
	sub_825101F0(ctx, base);
	// 826D12F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826D12F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D12FC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D1300: 4BBF4051  bl 0x822c5350
	ctx.lr = 0x826D1304;
	sub_822C5350(ctx, base);
	// 826D1304: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D1308: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D130C: 3864FFF8  addi r3, r4, -8
	ctx.r[3].s64 = ctx.r[4].s64 + -8;
	// 826D1310: 48101039  bl 0x827d2348
	ctx.lr = 0x826D1314;
	sub_827D2348(ctx, base);
	// 826D1314: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D1318: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 826D131C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826D1320: 817C01F8  lwz r11, 0x1f8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(504 as u32) ) } as u64;
	// 826D1324: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1328: 409AFFB8  bne cr6, 0x826d12e0
	if !ctx.cr[6].eq {
	pc = 0x826D12E0; continue 'dispatch;
	}
	// 826D132C: 91FC0220  stw r15, 0x220(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(544 as u32), ctx.r[15].u32 ) };
	// 826D1330: 3BDC0220  addi r30, r28, 0x220
	ctx.r[30].s64 = ctx.r[28].s64 + 544;
	// 826D1334: 807C0224  lwz r3, 0x224(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(548 as u32) ) } as u64;
	// 826D1338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D133C: 91FC0224  stw r15, 0x224(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(548 as u32), ctx.r[15].u32 ) };
	// 826D1340: 419A0008  beq cr6, 0x826d1348
	if ctx.cr[6].eq {
	pc = 0x826D1348; continue 'dispatch;
	}
	// 826D1344: 4BBEF54D  bl 0x822c0890
	ctx.lr = 0x826D1348;
	sub_822C0890(ctx, base);
	// 826D1348: 91FC0228  stw r15, 0x228(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(552 as u32), ctx.r[15].u32 ) };
	// 826D134C: 3BFC0228  addi r31, r28, 0x228
	ctx.r[31].s64 = ctx.r[28].s64 + 552;
	// 826D1350: 807C022C  lwz r3, 0x22c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(556 as u32) ) } as u64;
	// 826D1354: 91FC022C  stw r15, 0x22c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(556 as u32), ctx.r[15].u32 ) };
	// 826D1358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D135C: 419A0008  beq cr6, 0x826d1364
	if ctx.cr[6].eq {
	pc = 0x826D1364; continue 'dispatch;
	}
	// 826D1360: 4BBEF531  bl 0x822c0890
	ctx.lr = 0x826D1364;
	sub_822C0890(ctx, base);
	// 826D1364: 91FC0230  stw r15, 0x230(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(560 as u32), ctx.r[15].u32 ) };
	// 826D1368: 3BBC0230  addi r29, r28, 0x230
	ctx.r[29].s64 = ctx.r[28].s64 + 560;
	// 826D136C: 807C0234  lwz r3, 0x234(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(564 as u32) ) } as u64;
	// 826D1370: 91FC0234  stw r15, 0x234(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(564 as u32), ctx.r[15].u32 ) };
	// 826D1374: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1378: 419A0008  beq cr6, 0x826d1380
	if ctx.cr[6].eq {
	pc = 0x826D1380; continue 'dispatch;
	}
	// 826D137C: 4BBEF515  bl 0x822c0890
	ctx.lr = 0x826D1380;
	sub_822C0890(ctx, base);
	// 826D1380: 91FC0238  stw r15, 0x238(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(568 as u32), ctx.r[15].u32 ) };
	// 826D1384: 3B7C0238  addi r27, r28, 0x238
	ctx.r[27].s64 = ctx.r[28].s64 + 568;
	// 826D1388: 807C023C  lwz r3, 0x23c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(572 as u32) ) } as u64;
	// 826D138C: 91FC023C  stw r15, 0x23c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(572 as u32), ctx.r[15].u32 ) };
	// 826D1390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1394: 419A0008  beq cr6, 0x826d139c
	if ctx.cr[6].eq {
	pc = 0x826D139C; continue 'dispatch;
	}
	// 826D1398: 4BBEF4F9  bl 0x822c0890
	ctx.lr = 0x826D139C;
	sub_822C0890(ctx, base);
	// 826D139C: 91FC0240  stw r15, 0x240(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(576 as u32), ctx.r[15].u32 ) };
	// 826D13A0: 3ABC0240  addi r21, r28, 0x240
	ctx.r[21].s64 = ctx.r[28].s64 + 576;
	// 826D13A4: 807C0244  lwz r3, 0x244(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(580 as u32) ) } as u64;
	// 826D13A8: 91FC0244  stw r15, 0x244(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(580 as u32), ctx.r[15].u32 ) };
	// 826D13AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D13B0: 419A0008  beq cr6, 0x826d13b8
	if ctx.cr[6].eq {
	pc = 0x826D13B8; continue 'dispatch;
	}
	// 826D13B4: 4BBEF4DD  bl 0x822c0890
	ctx.lr = 0x826D13B8;
	sub_822C0890(ctx, base);
	// 826D13B8: 91FC0248  stw r15, 0x248(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(584 as u32), ctx.r[15].u32 ) };
	// 826D13BC: 3A7C0248  addi r19, r28, 0x248
	ctx.r[19].s64 = ctx.r[28].s64 + 584;
	// 826D13C0: 807C024C  lwz r3, 0x24c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(588 as u32) ) } as u64;
	// 826D13C4: 91FC024C  stw r15, 0x24c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(588 as u32), ctx.r[15].u32 ) };
	// 826D13C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D13CC: 419A0008  beq cr6, 0x826d13d4
	if ctx.cr[6].eq {
	pc = 0x826D13D4; continue 'dispatch;
	}
	// 826D13D0: 4BBEF4C1  bl 0x822c0890
	ctx.lr = 0x826D13D4;
	sub_822C0890(ctx, base);
	// 826D13D4: 91FC0250  stw r15, 0x250(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(592 as u32), ctx.r[15].u32 ) };
	// 826D13D8: 3B5C0250  addi r26, r28, 0x250
	ctx.r[26].s64 = ctx.r[28].s64 + 592;
	// 826D13DC: 807C0254  lwz r3, 0x254(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(596 as u32) ) } as u64;
	// 826D13E0: 91FC0254  stw r15, 0x254(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(596 as u32), ctx.r[15].u32 ) };
	// 826D13E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D13E8: 419A0008  beq cr6, 0x826d13f0
	if ctx.cr[6].eq {
	pc = 0x826D13F0; continue 'dispatch;
	}
	// 826D13EC: 4BBEF4A5  bl 0x822c0890
	ctx.lr = 0x826D13F0;
	sub_822C0890(ctx, base);
	// 826D13F0: 91FC0258  stw r15, 0x258(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(600 as u32), ctx.r[15].u32 ) };
	// 826D13F4: 3B3C0258  addi r25, r28, 0x258
	ctx.r[25].s64 = ctx.r[28].s64 + 600;
	// 826D13F8: 807C025C  lwz r3, 0x25c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(604 as u32) ) } as u64;
	// 826D13FC: 91FC025C  stw r15, 0x25c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(604 as u32), ctx.r[15].u32 ) };
	// 826D1400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1404: 419A0008  beq cr6, 0x826d140c
	if ctx.cr[6].eq {
	pc = 0x826D140C; continue 'dispatch;
	}
	// 826D1408: 4BBEF489  bl 0x822c0890
	ctx.lr = 0x826D140C;
	sub_822C0890(ctx, base);
	// 826D140C: 91FC0260  stw r15, 0x260(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(608 as u32), ctx.r[15].u32 ) };
	// 826D1410: 3B1C0260  addi r24, r28, 0x260
	ctx.r[24].s64 = ctx.r[28].s64 + 608;
	// 826D1414: 807C0264  lwz r3, 0x264(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(612 as u32) ) } as u64;
	// 826D1418: 91FC0264  stw r15, 0x264(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(612 as u32), ctx.r[15].u32 ) };
	// 826D141C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1420: 419A0008  beq cr6, 0x826d1428
	if ctx.cr[6].eq {
	pc = 0x826D1428; continue 'dispatch;
	}
	// 826D1424: 4BBEF46D  bl 0x822c0890
	ctx.lr = 0x826D1428;
	sub_822C0890(ctx, base);
	// 826D1428: 91FC0268  stw r15, 0x268(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(616 as u32), ctx.r[15].u32 ) };
	// 826D142C: 3AFC0268  addi r23, r28, 0x268
	ctx.r[23].s64 = ctx.r[28].s64 + 616;
	// 826D1430: 807C026C  lwz r3, 0x26c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(620 as u32) ) } as u64;
	// 826D1434: 91FC026C  stw r15, 0x26c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(620 as u32), ctx.r[15].u32 ) };
	// 826D1438: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D143C: 419A0008  beq cr6, 0x826d1444
	if ctx.cr[6].eq {
	pc = 0x826D1444; continue 'dispatch;
	}
	// 826D1440: 4BBEF451  bl 0x822c0890
	ctx.lr = 0x826D1444;
	sub_822C0890(ctx, base);
	// 826D1444: 3ADC0270  addi r22, r28, 0x270
	ctx.r[22].s64 = ctx.r[28].s64 + 624;
	// 826D1448: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D144C: 4BBF575D  bl 0x822c6ba8
	ctx.lr = 0x826D1450;
	sub_822C6BA8(ctx, base);
	// 826D1450: 3A5C0280  addi r18, r28, 0x280
	ctx.r[18].s64 = ctx.r[28].s64 + 640;
	// 826D1454: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 826D1458: 4BBF5751  bl 0x822c6ba8
	ctx.lr = 0x826D145C;
	sub_822C6BA8(ctx, base);
	// 826D145C: 3A9C0290  addi r20, r28, 0x290
	ctx.r[20].s64 = ctx.r[28].s64 + 656;
	// 826D1460: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826D1464: 4BBF5745  bl 0x822c6ba8
	ctx.lr = 0x826D1468;
	sub_822C6BA8(ctx, base);
	// 826D1468: 3A3C02A0  addi r17, r28, 0x2a0
	ctx.r[17].s64 = ctx.r[28].s64 + 672;
	// 826D146C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 826D1470: 4BBF5739  bl 0x822c6ba8
	ctx.lr = 0x826D1474;
	sub_822C6BA8(ctx, base);
	// 826D1474: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826D1478: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826D147C: 4BE3E04D  bl 0x8250f4c8
	ctx.lr = 0x826D1480;
	sub_8250F4C8(ctx, base);
	// 826D1480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1484: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1488: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826D148C: 409A0008  bne cr6, 0x826d1494
	if !ctx.cr[6].eq {
	pc = 0x826D1494; continue 'dispatch;
	}
	// 826D1490: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 826D1494: 4BE37095  bl 0x82508528
	ctx.lr = 0x826D1498;
	sub_82508528(ctx, base);
	// 826D1498: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D149C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D14A0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D14A4: 48759645  bl 0x82e2aae8
	ctx.lr = 0x826D14A8;
	sub_82E2AAE8(ctx, base);
	// 826D14A8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826D14AC: 487207E5  bl 0x82df1c90
	ctx.lr = 0x826D14B0;
	sub_82DF1C90(ctx, base);
	// 826D14B0: 815C02E8  lwz r10, 0x2e8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(744 as u32) ) } as u64;
	// 826D14B4: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D14B8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826D14BC: 396BCC3C  addi r11, r11, -0x33c4
	ctx.r[11].s64 = ctx.r[11].s64 + -13252;
	// 826D14C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D14C4: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826D14C8: 48722541  bl 0x82df3a08
	ctx.lr = 0x826D14CC;
	sub_82DF3A08(ctx, base);
	// 826D14CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D14D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826D14D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D14D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826D14DC: 4875D995  bl 0x82e2ee70
	ctx.lr = 0x826D14E0;
	sub_82E2EE70(ctx, base);
	// 826D14E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D14E4: 48721F45  bl 0x82df3428
	ctx.lr = 0x826D14E8;
	sub_82DF3428(ctx, base);
	// 826D14E8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826D14EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D14F0: 419A0934  beq cr6, 0x826d1e24
	if ctx.cr[6].eq {
	pc = 0x826D1E24; continue 'dispatch;
	}
	// 826D14F4: 817C02E8  lwz r11, 0x2e8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(744 as u32) ) } as u64;
	// 826D14F8: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826D14FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1500: 394ACC44  addi r10, r10, -0x33bc
	ctx.r[10].s64 = ctx.r[10].s64 + -13244;
	// 826D1504: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D1508: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826D150C: 487224FD  bl 0x82df3a08
	ctx.lr = 0x826D1510;
	sub_82DF3A08(ctx, base);
	// 826D1510: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1514: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826D1518: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D151C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826D1520: 4875D951  bl 0x82e2ee70
	ctx.lr = 0x826D1524;
	sub_82E2EE70(ctx, base);
	// 826D1524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1528: 48721F01  bl 0x82df3428
	ctx.lr = 0x826D152C;
	sub_82DF3428(ctx, base);
	// 826D152C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 826D1530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1534: 419A08E0  beq cr6, 0x826d1e14
	if ctx.cr[6].eq {
	pc = 0x826D1E14; continue 'dispatch;
	}
	// 826D1538: 817C02E8  lwz r11, 0x2e8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(744 as u32) ) } as u64;
	// 826D153C: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826D1540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1544: 394ACC4C  addi r10, r10, -0x33b4
	ctx.r[10].s64 = ctx.r[10].s64 + -13236;
	// 826D1548: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D154C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826D1550: 487224B9  bl 0x82df3a08
	ctx.lr = 0x826D1554;
	sub_82DF3A08(ctx, base);
	// 826D1554: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1558: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826D155C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D1560: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826D1564: 4875D90D  bl 0x82e2ee70
	ctx.lr = 0x826D1568;
	sub_82E2EE70(ctx, base);
	// 826D1568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D156C: 48721EBD  bl 0x82df3428
	ctx.lr = 0x826D1570;
	sub_82DF3428(ctx, base);
	// 826D1570: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 826D1574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1578: 419A088C  beq cr6, 0x826d1e04
	if ctx.cr[6].eq {
	pc = 0x826D1E04; continue 'dispatch;
	}
	// 826D157C: 817C02E8  lwz r11, 0x2e8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(744 as u32) ) } as u64;
	// 826D1580: 3D40832A  lis r10, -0x7cd6
	ctx.r[10].s64 = -2094399488;
	// 826D1584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1588: 394ACC54  addi r10, r10, -0x33ac
	ctx.r[10].s64 = ctx.r[10].s64 + -13228;
	// 826D158C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D1590: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 826D1594: 48722475  bl 0x82df3a08
	ctx.lr = 0x826D1598;
	sub_82DF3A08(ctx, base);
	// 826D1598: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D159C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826D15A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D15A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826D15A8: 4875D8C9  bl 0x82e2ee70
	ctx.lr = 0x826D15AC;
	sub_82E2EE70(ctx, base);
	// 826D15AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D15B0: 48721E79  bl 0x82df3428
	ctx.lr = 0x826D15B4;
	sub_82DF3428(ctx, base);
	// 826D15B4: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 826D15B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D15BC: 419A0838  beq cr6, 0x826d1df4
	if ctx.cr[6].eq {
	pc = 0x826D1DF4; continue 'dispatch;
	}
	// 826D15C0: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D15C4: 91E10058  stw r15, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[15].u32 ) };
	// 826D15C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D15CC: 91E1005C  stw r15, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[15].u32 ) };
	// 826D15D0: 3A0B8CF0  addi r16, r11, -0x7310
	ctx.r[16].s64 = ctx.r[11].s64 + -29456;
	// 826D15D4: 38A001A1  li r5, 0x1a1
	ctx.r[5].s64 = 417;
	// 826D15D8: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D15DC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D15E0: 48720E09  bl 0x82df23e8
	ctx.lr = 0x826D15E4;
	sub_82DF23E8(ctx, base);
	// 826D15E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D15E8: 41820010  beq 0x826d15f8
	if ctx.cr[0].eq {
	pc = 0x826D15F8; continue 'dispatch;
	}
	// 826D15EC: 48741A1D  bl 0x82e13008
	ctx.lr = 0x826D15F0;
	sub_82E13008(ctx, base);
	// 826D15F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D15F4: 48000008  b 0x826d15fc
	pc = 0x826D15FC; continue 'dispatch;
	// 826D15F8: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D15FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D1600: 4BC10751  bl 0x822e1d50
	ctx.lr = 0x826D1604;
	sub_822E1D50(ctx, base);
	// 826D1604: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826D1608: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826D160C: 81DE0000  lwz r14, 0(r30)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1610: 4BE40B09  bl 0x82512118
	ctx.lr = 0x826D1614;
	sub_82512118(ctx, base);
	// 826D1614: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 826D1618: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D161C: 48741815  bl 0x82e12e30
	ctx.lr = 0x826D1620;
	sub_82E12E30(ctx, base);
	// 826D1620: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826D1624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1628: 419A0008  beq cr6, 0x826d1630
	if ctx.cr[6].eq {
	pc = 0x826D1630; continue 'dispatch;
	}
	// 826D162C: 4BBEF265  bl 0x822c0890
	ctx.lr = 0x826D1630;
	sub_822C0890(ctx, base);
	// 826D1630: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1638: 38A001A3  li r5, 0x1a3
	ctx.r[5].s64 = 419;
	// 826D163C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1640: 48720DA9  bl 0x82df23e8
	ctx.lr = 0x826D1644;
	sub_82DF23E8(ctx, base);
	// 826D1644: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1648: 41820010  beq 0x826d1658
	if ctx.cr[0].eq {
	pc = 0x826D1658; continue 'dispatch;
	}
	// 826D164C: 487419BD  bl 0x82e13008
	ctx.lr = 0x826D1650;
	sub_82E13008(ctx, base);
	// 826D1650: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1654: 48000008  b 0x826d165c
	pc = 0x826D165C; continue 'dispatch;
	// 826D1658: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D165C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1660: 4BC106F1  bl 0x822e1d50
	ctx.lr = 0x826D1664;
	sub_822E1D50(ctx, base);
	// 826D1664: 897C02F8  lbz r11, 0x2f8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(760 as u32) ) } as u64;
	// 826D1668: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D166C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1670: 4182000C  beq 0x826d167c
	if ctx.cr[0].eq {
	pc = 0x826D167C; continue 'dispatch;
	}
	// 826D1674: 807C0140  lwz r3, 0x140(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(320 as u32) ) } as u64;
	// 826D1678: 48000008  b 0x826d1680
	pc = 0x826D1680; continue 'dispatch;
	// 826D167C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1680: 487417B1  bl 0x82e12e30
	ctx.lr = 0x826D1684;
	sub_82E12E30(ctx, base);
	// 826D1684: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1688: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D168C: 38A001AC  li r5, 0x1ac
	ctx.r[5].s64 = 428;
	// 826D1690: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1694: 48720D55  bl 0x82df23e8
	ctx.lr = 0x826D1698;
	sub_82DF23E8(ctx, base);
	// 826D1698: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D169C: 41820010  beq 0x826d16ac
	if ctx.cr[0].eq {
	pc = 0x826D16AC; continue 'dispatch;
	}
	// 826D16A0: 48741969  bl 0x82e13008
	ctx.lr = 0x826D16A4;
	sub_82E13008(ctx, base);
	// 826D16A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D16A8: 48000008  b 0x826d16b0
	pc = 0x826D16B0; continue 'dispatch;
	// 826D16AC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D16B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D16B4: 4BC1069D  bl 0x822e1d50
	ctx.lr = 0x826D16B8;
	sub_822E1D50(ctx, base);
	// 826D16B8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D16BC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D16C0: 48741771  bl 0x82e12e30
	ctx.lr = 0x826D16C4;
	sub_82E12E30(ctx, base);
	// 826D16C4: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D16C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D16CC: 38A001AE  li r5, 0x1ae
	ctx.r[5].s64 = 430;
	// 826D16D0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D16D4: 48720D15  bl 0x82df23e8
	ctx.lr = 0x826D16D8;
	sub_82DF23E8(ctx, base);
	// 826D16D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D16DC: 41820010  beq 0x826d16ec
	if ctx.cr[0].eq {
	pc = 0x826D16EC; continue 'dispatch;
	}
	// 826D16E0: 48741929  bl 0x82e13008
	ctx.lr = 0x826D16E4;
	sub_82E13008(ctx, base);
	// 826D16E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D16E8: 48000008  b 0x826d16f0
	pc = 0x826D16F0; continue 'dispatch;
	// 826D16EC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D16F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826D16F4: 4BC1065D  bl 0x822e1d50
	ctx.lr = 0x826D16F8;
	sub_822E1D50(ctx, base);
	// 826D16F8: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D16FC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1700: 48741731  bl 0x82e12e30
	ctx.lr = 0x826D1704;
	sub_82E12E30(ctx, base);
	// 826D1704: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1708: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D170C: 38A001B1  li r5, 0x1b1
	ctx.r[5].s64 = 433;
	// 826D1710: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1714: 48720CD5  bl 0x82df23e8
	ctx.lr = 0x826D1718;
	sub_82DF23E8(ctx, base);
	// 826D1718: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D171C: 41820010  beq 0x826d172c
	if ctx.cr[0].eq {
	pc = 0x826D172C; continue 'dispatch;
	}
	// 826D1720: 487418E9  bl 0x82e13008
	ctx.lr = 0x826D1724;
	sub_82E13008(ctx, base);
	// 826D1724: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1728: 48000008  b 0x826d1730
	pc = 0x826D1730; continue 'dispatch;
	// 826D172C: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1730: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 826D1734: 4BC1061D  bl 0x822e1d50
	ctx.lr = 0x826D1738;
	sub_822E1D50(ctx, base);
	// 826D1738: 80950000  lwz r4, 0(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D173C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1740: 487416F1  bl 0x82e12e30
	ctx.lr = 0x826D1744;
	sub_82E12E30(ctx, base);
	// 826D1744: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D174C: 38A001B3  li r5, 0x1b3
	ctx.r[5].s64 = 435;
	// 826D1750: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1754: 48720C95  bl 0x82df23e8
	ctx.lr = 0x826D1758;
	sub_82DF23E8(ctx, base);
	// 826D1758: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D175C: 41820010  beq 0x826d176c
	if ctx.cr[0].eq {
	pc = 0x826D176C; continue 'dispatch;
	}
	// 826D1760: 487418A9  bl 0x82e13008
	ctx.lr = 0x826D1764;
	sub_82E13008(ctx, base);
	// 826D1764: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1768: 48000008  b 0x826d1770
	pc = 0x826D1770; continue 'dispatch;
	// 826D176C: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1770: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 826D1774: 4BC105DD  bl 0x822e1d50
	ctx.lr = 0x826D1778;
	sub_822E1D50(ctx, base);
	// 826D1778: 80930000  lwz r4, 0(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D177C: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1780: 487416B1  bl 0x82e12e30
	ctx.lr = 0x826D1784;
	sub_82E12E30(ctx, base);
	// 826D1784: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1788: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D178C: 38A001B6  li r5, 0x1b6
	ctx.r[5].s64 = 438;
	// 826D1790: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1794: 48720C55  bl 0x82df23e8
	ctx.lr = 0x826D1798;
	sub_82DF23E8(ctx, base);
	// 826D1798: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D179C: 41820010  beq 0x826d17ac
	if ctx.cr[0].eq {
	pc = 0x826D17AC; continue 'dispatch;
	}
	// 826D17A0: 48741869  bl 0x82e13008
	ctx.lr = 0x826D17A4;
	sub_82E13008(ctx, base);
	// 826D17A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D17A8: 48000008  b 0x826d17b0
	pc = 0x826D17B0; continue 'dispatch;
	// 826D17AC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D17B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826D17B4: 4BC1059D  bl 0x822e1d50
	ctx.lr = 0x826D17B8;
	sub_822E1D50(ctx, base);
	// 826D17B8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D17BC: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D17C0: 48741671  bl 0x82e12e30
	ctx.lr = 0x826D17C4;
	sub_82E12E30(ctx, base);
	// 826D17C4: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D17C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D17CC: 38A001B8  li r5, 0x1b8
	ctx.r[5].s64 = 440;
	// 826D17D0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D17D4: 48720C15  bl 0x82df23e8
	ctx.lr = 0x826D17D8;
	sub_82DF23E8(ctx, base);
	// 826D17D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D17DC: 41820010  beq 0x826d17ec
	if ctx.cr[0].eq {
	pc = 0x826D17EC; continue 'dispatch;
	}
	// 826D17E0: 48741829  bl 0x82e13008
	ctx.lr = 0x826D17E4;
	sub_82E13008(ctx, base);
	// 826D17E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D17E8: 48000008  b 0x826d17f0
	pc = 0x826D17F0; continue 'dispatch;
	// 826D17EC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D17F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826D17F4: 4BC1055D  bl 0x822e1d50
	ctx.lr = 0x826D17F8;
	sub_822E1D50(ctx, base);
	// 826D17F8: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D17FC: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1800: 48741631  bl 0x82e12e30
	ctx.lr = 0x826D1804;
	sub_82E12E30(ctx, base);
	// 826D1804: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1808: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D180C: 38A001BA  li r5, 0x1ba
	ctx.r[5].s64 = 442;
	// 826D1810: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1814: 48720BD5  bl 0x82df23e8
	ctx.lr = 0x826D1818;
	sub_82DF23E8(ctx, base);
	// 826D1818: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D181C: 41820010  beq 0x826d182c
	if ctx.cr[0].eq {
	pc = 0x826D182C; continue 'dispatch;
	}
	// 826D1820: 487417E9  bl 0x82e13008
	ctx.lr = 0x826D1824;
	sub_82E13008(ctx, base);
	// 826D1824: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1828: 48000008  b 0x826d1830
	pc = 0x826D1830; continue 'dispatch;
	// 826D182C: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1830: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 826D1834: 4BC1051D  bl 0x822e1d50
	ctx.lr = 0x826D1838;
	sub_822E1D50(ctx, base);
	// 826D1838: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D183C: 80730000  lwz r3, 0(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1840: 487415F1  bl 0x82e12e30
	ctx.lr = 0x826D1844;
	sub_82E12E30(ctx, base);
	// 826D1844: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1848: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D184C: 38A001BC  li r5, 0x1bc
	ctx.r[5].s64 = 444;
	// 826D1850: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1854: 48720B95  bl 0x82df23e8
	ctx.lr = 0x826D1858;
	sub_82DF23E8(ctx, base);
	// 826D1858: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D185C: 41820010  beq 0x826d186c
	if ctx.cr[0].eq {
	pc = 0x826D186C; continue 'dispatch;
	}
	// 826D1860: 487417A9  bl 0x82e13008
	ctx.lr = 0x826D1864;
	sub_82E13008(ctx, base);
	// 826D1864: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1868: 48000008  b 0x826d1870
	pc = 0x826D1870; continue 'dispatch;
	// 826D186C: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1870: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 826D1874: 4BC104DD  bl 0x822e1d50
	ctx.lr = 0x826D1878;
	sub_822E1D50(ctx, base);
	// 826D1878: 80970000  lwz r4, 0(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D187C: 80730000  lwz r3, 0(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1880: 487415B1  bl 0x82e12e30
	ctx.lr = 0x826D1884;
	sub_82E12E30(ctx, base);
	// 826D1884: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D1888: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D188C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1890: 4099006C  ble cr6, 0x826d18fc
	if !ctx.cr[6].gt {
	pc = 0x826D18FC; continue 'dispatch;
	}
	// 826D1894: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1898: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D189C: 38A001C3  li r5, 0x1c3
	ctx.r[5].s64 = 451;
	// 826D18A0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D18A4: 48720B45  bl 0x82df23e8
	ctx.lr = 0x826D18A8;
	sub_82DF23E8(ctx, base);
	// 826D18A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D18AC: 41820010  beq 0x826d18bc
	if ctx.cr[0].eq {
	pc = 0x826D18BC; continue 'dispatch;
	}
	// 826D18B0: 48741759  bl 0x82e13008
	ctx.lr = 0x826D18B4;
	sub_82E13008(ctx, base);
	// 826D18B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D18B8: 48000008  b 0x826d18c0
	pc = 0x826D18C0; continue 'dispatch;
	// 826D18BC: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D18C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D18C4: 4BC1048D  bl 0x822e1d50
	ctx.lr = 0x826D18C8;
	sub_822E1D50(ctx, base);
	// 826D18C8: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 826D18CC: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826D18D0: 396B004A  addi r11, r11, 0x4a
	ctx.r[11].s64 = ctx.r[11].s64 + 74;
	// 826D18D4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D18D8: 7C6BE02E  lwzx r3, r11, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826D18DC: 48741555  bl 0x82e12e30
	ctx.lr = 0x826D18E0;
	sub_82E12E30(ctx, base);
	// 826D18E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826D18E4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D18E8: 484E1821  bl 0x82bb3108
	ctx.lr = 0x826D18EC;
	sub_82BB3108(ctx, base);
	// 826D18EC: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D18F0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826D18F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D18F8: 4198FF9C  blt cr6, 0x826d1894
	if ctx.cr[6].lt {
	pc = 0x826D1894; continue 'dispatch;
	}
	// 826D18FC: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D1900: 37EBFFFF  addic. r31, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D1904: 40810058  ble 0x826d195c
	if !ctx.cr[0].gt {
	pc = 0x826D195C; continue 'dispatch;
	}
	// 826D1908: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D190C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1910: 38A001CC  li r5, 0x1cc
	ctx.r[5].s64 = 460;
	// 826D1914: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D1918: 48720AD1  bl 0x82df23e8
	ctx.lr = 0x826D191C;
	sub_82DF23E8(ctx, base);
	// 826D191C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1920: 41820010  beq 0x826d1930
	if ctx.cr[0].eq {
	pc = 0x826D1930; continue 'dispatch;
	}
	// 826D1924: 487416E5  bl 0x82e13008
	ctx.lr = 0x826D1928;
	sub_82E13008(ctx, base);
	// 826D1928: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D192C: 48000008  b 0x826d1934
	pc = 0x826D1934; continue 'dispatch;
	// 826D1930: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1934: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D1938: 4BC10419  bl 0x822e1d50
	ctx.lr = 0x826D193C;
	sub_822E1D50(ctx, base);
	// 826D193C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826D1940: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1944: 487414ED  bl 0x82e12e30
	ctx.lr = 0x826D1948;
	sub_82E12E30(ctx, base);
	// 826D1948: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826D194C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 826D1950: 484E17B9  bl 0x82bb3108
	ctx.lr = 0x826D1954;
	sub_82BB3108(ctx, base);
	// 826D1954: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D1958: 4082FFB0  bne 0x826d1908
	if !ctx.cr[0].eq {
	pc = 0x826D1908; continue 'dispatch;
	}
	// 826D195C: 817C02F0  lwz r11, 0x2f0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D1960: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D1964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1968: 4099006C  ble cr6, 0x826d19d4
	if !ctx.cr[6].gt {
	pc = 0x826D19D4; continue 'dispatch;
	}
	// 826D196C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1970: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1974: 38A001D5  li r5, 0x1d5
	ctx.r[5].s64 = 469;
	// 826D1978: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D197C: 48720A6D  bl 0x82df23e8
	ctx.lr = 0x826D1980;
	sub_82DF23E8(ctx, base);
	// 826D1980: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1984: 41820010  beq 0x826d1994
	if ctx.cr[0].eq {
	pc = 0x826D1994; continue 'dispatch;
	}
	// 826D1988: 48741681  bl 0x82e13008
	ctx.lr = 0x826D198C;
	sub_82E13008(ctx, base);
	// 826D198C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1990: 48000008  b 0x826d1998
	pc = 0x826D1998; continue 'dispatch;
	// 826D1994: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D199C: 4BC103B5  bl 0x822e1d50
	ctx.lr = 0x826D19A0;
	sub_822E1D50(ctx, base);
	// 826D19A0: 57EB07FE  clrlwi r11, r31, 0x1f
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00000001u64;
	// 826D19A4: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826D19A8: 396B004C  addi r11, r11, 0x4c
	ctx.r[11].s64 = ctx.r[11].s64 + 76;
	// 826D19AC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D19B0: 7C6BE02E  lwzx r3, r11, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 826D19B4: 4874147D  bl 0x82e12e30
	ctx.lr = 0x826D19B8;
	sub_82E12E30(ctx, base);
	// 826D19B8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826D19BC: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 826D19C0: 484E1749  bl 0x82bb3108
	ctx.lr = 0x826D19C4;
	sub_82BB3108(ctx, base);
	// 826D19C4: 817C02F0  lwz r11, 0x2f0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D19C8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826D19CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D19D0: 4198FF9C  blt cr6, 0x826d196c
	if ctx.cr[6].lt {
	pc = 0x826D196C; continue 'dispatch;
	}
	// 826D19D4: 817C02F0  lwz r11, 0x2f0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D19D8: 37EBFFFF  addic. r31, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D19DC: 40810058  ble 0x826d1a34
	if !ctx.cr[0].gt {
	pc = 0x826D1A34; continue 'dispatch;
	}
	// 826D19E0: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D19E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D19E8: 38A001DE  li r5, 0x1de
	ctx.r[5].s64 = 478;
	// 826D19EC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826D19F0: 487209F9  bl 0x82df23e8
	ctx.lr = 0x826D19F4;
	sub_82DF23E8(ctx, base);
	// 826D19F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D19F8: 41820010  beq 0x826d1a08
	if ctx.cr[0].eq {
	pc = 0x826D1A08; continue 'dispatch;
	}
	// 826D19FC: 4874160D  bl 0x82e13008
	ctx.lr = 0x826D1A00;
	sub_82E13008(ctx, base);
	// 826D1A00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1A04: 48000008  b 0x826d1a0c
	pc = 0x826D1A0C; continue 'dispatch;
	// 826D1A08: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1A0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D1A10: 4BC10341  bl 0x822e1d50
	ctx.lr = 0x826D1A14;
	sub_822E1D50(ctx, base);
	// 826D1A14: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826D1A18: 80730000  lwz r3, 0(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1A1C: 48741415  bl 0x82e12e30
	ctx.lr = 0x826D1A20;
	sub_82E12E30(ctx, base);
	// 826D1A20: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826D1A24: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 826D1A28: 484E16E1  bl 0x82bb3108
	ctx.lr = 0x826D1A2C;
	sub_82BB3108(ctx, base);
	// 826D1A2C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D1A30: 4082FFB0  bne 0x826d19e0
	if !ctx.cr[0].eq {
	pc = 0x826D19E0; continue 'dispatch;
	}
	// 826D1A34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D1A38: 4BFFCD69  bl 0x826ce7a0
	ctx.lr = 0x826D1A3C;
	sub_826CE7A0(ctx, base);
	// 826D1A3C: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D1A40: 91E10054  stw r15, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[15].u32 ) };
	// 826D1A44: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D1A48: 91E10050  stw r15, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[15].u32 ) };
	// 826D1A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1A50: 419A00F0  beq cr6, 0x826d1b40
	if ctx.cr[6].eq {
	pc = 0x826D1B40; continue 'dispatch;
	}
	// 826D1A54: 3BDC01F0  addi r30, r28, 0x1f0
	ctx.r[30].s64 = ctx.r[28].s64 + 496;
	// 826D1A58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D1A5C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1A60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1A64: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826D1A68: 409A001C  bne cr6, 0x826d1a84
	if !ctx.cr[6].eq {
	pc = 0x826D1A84; continue 'dispatch;
	}
	// 826D1A6C: 38A001ED  li r5, 0x1ed
	ctx.r[5].s64 = 493;
	// 826D1A70: 48720979  bl 0x82df23e8
	ctx.lr = 0x826D1A74;
	sub_82DF23E8(ctx, base);
	// 826D1A74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1A78: 41820050  beq 0x826d1ac8
	if ctx.cr[0].eq {
	pc = 0x826D1AC8; continue 'dispatch;
	}
	// 826D1A7C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826D1A80: 4800003C  b 0x826d1abc
	pc = 0x826D1ABC; continue 'dispatch;
	// 826D1A84: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826D1A88: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1A8C: 409A001C  bne cr6, 0x826d1aa8
	if !ctx.cr[6].eq {
	pc = 0x826D1AA8; continue 'dispatch;
	}
	// 826D1A90: 38A001F1  li r5, 0x1f1
	ctx.r[5].s64 = 497;
	// 826D1A94: 48720955  bl 0x82df23e8
	ctx.lr = 0x826D1A98;
	sub_82DF23E8(ctx, base);
	// 826D1A98: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1A9C: 4182002C  beq 0x826d1ac8
	if ctx.cr[0].eq {
	pc = 0x826D1AC8; continue 'dispatch;
	}
	// 826D1AA0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826D1AA4: 48000018  b 0x826d1abc
	pc = 0x826D1ABC; continue 'dispatch;
	// 826D1AA8: 38A001F5  li r5, 0x1f5
	ctx.r[5].s64 = 501;
	// 826D1AAC: 4872093D  bl 0x82df23e8
	ctx.lr = 0x826D1AB0;
	sub_82DF23E8(ctx, base);
	// 826D1AB0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1AB4: 41820014  beq 0x826d1ac8
	if ctx.cr[0].eq {
	pc = 0x826D1AC8; continue 'dispatch;
	}
	// 826D1AB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826D1ABC: 48744DD5  bl 0x82e16890
	ctx.lr = 0x826D1AC0;
	sub_82E16890(ctx, base);
	// 826D1AC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1AC4: 48000008  b 0x826d1acc
	pc = 0x826D1ACC; continue 'dispatch;
	// 826D1AC8: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1ACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1AD0: 4BC8B8A1  bl 0x8235d370
	ctx.lr = 0x826D1AD4;
	sub_8235D370(ctx, base);
	// 826D1AD4: 817C0274  lwz r11, 0x274(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(628 as u32) ) } as u64;
	// 826D1AD8: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 826D1ADC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 826D1AE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1AE4: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 826D1AE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D1AEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1AF0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 826D1AF4: 419A0024  beq cr6, 0x826d1b18
	if ctx.cr[6].eq {
	pc = 0x826D1B18; continue 'dispatch;
	}
	// 826D1AF8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D1AFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D1B00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1B04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D1B08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D1B0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D1B10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1B14: 4082FFE8  bne 0x826d1afc
	if !ctx.cr[0].eq {
	pc = 0x826D1AFC; continue 'dispatch;
	}
	// 826D1B18: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826D1B1C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D1B20: 48743591  bl 0x82e150b0
	ctx.lr = 0x826D1B24;
	sub_82E150B0(ctx, base);
	// 826D1B24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D1B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D1B2C: 484E15DD  bl 0x82bb3108
	ctx.lr = 0x826D1B30;
	sub_82BB3108(ctx, base);
	// 826D1B30: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D1B34: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826D1B38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1B3C: 4198FF1C  blt cr6, 0x826d1a58
	if ctx.cr[6].lt {
	pc = 0x826D1A58; continue 'dispatch;
	}
	// 826D1B40: 817C02EC  lwz r11, 0x2ec(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D1B44: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D1B48: 408100AC  ble 0x826d1bf4
	if !ctx.cr[0].gt {
	pc = 0x826D1BF4; continue 'dispatch;
	}
	// 826D1B4C: 3BBC01F0  addi r29, r28, 0x1f0
	ctx.r[29].s64 = ctx.r[28].s64 + 496;
	// 826D1B50: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D1B54: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 826D1B58: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1B5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1B60: 38A001FF  li r5, 0x1ff
	ctx.r[5].s64 = 511;
	// 826D1B64: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826D1B68: 48720881  bl 0x82df23e8
	ctx.lr = 0x826D1B6C;
	sub_82DF23E8(ctx, base);
	// 826D1B6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1B70: 41820014  beq 0x826d1b84
	if ctx.cr[0].eq {
	pc = 0x826D1B84; continue 'dispatch;
	}
	// 826D1B74: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826D1B78: 48744D19  bl 0x82e16890
	ctx.lr = 0x826D1B7C;
	sub_82E16890(ctx, base);
	// 826D1B7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1B80: 48000008  b 0x826d1b88
	pc = 0x826D1B88; continue 'dispatch;
	// 826D1B84: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1B8C: 4BC8B7E5  bl 0x8235d370
	ctx.lr = 0x826D1B90;
	sub_8235D370(ctx, base);
	// 826D1B90: 817C0294  lwz r11, 0x294(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(660 as u32) ) } as u64;
	// 826D1B94: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 826D1B98: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1B9C: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 826D1BA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D1BA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1BA8: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 826D1BAC: 419A0024  beq cr6, 0x826d1bd0
	if ctx.cr[6].eq {
	pc = 0x826D1BD0; continue 'dispatch;
	}
	// 826D1BB0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D1BB4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D1BB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1BBC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D1BC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D1BC4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D1BC8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1BCC: 4082FFE8  bne 0x826d1bb4
	if !ctx.cr[0].eq {
	pc = 0x826D1BB4; continue 'dispatch;
	}
	// 826D1BD0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826D1BD4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D1BD8: 487434D9  bl 0x82e150b0
	ctx.lr = 0x826D1BDC;
	sub_82E150B0(ctx, base);
	// 826D1BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D1BE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D1BE4: 484E1525  bl 0x82bb3108
	ctx.lr = 0x826D1BE8;
	sub_82BB3108(ctx, base);
	// 826D1BE8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826D1BEC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826D1BF0: 4082FF68  bne 0x826d1b58
	if !ctx.cr[0].eq {
	pc = 0x826D1B58; continue 'dispatch;
	}
	// 826D1BF4: 817C02F0  lwz r11, 0x2f0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D1BF8: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D1BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1C00: 419A00F0  beq cr6, 0x826d1cf0
	if ctx.cr[6].eq {
	pc = 0x826D1CF0; continue 'dispatch;
	}
	// 826D1C04: 3BDC01F0  addi r30, r28, 0x1f0
	ctx.r[30].s64 = ctx.r[28].s64 + 496;
	// 826D1C08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D1C0C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1C10: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1C14: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826D1C18: 409A001C  bne cr6, 0x826d1c34
	if !ctx.cr[6].eq {
	pc = 0x826D1C34; continue 'dispatch;
	}
	// 826D1C1C: 38A00208  li r5, 0x208
	ctx.r[5].s64 = 520;
	// 826D1C20: 487207C9  bl 0x82df23e8
	ctx.lr = 0x826D1C24;
	sub_82DF23E8(ctx, base);
	// 826D1C24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1C28: 41820050  beq 0x826d1c78
	if ctx.cr[0].eq {
	pc = 0x826D1C78; continue 'dispatch;
	}
	// 826D1C2C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826D1C30: 4800003C  b 0x826d1c6c
	pc = 0x826D1C6C; continue 'dispatch;
	// 826D1C34: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826D1C38: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1C3C: 409A001C  bne cr6, 0x826d1c58
	if !ctx.cr[6].eq {
	pc = 0x826D1C58; continue 'dispatch;
	}
	// 826D1C40: 38A0020C  li r5, 0x20c
	ctx.r[5].s64 = 524;
	// 826D1C44: 487207A5  bl 0x82df23e8
	ctx.lr = 0x826D1C48;
	sub_82DF23E8(ctx, base);
	// 826D1C48: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1C4C: 4182002C  beq 0x826d1c78
	if ctx.cr[0].eq {
	pc = 0x826D1C78; continue 'dispatch;
	}
	// 826D1C50: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 826D1C54: 48000018  b 0x826d1c6c
	pc = 0x826D1C6C; continue 'dispatch;
	// 826D1C58: 38A00210  li r5, 0x210
	ctx.r[5].s64 = 528;
	// 826D1C5C: 4872078D  bl 0x82df23e8
	ctx.lr = 0x826D1C60;
	sub_82DF23E8(ctx, base);
	// 826D1C60: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1C64: 41820014  beq 0x826d1c78
	if ctx.cr[0].eq {
	pc = 0x826D1C78; continue 'dispatch;
	}
	// 826D1C68: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826D1C6C: 48744C25  bl 0x82e16890
	ctx.lr = 0x826D1C70;
	sub_82E16890(ctx, base);
	// 826D1C70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1C74: 48000008  b 0x826d1c7c
	pc = 0x826D1C7C; continue 'dispatch;
	// 826D1C78: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1C7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1C80: 4BC8B6F1  bl 0x8235d370
	ctx.lr = 0x826D1C84;
	sub_8235D370(ctx, base);
	// 826D1C84: 815C0284  lwz r10, 0x284(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(644 as u32) ) } as u64;
	// 826D1C88: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D1C8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 826D1C90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1C94: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 826D1C98: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D1C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1CA0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 826D1CA4: 419A0024  beq cr6, 0x826d1cc8
	if ctx.cr[6].eq {
	pc = 0x826D1CC8; continue 'dispatch;
	}
	// 826D1CA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D1CAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D1CB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1CB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D1CB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D1CBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D1CC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1CC4: 4082FFE8  bne 0x826d1cac
	if !ctx.cr[0].eq {
	pc = 0x826D1CAC; continue 'dispatch;
	}
	// 826D1CC8: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826D1CCC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D1CD0: 487433E1  bl 0x82e150b0
	ctx.lr = 0x826D1CD4;
	sub_82E150B0(ctx, base);
	// 826D1CD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D1CD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D1CDC: 484E142D  bl 0x82bb3108
	ctx.lr = 0x826D1CE0;
	sub_82BB3108(ctx, base);
	// 826D1CE0: 817C02F0  lwz r11, 0x2f0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D1CE4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 826D1CE8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1CEC: 4198FF1C  blt cr6, 0x826d1c08
	if ctx.cr[6].lt {
	pc = 0x826D1C08; continue 'dispatch;
	}
	// 826D1CF0: 817C02F0  lwz r11, 0x2f0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D1CF4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D1CF8: 408100AC  ble 0x826d1da4
	if !ctx.cr[0].gt {
	pc = 0x826D1DA4; continue 'dispatch;
	}
	// 826D1CFC: 3BBC01F0  addi r29, r28, 0x1f0
	ctx.r[29].s64 = ctx.r[28].s64 + 496;
	// 826D1D00: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 826D1D04: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 826D1D08: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 826D1D0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D1D10: 38A0021A  li r5, 0x21a
	ctx.r[5].s64 = 538;
	// 826D1D14: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826D1D18: 487206D1  bl 0x82df23e8
	ctx.lr = 0x826D1D1C;
	sub_82DF23E8(ctx, base);
	// 826D1D1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1D20: 41820014  beq 0x826d1d34
	if ctx.cr[0].eq {
	pc = 0x826D1D34; continue 'dispatch;
	}
	// 826D1D24: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826D1D28: 48744B69  bl 0x82e16890
	ctx.lr = 0x826D1D2C;
	sub_82E16890(ctx, base);
	// 826D1D2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D1D30: 48000008  b 0x826d1d38
	pc = 0x826D1D38; continue 'dispatch;
	// 826D1D34: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 826D1D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D1D3C: 4BC8B635  bl 0x8235d370
	ctx.lr = 0x826D1D40;
	sub_8235D370(ctx, base);
	// 826D1D40: 817C02A4  lwz r11, 0x2a4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(676 as u32) ) } as u64;
	// 826D1D44: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 826D1D48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1D4C: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 826D1D50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D1D54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1D58: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 826D1D5C: 419A0024  beq cr6, 0x826d1d80
	if ctx.cr[6].eq {
	pc = 0x826D1D80; continue 'dispatch;
	}
	// 826D1D60: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D1D64: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D1D68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1D6C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D1D70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D1D74: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D1D78: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D1D7C: 4082FFE8  bne 0x826d1d64
	if !ctx.cr[0].eq {
	pc = 0x826D1D64; continue 'dispatch;
	}
	// 826D1D80: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 826D1D84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D1D88: 48743329  bl 0x82e150b0
	ctx.lr = 0x826D1D8C;
	sub_82E150B0(ctx, base);
	// 826D1D8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D1D90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D1D94: 484E1375  bl 0x82bb3108
	ctx.lr = 0x826D1D98;
	sub_82BB3108(ctx, base);
	// 826D1D98: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826D1D9C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826D1DA0: 4082FF68  bne 0x826d1d08
	if !ctx.cr[0].eq {
	pc = 0x826D1D08; continue 'dispatch;
	}
	// 826D1DA4: 83FC01F4  lwz r31, 0x1f4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(500 as u32) ) } as u64;
	// 826D1DA8: 48000020  b 0x826d1dc8
	pc = 0x826D1DC8; continue 'dispatch;
	// 826D1DAC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826D1DB0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D1DB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D1DB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D1DBC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826D1DC0: 4BE3ED99  bl 0x82510b58
	ctx.lr = 0x826D1DC4;
	sub_82510B58(ctx, base);
	// 826D1DC4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826D1DC8: 817C01F8  lwz r11, 0x1f8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(504 as u32) ) } as u64;
	// 826D1DCC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1DD0: 409AFFDC  bne cr6, 0x826d1dac
	if !ctx.cr[6].eq {
	pc = 0x826D1DAC; continue 'dispatch;
	}
	// 826D1DD4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826D1DD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1DDC: 419A0008  beq cr6, 0x826d1de4
	if ctx.cr[6].eq {
	pc = 0x826D1DE4; continue 'dispatch;
	}
	// 826D1DE0: 4BBEEAB1  bl 0x822c0890
	ctx.lr = 0x826D1DE4;
	sub_822C0890(ctx, base);
	// 826D1DE4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826D1DE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1DEC: 419A0008  beq cr6, 0x826d1df4
	if ctx.cr[6].eq {
	pc = 0x826D1DF4; continue 'dispatch;
	}
	// 826D1DF0: 4BBEEAA1  bl 0x822c0890
	ctx.lr = 0x826D1DF4;
	sub_822C0890(ctx, base);
	// 826D1DF4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826D1DF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1DFC: 419A0008  beq cr6, 0x826d1e04
	if ctx.cr[6].eq {
	pc = 0x826D1E04; continue 'dispatch;
	}
	// 826D1E00: 4BBEEA91  bl 0x822c0890
	ctx.lr = 0x826D1E04;
	sub_822C0890(ctx, base);
	// 826D1E04: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826D1E08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1E0C: 419A0008  beq cr6, 0x826d1e14
	if ctx.cr[6].eq {
	pc = 0x826D1E14; continue 'dispatch;
	}
	// 826D1E10: 4BBEEA81  bl 0x822c0890
	ctx.lr = 0x826D1E14;
	sub_822C0890(ctx, base);
	// 826D1E14: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826D1E18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1E1C: 419A0008  beq cr6, 0x826d1e24
	if ctx.cr[6].eq {
	pc = 0x826D1E24; continue 'dispatch;
	}
	// 826D1E20: 4BBEEA71  bl 0x822c0890
	ctx.lr = 0x826D1E24;
	sub_822C0890(ctx, base);
	// 826D1E24: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826D1E28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D1E2C: 419A0008  beq cr6, 0x826d1e34
	if ctx.cr[6].eq {
	pc = 0x826D1E34; continue 'dispatch;
	}
	// 826D1E30: 4BBEEA61  bl 0x822c0890
	ctx.lr = 0x826D1E34;
	sub_822C0890(ctx, base);
	// 826D1E34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D1E38: 48758CC9  bl 0x82e2ab00
	ctx.lr = 0x826D1E3C;
	sub_82E2AB00(ctx, base);
	// 826D1E3C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 826D1E40: 48AD6340  b 0x831a8180
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1E48 size=76
    let mut pc: u32 = 0x826D1E48;
    'dispatch: loop {
        match pc {
            0x826D1E48 => {
    //   block [0x826D1E48..0x826D1E94)
	// 826D1E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1E50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1E54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1E5C: 4BFD0FAD  bl 0x826a2e08
	ctx.lr = 0x826D1E60;
	sub_826A2E08(ctx, base);
	// 826D1E60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1E64: 4BFFF41D  bl 0x826d1280
	ctx.lr = 0x826D1E68;
	sub_826D1280(ctx, base);
	// 826D1E68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1E6C: 4BFFE3C5  bl 0x826d0230
	ctx.lr = 0x826D1E70;
	sub_826D0230(ctx, base);
	// 826D1E70: 817F02EC  lwz r11, 0x2ec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(748 as u32) ) } as u64;
	// 826D1E74: 815F02F0  lwz r10, 0x2f0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(752 as u32) ) } as u64;
	// 826D1E78: 917F02E0  stw r11, 0x2e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(736 as u32), ctx.r[11].u32 ) };
	// 826D1E7C: 915F02E4  stw r10, 0x2e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(740 as u32), ctx.r[10].u32 ) };
	// 826D1E80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D1E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1E98 size=160
    let mut pc: u32 = 0x826D1E98;
    'dispatch: loop {
        match pc {
            0x826D1E98 => {
    //   block [0x826D1E98..0x826D1F38)
	// 826D1E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1EA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1EAC: 4BFD5DFD  bl 0x826a7ca8
	ctx.lr = 0x826D1EB0;
	sub_826A7CA8(ctx, base);
	// 826D1EB0: 817F01FC  lwz r11, 0x1fc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) } as u64;
	// 826D1EB4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826D1EB8: 815F0208  lwz r10, 0x208(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 826D1EBC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826D1EC0: 419A0024  beq cr6, 0x826d1ee4
	if ctx.cr[6].eq {
	pc = 0x826D1EE4; continue 'dispatch;
	}
	// 826D1EC4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 826D1EC8: 409A0010  bne cr6, 0x826d1ed8
	if !ctx.cr[6].eq {
	pc = 0x826D1ED8; continue 'dispatch;
	}
	// 826D1ECC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 826D1ED0: 556BE7BC  rlwinm r11, r11, 0x1c, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 826D1ED4: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 826D1ED8: 817F0208  lwz r11, 0x208(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) } as u64;
	// 826D1EDC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826D1EE0: 917F01FC  stw r11, 0x1fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 826D1EE4: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 826D1EE8: 815F0200  lwz r10, 0x200(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) } as u64;
	// 826D1EEC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D1EF0: 419A0024  beq cr6, 0x826d1f14
	if ctx.cr[6].eq {
	pc = 0x826D1F14; continue 'dispatch;
	}
	// 826D1EF4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826D1EF8: 409A0010  bne cr6, 0x826d1f08
	if !ctx.cr[6].eq {
	pc = 0x826D1F08; continue 'dispatch;
	}
	// 826D1EFC: 7D4B0034  cntlzw r11, r10
	ctx.r[11].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 826D1F00: 556BE7BC  rlwinm r11, r11, 0x1c, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 826D1F04: 917F020C  stw r11, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 826D1F08: 817F020C  lwz r11, 0x20c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) } as u64;
	// 826D1F0C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826D1F10: 917F0200  stw r11, 0x200(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 826D1F14: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D1F18: 4182000C  beq 0x826d1f24
	if ctx.cr[0].eq {
	pc = 0x826D1F24; continue 'dispatch;
	}
	// 826D1F1C: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 826D1F20: 4BFFF361  bl 0x826d1280
	ctx.lr = 0x826D1F24;
	sub_826D1280(ctx, base);
	// 826D1F24: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D1F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1F30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1F38 size=52
    let mut pc: u32 = 0x826D1F38;
    'dispatch: loop {
        match pc {
            0x826D1F38 => {
    //   block [0x826D1F38..0x826D1F6C)
	// 826D1F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1F40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1F44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D1F4C: 4BFD0EB5  bl 0x826a2e00
	ctx.lr = 0x826D1F50;
	sub_826A2E00(ctx, base);
	// 826D1F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1F54: 4BFFF32D  bl 0x826d1280
	ctx.lr = 0x826D1F58;
	sub_826D1280(ctx, base);
	// 826D1F58: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826D1F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D1F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D1F64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D1F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D1F70 size=4
    let mut pc: u32 = 0x826D1F70;
    'dispatch: loop {
        match pc {
            0x826D1F70 => {
    //   block [0x826D1F70..0x826D1F74)
	// 826D1F70: 4BE406A8  b 0x82512618
	sub_82512618(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D1F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D1F78 size=196
    let mut pc: u32 = 0x826D1F78;
    'dispatch: loop {
        match pc {
            0x826D1F78 => {
    //   block [0x826D1F78..0x826D203C)
	// 826D1F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D1F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D1F80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D1F84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D1F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D1F8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826D1F90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D1F94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826D1F98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826D1F9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D1FA0: 4BBEE999  bl 0x822c0938
	ctx.lr = 0x826D1FA4;
	sub_822C0938(ctx, base);
	// 826D1FA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D1FA8: 41820028  beq 0x826d1fd0
	if ctx.cr[0].eq {
	pc = 0x826D1FD0; continue 'dispatch;
	}
	// 826D1FAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D1FB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826D1FB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826D1FB8: 392B9008  addi r9, r11, -0x6ff8
	ctx.r[9].s64 = ctx.r[11].s64 + -28664;
	// 826D1FBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826D1FC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D1FC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826D1FC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826D1FCC: 48000008  b 0x826d1fd4
	pc = 0x826D1FD4; continue 'dispatch;
	// 826D1FD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D1FD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D1FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D1FDC: 409A0044  bne cr6, 0x826d2020
	if !ctx.cr[6].eq {
	pc = 0x826D2020; continue 'dispatch;
	}
	// 826D1FE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D1FE4: 419A001C  beq cr6, 0x826d2000
	if ctx.cr[6].eq {
	pc = 0x826D2000; continue 'dispatch;
	}
	// 826D1FE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1FEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D1FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D1FF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D1FF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D1FFC: 4E800421  bctrl
	ctx.lr = 0x826D2000;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D2000: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D2004: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826D2008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D200C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826D2010: 816BCD94  lwz r11, -0x326c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12908 as u32) ) } as u64;
	// 826D2014: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D2018: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D201C: 4BBEDFE5  bl 0x822c0000
	ctx.lr = 0x826D2020;
	sub_822C0000(ctx, base);
	// 826D2020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D2024: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D2028: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D202C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D2030: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D2034: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D2038: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D2040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D2040 size=104
    let mut pc: u32 = 0x826D2040;
    'dispatch: loop {
        match pc {
            0x826D2040 => {
    //   block [0x826D2040..0x826D20A8)
	// 826D2040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D2044: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D2048: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D204C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D2050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D2054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826D2058: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826D205C: 48000014  b 0x826d2070
	pc = 0x826D2070; continue 'dispatch;
	// 826D2060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D2064: 48731F7D  bl 0x82e03fe0
	ctx.lr = 0x826D2068;
	sub_82E03FE0(ctx, base);
	// 826D2068: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 826D206C: 4872057D  bl 0x82df25e8
	ctx.lr = 0x826D2070;
	sub_82DF25E8(ctx, base);
	// 826D2070: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2074: 4875732D  bl 0x82e293a0
	ctx.lr = 0x826D2078;
	sub_82E293A0(ctx, base);
	// 826D2078: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D207C: 4182FFE4  beq 0x826d2060
	if ctx.cr[0].eq {
	pc = 0x826D2060; continue 'dispatch;
	}
	// 826D2080: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D2084: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2088: 419A0008  beq cr6, 0x826d2090
	if ctx.cr[6].eq {
	pc = 0x826D2090; continue 'dispatch;
	}
	// 826D208C: 4BBEE805  bl 0x822c0890
	ctx.lr = 0x826D2090;
	sub_822C0890(ctx, base);
	// 826D2090: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D2094: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D2098: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D209C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D20A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D20A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D20A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D20A8 size=232
    let mut pc: u32 = 0x826D20A8;
    'dispatch: loop {
        match pc {
            0x826D20A8 => {
    //   block [0x826D20A8..0x826D2190)
	// 826D20A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D20AC: 48AD60C1  bl 0x831a816c
	ctx.lr = 0x826D20B0;
	sub_831A8130(ctx, base);
	// 826D20B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D20B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D20B8: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 826D20BC: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826D20C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D20C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D20C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D20CC: 419A0024  beq cr6, 0x826d20f0
	if ctx.cr[6].eq {
	pc = 0x826D20F0; continue 'dispatch;
	}
	// 826D20D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D20D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D20D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D20DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D20E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D20E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D20E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D20EC: 4082FFE8  bne 0x826d20d4
	if !ctx.cr[0].eq {
	pc = 0x826D20D4; continue 'dispatch;
	}
	// 826D20F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D20F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D20F8: 4BE3D3D1  bl 0x8250f4c8
	ctx.lr = 0x826D20FC;
	sub_8250F4C8(ctx, base);
	// 826D20FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2104: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826D2108: 409A0008  bne cr6, 0x826d2110
	if !ctx.cr[6].eq {
	pc = 0x826D2110; continue 'dispatch;
	}
	// 826D210C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826D2110: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2118: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 826D211C: 4BE3D3FD  bl 0x8250f518
	ctx.lr = 0x826D2120;
	sub_8250F518(ctx, base);
	// 826D2120: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D2128: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D212C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826D2130: 4BE3B3D9  bl 0x8250d508
	ctx.lr = 0x826D2134;
	sub_8250D508(ctx, base);
	// 826D2134: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2138: 4871FB59  bl 0x82df1c90
	ctx.lr = 0x826D213C;
	sub_82DF1C90(ctx, base);
	// 826D213C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2140: 4871FB51  bl 0x82df1c90
	ctx.lr = 0x826D2144;
	sub_82DF1C90(ctx, base);
	// 826D2144: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826D2148: 48474581  bl 0x82b466c8
	ctx.lr = 0x826D214C;
	sub_82B466C8(ctx, base);
	// 826D214C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2150: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2154: 4BE3F995  bl 0x82511ae8
	ctx.lr = 0x826D2158;
	sub_82511AE8(ctx, base);
	// 826D2158: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D215C: 815E002C  lwz r10, 0x2c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 826D2160: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826D2164: 38AB9018  addi r5, r11, -0x6fe8
	ctx.r[5].s64 = ctx.r[11].s64 + -28648;
	// 826D2168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D216C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826D2170: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 826D2174: 4E800421  bctrl
	ctx.lr = 0x826D2178;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D2178: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826D217C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2180: 419A0008  beq cr6, 0x826d2188
	if ctx.cr[6].eq {
	pc = 0x826D2188; continue 'dispatch;
	}
	// 826D2184: 4BBEE70D  bl 0x822c0890
	ctx.lr = 0x826D2188;
	sub_822C0890(ctx, base);
	// 826D2188: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826D218C: 48AD6030  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D2190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D2190 size=156
    let mut pc: u32 = 0x826D2190;
    'dispatch: loop {
        match pc {
            0x826D2190 => {
    //   block [0x826D2190..0x826D222C)
	// 826D2190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D2194: 48AD5FD9  bl 0x831a816c
	ctx.lr = 0x826D2198;
	sub_831A8130(ctx, base);
	// 826D2198: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D219C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826D21A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826D21A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D21A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D21AC: 419A0068  beq cr6, 0x826d2214
	if ctx.cr[6].eq {
	pc = 0x826D2214; continue 'dispatch;
	}
	// 826D21B0: 487571F1  bl 0x82e293a0
	ctx.lr = 0x826D21B4;
	sub_82E293A0(ctx, base);
	// 826D21B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D21B8: 4082005C  bne 0x826d2214
	if !ctx.cr[0].eq {
	pc = 0x826D2214; continue 'dispatch;
	}
	// 826D21BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D21C0: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 826D21C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D21C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D21CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D21D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D21D4: 419A0024  beq cr6, 0x826d21f8
	if ctx.cr[6].eq {
	pc = 0x826D21F8; continue 'dispatch;
	}
	// 826D21D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D21DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D21E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D21E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D21E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D21EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D21F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D21F4: 4082FFE8  bne 0x826d21dc
	if !ctx.cr[0].eq {
	pc = 0x826D21DC; continue 'dispatch;
	}
	// 826D21F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D21FC: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 826D2200: 4BE17571  bl 0x824e9770
	ctx.lr = 0x826D2204;
	sub_824E9770(ctx, base);
	// 826D2204: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2208: 4BFFFE39  bl 0x826d2040
	ctx.lr = 0x826D220C;
	sub_826D2040(ctx, base);
	// 826D220C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2210: 48000008  b 0x826d2218
	pc = 0x826D2218; continue 'dispatch;
	// 826D2214: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D2218: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D221C: 419A0008  beq cr6, 0x826d2224
	if ctx.cr[6].eq {
	pc = 0x826D2224; continue 'dispatch;
	}
	// 826D2220: 4BBEE671  bl 0x822c0890
	ctx.lr = 0x826D2224;
	sub_822C0890(ctx, base);
	// 826D2224: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826D2228: 48AD5F94  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D2230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D2230 size=316
    let mut pc: u32 = 0x826D2230;
    'dispatch: loop {
        match pc {
            0x826D2230 => {
    //   block [0x826D2230..0x826D236C)
	// 826D2230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D2234: 48AD5F35  bl 0x831a8168
	ctx.lr = 0x826D2238;
	sub_831A8130(ctx, base);
	// 826D2238: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D223C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826D2240: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D2244: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 826D2248: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826D224C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826D2250: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2254: 388B9030  addi r4, r11, -0x6fd0
	ctx.r[4].s64 = ctx.r[11].s64 + -28624;
	// 826D2258: 38A000B1  li r5, 0xb1
	ctx.r[5].s64 = 177;
	// 826D225C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826D2260: 4BBEE179  bl 0x822c03d8
	ctx.lr = 0x826D2264;
	sub_822C03D8(ctx, base);
	// 826D2264: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D2268: 41820034  beq 0x826d229c
	if ctx.cr[0].eq {
	pc = 0x826D229C; continue 'dispatch;
	}
	// 826D226C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D2270: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D2274: 388B12AC  addi r4, r11, 0x12ac
	ctx.r[4].s64 = ctx.r[11].s64 + 4780;
	// 826D2278: 48721791  bl 0x82df3a08
	ctx.lr = 0x826D227C;
	sub_82DF3A08(ctx, base);
	// 826D227C: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 826D2280: 38BD0048  addi r5, r29, 0x48
	ctx.r[5].s64 = ctx.r[29].s64 + 72;
	// 826D2284: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D2288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D228C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826D2290: 4BED7D99  bl 0x825aa028
	ctx.lr = 0x826D2294;
	sub_825AA028(ctx, base);
	// 826D2294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D2298: 48000008  b 0x826d22a0
	pc = 0x826D22A0; continue 'dispatch;
	// 826D229C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826D22A0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D22A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D22A8: 388B114C  addi r4, r11, 0x114c
	ctx.r[4].s64 = ctx.r[11].s64 + 4428;
	// 826D22AC: 4872175D  bl 0x82df3a08
	ctx.lr = 0x826D22B0;
	sub_82DF3A08(ctx, base);
	// 826D22B0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 826D22B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D22B8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826D22BC: 4BED5465  bl 0x825a7720
	ctx.lr = 0x826D22C0;
	sub_825A7720(ctx, base);
	// 826D22C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D22C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D22C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826D22CC: 4BBEDD35  bl 0x822c0000
	ctx.lr = 0x826D22D0;
	sub_822C0000(ctx, base);
	// 826D22D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D22D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D22D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D22DC: 4BECFE35  bl 0x825a2110
	ctx.lr = 0x826D22E0;
	sub_825A2110(ctx, base);
	// 826D22E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D22E4: 48721145  bl 0x82df3428
	ctx.lr = 0x826D22E8;
	sub_82DF3428(ctx, base);
	// 826D22E8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D22EC: 4182000C  beq 0x826d22f8
	if ctx.cr[0].eq {
	pc = 0x826D22F8; continue 'dispatch;
	}
	// 826D22F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D22F4: 48721135  bl 0x82df3428
	ctx.lr = 0x826D22F8;
	sub_82DF3428(ctx, base);
	// 826D22F8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D22FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2300: 388B1298  addi r4, r11, 0x1298
	ctx.r[4].s64 = ctx.r[11].s64 + 4760;
	// 826D2304: 48721705  bl 0x82df3a08
	ctx.lr = 0x826D2308;
	sub_82DF3A08(ctx, base);
	// 826D2308: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D230C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D2310: 388B113C  addi r4, r11, 0x113c
	ctx.r[4].s64 = ctx.r[11].s64 + 4412;
	// 826D2314: 487216F5  bl 0x82df3a08
	ctx.lr = 0x826D2318;
	sub_82DF3A08(ctx, base);
	// 826D2318: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826D231C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826D2320: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2324: 38BD004C  addi r5, r29, 0x4c
	ctx.r[5].s64 = ctx.r[29].s64 + 76;
	// 826D2328: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D232C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2330: 4BEDB861  bl 0x825adb90
	ctx.lr = 0x826D2334;
	sub_825ADB90(ctx, base);
	// 826D2334: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D2338: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D233C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D2340: 4BECFA79  bl 0x825a1db8
	ctx.lr = 0x826D2344;
	sub_825A1DB8(ctx, base);
	// 826D2344: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826D2348: 487210E1  bl 0x82df3428
	ctx.lr = 0x826D234C;
	sub_82DF3428(ctx, base);
	// 826D234C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826D2350: 4BBF6969  bl 0x822c8cb8
	ctx.lr = 0x826D2354;
	sub_822C8CB8(ctx, base);
	// 826D2354: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D2358: 487210D1  bl 0x82df3428
	ctx.lr = 0x826D235C;
	sub_82DF3428(ctx, base);
	// 826D235C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2360: 487210C9  bl 0x82df3428
	ctx.lr = 0x826D2364;
	sub_82DF3428(ctx, base);
	// 826D2364: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 826D2368: 48AD5E50  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D2370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D2370 size=240
    let mut pc: u32 = 0x826D2370;
    'dispatch: loop {
        match pc {
            0x826D2370 => {
    //   block [0x826D2370..0x826D2460)
	// 826D2370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D2374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D2378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D237C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D2380: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826D2384: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826D2388: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D238C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D2390: 897F0128  lbz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 826D2394: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D2398: 408200A8  bne 0x826d2440
	if !ctx.cr[0].eq {
	pc = 0x826D2440; continue 'dispatch;
	}
	// 826D239C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D23A0: 815F0130  lwz r10, 0x130(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 826D23A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826D23A8: C3CB08A8  lfs f30, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826D23AC: 419A000C  beq cr6, 0x826d23b8
	if ctx.cr[6].eq {
	pc = 0x826D23B8; continue 'dispatch;
	}
	// 826D23B0: EFFE0828  fsubs f31, f30, f1
	ctx.f[31].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 826D23B4: 48000008  b 0x826d23bc
	pc = 0x826D23BC; continue 'dispatch;
	// 826D23B8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826D23BC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D23C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D23C4: 388B9080  addi r4, r11, -0x6f80
	ctx.r[4].s64 = ctx.r[11].s64 + -28544;
	// 826D23C8: 48721641  bl 0x82df3a08
	ctx.lr = 0x826D23CC;
	sub_82DF3A08(ctx, base);
	// 826D23CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826D23D0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D23D4: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826D23D8: 484E07F1  bl 0x82bb2bc8
	ctx.lr = 0x826D23DC;
	sub_82BB2BC8(ctx, base);
	// 826D23DC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826D23E0: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D23E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D23E8: 419A000C  beq cr6, 0x826d23f4
	if ctx.cr[6].eq {
	pc = 0x826D23F4; continue 'dispatch;
	}
	// 826D23EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 826D23F0: 4BBEE4A1  bl 0x822c0890
	ctx.lr = 0x826D23F4;
	sub_822C0890(ctx, base);
	// 826D23F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D23F8: 48721031  bl 0x82df3428
	ctx.lr = 0x826D23FC;
	sub_82DF3428(ctx, base);
	// 826D23FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2400: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D2404: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D2408: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D240C: 4E800421  bctrl
	ctx.lr = 0x826D2410;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D2410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D2414: EC2107F2  fmuls f1, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 826D2418: 484E66F9  bl 0x82bb8b10
	ctx.lr = 0x826D241C;
	sub_82BB8B10(ctx, base);
	// 826D241C: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 826D2420: C00BDFB0  lfs f0, -0x2050(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D2424: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 826D2428: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 826D242C: 41990014  bgt cr6, 0x826d2440
	if ctx.cr[6].gt {
	pc = 0x826D2440; continue 'dispatch;
	}
	// 826D2430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2434: 4BFFFC75  bl 0x826d20a8
	ctx.lr = 0x826D2438;
	sub_826D20A8(ctx, base);
	// 826D2438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826D243C: 997F0128  stb r11, 0x128(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u8 ) };
	// 826D2440: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826D2444: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D2448: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D244C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826D2450: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826D2454: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D2458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D245C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D2460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D2460 size=112
    let mut pc: u32 = 0x826D2460;
    'dispatch: loop {
        match pc {
            0x826D2460 => {
    //   block [0x826D2460..0x826D24D0)
	// 826D2460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D2464: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D2468: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D246C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D2470: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D2474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826D2478: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D247C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826D2480: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D2484: 4BE867E5  bl 0x82558c68
	ctx.lr = 0x826D2488;
	sub_82558C68(ctx, base);
	// 826D2488: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826D248C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D2490: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D2494: 4BBEDB6D  bl 0x822c0000
	ctx.lr = 0x826D2498;
	sub_822C0000(ctx, base);
	// 826D2498: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D249C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826D24A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D24A4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D24A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D24AC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826D24B0: 419A0008  beq cr6, 0x826d24b8
	if ctx.cr[6].eq {
	pc = 0x826D24B8; continue 'dispatch;
	}
	// 826D24B4: 4BBEE3DD  bl 0x822c0890
	ctx.lr = 0x826D24B8;
	sub_822C0890(ctx, base);
	// 826D24B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D24BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D24C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D24C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D24C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D24CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D24D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D24D0 size=240
    let mut pc: u32 = 0x826D24D0;
    'dispatch: loop {
        match pc {
            0x826D24D0 => {
    //   block [0x826D24D0..0x826D25C0)
	// 826D24D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D24D4: 48AD5C95  bl 0x831a8168
	ctx.lr = 0x826D24D8;
	sub_831A8130(ctx, base);
	// 826D24D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D24DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D24E0: 4BFF8111  bl 0x826ca5f0
	ctx.lr = 0x826D24E4;
	sub_826CA5F0(ctx, base);
	// 826D24E4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D24E8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826D24EC: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826D24F0: 396B90F4  addi r11, r11, -0x6f0c
	ctx.r[11].s64 = ctx.r[11].s64 + -28428;
	// 826D24F4: 394A90E0  addi r10, r10, -0x6f20
	ctx.r[10].s64 = ctx.r[10].s64 + -28448;
	// 826D24F8: 39299094  addi r9, r9, -0x6f6c
	ctx.r[9].s64 = ctx.r[9].s64 + -28524;
	// 826D24FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D2500: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826D2504: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826D2508: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826D250C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D2510: 93DF00E8  stw r30, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[30].u32 ) };
	// 826D2514: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826D2518: 93DF00EC  stw r30, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[30].u32 ) };
	// 826D251C: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826D2520: 93DF00F0  stw r30, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 826D2524: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2528: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 826D252C: 38899030  addi r4, r9, -0x6fd0
	ctx.r[4].s64 = ctx.r[9].s64 + -28624;
	// 826D2530: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 826D2534: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D2538: 93DF00FC  stw r30, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 826D253C: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 826D2540: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 826D2544: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 826D2548: 93DF0104  stw r30, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[30].u32 ) };
	// 826D254C: 3B9F0118  addi r28, r31, 0x118
	ctx.r[28].s64 = ctx.r[31].s64 + 280;
	// 826D2550: 93DF0108  stw r30, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u32 ) };
	// 826D2554: 93DF010C  stw r30, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 826D2558: 93DF0110  stw r30, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[30].u32 ) };
	// 826D255C: 93DF0114  stw r30, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[30].u32 ) };
	// 826D2560: 93DF0118  stw r30, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[30].u32 ) };
	// 826D2564: 93DF011C  stw r30, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 826D2568: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 826D256C: 93DF0124  stw r30, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[30].u32 ) };
	// 826D2570: 9BDF0128  stb r30, 0x128(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[30].u8 ) };
	// 826D2574: 816A853C  lwz r11, -0x7ac4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 826D2578: 93DF0130  stw r30, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[30].u32 ) };
	// 826D257C: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 826D2580: 4871FE69  bl 0x82df23e8
	ctx.lr = 0x826D2584;
	sub_82DF23E8(ctx, base);
	// 826D2584: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826D2588: 41820020  beq 0x826d25a8
	if ctx.cr[0].eq {
	pc = 0x826D25A8; continue 'dispatch;
	}
	// 826D258C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2590: 48787111  bl 0x82e596a0
	ctx.lr = 0x826D2594;
	sub_82E596A0(ctx, base);
	// 826D2594: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D2598: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826D259C: 396B1110  addi r11, r11, 0x1110
	ctx.r[11].s64 = ctx.r[11].s64 + 4368;
	// 826D25A0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D25A4: 48000008  b 0x826d25ac
	pc = 0x826D25AC; continue 'dispatch;
	// 826D25A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D25AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D25B0: 4BFD4501  bl 0x826a6ab0
	ctx.lr = 0x826D25B4;
	sub_826A6AB0(ctx, base);
	// 826D25B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D25B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826D25BC: 48AD5BFC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D25C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D25C0 size=2384
    let mut pc: u32 = 0x826D25C0;
    'dispatch: loop {
        match pc {
            0x826D25C0 => {
    //   block [0x826D25C0..0x826D2F10)
	// 826D25C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D25C4: 48AD5B89  bl 0x831a814c
	ctx.lr = 0x826D25C8;
	sub_831A8130(ctx, base);
	// 826D25C8: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 826D25CC: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 826D25D0: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D25D4: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 826D25D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D25DC: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 826D25E0: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 826D25E4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 826D25E8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 826D25EC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 826D25F0: 4BE3F3E9  bl 0x825119d8
	ctx.lr = 0x826D25F4;
	sub_825119D8(ctx, base);
	// 826D25F4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826D25F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D25FC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 826D2600: 48721409  bl 0x82df3a08
	ctx.lr = 0x826D2604;
	sub_82DF3A08(ctx, base);
	// 826D2604: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D2608: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D260C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D2610: 4BE36171  bl 0x82508780
	ctx.lr = 0x826D2614;
	sub_82508780(ctx, base);
	// 826D2614: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2618: 48720E11  bl 0x82df3428
	ctx.lr = 0x826D261C;
	sub_82DF3428(ctx, base);
	// 826D261C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D2620: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826D2624: 409A0008  bne cr6, 0x826d262c
	if !ctx.cr[6].eq {
	pc = 0x826D262C; continue 'dispatch;
	}
	// 826D2628: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826D262C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D2630: 4BE36171  bl 0x825087a0
	ctx.lr = 0x826D2634;
	sub_825087A0(ctx, base);
	// 826D2634: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D2638: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D263C: 3BCBCD74  addi r30, r11, -0x328c
	ctx.r[30].s64 = ctx.r[11].s64 + -12940;
	// 826D2640: 808BCD74  lwz r4, -0x328c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12940 as u32) ) } as u64;
	// 826D2644: 487213C5  bl 0x82df3a08
	ctx.lr = 0x826D2648;
	sub_82DF3A08(ctx, base);
	// 826D2648: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826D264C: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2650: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2654: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826D2658: 4BFF87C9  bl 0x826cae20
	ctx.lr = 0x826D265C;
	sub_826CAE20(ctx, base);
	// 826D265C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D2660: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 826D2664: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D2668: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826D266C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2670: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826D2674: 4BBF1DED  bl 0x822c4460
	ctx.lr = 0x826D2678;
	sub_822C4460(ctx, base);
	// 826D2678: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 826D267C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2680: 419A0008  beq cr6, 0x826d2688
	if ctx.cr[6].eq {
	pc = 0x826D2688; continue 'dispatch;
	}
	// 826D2684: 4BBEE20D  bl 0x822c0890
	ctx.lr = 0x826D2688;
	sub_822C0890(ctx, base);
	// 826D2688: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D268C: 48720D9D  bl 0x82df3428
	ctx.lr = 0x826D2690;
	sub_82DF3428(ctx, base);
	// 826D2690: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2694: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2698: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D269C: 4BE3FA7D  bl 0x82512118
	ctx.lr = 0x826D26A0;
	sub_82512118(ctx, base);
	// 826D26A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D26A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D26A8: 48742A09  bl 0x82e150b0
	ctx.lr = 0x826D26AC;
	sub_82E150B0(ctx, base);
	// 826D26AC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826D26B0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D26B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D26B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D26BC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826D26C0: 4BE3E499  bl 0x82510b58
	ctx.lr = 0x826D26C4;
	sub_82510B58(ctx, base);
	// 826D26C4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D26C8: 9AE100DC  stb r23, 0xdc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[23].u8 ) };
	// 826D26CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826D26D0: 3B6B9080  addi r27, r11, -0x6f80
	ctx.r[27].s64 = ctx.r[11].s64 + -28544;
	// 826D26D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826D26D8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 826D26DC: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 826D26E0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826D26E4: C3CA08A4  lfs f30, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826D26E8: 912100CC  stw r9, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[9].u32 ) };
	// 826D26EC: D3C100C8  stfs f30, 0xc8(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 826D26F0: C00B9534  lfs f0, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D26F4: D3C100D0  stfs f30, 0xd0(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 826D26F8: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 826D26FC: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 826D2700: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D2704: 916100C4  stw r11, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 826D2708: 4872C1C1  bl 0x82dfe8c8
	ctx.lr = 0x826D270C;
	sub_82DFE8C8(ctx, base);
	// 826D270C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826D2710: 4872C1B9  bl 0x82dfe8c8
	ctx.lr = 0x826D2714;
	sub_82DFE8C8(ctx, base);
	// 826D2714: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2718: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D271C: 487212ED  bl 0x82df3a08
	ctx.lr = 0x826D2720;
	sub_82DF3A08(ctx, base);
	// 826D2720: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826D2724: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 826D2728: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826D272C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2730: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826D2734: 4BFF879D  bl 0x826caed0
	ctx.lr = 0x826D2738;
	sub_826CAED0(ctx, base);
	// 826D2738: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D273C: 3B9F00F0  addi r28, r31, 0xf0
	ctx.r[28].s64 = ctx.r[31].s64 + 240;
	// 826D2740: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D2744: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 826D2748: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D274C: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826D2750: 4BBF1D11  bl 0x822c4460
	ctx.lr = 0x826D2754;
	sub_822C4460(ctx, base);
	// 826D2754: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 826D2758: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D275C: 419A0008  beq cr6, 0x826d2764
	if ctx.cr[6].eq {
	pc = 0x826D2764; continue 'dispatch;
	}
	// 826D2760: 4BBEE131  bl 0x822c0890
	ctx.lr = 0x826D2764;
	sub_822C0890(ctx, base);
	// 826D2764: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2768: 48720CC1  bl 0x82df3428
	ctx.lr = 0x826D276C;
	sub_82DF3428(ctx, base);
	// 826D276C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D2770: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2778: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826D277C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826D2780: 419A0024  beq cr6, 0x826d27a4
	if ctx.cr[6].eq {
	pc = 0x826D27A4; continue 'dispatch;
	}
	// 826D2784: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D2788: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D278C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2790: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D2794: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2798: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D279C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D27A0: 4082FFE8  bne 0x826d2788
	if !ctx.cr[0].eq {
	pc = 0x826D2788; continue 'dispatch;
	}
	// 826D27A4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826D27A8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D27AC: 487427C5  bl 0x82e14f70
	ctx.lr = 0x826D27B0;
	sub_82E14F70(ctx, base);
	// 826D27B0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826D27B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D27B8: 419A0008  beq cr6, 0x826d27c0
	if ctx.cr[6].eq {
	pc = 0x826D27C0; continue 'dispatch;
	}
	// 826D27BC: 4BBEE0D5  bl 0x822c0890
	ctx.lr = 0x826D27C0;
	sub_822C0890(ctx, base);
	// 826D27C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826D27C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D27C8: 48721241  bl 0x82df3a08
	ctx.lr = 0x826D27CC;
	sub_82DF3A08(ctx, base);
	// 826D27CC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826D27D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826D27D4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D27D8: 484E0B39  bl 0x82bb3310
	ctx.lr = 0x826D27DC;
	sub_82BB3310(ctx, base);
	// 826D27DC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826D27E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D27E4: 419A0008  beq cr6, 0x826d27ec
	if ctx.cr[6].eq {
	pc = 0x826D27EC; continue 'dispatch;
	}
	// 826D27E8: 4BBEE0A9  bl 0x822c0890
	ctx.lr = 0x826D27EC;
	sub_822C0890(ctx, base);
	// 826D27EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D27F0: 48720C39  bl 0x82df3428
	ctx.lr = 0x826D27F4;
	sub_82DF3428(ctx, base);
	// 826D27F4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D27F8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D27FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2800: 3B0B9030  addi r24, r11, -0x6fd0
	ctx.r[24].s64 = ctx.r[11].s64 + -28624;
	// 826D2804: 419A006C  beq cr6, 0x826d2870
	if ctx.cr[6].eq {
	pc = 0x826D2870; continue 'dispatch;
	}
	// 826D2808: 48756B99  bl 0x82e293a0
	ctx.lr = 0x826D280C;
	sub_82E293A0(ctx, base);
	// 826D280C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2810: 40820060  bne 0x826d2870
	if !ctx.cr[0].eq {
	pc = 0x826D2870; continue 'dispatch;
	}
	// 826D2814: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D2818: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D281C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2820: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826D2824: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826D2828: 419A0024  beq cr6, 0x826d284c
	if ctx.cr[6].eq {
	pc = 0x826D284C; continue 'dispatch;
	}
	// 826D282C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D2830: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D2834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2838: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D283C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2840: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D2844: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2848: 4082FFE8  bne 0x826d2830
	if !ctx.cr[0].eq {
	pc = 0x826D2830; continue 'dispatch;
	}
	// 826D284C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826D2850: 4BE18239  bl 0x824eaa88
	ctx.lr = 0x826D2854;
	sub_824EAA88(ctx, base);
	// 826D2854: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 826D2858: 38C00063  li r6, 0x63
	ctx.r[6].s64 = 99;
	// 826D285C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2860: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826D2864: 4BFFF92D  bl 0x826d2190
	ctx.lr = 0x826D2868;
	sub_826D2190(ctx, base);
	// 826D2868: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 826D286C: 4871F425  bl 0x82df1c90
	ctx.lr = 0x826D2870;
	sub_82DF1C90(ctx, base);
	// 826D2870: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2874: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 826D2878: 48721191  bl 0x82df3a08
	ctx.lr = 0x826D287C;
	sub_82DF3A08(ctx, base);
	// 826D287C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826D2880: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 826D2884: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2888: 487427A9  bl 0x82e15030
	ctx.lr = 0x826D288C;
	sub_82E15030(ctx, base);
	// 826D288C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D2890: 3B7F0110  addi r27, r31, 0x110
	ctx.r[27].s64 = ctx.r[31].s64 + 272;
	// 826D2894: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D2898: 387B0004  addi r3, r27, 4
	ctx.r[3].s64 = ctx.r[27].s64 + 4;
	// 826D289C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D28A0: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 826D28A4: 4BBF1BBD  bl 0x822c4460
	ctx.lr = 0x826D28A8;
	sub_822C4460(ctx, base);
	// 826D28A8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 826D28AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D28B0: 419A0008  beq cr6, 0x826d28b8
	if ctx.cr[6].eq {
	pc = 0x826D28B8; continue 'dispatch;
	}
	// 826D28B4: 4BBEDFDD  bl 0x822c0890
	ctx.lr = 0x826D28B8;
	sub_822C0890(ctx, base);
	// 826D28B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D28BC: 48720B6D  bl 0x82df3428
	ctx.lr = 0x826D28C0;
	sub_82DF3428(ctx, base);
	// 826D28C0: 92E10068  stw r23, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[23].u32 ) };
	// 826D28C4: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 826D28C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D28CC: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 826D28D0: 48721139  bl 0x82df3a08
	ctx.lr = 0x826D28D4;
	sub_82DF3A08(ctx, base);
	// 826D28D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D28D8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D28DC: 4872112D  bl 0x82df3a08
	ctx.lr = 0x826D28E0;
	sub_82DF3A08(ctx, base);
	// 826D28E0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826D28E4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826D28E8: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D28EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D28F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826D28F4: 4BFF84AD  bl 0x826cada0
	ctx.lr = 0x826D28F8;
	sub_826CADA0(ctx, base);
	// 826D28F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D28FC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 826D2900: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D2904: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2908: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826D290C: 4BBF1B55  bl 0x822c4460
	ctx.lr = 0x826D2910;
	sub_822C4460(ctx, base);
	// 826D2910: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826D2914: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2918: 419A0008  beq cr6, 0x826d2920
	if ctx.cr[6].eq {
	pc = 0x826D2920; continue 'dispatch;
	}
	// 826D291C: 4BBEDF75  bl 0x822c0890
	ctx.lr = 0x826D2920;
	sub_822C0890(ctx, base);
	// 826D2920: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2924: 48720B05  bl 0x82df3428
	ctx.lr = 0x826D2928;
	sub_82DF3428(ctx, base);
	// 826D2928: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D292C: 48720AFD  bl 0x82df3428
	ctx.lr = 0x826D2930;
	sub_82DF3428(ctx, base);
	// 826D2930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2934: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2938: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826D293C: 4BE3F7DD  bl 0x82512118
	ctx.lr = 0x826D2940;
	sub_82512118(ctx, base);
	// 826D2940: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2948: 4BC1B619  bl 0x822edf60
	ctx.lr = 0x826D294C;
	sub_822EDF60(ctx, base);
	// 826D294C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826D2950: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826D2954: 809C674C  lwz r4, 0x674c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826D2958: 4BDBCA49  bl 0x8248f3a0
	ctx.lr = 0x826D295C;
	sub_8248F3A0(ctx, base);
	// 826D295C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826D2960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2964: 4BE3E3DD  bl 0x82510d40
	ctx.lr = 0x826D2968;
	sub_82510D40(ctx, base);
	// 826D2968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D296C: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 826D2970: 48721099  bl 0x82df3a08
	ctx.lr = 0x826D2974;
	sub_82DF3A08(ctx, base);
	// 826D2974: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2978: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D297C: 4872108D  bl 0x82df3a08
	ctx.lr = 0x826D2980;
	sub_82DF3A08(ctx, base);
	// 826D2980: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826D2984: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826D2988: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D298C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2990: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826D2994: 4BFF840D  bl 0x826cada0
	ctx.lr = 0x826D2998;
	sub_826CADA0(ctx, base);
	// 826D2998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D299C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 826D29A0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D29A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D29A8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 826D29AC: 4BBF1AB5  bl 0x822c4460
	ctx.lr = 0x826D29B0;
	sub_822C4460(ctx, base);
	// 826D29B0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 826D29B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D29B8: 419A0008  beq cr6, 0x826d29c0
	if ctx.cr[6].eq {
	pc = 0x826D29C0; continue 'dispatch;
	}
	// 826D29BC: 4BBEDED5  bl 0x822c0890
	ctx.lr = 0x826D29C0;
	sub_822C0890(ctx, base);
	// 826D29C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D29C4: 48720A65  bl 0x82df3428
	ctx.lr = 0x826D29C8;
	sub_82DF3428(ctx, base);
	// 826D29C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D29CC: 48720A5D  bl 0x82df3428
	ctx.lr = 0x826D29D0;
	sub_82DF3428(ctx, base);
	// 826D29D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D29D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D29D8: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826D29DC: 4BE3F73D  bl 0x82512118
	ctx.lr = 0x826D29E0;
	sub_82512118(ctx, base);
	// 826D29E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D29E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D29E8: 4BC1B579  bl 0x822edf60
	ctx.lr = 0x826D29EC;
	sub_822EDF60(ctx, base);
	// 826D29EC: 809C674C  lwz r4, 0x674c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826D29F0: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826D29F4: 4BDBC9AD  bl 0x8248f3a0
	ctx.lr = 0x826D29F8;
	sub_8248F3A0(ctx, base);
	// 826D29F8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 826D29FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2A00: 4BE3E341  bl 0x82510d40
	ctx.lr = 0x826D2A04;
	sub_82510D40(ctx, base);
	// 826D2A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2A08: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 826D2A0C: 48720FFD  bl 0x82df3a08
	ctx.lr = 0x826D2A10;
	sub_82DF3A08(ctx, base);
	// 826D2A10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2A14: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D2A18: 48720FF1  bl 0x82df3a08
	ctx.lr = 0x826D2A1C;
	sub_82DF3A08(ctx, base);
	// 826D2A1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826D2A20: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 826D2A24: 80BA0000  lwz r5, 0(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2A28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D2A2C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826D2A30: 4BFF8371  bl 0x826cada0
	ctx.lr = 0x826D2A34;
	sub_826CADA0(ctx, base);
	// 826D2A34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D2A38: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 826D2A3C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D2A40: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 826D2A44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2A48: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 826D2A4C: 4BBF1A15  bl 0x822c4460
	ctx.lr = 0x826D2A50;
	sub_822C4460(ctx, base);
	// 826D2A50: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 826D2A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2A58: 419A0008  beq cr6, 0x826d2a60
	if ctx.cr[6].eq {
	pc = 0x826D2A60; continue 'dispatch;
	}
	// 826D2A5C: 4BBEDE35  bl 0x822c0890
	ctx.lr = 0x826D2A60;
	sub_822C0890(ctx, base);
	// 826D2A60: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2A64: 487209C5  bl 0x82df3428
	ctx.lr = 0x826D2A68;
	sub_82DF3428(ctx, base);
	// 826D2A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2A6C: 487209BD  bl 0x82df3428
	ctx.lr = 0x826D2A70;
	sub_82DF3428(ctx, base);
	// 826D2A70: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D2A74: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2A7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826D2A80: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826D2A84: 419A0024  beq cr6, 0x826d2aa8
	if ctx.cr[6].eq {
	pc = 0x826D2AA8; continue 'dispatch;
	}
	// 826D2A88: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D2A8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D2A90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2A94: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D2A98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2A9C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D2AA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2AA4: 4082FFE8  bne 0x826d2a8c
	if !ctx.cr[0].eq {
	pc = 0x826D2A8C; continue 'dispatch;
	}
	// 826D2AA8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826D2AAC: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2AB0: 4BC1B4B1  bl 0x822edf60
	ctx.lr = 0x826D2AB4;
	sub_822EDF60(ctx, base);
	// 826D2AB4: 809C674C  lwz r4, 0x674c(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26444 as u32) ) } as u64;
	// 826D2AB8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2ABC: 4BDBC8E5  bl 0x8248f3a0
	ctx.lr = 0x826D2AC0;
	sub_8248F3A0(ctx, base);
	// 826D2AC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826D2AC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2AC8: 4BE3E279  bl 0x82510d40
	ctx.lr = 0x826D2ACC;
	sub_82510D40(ctx, base);
	// 826D2ACC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826D2AD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2AD4: 419A0008  beq cr6, 0x826d2adc
	if ctx.cr[6].eq {
	pc = 0x826D2ADC; continue 'dispatch;
	}
	// 826D2AD8: 4BBEDDB9  bl 0x822c0890
	ctx.lr = 0x826D2ADC;
	sub_822C0890(ctx, base);
	// 826D2ADC: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 826D2AE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2AE4: 4BE3F2B5  bl 0x82511d98
	ctx.lr = 0x826D2AE8;
	sub_82511D98(ctx, base);
	// 826D2AE8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826D2AEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2AF0: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 826D2AF4: 38A00082  li r5, 0x82
	ctx.r[5].s64 = 130;
	// 826D2AF8: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 826D2AFC: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826D2B00: 4871F8E9  bl 0x82df23e8
	ctx.lr = 0x826D2B04;
	sub_82DF23E8(ctx, base);
	// 826D2B04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D2B08: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826D2B0C: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826D2B10: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 826D2B14: 4182004C  beq 0x826d2b60
	if ctx.cr[0].eq {
	pc = 0x826D2B60; continue 'dispatch;
	}
	// 826D2B18: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D2B1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2B20: 388B916C  addi r4, r11, -0x6e94
	ctx.r[4].s64 = ctx.r[11].s64 + -28308;
	// 826D2B24: 48720EE5  bl 0x82df3a08
	ctx.lr = 0x826D2B28;
	sub_82DF3A08(ctx, base);
	// 826D2B28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2B2C: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 826D2B30: 48720ED9  bl 0x82df3a08
	ctx.lr = 0x826D2B34;
	sub_82DF3A08(ctx, base);
	// 826D2B34: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 826D2B38: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826D2B3C: 80FC6824  lwz r7, 0x6824(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826D2B40: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2B44: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826D2B48: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826D2B4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2B50: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	// 826D2B54: 4BC0F50D  bl 0x822e2060
	ctx.lr = 0x826D2B58;
	sub_822E2060(ctx, base);
	// 826D2B58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2B5C: 48000008  b 0x826d2b64
	pc = 0x826D2B64; continue 'dispatch;
	// 826D2B60: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826D2B64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2B68: 4BFFF8F9  bl 0x826d2460
	ctx.lr = 0x826D2B6C;
	sub_826D2460(ctx, base);
	// 826D2B6C: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2B70: 41820010  beq 0x826d2b80
	if ctx.cr[0].eq {
	pc = 0x826D2B80; continue 'dispatch;
	}
	// 826D2B74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2B78: 573907FA  rlwinm r25, r25, 0, 0x1f, 0x1d
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2B7C: 487208AD  bl 0x82df3428
	ctx.lr = 0x826D2B80;
	sub_82DF3428(ctx, base);
	// 826D2B80: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2B84: 41820010  beq 0x826d2b94
	if ctx.cr[0].eq {
	pc = 0x826D2B94; continue 'dispatch;
	}
	// 826D2B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2B8C: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2B90: 48720899  bl 0x82df3428
	ctx.lr = 0x826D2B94;
	sub_82DF3428(ctx, base);
	// 826D2B94: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826D2B98: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826D2B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2BA0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826D2BA4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826D2BA8: 419A0024  beq cr6, 0x826d2bcc
	if ctx.cr[6].eq {
	pc = 0x826D2BCC; continue 'dispatch;
	}
	// 826D2BAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D2BB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D2BB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2BB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D2BBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2BC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D2BC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2BC8: 4082FFE8  bne 0x826d2bb0
	if !ctx.cr[0].eq {
	pc = 0x826D2BB0; continue 'dispatch;
	}
	// 826D2BCC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826D2BD0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2BD4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826D2BD8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D2BDC: 4BE3A92D  bl 0x8250d508
	ctx.lr = 0x826D2BE0;
	sub_8250D508(ctx, base);
	// 826D2BE0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826D2BE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2BE8: 38A00084  li r5, 0x84
	ctx.r[5].s64 = 132;
	// 826D2BEC: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826D2BF0: 4871F7F9  bl 0x82df23e8
	ctx.lr = 0x826D2BF4;
	sub_82DF23E8(ctx, base);
	// 826D2BF4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826D2BF8: 41820050  beq 0x826d2c48
	if ctx.cr[0].eq {
	pc = 0x826D2C48; continue 'dispatch;
	}
	// 826D2BFC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D2C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2C04: 388B9158  addi r4, r11, -0x6ea8
	ctx.r[4].s64 = ctx.r[11].s64 + -28328;
	// 826D2C08: 48720E01  bl 0x82df3a08
	ctx.lr = 0x826D2C0C;
	sub_82DF3A08(ctx, base);
	// 826D2C0C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2C10: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 826D2C14: 633B0004  ori r27, r25, 4
	ctx.r[27].u64 = ctx.r[25].u64 | 4;
	// 826D2C18: 48720DF1  bl 0x82df3a08
	ctx.lr = 0x826D2C1C;
	sub_82DF3A08(ctx, base);
	// 826D2C1C: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 826D2C20: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826D2C24: 80FC6824  lwz r7, 0x6824(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826D2C28: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2C2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826D2C30: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826D2C34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2C38: 63790008  ori r25, r27, 8
	ctx.r[25].u64 = ctx.r[27].u64 | 8;
	// 826D2C3C: 4BC0F425  bl 0x822e2060
	ctx.lr = 0x826D2C40;
	sub_822E2060(ctx, base);
	// 826D2C40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2C44: 48000008  b 0x826d2c4c
	pc = 0x826D2C4C; continue 'dispatch;
	// 826D2C48: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826D2C4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2C50: 4BFFF811  bl 0x826d2460
	ctx.lr = 0x826D2C54;
	sub_826D2460(ctx, base);
	// 826D2C54: 572B0739  rlwinm. r11, r25, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2C58: 41820010  beq 0x826d2c68
	if ctx.cr[0].eq {
	pc = 0x826D2C68; continue 'dispatch;
	}
	// 826D2C5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2C60: 57390776  rlwinm r25, r25, 0, 0x1d, 0x1b
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2C64: 487207C5  bl 0x82df3428
	ctx.lr = 0x826D2C68;
	sub_82DF3428(ctx, base);
	// 826D2C68: 572B077B  rlwinm. r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2C6C: 41820010  beq 0x826d2c7c
	if ctx.cr[0].eq {
	pc = 0x826D2C7C; continue 'dispatch;
	}
	// 826D2C70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2C74: 573907B8  rlwinm r25, r25, 0, 0x1e, 0x1c
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2C78: 487207B1  bl 0x82df3428
	ctx.lr = 0x826D2C7C;
	sub_82DF3428(ctx, base);
	// 826D2C7C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826D2C80: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826D2C84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2C88: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826D2C8C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826D2C90: 419A0024  beq cr6, 0x826d2cb4
	if ctx.cr[6].eq {
	pc = 0x826D2CB4; continue 'dispatch;
	}
	// 826D2C94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D2C98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D2C9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2CA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D2CA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2CA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D2CAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2CB0: 4082FFE8  bne 0x826d2c98
	if !ctx.cr[0].eq {
	pc = 0x826D2C98; continue 'dispatch;
	}
	// 826D2CB4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826D2CB8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2CBC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826D2CC0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D2CC4: 4BE3A845  bl 0x8250d508
	ctx.lr = 0x826D2CC8;
	sub_8250D508(ctx, base);
	// 826D2CC8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826D2CCC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2CD0: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 826D2CD4: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826D2CD8: 4871F711  bl 0x82df23e8
	ctx.lr = 0x826D2CDC;
	sub_82DF23E8(ctx, base);
	// 826D2CDC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826D2CE0: 41820050  beq 0x826d2d30
	if ctx.cr[0].eq {
	pc = 0x826D2D30; continue 'dispatch;
	}
	// 826D2CE4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D2CE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2CEC: 388B9144  addi r4, r11, -0x6ebc
	ctx.r[4].s64 = ctx.r[11].s64 + -28348;
	// 826D2CF0: 48720D19  bl 0x82df3a08
	ctx.lr = 0x826D2CF4;
	sub_82DF3A08(ctx, base);
	// 826D2CF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2CF8: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 826D2CFC: 633B0010  ori r27, r25, 0x10
	ctx.r[27].u64 = ctx.r[25].u64 | 16;
	// 826D2D00: 48720D09  bl 0x82df3a08
	ctx.lr = 0x826D2D04;
	sub_82DF3A08(ctx, base);
	// 826D2D04: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 826D2D08: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826D2D0C: 80FC6824  lwz r7, 0x6824(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826D2D10: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2D14: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826D2D18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826D2D1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2D20: 63790020  ori r25, r27, 0x20
	ctx.r[25].u64 = ctx.r[27].u64 | 32;
	// 826D2D24: 4BC0F33D  bl 0x822e2060
	ctx.lr = 0x826D2D28;
	sub_822E2060(ctx, base);
	// 826D2D28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2D2C: 48000008  b 0x826d2d34
	pc = 0x826D2D34; continue 'dispatch;
	// 826D2D30: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826D2D34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D2D38: 4BFFF729  bl 0x826d2460
	ctx.lr = 0x826D2D3C;
	sub_826D2460(ctx, base);
	// 826D2D3C: 572B06B5  rlwinm. r11, r25, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2D40: 41820010  beq 0x826d2d50
	if ctx.cr[0].eq {
	pc = 0x826D2D50; continue 'dispatch;
	}
	// 826D2D44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2D48: 573906F2  rlwinm r25, r25, 0, 0x1b, 0x19
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2D4C: 487206DD  bl 0x82df3428
	ctx.lr = 0x826D2D50;
	sub_82DF3428(ctx, base);
	// 826D2D50: 572B06F7  rlwinm. r11, r25, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2D54: 41820010  beq 0x826d2d64
	if ctx.cr[0].eq {
	pc = 0x826D2D64; continue 'dispatch;
	}
	// 826D2D58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2D5C: 57390734  rlwinm r25, r25, 0, 0x1c, 0x1a
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2D60: 487206C9  bl 0x82df3428
	ctx.lr = 0x826D2D64;
	sub_82DF3428(ctx, base);
	// 826D2D64: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 826D2D68: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 826D2D6C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826D2D70: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 826D2D74: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826D2D78: 419A0024  beq cr6, 0x826d2d9c
	if ctx.cr[6].eq {
	pc = 0x826D2D9C; continue 'dispatch;
	}
	// 826D2D7C: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 826D2D80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D2D84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2D88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D2D8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2D90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D2D94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2D98: 4082FFE8  bne 0x826d2d80
	if !ctx.cr[0].eq {
	pc = 0x826D2D80; continue 'dispatch;
	}
	// 826D2D9C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826D2DA0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2DA4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 826D2DA8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 826D2DAC: 4BE3A75D  bl 0x8250d508
	ctx.lr = 0x826D2DB0;
	sub_8250D508(ctx, base);
	// 826D2DB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 826D2DB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D2DB8: 38A00088  li r5, 0x88
	ctx.r[5].s64 = 136;
	// 826D2DBC: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 826D2DC0: 4871F629  bl 0x82df23e8
	ctx.lr = 0x826D2DC4;
	sub_82DF23E8(ctx, base);
	// 826D2DC4: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826D2DC8: 4182004C  beq 0x826d2e14
	if ctx.cr[0].eq {
	pc = 0x826D2E14; continue 'dispatch;
	}
	// 826D2DCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2DD0: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 826D2DD4: 48720C35  bl 0x82df3a08
	ctx.lr = 0x826D2DD8;
	sub_82DF3A08(ctx, base);
	// 826D2DD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2DDC: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 826D2DE0: 633E0040  ori r30, r25, 0x40
	ctx.r[30].u64 = ctx.r[25].u64 | 64;
	// 826D2DE4: 48720C25  bl 0x82df3a08
	ctx.lr = 0x826D2DE8;
	sub_82DF3A08(ctx, base);
	// 826D2DE8: 390100F0  addi r8, r1, 0xf0
	ctx.r[8].s64 = ctx.r[1].s64 + 240;
	// 826D2DEC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 826D2DF0: 80FC6824  lwz r7, 0x6824(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26660 as u32) ) } as u64;
	// 826D2DF4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D2DF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826D2DFC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826D2E00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2E04: 63D90080  ori r25, r30, 0x80
	ctx.r[25].u64 = ctx.r[30].u64 | 128;
	// 826D2E08: 4BC0F259  bl 0x822e2060
	ctx.lr = 0x826D2E0C;
	sub_822E2060(ctx, base);
	// 826D2E0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2E10: 48000008  b 0x826d2e18
	pc = 0x826D2E18; continue 'dispatch;
	// 826D2E14: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826D2E18: 387F0100  addi r3, r31, 0x100
	ctx.r[3].s64 = ctx.r[31].s64 + 256;
	// 826D2E1C: 4BFFF645  bl 0x826d2460
	ctx.lr = 0x826D2E20;
	sub_826D2460(ctx, base);
	// 826D2E20: 572B0631  rlwinm. r11, r25, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2E24: 41820010  beq 0x826d2e34
	if ctx.cr[0].eq {
	pc = 0x826D2E34; continue 'dispatch;
	}
	// 826D2E28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2E2C: 5739066E  rlwinm r25, r25, 0, 0x19, 0x17
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 826D2E30: 487205F9  bl 0x82df3428
	ctx.lr = 0x826D2E34;
	sub_82DF3428(ctx, base);
	// 826D2E34: 572B0673  rlwinm. r11, r25, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2E38: 4182000C  beq 0x826d2e44
	if ctx.cr[0].eq {
	pc = 0x826D2E44; continue 'dispatch;
	}
	// 826D2E3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D2E40: 487205E9  bl 0x82df3428
	ctx.lr = 0x826D2E44;
	sub_82DF3428(ctx, base);
	// 826D2E44: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 826D2E48: 419A000C  beq cr6, 0x826d2e54
	if ctx.cr[6].eq {
	pc = 0x826D2E54; continue 'dispatch;
	}
	// 826D2E4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826D2E50: 4BBEDA41  bl 0x822c0890
	ctx.lr = 0x826D2E54;
	sub_822C0890(ctx, base);
	// 826D2E54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826D2E58: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D2E5C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 826D2E60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 826D2E64: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826D2E68: 48474039  bl 0x82b46ea0
	ctx.lr = 0x826D2E6C;
	sub_82B46EA0(ctx, base);
	// 826D2E6C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D2E70: 3BDF0108  addi r30, r31, 0x108
	ctx.r[30].s64 = ctx.r[31].s64 + 264;
	// 826D2E74: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826D2E78: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 826D2E7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2E80: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 826D2E84: 4BBF15DD  bl 0x822c4460
	ctx.lr = 0x826D2E88;
	sub_822C4460(ctx, base);
	// 826D2E88: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 826D2E8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2E90: 419A0008  beq cr6, 0x826d2e98
	if ctx.cr[6].eq {
	pc = 0x826D2E98; continue 'dispatch;
	}
	// 826D2E94: 4BBED9FD  bl 0x822c0890
	ctx.lr = 0x826D2E98;
	sub_822C0890(ctx, base);
	// 826D2E98: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2E9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D2EA0: 419A0058  beq cr6, 0x826d2ef8
	if ctx.cr[6].eq {
	pc = 0x826D2EF8; continue 'dispatch;
	}
	// 826D2EA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D2EA8: 48473CD1  bl 0x82b46b78
	ctx.lr = 0x826D2EAC;
	sub_82B46B78(ctx, base);
	// 826D2EAC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D2EB0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2EB4: 388B9130  addi r4, r11, -0x6ed0
	ctx.r[4].s64 = ctx.r[11].s64 + -28368;
	// 826D2EB8: 48473A09  bl 0x82b468c0
	ctx.lr = 0x826D2EBC;
	sub_82B468C0(ctx, base);
	// 826D2EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D2EC0: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2EC4: 4BE3EC25  bl 0x82511ae8
	ctx.lr = 0x826D2EC8;
	sub_82511AE8(ctx, base);
	// 826D2EC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D2ECC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D2ED0: 48473CD9  bl 0x82b46ba8
	ctx.lr = 0x826D2ED4;
	sub_82B46BA8(ctx, base);
	// 826D2ED4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2ED8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826D2EDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2EE0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D2EE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D2EE8: 4E800421  bctrl
	ctx.lr = 0x826D2EEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D2EEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D2EF0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2EF4: 484738CD  bl 0x82b467c0
	ctx.lr = 0x826D2EF8;
	sub_82B467C0(ctx, base);
	// 826D2EF8: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826D2EFC: D3CB0018  stfs f30, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826D2F00: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 826D2F04: CBC1FF90  lfd f30, -0x70(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 826D2F08: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 826D2F0C: 48AD5290  b 0x831a819c
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D2F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D2F10 size=264
    let mut pc: u32 = 0x826D2F10;
    'dispatch: loop {
        match pc {
            0x826D2F10 => {
    //   block [0x826D2F10..0x826D3018)
	// 826D2F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D2F14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D2F18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D2F1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D2F20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D2F24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D2F28: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826D2F2C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826D2F30: 816B853C  lwz r11, -0x7ac4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 826D2F34: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D2F38: 419A0090  beq cr6, 0x826d2fc8
	if ctx.cr[6].eq {
	pc = 0x826D2FC8; continue 'dispatch;
	}
	// 826D2F3C: 357FFF1C  addic. r11, r31, -0xe4
	ctx.xer.ca = (ctx.r[31].u32 > (!(-228 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + -228;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2F40: 3BDFFF44  addi r30, r31, -0xbc
	ctx.r[30].s64 = ctx.r[31].s64 + -188;
	// 826D2F44: 40820008  bne 0x826d2f4c
	if !ctx.cr[0].eq {
	pc = 0x826D2F4C; continue 'dispatch;
	}
	// 826D2F48: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826D2F4C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 826D2F50: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 826D2F54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2F58: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D2F5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D2F60: 419A0024  beq cr6, 0x826d2f84
	if ctx.cr[6].eq {
	pc = 0x826D2F84; continue 'dispatch;
	}
	// 826D2F64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D2F68: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D2F6C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2F70: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D2F74: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D2F78: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D2F7C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D2F80: 4082FFE8  bne 0x826d2f68
	if !ctx.cr[0].eq {
	pc = 0x826D2F68; continue 'dispatch;
	}
	// 826D2F84: 389FFF1C  addi r4, r31, -0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + -228;
	// 826D2F88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2F8C: 4BE3C5DD  bl 0x8250f568
	ctx.lr = 0x826D2F90;
	sub_8250F568(ctx, base);
	// 826D2F90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D2F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D2F98: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 826D2F9C: 409A0008  bne cr6, 0x826d2fa4
	if !ctx.cr[6].eq {
	pc = 0x826D2FA4; continue 'dispatch;
	}
	// 826D2FA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826D2FA4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D2FA8: 80DF0048  lwz r6, 0x48(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 826D2FAC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 826D2FB0: 388B9030  addi r4, r11, -0x6fd0
	ctx.r[4].s64 = ctx.r[11].s64 + -28624;
	// 826D2FB4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826D2FB8: 38A000A1  li r5, 0xa1
	ctx.r[5].s64 = 161;
	// 826D2FBC: 480DDD25  bl 0x827b0ce0
	ctx.lr = 0x826D2FC0;
	sub_827B0CE0(ctx, base);
	// 826D2FC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D2FC4: 4871ECCD  bl 0x82df1c90
	ctx.lr = 0x826D2FC8;
	sub_82DF1C90(ctx, base);
	// 826D2FC8: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 826D2FCC: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 826D2FD0: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D2FD4: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 826D2FD8: C02B0018  lfs f1, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D2FDC: 4BFFF395  bl 0x826d2370
	ctx.lr = 0x826D2FE0;
	sub_826D2370(ctx, base);
	// 826D2FE0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 826D2FE4: 484E1835  bl 0x82bb4818
	ctx.lr = 0x826D2FE8;
	sub_82BB4818(ctx, base);
	// 826D2FE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D2FEC: 41820014  beq 0x826d3000
	if ctx.cr[0].eq {
	pc = 0x826D3000; continue 'dispatch;
	}
	// 826D2FF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D2FF4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 826D2FF8: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D2FFC: 484E24F5  bl 0x82bb54f0
	ctx.lr = 0x826D3000;
	sub_82BB54F0(ctx, base);
	// 826D3000: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826D3004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D3008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D300C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D3010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D3014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3018 size=368
    let mut pc: u32 = 0x826D3018;
    'dispatch: loop {
        match pc {
            0x826D3018 => {
    //   block [0x826D3018..0x826D3188)
	// 826D3018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D301C: 48AD5151  bl 0x831a816c
	ctx.lr = 0x826D3020;
	sub_831A8130(ctx, base);
	// 826D3020: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3024: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3028: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 826D302C: 4BE3D6DD  bl 0x82510708
	ctx.lr = 0x826D3030;
	sub_82510708(ctx, base);
	// 826D3030: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826D3034: 815F012C  lwz r10, 0x12c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826D3038: 816B853C  lwz r11, -0x7ac4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31428 as u32) ) } as u64;
	// 826D303C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D3040: 419A008C  beq cr6, 0x826d30cc
	if ctx.cr[6].eq {
	pc = 0x826D30CC; continue 'dispatch;
	}
	// 826D3044: 817F011C  lwz r11, 0x11c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826D3048: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 826D304C: 815F0118  lwz r10, 0x118(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826D3050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D3054: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D3058: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D305C: 419A0024  beq cr6, 0x826d3080
	if ctx.cr[6].eq {
	pc = 0x826D3080; continue 'dispatch;
	}
	// 826D3060: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D3064: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D3068: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D306C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D3070: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D3074: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D3078: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D307C: 4082FFE8  bne 0x826d3064
	if !ctx.cr[0].eq {
	pc = 0x826D3064; continue 'dispatch;
	}
	// 826D3080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D3084: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D3088: 4BE3C4E1  bl 0x8250f568
	ctx.lr = 0x826D308C;
	sub_8250F568(ctx, base);
	// 826D308C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D3090: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D3094: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 826D3098: 409A0008  bne cr6, 0x826d30a0
	if !ctx.cr[6].eq {
	pc = 0x826D30A0; continue 'dispatch;
	}
	// 826D309C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826D30A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D30A4: 80DF012C  lwz r6, 0x12c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826D30A8: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826D30AC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 826D30B0: 388A9030  addi r4, r10, -0x6fd0
	ctx.r[4].s64 = ctx.r[10].s64 + -28624;
	// 826D30B4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826D30B8: 38A000BD  li r5, 0xbd
	ctx.r[5].s64 = 189;
	// 826D30BC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D30C0: 480DA511  bl 0x827ad5d0
	ctx.lr = 0x826D30C4;
	sub_827AD5D0(ctx, base);
	// 826D30C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D30C8: 4871EBC9  bl 0x82df1c90
	ctx.lr = 0x826D30CC;
	sub_82DF1C90(ctx, base);
	// 826D30CC: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826D30D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D30D4: C02B0018  lfs f1, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D30D8: 4BFFF299  bl 0x826d2370
	ctx.lr = 0x826D30DC;
	sub_826D2370(ctx, base);
	// 826D30DC: 807F0108  lwz r3, 0x108(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826D30E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D30E4: 419A0074  beq cr6, 0x826d3158
	if ctx.cr[6].eq {
	pc = 0x826D3158; continue 'dispatch;
	}
	// 826D30E8: 897F0128  lbz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 826D30EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D30F0: 40820068  bne 0x826d3158
	if !ctx.cr[0].eq {
	pc = 0x826D3158; continue 'dispatch;
	}
	// 826D30F4: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826D30F8: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D30FC: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 826D3100: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826D3104: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D3108: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826D310C: C00ADFB0  lfs f0, -0x2050(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D3110: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D3114: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 826D3118: FDA06210  fabs f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 826D311C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826D3120: 4098000C  bge cr6, 0x826d312c
	if !ctx.cr[6].lt {
	pc = 0x826D312C; continue 'dispatch;
	}
	// 826D3124: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 826D3128: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826D312C: 817F0124  lwz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826D3130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D3134: 4099001C  ble cr6, 0x826d3150
	if !ctx.cr[6].gt {
	pc = 0x826D3150; continue 'dispatch;
	}
	// 826D3138: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826D313C: 48473685  bl 0x82b467c0
	ctx.lr = 0x826D3140;
	sub_82B467C0(ctx, base);
	// 826D3140: 817F0124  lwz r11, 0x124(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826D3144: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 826D3148: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 826D314C: 4800000C  b 0x826d3158
	pc = 0x826D3158; continue 'dispatch;
	// 826D3150: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D3154: 4847366D  bl 0x82b467c0
	ctx.lr = 0x826D3158;
	sub_82B467C0(ctx, base);
	// 826D3158: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826D315C: 484E16BD  bl 0x82bb4818
	ctx.lr = 0x826D3160;
	sub_82BB4818(ctx, base);
	// 826D3160: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D3164: 41820010  beq 0x826d3174
	if ctx.cr[0].eq {
	pc = 0x826D3174; continue 'dispatch;
	}
	// 826D3168: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D316C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 826D3170: 484E2381  bl 0x82bb54f0
	ctx.lr = 0x826D3174;
	sub_82BB54F0(ctx, base);
	// 826D3174: 817F0118  lwz r11, 0x118(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 826D3178: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D317C: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 826D3180: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826D3184: 48AD5038  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3188 size=424
    let mut pc: u32 = 0x826D3188;
    'dispatch: loop {
        match pc {
            0x826D3188 => {
    //   block [0x826D3188..0x826D3330)
	// 826D3188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D318C: 48AD4FD9  bl 0x831a8164
	ctx.lr = 0x826D3190;
	sub_831A8130(ctx, base);
	// 826D3190: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3194: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D3198: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826D319C: 3BCB9030  addi r30, r11, -0x6fd0
	ctx.r[30].s64 = ctx.r[11].s64 + -28624;
	// 826D31A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826D31A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D31A8: 38A00037  li r5, 0x37
	ctx.r[5].s64 = 55;
	// 826D31AC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826D31B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D31B4: 38600134  li r3, 0x134
	ctx.r[3].s64 = 308;
	// 826D31B8: 4871F231  bl 0x82df23e8
	ctx.lr = 0x826D31BC;
	sub_82DF23E8(ctx, base);
	// 826D31BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D31C0: 41820010  beq 0x826d31d0
	if ctx.cr[0].eq {
	pc = 0x826D31D0; continue 'dispatch;
	}
	// 826D31C4: 4BFFF30D  bl 0x826d24d0
	ctx.lr = 0x826D31C8;
	sub_826D24D0(ctx, base);
	// 826D31C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D31CC: 48000008  b 0x826d31d4
	pc = 0x826D31D4; continue 'dispatch;
	// 826D31D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826D31D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826D31D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D31DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D31E0: 4BFFED99  bl 0x826d1f78
	ctx.lr = 0x826D31E4;
	sub_826D1F78(ctx, base);
	// 826D31E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D31E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D31EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D31F0: 4BBECE11  bl 0x822c0000
	ctx.lr = 0x826D31F4;
	sub_822C0000(ctx, base);
	// 826D31F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D31F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D31FC: 38A00038  li r5, 0x38
	ctx.r[5].s64 = 56;
	// 826D3200: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826D3204: 4BBED1D5  bl 0x822c03d8
	ctx.lr = 0x826D3208;
	sub_822C03D8(ctx, base);
	// 826D3208: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826D320C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826D3210: 418200B4  beq 0x826d32c4
	if ctx.cr[0].eq {
	pc = 0x826D32C4; continue 'dispatch;
	}
	// 826D3214: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D3218: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 826D321C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826D3220: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 826D3224: 409A0008  bne cr6, 0x826d322c
	if !ctx.cr[6].eq {
	pc = 0x826D322C; continue 'dispatch;
	}
	// 826D3228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D322C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826D3230: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826D3234: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 826D3238: 419A0024  beq cr6, 0x826d325c
	if ctx.cr[6].eq {
	pc = 0x826D325C; continue 'dispatch;
	}
	// 826D323C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826D3240: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 826D3244: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D3248: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 826D324C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 826D3250: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D3254: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D3258: 4082FFE8  bne 0x826d3240
	if !ctx.cr[0].eq {
	pc = 0x826D3240; continue 'dispatch;
	}
	// 826D325C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 826D3260: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826D3264: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826D3268: 419A0024  beq cr6, 0x826d328c
	if ctx.cr[6].eq {
	pc = 0x826D328C; continue 'dispatch;
	}
	// 826D326C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826D3270: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D3274: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D3278: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D327C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D3280: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D3284: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D3288: 4082FFE8  bne 0x826d3270
	if !ctx.cr[0].eq {
	pc = 0x826D3270; continue 'dispatch;
	}
	// 826D328C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D3290: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826D3294: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826D3298: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826D329C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826D32A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D32A4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D32A8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826D32AC: 480C5C85  bl 0x82798f30
	ctx.lr = 0x826D32B0;
	sub_82798F30(ctx, base);
	// 826D32B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D32B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D32B8: 480C83B1  bl 0x8279b668
	ctx.lr = 0x826D32BC;
	sub_8279B668(ctx, base);
	// 826D32BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D32C0: 48000008  b 0x826d32c8
	pc = 0x826D32C8; continue 'dispatch;
	// 826D32C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826D32C8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826D32CC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 826D32D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D32D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D32D8: 4BEC4979  bl 0x82597c50
	ctx.lr = 0x826D32DC;
	sub_82597C50(ctx, base);
	// 826D32DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D32E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D32E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D32E8: 4BBECD19  bl 0x822c0000
	ctx.lr = 0x826D32EC;
	sub_822C0000(ctx, base);
	// 826D32EC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826D32F0: 41820024  beq 0x826d3314
	if ctx.cr[0].eq {
	pc = 0x826D3314; continue 'dispatch;
	}
	// 826D32F4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826D32F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D32FC: 419A0008  beq cr6, 0x826d3304
	if ctx.cr[6].eq {
	pc = 0x826D3304; continue 'dispatch;
	}
	// 826D3300: 4BBED591  bl 0x822c0890
	ctx.lr = 0x826D3304;
	sub_822C0890(ctx, base);
	// 826D3304: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826D3308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D330C: 419A0008  beq cr6, 0x826d3314
	if ctx.cr[6].eq {
	pc = 0x826D3314; continue 'dispatch;
	}
	// 826D3310: 4BBED581  bl 0x822c0890
	ctx.lr = 0x826D3314;
	sub_822C0890(ctx, base);
	// 826D3314: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826D3318: 419A000C  beq cr6, 0x826d3324
	if ctx.cr[6].eq {
	pc = 0x826D3324; continue 'dispatch;
	}
	// 826D331C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D3320: 4BBED571  bl 0x822c0890
	ctx.lr = 0x826D3324;
	sub_822C0890(ctx, base);
	// 826D3324: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826D3328: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826D332C: 48AD4E88  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3330 size=8
    let mut pc: u32 = 0x826D3330;
    'dispatch: loop {
        match pc {
            0x826D3330 => {
    //   block [0x826D3330..0x826D3338)
	// 826D3330: 80630110  lwz r3, 0x110(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(272 as u32) ) } as u64;
	// 826D3334: 480FCB0C  b 0x827cfe40
	sub_827CFE40(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3338 size=32
    let mut pc: u32 = 0x826D3338;
    'dispatch: loop {
        match pc {
            0x826D3338 => {
    //   block [0x826D3338..0x826D3358)
	// 826D3338: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826D333C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D3340: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 826D3344: 419A0054  beq cr6, 0x826d3398
	if ctx.cr[6].eq {
		sub_826D3398(ctx, base);
		return;
	}
	// 826D3348: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 826D334C: 419A002C  beq cr6, 0x826d3378
	if ctx.cr[6].eq {
		sub_826D3378(ctx, base);
		return;
	}
	// 826D3350: 2F0A0007  cmpwi cr6, r10, 7
	ctx.cr[6].compare_i32(ctx.r[10].s32, 7, &mut ctx.xer);
	// 826D3354: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3358 size=24
    let mut pc: u32 = 0x826D3358;
    'dispatch: loop {
        match pc {
            0x826D3358 => {
    //   block [0x826D3358..0x826D3370)
	// 826D3358: 806B0114  lwz r3, 0x114(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 826D335C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826D3360: 994B014C  stb r10, 0x14c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(332 as u32), ctx.r[10].u8 ) };
	// 826D3364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D3368: 994B019D  stb r10, 0x19d(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(413 as u32), ctx.r[10].u8 ) };
	// 826D336C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3370 size=8
    let mut pc: u32 = 0x826D3370;
    'dispatch: loop {
        match pc {
            0x826D3370 => {
    //   block [0x826D3370..0x826D3378)
	// 826D3370: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D3374: 4847344C  b 0x82b467c0
	sub_82B467C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3378 size=24
    let mut pc: u32 = 0x826D3378;
    'dispatch: loop {
        match pc {
            0x826D3378 => {
    //   block [0x826D3378..0x826D3390)
	// 826D3378: 806B0114  lwz r3, 0x114(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) } as u64;
	// 826D337C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826D3380: 994B014C  stb r10, 0x14c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(332 as u32), ctx.r[10].u8 ) };
	// 826D3384: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D3388: 994B019D  stb r10, 0x19d(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(413 as u32), ctx.r[10].u8 ) };
	// 826D338C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3390 size=8
    let mut pc: u32 = 0x826D3390;
    'dispatch: loop {
        match pc {
            0x826D3390 => {
    //   block [0x826D3390..0x826D3398)
	// 826D3390: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826D3394: 4847342C  b 0x82b467c0
	sub_82B467C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D3398 size=8
    let mut pc: u32 = 0x826D3398;
    'dispatch: loop {
        match pc {
            0x826D3398 => {
    //   block [0x826D3398..0x826D33A0)
	// 826D3398: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 826D339C: 4BE3D234  b 0x825105d0
	sub_825105D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D33A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826D33A0 size=4
    let mut pc: u32 = 0x826D33A0;
    'dispatch: loop {
        match pc {
            0x826D33A0 => {
    //   block [0x826D33A0..0x826D33A4)
	// 826D33A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D33A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D33A8 size=196
    let mut pc: u32 = 0x826D33A8;
    'dispatch: loop {
        match pc {
            0x826D33A8 => {
    //   block [0x826D33A8..0x826D346C)
	// 826D33A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D33AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D33B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D33B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D33B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D33BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826D33C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D33C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826D33C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826D33CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D33D0: 4BBED569  bl 0x822c0938
	ctx.lr = 0x826D33D4;
	sub_822C0938(ctx, base);
	// 826D33D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D33D8: 41820028  beq 0x826d3400
	if ctx.cr[0].eq {
	pc = 0x826D3400; continue 'dispatch;
	}
	// 826D33DC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D33E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826D33E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826D33E8: 392B92A0  addi r9, r11, -0x6d60
	ctx.r[9].s64 = ctx.r[11].s64 + -28000;
	// 826D33EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826D33F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D33F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826D33F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826D33FC: 48000008  b 0x826d3404
	pc = 0x826D3404; continue 'dispatch;
	// 826D3400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D3404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D3408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D340C: 409A0044  bne cr6, 0x826d3450
	if !ctx.cr[6].eq {
	pc = 0x826D3450; continue 'dispatch;
	}
	// 826D3410: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D3414: 419A001C  beq cr6, 0x826d3430
	if ctx.cr[6].eq {
	pc = 0x826D3430; continue 'dispatch;
	}
	// 826D3418: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D341C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D3420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D3424: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D3428: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D342C: 4E800421  bctrl
	ctx.lr = 0x826D3430;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D3430: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D3434: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826D3438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D343C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826D3440: 816BCE2C  lwz r11, -0x31d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12756 as u32) ) } as u64;
	// 826D3444: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D3448: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D344C: 4BBECBB5  bl 0x822c0000
	ctx.lr = 0x826D3450;
	sub_822C0000(ctx, base);
	// 826D3450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D3458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D345C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D3460: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D3464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D3468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D3470 size=196
    let mut pc: u32 = 0x826D3470;
    'dispatch: loop {
        match pc {
            0x826D3470 => {
    //   block [0x826D3470..0x826D3534)
	// 826D3470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D3474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D3478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D347C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D3480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3484: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826D3488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D348C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826D3490: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826D3494: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D3498: 4BBED4A1  bl 0x822c0938
	ctx.lr = 0x826D349C;
	sub_822C0938(ctx, base);
	// 826D349C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D34A0: 41820028  beq 0x826d34c8
	if ctx.cr[0].eq {
	pc = 0x826D34C8; continue 'dispatch;
	}
	// 826D34A4: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D34A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826D34AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826D34B0: 392B92B4  addi r9, r11, -0x6d4c
	ctx.r[9].s64 = ctx.r[11].s64 + -27980;
	// 826D34B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826D34B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826D34BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826D34C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826D34C4: 48000008  b 0x826d34cc
	pc = 0x826D34CC; continue 'dispatch;
	// 826D34C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826D34CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D34D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D34D4: 409A0044  bne cr6, 0x826d3518
	if !ctx.cr[6].eq {
	pc = 0x826D3518; continue 'dispatch;
	}
	// 826D34D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D34DC: 419A001C  beq cr6, 0x826d34f8
	if ctx.cr[6].eq {
	pc = 0x826D34F8; continue 'dispatch;
	}
	// 826D34E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D34E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826D34E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D34EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D34F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D34F4: 4E800421  bctrl
	ctx.lr = 0x826D34F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D34F8: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D34FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826D3500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3504: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826D3508: 816BCE2C  lwz r11, -0x31d4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12756 as u32) ) } as u64;
	// 826D350C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826D3510: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D3514: 4BBECAED  bl 0x822c0000
	ctx.lr = 0x826D3518;
	sub_822C0000(ctx, base);
	// 826D3518: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D351C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D3520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D3524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D3528: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D352C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D3530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3538 size=800
    let mut pc: u32 = 0x826D3538;
    'dispatch: loop {
        match pc {
            0x826D3538 => {
    //   block [0x826D3538..0x826D3858)
	// 826D3538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D353C: 48AD4C29  bl 0x831a8164
	ctx.lr = 0x826D3540;
	sub_831A8130(ctx, base);
	// 826D3540: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 826D3544: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3548: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 826D354C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3550: 4BE3E849  bl 0x82511d98
	ctx.lr = 0x826D3554;
	sub_82511D98(ctx, base);
	// 826D3554: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826D3558: 487F9491  bl 0x82ecc9e8
	ctx.lr = 0x826D355C;
	sub_82ECC9E8(ctx, base);
	// 826D355C: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 826D3560: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D3564: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 826D3568: 99610190  stb r11, 0x190(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[11].u8 ) };
	// 826D356C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826D3570: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826D3574: 7C7DF02E  lwzx r3, r29, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 826D3578: 487CD1B9  bl 0x82ea0730
	ctx.lr = 0x826D357C;
	sub_82EA0730(ctx, base);
	// 826D357C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 826D3580: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D3584: B1430004  sth r10, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 826D3588: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 826D358C: 3B8B9294  addi r28, r11, -0x6d6c
	ctx.r[28].s64 = ctx.r[11].s64 + -28012;
	// 826D3590: 817F0188  lwz r11, 0x188(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826D3594: 80FF018C  lwz r7, 0x18c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826D3598: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826D359C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 826D35A0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826D35A4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 826D35A8: C029F614  lfs f1, -0x9ec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-2540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D35AC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 826D35B0: C19CFFF0  lfs f12, -0x10(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826D35B4: 393CFFF4  addi r9, r28, -0xc
	ctx.r[9].s64 = ctx.r[28].s64 + -12;
	// 826D35B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 826D35BC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 826D35C0: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 826D35C4: C1AA6150  lfs f13, 0x6150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D35C8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 826D35CC: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 826D35D0: 7DAB4C2E  lfsx f13, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D35D4: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 826D35D8: C0089450  lfs f0, -0x6bb0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D35DC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 826D35E0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826D35E4: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826D35E8: EC0B603A  fmadds f0, f11, f0, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 826D35EC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 826D35F0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 826D35F4: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 826D35F8: 13E038C7  vcmpequd (lvx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3858 size=240
    let mut pc: u32 = 0x826D3858;
    'dispatch: loop {
        match pc {
            0x826D3858 => {
    //   block [0x826D3858..0x826D3948)
	// 826D3858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D385C: 48AD4909  bl 0x831a8164
	ctx.lr = 0x826D3860;
	sub_831A8130(ctx, base);
	// 826D3860: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826D386C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 826D3870: 895F0108  lbz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 826D3874: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 826D3878: 419A00C8  beq cr6, 0x826d3940
	if ctx.cr[6].eq {
	pc = 0x826D3940; continue 'dispatch;
	}
	// 826D387C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D3880: 419A00AC  beq cr6, 0x826d392c
	if ctx.cr[6].eq {
	pc = 0x826D392C; continue 'dispatch;
	}
	// 826D3884: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D388C: 388B1F80  addi r4, r11, 0x1f80
	ctx.r[4].s64 = ctx.r[11].s64 + 8064;
	// 826D3890: 48720179  bl 0x82df3a08
	ctx.lr = 0x826D3894;
	sub_82DF3A08(ctx, base);
	// 826D3894: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 826D3898: 815F012C  lwz r10, 0x12c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 826D389C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D38A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826D38A4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826D38A8: 419A0024  beq cr6, 0x826d38cc
	if ctx.cr[6].eq {
	pc = 0x826D38CC; continue 'dispatch;
	}
	// 826D38AC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D38B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D38B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D38B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D38BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D38C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D38C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D38C8: 4082FFE8  bne 0x826d38b0
	if !ctx.cr[0].eq {
	pc = 0x826D38B0; continue 'dispatch;
	}
	// 826D38CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826D38D0: 83BF0110  lwz r29, 0x110(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826D38D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D38D8: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 826D38DC: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 826D38E0: 4BE3BBE9  bl 0x8250f4c8
	ctx.lr = 0x826D38E4;
	sub_8250F4C8(ctx, base);
	// 826D38E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D38E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D38EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826D38F0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 826D38F4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 826D38F8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826D38FC: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D3900: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 826D3904: 480FCA35  bl 0x827d0338
	ctx.lr = 0x826D3908;
	sub_827D0338(ctx, base);
	// 826D3908: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826D390C: 907F010C  stw r3, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[3].u32 ) };
	// 826D3910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D3914: 419A000C  beq cr6, 0x826d3920
	if ctx.cr[6].eq {
	pc = 0x826D3920; continue 'dispatch;
	}
	// 826D3918: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 826D391C: 4BBECF75  bl 0x822c0890
	ctx.lr = 0x826D3920;
	sub_822C0890(ctx, base);
	// 826D3920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3924: 4871FB05  bl 0x82df3428
	ctx.lr = 0x826D3928;
	sub_82DF3428(ctx, base);
	// 826D3928: 48000014  b 0x826d393c
	pc = 0x826D393C; continue 'dispatch;
	// 826D392C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826D3930: 809F010C  lwz r4, 0x10c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 826D3934: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 826D3938: 480FBCD9  bl 0x827cf610
	ctx.lr = 0x826D393C;
	sub_827CF610(ctx, base);
	// 826D393C: 9BDF0108  stb r30, 0x108(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u8 ) };
	// 826D3940: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826D3944: 48AD4870  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3948 size=336
    let mut pc: u32 = 0x826D3948;
    'dispatch: loop {
        match pc {
            0x826D3948 => {
    //   block [0x826D3948..0x826D3A98)
	// 826D3948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D394C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D3950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D3954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D3958: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826D395C: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3964: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 826D3968: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826D396C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826D3970: 3BCB6910  addi r30, r11, 0x6910
	ctx.r[30].s64 = ctx.r[11].s64 + 26896;
	// 826D3974: 809F0144  lwz r4, 0x144(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826D3978: 4BFF7F79  bl 0x826cb8f0
	ctx.lr = 0x826D397C;
	sub_826CB8F0(ctx, base);
	// 826D397C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D3980: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826D3984: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D3988: 487A8341  bl 0x82e7bcc8
	ctx.lr = 0x826D398C;
	sub_82E7BCC8(ctx, base);
	// 826D398C: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826D3990: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826D3994: 4BFF7EE5  bl 0x826cb878
	ctx.lr = 0x826D3998;
	sub_826CB878(ctx, base);
	// 826D3998: 807F0144  lwz r3, 0x144(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826D399C: 4BFF7EE5  bl 0x826cb880
	ctx.lr = 0x826D39A0;
	sub_826CB880(ctx, base);
	// 826D39A0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826D39A4: 809F0144  lwz r4, 0x144(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826D39A8: 4BFF7F49  bl 0x826cb8f0
	ctx.lr = 0x826D39AC;
	sub_826CB8F0(ctx, base);
	// 826D39AC: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 826D39B0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826D39B4: C00B932C  lfs f0, -0x6cd4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27860 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D39B8: EC3F0032  fmuls f1, f31, f0
	ctx.f[1].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 826D39BC: 487A908D  bl 0x82e7ca48
	ctx.lr = 0x826D39C0;
	sub_82E7CA48(ctx, base);
	// 826D39C0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 826D39C4: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826D39C8: 4873F899  bl 0x82e13260
	ctx.lr = 0x826D39CC;
	sub_82E13260(ctx, base);
	// 826D39CC: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 826D39D0: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826D39D4: 4873F88D  bl 0x82e13260
	ctx.lr = 0x826D39D8;
	sub_82E13260(ctx, base);
	// 826D39D8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826D39DC: 809F0144  lwz r4, 0x144(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 826D39E0: 4BFF7F11  bl 0x826cb8f0
	ctx.lr = 0x826D39E4;
	sub_826CB8F0(ctx, base);
	// 826D39E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D39E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826D39EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826D39F0: 487A82D9  bl 0x82e7bcc8
	ctx.lr = 0x826D39F4;
	sub_82E7BCC8(ctx, base);
	// 826D39F4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 826D39F8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 826D39FC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 826D3A00: 3D008212  lis r8, -0x7dee
	ctx.r[8].s64 = -2112749568;
	// 826D3A04: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826D3A08: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D3A98 size=112
    let mut pc: u32 = 0x826D3A98;
    'dispatch: loop {
        match pc {
            0x826D3A98 => {
    //   block [0x826D3A98..0x826D3B08)
	// 826D3A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D3A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D3AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D3AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D3AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3AAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826D3AB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3AB4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826D3AB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3ABC: 4BFFF9B5  bl 0x826d3470
	ctx.lr = 0x826D3AC0;
	sub_826D3470(ctx, base);
	// 826D3AC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826D3AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826D3AC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3ACC: 4BBEC535  bl 0x822c0000
	ctx.lr = 0x826D3AD0;
	sub_822C0000(ctx, base);
	// 826D3AD0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826D3AD4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826D3AD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826D3ADC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D3AE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D3AE4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826D3AE8: 419A0008  beq cr6, 0x826d3af0
	if ctx.cr[6].eq {
	pc = 0x826D3AF0; continue 'dispatch;
	}
	// 826D3AEC: 4BBECDA5  bl 0x822c0890
	ctx.lr = 0x826D3AF0;
	sub_822C0890(ctx, base);
	// 826D3AF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826D3AF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D3AF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D3AFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D3B00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D3B04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D3B08 size=160
    let mut pc: u32 = 0x826D3B08;
    'dispatch: loop {
        match pc {
            0x826D3B08 => {
    //   block [0x826D3B08..0x826D3BA8)
	// 826D3B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D3B0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D3B10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D3B14: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3B1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826D3B20: 419A0074  beq cr6, 0x826d3b94
	if ctx.cr[6].eq {
	pc = 0x826D3B94; continue 'dispatch;
	}
	// 826D3B24: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3B28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3B2C: 388BD2A8  addi r4, r11, -0x2d58
	ctx.r[4].s64 = ctx.r[11].s64 + -11608;
	// 826D3B30: 4871FED9  bl 0x82df3a08
	ctx.lr = 0x826D3B34;
	sub_82DF3A08(ctx, base);
	// 826D3B34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826D3B38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3B3C: 388B0740  addi r4, r11, 0x740
	ctx.r[4].s64 = ctx.r[11].s64 + 1856;
	// 826D3B40: 4871FEC9  bl 0x82df3a08
	ctx.lr = 0x826D3B44;
	sub_82DF3A08(ctx, base);
	// 826D3B44: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D3B48: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826D3B4C: 38ABCDFC  addi r5, r11, -0x3204
	ctx.r[5].s64 = ctx.r[11].s64 + -12804;
	// 826D3B50: 38E003E8  li r7, 0x3e8
	ctx.r[7].s64 = 1000;
	// 826D3B54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D3B58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3B5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D3B60: 4BECF8B9  bl 0x825a3418
	ctx.lr = 0x826D3B64;
	sub_825A3418(ctx, base);
	// 826D3B64: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3B68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D3B70: 4BECE369  bl 0x825a1ed8
	ctx.lr = 0x826D3B74;
	sub_825A1ED8(ctx, base);
	// 826D3B74: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 826D3B78: 4871F8B1  bl 0x82df3428
	ctx.lr = 0x826D3B7C;
	sub_82DF3428(ctx, base);
	// 826D3B7C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826D3B80: 4BBF5139  bl 0x822c8cb8
	ctx.lr = 0x826D3B84;
	sub_822C8CB8(ctx, base);
	// 826D3B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3B88: 4871F8A1  bl 0x82df3428
	ctx.lr = 0x826D3B8C;
	sub_82DF3428(ctx, base);
	// 826D3B8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3B90: 4871F899  bl 0x82df3428
	ctx.lr = 0x826D3B94;
	sub_82DF3428(ctx, base);
	// 826D3B94: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 826D3B98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D3B9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D3BA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D3BA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3BA8 size=736
    let mut pc: u32 = 0x826D3BA8;
    'dispatch: loop {
        match pc {
            0x826D3BA8 => {
    //   block [0x826D3BA8..0x826D3E88)
	// 826D3BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D3BAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D3BB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826D3BB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D3BB8: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 826D3BBC: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 826D3BC0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 826D3BC4: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3BC8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3BCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3BD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826D3BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3BD8: 388BD334  addi r4, r11, -0x2ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -11468;
	// 826D3BDC: 4871FE2D  bl 0x82df3a08
	ctx.lr = 0x826D3BE0;
	sub_82DF3A08(ctx, base);
	// 826D3BE0: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3BE4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3BE8: 388BD318  addi r4, r11, -0x2ce8
	ctx.r[4].s64 = ctx.r[11].s64 + -11496;
	// 826D3BEC: 4871FE1D  bl 0x82df3a08
	ctx.lr = 0x826D3BF0;
	sub_82DF3A08(ctx, base);
	// 826D3BF0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826D3BF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 826D3BF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D3BFC: 38BF00A4  addi r5, r31, 0xa4
	ctx.r[5].s64 = ctx.r[31].s64 + 164;
	// 826D3C00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3C04: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826D3C08: 4BECF811  bl 0x825a3418
	ctx.lr = 0x826D3C0C;
	sub_825A3418(ctx, base);
	// 826D3C0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3C10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3C14: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3C18: 4BECE2C1  bl 0x825a1ed8
	ctx.lr = 0x826D3C1C;
	sub_825A1ED8(ctx, base);
	// 826D3C1C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 826D3C20: 4871F809  bl 0x82df3428
	ctx.lr = 0x826D3C24;
	sub_82DF3428(ctx, base);
	// 826D3C24: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826D3C28: 4BBF5091  bl 0x822c8cb8
	ctx.lr = 0x826D3C2C;
	sub_822C8CB8(ctx, base);
	// 826D3C2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3C30: 4871F7F9  bl 0x82df3428
	ctx.lr = 0x826D3C34;
	sub_82DF3428(ctx, base);
	// 826D3C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3C38: 4871F7F1  bl 0x82df3428
	ctx.lr = 0x826D3C3C;
	sub_82DF3428(ctx, base);
	// 826D3C3C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3C40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3C44: 388BD3FC  addi r4, r11, -0x2c04
	ctx.r[4].s64 = ctx.r[11].s64 + -11268;
	// 826D3C48: 4871FDC1  bl 0x82df3a08
	ctx.lr = 0x826D3C4C;
	sub_82DF3A08(ctx, base);
	// 826D3C4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3C54: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 826D3C58: 4871FDB1  bl 0x82df3a08
	ctx.lr = 0x826D3C5C;
	sub_82DF3A08(ctx, base);
	// 826D3C5C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 826D3C60: 38E00064  li r7, 0x64
	ctx.r[7].s64 = 100;
	// 826D3C64: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D3C68: 38BF00A8  addi r5, r31, 0xa8
	ctx.r[5].s64 = ctx.r[31].s64 + 168;
	// 826D3C6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3C70: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 826D3C74: 4BECF7A5  bl 0x825a3418
	ctx.lr = 0x826D3C78;
	sub_825A3418(ctx, base);
	// 826D3C78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3C80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3C84: 4BECE255  bl 0x825a1ed8
	ctx.lr = 0x826D3C88;
	sub_825A1ED8(ctx, base);
	// 826D3C88: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 826D3C8C: 4871F79D  bl 0x82df3428
	ctx.lr = 0x826D3C90;
	sub_82DF3428(ctx, base);
	// 826D3C90: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826D3C94: 4BBF5025  bl 0x822c8cb8
	ctx.lr = 0x826D3C98;
	sub_822C8CB8(ctx, base);
	// 826D3C98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3C9C: 4871F78D  bl 0x82df3428
	ctx.lr = 0x826D3CA0;
	sub_82DF3428(ctx, base);
	// 826D3CA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3CA4: 4871F785  bl 0x82df3428
	ctx.lr = 0x826D3CA8;
	sub_82DF3428(ctx, base);
	// 826D3CA8: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3CAC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3CB0: 388BD2E0  addi r4, r11, -0x2d20
	ctx.r[4].s64 = ctx.r[11].s64 + -11552;
	// 826D3CB4: 4871FD55  bl 0x82df3a08
	ctx.lr = 0x826D3CB8;
	sub_82DF3A08(ctx, base);
	// 826D3CB8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3CBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3CC0: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 826D3CC4: 4871FD45  bl 0x82df3a08
	ctx.lr = 0x826D3CC8;
	sub_82DF3A08(ctx, base);
	// 826D3CC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826D3CCC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 826D3CD0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826D3CD4: 38BF00AC  addi r5, r31, 0xac
	ctx.r[5].s64 = ctx.r[31].s64 + 172;
	// 826D3CD8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3CDC: C3EB964C  lfs f31, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826D3CE0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826D3CE4: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826D3CE8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826D3CEC: C3A908A4  lfs f29, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826D3CF0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826D3CF4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826D3CF8: 4BECF5B1  bl 0x825a32a8
	ctx.lr = 0x826D3CFC;
	sub_825A32A8(ctx, base);
	// 826D3CFC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3D00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3D04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3D08: 4BECDA69  bl 0x825a1770
	ctx.lr = 0x826D3D0C;
	sub_825A1770(ctx, base);
	// 826D3D0C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826D3D10: 4871F719  bl 0x82df3428
	ctx.lr = 0x826D3D14;
	sub_82DF3428(ctx, base);
	// 826D3D14: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826D3D18: 4BBF4FA1  bl 0x822c8cb8
	ctx.lr = 0x826D3D1C;
	sub_822C8CB8(ctx, base);
	// 826D3D1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3D20: 4871F709  bl 0x82df3428
	ctx.lr = 0x826D3D24;
	sub_82DF3428(ctx, base);
	// 826D3D24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3D28: 4871F701  bl 0x82df3428
	ctx.lr = 0x826D3D2C;
	sub_82DF3428(ctx, base);
	// 826D3D2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3D30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3D34: 388BFD10  addi r4, r11, -0x2f0
	ctx.r[4].s64 = ctx.r[11].s64 + -752;
	// 826D3D38: 4871FCD1  bl 0x82df3a08
	ctx.lr = 0x826D3D3C;
	sub_82DF3A08(ctx, base);
	// 826D3D3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3D40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3D44: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826D3D48: 4871FCC1  bl 0x82df3a08
	ctx.lr = 0x826D3D4C;
	sub_82DF3A08(ctx, base);
	// 826D3D4C: 38BF00B0  addi r5, r31, 0xb0
	ctx.r[5].s64 = ctx.r[31].s64 + 176;
	// 826D3D50: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3D54: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826D3D58: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 826D3D5C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826D3D60: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826D3D64: 4BECF545  bl 0x825a32a8
	ctx.lr = 0x826D3D68;
	sub_825A32A8(ctx, base);
	// 826D3D68: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3D6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3D70: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3D74: 4BECD9FD  bl 0x825a1770
	ctx.lr = 0x826D3D78;
	sub_825A1770(ctx, base);
	// 826D3D78: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826D3D7C: 4871F6AD  bl 0x82df3428
	ctx.lr = 0x826D3D80;
	sub_82DF3428(ctx, base);
	// 826D3D80: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826D3D84: 4BBF4F35  bl 0x822c8cb8
	ctx.lr = 0x826D3D88;
	sub_822C8CB8(ctx, base);
	// 826D3D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3D8C: 4871F69D  bl 0x82df3428
	ctx.lr = 0x826D3D90;
	sub_82DF3428(ctx, base);
	// 826D3D90: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3D94: 4871F695  bl 0x82df3428
	ctx.lr = 0x826D3D98;
	sub_82DF3428(ctx, base);
	// 826D3D98: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3D9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3DA0: 388BF3F8  addi r4, r11, -0xc08
	ctx.r[4].s64 = ctx.r[11].s64 + -3080;
	// 826D3DA4: 4871FC65  bl 0x82df3a08
	ctx.lr = 0x826D3DA8;
	sub_82DF3A08(ctx, base);
	// 826D3DA8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3DAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3DB0: 388B4370  addi r4, r11, 0x4370
	ctx.r[4].s64 = ctx.r[11].s64 + 17264;
	// 826D3DB4: 4871FC55  bl 0x82df3a08
	ctx.lr = 0x826D3DB8;
	sub_82DF3A08(ctx, base);
	// 826D3DB8: 38BF00B4  addi r5, r31, 0xb4
	ctx.r[5].s64 = ctx.r[31].s64 + 180;
	// 826D3DBC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3DC0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826D3DC4: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 826D3DC8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826D3DCC: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826D3DD0: 4BECF4D9  bl 0x825a32a8
	ctx.lr = 0x826D3DD4;
	sub_825A32A8(ctx, base);
	// 826D3DD4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3DD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3DDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3DE0: 4BECD991  bl 0x825a1770
	ctx.lr = 0x826D3DE4;
	sub_825A1770(ctx, base);
	// 826D3DE4: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 826D3DE8: 4871F641  bl 0x82df3428
	ctx.lr = 0x826D3DEC;
	sub_82DF3428(ctx, base);
	// 826D3DEC: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 826D3DF0: 4BBF4EC9  bl 0x822c8cb8
	ctx.lr = 0x826D3DF4;
	sub_822C8CB8(ctx, base);
	// 826D3DF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3DF8: 4871F631  bl 0x82df3428
	ctx.lr = 0x826D3DFC;
	sub_82DF3428(ctx, base);
	// 826D3DFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3E00: 4871F629  bl 0x82df3428
	ctx.lr = 0x826D3E04;
	sub_82DF3428(ctx, base);
	// 826D3E04: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826D3E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3E0C: 388B4164  addi r4, r11, 0x4164
	ctx.r[4].s64 = ctx.r[11].s64 + 16740;
	// 826D3E10: 4871FBF9  bl 0x82df3a08
	ctx.lr = 0x826D3E14;
	sub_82DF3A08(ctx, base);
	// 826D3E14: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 826D3E18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3E1C: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 826D3E20: 4871FBE9  bl 0x82df3a08
	ctx.lr = 0x826D3E24;
	sub_82DF3A08(ctx, base);
	// 826D3E24: 38BF00B8  addi r5, r31, 0xb8
	ctx.r[5].s64 = ctx.r[31].s64 + 184;
	// 826D3E28: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826D3E2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D3E30: 4BECF221  bl 0x825a3050
	ctx.lr = 0x826D3E34;
	sub_825A3050(ctx, base);
	// 826D3E34: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826D3E38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826D3E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3E40: 4BECE349  bl 0x825a2188
	ctx.lr = 0x826D3E44;
	sub_825A2188(ctx, base);
	// 826D3E44: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826D3E48: 4871F5E1  bl 0x82df3428
	ctx.lr = 0x826D3E4C;
	sub_82DF3428(ctx, base);
	// 826D3E4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826D3E50: 4BBF4E69  bl 0x822c8cb8
	ctx.lr = 0x826D3E54;
	sub_822C8CB8(ctx, base);
	// 826D3E54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826D3E58: 4871F5D1  bl 0x82df3428
	ctx.lr = 0x826D3E5C;
	sub_82DF3428(ctx, base);
	// 826D3E5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826D3E60: 4871F5C9  bl 0x82df3428
	ctx.lr = 0x826D3E64;
	sub_82DF3428(ctx, base);
	// 826D3E64: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 826D3E68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D3E6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D3E70: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826D3E74: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826D3E78: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826D3E7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826D3E80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D3E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3E88 size=244
    let mut pc: u32 = 0x826D3E88;
    'dispatch: loop {
        match pc {
            0x826D3E88 => {
    //   block [0x826D3E88..0x826D3F7C)
	// 826D3E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D3E8C: 48AD42DD  bl 0x831a8168
	ctx.lr = 0x826D3E90;
	sub_831A8130(ctx, base);
	// 826D3E90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3E94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3E98: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826D3E9C: 4BE3C86D  bl 0x82510708
	ctx.lr = 0x826D3EA0;
	sub_82510708(ctx, base);
	// 826D3EA0: 897F014C  lbz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 826D3EA4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D3EA8: 41820014  beq 0x826d3ebc
	if ctx.cr[0].eq {
	pc = 0x826D3EBC; continue 'dispatch;
	}
	// 826D3EAC: C01F0150  lfs f0, 0x150(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D3EB0: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D3EB4: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826D3EB8: D01F0150  stfs f0, 0x150(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 826D3EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826D3EC0: C03F0150  lfs f1, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D3EC4: 4BFFFA85  bl 0x826d3948
	ctx.lr = 0x826D3EC8;
	sub_826D3948(ctx, base);
	// 826D3EC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826D3ECC: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826D3ED0: 83DF0114  lwz r30, 0x114(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 826D3ED4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826D3ED8: 419A0034  beq cr6, 0x826d3f0c
	if ctx.cr[6].eq {
	pc = 0x826D3F0C; continue 'dispatch;
	}
	// 826D3EDC: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 826D3EE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D3EE4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826D3EE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D3EEC: 4E800421  bctrl
	ctx.lr = 0x826D3EF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D3EF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D3EF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826D3EF8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D3EFC: 487A7DCD  bl 0x82e7bcc8
	ctx.lr = 0x826D3F00;
	sub_82E7BCC8(ctx, base);
	// 826D3F00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D3F04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D3F08: 48472CA1  bl 0x82b46ba8
	ctx.lr = 0x826D3F0C;
	sub_82B46BA8(ctx, base);
	// 826D3F0C: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826D3F10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D3F14: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826D3F18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D3F1C: 4E800421  bctrl
	ctx.lr = 0x826D3F20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D3F20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D3F24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D3F28: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D3F2C: 487A7D9D  bl 0x82e7bcc8
	ctx.lr = 0x826D3F30;
	sub_82E7BCC8(ctx, base);
	// 826D3F30: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 826D3F34: 397F0160  addi r11, r31, 0x160
	ctx.r[11].s64 = ctx.r[31].s64 + 352;
	// 826D3F38: C1BC0000  lfs f13, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D3F3C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826D3F40: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 826D3F44: 38E00170  li r7, 0x170
	ctx.r[7].s64 = 368;
	// 826D3F48: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826D3F4C: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D3F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D3F80 size=180
    let mut pc: u32 = 0x826D3F80;
    'dispatch: loop {
        match pc {
            0x826D3F80 => {
    //   block [0x826D3F80..0x826D4034)
	// 826D3F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D3F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826D3F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826D3F8C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D3F90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D3F94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826D3F98: 3D208206  lis r9, -0x7dfa
	ctx.r[9].s64 = -2113536000;
	// 826D3F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D3FA0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826D3FA4: C1AB08A8  lfs f13, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D3FA8: 388992D8  addi r4, r9, -0x6d28
	ctx.r[4].s64 = ctx.r[9].s64 + -27944;
	// 826D3FAC: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D3FB0: 38A000FC  li r5, 0xfc
	ctx.r[5].s64 = 252;
	// 826D3FB4: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826D3FB8: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 826D3FBC: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 826D3FC0: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 826D3FC4: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 826D3FC8: 4871E421  bl 0x82df23e8
	ctx.lr = 0x826D3FCC;
	sub_82DF23E8(ctx, base);
	// 826D3FCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826D3FD0: 41820044  beq 0x826d4014
	if ctx.cr[0].eq {
	pc = 0x826D4014; continue 'dispatch;
	}
	// 826D3FD4: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826D3FD8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826D3FDC: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 826D3FE0: C07F0198  lfs f3, 0x198(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826D3FE4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826D3FE8: C05F0190  lfs f2, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826D3FEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 826D3FF0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 826D3FF4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 826D3FF8: C00A9450  lfs f0, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826D3FFC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 826D4000: C1A9ACFC  lfs f13, -0x5304(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826D4004: EC2C6838  fmsubs f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826D4008: 4BFF8779  bl 0x826cc780
	ctx.lr = 0x826D400C;
	sub_826CC780(ctx, base);
	// 826D400C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D4010: 48000008  b 0x826d4018
	pc = 0x826D4018; continue 'dispatch;
	// 826D4014: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826D4018: 387F0144  addi r3, r31, 0x144
	ctx.r[3].s64 = ctx.r[31].s64 + 324;
	// 826D401C: 4BFFFA7D  bl 0x826d3a98
	ctx.lr = 0x826D4020;
	sub_826D3A98(ctx, base);
	// 826D4020: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826D4024: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826D4028: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826D402C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826D4030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D4038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826D4038 size=240
    let mut pc: u32 = 0x826D4038;
    'dispatch: loop {
        match pc {
            0x826D4038 => {
    //   block [0x826D4038..0x826D4128)
	// 826D4038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D403C: 48AD4131  bl 0x831a816c
	ctx.lr = 0x826D4040;
	sub_831A8130(ctx, base);
	// 826D4040: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D4044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826D4048: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826D404C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826D4050: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826D4054: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 826D4058: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D405C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 826D4060: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826D4064: 4E800421  bctrl
	ctx.lr = 0x826D4068;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826D4068: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826D406C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826D4070: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D4074: 487A7C55  bl 0x82e7bcc8
	ctx.lr = 0x826D4078;
	sub_82E7BCC8(ctx, base);
	// 826D4078: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 826D407C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 826D4080: 38ABCDFC  addi r5, r11, -0x3204
	ctx.r[5].s64 = ctx.r[11].s64 + -12804;
	// 826D4084: 388A8614  addi r4, r10, -0x79ec
	ctx.r[4].s64 = ctx.r[10].s64 + -31212;
	// 826D4088: 38FF0170  addi r7, r31, 0x170
	ctx.r[7].s64 = ctx.r[31].s64 + 368;
	// 826D408C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 826D4090: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826D4094: 4BD4332D  bl 0x824173c0
	ctx.lr = 0x826D4098;
	sub_824173C0(ctx, base);
	// 826D4098: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826D409C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826D40A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826D40A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826D40A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826D40AC: 419A0024  beq cr6, 0x826d40d0
	if ctx.cr[6].eq {
	pc = 0x826D40D0; continue 'dispatch;
	}
	// 826D40B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826D40B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826D40B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D40BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826D40C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826D40C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826D40C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826D40CC: 4082FFE8  bne 0x826d40b4
	if !ctx.cr[0].eq {
	pc = 0x826D40B4; continue 'dispatch;
	}
	// 826D40D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D40D4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 826D40D8: 48934051  bl 0x83008128
	ctx.lr = 0x826D40DC;
	sub_83008128(ctx, base);
	// 826D40DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826D40E0: 3D408206  lis r10, -0x7dfa
	ctx.r[10].s64 = -2113536000;
	// 826D40E4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 826D40E8: 388A92D8  addi r4, r10, -0x6d28
	ctx.r[4].s64 = ctx.r[10].s64 + -27944;
	// 826D40EC: 38A001EE  li r5, 0x1ee
	ctx.r[5].s64 = 494;
	// 826D40F0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 826D40F4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826D40F8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 826D40FC: 48784945  bl 0x82e58a40
	ctx.lr = 0x826D4100;
	sub_82E58A40(ctx, base);
	// 826D4100: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826D4104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D4108: 419A0008  beq cr6, 0x826d4110
	if ctx.cr[6].eq {
	pc = 0x826D4110; continue 'dispatch;
	}
	// 826D410C: 4BBEC785  bl 0x822c0890
	ctx.lr = 0x826D4110;
	sub_822C0890(ctx, base);
	// 826D4110: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826D4114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826D4118: 419A0008  beq cr6, 0x826d4120
	if ctx.cr[6].eq {
	pc = 0x826D4120; continue 'dispatch;
	}
	// 826D411C: 4BBEC775  bl 0x822c0890
	ctx.lr = 0x826D4120;
	sub_822C0890(ctx, base);
	// 826D4120: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826D4124: 48AD4098  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826D4128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826D4128 size=144
    let mut pc: u32 = 0x826D4128;
    'dispatch: loop {
        match pc {
            0x826D4128 => {
    //   block [0x826D4128..0x826D41B8)
	// 826D4128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826D412C: 48AD4039  bl 0x831a8164
	ctx.lr = 0x826D4130;
	sub_831A8130(ctx, base);
	// 826D4130: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826D4134: 3F608335  lis r27, -0x7ccb
	ctx.r[27].s64 = -2093678592;
	// 826D4138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826D413C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D4140: 38BE00E8  addi r5, r30, 0xe8
	ctx.r[5].s64 = ctx.r[30].s64 + 232;
	// 826D4144: 809B7058  lwz r4, 0x7058(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826D4148: 4BE3C0A9  bl 0x825101f0
	ctx.lr = 0x826D414C;
	sub_825101F0(ctx, base);
	// 826D414C: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 826D4150: 83BE00F4  lwz r29, 0xf4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(244 as u32) ) } as u64;
	// 826D4154: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D4158: 419A0058  beq cr6, 0x826d41b0
	if ctx.cr[6].eq {
	pc = 0x826D41B0; continue 'dispatch;
	}
	// 826D415C: 3BFE00F0  addi r31, r30, 0xf0
	ctx.r[31].s64 = ctx.r[30].s64 + 240;
	// 826D4160: 3B9D0008  addi r28, r29, 8
	ctx.r[28].s64 = ctx.r[29].s64 + 8;
	// 826D4164: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826D4168: 809B7058  lwz r4, 0x7058(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826D416C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D4170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826D4174: 4BE3C07D  bl 0x825101f0
	ctx.lr = 0x826D4178;
	sub_825101F0(ctx, base);
	// 826D4178: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826D417C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826D4180: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D4184: 4BBF11CD  bl 0x822c5350
	ctx.lr = 0x826D4188;
	sub_822C5350(ctx, base);
	// 826D4188: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D418C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826D4190: 3864FFF8  addi r3, r4, -8
	ctx.r[3].s64 = ctx.r[4].s64 + -8;
	// 826D4194: 480FE1B5  bl 0x827d2348
	ctx.lr = 0x826D4198;
	sub_827D2348(ctx, base);
	// 826D4198: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 826D419C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 826D41A0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 826D41A4: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 826D41A8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826D41AC: 409AFFB8  bne cr6, 0x826d4164
	if !ctx.cr[6].eq {
	pc = 0x826D4164; continue 'dispatch;
	}
	// 826D41B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826D41B4: 48AD4000  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


