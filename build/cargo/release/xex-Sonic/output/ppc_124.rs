pub fn sub_829E2830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E2830 size=196
    let mut pc: u32 = 0x829E2830;
    'dispatch: loop {
        match pc {
            0x829E2830 => {
    //   block [0x829E2830..0x829E28F4)
	// 829E2830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E2834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E2838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E283C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E2840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E2844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2848: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E284C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829E2850: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E2854: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E2858: 4B8DE0E1  bl 0x822c0938
	ctx.lr = 0x829E285C;
	sub_822C0938(ctx, base);
	// 829E285C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E2860: 41820028  beq 0x829e2888
	if ctx.cr[0].eq {
	pc = 0x829E2888; continue 'dispatch;
	}
	// 829E2864: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E2868: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829E286C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E2870: 392B59B8  addi r9, r11, 0x59b8
	ctx.r[9].s64 = ctx.r[11].s64 + 22968;
	// 829E2874: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829E2878: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E287C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E2880: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829E2884: 48000008  b 0x829e288c
	pc = 0x829E288C; continue 'dispatch;
	// 829E2888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E288C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E2890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E2894: 409A0044  bne cr6, 0x829e28d8
	if !ctx.cr[6].eq {
	pc = 0x829E28D8; continue 'dispatch;
	}
	// 829E2898: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E289C: 419A001C  beq cr6, 0x829e28b8
	if ctx.cr[6].eq {
	pc = 0x829E28B8; continue 'dispatch;
	}
	// 829E28A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E28A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E28A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E28AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E28B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E28B4: 4E800421  bctrl
	ctx.lr = 0x829E28B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E28B8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E28BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E28C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E28C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829E28C8: 816BCB48  lwz r11, -0x34b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13496 as u32) ) } as u64;
	// 829E28CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E28D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E28D4: 4B8DD72D  bl 0x822c0000
	ctx.lr = 0x829E28D8;
	sub_822C0000(ctx, base);
	// 829E28D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E28DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E28E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E28E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E28E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E28EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E28F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E28F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E28F8 size=196
    let mut pc: u32 = 0x829E28F8;
    'dispatch: loop {
        match pc {
            0x829E28F8 => {
    //   block [0x829E28F8..0x829E29BC)
	// 829E28F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E28FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E2900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E2904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E2908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E290C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E2914: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829E2918: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E291C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E2920: 4B8DE019  bl 0x822c0938
	ctx.lr = 0x829E2924;
	sub_822C0938(ctx, base);
	// 829E2924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E2928: 41820028  beq 0x829e2950
	if ctx.cr[0].eq {
	pc = 0x829E2950; continue 'dispatch;
	}
	// 829E292C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E2930: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829E2934: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E2938: 392B59CC  addi r9, r11, 0x59cc
	ctx.r[9].s64 = ctx.r[11].s64 + 22988;
	// 829E293C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829E2940: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E2944: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E2948: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829E294C: 48000008  b 0x829e2954
	pc = 0x829E2954; continue 'dispatch;
	// 829E2950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E2954: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E2958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E295C: 409A0044  bne cr6, 0x829e29a0
	if !ctx.cr[6].eq {
	pc = 0x829E29A0; continue 'dispatch;
	}
	// 829E2960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E2964: 419A001C  beq cr6, 0x829e2980
	if ctx.cr[6].eq {
	pc = 0x829E2980; continue 'dispatch;
	}
	// 829E2968: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E296C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E2970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E2974: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E297C: 4E800421  bctrl
	ctx.lr = 0x829E2980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E2980: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E2984: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E2988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E298C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829E2990: 816BCB48  lwz r11, -0x34b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13496 as u32) ) } as u64;
	// 829E2994: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E2998: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E299C: 4B8DD665  bl 0x822c0000
	ctx.lr = 0x829E29A0;
	sub_822C0000(ctx, base);
	// 829E29A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E29A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E29A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E29AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E29B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E29B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E29B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E29C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E29C0 size=272
    let mut pc: u32 = 0x829E29C0;
    'dispatch: loop {
        match pc {
            0x829E29C0 => {
    //   block [0x829E29C0..0x829E2AD0)
	// 829E29C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E29C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E29C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E29CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E29D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E29D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E29D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E29DC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E29E0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829E29E4: 396B5A7C  addi r11, r11, 0x5a7c
	ctx.r[11].s64 = ctx.r[11].s64 + 23164;
	// 829E29E8: 815F0270  lwz r10, 0x270(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(624 as u32) ) } as u64;
	// 829E29EC: 39295A68  addi r9, r9, 0x5a68
	ctx.r[9].s64 = ctx.r[9].s64 + 23144;
	// 829E29F0: 39085A58  addi r8, r8, 0x5a58
	ctx.r[8].s64 = ctx.r[8].s64 + 23128;
	// 829E29F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E29F8: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E29FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E2A00: 911F0160  stw r8, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[8].u32 ) };
	// 829E2A04: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 829E2A08: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2A0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829E2A10: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 829E2A14: 4BFE60CD  bl 0x829c8ae0
	ctx.lr = 0x829E2A18;
	sub_829C8AE0(ctx, base);
	// 829E2A18: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E2A1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A20: 419A0008  beq cr6, 0x829e2a28
	if ctx.cr[6].eq {
	pc = 0x829E2A28; continue 'dispatch;
	}
	// 829E2A24: 4BFE2AC5  bl 0x829c54e8
	ctx.lr = 0x829E2A28;
	sub_829C54E8(ctx, base);
	// 829E2A28: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E2A2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A30: 419A0008  beq cr6, 0x829e2a38
	if ctx.cr[6].eq {
	pc = 0x829E2A38; continue 'dispatch;
	}
	// 829E2A34: 4B8DDE5D  bl 0x822c0890
	ctx.lr = 0x829E2A38;
	sub_822C0890(ctx, base);
	// 829E2A38: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 829E2A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A40: 419A0008  beq cr6, 0x829e2a48
	if ctx.cr[6].eq {
	pc = 0x829E2A48; continue 'dispatch;
	}
	// 829E2A44: 4B8DDE4D  bl 0x822c0890
	ctx.lr = 0x829E2A48;
	sub_822C0890(ctx, base);
	// 829E2A48: 807F027C  lwz r3, 0x27c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) } as u64;
	// 829E2A4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A50: 419A0008  beq cr6, 0x829e2a58
	if ctx.cr[6].eq {
	pc = 0x829E2A58; continue 'dispatch;
	}
	// 829E2A54: 4B8DDE3D  bl 0x822c0890
	ctx.lr = 0x829E2A58;
	sub_822C0890(ctx, base);
	// 829E2A58: 807F0274  lwz r3, 0x274(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 829E2A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A60: 419A0008  beq cr6, 0x829e2a68
	if ctx.cr[6].eq {
	pc = 0x829E2A68; continue 'dispatch;
	}
	// 829E2A64: 4B8DDE2D  bl 0x822c0890
	ctx.lr = 0x829E2A68;
	sub_822C0890(ctx, base);
	// 829E2A68: 807F026C  lwz r3, 0x26c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 829E2A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A70: 419A0008  beq cr6, 0x829e2a78
	if ctx.cr[6].eq {
	pc = 0x829E2A78; continue 'dispatch;
	}
	// 829E2A74: 4B8DDE1D  bl 0x822c0890
	ctx.lr = 0x829E2A78;
	sub_822C0890(ctx, base);
	// 829E2A78: 807F0264  lwz r3, 0x264(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(612 as u32) ) } as u64;
	// 829E2A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A80: 419A0008  beq cr6, 0x829e2a88
	if ctx.cr[6].eq {
	pc = 0x829E2A88; continue 'dispatch;
	}
	// 829E2A84: 4B8DDE0D  bl 0x822c0890
	ctx.lr = 0x829E2A88;
	sub_822C0890(ctx, base);
	// 829E2A88: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 829E2A8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2A90: 419A0008  beq cr6, 0x829e2a98
	if ctx.cr[6].eq {
	pc = 0x829E2A98; continue 'dispatch;
	}
	// 829E2A94: 4B8DDDFD  bl 0x822c0890
	ctx.lr = 0x829E2A98;
	sub_822C0890(ctx, base);
	// 829E2A98: 807F01F4  lwz r3, 0x1f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 829E2A9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2AA0: 419A0008  beq cr6, 0x829e2aa8
	if ctx.cr[6].eq {
	pc = 0x829E2AA8; continue 'dispatch;
	}
	// 829E2AA4: 4B8DDDED  bl 0x822c0890
	ctx.lr = 0x829E2AA8;
	sub_822C0890(ctx, base);
	// 829E2AA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E2AAC: 4847AD9D  bl 0x82e5d848
	ctx.lr = 0x829E2AB0;
	sub_82E5D848(ctx, base);
	// 829E2AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E2AB4: 4BB30C15  bl 0x825136c8
	ctx.lr = 0x829E2AB8;
	sub_825136C8(ctx, base);
	// 829E2AB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E2ABC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E2AC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E2AC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E2AC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E2ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E2AD0 size=8
    let mut pc: u32 = 0x829E2AD0;
    'dispatch: loop {
        match pc {
            0x829E2AD0 => {
    //   block [0x829E2AD0..0x829E2AD8)
	// 829E2AD0: 3863FEA0  addi r3, r3, -0x160
	ctx.r[3].s64 = ctx.r[3].s64 + -352;
	// 829E2AD4: 48000964  b 0x829e3438
	sub_829E3438(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E2AD8 size=8
    let mut pc: u32 = 0x829E2AD8;
    'dispatch: loop {
        match pc {
            0x829E2AD8 => {
    //   block [0x829E2AD8..0x829E2AE0)
	// 829E2AD8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E2ADC: 4800095C  b 0x829e3438
	sub_829E3438(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E2AE0 size=212
    let mut pc: u32 = 0x829E2AE0;
    'dispatch: loop {
        match pc {
            0x829E2AE0 => {
    //   block [0x829E2AE0..0x829E2BB4)
	// 829E2AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E2AE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E2AE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E2AEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E2AF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E2AF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2AF8: 48771B09  bl 0x83154600
	ctx.lr = 0x829E2AFC;
	sub_83154600(ctx, base);
	// 829E2AFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E2B00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E2B04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2B08: 4BB2C9C1  bl 0x8250f4c8
	ctx.lr = 0x829E2B0C;
	sub_8250F4C8(ctx, base);
	// 829E2B0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E2B14: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829E2B18: 409A0008  bne cr6, 0x829e2b20
	if !ctx.cr[6].eq {
	pc = 0x829E2B20; continue 'dispatch;
	}
	// 829E2B1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E2B20: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829E2B24: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829E2B28: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829E2B2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E2B30: 48164371  bl 0x82b46ea0
	ctx.lr = 0x829E2B34;
	sub_82B46EA0(ctx, base);
	// 829E2B34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E2B38: 4840F159  bl 0x82df1c90
	ctx.lr = 0x829E2B3C;
	sub_82DF1C90(ctx, base);
	// 829E2B3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E2B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E2B44: 419A003C  beq cr6, 0x829e2b80
	if ctx.cr[6].eq {
	pc = 0x829E2B80; continue 'dispatch;
	}
	// 829E2B48: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E2B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E2B50: 4BB30A29  bl 0x82513578
	ctx.lr = 0x829E2B54;
	sub_82513578(ctx, base);
	// 829E2B54: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E2B58: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 829E2B5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E2B60: 388BA474  addi r4, r11, -0x5b8c
	ctx.r[4].s64 = ctx.r[11].s64 + -23436;
	// 829E2B64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2B68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2B6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E2B70: 4E800421  bctrl
	ctx.lr = 0x829E2B74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E2B74: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E2B78: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E2B7C: 4816402D  bl 0x82b46ba8
	ctx.lr = 0x829E2B80;
	sub_82B46BA8(ctx, base);
	// 829E2B80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E2B84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E2B88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2B8C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E2B90: D01E0060  stfs f0, 0x60(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829E2B94: 419A0008  beq cr6, 0x829e2b9c
	if ctx.cr[6].eq {
	pc = 0x829E2B9C; continue 'dispatch;
	}
	// 829E2B98: 4B8DDCF9  bl 0x822c0890
	ctx.lr = 0x829E2B9C;
	sub_822C0890(ctx, base);
	// 829E2B9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E2BA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E2BA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E2BA8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E2BAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E2BB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E2BB8 size=156
    let mut pc: u32 = 0x829E2BB8;
    'dispatch: loop {
        match pc {
            0x829E2BB8 => {
    //   block [0x829E2BB8..0x829E2C54)
	// 829E2BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E2BBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E2BC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E2BC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E2BC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E2BCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2BD0: 48771A31  bl 0x83154600
	ctx.lr = 0x829E2BD4;
	sub_83154600(ctx, base);
	// 829E2BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E2BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E2BDC: 48476B9D  bl 0x82e59778
	ctx.lr = 0x829E2BE0;
	sub_82E59778(ctx, base);
	// 829E2BE0: C01E0060  lfs f0, 0x60(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E2BE4: EDA1002A  fadds f13, f1, f0
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829E2BE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E2BEC: D1BE0060  stfs f13, 0x60(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829E2BF0: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E2BF4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829E2BF8: 40990044  ble cr6, 0x829e2c3c
	if !ctx.cr[6].gt {
	pc = 0x829E2C3C; continue 'dispatch;
	}
	// 829E2BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E2C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E2C04: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 829E2C08: 48410E01  bl 0x82df3a08
	ctx.lr = 0x829E2C0C;
	sub_82DF3A08(ctx, base);
	// 829E2C0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E2C10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829E2C14: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 829E2C18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E2C1C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E2C20: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829E2C24: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E2C28: 4847BD39  bl 0x82e5e960
	ctx.lr = 0x829E2C2C;
	sub_82E5E960(ctx, base);
	// 829E2C2C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E2C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2C34: 419A0008  beq cr6, 0x829e2c3c
	if ctx.cr[6].eq {
	pc = 0x829E2C3C; continue 'dispatch;
	}
	// 829E2C38: 4B8DDC59  bl 0x822c0890
	ctx.lr = 0x829E2C3C;
	sub_822C0890(ctx, base);
	// 829E2C3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E2C40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E2C44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E2C48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E2C4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E2C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E2C58 size=236
    let mut pc: u32 = 0x829E2C58;
    'dispatch: loop {
        match pc {
            0x829E2C58 => {
    //   block [0x829E2C58..0x829E2D44)
	// 829E2C58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E2C5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E2C60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E2C64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E2C68: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829E2C6C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E2C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E2C74: 4877198D  bl 0x83154600
	ctx.lr = 0x829E2C78;
	sub_83154600(ctx, base);
	// 829E2C78: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 829E2C7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2C80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E2C84: 419A00A4  beq cr6, 0x829e2d28
	if ctx.cr[6].eq {
	pc = 0x829E2D28; continue 'dispatch;
	}
	// 829E2C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E2C8C: 48476AED  bl 0x82e59778
	ctx.lr = 0x829E2C90;
	sub_82E59778(ctx, base);
	// 829E2C90: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E2C94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E2C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E2C9C: C00B9524  lfs f0, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E2CA0: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829E2CA4: 4BB308D5  bl 0x82513578
	ctx.lr = 0x829E2CA8;
	sub_82513578(ctx, base);
	// 829E2CA8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E2CAC: EC1F07F2  fmuls f0, f31, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 829E2CB0: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 829E2CB4: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 829E2CB8: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E2CBC: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E2D48 size=616
    let mut pc: u32 = 0x829E2D48;
    'dispatch: loop {
        match pc {
            0x829E2D48 => {
    //   block [0x829E2D48..0x829E2FB0)
	// 829E2D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E2D4C: 487C541D  bl 0x831a8168
	ctx.lr = 0x829E2D50;
	sub_831A8130(ctx, base);
	// 829E2D50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E2D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2D58: 487718A9  bl 0x83154600
	ctx.lr = 0x829E2D5C;
	sub_83154600(ctx, base);
	// 829E2D5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E2D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E2D64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2D68: 4BDD3871  bl 0x827b65d8
	ctx.lr = 0x829E2D6C;
	sub_827B65D8(ctx, base);
	// 829E2D6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2D70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2D74: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E2D78: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E2D7C: 419A000C  beq cr6, 0x829e2d88
	if ctx.cr[6].eq {
	pc = 0x829E2D88; continue 'dispatch;
	}
	// 829E2D80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E2D84: 484EBA7D  bl 0x82ece800
	ctx.lr = 0x829E2D88;
	sub_82ECE800(ctx, base);
	// 829E2D88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E2D8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2D90: 419A0008  beq cr6, 0x829e2d98
	if ctx.cr[6].eq {
	pc = 0x829E2D98; continue 'dispatch;
	}
	// 829E2D94: 4B8DDAFD  bl 0x822c0890
	ctx.lr = 0x829E2D98;
	sub_822C0890(ctx, base);
	// 829E2D98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2D9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E2DA0: 4BDD3839  bl 0x827b65d8
	ctx.lr = 0x829E2DA4;
	sub_827B65D8(ctx, base);
	// 829E2DA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2DA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E2DAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E2DB0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E2DB4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2DB8: 484E8DD9  bl 0x82ecbb90
	ctx.lr = 0x829E2DBC;
	sub_82ECBB90(ctx, base);
	// 829E2DBC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E2DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2DC4: 419A0008  beq cr6, 0x829e2dcc
	if ctx.cr[6].eq {
	pc = 0x829E2DCC; continue 'dispatch;
	}
	// 829E2DC8: 4B8DDAC9  bl 0x822c0890
	ctx.lr = 0x829E2DCC;
	sub_822C0890(ctx, base);
	// 829E2DCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2DD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E2DD4: 4BDD3805  bl 0x827b65d8
	ctx.lr = 0x829E2DD8;
	sub_827B65D8(ctx, base);
	// 829E2DD8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E2DDC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2DE0: 3BAB7060  addi r29, r11, 0x7060
	ctx.r[29].s64 = ctx.r[11].s64 + 28768;
	// 829E2DE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E2DE8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2DEC: 4B9069D5  bl 0x822e97c0
	ctx.lr = 0x829E2DF0;
	sub_822E97C0(ctx, base);
	// 829E2DF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E2DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2DF8: 419A0008  beq cr6, 0x829e2e00
	if ctx.cr[6].eq {
	pc = 0x829E2E00; continue 'dispatch;
	}
	// 829E2DFC: 4B8DDA95  bl 0x822c0890
	ctx.lr = 0x829E2E00;
	sub_822C0890(ctx, base);
	// 829E2E00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2E04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E2E08: 4BDD37D1  bl 0x827b65d8
	ctx.lr = 0x829E2E0C;
	sub_827B65D8(ctx, base);
	// 829E2E0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2E10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E2E14: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2E18: 4B90A0E1  bl 0x822ecef8
	ctx.lr = 0x829E2E1C;
	sub_822ECEF8(ctx, base);
	// 829E2E1C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829E2E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2E24: 419A0008  beq cr6, 0x829e2e2c
	if ctx.cr[6].eq {
	pc = 0x829E2E2C; continue 'dispatch;
	}
	// 829E2E28: 4B8DDA69  bl 0x822c0890
	ctx.lr = 0x829E2E2C;
	sub_822C0890(ctx, base);
	// 829E2E2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2E30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E2E34: 4BDD37A5  bl 0x827b65d8
	ctx.lr = 0x829E2E38;
	sub_827B65D8(ctx, base);
	// 829E2E38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2E3C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2E40: 386B00D0  addi r3, r11, 0xd0
	ctx.r[3].s64 = ctx.r[11].s64 + 208;
	// 829E2E44: 484F7735  bl 0x82eda578
	ctx.lr = 0x829E2E48;
	sub_82EDA578(ctx, base);
	// 829E2E48: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829E2E4C: D03E006C  stfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829E2E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2E54: 419A0008  beq cr6, 0x829e2e5c
	if ctx.cr[6].eq {
	pc = 0x829E2E5C; continue 'dispatch;
	}
	// 829E2E58: 4B8DDA39  bl 0x822c0890
	ctx.lr = 0x829E2E5C;
	sub_822C0890(ctx, base);
	// 829E2E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2E60: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E2E64: 4BDD3775  bl 0x827b65d8
	ctx.lr = 0x829E2E68;
	sub_827B65D8(ctx, base);
	// 829E2E68: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E2E6C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2E70: C02BCC2C  lfs f1, -0x33d4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13268 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E2E74: 4B90ACE5  bl 0x822edb58
	ctx.lr = 0x829E2E78;
	sub_822EDB58(ctx, base);
	// 829E2E78: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E2E7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2E80: 419A0008  beq cr6, 0x829e2e88
	if ctx.cr[6].eq {
	pc = 0x829E2E88; continue 'dispatch;
	}
	// 829E2E84: 4B8DDA0D  bl 0x822c0890
	ctx.lr = 0x829E2E88;
	sub_822C0890(ctx, base);
	// 829E2E88: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829E2E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E2E90: 4BB306E9  bl 0x82513578
	ctx.lr = 0x829E2E94;
	sub_82513578(ctx, base);
	// 829E2E94: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E2FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E2FB0 size=204
    let mut pc: u32 = 0x829E2FB0;
    'dispatch: loop {
        match pc {
            0x829E2FB0 => {
    //   block [0x829E2FB0..0x829E307C)
	// 829E2FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E2FB4: 487C51B9  bl 0x831a816c
	ctx.lr = 0x829E2FB8;
	sub_831A8130(ctx, base);
	// 829E2FB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E2FBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E2FC0: 48771641  bl 0x83154600
	ctx.lr = 0x829E2FC4;
	sub_83154600(ctx, base);
	// 829E2FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E2FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E2FCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E2FD0: 4BDD3609  bl 0x827b65d8
	ctx.lr = 0x829E2FD4;
	sub_827B65D8(ctx, base);
	// 829E2FD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E2FD8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E2FDC: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E2FE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E2FE4: 419A000C  beq cr6, 0x829e2ff0
	if ctx.cr[6].eq {
	pc = 0x829E2FF0; continue 'dispatch;
	}
	// 829E2FE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E2FEC: 484EB815  bl 0x82ece800
	ctx.lr = 0x829E2FF0;
	sub_82ECE800(ctx, base);
	// 829E2FF0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E2FF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E2FF8: 419A0008  beq cr6, 0x829e3000
	if ctx.cr[6].eq {
	pc = 0x829E3000; continue 'dispatch;
	}
	// 829E2FFC: 4B8DD895  bl 0x822c0890
	ctx.lr = 0x829E3000;
	sub_822C0890(ctx, base);
	// 829E3000: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3004: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3008: 4BDD35D1  bl 0x827b65d8
	ctx.lr = 0x829E300C;
	sub_827B65D8(ctx, base);
	// 829E300C: C03E006C  lfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E3010: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3014: 4B90AB45  bl 0x822edb58
	ctx.lr = 0x829E3018;
	sub_822EDB58(ctx, base);
	// 829E3018: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E301C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3020: 419A0008  beq cr6, 0x829e3028
	if ctx.cr[6].eq {
	pc = 0x829E3028; continue 'dispatch;
	}
	// 829E3024: 4B8DD86D  bl 0x822c0890
	ctx.lr = 0x829E3028;
	sub_822C0890(ctx, base);
	// 829E3028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E302C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E3030: 4BDD35A9  bl 0x827b65d8
	ctx.lr = 0x829E3034;
	sub_827B65D8(ctx, base);
	// 829E3034: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3038: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E303C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E3040: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E3044: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E3048: 484E8B49  bl 0x82ecbb90
	ctx.lr = 0x829E304C;
	sub_82ECBB90(ctx, base);
	// 829E304C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E3050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3054: 419A0008  beq cr6, 0x829e305c
	if ctx.cr[6].eq {
	pc = 0x829E305C; continue 'dispatch;
	}
	// 829E3058: 4B8DD839  bl 0x822c0890
	ctx.lr = 0x829E305C;
	sub_822C0890(ctx, base);
	// 829E305C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E3060: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E3064: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 829E3068: 419A000C  beq cr6, 0x829e3074
	if ctx.cr[6].eq {
	pc = 0x829E3074; continue 'dispatch;
	}
	// 829E306C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E3070: 484E9F99  bl 0x82ecd008
	ctx.lr = 0x829E3074;
	sub_82ECD008(ctx, base);
	// 829E3074: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E3078: 487C5144  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E3080 size=112
    let mut pc: u32 = 0x829E3080;
    'dispatch: loop {
        match pc {
            0x829E3080 => {
    //   block [0x829E3080..0x829E30F0)
	// 829E3080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E3088: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E308C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3090: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E3094: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E309C: 388B039C  addi r4, r11, 0x39c
	ctx.r[4].s64 = ctx.r[11].s64 + 924;
	// 829E30A0: 48410969  bl 0x82df3a08
	ctx.lr = 0x829E30A4;
	sub_82DF3A08(ctx, base);
	// 829E30A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E30A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829E30AC: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 829E30B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E30B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E30B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829E30BC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E30C0: 4847B8A1  bl 0x82e5e960
	ctx.lr = 0x829E30C4;
	sub_82E5E960(ctx, base);
	// 829E30C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E30C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E30CC: 419A0008  beq cr6, 0x829e30d4
	if ctx.cr[6].eq {
	pc = 0x829E30D4; continue 'dispatch;
	}
	// 829E30D0: 4B8DD7C1  bl 0x822c0890
	ctx.lr = 0x829E30D4;
	sub_822C0890(ctx, base);
	// 829E30D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E30D8: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 829E30DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E30E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E30E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E30E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E30EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E30F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E30F0 size=508
    let mut pc: u32 = 0x829E30F0;
    'dispatch: loop {
        match pc {
            0x829E30F0 => {
    //   block [0x829E30F0..0x829E32EC)
	// 829E30F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E30F4: 487C5075  bl 0x831a8168
	ctx.lr = 0x829E30F8;
	sub_831A8130(ctx, base);
	// 829E30F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E30FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3100: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 829E3104: 3BDF01C0  addi r30, r31, 0x1c0
	ctx.r[30].s64 = ctx.r[31].s64 + 448;
	// 829E3108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E310C: 3BA40030  addi r29, r4, 0x30
	ctx.r[29].s64 = ctx.r[4].s64 + 48;
	// 829E3110: 3B840040  addi r28, r4, 0x40
	ctx.r[28].s64 = ctx.r[4].s64 + 64;
	// 829E3114: 13E450C7  vcmpequd (lvx128) v31, v4, v10
	tmp.u32 = ctx.r[4].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E32F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E32F0 size=112
    let mut pc: u32 = 0x829E32F0;
    'dispatch: loop {
        match pc {
            0x829E32F0 => {
    //   block [0x829E32F0..0x829E3360)
	// 829E32F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E32F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E32F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E32FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3300: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E3304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E330C: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 829E3310: 484106F9  bl 0x82df3a08
	ctx.lr = 0x829E3314;
	sub_82DF3A08(ctx, base);
	// 829E3314: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E3318: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829E331C: 389F0160  addi r4, r31, 0x160
	ctx.r[4].s64 = ctx.r[31].s64 + 352;
	// 829E3320: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3324: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3328: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829E332C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E3330: 4847B631  bl 0x82e5e960
	ctx.lr = 0x829E3334;
	sub_82E5E960(ctx, base);
	// 829E3334: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E3338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E333C: 419A0008  beq cr6, 0x829e3344
	if ctx.cr[6].eq {
	pc = 0x829E3344; continue 'dispatch;
	}
	// 829E3340: 4B8DD551  bl 0x822c0890
	ctx.lr = 0x829E3344;
	sub_822C0890(ctx, base);
	// 829E3344: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E3348: 917F024C  stw r11, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[11].u32 ) };
	// 829E334C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E3350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E3354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E3358: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E335C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E3360 size=212
    let mut pc: u32 = 0x829E3360;
    'dispatch: loop {
        match pc {
            0x829E3360 => {
    //   block [0x829E3360..0x829E3434)
	// 829E3360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E3368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E336C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E3370: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829E3374: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3378: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E337C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829E3380: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E3384: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E3388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E338C: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 829E3390: 915E0060  stw r10, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829E3394: 4BB301E5  bl 0x82513578
	ctx.lr = 0x829E3398;
	sub_82513578(ctx, base);
	// 829E3398: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829E339C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E33A0: 4BB30199  bl 0x82513538
	ctx.lr = 0x829E33A4;
	sub_82513538(ctx, base);
	// 829E33A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829E33A8: 48498759  bl 0x82e7bb00
	ctx.lr = 0x829E33AC;
	sub_82E7BB00(ctx, base);
	// 829E33AC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829E33B0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E33B4: 48498E45  bl 0x82e7c1f8
	ctx.lr = 0x829E33B8;
	sub_82E7C1F8(ctx, base);
	// 829E33B8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829E33BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829E33C0: C3FF01FC  lfs f31, 0x1fc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829E33C4: 48498E35  bl 0x82e7c1f8
	ctx.lr = 0x829E33C8;
	sub_82E7C1F8(ctx, base);
	// 829E33C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E33CC: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829E33D0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3438 size=76
    let mut pc: u32 = 0x829E3438;
    'dispatch: loop {
        match pc {
            0x829E3438 => {
    //   block [0x829E3438..0x829E3484)
	// 829E3438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E343C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E3440: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E3444: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E3448: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E344C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3450: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E3454: 4BFFF56D  bl 0x829e29c0
	ctx.lr = 0x829E3458;
	sub_829E29C0(ctx, base);
	// 829E3458: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E345C: 4182000C  beq 0x829e3468
	if ctx.cr[0].eq {
	pc = 0x829E3468; continue 'dispatch;
	}
	// 829E3460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3464: 4840EF75  bl 0x82df23d8
	ctx.lr = 0x829E3468;
	sub_82DF23D8(ctx, base);
	// 829E3468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E346C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E3470: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E3474: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E3478: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E347C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E3480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3488 size=204
    let mut pc: u32 = 0x829E3488;
    'dispatch: loop {
        match pc {
            0x829E3488 => {
    //   block [0x829E3488..0x829E3554)
	// 829E3488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E348C: 487C4CDD  bl 0x831a8168
	ctx.lr = 0x829E3490;
	sub_831A8130(ctx, base);
	// 829E3490: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3494: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E3498: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829E349C: 3BFD0278  addi r31, r29, 0x278
	ctx.r[31].s64 = ctx.r[29].s64 + 632;
	// 829E34A0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E34A4: 817D0278  lwz r11, 0x278(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(632 as u32) ) } as u64;
	// 829E34A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E34AC: 419A0048  beq cr6, 0x829e34f4
	if ctx.cr[6].eq {
	pc = 0x829E34F4; continue 'dispatch;
	}
	// 829E34B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E34B4: 4BB2749D  bl 0x8250a950
	ctx.lr = 0x829E34B8;
	sub_8250A950(ctx, base);
	// 829E34B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E34BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E34C0: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829E34C4: 409A0008  bne cr6, 0x829e34cc
	if !ctx.cr[6].eq {
	pc = 0x829E34CC; continue 'dispatch;
	}
	// 829E34C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E34CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E34D0: 4BDF04A1  bl 0x827d3970
	ctx.lr = 0x829E34D4;
	sub_827D3970(ctx, base);
	// 829E34D4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E34D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E34DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E34E0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829E34E4: 419A0008  beq cr6, 0x829e34ec
	if ctx.cr[6].eq {
	pc = 0x829E34EC; continue 'dispatch;
	}
	// 829E34E8: 4B8DD3A9  bl 0x822c0890
	ctx.lr = 0x829E34EC;
	sub_822C0890(ctx, base);
	// 829E34EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E34F0: 4840E7A1  bl 0x82df1c90
	ctx.lr = 0x829E34F4;
	sub_82DF1C90(ctx, base);
	// 829E34F4: 817D0280  lwz r11, 0x280(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(640 as u32) ) } as u64;
	// 829E34F8: 3BFD0280  addi r31, r29, 0x280
	ctx.r[31].s64 = ctx.r[29].s64 + 640;
	// 829E34FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E3500: 419A004C  beq cr6, 0x829e354c
	if ctx.cr[6].eq {
	pc = 0x829E354C; continue 'dispatch;
	}
	// 829E3504: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E3508: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E350C: 4BB27445  bl 0x8250a950
	ctx.lr = 0x829E3510;
	sub_8250A950(ctx, base);
	// 829E3510: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E3514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E3518: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829E351C: 409A0008  bne cr6, 0x829e3524
	if !ctx.cr[6].eq {
	pc = 0x829E3524; continue 'dispatch;
	}
	// 829E3520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3524: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3528: 4BDF0449  bl 0x827d3970
	ctx.lr = 0x829E352C;
	sub_827D3970(ctx, base);
	// 829E352C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E3530: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E3534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3538: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829E353C: 419A0008  beq cr6, 0x829e3544
	if ctx.cr[6].eq {
	pc = 0x829E3544; continue 'dispatch;
	}
	// 829E3540: 4B8DD351  bl 0x822c0890
	ctx.lr = 0x829E3544;
	sub_822C0890(ctx, base);
	// 829E3544: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3548: 4840E749  bl 0x82df1c90
	ctx.lr = 0x829E354C;
	sub_82DF1C90(ctx, base);
	// 829E354C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E3550: 487C4C68  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3558 size=324
    let mut pc: u32 = 0x829E3558;
    'dispatch: loop {
        match pc {
            0x829E3558 => {
    //   block [0x829E3558..0x829E369C)
	// 829E3558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E355C: 487C4C11  bl 0x831a816c
	ctx.lr = 0x829E3560;
	sub_831A8130(ctx, base);
	// 829E3560: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3564: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E3568: 48771099  bl 0x83154600
	ctx.lr = 0x829E356C;
	sub_83154600(ctx, base);
	// 829E356C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E3574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3578: 4BDD3061  bl 0x827b65d8
	ctx.lr = 0x829E357C;
	sub_827B65D8(ctx, base);
	// 829E357C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3580: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E3584: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E3588: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E358C: 419A000C  beq cr6, 0x829e3598
	if ctx.cr[6].eq {
	pc = 0x829E3598; continue 'dispatch;
	}
	// 829E3590: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E3594: 484EB26D  bl 0x82ece800
	ctx.lr = 0x829E3598;
	sub_82ECE800(ctx, base);
	// 829E3598: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E359C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E35A0: 419A0008  beq cr6, 0x829e35a8
	if ctx.cr[6].eq {
	pc = 0x829E35A8; continue 'dispatch;
	}
	// 829E35A4: 4B8DD2ED  bl 0x822c0890
	ctx.lr = 0x829E35A8;
	sub_822C0890(ctx, base);
	// 829E35A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E35AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E35B0: 4BDD3029  bl 0x827b65d8
	ctx.lr = 0x829E35B4;
	sub_827B65D8(ctx, base);
	// 829E35B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E35B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E35BC: 808B682C  lwz r4, 0x682c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26668 as u32) ) } as u64;
	// 829E35C0: 4BAABDE1  bl 0x8248f3a0
	ctx.lr = 0x829E35C4;
	sub_8248F3A0(ctx, base);
	// 829E35C4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E35C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E35CC: 419A0008  beq cr6, 0x829e35d4
	if ctx.cr[6].eq {
	pc = 0x829E35D4; continue 'dispatch;
	}
	// 829E35D0: 4B8DD2C1  bl 0x822c0890
	ctx.lr = 0x829E35D4;
	sub_822C0890(ctx, base);
	// 829E35D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E35D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E35DC: 4BDD2FFD  bl 0x827b65d8
	ctx.lr = 0x829E35E0;
	sub_827B65D8(ctx, base);
	// 829E35E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E35E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E35E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E35EC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 829E35F0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E35F4: 484E859D  bl 0x82ecbb90
	ctx.lr = 0x829E35F8;
	sub_82ECBB90(ctx, base);
	// 829E35F8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E35FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3600: 419A0008  beq cr6, 0x829e3608
	if ctx.cr[6].eq {
	pc = 0x829E3608; continue 'dispatch;
	}
	// 829E3604: 4B8DD28D  bl 0x822c0890
	ctx.lr = 0x829E3608;
	sub_822C0890(ctx, base);
	// 829E3608: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 829E360C: 4BA48FED  bl 0x8242c5f8
	ctx.lr = 0x829E3610;
	sub_8242C5F8(ctx, base);
	// 829E3610: 389E0070  addi r4, r30, 0x70
	ctx.r[4].s64 = ctx.r[30].s64 + 112;
	// 829E3614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3618: 4BB2FF61  bl 0x82513578
	ctx.lr = 0x829E361C;
	sub_82513578(ctx, base);
	// 829E361C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3620: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E3624: 4BB2BEA5  bl 0x8250f4c8
	ctx.lr = 0x829E3628;
	sub_8250F4C8(ctx, base);
	// 829E3628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E362C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E3630: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829E3634: 409A0008  bne cr6, 0x829e363c
	if !ctx.cr[6].eq {
	pc = 0x829E363C; continue 'dispatch;
	}
	// 829E3638: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E363C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829E3640: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829E3644: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829E3648: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E364C: 48163855  bl 0x82b46ea0
	ctx.lr = 0x829E3650;
	sub_82B46EA0(ctx, base);
	// 829E3650: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E3654: 395E0080  addi r10, r30, 0x80
	ctx.r[10].s64 = ctx.r[30].s64 + 128;
	// 829E3658: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829E365C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 829E3660: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3664: 917E0080  stw r11, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829E3668: 4B8E0DF9  bl 0x822c4460
	ctx.lr = 0x829E366C;
	sub_822C4460(ctx, base);
	// 829E366C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829E3670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3674: 419A0008  beq cr6, 0x829e367c
	if ctx.cr[6].eq {
	pc = 0x829E367C; continue 'dispatch;
	}
	// 829E3678: 4B8DD219  bl 0x822c0890
	ctx.lr = 0x829E367C;
	sub_822C0890(ctx, base);
	// 829E367C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E3680: 4840E611  bl 0x82df1c90
	ctx.lr = 0x829E3684;
	sub_82DF1C90(ctx, base);
	// 829E3684: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E3688: 419A000C  beq cr6, 0x829e3694
	if ctx.cr[6].eq {
	pc = 0x829E3694; continue 'dispatch;
	}
	// 829E368C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E3690: 484E9979  bl 0x82ecd008
	ctx.lr = 0x829E3694;
	sub_82ECD008(ctx, base);
	// 829E3694: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E3698: 487C4B24  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E36A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E36A0 size=116
    let mut pc: u32 = 0x829E36A0;
    'dispatch: loop {
        match pc {
            0x829E36A0 => {
    //   block [0x829E36A0..0x829E3714)
	// 829E36A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E36A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E36A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E36AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E36B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E36B4: 4BB2EBAD  bl 0x82512260
	ctx.lr = 0x829E36B8;
	sub_82512260(ctx, base);
	// 829E36B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E36BC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E36C0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 829E36C4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E36C8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829E36CC: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829E36D0: 394A5B54  addi r10, r10, 0x5b54
	ctx.r[10].s64 = ctx.r[10].s64 + 23380;
	// 829E36D4: 39295B40  addi r9, r9, 0x5b40
	ctx.r[9].s64 = ctx.r[9].s64 + 23360;
	// 829E36D8: 39085AF4  addi r8, r8, 0x5af4
	ctx.r[8].s64 = ctx.r[8].s64 + 23284;
	// 829E36DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829E36E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E36E4: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E36E8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 829E36EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E36F0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829E36F4: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829E36F8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 829E36FC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 829E3700: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E3704: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E3708: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E370C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E3710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E3718 size=8
    let mut pc: u32 = 0x829E3718;
    'dispatch: loop {
        match pc {
            0x829E3718 => {
    //   block [0x829E3718..0x829E3720)
	// 829E3718: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E371C: 480005B4  b 0x829e3cd0
	sub_829E3CD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E3720 size=8
    let mut pc: u32 = 0x829E3720;
    'dispatch: loop {
        match pc {
            0x829E3720 => {
    //   block [0x829E3720..0x829E3728)
	// 829E3720: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829E3724: 480005AC  b 0x829e3cd0
	sub_829E3CD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3728 size=136
    let mut pc: u32 = 0x829E3728;
    'dispatch: loop {
        match pc {
            0x829E3728 => {
    //   block [0x829E3728..0x829E37B0)
	// 829E3728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E372C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E3730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E3734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E3738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E373C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3740: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3744: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E3748: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E374C: 396B5B54  addi r11, r11, 0x5b54
	ctx.r[11].s64 = ctx.r[11].s64 + 23380;
	// 829E3750: 394A5B40  addi r10, r10, 0x5b40
	ctx.r[10].s64 = ctx.r[10].s64 + 23360;
	// 829E3754: 39295AF4  addi r9, r9, 0x5af4
	ctx.r[9].s64 = ctx.r[9].s64 + 23284;
	// 829E3758: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E375C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829E3760: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 829E3764: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 829E3768: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 829E376C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3770: 419A0008  beq cr6, 0x829e3778
	if ctx.cr[6].eq {
	pc = 0x829E3778; continue 'dispatch;
	}
	// 829E3774: 4B8DD11D  bl 0x822c0890
	ctx.lr = 0x829E3778;
	sub_822C0890(ctx, base);
	// 829E3778: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829E377C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3780: 419A0008  beq cr6, 0x829e3788
	if ctx.cr[6].eq {
	pc = 0x829E3788; continue 'dispatch;
	}
	// 829E3784: 4B8DD10D  bl 0x822c0890
	ctx.lr = 0x829E3788;
	sub_822C0890(ctx, base);
	// 829E3788: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E378C: 4BDC3ECD  bl 0x827a7658
	ctx.lr = 0x829E3790;
	sub_827A7658(ctx, base);
	// 829E3790: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3794: 4B96BBBD  bl 0x8234f350
	ctx.lr = 0x829E3798;
	sub_8234F350(ctx, base);
	// 829E3798: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E379C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E37A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E37A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E37A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E37AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E37B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E37B0 size=124
    let mut pc: u32 = 0x829E37B0;
    'dispatch: loop {
        match pc {
            0x829E37B0 => {
    //   block [0x829E37B0..0x829E382C)
	// 829E37B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E37B4: 487C49B9  bl 0x831a816c
	ctx.lr = 0x829E37B8;
	sub_831A8130(ctx, base);
	// 829E37B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E37BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E37C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E37C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E37C8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 829E37CC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 829E37D0: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829E37D4: 4840EC15  bl 0x82df23e8
	ctx.lr = 0x829E37D8;
	sub_82DF23E8(ctx, base);
	// 829E37D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E37DC: 4182001C  beq 0x829e37f8
	if ctx.cr[0].eq {
	pc = 0x829E37F8; continue 'dispatch;
	}
	// 829E37E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E37E4: 48479145  bl 0x82e5c928
	ctx.lr = 0x829E37E8;
	sub_82E5C928(ctx, base);
	// 829E37E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E37EC: 396B59E0  addi r11, r11, 0x59e0
	ctx.r[11].s64 = ctx.r[11].s64 + 23008;
	// 829E37F0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E37F4: 48000008  b 0x829e37fc
	pc = 0x829E37FC; continue 'dispatch;
	// 829E37F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E37FC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E3800: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829E3804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E380C: 4BFFEE95  bl 0x829e26a0
	ctx.lr = 0x829E3810;
	sub_829E26A0(ctx, base);
	// 829E3810: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E3814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E381C: 4B8DC7E5  bl 0x822c0000
	ctx.lr = 0x829E3820;
	sub_822C0000(ctx, base);
	// 829E3820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E3824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E3828: 487C4994  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3830 size=124
    let mut pc: u32 = 0x829E3830;
    'dispatch: loop {
        match pc {
            0x829E3830 => {
    //   block [0x829E3830..0x829E38AC)
	// 829E3830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3834: 487C4939  bl 0x831a816c
	ctx.lr = 0x829E3838;
	sub_831A8130(ctx, base);
	// 829E3838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E383C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E3840: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E3844: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3848: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 829E384C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 829E3850: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829E3854: 4840EB95  bl 0x82df23e8
	ctx.lr = 0x829E3858;
	sub_82DF23E8(ctx, base);
	// 829E3858: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E385C: 4182001C  beq 0x829e3878
	if ctx.cr[0].eq {
	pc = 0x829E3878; continue 'dispatch;
	}
	// 829E3860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3864: 484790C5  bl 0x82e5c928
	ctx.lr = 0x829E3868;
	sub_82E5C928(ctx, base);
	// 829E3868: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E386C: 396B5A08  addi r11, r11, 0x5a08
	ctx.r[11].s64 = ctx.r[11].s64 + 23048;
	// 829E3870: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E3874: 48000008  b 0x829e387c
	pc = 0x829E387C; continue 'dispatch;
	// 829E3878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E387C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E3880: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829E3884: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3888: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E388C: 4BFFEEDD  bl 0x829e2768
	ctx.lr = 0x829E3890;
	sub_829E2768(ctx, base);
	// 829E3890: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E3894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E389C: 4B8DC765  bl 0x822c0000
	ctx.lr = 0x829E38A0;
	sub_822C0000(ctx, base);
	// 829E38A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E38A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E38A8: 487C4914  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E38B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E38B0 size=136
    let mut pc: u32 = 0x829E38B0;
    'dispatch: loop {
        match pc {
            0x829E38B0 => {
    //   block [0x829E38B0..0x829E3938)
	// 829E38B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E38B4: 487C48B9  bl 0x831a816c
	ctx.lr = 0x829E38B8;
	sub_831A8130(ctx, base);
	// 829E38B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E38BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E38C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E38C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E38C8: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 829E38CC: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 829E38D0: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 829E38D4: 4840EB15  bl 0x82df23e8
	ctx.lr = 0x829E38D8;
	sub_82DF23E8(ctx, base);
	// 829E38D8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E38DC: 41820028  beq 0x829e3904
	if ctx.cr[0].eq {
	pc = 0x829E3904; continue 'dispatch;
	}
	// 829E38E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E38E4: 48479045  bl 0x82e5c928
	ctx.lr = 0x829E38E8;
	sub_82E5C928(ctx, base);
	// 829E38E8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E38EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E38F0: 394A5AC8  addi r10, r10, 0x5ac8
	ctx.r[10].s64 = ctx.r[10].s64 + 23240;
	// 829E38F4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829E38F8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 829E38FC: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 829E3900: 48000008  b 0x829e3908
	pc = 0x829E3908; continue 'dispatch;
	// 829E3904: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E3908: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E390C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829E3910: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3914: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3918: 4BFFEF19  bl 0x829e2830
	ctx.lr = 0x829E391C;
	sub_829E2830(ctx, base);
	// 829E391C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E3920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3924: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3928: 4B8DC6D9  bl 0x822c0000
	ctx.lr = 0x829E392C;
	sub_822C0000(ctx, base);
	// 829E392C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E3930: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E3934: 487C4888  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3938 size=124
    let mut pc: u32 = 0x829E3938;
    'dispatch: loop {
        match pc {
            0x829E3938 => {
    //   block [0x829E3938..0x829E39B4)
	// 829E3938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E393C: 487C4831  bl 0x831a816c
	ctx.lr = 0x829E3940;
	sub_831A8130(ctx, base);
	// 829E3940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3944: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E3948: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E394C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3950: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 829E3954: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 829E3958: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 829E395C: 4840EA8D  bl 0x82df23e8
	ctx.lr = 0x829E3960;
	sub_82DF23E8(ctx, base);
	// 829E3960: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E3964: 4182001C  beq 0x829e3980
	if ctx.cr[0].eq {
	pc = 0x829E3980; continue 'dispatch;
	}
	// 829E3968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E396C: 48478FBD  bl 0x82e5c928
	ctx.lr = 0x829E3970;
	sub_82E5C928(ctx, base);
	// 829E3970: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3974: 396B5A30  addi r11, r11, 0x5a30
	ctx.r[11].s64 = ctx.r[11].s64 + 23088;
	// 829E3978: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E397C: 48000008  b 0x829e3984
	pc = 0x829E3984; continue 'dispatch;
	// 829E3980: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E3984: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E3988: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829E398C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3994: 4BFFEF65  bl 0x829e28f8
	ctx.lr = 0x829E3998;
	sub_829E28F8(ctx, base);
	// 829E3998: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E399C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E39A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E39A4: 4B8DC65D  bl 0x822c0000
	ctx.lr = 0x829E39A8;
	sub_822C0000(ctx, base);
	// 829E39A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E39AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E39B0: 487C480C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E39B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E39B8 size=96
    let mut pc: u32 = 0x829E39B8;
    'dispatch: loop {
        match pc {
            0x829E39B8 => {
    //   block [0x829E39B8..0x829E3A18)
	// 829E39B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E39BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E39C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E39C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E39C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E39CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E39D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E39D4: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 829E39D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E39DC: 419A0008  beq cr6, 0x829e39e4
	if ctx.cr[6].eq {
	pc = 0x829E39E4; continue 'dispatch;
	}
	// 829E39E0: 4B8DCEB1  bl 0x822c0890
	ctx.lr = 0x829E39E4;
	sub_822C0890(ctx, base);
	// 829E39E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E39E8: 48478BA1  bl 0x82e5c588
	ctx.lr = 0x829E39EC;
	sub_82E5C588(ctx, base);
	// 829E39EC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E39F0: 4182000C  beq 0x829e39fc
	if ctx.cr[0].eq {
	pc = 0x829E39FC; continue 'dispatch;
	}
	// 829E39F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E39F8: 4840E9E1  bl 0x82df23d8
	ctx.lr = 0x829E39FC;
	sub_82DF23D8(ctx, base);
	// 829E39FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3A00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E3A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E3A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E3A0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E3A10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E3A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E3A18 size=696
    let mut pc: u32 = 0x829E3A18;
    'dispatch: loop {
        match pc {
            0x829E3A18 => {
    //   block [0x829E3A18..0x829E3CD0)
	// 829E3A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3A1C: 487C473D  bl 0x831a8158
	ctx.lr = 0x829E3A20;
	sub_831A8130(ctx, base);
	// 829E3A20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3A24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3A28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3A2C: 3BCB5BEC  addi r30, r11, 0x5bec
	ctx.r[30].s64 = ctx.r[11].s64 + 23532;
	// 829E3A30: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 829E3A34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3A38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3A3C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 829E3A40: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 829E3A44: 4840FFC5  bl 0x82df3a08
	ctx.lr = 0x829E3A48;
	sub_82DF3A08(ctx, base);
	// 829E3A48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3A4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E3A50: 388B5BD8  addi r4, r11, 0x5bd8
	ctx.r[4].s64 = ctx.r[11].s64 + 23512;
	// 829E3A54: 4840FFB5  bl 0x82df3a08
	ctx.lr = 0x829E3A58;
	sub_82DF3A08(ctx, base);
	// 829E3A58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3A5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E3A60: 4840FFA9  bl 0x82df3a08
	ctx.lr = 0x829E3A64;
	sub_82DF3A08(ctx, base);
	// 829E3A64: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E3A68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829E3A6C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 829E3A70: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 829E3A74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E3A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3A7C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829E3A80: 4BB30061  bl 0x82513ae0
	ctx.lr = 0x829E3A84;
	sub_82513AE0(ctx, base);
	// 829E3A84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E3A88: 4840F9A1  bl 0x82df3428
	ctx.lr = 0x829E3A8C;
	sub_82DF3428(ctx, base);
	// 829E3A8C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E3A90: 4840F999  bl 0x82df3428
	ctx.lr = 0x829E3A94;
	sub_82DF3428(ctx, base);
	// 829E3A94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3A98: 4840F991  bl 0x82df3428
	ctx.lr = 0x829E3A9C;
	sub_82DF3428(ctx, base);
	// 829E3A9C: 387F0160  addi r3, r31, 0x160
	ctx.r[3].s64 = ctx.r[31].s64 + 352;
	// 829E3AA0: 48479E31  bl 0x82e5d8d0
	ctx.lr = 0x829E3AA4;
	sub_82E5D8D0(ctx, base);
	// 829E3AA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3AA8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E3AAC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E3AB0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829E3AB4: 396B5930  addi r11, r11, 0x5930
	ctx.r[11].s64 = ctx.r[11].s64 + 22832;
	// 829E3AB8: 394A5A7C  addi r10, r10, 0x5a7c
	ctx.r[10].s64 = ctx.r[10].s64 + 23164;
	// 829E3ABC: 39295A68  addi r9, r9, 0x5a68
	ctx.r[9].s64 = ctx.r[9].s64 + 23144;
	// 829E3AC0: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829E3AC4: 39085A58  addi r8, r8, 0x5a58
	ctx.r[8].s64 = ctx.r[8].s64 + 23128;
	// 829E3AC8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829E3ACC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E3AD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3AD4: 911F0160  stw r8, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[8].u32 ) };
	// 829E3AD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3ADC: 3B6B5B90  addi r27, r11, 0x5b90
	ctx.r[27].s64 = ctx.r[11].s64 + 23440;
	// 829E3AE0: 38A001A2  li r5, 0x1a2
	ctx.r[5].s64 = 418;
	// 829E3AE4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E3AE8: 38600138  li r3, 0x138
	ctx.r[3].s64 = 312;
	// 829E3AEC: 4B8DC8ED  bl 0x822c03d8
	ctx.lr = 0x829E3AF0;
	sub_822C03D8(ctx, base);
	// 829E3AF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E3AF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E3AF8: 41820024  beq 0x829e3b1c
	if ctx.cr[0].eq {
	pc = 0x829E3B1C; continue 'dispatch;
	}
	// 829E3AFC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829E3B00: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829E3B04: 93CA0000  stw r30, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E3B08: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E3B0C: 394A0068  addi r10, r10, 0x68
	ctx.r[10].s64 = ctx.r[10].s64 + 104;
	// 829E3B10: 4080FFF4  bge 0x829e3b04
	if !ctx.cr[0].lt {
	pc = 0x829E3B04; continue 'dispatch;
	}
	// 829E3B14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E3B18: 48000008  b 0x829e3b20
	pc = 0x829E3B20; continue 'dispatch;
	// 829E3B1C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 829E3B20: 93BF01F0  stw r29, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[29].u32 ) };
	// 829E3B24: 397F01F0  addi r11, r31, 0x1f0
	ctx.r[11].s64 = ctx.r[31].s64 + 496;
	// 829E3B28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E3B2C: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 829E3B30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E3B34: 4B9BEA9D  bl 0x823a25d0
	ctx.lr = 0x829E3B38;
	sub_823A25D0(ctx, base);
	// 829E3B38: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E3B3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E3B40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E3B44: 4B8DC4BD  bl 0x822c0000
	ctx.lr = 0x829E3B48;
	sub_822C0000(ctx, base);
	// 829E3B48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E3B4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829E3B50: 93DF0248  stw r30, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[30].u32 ) };
	// 829E3B54: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829E3B58: 93DF024C  stw r30, 0x24c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(588 as u32), ctx.r[30].u32 ) };
	// 829E3B5C: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 829E3B60: 93DF0250  stw r30, 0x250(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
	// 829E3B64: 93DF0254  stw r30, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[30].u32 ) };
	// 829E3B68: 3BBF0270  addi r29, r31, 0x270
	ctx.r[29].s64 = ctx.r[31].s64 + 624;
	// 829E3B6C: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E3B70: 911F0240  stw r8, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[8].u32 ) };
	// 829E3B74: C1AA9524  lfs f13, -0x6adc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E3B78: 3B9F0268  addi r28, r31, 0x268
	ctx.r[28].s64 = ctx.r[31].s64 + 616;
	// 829E3B7C: C189A9F0  lfs f12, -0x5610(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829E3B80: D01F0230  stfs f0, 0x230(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 829E3B84: D1BF0234  stfs f13, 0x234(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 829E3B88: D19F0238  stfs f12, 0x238(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 829E3B8C: D01F023C  stfs f0, 0x23c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 829E3B90: 93DF0258  stw r30, 0x258(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(600 as u32), ctx.r[30].u32 ) };
	// 829E3B94: 93DF025C  stw r30, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[30].u32 ) };
	// 829E3B98: 93DF0260  stw r30, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[30].u32 ) };
	// 829E3B9C: 93DF0264  stw r30, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
	// 829E3BA0: 93DF0268  stw r30, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[30].u32 ) };
	// 829E3BA4: 93DF026C  stw r30, 0x26c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(620 as u32), ctx.r[30].u32 ) };
	// 829E3BA8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3BAC: 917F0270  stw r11, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[11].u32 ) };
	// 829E3BB0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E3BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E3BB8: 917F0274  stw r11, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	// 829E3BBC: 419A0024  beq cr6, 0x829e3be0
	if ctx.cr[6].eq {
	pc = 0x829E3BE0; continue 'dispatch;
	}
	// 829E3BC0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E3BC4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E3BC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E3BCC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E3BD0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E3BD4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E3BD8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E3BDC: 4082FFE8  bne 0x829e3bc4
	if !ctx.cr[0].eq {
	pc = 0x829E3BC4; continue 'dispatch;
	}
	// 829E3BE0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E3BE4: 93DF0278  stw r30, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[30].u32 ) };
	// 829E3BE8: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829E3BEC: 93DF027C  stw r30, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[30].u32 ) };
	// 829E3BF0: 93DF0280  stw r30, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[30].u32 ) };
	// 829E3BF4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E3BF8: 93DF0284  stw r30, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[30].u32 ) };
	// 829E3BFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3C00: 38A001B5  li r5, 0x1b5
	ctx.r[5].s64 = 437;
	// 829E3C04: C00BFD2C  lfs f0, -0x2d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E3C08: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 829E3C0C: C1AA7BC4  lfs f13, 0x7bc4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E3C10: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 829E3C14: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 829E3C18: D1BF0200  stfs f13, 0x200(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 829E3C1C: 4B8DC7BD  bl 0x822c03d8
	ctx.lr = 0x829E3C20;
	sub_822C03D8(ctx, base);
	// 829E3C20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E3C24: 4182002C  beq 0x829e3c50
	if ctx.cr[0].eq {
	pc = 0x829E3C50; continue 'dispatch;
	}
	// 829E3C28: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E3C2C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829E3C30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829E3C34: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829E3C38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3C3C: C04B08A4  lfs f2, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 829E3C40: C02A9450  lfs f1, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E3C44: 4BA487C5  bl 0x8242c408
	ctx.lr = 0x829E3C48;
	sub_8242C408(ctx, base);
	// 829E3C48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E3C4C: 48000008  b 0x829e3c54
	pc = 0x829E3C54; continue 'dispatch;
	// 829E3C50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3C54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E3C58: 4BC08E89  bl 0x825ecae0
	ctx.lr = 0x829E3C5C;
	sub_825ECAE0(ctx, base);
	// 829E3C5C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829E3C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3C64: 4BB2FBDD  bl 0x82513840
	ctx.lr = 0x829E3C68;
	sub_82513840(ctx, base);
	// 829E3C68: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829E3C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3C70: 4BB2FC31  bl 0x825138a0
	ctx.lr = 0x829E3C74;
	sub_825138A0(ctx, base);
	// 829E3C74: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3C78: C0190004  lfs f0, 4(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E3C7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E3C80: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829E3C84: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3C88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829E3C8C: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 829E3C90: 4BFE4E51  bl 0x829c8ae0
	ctx.lr = 0x829E3C94;
	sub_829C8AE0(ctx, base);
	// 829E3C94: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829E3C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3C9C: 419A0008  beq cr6, 0x829e3ca4
	if ctx.cr[6].eq {
	pc = 0x829E3CA4; continue 'dispatch;
	}
	// 829E3CA0: 4BFE1829  bl 0x829c54c8
	ctx.lr = 0x829E3CA4;
	sub_829C54C8(ctx, base);
	// 829E3CA4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E3CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3CAC: 419A0008  beq cr6, 0x829e3cb4
	if ctx.cr[6].eq {
	pc = 0x829E3CB4; continue 'dispatch;
	}
	// 829E3CB0: 4B8DCBE1  bl 0x822c0890
	ctx.lr = 0x829E3CB4;
	sub_822C0890(ctx, base);
	// 829E3CB4: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E3CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3CBC: 419A0008  beq cr6, 0x829e3cc4
	if ctx.cr[6].eq {
	pc = 0x829E3CC4; continue 'dispatch;
	}
	// 829E3CC0: 4B8DCBD1  bl 0x822c0890
	ctx.lr = 0x829E3CC4;
	sub_822C0890(ctx, base);
	// 829E3CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3CC8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829E3CCC: 487C44DC  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3CD0 size=76
    let mut pc: u32 = 0x829E3CD0;
    'dispatch: loop {
        match pc {
            0x829E3CD0 => {
    //   block [0x829E3CD0..0x829E3D1C)
	// 829E3CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E3CD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E3CDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E3CE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3CE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E3CEC: 4BFFFA3D  bl 0x829e3728
	ctx.lr = 0x829E3CF0;
	sub_829E3728(ctx, base);
	// 829E3CF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E3CF4: 4182000C  beq 0x829e3d00
	if ctx.cr[0].eq {
	pc = 0x829E3D00; continue 'dispatch;
	}
	// 829E3CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3CFC: 4840E6DD  bl 0x82df23d8
	ctx.lr = 0x829E3D00;
	sub_82DF23D8(ctx, base);
	// 829E3D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E3D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E3D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E3D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E3D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E3D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E3D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E3D20 size=388
    let mut pc: u32 = 0x829E3D20;
    'dispatch: loop {
        match pc {
            0x829E3D20 => {
    //   block [0x829E3D20..0x829E3EA4)
	// 829E3D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3D24: 487C4445  bl 0x831a8168
	ctx.lr = 0x829E3D28;
	sub_831A8130(ctx, base);
	// 829E3D28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3D2C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829E3D30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E3D34: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E3D38: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829E3D3C: 4BB2DC9D  bl 0x825119d8
	ctx.lr = 0x829E3D40;
	sub_825119D8(ctx, base);
	// 829E3D40: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E3D44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E3D48: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E3D4C: 4840FCBD  bl 0x82df3a08
	ctx.lr = 0x829E3D50;
	sub_82DF3A08(ctx, base);
	// 829E3D50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E3D54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E3D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3D5C: 4BB24A25  bl 0x82508780
	ctx.lr = 0x829E3D60;
	sub_82508780(ctx, base);
	// 829E3D60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E3D64: 4840F6C5  bl 0x82df3428
	ctx.lr = 0x829E3D68;
	sub_82DF3428(ctx, base);
	// 829E3D68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E3D6C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829E3D70: 409A0008  bne cr6, 0x829e3d78
	if !ctx.cr[6].eq {
	pc = 0x829E3D78; continue 'dispatch;
	}
	// 829E3D74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E3D78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3D7C: 4BB24A25  bl 0x825087a0
	ctx.lr = 0x829E3D80;
	sub_825087A0(ctx, base);
	// 829E3D80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E3D84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3D88: 3BAB5B90  addi r29, r11, 0x5b90
	ctx.r[29].s64 = ctx.r[11].s64 + 23440;
	// 829E3D8C: 38A0045B  li r5, 0x45b
	ctx.r[5].s64 = 1115;
	// 829E3D90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E3D94: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E3D98: 4B8DC641  bl 0x822c03d8
	ctx.lr = 0x829E3D9C;
	sub_822C03D8(ctx, base);
	// 829E3D9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E3DA0: 41820014  beq 0x829e3db4
	if ctx.cr[0].eq {
	pc = 0x829E3DB4; continue 'dispatch;
	}
	// 829E3DA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E3DA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E3DAC: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 829E3DB0: 48000008  b 0x829e3db8
	pc = 0x829E3DB8; continue 'dispatch;
	// 829E3DB4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E3DB8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829E3DBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3DC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E3DC4: 4BFFE765  bl 0x829e2528
	ctx.lr = 0x829E3DC8;
	sub_829E2528(ctx, base);
	// 829E3DC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E3DCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3DD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E3DD4: 4B8DC22D  bl 0x822c0000
	ctx.lr = 0x829E3DD8;
	sub_822C0000(ctx, base);
	// 829E3DD8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E3DDC: 397F00E8  addi r11, r31, 0xe8
	ctx.r[11].s64 = ctx.r[31].s64 + 232;
	// 829E3DE0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829E3DE4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 829E3DE8: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 829E3DEC: 4B8E0675  bl 0x822c4460
	ctx.lr = 0x829E3DF0;
	sub_822C4460(ctx, base);
	// 829E3DF0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E3DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3DF8: 419A0008  beq cr6, 0x829e3e00
	if ctx.cr[6].eq {
	pc = 0x829E3E00; continue 'dispatch;
	}
	// 829E3DFC: 4B8DCA95  bl 0x822c0890
	ctx.lr = 0x829E3E00;
	sub_822C0890(ctx, base);
	// 829E3E00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E3E04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E3E08: 38A0045E  li r5, 0x45e
	ctx.r[5].s64 = 1118;
	// 829E3E0C: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 829E3E10: 4B8DC5C9  bl 0x822c03d8
	ctx.lr = 0x829E3E14;
	sub_822C03D8(ctx, base);
	// 829E3E14: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829E3E18: 41820028  beq 0x829e3e40
	if ctx.cr[0].eq {
	pc = 0x829E3E40; continue 'dispatch;
	}
	// 829E3E1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E3E20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3E24: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829E3E28: 4BB2B6F1  bl 0x8250f518
	ctx.lr = 0x829E3E2C;
	sub_8250F518(ctx, base);
	// 829E3E2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E3E30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E3E34: 4BAAD2BD  bl 0x824910f0
	ctx.lr = 0x829E3E38;
	sub_824910F0(ctx, base);
	// 829E3E38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E3E3C: 48000008  b 0x829e3e44
	pc = 0x829E3E44; continue 'dispatch;
	// 829E3E40: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E3E44: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829E3E48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3E4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E3E50: 4B924AE9  bl 0x82308938
	ctx.lr = 0x829E3E54;
	sub_82308938(ctx, base);
	// 829E3E54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E3E58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3E5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E3E60: 4B8DC1A1  bl 0x822c0000
	ctx.lr = 0x829E3E64;
	sub_822C0000(ctx, base);
	// 829E3E64: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E3E68: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 829E3E6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829E3E70: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 829E3E74: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 829E3E78: 4B8E05E9  bl 0x822c4460
	ctx.lr = 0x829E3E7C;
	sub_822C4460(ctx, base);
	// 829E3E7C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E3E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E3E84: 419A0008  beq cr6, 0x829e3e8c
	if ctx.cr[6].eq {
	pc = 0x829E3E8C; continue 'dispatch;
	}
	// 829E3E88: 4B8DCA09  bl 0x822c0890
	ctx.lr = 0x829E3E8C;
	sub_822C0890(ctx, base);
	// 829E3E8C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E3E90: 4182000C  beq 0x829e3e9c
	if ctx.cr[0].eq {
	pc = 0x829E3E9C; continue 'dispatch;
	}
	// 829E3E94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E3E98: 4840DDF9  bl 0x82df1c90
	ctx.lr = 0x829E3E9C;
	sub_82DF1C90(ctx, base);
	// 829E3E9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E3EA0: 487C4318  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E3EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E3EA8 size=968
    let mut pc: u32 = 0x829E3EA8;
    'dispatch: loop {
        match pc {
            0x829E3EA8 => {
    //   block [0x829E3EA8..0x829E4270)
	// 829E3EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E3EAC: 487C42AD  bl 0x831a8158
	ctx.lr = 0x829E3EB0;
	sub_831A8130(ctx, base);
	// 829E3EB0: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 829E3EB4: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E3EB8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 829E3EBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829E3EC0: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 829E3EC4: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 829E3EC8: 48770739  bl 0x83154600
	ctx.lr = 0x829E3ECC;
	sub_83154600(ctx, base);
	// 829E3ECC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E3ED0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E3ED4: 484758A5  bl 0x82e59778
	ctx.lr = 0x829E3ED8;
	sub_82E59778(ctx, base);
	// 829E3ED8: C01C0068  lfs f0, 0x68(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E3EDC: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 829E3EE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E3EE4: C19C0064  lfs f12, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829E3EE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E3EEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E3EF0: C00B093C  lfs f0, 0x93c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E3EF4: C3EA08A8  lfs f31, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829E3EF8: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 829E3EFC: D01C0064  stfs f0, 0x64(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829E3F00: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829E3F04: 4198008C  blt cr6, 0x829e3f90
	if ctx.cr[6].lt {
	pc = 0x829E3F90; continue 'dispatch;
	}
	// 829E3F08: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829E3F0C: 4BDD26CD  bl 0x827b65d8
	ctx.lr = 0x829E3F10;
	sub_827B65D8(ctx, base);
	// 829E3F10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E3F14: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829E3F18: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3F1C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E3F20: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E3F24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E3F28: 4E800421  bctrl
	ctx.lr = 0x829E3F2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E3F2C: 3BFC0080  addi r31, r28, 0x80
	ctx.r[31].s64 = ctx.r[28].s64 + 128;
	// 829E3F30: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829E3F34: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E3F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E4270 size=440
    let mut pc: u32 = 0x829E4270;
    'dispatch: loop {
        match pc {
            0x829E4270 => {
    //   block [0x829E4270..0x829E4428)
	// 829E4270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E4274: 487C3EED  bl 0x831a8160
	ctx.lr = 0x829E4278;
	sub_831A8130(ctx, base);
	// 829E4278: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E427C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E4280: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829E4284: 3BCB5B90  addi r30, r11, 0x5b90
	ctx.r[30].s64 = ctx.r[11].s64 + 23440;
	// 829E4288: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829E428C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4290: 38A0043E  li r5, 0x43e
	ctx.r[5].s64 = 1086;
	// 829E4294: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 829E4298: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E429C: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 829E42A0: 4840E149  bl 0x82df23e8
	ctx.lr = 0x829E42A4;
	sub_82DF23E8(ctx, base);
	// 829E42A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E42A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E42AC: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 829E42B0: 4182001C  beq 0x829e42cc
	if ctx.cr[0].eq {
	pc = 0x829E42CC; continue 'dispatch;
	}
	// 829E42B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E42B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E42BC: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 829E42C0: 4BFFF3E1  bl 0x829e36a0
	ctx.lr = 0x829E42C4;
	sub_829E36A0(ctx, base);
	// 829E42C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E42C8: 48000008  b 0x829e42d0
	pc = 0x829E42D0; continue 'dispatch;
	// 829E42CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E42D0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829E42D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E42D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E42DC: 4BFFE185  bl 0x829e2460
	ctx.lr = 0x829E42E0;
	sub_829E2460(ctx, base);
	// 829E42E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E42E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E42E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E42EC: 4B8DBD15  bl 0x822c0000
	ctx.lr = 0x829E42F0;
	sub_822C0000(ctx, base);
	// 829E42F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E42F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E42F8: 38A0043F  li r5, 0x43f
	ctx.r[5].s64 = 1087;
	// 829E42FC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829E4300: 4B8DC0D9  bl 0x822c03d8
	ctx.lr = 0x829E4304;
	sub_822C03D8(ctx, base);
	// 829E4304: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E4308: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E430C: 418200B0  beq 0x829e43bc
	if ctx.cr[0].eq {
	pc = 0x829E43BC; continue 'dispatch;
	}
	// 829E4310: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E4314: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 829E4318: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E431C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 829E4320: 409A0008  bne cr6, 0x829e4328
	if !ctx.cr[6].eq {
	pc = 0x829E4328; continue 'dispatch;
	}
	// 829E4324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E4328: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E432C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E4330: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 829E4334: 419A0024  beq cr6, 0x829e4358
	if ctx.cr[6].eq {
	pc = 0x829E4358; continue 'dispatch;
	}
	// 829E4338: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 829E433C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 829E4340: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4344: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 829E4348: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829E434C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E4350: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4354: 4082FFE8  bne 0x829e433c
	if !ctx.cr[0].eq {
	pc = 0x829E433C; continue 'dispatch;
	}
	// 829E4358: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829E435C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E4360: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 829E4364: 419A0024  beq cr6, 0x829e4388
	if ctx.cr[6].eq {
	pc = 0x829E4388; continue 'dispatch;
	}
	// 829E4368: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 829E436C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E4370: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4374: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E4378: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E437C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E4380: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4384: 4082FFE8  bne 0x829e436c
	if !ctx.cr[0].eq {
	pc = 0x829E436C; continue 'dispatch;
	}
	// 829E4388: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E438C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E4390: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 829E4394: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E4398: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E439C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E43A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E43A4: 4BDB4B8D  bl 0x82798f30
	ctx.lr = 0x829E43A8;
	sub_82798F30(ctx, base);
	// 829E43A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E43AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E43B0: 4BDB72B9  bl 0x8279b668
	ctx.lr = 0x829E43B4;
	sub_8279B668(ctx, base);
	// 829E43B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E43B8: 48000008  b 0x829e43c0
	pc = 0x829E43C0; continue 'dispatch;
	// 829E43BC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E43C0: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E43C4: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 829E43C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E43CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E43D0: 4BBB3881  bl 0x82597c50
	ctx.lr = 0x829E43D4;
	sub_82597C50(ctx, base);
	// 829E43D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E43D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E43DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E43E0: 4B8DBC21  bl 0x822c0000
	ctx.lr = 0x829E43E4;
	sub_822C0000(ctx, base);
	// 829E43E4: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E43E8: 41820024  beq 0x829e440c
	if ctx.cr[0].eq {
	pc = 0x829E440C; continue 'dispatch;
	}
	// 829E43EC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E43F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E43F4: 419A0008  beq cr6, 0x829e43fc
	if ctx.cr[6].eq {
	pc = 0x829E43FC; continue 'dispatch;
	}
	// 829E43F8: 4B8DC499  bl 0x822c0890
	ctx.lr = 0x829E43FC;
	sub_822C0890(ctx, base);
	// 829E43FC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829E4400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4404: 419A0008  beq cr6, 0x829e440c
	if ctx.cr[6].eq {
	pc = 0x829E440C; continue 'dispatch;
	}
	// 829E4408: 4B8DC489  bl 0x822c0890
	ctx.lr = 0x829E440C;
	sub_822C0890(ctx, base);
	// 829E440C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E4410: 419A000C  beq cr6, 0x829e441c
	if ctx.cr[6].eq {
	pc = 0x829E441C; continue 'dispatch;
	}
	// 829E4414: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E4418: 4B8DC479  bl 0x822c0890
	ctx.lr = 0x829E441C;
	sub_822C0890(ctx, base);
	// 829E441C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829E4420: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 829E4424: 487C3D8C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E4428 size=92
    let mut pc: u32 = 0x829E4428;
    'dispatch: loop {
        match pc {
            0x829E4428 => {
    //   block [0x829E4428..0x829E4484)
	// 829E4428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E442C: 487C3D41  bl 0x831a816c
	ctx.lr = 0x829E4430;
	sub_831A8130(ctx, base);
	// 829E4430: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E4434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E4438: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 829E443C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829E4440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E4444: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E4448: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E444C: 388A37B0  addi r4, r10, 0x37b0
	ctx.r[4].s64 = ctx.r[10].s64 + 14256;
	// 829E4450: 4B97B621  bl 0x8235fa70
	ctx.lr = 0x829E4454;
	sub_8235FA70(ctx, base);
	// 829E4454: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E445C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829E4460: 4840F7A1  bl 0x82df3c00
	ctx.lr = 0x829E4464;
	sub_82DF3C00(ctx, base);
	// 829E4464: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4468: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E446C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E4470: 48477CE9  bl 0x82e5c158
	ctx.lr = 0x829E4474;
	sub_82E5C158(ctx, base);
	// 829E4474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4478: 4840EFB1  bl 0x82df3428
	ctx.lr = 0x829E447C;
	sub_82DF3428(ctx, base);
	// 829E447C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E4480: 487C3D3C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E4488 size=92
    let mut pc: u32 = 0x829E4488;
    'dispatch: loop {
        match pc {
            0x829E4488 => {
    //   block [0x829E4488..0x829E44E4)
	// 829E4488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E448C: 487C3CE1  bl 0x831a816c
	ctx.lr = 0x829E4490;
	sub_831A8130(ctx, base);
	// 829E4490: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E4494: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E4498: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 829E449C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829E44A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E44A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E44A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E44AC: 388A3830  addi r4, r10, 0x3830
	ctx.r[4].s64 = ctx.r[10].s64 + 14384;
	// 829E44B0: 4B97B5C1  bl 0x8235fa70
	ctx.lr = 0x829E44B4;
	sub_8235FA70(ctx, base);
	// 829E44B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E44B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E44BC: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829E44C0: 4840F741  bl 0x82df3c00
	ctx.lr = 0x829E44C4;
	sub_82DF3C00(ctx, base);
	// 829E44C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E44C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E44CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E44D0: 48477C89  bl 0x82e5c158
	ctx.lr = 0x829E44D4;
	sub_82E5C158(ctx, base);
	// 829E44D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E44D8: 4840EF51  bl 0x82df3428
	ctx.lr = 0x829E44DC;
	sub_82DF3428(ctx, base);
	// 829E44DC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E44E0: 487C3CDC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E44E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E44E8 size=92
    let mut pc: u32 = 0x829E44E8;
    'dispatch: loop {
        match pc {
            0x829E44E8 => {
    //   block [0x829E44E8..0x829E4544)
	// 829E44E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E44EC: 487C3C81  bl 0x831a816c
	ctx.lr = 0x829E44F0;
	sub_831A8130(ctx, base);
	// 829E44F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E44F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E44F8: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 829E44FC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829E4500: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E4504: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E4508: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E450C: 388A38B0  addi r4, r10, 0x38b0
	ctx.r[4].s64 = ctx.r[10].s64 + 14512;
	// 829E4510: 4B97B561  bl 0x8235fa70
	ctx.lr = 0x829E4514;
	sub_8235FA70(ctx, base);
	// 829E4514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E451C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829E4520: 4840F6E1  bl 0x82df3c00
	ctx.lr = 0x829E4524;
	sub_82DF3C00(ctx, base);
	// 829E4524: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E452C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E4530: 48477C29  bl 0x82e5c158
	ctx.lr = 0x829E4534;
	sub_82E5C158(ctx, base);
	// 829E4534: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4538: 4840EEF1  bl 0x82df3428
	ctx.lr = 0x829E453C;
	sub_82DF3428(ctx, base);
	// 829E453C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E4540: 487C3C7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E4548 size=92
    let mut pc: u32 = 0x829E4548;
    'dispatch: loop {
        match pc {
            0x829E4548 => {
    //   block [0x829E4548..0x829E45A4)
	// 829E4548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E454C: 487C3C21  bl 0x831a816c
	ctx.lr = 0x829E4550;
	sub_831A8130(ctx, base);
	// 829E4550: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E4554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E4558: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 829E455C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829E4560: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E4564: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E4568: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E456C: 388A3938  addi r4, r10, 0x3938
	ctx.r[4].s64 = ctx.r[10].s64 + 14648;
	// 829E4570: 4B97B501  bl 0x8235fa70
	ctx.lr = 0x829E4574;
	sub_8235FA70(ctx, base);
	// 829E4574: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E457C: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 829E4580: 4840F681  bl 0x82df3c00
	ctx.lr = 0x829E4584;
	sub_82DF3C00(ctx, base);
	// 829E4584: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E458C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E4590: 48477BC9  bl 0x82e5c158
	ctx.lr = 0x829E4594;
	sub_82E5C158(ctx, base);
	// 829E4594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4598: 4840EE91  bl 0x82df3428
	ctx.lr = 0x829E459C;
	sub_82DF3428(ctx, base);
	// 829E459C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E45A0: 487C3C1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E45A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E45A8 size=248
    let mut pc: u32 = 0x829E45A8;
    'dispatch: loop {
        match pc {
            0x829E45A8 => {
    //   block [0x829E45A8..0x829E46A0)
	// 829E45A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E45AC: 487C3BBD  bl 0x831a8168
	ctx.lr = 0x829E45B0;
	sub_831A8130(ctx, base);
	// 829E45B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E45B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E45B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E45BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E45C0: 48623B69  bl 0x83008128
	ctx.lr = 0x829E45C4;
	sub_83008128(ctx, base);
	// 829E45C4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829E45C8: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 829E45CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E45D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E45D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E45D8: 4B98FB39  bl 0x82374110
	ctx.lr = 0x829E45DC;
	sub_82374110(ctx, base);
	// 829E45DC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829E45E0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E45E4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E45E8: 409A00B0  bne cr6, 0x829e4698
	if !ctx.cr[6].eq {
	pc = 0x829E4698; continue 'dispatch;
	}
	// 829E45EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E45F0: 4BFE59B1  bl 0x829c9fa0
	ctx.lr = 0x829E45F4;
	sub_829C9FA0(ctx, base);
	// 829E45F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E45F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 829E45FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E4600: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E4604: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829E4608: 419A0024  beq cr6, 0x829e462c
	if ctx.cr[6].eq {
	pc = 0x829E462C; continue 'dispatch;
	}
	// 829E460C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E4610: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E4614: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4618: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E461C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E4620: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E4624: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4628: 4082FFE8  bne 0x829e4610
	if !ctx.cr[0].eq {
	pc = 0x829E4610; continue 'dispatch;
	}
	// 829E462C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4630: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 829E4634: 48623AF5  bl 0x83008128
	ctx.lr = 0x829E4638;
	sub_83008128(ctx, base);
	// 829E4638: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E463C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E4640: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829E4644: 388A5B90  addi r4, r10, 0x5b90
	ctx.r[4].s64 = ctx.r[10].s64 + 23440;
	// 829E4648: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 829E464C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829E4650: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E4654: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829E4658: 484743E9  bl 0x82e58a40
	ctx.lr = 0x829E465C;
	sub_82E58A40(ctx, base);
	// 829E465C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E4660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4664: 419A0008  beq cr6, 0x829e466c
	if ctx.cr[6].eq {
	pc = 0x829E466C; continue 'dispatch;
	}
	// 829E4668: 4B8DC229  bl 0x822c0890
	ctx.lr = 0x829E466C;
	sub_822C0890(ctx, base);
	// 829E466C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829E4670: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4674: 419A0008  beq cr6, 0x829e467c
	if ctx.cr[6].eq {
	pc = 0x829E467C; continue 'dispatch;
	}
	// 829E4678: 4B8DC219  bl 0x822c0890
	ctx.lr = 0x829E467C;
	sub_822C0890(ctx, base);
	// 829E467C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4680: 48623AA9  bl 0x83008128
	ctx.lr = 0x829E4684;
	sub_83008128(ctx, base);
	// 829E4684: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829E4688: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E468C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E4690: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E4694: 4BB6C2C5  bl 0x82550958
	ctx.lr = 0x829E4698;
	sub_82550958(ctx, base);
	// 829E4698: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E469C: 487C3B1C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E46A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E46A0 size=108
    let mut pc: u32 = 0x829E46A0;
    'dispatch: loop {
        match pc {
            0x829E46A0 => {
    //   block [0x829E46A0..0x829E470C)
	// 829E46A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E46A4: 487C3AC9  bl 0x831a816c
	ctx.lr = 0x829E46A8;
	sub_831A8130(ctx, base);
	// 829E46A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E46AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E46B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E46B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E46B8: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E46BC: 41820038  beq 0x829e46f4
	if ctx.cr[0].eq {
	pc = 0x829E46F4; continue 'dispatch;
	}
	// 829E46C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E46C4: 487C52C5  bl 0x831a9988
	ctx.lr = 0x829E46C8;
	sub_831A9988(ctx, base);
	// 829E46C8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E46CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E46D0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829E46D4: 487C3A25  bl 0x831a80f8
	ctx.lr = 0x829E46D8;
	sub_831A80F8(ctx, base);
	// 829E46D8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E46DC: 41820018  beq 0x829e46f4
	if ctx.cr[0].eq {
	pc = 0x829E46F4; continue 'dispatch;
	}
	// 829E46E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E46E4: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 829E46E8: 4BFFFEC1  bl 0x829e45a8
	ctx.lr = 0x829E46EC;
	sub_829E45A8(ctx, base);
	// 829E46EC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E46F0: 48000014  b 0x829e4704
	pc = 0x829E4704; continue 'dispatch;
	// 829E46F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E46F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E46FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E4700: 4BB2DF19  bl 0x82512618
	ctx.lr = 0x829E4704;
	sub_82512618(ctx, base);
	// 829E4704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E4708: 487C3AB4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E4710 size=600
    let mut pc: u32 = 0x829E4710;
    'dispatch: loop {
        match pc {
            0x829E4710 => {
    //   block [0x829E4710..0x829E4968)
	// 829E4710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E4714: 487C3A55  bl 0x831a8168
	ctx.lr = 0x829E4718;
	sub_831A8130(ctx, base);
	// 829E4718: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E471C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E4720: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E4724: 4BB2D2B5  bl 0x825119d8
	ctx.lr = 0x829E4728;
	sub_825119D8(ctx, base);
	// 829E4728: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E472C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4730: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E4734: 4840F2D5  bl 0x82df3a08
	ctx.lr = 0x829E4738;
	sub_82DF3A08(ctx, base);
	// 829E4738: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E473C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E4740: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E4744: 4BB2403D  bl 0x82508780
	ctx.lr = 0x829E4748;
	sub_82508780(ctx, base);
	// 829E4748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E474C: 4840ECDD  bl 0x82df3428
	ctx.lr = 0x829E4750;
	sub_82DF3428(ctx, base);
	// 829E4750: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E4754: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829E4758: 409A0008  bne cr6, 0x829e4760
	if !ctx.cr[6].eq {
	pc = 0x829E4760; continue 'dispatch;
	}
	// 829E475C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E4760: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E4764: 4BB2403D  bl 0x825087a0
	ctx.lr = 0x829E4768;
	sub_825087A0(ctx, base);
	// 829E4768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E476C: 4BB2E32D  bl 0x82512a98
	ctx.lr = 0x829E4770;
	sub_82512A98(ctx, base);
	// 829E4770: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4774: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 829E4778: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829E477C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 829E4780: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829E4784: 484BBFAD  bl 0x82ea0730
	ctx.lr = 0x829E4788;
	sub_82EA0730(ctx, base);
	// 829E4788: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 829E478C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829E4790: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 829E4794: C02AA1C4  lfs f1, -0x5e3c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E4798: 48535A59  bl 0x82f1a1f0
	ctx.lr = 0x829E479C;
	sub_82F1A1F0(ctx, base);
	// 829E479C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829E47A0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 829E47A4: 4182000C  beq 0x829e47b0
	if ctx.cr[0].eq {
	pc = 0x829E47B0; continue 'dispatch;
	}
	// 829E47A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E47AC: 4B903A9D  bl 0x822e8248
	ctx.lr = 0x829E47B0;
	sub_822E8248(ctx, base);
	// 829E47B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E47B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E47B8: 388B5C18  addi r4, r11, 0x5c18
	ctx.r[4].s64 = ctx.r[11].s64 + 23576;
	// 829E47BC: 48414D75  bl 0x82df9530
	ctx.lr = 0x829E47C0;
	sub_82DF9530(ctx, base);
	// 829E47C0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E47C4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829E47C8: 808B67D4  lwz r4, 0x67d4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 829E47CC: 4B900765  bl 0x822e4f30
	ctx.lr = 0x829E47D0;
	sub_822E4F30(ctx, base);
	// 829E47D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829E47D4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829E47D8: 4B9006E9  bl 0x822e4ec0
	ctx.lr = 0x829E47DC;
	sub_822E4EC0(ctx, base);
	// 829E47DC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829E47E0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E47E4: E8BC0000  ld r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 829E47E8: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829E47EC: 806B6734  lwz r3, 0x6734(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 829E47F0: 4BAA7B81  bl 0x8248c370
	ctx.lr = 0x829E47F4;
	sub_8248C370(ctx, base);
	// 829E47F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829E47F8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 829E47FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E4800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E4804: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829E4808: 4BB2E849  bl 0x82513050
	ctx.lr = 0x829E480C;
	sub_82513050(ctx, base);
	// 829E480C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E4810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4814: 419A0008  beq cr6, 0x829e481c
	if ctx.cr[6].eq {
	pc = 0x829E481C; continue 'dispatch;
	}
	// 829E4818: 4B903A51  bl 0x822e8268
	ctx.lr = 0x829E481C;
	sub_822E8268(ctx, base);
	// 829E481C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E4820: 419A000C  beq cr6, 0x829e482c
	if ctx.cr[6].eq {
	pc = 0x829E482C; continue 'dispatch;
	}
	// 829E4824: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4828: 4B903A41  bl 0x822e8268
	ctx.lr = 0x829E482C;
	sub_822E8268(ctx, base);
	// 829E482C: 3D608205  lis r11, -0x7dfb
	ctx.r[11].s64 = -2113601536;
	// 829E4830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4834: 388B54AC  addi r4, r11, 0x54ac
	ctx.r[4].s64 = ctx.r[11].s64 + 21676;
	// 829E4838: 4840F1D1  bl 0x82df3a08
	ctx.lr = 0x829E483C;
	sub_82DF3A08(ctx, base);
	// 829E483C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E4840: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E4844: 4BB2610D  bl 0x8250a950
	ctx.lr = 0x829E4848;
	sub_8250A950(ctx, base);
	// 829E4848: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E484C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E4850: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 829E4854: 409A0008  bne cr6, 0x829e485c
	if !ctx.cr[6].eq {
	pc = 0x829E485C; continue 'dispatch;
	}
	// 829E4858: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E485C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4860: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E4864: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 829E4868: 4BB2D8B1  bl 0x82512118
	ctx.lr = 0x829E486C;
	sub_82512118(ctx, base);
	// 829E486C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829E4870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4874: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E4878: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E487C: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 829E4880: 4BDF0431  bl 0x827d4cb0
	ctx.lr = 0x829E4884;
	sub_827D4CB0(ctx, base);
	// 829E4884: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E4888: 395F00F4  addi r10, r31, 0xf4
	ctx.r[10].s64 = ctx.r[31].s64 + 244;
	// 829E488C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829E4890: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 829E4894: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4898: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 829E489C: 4B8DFBC5  bl 0x822c4460
	ctx.lr = 0x829E48A0;
	sub_822C4460(ctx, base);
	// 829E48A0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E48A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E48A8: 419A0008  beq cr6, 0x829e48b0
	if ctx.cr[6].eq {
	pc = 0x829E48B0; continue 'dispatch;
	}
	// 829E48AC: 4B8DBFE5  bl 0x822c0890
	ctx.lr = 0x829E48B0;
	sub_822C0890(ctx, base);
	// 829E48B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E48B4: 4840D3DD  bl 0x82df1c90
	ctx.lr = 0x829E48B8;
	sub_82DF1C90(ctx, base);
	// 829E48B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829E48BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E48C0: 419A0008  beq cr6, 0x829e48c8
	if ctx.cr[6].eq {
	pc = 0x829E48C8; continue 'dispatch;
	}
	// 829E48C4: 4B8DBFCD  bl 0x822c0890
	ctx.lr = 0x829E48C8;
	sub_822C0890(ctx, base);
	// 829E48C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E48CC: 4840EB5D  bl 0x82df3428
	ctx.lr = 0x829E48D0;
	sub_82DF3428(ctx, base);
	// 829E48D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E48D4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E48D8: 4BB2ABF1  bl 0x8250f4c8
	ctx.lr = 0x829E48DC;
	sub_8250F4C8(ctx, base);
	// 829E48DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E48E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E48E4: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829E48E8: 409A0008  bne cr6, 0x829e48f0
	if !ctx.cr[6].eq {
	pc = 0x829E48F0; continue 'dispatch;
	}
	// 829E48EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E48F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829E48F4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829E48F8: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829E48FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E4900: 481625A1  bl 0x82b46ea0
	ctx.lr = 0x829E4904;
	sub_82B46EA0(ctx, base);
	// 829E4904: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E4908: 4840D389  bl 0x82df1c90
	ctx.lr = 0x829E490C;
	sub_82DF1C90(ctx, base);
	// 829E490C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E4910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E4914: 419A003C  beq cr6, 0x829e4950
	if ctx.cr[6].eq {
	pc = 0x829E4950; continue 'dispatch;
	}
	// 829E4918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E491C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829E4920: 4BB2D1C9  bl 0x82511ae8
	ctx.lr = 0x829E4924;
	sub_82511AE8(ctx, base);
	// 829E4924: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E492C: 4816227D  bl 0x82b46ba8
	ctx.lr = 0x829E4930;
	sub_82B46BA8(ctx, base);
	// 829E4930: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E4934: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E4938: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E493C: 388B5C04  addi r4, r11, 0x5c04
	ctx.r[4].s64 = ctx.r[11].s64 + 23556;
	// 829E4940: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E4948: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E494C: 4E800421  bctrl
	ctx.lr = 0x829E4950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E4950: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E4954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4958: 419A0008  beq cr6, 0x829e4960
	if ctx.cr[6].eq {
	pc = 0x829E4960; continue 'dispatch;
	}
	// 829E495C: 4B8DBF35  bl 0x822c0890
	ctx.lr = 0x829E4960;
	sub_822C0890(ctx, base);
	// 829E4960: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829E4964: 487C3854  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E4968 size=1584
    let mut pc: u32 = 0x829E4968;
    'dispatch: loop {
        match pc {
            0x829E4968 => {
    //   block [0x829E4968..0x829E4F98)
	// 829E4968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E496C: 487C37E9  bl 0x831a8154
	ctx.lr = 0x829E4970;
	sub_831A8130(ctx, base);
	// 829E4970: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 829E4974: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E4978: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 829E497C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E4980: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 829E4984: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 829E4988: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829E498C: 4BB2F8E5  bl 0x82514270
	ctx.lr = 0x829E4990;
	sub_82514270(ctx, base);
	// 829E4990: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E4994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E4998: 4BB2A9D9  bl 0x8250f370
	ctx.lr = 0x829E499C;
	sub_8250F370(ctx, base);
	// 829E499C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E49A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E49A4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E49A8: 4840F061  bl 0x82df3a08
	ctx.lr = 0x829E49AC;
	sub_82DF3A08(ctx, base);
	// 829E49AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E49B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E49B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E49B8: 4BB23DC9  bl 0x82508780
	ctx.lr = 0x829E49BC;
	sub_82508780(ctx, base);
	// 829E49BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E49C0: 4840EA69  bl 0x82df3428
	ctx.lr = 0x829E49C4;
	sub_82DF3428(ctx, base);
	// 829E49C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E49C8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829E49CC: 409A0008  bne cr6, 0x829e49d4
	if !ctx.cr[6].eq {
	pc = 0x829E49D4; continue 'dispatch;
	}
	// 829E49D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E49D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829E49D8: 4BB23DC9  bl 0x825087a0
	ctx.lr = 0x829E49DC;
	sub_825087A0(ctx, base);
	// 829E49DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E49E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E49E4: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 829E49E8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829E49EC: 4BDD1BED  bl 0x827b65d8
	ctx.lr = 0x829E49F0;
	sub_827B65D8(ctx, base);
	// 829E49F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E49F4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E49F8: 808B666C  lwz r4, 0x666c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26220 as u32) ) } as u64;
	// 829E49FC: 4BAAA9A5  bl 0x8248f3a0
	ctx.lr = 0x829E4A00;
	sub_8248F3A0(ctx, base);
	// 829E4A00: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829E4A04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4A08: 419A0008  beq cr6, 0x829e4a10
	if ctx.cr[6].eq {
	pc = 0x829E4A10; continue 'dispatch;
	}
	// 829E4A0C: 4B8DBE85  bl 0x822c0890
	ctx.lr = 0x829E4A10;
	sub_822C0890(ctx, base);
	// 829E4A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4A14: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829E4A18: 4BDD1BC1  bl 0x827b65d8
	ctx.lr = 0x829E4A1C;
	sub_827B65D8(ctx, base);
	// 829E4A1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4A20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E4A24: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E4A28: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E4A2C: 419A000C  beq cr6, 0x829e4a38
	if ctx.cr[6].eq {
	pc = 0x829E4A38; continue 'dispatch;
	}
	// 829E4A30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4A34: 484E9DCD  bl 0x82ece800
	ctx.lr = 0x829E4A38;
	sub_82ECE800(ctx, base);
	// 829E4A38: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E4A3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4A40: 419A0008  beq cr6, 0x829e4a48
	if ctx.cr[6].eq {
	pc = 0x829E4A48; continue 'dispatch;
	}
	// 829E4A44: 4B8DBE4D  bl 0x822c0890
	ctx.lr = 0x829E4A48;
	sub_822C0890(ctx, base);
	// 829E4A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4A4C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829E4A50: 4BDD1B89  bl 0x827b65d8
	ctx.lr = 0x829E4A54;
	sub_827B65D8(ctx, base);
	// 829E4A54: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4A58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E4A5C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E4A60: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E4A64: 484E6A8D  bl 0x82ecb4f0
	ctx.lr = 0x829E4A68;
	sub_82ECB4F0(ctx, base);
	// 829E4A68: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829E4A6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4A70: 419A0008  beq cr6, 0x829e4a78
	if ctx.cr[6].eq {
	pc = 0x829E4A78; continue 'dispatch;
	}
	// 829E4A74: 4B8DBE1D  bl 0x822c0890
	ctx.lr = 0x829E4A78;
	sub_822C0890(ctx, base);
	// 829E4A78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4A7C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829E4A80: 4BDD1B59  bl 0x827b65d8
	ctx.lr = 0x829E4A84;
	sub_827B65D8(ctx, base);
	// 829E4A84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4A88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4A8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E4A90: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 829E4A94: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E4A98: 484E70F9  bl 0x82ecbb90
	ctx.lr = 0x829E4A9C;
	sub_82ECBB90(ctx, base);
	// 829E4A9C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 829E4AA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4AA4: 419A0008  beq cr6, 0x829e4aac
	if ctx.cr[6].eq {
	pc = 0x829E4AAC; continue 'dispatch;
	}
	// 829E4AA8: 4B8DBDE9  bl 0x822c0890
	ctx.lr = 0x829E4AAC;
	sub_822C0890(ctx, base);
	// 829E4AAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E4AB0: 419A000C  beq cr6, 0x829e4abc
	if ctx.cr[6].eq {
	pc = 0x829E4ABC; continue 'dispatch;
	}
	// 829E4AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4AB8: 484E8551  bl 0x82ecd008
	ctx.lr = 0x829E4ABC;
	sub_82ECD008(ctx, base);
	// 829E4ABC: 817F0160  lwz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829E4AC0: 3BDF0160  addi r30, r31, 0x160
	ctx.r[30].s64 = ctx.r[31].s64 + 352;
	// 829E4AC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4AC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4ACC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E4AD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E4AD4: 4E800421  bctrl
	ctx.lr = 0x829E4AD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E4AD8: 3D608206  lis r11, -0x7dfa
	ctx.r[11].s64 = -2113536000;
	// 829E4ADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4AE0: 3BABF9A0  addi r29, r11, -0x660
	ctx.r[29].s64 = ctx.r[11].s64 + -1632;
	// 829E4AE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E4AE8: 4840EF21  bl 0x82df3a08
	ctx.lr = 0x829E4AEC;
	sub_82DF3A08(ctx, base);
	// 829E4AEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4AF4: 4BFFF935  bl 0x829e4428
	ctx.lr = 0x829E4AF8;
	sub_829E4428(ctx, base);
	// 829E4AF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E4AFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4B00: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 829E4B04: 4840EF05  bl 0x82df3a08
	ctx.lr = 0x829E4B08;
	sub_82DF3A08(ctx, base);
	// 829E4B08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4B10: 4BFFF979  bl 0x829e4488
	ctx.lr = 0x829E4B14;
	sub_829E4488(ctx, base);
	// 829E4B14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E4B18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4B1C: 388B039C  addi r4, r11, 0x39c
	ctx.r[4].s64 = ctx.r[11].s64 + 924;
	// 829E4B20: 4840EEE9  bl 0x82df3a08
	ctx.lr = 0x829E4B24;
	sub_82DF3A08(ctx, base);
	// 829E4B24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4B2C: 4BFFF9BD  bl 0x829e44e8
	ctx.lr = 0x829E4B30;
	sub_829E44E8(ctx, base);
	// 829E4B30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829E4B34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4B38: 388B03A4  addi r4, r11, 0x3a4
	ctx.r[4].s64 = ctx.r[11].s64 + 932;
	// 829E4B3C: 4840EECD  bl 0x82df3a08
	ctx.lr = 0x829E4B40;
	sub_82DF3A08(ctx, base);
	// 829E4B40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4B44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4B48: 4BFFFA01  bl 0x829e4548
	ctx.lr = 0x829E4B4C;
	sub_829E4548(ctx, base);
	// 829E4B4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E4B50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4B54: 4840EEB5  bl 0x82df3a08
	ctx.lr = 0x829E4B58;
	sub_82DF3A08(ctx, base);
	// 829E4B58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E4B5C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829E4B60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4B64: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829E4B68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4B6C: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829E4B70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829E4B74: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829E4B78: 48479DE9  bl 0x82e5e960
	ctx.lr = 0x829E4B7C;
	sub_82E5E960(ctx, base);
	// 829E4B7C: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829E4B80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4B84: 419A0008  beq cr6, 0x829e4b8c
	if ctx.cr[6].eq {
	pc = 0x829E4B8C; continue 'dispatch;
	}
	// 829E4B88: 4B8DBD09  bl 0x822c0890
	ctx.lr = 0x829E4B8C;
	sub_822C0890(ctx, base);
	// 829E4B8C: D3E10080  stfs f31, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829E4B90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E4B94: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829E4B98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4B9C: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829E4BA0: 3B0B5B90  addi r24, r11, 0x5b90
	ctx.r[24].s64 = ctx.r[11].s64 + 23440;
	// 829E4BA4: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829E4BA8: 38A00203  li r5, 0x203
	ctx.r[5].s64 = 515;
	// 829E4BAC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829E4BB0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 829E4BB4: 4840D835  bl 0x82df23e8
	ctx.lr = 0x829E4BB8;
	sub_82DF23E8(ctx, base);
	// 829E4BB8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E4BBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E4BC0: 3B4BBA80  addi r26, r11, -0x4580
	ctx.r[26].s64 = ctx.r[11].s64 + -17792;
	// 829E4BC4: 41820018  beq 0x829e4bdc
	if ctx.cr[0].eq {
	pc = 0x829E4BDC; continue 'dispatch;
	}
	// 829E4BC8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 829E4BCC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829E4BD0: 4BBA6151  bl 0x8258ad20
	ctx.lr = 0x829E4BD4;
	sub_8258AD20(ctx, base);
	// 829E4BD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E4BD8: 48000008  b 0x829e4be0
	pc = 0x829E4BE0; continue 'dispatch;
	// 829E4BDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E4BE0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 829E4BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4BE8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829E4BEC: 4B921DA5  bl 0x82306990
	ctx.lr = 0x829E4BF0;
	sub_82306990(ctx, base);
	// 829E4BF0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E4BF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E4BF8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829E4BFC: 4B8DB405  bl 0x822c0000
	ctx.lr = 0x829E4C00;
	sub_822C0000(ctx, base);
	// 829E4C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4C04: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829E4C08: 4BDD19D1  bl 0x827b65d8
	ctx.lr = 0x829E4C0C;
	sub_827B65D8(ctx, base);
	// 829E4C0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E4C10: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829E4C14: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4C18: 4B908F01  bl 0x822edb18
	ctx.lr = 0x829E4C1C;
	sub_822EDB18(ctx, base);
	// 829E4C1C: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829E4C20: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4C24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E4C28: 4842E209  bl 0x82e12e30
	ctx.lr = 0x829E4C2C;
	sub_82E12E30(ctx, base);
	// 829E4C2C: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829E4C30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4C34: 419A0008  beq cr6, 0x829e4c3c
	if ctx.cr[6].eq {
	pc = 0x829E4C3C; continue 'dispatch;
	}
	// 829E4C38: 4B8DBC59  bl 0x822c0890
	ctx.lr = 0x829E4C3C;
	sub_822C0890(ctx, base);
	// 829E4C3C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829E4C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4C44: 419A0008  beq cr6, 0x829e4c4c
	if ctx.cr[6].eq {
	pc = 0x829E4C4C; continue 'dispatch;
	}
	// 829E4C48: 4B8DBC49  bl 0x822c0890
	ctx.lr = 0x829E4C4C;
	sub_822C0890(ctx, base);
	// 829E4C4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E4C50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4C54: 388B5C38  addi r4, r11, 0x5c38
	ctx.r[4].s64 = ctx.r[11].s64 + 23608;
	// 829E4C58: 4840EDB1  bl 0x82df3a08
	ctx.lr = 0x829E4C5C;
	sub_82DF3A08(ctx, base);
	// 829E4C5C: 83810064  lwz r28, 0x64(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E4C60: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 829E4C64: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E4C68: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 829E4C6C: 419A0024  beq cr6, 0x829e4c90
	if ctx.cr[6].eq {
	pc = 0x829E4C90; continue 'dispatch;
	}
	// 829E4C70: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 829E4C74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E4C78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4C7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E4C80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E4C84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E4C88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4C8C: 4082FFE8  bne 0x829e4c74
	if !ctx.cr[0].eq {
	pc = 0x829E4C74; continue 'dispatch;
	}
	// 829E4C90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E4C94: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829E4C98: 4BB25CB9  bl 0x8250a950
	ctx.lr = 0x829E4C9C;
	sub_8250A950(ctx, base);
	// 829E4C9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E4CA4: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829E4CA8: 409A0008  bne cr6, 0x829e4cb0
	if !ctx.cr[6].eq {
	pc = 0x829E4CB0; continue 'dispatch;
	}
	// 829E4CAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E4CB0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829E4CB4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829E4CB8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829E4CBC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829E4CC0: 4BDEFFF1  bl 0x827d4cb0
	ctx.lr = 0x829E4CC4;
	sub_827D4CB0(ctx, base);
	// 829E4CC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E4CC8: 3BDF0278  addi r30, r31, 0x278
	ctx.r[30].s64 = ctx.r[31].s64 + 632;
	// 829E4CCC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829E4CD0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 829E4CD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4CD8: 917F0278  stw r11, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[11].u32 ) };
	// 829E4CDC: 4B8DF785  bl 0x822c4460
	ctx.lr = 0x829E4CE0;
	sub_822C4460(ctx, base);
	// 829E4CE0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 829E4CE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4CE8: 419A0008  beq cr6, 0x829e4cf0
	if ctx.cr[6].eq {
	pc = 0x829E4CF0; continue 'dispatch;
	}
	// 829E4CEC: 4B8DBBA5  bl 0x822c0890
	ctx.lr = 0x829E4CF0;
	sub_822C0890(ctx, base);
	// 829E4CF0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829E4CF4: 4840CF9D  bl 0x82df1c90
	ctx.lr = 0x829E4CF8;
	sub_82DF1C90(ctx, base);
	// 829E4CF8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829E4CFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4D00: 419A0008  beq cr6, 0x829e4d08
	if ctx.cr[6].eq {
	pc = 0x829E4D08; continue 'dispatch;
	}
	// 829E4D04: 4B8DBB8D  bl 0x822c0890
	ctx.lr = 0x829E4D08;
	sub_822C0890(ctx, base);
	// 829E4D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4D0C: 4840E71D  bl 0x82df3428
	ctx.lr = 0x829E4D10;
	sub_82DF3428(ctx, base);
	// 829E4D10: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E4D14: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4D18: 4849CA29  bl 0x82e81740
	ctx.lr = 0x829E4D1C;
	sub_82E81740(ctx, base);
	// 829E4D1C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E4D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4D24: 388B5C24  addi r4, r11, 0x5c24
	ctx.r[4].s64 = ctx.r[11].s64 + 23588;
	// 829E4D28: 4840ECE1  bl 0x82df3a08
	ctx.lr = 0x829E4D2C;
	sub_82DF3A08(ctx, base);
	// 829E4D2C: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 829E4D30: 9381007C  stw r28, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 829E4D34: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E4D38: 419A0024  beq cr6, 0x829e4d5c
	if ctx.cr[6].eq {
	pc = 0x829E4D5C; continue 'dispatch;
	}
	// 829E4D3C: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 829E4D40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E4D44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4D48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E4D4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E4D50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E4D54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E4D58: 4082FFE8  bne 0x829e4d40
	if !ctx.cr[0].eq {
	pc = 0x829E4D40; continue 'dispatch;
	}
	// 829E4D5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E4D60: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829E4D64: 4BB25BED  bl 0x8250a950
	ctx.lr = 0x829E4D68;
	sub_8250A950(ctx, base);
	// 829E4D68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E4D70: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829E4D74: 409A0008  bne cr6, 0x829e4d7c
	if !ctx.cr[6].eq {
	pc = 0x829E4D7C; continue 'dispatch;
	}
	// 829E4D78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E4D7C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 829E4D80: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829E4D84: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 829E4D88: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829E4D8C: 4BDEFF25  bl 0x827d4cb0
	ctx.lr = 0x829E4D90;
	sub_827D4CB0(ctx, base);
	// 829E4D90: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E4D94: 395F0280  addi r10, r31, 0x280
	ctx.r[10].s64 = ctx.r[31].s64 + 640;
	// 829E4D98: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829E4D9C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 829E4DA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4DA4: 917F0280  stw r11, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[11].u32 ) };
	// 829E4DA8: 4B8DF6B9  bl 0x822c4460
	ctx.lr = 0x829E4DAC;
	sub_822C4460(ctx, base);
	// 829E4DAC: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 829E4DB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4DB4: 419A0008  beq cr6, 0x829e4dbc
	if ctx.cr[6].eq {
	pc = 0x829E4DBC; continue 'dispatch;
	}
	// 829E4DB8: 4B8DBAD9  bl 0x822c0890
	ctx.lr = 0x829E4DBC;
	sub_822C0890(ctx, base);
	// 829E4DBC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829E4DC0: 4840CED1  bl 0x82df1c90
	ctx.lr = 0x829E4DC4;
	sub_82DF1C90(ctx, base);
	// 829E4DC4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829E4DC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4DCC: 419A0008  beq cr6, 0x829e4dd4
	if ctx.cr[6].eq {
	pc = 0x829E4DD4; continue 'dispatch;
	}
	// 829E4DD0: 4B8DBAC1  bl 0x822c0890
	ctx.lr = 0x829E4DD4;
	sub_822C0890(ctx, base);
	// 829E4DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4DD8: 4840E651  bl 0x82df3428
	ctx.lr = 0x829E4DDC;
	sub_82DF3428(ctx, base);
	// 829E4DDC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E4DE0: 419A000C  beq cr6, 0x829e4dec
	if ctx.cr[6].eq {
	pc = 0x829E4DEC; continue 'dispatch;
	}
	// 829E4DE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E4DE8: 4B8DBAA9  bl 0x822c0890
	ctx.lr = 0x829E4DEC;
	sub_822C0890(ctx, base);
	// 829E4DEC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829E4DF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4DF4: 38A0020D  li r5, 0x20d
	ctx.r[5].s64 = 525;
	// 829E4DF8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 829E4DFC: 4B8DB5DD  bl 0x822c03d8
	ctx.lr = 0x829E4E00;
	sub_822C03D8(ctx, base);
	// 829E4E00: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E4E04: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829E4E08: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 829E4E0C: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829E4E10: 41820090  beq 0x829e4ea0
	if ctx.cr[0].eq {
	pc = 0x829E4EA0; continue 'dispatch;
	}
	// 829E4E14: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4E18: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 829E4E1C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829E4E20: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 829E4E24: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829E4E28: 484BB909  bl 0x82ea0730
	ctx.lr = 0x829E4E2C;
	sub_82EA0730(ctx, base);
	// 829E4E2C: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 829E4E30: C03F0234  lfs f1, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E4E34: 485353BD  bl 0x82f1a1f0
	ctx.lr = 0x829E4E38;
	sub_82F1A1F0(ctx, base);
	// 829E4E38: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 829E4E3C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E4E40: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 829E4E44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E4E48: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 829E4E4C: 80AB67D4  lwz r5, 0x67d4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26580 as u32) ) } as u64;
	// 829E4E50: 808A6834  lwz r4, 0x6834(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26676 as u32) ) } as u64;
	// 829E4E54: 4B91294D  bl 0x822f77a0
	ctx.lr = 0x829E4E58;
	sub_822F77A0(ctx, base);
	// 829E4E58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829E4E5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4E60: 4B900061  bl 0x822e4ec0
	ctx.lr = 0x829E4E64;
	sub_822E4EC0(ctx, base);
	// 829E4E64: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829E4E68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4E6C: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 829E4E70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E4E74: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E4E78: 4BAA7411  bl 0x8248c288
	ctx.lr = 0x829E4E7C;
	sub_8248C288(ctx, base);
	// 829E4E7C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829E4E80: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829E4E84: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E4E88: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 829E4E8C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E4E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4E94: 4BAAD30D  bl 0x824921a0
	ctx.lr = 0x829E4E98;
	sub_824921A0(ctx, base);
	// 829E4E98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4E9C: 48000008  b 0x829e4ea4
	pc = 0x829E4EA4; continue 'dispatch;
	// 829E4EA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E4EA4: 387F0258  addi r3, r31, 0x258
	ctx.r[3].s64 = ctx.r[31].s64 + 600;
	// 829E4EA8: 4B8FFF41  bl 0x822e4de8
	ctx.lr = 0x829E4EAC;
	sub_822E4DE8(ctx, base);
	// 829E4EAC: 572B07FF  clrlwi. r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E4EB0: 41820018  beq 0x829e4ec8
	if ctx.cr[0].eq {
	pc = 0x829E4EC8; continue 'dispatch;
	}
	// 829E4EB4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 829E4EB8: 5739003C  rlwinm r25, r25, 0, 0, 0x1e
	ctx.r[25].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 829E4EBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4EC0: 419A0008  beq cr6, 0x829e4ec8
	if ctx.cr[6].eq {
	pc = 0x829E4EC8; continue 'dispatch;
	}
	// 829E4EC4: 4B9033A5  bl 0x822e8268
	ctx.lr = 0x829E4EC8;
	sub_822E8268(ctx, base);
	// 829E4EC8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829E4ECC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4ED0: 38A00215  li r5, 0x215
	ctx.r[5].s64 = 533;
	// 829E4ED4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 829E4ED8: 4B8DB501  bl 0x822c03d8
	ctx.lr = 0x829E4EDC;
	sub_822C03D8(ctx, base);
	// 829E4EDC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829E4EE0: 41820088  beq 0x829e4f68
	if ctx.cr[0].eq {
	pc = 0x829E4F68; continue 'dispatch;
	}
	// 829E4EE4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4EE8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 829E4EEC: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829E4EF0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 829E4EF4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829E4EF8: 484BB839  bl 0x82ea0730
	ctx.lr = 0x829E4EFC;
	sub_82EA0730(ctx, base);
	// 829E4EFC: B3830004  sth r28, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u16 ) };
	// 829E4F00: C03F0238  lfs f1, 0x238(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E4F04: 485352ED  bl 0x82f1a1f0
	ctx.lr = 0x829E4F08;
	sub_82F1A1F0(ctx, base);
	// 829E4F08: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 829E4F0C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E4F10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E4F14: 63390002  ori r25, r25, 2
	ctx.r[25].u64 = ctx.r[25].u64 | 2;
	// 829E4F18: 808B6750  lwz r4, 0x6750(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26448 as u32) ) } as u64;
	// 829E4F1C: 4B900015  bl 0x822e4f30
	ctx.lr = 0x829E4F20;
	sub_822E4F30(ctx, base);
	// 829E4F20: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829E4F24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4F28: 4B8FFF99  bl 0x822e4ec0
	ctx.lr = 0x829E4F2C;
	sub_822E4EC0(ctx, base);
	// 829E4F2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829E4F30: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E4F34: E89C0000  ld r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 829E4F38: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E4F3C: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E4F40: 4BAA7349  bl 0x8248c288
	ctx.lr = 0x829E4F44;
	sub_8248C288(ctx, base);
	// 829E4F44: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 829E4F48: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 829E4F4C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E4F50: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E4F54: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E4F58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4F5C: 4BAAD245  bl 0x824921a0
	ctx.lr = 0x829E4F60;
	sub_824921A0(ctx, base);
	// 829E4F60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E4F64: 48000008  b 0x829e4f6c
	pc = 0x829E4F6C; continue 'dispatch;
	// 829E4F68: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E4F6C: 387F0260  addi r3, r31, 0x260
	ctx.r[3].s64 = ctx.r[31].s64 + 608;
	// 829E4F70: 4B8FFE79  bl 0x822e4de8
	ctx.lr = 0x829E4F74;
	sub_822E4DE8(ctx, base);
	// 829E4F74: 572B07BD  rlwinm. r11, r25, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E4F78: 41820014  beq 0x829e4f8c
	if ctx.cr[0].eq {
	pc = 0x829E4F8C; continue 'dispatch;
	}
	// 829E4F7C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E4F80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4F84: 419A0008  beq cr6, 0x829e4f8c
	if ctx.cr[6].eq {
	pc = 0x829E4F8C; continue 'dispatch;
	}
	// 829E4F88: 4B9032E1  bl 0x822e8268
	ctx.lr = 0x829E4F8C;
	sub_822E8268(ctx, base);
	// 829E4F8C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 829E4F90: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 829E4F94: 487C3210  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E4F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E4F98 size=260
    let mut pc: u32 = 0x829E4F98;
    'dispatch: loop {
        match pc {
            0x829E4F98 => {
    //   block [0x829E4F98..0x829E509C)
	// 829E4F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E4F9C: 487C31CD  bl 0x831a8168
	ctx.lr = 0x829E4FA0;
	sub_831A8130(ctx, base);
	// 829E4FA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E4FA4: 4876F65D  bl 0x83154600
	ctx.lr = 0x829E4FA8;
	sub_83154600(ctx, base);
	// 829E4FA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E4FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E4FB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4FB4: 4BDD1625  bl 0x827b65d8
	ctx.lr = 0x829E4FB8;
	sub_827B65D8(ctx, base);
	// 829E4FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E4FBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E4FC0: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E4FC4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E4FC8: 419A000C  beq cr6, 0x829e4fd4
	if ctx.cr[6].eq {
	pc = 0x829E4FD4; continue 'dispatch;
	}
	// 829E4FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E4FD0: 484E9831  bl 0x82ece800
	ctx.lr = 0x829E4FD4;
	sub_82ECE800(ctx, base);
	// 829E4FD4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E4FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E4FDC: 419A0008  beq cr6, 0x829e4fe4
	if ctx.cr[6].eq {
	pc = 0x829E4FE4; continue 'dispatch;
	}
	// 829E4FE0: 4B8DB8B1  bl 0x822c0890
	ctx.lr = 0x829E4FE4;
	sub_822C0890(ctx, base);
	// 829E4FE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E4FE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E4FEC: 4BDD15ED  bl 0x827b65d8
	ctx.lr = 0x829E4FF0;
	sub_827B65D8(ctx, base);
	// 829E4FF0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829E4FF4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E4FF8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E4FFC: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5000: 808B6838  lwz r4, 0x6838(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26680 as u32) ) } as u64;
	// 829E5004: 4B8FFF2D  bl 0x822e4f30
	ctx.lr = 0x829E5008;
	sub_822E4F30(ctx, base);
	// 829E5008: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829E500C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E5010: 4B8FFEB1  bl 0x822e4ec0
	ctx.lr = 0x829E5014;
	sub_822E4EC0(ctx, base);
	// 829E5014: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829E5018: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E501C: E8BC0000  ld r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	// 829E5020: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829E5024: 806B6830  lwz r3, 0x6830(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 829E5028: 4BAA7349  bl 0x8248c370
	ctx.lr = 0x829E502C;
	sub_8248C370(ctx, base);
	// 829E502C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E5034: 4BAAA36D  bl 0x8248f3a0
	ctx.lr = 0x829E5038;
	sub_8248F3A0(ctx, base);
	// 829E5038: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E503C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5040: 419A0008  beq cr6, 0x829e5048
	if ctx.cr[6].eq {
	pc = 0x829E5048; continue 'dispatch;
	}
	// 829E5044: 4B8DB84D  bl 0x822c0890
	ctx.lr = 0x829E5048;
	sub_822C0890(ctx, base);
	// 829E5048: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E504C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E5050: 4BDD1589  bl 0x827b65d8
	ctx.lr = 0x829E5054;
	sub_827B65D8(ctx, base);
	// 829E5054: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5058: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E505C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E5060: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E5064: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E5068: 484E6B29  bl 0x82ecbb90
	ctx.lr = 0x829E506C;
	sub_82ECBB90(ctx, base);
	// 829E506C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E5070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5074: 419A0008  beq cr6, 0x829e507c
	if ctx.cr[6].eq {
	pc = 0x829E507C; continue 'dispatch;
	}
	// 829E5078: 4B8DB819  bl 0x822c0890
	ctx.lr = 0x829E507C;
	sub_822C0890(ctx, base);
	// 829E507C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E5080: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E5084: 917F0254  stw r11, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[11].u32 ) };
	// 829E5088: 419A000C  beq cr6, 0x829e5094
	if ctx.cr[6].eq {
	pc = 0x829E5094; continue 'dispatch;
	}
	// 829E508C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5090: 484E7F79  bl 0x82ecd008
	ctx.lr = 0x829E5094;
	sub_82ECD008(ctx, base);
	// 829E5094: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E5098: 487C3120  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E50A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E50A0 size=324
    let mut pc: u32 = 0x829E50A0;
    'dispatch: loop {
        match pc {
            0x829E50A0 => {
    //   block [0x829E50A0..0x829E51E4)
	// 829E50A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E50A4: 487C30C1  bl 0x831a8164
	ctx.lr = 0x829E50A8;
	sub_831A8130(ctx, base);
	// 829E50A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E50AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E50B0: 4876F551  bl 0x83154600
	ctx.lr = 0x829E50B4;
	sub_83154600(ctx, base);
	// 829E50B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E50B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E50BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E50C0: 4BDD1519  bl 0x827b65d8
	ctx.lr = 0x829E50C4;
	sub_827B65D8(ctx, base);
	// 829E50C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E50C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E50CC: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E50D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E50D4: 419A000C  beq cr6, 0x829e50e0
	if ctx.cr[6].eq {
	pc = 0x829E50E0; continue 'dispatch;
	}
	// 829E50D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E50DC: 484E9725  bl 0x82ece800
	ctx.lr = 0x829E50E0;
	sub_82ECE800(ctx, base);
	// 829E50E0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E50E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E50E8: 419A0008  beq cr6, 0x829e50f0
	if ctx.cr[6].eq {
	pc = 0x829E50F0; continue 'dispatch;
	}
	// 829E50EC: 4B8DB7A5  bl 0x822c0890
	ctx.lr = 0x829E50F0;
	sub_822C0890(ctx, base);
	// 829E50F0: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 829E50F4: 4BA4790D  bl 0x8242ca00
	ctx.lr = 0x829E50F8;
	sub_8242CA00(ctx, base);
	// 829E50F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E50FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E5100: 4BDD14D9  bl 0x827b65d8
	ctx.lr = 0x829E5104;
	sub_827B65D8(ctx, base);
	// 829E5104: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829E5108: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E510C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E5110: 838A0000  lwz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5114: 808B6838  lwz r4, 0x6838(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26680 as u32) ) } as u64;
	// 829E5118: 4B8FFE19  bl 0x822e4f30
	ctx.lr = 0x829E511C;
	sub_822E4F30(ctx, base);
	// 829E511C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829E5120: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E5124: 4B8FFD9D  bl 0x822e4ec0
	ctx.lr = 0x829E5128;
	sub_822E4EC0(ctx, base);
	// 829E5128: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829E512C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E5130: E8BB0000  ld r5, 0(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 829E5134: E88A0000  ld r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 829E5138: 806B6830  lwz r3, 0x6830(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26672 as u32) ) } as u64;
	// 829E513C: 4BAA7235  bl 0x8248c370
	ctx.lr = 0x829E5140;
	sub_8248C370(ctx, base);
	// 829E5140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5144: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E5148: 4BAAA259  bl 0x8248f3a0
	ctx.lr = 0x829E514C;
	sub_8248F3A0(ctx, base);
	// 829E514C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E5150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5154: 419A0008  beq cr6, 0x829e515c
	if ctx.cr[6].eq {
	pc = 0x829E515C; continue 'dispatch;
	}
	// 829E5158: 4B8DB739  bl 0x822c0890
	ctx.lr = 0x829E515C;
	sub_822C0890(ctx, base);
	// 829E515C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5160: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E5164: 4BDD1475  bl 0x827b65d8
	ctx.lr = 0x829E5168;
	sub_827B65D8(ctx, base);
	// 829E5168: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E516C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E5170: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829E5174: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E5178: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E517C: 484E6A15  bl 0x82ecbb90
	ctx.lr = 0x829E5180;
	sub_82ECBB90(ctx, base);
	// 829E5180: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E5184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5188: 419A0008  beq cr6, 0x829e5190
	if ctx.cr[6].eq {
	pc = 0x829E5190; continue 'dispatch;
	}
	// 829E518C: 4B8DB705  bl 0x822c0890
	ctx.lr = 0x829E5190;
	sub_822C0890(ctx, base);
	// 829E5190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5194: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E5198: 4BDD1441  bl 0x827b65d8
	ctx.lr = 0x829E519C;
	sub_827B65D8(ctx, base);
	// 829E519C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E51A0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E51A4: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 829E51A8: 4B907FA9  bl 0x822ed150
	ctx.lr = 0x829E51AC;
	sub_822ED150(ctx, base);
	// 829E51AC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829E51B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E51B4: 419A0008  beq cr6, 0x829e51bc
	if ctx.cr[6].eq {
	pc = 0x829E51BC; continue 'dispatch;
	}
	// 829E51B8: 4B8DB6D9  bl 0x822c0890
	ctx.lr = 0x829E51BC;
	sub_822C0890(ctx, base);
	// 829E51BC: 807E0080  lwz r3, 0x80(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 829E51C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E51C4: 419A0008  beq cr6, 0x829e51cc
	if ctx.cr[6].eq {
	pc = 0x829E51CC; continue 'dispatch;
	}
	// 829E51C8: 48161501  bl 0x82b466c8
	ctx.lr = 0x829E51CC;
	sub_82B466C8(ctx, base);
	// 829E51CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E51D0: 419A000C  beq cr6, 0x829e51dc
	if ctx.cr[6].eq {
	pc = 0x829E51DC; continue 'dispatch;
	}
	// 829E51D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E51D8: 484E7E31  bl 0x82ecd008
	ctx.lr = 0x829E51DC;
	sub_82ECD008(ctx, base);
	// 829E51DC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829E51E0: 487C2FD4  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E51E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E51E8 size=820
    let mut pc: u32 = 0x829E51E8;
    'dispatch: loop {
        match pc {
            0x829E51E8 => {
    //   block [0x829E51E8..0x829E551C)
	// 829E51E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E51EC: 487C2F7D  bl 0x831a8168
	ctx.lr = 0x829E51F0;
	sub_831A8130(ctx, base);
	// 829E51F0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E51F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E51F8: 817E00E8  lwz r11, 0xe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 829E51FC: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5200: 7D6B0775  extsb. r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5204: 40810310  ble 0x829e5514
	if !ctx.cr[0].gt {
	pc = 0x829E5514; continue 'dispatch;
	}
	// 829E5208: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829E520C: 4BFE38D5  bl 0x829c8ae0
	ctx.lr = 0x829E5210;
	sub_829C8AE0(ctx, base);
	// 829E5210: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5214: 4BFE08F5  bl 0x829c5b08
	ctx.lr = 0x829E5218;
	sub_829C5B08(ctx, base);
	// 829E5218: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829E521C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5224: 419A000C  beq cr6, 0x829e5230
	if ctx.cr[6].eq {
	pc = 0x829E5230; continue 'dispatch;
	}
	// 829E5228: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829E522C: 4B8DB665  bl 0x822c0890
	ctx.lr = 0x829E5230;
	sub_822C0890(ctx, base);
	// 829E5230: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5234: 418202E0  beq 0x829e5514
	if ctx.cr[0].eq {
	pc = 0x829E5514; continue 'dispatch;
	}
	// 829E5238: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E523C: 4BB2C8AD  bl 0x82511ae8
	ctx.lr = 0x829E5240;
	sub_82511AE8(ctx, base);
	// 829E5240: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 829E5244: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E5248: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E524C: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 829E5250: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 829E5254: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5520 size=104
    let mut pc: u32 = 0x829E5520;
    'dispatch: loop {
        match pc {
            0x829E5520 => {
    //   block [0x829E5520..0x829E5588)
	// 829E5520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5524: 487C2C49  bl 0x831a816c
	ctx.lr = 0x829E5528;
	sub_831A8130(ctx, base);
	// 829E5528: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E552C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5534: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E5538: 4BFE35A9  bl 0x829c8ae0
	ctx.lr = 0x829E553C;
	sub_829C8AE0(ctx, base);
	// 829E553C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5540: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E5544: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 829E5548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E554C: 555DDFFE  rlwinm r29, r10, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 829E5550: 419A000C  beq cr6, 0x829e555c
	if ctx.cr[6].eq {
	pc = 0x829E555C; continue 'dispatch;
	}
	// 829E5554: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829E5558: 4B8DB339  bl 0x822c0890
	ctx.lr = 0x829E555C;
	sub_822C0890(ctx, base);
	// 829E555C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5564: 4182000C  beq 0x829e5570
	if ctx.cr[0].eq {
	pc = 0x829E5570; continue 'dispatch;
	}
	// 829E5568: 4BB2B069  bl 0x825105d0
	ctx.lr = 0x829E556C;
	sub_825105D0(ctx, base);
	// 829E556C: 48000014  b 0x829e5580
	pc = 0x829E5580; continue 'dispatch;
	// 829E5570: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5574: 4BB2B195  bl 0x82510708
	ctx.lr = 0x829E5578;
	sub_82510708(ctx, base);
	// 829E5578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E557C: 4BFFFC6D  bl 0x829e51e8
	ctx.lr = 0x829E5580;
	sub_829E51E8(ctx, base);
	// 829E5580: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E5584: 487C2C38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5588 size=112
    let mut pc: u32 = 0x829E5588;
    'dispatch: loop {
        match pc {
            0x829E5588 => {
    //   block [0x829E5588..0x829E55F8)
	// 829E5588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E558C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5594: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5598: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E559C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E55A0: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829E55A4: 4BB2CCBD  bl 0x82512260
	ctx.lr = 0x829E55A8;
	sub_82512260(ctx, base);
	// 829E55A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E55AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E55B0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E55B4: 394A5C64  addi r10, r10, 0x5c64
	ctx.r[10].s64 = ctx.r[10].s64 + 23652;
	// 829E55B8: 39295C50  addi r9, r9, 0x5c50
	ctx.r[9].s64 = ctx.r[9].s64 + 23632;
	// 829E55BC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E55C0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829E55C4: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 829E55C8: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E55CC: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829E55D0: 4BA4FA41  bl 0x82435010
	ctx.lr = 0x829E55D4;
	sub_82435010(ctx, base);
	// 829E55D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E55D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E55DC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 829E55E0: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 829E55E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E55E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E55EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E55F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E55F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E55F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E55F8 size=8
    let mut pc: u32 = 0x829E55F8;
    'dispatch: loop {
        match pc {
            0x829E55F8 => {
    //   block [0x829E55F8..0x829E5600)
	// 829E55F8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E55FC: 48000004  b 0x829e5600
	sub_829E5600(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5600 size=104
    let mut pc: u32 = 0x829E5600;
    'dispatch: loop {
        match pc {
            0x829E5600 => {
    //   block [0x829E5600..0x829E5668)
	// 829E5600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5604: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5608: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E560C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5610: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5618: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E561C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829E5620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5624: 419A0008  beq cr6, 0x829e562c
	if ctx.cr[6].eq {
	pc = 0x829E562C; continue 'dispatch;
	}
	// 829E5628: 4B8DB269  bl 0x822c0890
	ctx.lr = 0x829E562C;
	sub_822C0890(ctx, base);
	// 829E562C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829E5630: 4B93B8C1  bl 0x82320ef0
	ctx.lr = 0x829E5634;
	sub_82320EF0(ctx, base);
	// 829E5634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5638: 4B969D19  bl 0x8234f350
	ctx.lr = 0x829E563C;
	sub_8234F350(ctx, base);
	// 829E563C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5640: 4182000C  beq 0x829e564c
	if ctx.cr[0].eq {
	pc = 0x829E564C; continue 'dispatch;
	}
	// 829E5644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5648: 4840CD91  bl 0x82df23d8
	ctx.lr = 0x829E564C;
	sub_82DF23D8(ctx, base);
	// 829E564C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5650: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E5654: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5658: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E565C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E5660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5668 size=648
    let mut pc: u32 = 0x829E5668;
    'dispatch: loop {
        match pc {
            0x829E5668 => {
    //   block [0x829E5668..0x829E58F0)
	// 829E5668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E566C: 487C2AFD  bl 0x831a8168
	ctx.lr = 0x829E5670;
	sub_831A8130(ctx, base);
	// 829E5670: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5674: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 829E5678: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E567C: 4BB2DEFD  bl 0x82513578
	ctx.lr = 0x829E5680;
	sub_82513578(ctx, base);
	// 829E5680: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E5684: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E5688: 388B5B90  addi r4, r11, 0x5b90
	ctx.r[4].s64 = ctx.r[11].s64 + 23440;
	// 829E568C: 38A0027C  li r5, 0x27c
	ctx.r[5].s64 = 636;
	// 829E5690: 386000FC  li r3, 0xfc
	ctx.r[3].s64 = 252;
	// 829E5694: 4840CD55  bl 0x82df23e8
	ctx.lr = 0x829E5698;
	sub_82DF23E8(ctx, base);
	// 829E5698: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E569C: 41820014  beq 0x829e56b0
	if ctx.cr[0].eq {
	pc = 0x829E56B0; continue 'dispatch;
	}
	// 829E56A0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 829E56A4: 4BFFFEE5  bl 0x829e5588
	ctx.lr = 0x829E56A8;
	sub_829E5588(ctx, base);
	// 829E56A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E56AC: 48000008  b 0x829e56b4
	pc = 0x829E56B4; continue 'dispatch;
	// 829E56B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E56B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829E56B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E56BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E56C0: 4BFFCCD9  bl 0x829e2398
	ctx.lr = 0x829E56C4;
	sub_829E2398(ctx, base);
	// 829E56C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E56C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E56CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E56D0: 4B8DA931  bl 0x822c0000
	ctx.lr = 0x829E56D4;
	sub_822C0000(ctx, base);
	// 829E56D4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E56D8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E56DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E56E0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 829E56E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829E56E8: 419A0024  beq cr6, 0x829e570c
	if ctx.cr[6].eq {
	pc = 0x829E570C; continue 'dispatch;
	}
	// 829E56EC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829E56F0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E56F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E56F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E56FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E5700: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E5704: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E5708: 4082FFE8  bne 0x829e56f0
	if !ctx.cr[0].eq {
	pc = 0x829E56F0; continue 'dispatch;
	}
	// 829E570C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5710: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E5714: 4BB29DB5  bl 0x8250f4c8
	ctx.lr = 0x829E5718;
	sub_8250F4C8(ctx, base);
	// 829E5718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E571C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5720: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 829E5724: 409A0008  bne cr6, 0x829e572c
	if !ctx.cr[6].eq {
	pc = 0x829E572C; continue 'dispatch;
	}
	// 829E5728: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E572C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5730: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829E5734: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 829E5738: 4BB29DE1  bl 0x8250f518
	ctx.lr = 0x829E573C;
	sub_8250F518(ctx, base);
	// 829E573C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5744: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829E5748: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E574C: 4BB27DBD  bl 0x8250d508
	ctx.lr = 0x829E5750;
	sub_8250D508(ctx, base);
	// 829E5750: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E5754: 4840C53D  bl 0x82df1c90
	ctx.lr = 0x829E5758;
	sub_82DF1C90(ctx, base);
	// 829E5758: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829E575C: 4840C535  bl 0x82df1c90
	ctx.lr = 0x829E5760;
	sub_82DF1C90(ctx, base);
	// 829E5760: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829E5764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5768: 4BB2DE11  bl 0x82513578
	ctx.lr = 0x829E576C;
	sub_82513578(ctx, base);
	// 829E576C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 829E5770: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5774: 4BB2DE75  bl 0x825135e8
	ctx.lr = 0x829E5778;
	sub_825135E8(ctx, base);
	// 829E5778: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 829E577C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5780: 4BB2DEE9  bl 0x82513668
	ctx.lr = 0x829E5784;
	sub_82513668(ctx, base);
	// 829E5784: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5788: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E578C: 4BB29D3D  bl 0x8250f4c8
	ctx.lr = 0x829E5790;
	sub_8250F4C8(ctx, base);
	// 829E5790: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5798: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829E579C: 409A0008  bne cr6, 0x829e57a4
	if !ctx.cr[6].eq {
	pc = 0x829E57A4; continue 'dispatch;
	}
	// 829E57A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E57A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E57A8: 4BB24E91  bl 0x8250a638
	ctx.lr = 0x829E57AC;
	sub_8250A638(ctx, base);
	// 829E57AC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E57B0: 4840C4E1  bl 0x82df1c90
	ctx.lr = 0x829E57B4;
	sub_82DF1C90(ctx, base);
	// 829E57B4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829E57B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E57BC: 419A0104  beq cr6, 0x829e58c0
	if ctx.cr[6].eq {
	pc = 0x829E58C0; continue 'dispatch;
	}
	// 829E57C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E57C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E57C8: 388B5CA0  addi r4, r11, 0x5ca0
	ctx.r[4].s64 = ctx.r[11].s64 + 23712;
	// 829E57CC: 4840E23D  bl 0x82df3a08
	ctx.lr = 0x829E57D0;
	sub_82DF3A08(ctx, base);
	// 829E57D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E57D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E57D8: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829E57DC: 4BDDB82D  bl 0x827c1008
	ctx.lr = 0x829E57E0;
	sub_827C1008(ctx, base);
	// 829E57E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E57E4: 4840DC45  bl 0x82df3428
	ctx.lr = 0x829E57E8;
	sub_82DF3428(ctx, base);
	// 829E57E8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E57EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E57F0: 419A00C0  beq cr6, 0x829e58b0
	if ctx.cr[6].eq {
	pc = 0x829E58B0; continue 'dispatch;
	}
	// 829E57F4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 829E57F8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 829E57FC: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829E5800: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 829E5804: 4B921F75  bl 0x82307778
	ctx.lr = 0x829E5808;
	sub_82307778(ctx, base);
	// 829E5808: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E580C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5810: 4BDD64C1  bl 0x827bbcd0
	ctx.lr = 0x829E5814;
	sub_827BBCD0(ctx, base);
	// 829E5814: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E5818: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E581C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5820: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E5824: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E5828: 419A0024  beq cr6, 0x829e584c
	if ctx.cr[6].eq {
	pc = 0x829E584C; continue 'dispatch;
	}
	// 829E582C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E5830: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E5834: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E5838: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E583C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E5840: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E5844: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E5848: 4082FFE8  bne 0x829e5830
	if !ctx.cr[0].eq {
	pc = 0x829E5830; continue 'dispatch;
	}
	// 829E584C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5850: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E5854: 4BB29C75  bl 0x8250f4c8
	ctx.lr = 0x829E5858;
	sub_8250F4C8(ctx, base);
	// 829E5858: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E585C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5860: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 829E5864: 409A0008  bne cr6, 0x829e586c
	if !ctx.cr[6].eq {
	pc = 0x829E586C; continue 'dispatch;
	}
	// 829E5868: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E586C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5870: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829E5874: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 829E5878: 4BB29CA1  bl 0x8250f518
	ctx.lr = 0x829E587C;
	sub_8250F518(ctx, base);
	// 829E587C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5884: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829E5888: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E588C: 4BB27C7D  bl 0x8250d508
	ctx.lr = 0x829E5890;
	sub_8250D508(ctx, base);
	// 829E5890: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E5894: 4840C3FD  bl 0x82df1c90
	ctx.lr = 0x829E5898;
	sub_82DF1C90(ctx, base);
	// 829E5898: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829E589C: 4840C3F5  bl 0x82df1c90
	ctx.lr = 0x829E58A0;
	sub_82DF1C90(ctx, base);
	// 829E58A0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 829E58A4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 829E58A8: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E58AC: 4BDD78B5  bl 0x827bd160
	ctx.lr = 0x829E58B0;
	sub_827BD160(ctx, base);
	// 829E58B0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E58B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E58B8: 419A0008  beq cr6, 0x829e58c0
	if ctx.cr[6].eq {
	pc = 0x829E58C0; continue 'dispatch;
	}
	// 829E58BC: 4B8DAFD5  bl 0x822c0890
	ctx.lr = 0x829E58C0;
	sub_822C0890(ctx, base);
	// 829E58C0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E58C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E58C8: 419A0008  beq cr6, 0x829e58d0
	if ctx.cr[6].eq {
	pc = 0x829E58D0; continue 'dispatch;
	}
	// 829E58CC: 4B8DAFC5  bl 0x822c0890
	ctx.lr = 0x829E58D0;
	sub_822C0890(ctx, base);
	// 829E58D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E58D4: 4BB2ACFD  bl 0x825105d0
	ctx.lr = 0x829E58D8;
	sub_825105D0(ctx, base);
	// 829E58D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E58DC: 419A000C  beq cr6, 0x829e58e8
	if ctx.cr[6].eq {
	pc = 0x829E58E8; continue 'dispatch;
	}
	// 829E58E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E58E4: 4B8DAFAD  bl 0x822c0890
	ctx.lr = 0x829E58E8;
	sub_822C0890(ctx, base);
	// 829E58E8: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 829E58EC: 487C28CC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E58F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E58F0 size=120
    let mut pc: u32 = 0x829E58F0;
    'dispatch: loop {
        match pc {
            0x829E58F0 => {
    //   block [0x829E58F0..0x829E5968)
	// 829E58F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E58F4: 487C2879  bl 0x831a816c
	ctx.lr = 0x829E58F8;
	sub_831A8130(ctx, base);
	// 829E58F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E58FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E5904: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5908: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E590C: 4BB29BBD  bl 0x8250f4c8
	ctx.lr = 0x829E5910;
	sub_8250F4C8(ctx, base);
	// 829E5910: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E5918: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829E591C: 409A0008  bne cr6, 0x829e5924
	if !ctx.cr[6].eq {
	pc = 0x829E5924; continue 'dispatch;
	}
	// 829E5920: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829E5924: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E5928: 4BB230F1  bl 0x82508a18
	ctx.lr = 0x829E592C;
	sub_82508A18(ctx, base);
	// 829E592C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E5930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5934: 486227F5  bl 0x83008128
	ctx.lr = 0x829E5938;
	sub_83008128(ctx, base);
	// 829E5938: 7D63E850  subf r11, r3, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[3].s64;
	// 829E593C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5940: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829E5944: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829E5948: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 829E594C: 4840C345  bl 0x82df1c90
	ctx.lr = 0x829E5950;
	sub_82DF1C90(ctx, base);
	// 829E5950: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5954: 4182000C  beq 0x829e5960
	if ctx.cr[0].eq {
	pc = 0x829E5960; continue 'dispatch;
	}
	// 829E5958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E595C: 4BFFFD0D  bl 0x829e5668
	ctx.lr = 0x829E5960;
	sub_829E5668(ctx, base);
	// 829E5960: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E5964: 487C2858  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5968 size=260
    let mut pc: u32 = 0x829E5968;
    'dispatch: loop {
        match pc {
            0x829E5968 => {
    //   block [0x829E5968..0x829E5A6C)
	// 829E5968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E596C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E5974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5978: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E597C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5980: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E5984: 4BFFFCE5  bl 0x829e5668
	ctx.lr = 0x829E5988;
	sub_829E5668(ctx, base);
	// 829E5988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E598C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E5990: 4BDD0C49  bl 0x827b65d8
	ctx.lr = 0x829E5994;
	sub_827B65D8(ctx, base);
	// 829E5994: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E5998: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E599C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E59A0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E59A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829E59A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E59AC: 4E800421  bctrl
	ctx.lr = 0x829E59B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E59B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E59B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E59B8: 4BC01C79  bl 0x825e7630
	ctx.lr = 0x829E59BC;
	sub_825E7630(ctx, base);
	// 829E59BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E59C0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829E59C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E59C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E59CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E59D0: 419A0024  beq cr6, 0x829e59f4
	if ctx.cr[6].eq {
	pc = 0x829E59F4; continue 'dispatch;
	}
	// 829E59D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E59D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E59DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E59E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E59E4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E59E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E59EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E59F0: 4082FFE8  bne 0x829e59d8
	if !ctx.cr[0].eq {
	pc = 0x829E59D8; continue 'dispatch;
	}
	// 829E59F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E59F8: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829E59FC: 4862272D  bl 0x83008128
	ctx.lr = 0x829E5A00;
	sub_83008128(ctx, base);
	// 829E5A00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E5A04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E5A08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829E5A0C: 388A5B90  addi r4, r10, 0x5b90
	ctx.r[4].s64 = ctx.r[10].s64 + 23440;
	// 829E5A10: 38A002BA  li r5, 0x2ba
	ctx.r[5].s64 = 698;
	// 829E5A14: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829E5A18: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E5A1C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829E5A20: 48473021  bl 0x82e58a40
	ctx.lr = 0x829E5A24;
	sub_82E58A40(ctx, base);
	// 829E5A24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E5A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5A2C: 419A0008  beq cr6, 0x829e5a34
	if ctx.cr[6].eq {
	pc = 0x829E5A34; continue 'dispatch;
	}
	// 829E5A30: 4B8DAE61  bl 0x822c0890
	ctx.lr = 0x829E5A34;
	sub_822C0890(ctx, base);
	// 829E5A34: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E5A38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5A3C: 419A0008  beq cr6, 0x829e5a44
	if ctx.cr[6].eq {
	pc = 0x829E5A44; continue 'dispatch;
	}
	// 829E5A40: 4B8DAE51  bl 0x822c0890
	ctx.lr = 0x829E5A44;
	sub_822C0890(ctx, base);
	// 829E5A44: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E5A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5A4C: 419A0008  beq cr6, 0x829e5a54
	if ctx.cr[6].eq {
	pc = 0x829E5A54; continue 'dispatch;
	}
	// 829E5A50: 4B8DAE41  bl 0x822c0890
	ctx.lr = 0x829E5A54;
	sub_822C0890(ctx, base);
	// 829E5A54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829E5A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5A60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E5A64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5A70 size=612
    let mut pc: u32 = 0x829E5A70;
    'dispatch: loop {
        match pc {
            0x829E5A70 => {
    //   block [0x829E5A70..0x829E5CD4)
	// 829E5A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5A74: 487C26F5  bl 0x831a8168
	ctx.lr = 0x829E5A78;
	sub_831A8130(ctx, base);
	// 829E5A78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5A7C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829E5A80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E5A84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E5A88: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829E5A8C: 41820038  beq 0x829e5ac4
	if ctx.cr[0].eq {
	pc = 0x829E5AC4; continue 'dispatch;
	}
	// 829E5A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5A94: 487C3EF5  bl 0x831a9988
	ctx.lr = 0x829E5A98;
	sub_831A9988(ctx, base);
	// 829E5A98: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E5A9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5AA0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829E5AA4: 487C2655  bl 0x831a80f8
	ctx.lr = 0x829E5AA8;
	sub_831A80F8(ctx, base);
	// 829E5AA8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5AAC: 41820018  beq 0x829e5ac4
	if ctx.cr[0].eq {
	pc = 0x829E5AC4; continue 'dispatch;
	}
	// 829E5AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5AB4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5AB8: 4BFFFE39  bl 0x829e58f0
	ctx.lr = 0x829E5ABC;
	sub_829E58F0(ctx, base);
	// 829E5ABC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E5AC0: 4800020C  b 0x829e5ccc
	pc = 0x829E5CCC; continue 'dispatch;
	// 829E5AC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5AC8: 419A01F4  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5AD0: 487C3EB9  bl 0x831a9988
	ctx.lr = 0x829E5AD4;
	sub_831A9988(ctx, base);
	// 829E5AD4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829E5AD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5ADC: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829E5AE0: 487C2619  bl 0x831a80f8
	ctx.lr = 0x829E5AE4;
	sub_831A80F8(ctx, base);
	// 829E5AE4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5AE8: 41820014  beq 0x829e5afc
	if ctx.cr[0].eq {
	pc = 0x829E5AFC; continue 'dispatch;
	}
	// 829E5AEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5AF0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5AF4: 4BFFFE75  bl 0x829e5968
	ctx.lr = 0x829E5AF8;
	sub_829E5968(ctx, base);
	// 829E5AF8: 4BFFFFC4  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5AFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5B00: 419A01BC  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5B08: 487C3E81  bl 0x831a9988
	ctx.lr = 0x829E5B0C;
	sub_831A9988(ctx, base);
	// 829E5B0C: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 829E5B10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5B14: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 829E5B18: 487C25E1  bl 0x831a80f8
	ctx.lr = 0x829E5B1C;
	sub_831A80F8(ctx, base);
	// 829E5B1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5B20: 41820014  beq 0x829e5b34
	if ctx.cr[0].eq {
	pc = 0x829E5B34; continue 'dispatch;
	}
	// 829E5B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5B28: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5B2C: 4BCDC9BD  bl 0x826c24e8
	ctx.lr = 0x829E5B30;
	sub_826C24E8(ctx, base);
	// 829E5B30: 4BFFFF8C  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5B34: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5B38: 419A0184  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5B40: 487C3E49  bl 0x831a9988
	ctx.lr = 0x829E5B44;
	sub_831A9988(ctx, base);
	// 829E5B44: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 829E5B48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5B4C: 386B1FA4  addi r3, r11, 0x1fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 8100;
	// 829E5B50: 487C25A9  bl 0x831a80f8
	ctx.lr = 0x829E5B54;
	sub_831A80F8(ctx, base);
	// 829E5B54: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5B58: 41820014  beq 0x829e5b6c
	if ctx.cr[0].eq {
	pc = 0x829E5B6C; continue 'dispatch;
	}
	// 829E5B5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5B60: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5B64: 4BFFC76D  bl 0x829e22d0
	ctx.lr = 0x829E5B68;
	sub_829E22D0(ctx, base);
	// 829E5B68: 4BFFFF54  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5B6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5B70: 419A014C  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5B78: 487C3E11  bl 0x831a9988
	ctx.lr = 0x829E5B7C;
	sub_831A9988(ctx, base);
	// 829E5B7C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E5B80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5B84: 386B3A18  addi r3, r11, 0x3a18
	ctx.r[3].s64 = ctx.r[11].s64 + 14872;
	// 829E5B88: 487C2571  bl 0x831a80f8
	ctx.lr = 0x829E5B8C;
	sub_831A80F8(ctx, base);
	// 829E5B8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5B90: 41820014  beq 0x829e5ba4
	if ctx.cr[0].eq {
	pc = 0x829E5BA4; continue 'dispatch;
	}
	// 829E5B94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5B98: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5B9C: 4BFFD4E5  bl 0x829e3080
	ctx.lr = 0x829E5BA0;
	sub_829E3080(ctx, base);
	// 829E5BA0: 4BFFFF1C  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5BA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5BA8: 419A0114  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5BB0: 487C3DD9  bl 0x831a9988
	ctx.lr = 0x829E5BB4;
	sub_831A9988(ctx, base);
	// 829E5BB4: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 829E5BB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5BBC: 386BFE48  addi r3, r11, -0x1b8
	ctx.r[3].s64 = ctx.r[11].s64 + -440;
	// 829E5BC0: 487C2539  bl 0x831a80f8
	ctx.lr = 0x829E5BC4;
	sub_831A80F8(ctx, base);
	// 829E5BC4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5BC8: 41820014  beq 0x829e5bdc
	if ctx.cr[0].eq {
	pc = 0x829E5BDC; continue 'dispatch;
	}
	// 829E5BCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5BD0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5BD4: 4BFFD71D  bl 0x829e32f0
	ctx.lr = 0x829E5BD8;
	sub_829E32F0(ctx, base);
	// 829E5BD8: 4BFFFEE4  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5BDC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5BE0: 419A00DC  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5BE8: 487C3DA1  bl 0x831a9988
	ctx.lr = 0x829E5BEC;
	sub_831A9988(ctx, base);
	// 829E5BEC: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 829E5BF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5BF4: 386BFD00  addi r3, r11, -0x300
	ctx.r[3].s64 = ctx.r[11].s64 + -768;
	// 829E5BF8: 487C2501  bl 0x831a80f8
	ctx.lr = 0x829E5BFC;
	sub_831A80F8(ctx, base);
	// 829E5BFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5C00: 41820014  beq 0x829e5c14
	if ctx.cr[0].eq {
	pc = 0x829E5C14; continue 'dispatch;
	}
	// 829E5C04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5C08: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5C0C: 4BFFD4E5  bl 0x829e30f0
	ctx.lr = 0x829E5C10;
	sub_829E30F0(ctx, base);
	// 829E5C10: 4BFFFEAC  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5C14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5C18: 419A00A4  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5C20: 487C3D69  bl 0x831a9988
	ctx.lr = 0x829E5C24;
	sub_831A9988(ctx, base);
	// 829E5C24: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E5C28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5C2C: 386B39EC  addi r3, r11, 0x39ec
	ctx.r[3].s64 = ctx.r[11].s64 + 14828;
	// 829E5C30: 487C24C9  bl 0x831a80f8
	ctx.lr = 0x829E5C34;
	sub_831A80F8(ctx, base);
	// 829E5C34: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5C38: 41820014  beq 0x829e5c4c
	if ctx.cr[0].eq {
	pc = 0x829E5C4C; continue 'dispatch;
	}
	// 829E5C3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5C40: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5C44: 4BFFD6AD  bl 0x829e32f0
	ctx.lr = 0x829E5C48;
	sub_829E32F0(ctx, base);
	// 829E5C48: 4BFFFE74  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5C4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5C50: 419A006C  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5C58: 487C3D31  bl 0x831a9988
	ctx.lr = 0x829E5C5C;
	sub_831A9988(ctx, base);
	// 829E5C5C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E5C60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5C64: 386B3A44  addi r3, r11, 0x3a44
	ctx.r[3].s64 = ctx.r[11].s64 + 14916;
	// 829E5C68: 487C2491  bl 0x831a80f8
	ctx.lr = 0x829E5C6C;
	sub_831A80F8(ctx, base);
	// 829E5C6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5C70: 41820014  beq 0x829e5c84
	if ctx.cr[0].eq {
	pc = 0x829E5C84; continue 'dispatch;
	}
	// 829E5C74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5C78: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5C7C: 4BFFD6E5  bl 0x829e3360
	ctx.lr = 0x829E5C80;
	sub_829E3360(ctx, base);
	// 829E5C80: 4BFFFE3C  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5C84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829E5C88: 419A0034  beq cr6, 0x829e5cbc
	if ctx.cr[6].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5C90: 487C3CF9  bl 0x831a9988
	ctx.lr = 0x829E5C94;
	sub_831A9988(ctx, base);
	// 829E5C94: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829E5C98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E5C9C: 386B66B4  addi r3, r11, 0x66b4
	ctx.r[3].s64 = ctx.r[11].s64 + 26292;
	// 829E5CA0: 487C2459  bl 0x831a80f8
	ctx.lr = 0x829E5CA4;
	sub_831A80F8(ctx, base);
	// 829E5CA4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5CA8: 41820014  beq 0x829e5cbc
	if ctx.cr[0].eq {
	pc = 0x829E5CBC; continue 'dispatch;
	}
	// 829E5CAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5CB0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E5CB4: 4BFFC5E5  bl 0x829e2298
	ctx.lr = 0x829E5CB8;
	sub_829E2298(ctx, base);
	// 829E5CB8: 4BFFFE04  b 0x829e5abc
	pc = 0x829E5ABC; continue 'dispatch;
	// 829E5CBC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829E5CC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E5CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5CC8: 4BB2DFE9  bl 0x82513cb0
	ctx.lr = 0x829E5CCC;
	sub_82513CB0(ctx, base);
	// 829E5CCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E5CD0: 487C24E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5CD8 size=280
    let mut pc: u32 = 0x829E5CD8;
    'dispatch: loop {
        match pc {
            0x829E5CD8 => {
    //   block [0x829E5CD8..0x829E5DF0)
	// 829E5CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E5CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5CE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5CEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5CF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E5CF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E5CF8: 4BFE2DE9  bl 0x829c8ae0
	ctx.lr = 0x829E5CFC;
	sub_829C8AE0(ctx, base);
	// 829E5CFC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E5D00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5D04: 419A00BC  beq cr6, 0x829e5dc0
	if ctx.cr[6].eq {
	pc = 0x829E5DC0; continue 'dispatch;
	}
	// 829E5D08: 4BFDF819  bl 0x829c5520
	ctx.lr = 0x829E5D0C;
	sub_829C5520(ctx, base);
	// 829E5D0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5D10: 40820014  bne 0x829e5d24
	if !ctx.cr[0].eq {
	pc = 0x829E5D24; continue 'dispatch;
	}
	// 829E5D14: 817F0254  lwz r11, 0x254(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 829E5D18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E5D1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5D20: 409A0008  bne cr6, 0x829e5d28
	if !ctx.cr[6].eq {
	pc = 0x829E5D28; continue 'dispatch;
	}
	// 829E5D24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E5D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5D2C: 4BB29E15  bl 0x8250fb40
	ctx.lr = 0x829E5D30;
	sub_8250FB40(ctx, base);
	// 829E5D30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5D38: 4BB2A9D1  bl 0x82510708
	ctx.lr = 0x829E5D3C;
	sub_82510708(ctx, base);
	// 829E5D3C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5D40: D01F0230  stfs f0, 0x230(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 829E5D44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E5D48: 387F0160  addi r3, r31, 0x160
	ctx.r[3].s64 = ctx.r[31].s64 + 352;
	// 829E5D4C: 4847712D  bl 0x82e5ce78
	ctx.lr = 0x829E5D50;
	sub_82E5CE78(ctx, base);
	// 829E5D50: 817F0250  lwz r11, 0x250(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(592 as u32) ) } as u64;
	// 829E5D54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5D58: 419A000C  beq cr6, 0x829e5d64
	if ctx.cr[6].eq {
	pc = 0x829E5D64; continue 'dispatch;
	}
	// 829E5D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5D60: 4BFFF909  bl 0x829e5668
	ctx.lr = 0x829E5D64;
	sub_829E5668(ctx, base);
	// 829E5D64: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E5D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5D6C: 4BB2D80D  bl 0x82513578
	ctx.lr = 0x829E5D70;
	sub_82513578(ctx, base);
	// 829E5D70: 817F024C  lwz r11, 0x24c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(588 as u32) ) } as u64;
	// 829E5D74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E5D78: 409A002C  bne cr6, 0x829e5da4
	if !ctx.cr[6].eq {
	pc = 0x829E5DA4; continue 'dispatch;
	}
	// 829E5D7C: C01F0244  lfs f0, 0x244(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5D80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E5D84: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E5D88: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829E5D8C: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5D90: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829E5D94: 40990018  ble cr6, 0x829e5dac
	if !ctx.cr[6].gt {
	pc = 0x829E5DAC; continue 'dispatch;
	}
	// 829E5D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5D9C: 4BFFF8CD  bl 0x829e5668
	ctx.lr = 0x829E5DA0;
	sub_829E5668(ctx, base);
	// 829E5DA0: 4800000C  b 0x829e5dac
	pc = 0x829E5DAC; continue 'dispatch;
	// 829E5DA4: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5DA8: D01F0244  stfs f0, 0x244(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), tmp.u32 ) };
	// 829E5DAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E5DB0: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E5DB4: C00B591C  lfs f0, 0x591c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22812 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5DB8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829E5DBC: 4098000C  bge cr6, 0x829e5dc8
	if !ctx.cr[6].lt {
	pc = 0x829E5DC8; continue 'dispatch;
	}
	// 829E5DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5DC4: 4BB2A80D  bl 0x825105d0
	ctx.lr = 0x829E5DC8;
	sub_825105D0(ctx, base);
	// 829E5DC8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E5DCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E5DD0: 419A0008  beq cr6, 0x829e5dd8
	if ctx.cr[6].eq {
	pc = 0x829E5DD8; continue 'dispatch;
	}
	// 829E5DD4: 4B8DAABD  bl 0x822c0890
	ctx.lr = 0x829E5DD8;
	sub_822C0890(ctx, base);
	// 829E5DD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E5DDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5DE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5DE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E5DE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5DEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5DF0 size=96
    let mut pc: u32 = 0x829E5DF0;
    'dispatch: loop {
        match pc {
            0x829E5DF0 => {
    //   block [0x829E5DF0..0x829E5E50)
	// 829E5DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E5DF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E5DFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E5E00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5E04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5E08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E5E0C: 4BB2A8FD  bl 0x82510708
	ctx.lr = 0x829E5E10;
	sub_82510708(ctx, base);
	// 829E5E10: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E5E14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E5E18: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829E5E1C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 829E5E20: D1BF00E4  stfs f13, 0xe4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 829E5E24: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E5E28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829E5E2C: 4099000C  ble cr6, 0x829e5e38
	if !ctx.cr[6].gt {
	pc = 0x829E5E38; continue 'dispatch;
	}
	// 829E5E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5E34: 4BB2A79D  bl 0x825105d0
	ctx.lr = 0x829E5E38;
	sub_825105D0(ctx, base);
	// 829E5E38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E5E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E5E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E5E44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E5E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E5E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5E50 size=72
    let mut pc: u32 = 0x829E5E50;
    'dispatch: loop {
        match pc {
            0x829E5E50 => {
    //   block [0x829E5E50..0x829E5E98)
	// 829E5E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5E54: 487C2319  bl 0x831a816c
	ctx.lr = 0x829E5E58;
	sub_831A8130(ctx, base);
	// 829E5E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5E5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829E5E60: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829E5E64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E5E68: 9BFD0018  stb r31, 0x18(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u8 ) };
	// 829E5E6C: 4BB2BC7D  bl 0x82511ae8
	ctx.lr = 0x829E5E70;
	sub_82511AE8(ctx, base);
	// 829E5E70: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 829E5E74: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E5E98 size=320
    let mut pc: u32 = 0x829E5E98;
    'dispatch: loop {
        match pc {
            0x829E5E98 => {
    //   block [0x829E5E98..0x829E5FD8)
	// 829E5E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5E9C: 487C22D1  bl 0x831a816c
	ctx.lr = 0x829E5EA0;
	sub_831A8130(ctx, base);
	// 829E5EA0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5EA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E5EA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E5EAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5EB0: 48622279  bl 0x83008128
	ctx.lr = 0x829E5EB4;
	sub_83008128(ctx, base);
	// 829E5EB4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829E5EB8: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 829E5EBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E5EC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E5EC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E5EC8: 4B98E249  bl 0x82374110
	ctx.lr = 0x829E5ECC;
	sub_82374110(ctx, base);
	// 829E5ECC: 817F00EC  lwz r11, 0xec(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829E5ED0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E5ED4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829E5ED8: 409A00F8  bne cr6, 0x829e5fd0
	if !ctx.cr[6].eq {
	pc = 0x829E5FD0; continue 'dispatch;
	}
	// 829E5EDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E5EE0: 48622249  bl 0x83008128
	ctx.lr = 0x829E5EE4;
	sub_83008128(ctx, base);
	// 829E5EE4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829E5EE8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E5EEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E5EF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829E5EF4: 4BB6AA65  bl 0x82550958
	ctx.lr = 0x829E5EF8;
	sub_82550958(ctx, base);
	// 829E5EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5EFC: 4BB2BBED  bl 0x82511ae8
	ctx.lr = 0x829E5F00;
	sub_82511AE8(ctx, base);
	// 829E5F00: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 829E5F04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E5F08: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E5F0C: 39200011  li r9, 0x11
	ctx.r[9].s64 = 17;
	// 829E5F10: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 829E5F14: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 829E5F18: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E5FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E5FD8 size=164
    let mut pc: u32 = 0x829E5FD8;
    'dispatch: loop {
        match pc {
            0x829E5FD8 => {
    //   block [0x829E5FD8..0x829E607C)
	// 829E5FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E5FDC: 487C218D  bl 0x831a8168
	ctx.lr = 0x829E5FE0;
	sub_831A8130(ctx, base);
	// 829E5FE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E5FE4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E5FE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E5FEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E5FF0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829E5FF4: 41820038  beq 0x829e602c
	if ctx.cr[0].eq {
	pc = 0x829E602C; continue 'dispatch;
	}
	// 829E5FF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E5FFC: 487C398D  bl 0x831a9988
	ctx.lr = 0x829E6000;
	sub_831A9988(ctx, base);
	// 829E6000: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E6004: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E6008: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829E600C: 487C20ED  bl 0x831a80f8
	ctx.lr = 0x829E6010;
	sub_831A80F8(ctx, base);
	// 829E6010: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E6014: 41820018  beq 0x829e602c
	if ctx.cr[0].eq {
	pc = 0x829E602C; continue 'dispatch;
	}
	// 829E6018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E601C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E6020: 4BFFFE79  bl 0x829e5e98
	ctx.lr = 0x829E6024;
	sub_829E5E98(ctx, base);
	// 829E6024: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E6028: 4800004C  b 0x829e6074
	pc = 0x829E6074; continue 'dispatch;
	// 829E602C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E6030: 419A0034  beq cr6, 0x829e6064
	if ctx.cr[6].eq {
	pc = 0x829E6064; continue 'dispatch;
	}
	// 829E6034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6038: 487C3951  bl 0x831a9988
	ctx.lr = 0x829E603C;
	sub_831A9988(ctx, base);
	// 829E603C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 829E6040: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E6044: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 829E6048: 487C20B1  bl 0x831a80f8
	ctx.lr = 0x829E604C;
	sub_831A80F8(ctx, base);
	// 829E604C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E6050: 41820014  beq 0x829e6064
	if ctx.cr[0].eq {
	pc = 0x829E6064; continue 'dispatch;
	}
	// 829E6054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E6058: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E605C: 4BFFFDF5  bl 0x829e5e50
	ctx.lr = 0x829E6060;
	sub_829E5E50(ctx, base);
	// 829E6060: 4BFFFFC4  b 0x829e6024
	pc = 0x829E6024; continue 'dispatch;
	// 829E6064: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E6068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E606C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E6070: 4BB2C5A9  bl 0x82512618
	ctx.lr = 0x829E6074;
	sub_82512618(ctx, base);
	// 829E6074: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E6078: 487C2140  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E6080 size=352
    let mut pc: u32 = 0x829E6080;
    'dispatch: loop {
        match pc {
            0x829E6080 => {
    //   block [0x829E6080..0x829E61E0)
	// 829E6080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6084: 487C20E9  bl 0x831a816c
	ctx.lr = 0x829E6088;
	sub_831A8130(ctx, base);
	// 829E6088: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E608C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E6090: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 829E6094: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829E6098: 4BB2B941  bl 0x825119d8
	ctx.lr = 0x829E609C;
	sub_825119D8(ctx, base);
	// 829E609C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E60A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E60A4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E60A8: 4840D961  bl 0x82df3a08
	ctx.lr = 0x829E60AC;
	sub_82DF3A08(ctx, base);
	// 829E60AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E60B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E60B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E60B8: 4BB226C9  bl 0x82508780
	ctx.lr = 0x829E60BC;
	sub_82508780(ctx, base);
	// 829E60BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E60C0: 4840D369  bl 0x82df3428
	ctx.lr = 0x829E60C4;
	sub_82DF3428(ctx, base);
	// 829E60C4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E60C8: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 829E60CC: 409A0008  bne cr6, 0x829e60d4
	if !ctx.cr[6].eq {
	pc = 0x829E60D4; continue 'dispatch;
	}
	// 829E60D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E60D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E60D8: 4BB226C9  bl 0x825087a0
	ctx.lr = 0x829E60DC;
	sub_825087A0(ctx, base);
	// 829E60DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E60E0: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E60E4: 48444A05  bl 0x82e2aae8
	ctx.lr = 0x829E60E8;
	sub_82E2AAE8(ctx, base);
	// 829E60E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E60EC: 4BB2C9AD  bl 0x82512a98
	ctx.lr = 0x829E60F0;
	sub_82512A98(ctx, base);
	// 829E60F0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E60F4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 829E60F8: 3D208335  lis r9, -0x7ccb
	ctx.r[9].s64 = -2093678592;
	// 829E60FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6100: 80CB683C  lwz r6, 0x683c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26684 as u32) ) } as u64;
	// 829E6104: 80AA6838  lwz r5, 0x6838(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26680 as u32) ) } as u64;
	// 829E6108: 80896784  lwz r4, 0x6784(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(26500 as u32) ) } as u64;
	// 829E610C: 4B91170D  bl 0x822f7818
	ctx.lr = 0x829E6110;
	sub_822F7818(ctx, base);
	// 829E6110: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E6114: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 829E6118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E611C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E6120: 80AB6888  lwz r5, 0x6888(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26760 as u32) ) } as u64;
	// 829E6124: 808A67D4  lwz r4, 0x67d4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26580 as u32) ) } as u64;
	// 829E6128: 4B911679  bl 0x822f77a0
	ctx.lr = 0x829E612C;
	sub_822F77A0(ctx, base);
	// 829E612C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829E6130: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 829E6134: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E6138: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829E613C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829E6140: 4BAA6149  bl 0x8248c288
	ctx.lr = 0x829E6144;
	sub_8248C288(ctx, base);
	// 829E6144: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6148: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 829E614C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829E6150: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 829E6154: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6158: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829E615C: 484BA5D5  bl 0x82ea0730
	ctx.lr = 0x829E6160;
	sub_82EA0730(ctx, base);
	// 829E6160: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 829E6164: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 829E6168: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 829E616C: C02A7BC4  lfs f1, 0x7bc4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31684 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E6170: 48534081  bl 0x82f1a1f0
	ctx.lr = 0x829E6174;
	sub_82F1A1F0(ctx, base);
	// 829E6174: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E6178: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 829E617C: 4182000C  beq 0x829e6188
	if ctx.cr[0].eq {
	pc = 0x829E6188; continue 'dispatch;
	}
	// 829E6180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6184: 4B9020C5  bl 0x822e8248
	ctx.lr = 0x829E6188;
	sub_822E8248(ctx, base);
	// 829E6188: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E618C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E6190: 388B5D08  addi r4, r11, 0x5d08
	ctx.r[4].s64 = ctx.r[11].s64 + 23816;
	// 829E6194: 4841339D  bl 0x82df9530
	ctx.lr = 0x829E6198;
	sub_82DF9530(ctx, base);
	// 829E6198: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829E619C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E61A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829E61A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E61A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E61AC: 4BB2CEA5  bl 0x82513050
	ctx.lr = 0x829E61B0;
	sub_82513050(ctx, base);
	// 829E61B0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829E61B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E61B8: 419A0008  beq cr6, 0x829e61c0
	if ctx.cr[6].eq {
	pc = 0x829E61C0; continue 'dispatch;
	}
	// 829E61BC: 4B9020AD  bl 0x822e8268
	ctx.lr = 0x829E61C0;
	sub_822E8268(ctx, base);
	// 829E61C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E61C4: 419A000C  beq cr6, 0x829e61d0
	if ctx.cr[6].eq {
	pc = 0x829E61D0; continue 'dispatch;
	}
	// 829E61C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E61CC: 4B90209D  bl 0x822e8268
	ctx.lr = 0x829E61D0;
	sub_822E8268(ctx, base);
	// 829E61D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E61D4: 4844492D  bl 0x82e2ab00
	ctx.lr = 0x829E61D8;
	sub_82E2AB00(ctx, base);
	// 829E61D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E61DC: 487C1FE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E61E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E61E0 size=80
    let mut pc: u32 = 0x829E61E0;
    'dispatch: loop {
        match pc {
            0x829E61E0 => {
    //   block [0x829E61E0..0x829E6230)
	// 829E61E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E61E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E61E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E61EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E61F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E61F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E61F8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E61FC: 396B5D34  addi r11, r11, 0x5d34
	ctx.r[11].s64 = ctx.r[11].s64 + 23860;
	// 829E6200: 394A5D20  addi r10, r10, 0x5d20
	ctx.r[10].s64 = ctx.r[10].s64 + 23840;
	// 829E6204: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E6208: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829E620C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829E6210: 4B93ACE1  bl 0x82320ef0
	ctx.lr = 0x829E6214;
	sub_82320EF0(ctx, base);
	// 829E6214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6218: 4B969139  bl 0x8234f350
	ctx.lr = 0x829E621C;
	sub_8234F350(ctx, base);
	// 829E621C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E6220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E6224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E6228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E622C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E6230 size=8
    let mut pc: u32 = 0x829E6230;
    'dispatch: loop {
        match pc {
            0x829E6230 => {
    //   block [0x829E6230..0x829E6238)
	// 829E6230: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E6234: 4800008C  b 0x829e62c0
	sub_829E62C0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E6238 size=132
    let mut pc: u32 = 0x829E6238;
    'dispatch: loop {
        match pc {
            0x829E6238 => {
    //   block [0x829E6238..0x829E62BC)
	// 829E6238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E623C: 487C1F31  bl 0x831a816c
	ctx.lr = 0x829E6240;
	sub_831A8130(ctx, base);
	// 829E6240: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 829E6244: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 829E6248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E624C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E6250: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829E6254: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E6258: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 829E625C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829E6260: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6264: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829E6268: 4BB2BFF9  bl 0x82512260
	ctx.lr = 0x829E626C;
	sub_82512260(ctx, base);
	// 829E626C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E6270: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E6274: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E6278: 394A5D34  addi r10, r10, 0x5d34
	ctx.r[10].s64 = ctx.r[10].s64 + 23860;
	// 829E627C: 39295D20  addi r9, r9, 0x5d20
	ctx.r[9].s64 = ctx.r[9].s64 + 23840;
	// 829E6280: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E6284: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829E6288: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 829E628C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E6290: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829E6294: 4BA4ED7D  bl 0x82435010
	ctx.lr = 0x829E6298;
	sub_82435010(ctx, base);
	// 829E6298: D3FF00FC  stfs f31, 0xfc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 829E629C: D3DF0100  stfs f30, 0x100(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829E62A0: 93DF00F4  stw r30, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[30].u32 ) };
	// 829E62A4: 93BF00F8  stw r29, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[29].u32 ) };
	// 829E62A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E62AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E62B0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829E62B4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 829E62B8: 487C1F04  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E62C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E62C0 size=76
    let mut pc: u32 = 0x829E62C0;
    'dispatch: loop {
        match pc {
            0x829E62C0 => {
    //   block [0x829E62C0..0x829E630C)
	// 829E62C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E62C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E62C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E62CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E62D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E62D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E62D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E62DC: 4BFFFF05  bl 0x829e61e0
	ctx.lr = 0x829E62E0;
	sub_829E61E0(ctx, base);
	// 829E62E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E62E4: 4182000C  beq 0x829e62f0
	if ctx.cr[0].eq {
	pc = 0x829E62F0; continue 'dispatch;
	}
	// 829E62E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E62EC: 4840C0ED  bl 0x82df23d8
	ctx.lr = 0x829E62F0;
	sub_82DF23D8(ctx, base);
	// 829E62F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E62F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E62F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E62FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E6300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E6304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E6308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6310 size=136
    let mut pc: u32 = 0x829E6310;
    'dispatch: loop {
        match pc {
            0x829E6310 => {
    //   block [0x829E6310..0x829E6398)
	// 829E6310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E6318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E631C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E6320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E6328: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E632C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829E6330: 409A0020  bne cr6, 0x829e6350
	if !ctx.cr[6].eq {
	pc = 0x829E6350; continue 'dispatch;
	}
	// 829E6334: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E6338: 419A0048  beq cr6, 0x829e6380
	if ctx.cr[6].eq {
	pc = 0x829E6380; continue 'dispatch;
	}
	// 829E633C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829E6340: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829E6344: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829E6348: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829E634C: 48000034  b 0x829e6380
	pc = 0x829E6380; continue 'dispatch;
	// 829E6350: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829E6354: 419A002C  beq cr6, 0x829e6380
	if ctx.cr[6].eq {
	pc = 0x829E6380; continue 'dispatch;
	}
	// 829E6358: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E635C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6360: 388BD0E0  addi r4, r11, -0x2f20
	ctx.r[4].s64 = ctx.r[11].s64 + -12064;
	// 829E6364: 487C1D95  bl 0x831a80f8
	ctx.lr = 0x829E6368;
	sub_831A80F8(ctx, base);
	// 829E6368: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E636C: 4182000C  beq 0x829e6378
	if ctx.cr[0].eq {
	pc = 0x829E6378; continue 'dispatch;
	}
	// 829E6370: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E6374: 4800000C  b 0x829e6380
	pc = 0x829E6380; continue 'dispatch;
	// 829E6378: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E637C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E6380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E6384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E6388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E638C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E6390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E6394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6398 size=72
    let mut pc: u32 = 0x829E6398;
    'dispatch: loop {
        match pc {
            0x829E6398 => {
    //   block [0x829E6398..0x829E63E0)
	// 829E6398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E639C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E63A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E63A4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829E63A8: 419A001C  beq cr6, 0x829e63c4
	if ctx.cr[6].eq {
	pc = 0x829E63C4; continue 'dispatch;
	}
	// 829E63AC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E63B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829E63B4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829E63B8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E63BC: 4BFFFF55  bl 0x829e6310
	ctx.lr = 0x829E63C0;
	sub_829E6310(ctx, base);
	// 829E63C0: 48000010  b 0x829e63d0
	pc = 0x829E63D0; continue 'dispatch;
	// 829E63C4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E63C8: 396BD0E0  addi r11, r11, -0x2f20
	ctx.r[11].s64 = ctx.r[11].s64 + -12064;
	// 829E63CC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E63D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E63D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E63D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E63DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E63E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E63E0 size=312
    let mut pc: u32 = 0x829E63E0;
    'dispatch: loop {
        match pc {
            0x829E63E0 => {
    //   block [0x829E63E0..0x829E6518)
	// 829E63E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E63E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E63E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E63EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E63F0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 829E63F4: 487C2685  bl 0x831a8a78
	ctx.lr = 0x829E63F8;
	sub_831A8A40(ctx, base);
	// 829E63F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E63FC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 829E6400: FFE01090  fmr f31, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[2].f64;
	// 829E6404: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E6408: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 829E640C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6410: FFA02090  fmr f29, f4
	ctx.f[29].f64 = ctx.f[4].f64;
	// 829E6414: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829E6418: FF802890  fmr f28, f5
	ctx.f[28].f64 = ctx.f[5].f64;
	// 829E641C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E6420: 4BB2BE41  bl 0x82512260
	ctx.lr = 0x829E6424;
	sub_82512260(ctx, base);
	// 829E6424: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E6428: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E642C: 392B5D94  addi r9, r11, 0x5d94
	ctx.r[9].s64 = ctx.r[11].s64 + 23956;
	// 829E6430: 394A5D80  addi r10, r10, 0x5d80
	ctx.r[10].s64 = ctx.r[10].s64 + 23936;
	// 829E6434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E6438: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E643C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829E6440: 393F00F4  addi r9, r31, 0xf4
	ctx.r[9].s64 = ctx.r[31].s64 + 244;
	// 829E6444: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829E6448: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 829E644C: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829E6450: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829E6454: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 829E6458: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E645C: 913F00F4  stw r9, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 829E6460: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E6464: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 829E6468: 913F00F8  stw r9, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[9].u32 ) };
	// 829E646C: 419A0024  beq cr6, 0x829e6490
	if ctx.cr[6].eq {
	pc = 0x829E6490; continue 'dispatch;
	}
	// 829E6470: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 829E6474: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 829E6478: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E647C: 7D004828  lwarx r8, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 829E6480: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 829E6484: 7D00492D  stwcx. r8, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E6488: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E648C: 4082FFE8  bne 0x829e6474
	if !ctx.cr[0].eq {
	pc = 0x829E6474; continue 'dispatch;
	}
	// 829E6490: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E6494: 810100E4  lwz r8, 0xe4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E6498: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829E649C: 80C100EC  lwz r6, 0xec(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 829E64A0: D3DF0108  stfs f30, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829E64A4: 997F011D  stb r11, 0x11d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(285 as u32), ctx.r[11].u8 ) };
	// 829E64A8: D3BF010C  stfs f29, 0x10c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829E64AC: 997F011C  stb r11, 0x11c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u8 ) };
	// 829E64B0: D3FF0104  stfs f31, 0x104(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 829E64B4: C1A95D78  lfs f13, 0x5d78(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(23928 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E64B8: 911F0114  stw r8, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[8].u32 ) };
	// 829E64BC: C00708A4  lfs f0, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E64C0: 90DF0118  stw r6, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[6].u32 ) };
	// 829E64C4: D1BF00FC  stfs f13, 0xfc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 829E64C8: D01F0100  stfs f0, 0x100(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 829E64CC: D39F0110  stfs f28, 0x110(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829E64D0: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 829E64D4: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 829E64D8: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 829E64DC: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 829E64E0: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 829E64E4: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E64E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E64EC: 419A0008  beq cr6, 0x829e64f4
	if ctx.cr[6].eq {
	pc = 0x829E64F4; continue 'dispatch;
	}
	// 829E64F0: 4B8DA3A1  bl 0x822c0890
	ctx.lr = 0x829E64F4;
	sub_822C0890(ctx, base);
	// 829E64F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E64F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E64FC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 829E6500: 487C25C5  bl 0x831a8ac4
	ctx.lr = 0x829E6504;
	sub_831A8A8C(ctx, base);
	// 829E6504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E6508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E650C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E6510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E6514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E6518 size=8
    let mut pc: u32 = 0x829E6518;
    'dispatch: loop {
        match pc {
            0x829E6518 => {
    //   block [0x829E6518..0x829E6520)
	// 829E6518: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E651C: 480007B4  b 0x829e6cd0
	sub_829E6CD0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6520 size=152
    let mut pc: u32 = 0x829E6520;
    'dispatch: loop {
        match pc {
            0x829E6520 => {
    //   block [0x829E6520..0x829E65B8)
	// 829E6520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E6528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E652C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6534: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E6538: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E653C: 396B5D94  addi r11, r11, 0x5d94
	ctx.r[11].s64 = ctx.r[11].s64 + 23956;
	// 829E6540: 394A5D80  addi r10, r10, 0x5d80
	ctx.r[10].s64 = ctx.r[10].s64 + 23936;
	// 829E6544: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E6548: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829E654C: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 829E6550: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E6554: 419A0008  beq cr6, 0x829e655c
	if ctx.cr[6].eq {
	pc = 0x829E655C; continue 'dispatch;
	}
	// 829E6558: 4B8DA339  bl 0x822c0890
	ctx.lr = 0x829E655C;
	sub_822C0890(ctx, base);
	// 829E655C: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 829E6560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E6564: 419A0008  beq cr6, 0x829e656c
	if ctx.cr[6].eq {
	pc = 0x829E656C; continue 'dispatch;
	}
	// 829E6568: 4B8DA329  bl 0x822c0890
	ctx.lr = 0x829E656C;
	sub_822C0890(ctx, base);
	// 829E656C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829E6570: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E6574: 419A0008  beq cr6, 0x829e657c
	if ctx.cr[6].eq {
	pc = 0x829E657C; continue 'dispatch;
	}
	// 829E6578: 4B8DA319  bl 0x822c0890
	ctx.lr = 0x829E657C;
	sub_822C0890(ctx, base);
	// 829E657C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 829E6580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E6584: 419A0008  beq cr6, 0x829e658c
	if ctx.cr[6].eq {
	pc = 0x829E658C; continue 'dispatch;
	}
	// 829E6588: 4B8DA309  bl 0x822c0890
	ctx.lr = 0x829E658C;
	sub_822C0890(ctx, base);
	// 829E658C: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829E6590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E6594: 419A0008  beq cr6, 0x829e659c
	if ctx.cr[6].eq {
	pc = 0x829E659C; continue 'dispatch;
	}
	// 829E6598: 4B8DA2F9  bl 0x822c0890
	ctx.lr = 0x829E659C;
	sub_822C0890(ctx, base);
	// 829E659C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E65A0: 4B968DB1  bl 0x8234f350
	ctx.lr = 0x829E65A4;
	sub_8234F350(ctx, base);
	// 829E65A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E65A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E65AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E65B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E65B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E65B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E65B8 size=1812
    let mut pc: u32 = 0x829E65B8;
    'dispatch: loop {
        match pc {
            0x829E65B8 => {
    //   block [0x829E65B8..0x829E6CCC)
	// 829E65B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E65BC: 487C1BA9  bl 0x831a8164
	ctx.lr = 0x829E65C0;
	sub_831A8130(ctx, base);
	// 829E65C0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829E65C4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829E65C8: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6CD0 size=76
    let mut pc: u32 = 0x829E6CD0;
    'dispatch: loop {
        match pc {
            0x829E6CD0 => {
    //   block [0x829E6CD0..0x829E6D1C)
	// 829E6CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6CD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E6CD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E6CDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E6CE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6CE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E6CEC: 4BFFF835  bl 0x829e6520
	ctx.lr = 0x829E6CF0;
	sub_829E6520(ctx, base);
	// 829E6CF0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E6CF4: 4182000C  beq 0x829e6d00
	if ctx.cr[0].eq {
	pc = 0x829E6D00; continue 'dispatch;
	}
	// 829E6CF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6CFC: 4840B6DD  bl 0x82df23d8
	ctx.lr = 0x829E6D00;
	sub_82DF23D8(ctx, base);
	// 829E6D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6D04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E6D08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E6D0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E6D10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E6D14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E6D18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E6D20 size=128
    let mut pc: u32 = 0x829E6D20;
    'dispatch: loop {
        match pc {
            0x829E6D20 => {
    //   block [0x829E6D20..0x829E6DA0)
	// 829E6D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E6D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E6D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E6D30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6D34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6D38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E6D3C: 4BB299CD  bl 0x82510708
	ctx.lr = 0x829E6D40;
	sub_82510708(ctx, base);
	// 829E6D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6D44: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E6D48: 4BFFF871  bl 0x829e65b8
	ctx.lr = 0x829E6D4C;
	sub_829E65B8(ctx, base);
	// 829E6D4C: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E6D50: C01F0130  lfs f0, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E6D54: 809F0128  lwz r4, 0x128(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 829E6D58: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829E6D5C: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 829E6D60: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E6D64: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829E6D68: 4198000C  blt cr6, 0x829e6d74
	if ctx.cr[6].lt {
	pc = 0x829E6D74; continue 'dispatch;
	}
	// 829E6D6C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829E6D70: D01F0130  stfs f0, 0x130(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 829E6D74: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E6D78: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829E6D7C: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E6D80: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829E6D84: 48457AB5  bl 0x82e3e838
	ctx.lr = 0x829E6D88;
	sub_82E3E838(ctx, base);
	// 829E6D88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E6D8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E6D90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E6D94: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E6D98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E6D9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E6DA0 size=260
    let mut pc: u32 = 0x829E6DA0;
    'dispatch: loop {
        match pc {
            0x829E6DA0 => {
    //   block [0x829E6DA0..0x829E6EA4)
	// 829E6DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E6DA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E6DAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E6DB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6DB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6DB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E6DBC: 4BB2AD2D  bl 0x82511ae8
	ctx.lr = 0x829E6DC0;
	sub_82511AE8(ctx, base);
	// 829E6DC0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 829E6DC4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E6DC8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E6DCC: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 829E6DD0: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 829E6DD4: 388785AC  addi r4, r7, -0x7a54
	ctx.r[4].s64 = ctx.r[7].s64 + -31316;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6EA8 size=108
    let mut pc: u32 = 0x829E6EA8;
    'dispatch: loop {
        match pc {
            0x829E6EA8 => {
    //   block [0x829E6EA8..0x829E6F14)
	// 829E6EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6EAC: 487C12C1  bl 0x831a816c
	ctx.lr = 0x829E6EB0;
	sub_831A8130(ctx, base);
	// 829E6EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6EB4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E6EB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E6EBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E6EC0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E6EC4: 41820038  beq 0x829e6efc
	if ctx.cr[0].eq {
	pc = 0x829E6EFC; continue 'dispatch;
	}
	// 829E6EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6ECC: 487C2ABD  bl 0x831a9988
	ctx.lr = 0x829E6ED0;
	sub_831A9988(ctx, base);
	// 829E6ED0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E6ED4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E6ED8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829E6EDC: 487C121D  bl 0x831a80f8
	ctx.lr = 0x829E6EE0;
	sub_831A80F8(ctx, base);
	// 829E6EE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E6EE4: 41820018  beq 0x829e6efc
	if ctx.cr[0].eq {
	pc = 0x829E6EFC; continue 'dispatch;
	}
	// 829E6EE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E6EEC: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 829E6EF0: 4BFFFEB1  bl 0x829e6da0
	ctx.lr = 0x829E6EF4;
	sub_829E6DA0(ctx, base);
	// 829E6EF4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E6EF8: 48000014  b 0x829e6f0c
	pc = 0x829E6F0C; continue 'dispatch;
	// 829E6EFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E6F00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E6F04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E6F08: 4BB2B711  bl 0x82512618
	ctx.lr = 0x829E6F0C;
	sub_82512618(ctx, base);
	// 829E6F0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E6F10: 487C12AC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E6F18 size=128
    let mut pc: u32 = 0x829E6F18;
    'dispatch: loop {
        match pc {
            0x829E6F18 => {
    //   block [0x829E6F18..0x829E6F98)
	// 829E6F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6F1C: 487C1251  bl 0x831a816c
	ctx.lr = 0x829E6F20;
	sub_831A8130(ctx, base);
	// 829E6F20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6F24: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829E6F28: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E6F2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E6F30: 3BEBD8BC  addi r31, r11, -0x2744
	ctx.r[31].s64 = ctx.r[11].s64 + -10052;
	// 829E6F34: 816AD8C4  lwz r11, -0x273c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10044 as u32) ) } as u64;
	// 829E6F38: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829E6F3C: 40820024  bne 0x829e6f60
	if !ctx.cr[0].eq {
	pc = 0x829E6F60; continue 'dispatch;
	}
	// 829E6F40: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829E6F44: 3D00829E  lis r8, -0x7d62
	ctx.r[8].s64 = -2103574528;
	// 829E6F48: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829E6F4C: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829E6F50: 39086398  addi r8, r8, 0x6398
	ctx.r[8].s64 = ctx.r[8].s64 + 25496;
	// 829E6F54: 916AD8C4  stw r11, -0x273c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10044 as u32), ctx.r[11].u32 ) };
	// 829E6F58: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829E6F5C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829E6F60: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E6F64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E6F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E6F6C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829E6F70: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829E6F74: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E6F78: 4BC6D649  bl 0x826545c0
	ctx.lr = 0x829E6F7C;
	sub_826545C0(ctx, base);
	// 829E6F7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E6F80: 4182000C  beq 0x829e6f8c
	if ctx.cr[0].eq {
	pc = 0x829E6F8C; continue 'dispatch;
	}
	// 829E6F84: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E6F88: 48000008  b 0x829e6f90
	pc = 0x829E6F90; continue 'dispatch;
	// 829E6F8C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E6F90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E6F94: 487C1228  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E6F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E6F98 size=176
    let mut pc: u32 = 0x829E6F98;
    'dispatch: loop {
        match pc {
            0x829E6F98 => {
    //   block [0x829E6F98..0x829E7048)
	// 829E6F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E6F9C: 487C11D1  bl 0x831a816c
	ctx.lr = 0x829E6FA0;
	sub_831A8130(ctx, base);
	// 829E6FA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E6FA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E6FA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E6FAC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829E6FB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E6FB4: 388B5DF8  addi r4, r11, 0x5df8
	ctx.r[4].s64 = ctx.r[11].s64 + 24056;
	// 829E6FB8: 38A00095  li r5, 0x95
	ctx.r[5].s64 = 149;
	// 829E6FBC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829E6FC0: 4840B429  bl 0x82df23e8
	ctx.lr = 0x829E6FC4;
	sub_82DF23E8(ctx, base);
	// 829E6FC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E6FC8: 41820010  beq 0x829e6fd8
	if ctx.cr[0].eq {
	pc = 0x829E6FD8; continue 'dispatch;
	}
	// 829E6FCC: 4BC15FA5  bl 0x825fcf70
	ctx.lr = 0x829E6FD0;
	sub_825FCF70(ctx, base);
	// 829E6FD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E6FD4: 48000008  b 0x829e6fdc
	pc = 0x829E6FDC; continue 'dispatch;
	// 829E6FD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E6FDC: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 829E6FE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E6FE4: 4BC14815  bl 0x825fb7f8
	ctx.lr = 0x829E6FE8;
	sub_825FB7F8(ctx, base);
	// 829E6FE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E6FEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E6FF0: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E6FF4: 4842F84D  bl 0x82e16840
	ctx.lr = 0x829E6FF8;
	sub_82E16840(ctx, base);
	// 829E6FF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E6FFC: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829E7000: 48430361  bl 0x82e17360
	ctx.lr = 0x829E7004;
	sub_82E17360(ctx, base);
	// 829E7004: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E7008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E700C: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 829E7010: 83DF0120  lwz r30, 0x120(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829E7014: 4841251D  bl 0x82df9530
	ctx.lr = 0x829E7018;
	sub_82DF9530(ctx, base);
	// 829E7018: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E701C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829E7020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7024: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7028: 48430721  bl 0x82e17748
	ctx.lr = 0x829E702C;
	sub_82E17748(ctx, base);
	// 829E702C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E7030: 809F0128  lwz r4, 0x128(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 829E7034: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829E7038: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E703C: 484577FD  bl 0x82e3e838
	ctx.lr = 0x829E7040;
	sub_82E3E838(ctx, base);
	// 829E7040: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E7044: 487C1178  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E7048 size=956
    let mut pc: u32 = 0x829E7048;
    'dispatch: loop {
        match pc {
            0x829E7048 => {
    //   block [0x829E7048..0x829E7404)
	// 829E7048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E704C: 487C1119  bl 0x831a8164
	ctx.lr = 0x829E7050;
	sub_831A8130(ctx, base);
	// 829E7050: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7054: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E7058: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E705C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829E7060: 4BB2A979  bl 0x825119d8
	ctx.lr = 0x829E7064;
	sub_825119D8(ctx, base);
	// 829E7064: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E7068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E706C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E7070: 4840C999  bl 0x82df3a08
	ctx.lr = 0x829E7074;
	sub_82DF3A08(ctx, base);
	// 829E7074: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E7078: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E707C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7080: 4BB21701  bl 0x82508780
	ctx.lr = 0x829E7084;
	sub_82508780(ctx, base);
	// 829E7084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7088: 4840C3A1  bl 0x82df3428
	ctx.lr = 0x829E708C;
	sub_82DF3428(ctx, base);
	// 829E708C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829E7090: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E7094: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829E7098: 409A0008  bne cr6, 0x829e70a0
	if !ctx.cr[6].eq {
	pc = 0x829E70A0; continue 'dispatch;
	}
	// 829E709C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E70A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E70A4: 4BB216FD  bl 0x825087a0
	ctx.lr = 0x829E70A8;
	sub_825087A0(ctx, base);
	// 829E70A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829E70AC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E70B0: 48443A39  bl 0x82e2aae8
	ctx.lr = 0x829E70B4;
	sub_82E2AAE8(ctx, base);
	// 829E70B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E70B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E70BC: 388B5E88  addi r4, r11, 0x5e88
	ctx.r[4].s64 = ctx.r[11].s64 + 24200;
	// 829E70C0: 4840C949  bl 0x82df3a08
	ctx.lr = 0x829E70C4;
	sub_82DF3A08(ctx, base);
	// 829E70C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E70C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E70CC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829E70D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E70D4: 48447D9D  bl 0x82e2ee70
	ctx.lr = 0x829E70D8;
	sub_82E2EE70(ctx, base);
	// 829E70D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E70DC: 4840C34D  bl 0x82df3428
	ctx.lr = 0x829E70E0;
	sub_82DF3428(ctx, base);
	// 829E70E0: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829E70E4: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 829E70E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E70EC: 419A00F8  beq cr6, 0x829e71e4
	if ctx.cr[6].eq {
	pc = 0x829E71E4; continue 'dispatch;
	}
	// 829E70F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E70F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E70F8: 388B5DF8  addi r4, r11, 0x5df8
	ctx.r[4].s64 = ctx.r[11].s64 + 24056;
	// 829E70FC: 38A00071  li r5, 0x71
	ctx.r[5].s64 = 113;
	// 829E7100: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 829E7104: 4840B2E5  bl 0x82df23e8
	ctx.lr = 0x829E7108;
	sub_82DF23E8(ctx, base);
	// 829E7108: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E710C: 41820014  beq 0x829e7120
	if ctx.cr[0].eq {
	pc = 0x829E7120; continue 'dispatch;
	}
	// 829E7110: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 829E7114: 4842F77D  bl 0x82e16890
	ctx.lr = 0x829E7118;
	sub_82E16890(ctx, base);
	// 829E7118: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E711C: 48000008  b 0x829e7124
	pc = 0x829E7124; continue 'dispatch;
	// 829E7120: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E7124: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829E7128: 4B976249  bl 0x8235d370
	ctx.lr = 0x829E712C;
	sub_8235D370(ctx, base);
	// 829E712C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E7130: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829E7134: C06B08A4  lfs f3, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829E7138: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 829E713C: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 829E7140: 837F00E4  lwz r27, 0xe4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E7144: 48494E2D  bl 0x82e7bf70
	ctx.lr = 0x829E7148;
	sub_82E7BF70(ctx, base);
	// 829E7148: 815B0084  lwz r10, 0x84(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(132 as u32) ) } as u64;
	// 829E714C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829E7150: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 829E7154: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 829E7158: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 829E715C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 829E7160: 13E03C07  vcmpneb. (lvlx128) v31, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E7164: 13C83C07  vcmpneb. (lvlx128) v30, v8, v7
	tmp.u32 = ctx.r[8].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E7168: 13BE3C07  vcmpneb. (lvlx128) v29, v30, v7
	tmp.u32 = ctx.r[30].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E716C: 13893C07  vcmpneb. (lvlx128) v28, v9, v7
	tmp.u32 = ctx.r[9].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7408 size=136
    let mut pc: u32 = 0x829E7408;
    'dispatch: loop {
        match pc {
            0x829E7408 => {
    //   block [0x829E7408..0x829E7490)
	// 829E7408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E740C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E7414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E7418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E741C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E7420: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E7424: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829E7428: 409A0020  bne cr6, 0x829e7448
	if !ctx.cr[6].eq {
	pc = 0x829E7448; continue 'dispatch;
	}
	// 829E742C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E7430: 419A0048  beq cr6, 0x829e7478
	if ctx.cr[6].eq {
	pc = 0x829E7478; continue 'dispatch;
	}
	// 829E7434: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829E7438: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829E743C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829E7440: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829E7444: 48000034  b 0x829e7478
	pc = 0x829E7478; continue 'dispatch;
	// 829E7448: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829E744C: 419A002C  beq cr6, 0x829e7478
	if ctx.cr[6].eq {
	pc = 0x829E7478; continue 'dispatch;
	}
	// 829E7450: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E7454: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7458: 388BD2E8  addi r4, r11, -0x2d18
	ctx.r[4].s64 = ctx.r[11].s64 + -11544;
	// 829E745C: 487C0C9D  bl 0x831a80f8
	ctx.lr = 0x829E7460;
	sub_831A80F8(ctx, base);
	// 829E7460: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E7464: 4182000C  beq 0x829e7470
	if ctx.cr[0].eq {
	pc = 0x829E7470; continue 'dispatch;
	}
	// 829E7468: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E746C: 4800000C  b 0x829e7478
	pc = 0x829E7478; continue 'dispatch;
	// 829E7470: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E7474: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E7478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E747C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E7480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E7488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E748C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7490 size=196
    let mut pc: u32 = 0x829E7490;
    'dispatch: loop {
        match pc {
            0x829E7490 => {
    //   block [0x829E7490..0x829E7554)
	// 829E7490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E749C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E74A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E74A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E74A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E74AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829E74B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E74B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E74B8: 4B8D9481  bl 0x822c0938
	ctx.lr = 0x829E74BC;
	sub_822C0938(ctx, base);
	// 829E74BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E74C0: 41820028  beq 0x829e74e8
	if ctx.cr[0].eq {
	pc = 0x829E74E8; continue 'dispatch;
	}
	// 829E74C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E74C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829E74CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E74D0: 392B5EA4  addi r9, r11, 0x5ea4
	ctx.r[9].s64 = ctx.r[11].s64 + 24228;
	// 829E74D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829E74D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E74DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E74E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829E74E4: 48000008  b 0x829e74ec
	pc = 0x829E74EC; continue 'dispatch;
	// 829E74E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E74EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E74F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E74F4: 409A0044  bne cr6, 0x829e7538
	if !ctx.cr[6].eq {
	pc = 0x829E7538; continue 'dispatch;
	}
	// 829E74F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E74FC: 419A001C  beq cr6, 0x829e7518
	if ctx.cr[6].eq {
	pc = 0x829E7518; continue 'dispatch;
	}
	// 829E7500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7504: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E7508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E750C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E7514: 4E800421  bctrl
	ctx.lr = 0x829E7518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E7518: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E751C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E7520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7524: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829E7528: 816BD21C  lwz r11, -0x2de4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11748 as u32) ) } as u64;
	// 829E752C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E7530: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E7534: 4B8D8ACD  bl 0x822c0000
	ctx.lr = 0x829E7538;
	sub_822C0000(ctx, base);
	// 829E7538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E753C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E7540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E7544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E754C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E7550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7558 size=196
    let mut pc: u32 = 0x829E7558;
    'dispatch: loop {
        match pc {
            0x829E7558 => {
    //   block [0x829E7558..0x829E761C)
	// 829E7558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E755C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E7564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E7568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E756C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E7570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E7574: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829E7578: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E757C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E7580: 4B8D93B9  bl 0x822c0938
	ctx.lr = 0x829E7584;
	sub_822C0938(ctx, base);
	// 829E7584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E7588: 41820028  beq 0x829e75b0
	if ctx.cr[0].eq {
	pc = 0x829E75B0; continue 'dispatch;
	}
	// 829E758C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E7590: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829E7594: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E7598: 392B5EB8  addi r9, r11, 0x5eb8
	ctx.r[9].s64 = ctx.r[11].s64 + 24248;
	// 829E759C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829E75A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E75A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E75A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829E75AC: 48000008  b 0x829e75b4
	pc = 0x829E75B4; continue 'dispatch;
	// 829E75B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E75B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E75B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E75BC: 409A0044  bne cr6, 0x829e7600
	if !ctx.cr[6].eq {
	pc = 0x829E7600; continue 'dispatch;
	}
	// 829E75C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E75C4: 419A001C  beq cr6, 0x829e75e0
	if ctx.cr[6].eq {
	pc = 0x829E75E0; continue 'dispatch;
	}
	// 829E75C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E75CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E75D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E75D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E75D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E75DC: 4E800421  bctrl
	ctx.lr = 0x829E75E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E75E0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E75E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E75E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E75EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829E75F0: 816BD21C  lwz r11, -0x2de4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11748 as u32) ) } as u64;
	// 829E75F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E75F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E75FC: 4B8D8A05  bl 0x822c0000
	ctx.lr = 0x829E7600;
	sub_822C0000(ctx, base);
	// 829E7600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E7608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E760C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7610: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E7614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E7618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7620 size=72
    let mut pc: u32 = 0x829E7620;
    'dispatch: loop {
        match pc {
            0x829E7620 => {
    //   block [0x829E7620..0x829E7668)
	// 829E7620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7628: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E762C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829E7630: 419A001C  beq cr6, 0x829e764c
	if ctx.cr[6].eq {
	pc = 0x829E764C; continue 'dispatch;
	}
	// 829E7634: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E7638: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829E763C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829E7640: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7644: 4BFFFDC5  bl 0x829e7408
	ctx.lr = 0x829E7648;
	sub_829E7408(ctx, base);
	// 829E7648: 48000010  b 0x829e7658
	pc = 0x829E7658; continue 'dispatch;
	// 829E764C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E7650: 396BD2E8  addi r11, r11, -0x2d18
	ctx.r[11].s64 = ctx.r[11].s64 + -11544;
	// 829E7654: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E7658: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E765C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E7660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E7668 size=348
    let mut pc: u32 = 0x829E7668;
    'dispatch: loop {
        match pc {
            0x829E7668 => {
    //   block [0x829E7668..0x829E77C4)
	// 829E7668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E766C: 487C0AF5  bl 0x831a8160
	ctx.lr = 0x829E7670;
	sub_831A8130(ctx, base);
	// 829E7670: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 829E7674: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 829E7678: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829E767C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7680: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E7684: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 829E7688: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829E768C: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 829E7690: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829E7694: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 829E7698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E769C: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 829E76A0: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 829E76A4: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 829E76A8: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 829E76AC: 4BB2ABB5  bl 0x82512260
	ctx.lr = 0x829E76B0;
	sub_82512260(ctx, base);
	// 829E76B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E76B4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E76B8: 392B5EEC  addi r9, r11, 0x5eec
	ctx.r[9].s64 = ctx.r[11].s64 + 24300;
	// 829E76BC: 394A5ED4  addi r10, r10, 0x5ed4
	ctx.r[10].s64 = ctx.r[10].s64 + 24276;
	// 829E76C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E76C4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E76C8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829E76CC: 39000100  li r8, 0x100
	ctx.r[8].s64 = 256;
	// 829E76D0: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829E76D4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829E76D8: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829E76DC: 393F012C  addi r9, r31, 0x12c
	ctx.r[9].s64 = ctx.r[31].s64 + 300;
	// 829E76E0: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829E76E4: 395E0004  addi r10, r30, 4
	ctx.r[10].s64 = ctx.r[30].s64 + 4;
	// 829E76E8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 829E76EC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 829E76F0: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 829E76F4: 13E0D0C7  vcmpequd (lvx128) v31, v0, v26
	tmp.u32 = ctx.r[26].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E77C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E77C8 size=8
    let mut pc: u32 = 0x829E77C8;
    'dispatch: loop {
        match pc {
            0x829E77C8 => {
    //   block [0x829E77C8..0x829E77D0)
	// 829E77C8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E77CC: 480005AC  b 0x829e7d78
	sub_829E7D78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E77D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E77D0 size=228
    let mut pc: u32 = 0x829E77D0;
    'dispatch: loop {
        match pc {
            0x829E77D0 => {
    //   block [0x829E77D0..0x829E78B4)
	// 829E77D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E77D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E77D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E77DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E77E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E77E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E77E8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829E77EC: 396B5EEC  addi r11, r11, 0x5eec
	ctx.r[11].s64 = ctx.r[11].s64 + 24300;
	// 829E77F0: 39295ED4  addi r9, r9, 0x5ed4
	ctx.r[9].s64 = ctx.r[9].s64 + 24276;
	// 829E77F4: 815F012C  lwz r10, 0x12c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 829E77F8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 829E77FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E7800: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E7804: 990A0040  stb r8, 0x40(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(64 as u32), ctx.r[8].u8 ) };
	// 829E7808: 807F0168  lwz r3, 0x168(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 829E780C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7810: 419A0008  beq cr6, 0x829e7818
	if ctx.cr[6].eq {
	pc = 0x829E7818; continue 'dispatch;
	}
	// 829E7814: 4B8D907D  bl 0x822c0890
	ctx.lr = 0x829E7818;
	sub_822C0890(ctx, base);
	// 829E7818: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 829E781C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7820: 419A0008  beq cr6, 0x829e7828
	if ctx.cr[6].eq {
	pc = 0x829E7828; continue 'dispatch;
	}
	// 829E7824: 4B8D906D  bl 0x822c0890
	ctx.lr = 0x829E7828;
	sub_822C0890(ctx, base);
	// 829E7828: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 829E782C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7830: 419A0008  beq cr6, 0x829e7838
	if ctx.cr[6].eq {
	pc = 0x829E7838; continue 'dispatch;
	}
	// 829E7834: 4B8D905D  bl 0x822c0890
	ctx.lr = 0x829E7838;
	sub_822C0890(ctx, base);
	// 829E7838: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 829E783C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7840: 419A0008  beq cr6, 0x829e7848
	if ctx.cr[6].eq {
	pc = 0x829E7848; continue 'dispatch;
	}
	// 829E7844: 4B8D904D  bl 0x822c0890
	ctx.lr = 0x829E7848;
	sub_822C0890(ctx, base);
	// 829E7848: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 829E784C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7850: 419A0008  beq cr6, 0x829e7858
	if ctx.cr[6].eq {
	pc = 0x829E7858; continue 'dispatch;
	}
	// 829E7854: 4B8D903D  bl 0x822c0890
	ctx.lr = 0x829E7858;
	sub_822C0890(ctx, base);
	// 829E7858: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 829E785C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7860: 419A0008  beq cr6, 0x829e7868
	if ctx.cr[6].eq {
	pc = 0x829E7868; continue 'dispatch;
	}
	// 829E7864: 4B8D902D  bl 0x822c0890
	ctx.lr = 0x829E7868;
	sub_822C0890(ctx, base);
	// 829E7868: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829E786C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7870: 419A0008  beq cr6, 0x829e7878
	if ctx.cr[6].eq {
	pc = 0x829E7878; continue 'dispatch;
	}
	// 829E7874: 4B8D901D  bl 0x822c0890
	ctx.lr = 0x829E7878;
	sub_822C0890(ctx, base);
	// 829E7878: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 829E787C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7880: 419A0008  beq cr6, 0x829e7888
	if ctx.cr[6].eq {
	pc = 0x829E7888; continue 'dispatch;
	}
	// 829E7884: 4B8D900D  bl 0x822c0890
	ctx.lr = 0x829E7888;
	sub_822C0890(ctx, base);
	// 829E7888: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829E788C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7890: 419A0008  beq cr6, 0x829e7898
	if ctx.cr[6].eq {
	pc = 0x829E7898; continue 'dispatch;
	}
	// 829E7894: 4B8D8FFD  bl 0x822c0890
	ctx.lr = 0x829E7898;
	sub_822C0890(ctx, base);
	// 829E7898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E789C: 4B967AB5  bl 0x8234f350
	ctx.lr = 0x829E78A0;
	sub_8234F350(ctx, base);
	// 829E78A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829E78A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E78A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E78AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E78B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E78B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E78B8 size=652
    let mut pc: u32 = 0x829E78B8;
    'dispatch: loop {
        match pc {
            0x829E78B8 => {
    //   block [0x829E78B8..0x829E7B44)
	// 829E78B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E78BC: 487C08AD  bl 0x831a8168
	ctx.lr = 0x829E78C0;
	sub_831A8130(ctx, base);
	// 829E78C0: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7B48 size=132
    let mut pc: u32 = 0x829E7B48;
    'dispatch: loop {
        match pc {
            0x829E7B48 => {
    //   block [0x829E7B48..0x829E7BCC)
	// 829E7B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7B4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7B50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E7B54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E7B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7B5C: 816300F4  lwz r11, 0xf4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(244 as u32) ) } as u64;
	// 829E7B60: 3BE300F4  addi r31, r3, 0xf4
	ctx.r[31].s64 = ctx.r[3].s64 + 244;
	// 829E7B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7B68: 419A004C  beq cr6, 0x829e7bb4
	if ctx.cr[6].eq {
	pc = 0x829E7BB4; continue 'dispatch;
	}
	// 829E7B6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7B70: 4BB22DE1  bl 0x8250a950
	ctx.lr = 0x829E7B74;
	sub_8250A950(ctx, base);
	// 829E7B74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7B78: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E7B7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7B80: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829E7B84: 409A0008  bne cr6, 0x829e7b8c
	if !ctx.cr[6].eq {
	pc = 0x829E7B8C; continue 'dispatch;
	}
	// 829E7B88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7B8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7B90: 4BDEBDE1  bl 0x827d3970
	ctx.lr = 0x829E7B94;
	sub_827D3970(ctx, base);
	// 829E7B94: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829E7B98: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E7B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E7BA0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829E7BA4: 419A0008  beq cr6, 0x829e7bac
	if ctx.cr[6].eq {
	pc = 0x829E7BAC; continue 'dispatch;
	}
	// 829E7BA8: 4B8D8CE9  bl 0x822c0890
	ctx.lr = 0x829E7BAC;
	sub_822C0890(ctx, base);
	// 829E7BAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7BB0: 4840A0E1  bl 0x82df1c90
	ctx.lr = 0x829E7BB4;
	sub_82DF1C90(ctx, base);
	// 829E7BB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E7BB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E7BBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7BC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E7BC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E7BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7BD0 size=116
    let mut pc: u32 = 0x829E7BD0;
    'dispatch: loop {
        match pc {
            0x829E7BD0 => {
    //   block [0x829E7BD0..0x829E7C44)
	// 829E7BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E7BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E7BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E7BE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E7BEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7BF4: 4BB278D5  bl 0x8250f4c8
	ctx.lr = 0x829E7BF8;
	sub_8250F4C8(ctx, base);
	// 829E7BF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7C00: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829E7C04: 409A0008  bne cr6, 0x829e7c0c
	if !ctx.cr[6].eq {
	pc = 0x829E7C0C; continue 'dispatch;
	}
	// 829E7C08: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829E7C0C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E7C10: 4BB20E09  bl 0x82508a18
	ctx.lr = 0x829E7C14;
	sub_82508A18(ctx, base);
	// 829E7C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7C18: 48620511  bl 0x83008128
	ctx.lr = 0x829E7C1C;
	sub_83008128(ctx, base);
	// 829E7C1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7C20: 4840A071  bl 0x82df1c90
	ctx.lr = 0x829E7C24;
	sub_82DF1C90(ctx, base);
	// 829E7C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7C28: 4BFFFC91  bl 0x829e78b8
	ctx.lr = 0x829E7C2C;
	sub_829E78B8(ctx, base);
	// 829E7C2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E7C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E7C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7C38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E7C3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E7C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E7C48 size=4
    let mut pc: u32 = 0x829E7C48;
    'dispatch: loop {
        match pc {
            0x829E7C48 => {
    //   block [0x829E7C48..0x829E7C4C)
	// 829E7C48: 4BFFFC70  b 0x829e78b8
	sub_829E78B8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7C50 size=124
    let mut pc: u32 = 0x829E7C50;
    'dispatch: loop {
        match pc {
            0x829E7C50 => {
    //   block [0x829E7C50..0x829E7CCC)
	// 829E7C50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7C54: 487C0519  bl 0x831a816c
	ctx.lr = 0x829E7C58;
	sub_831A8130(ctx, base);
	// 829E7C58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7C5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E7C60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E7C64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E7C68: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829E7C6C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829E7C70: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 829E7C74: 4840A775  bl 0x82df23e8
	ctx.lr = 0x829E7C78;
	sub_82DF23E8(ctx, base);
	// 829E7C78: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829E7C7C: 4182001C  beq 0x829e7c98
	if ctx.cr[0].eq {
	pc = 0x829E7C98; continue 'dispatch;
	}
	// 829E7C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7C84: 48471A1D  bl 0x82e596a0
	ctx.lr = 0x829E7C88;
	sub_82E596A0(ctx, base);
	// 829E7C88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E7C8C: 396B5ECC  addi r11, r11, 0x5ecc
	ctx.r[11].s64 = ctx.r[11].s64 + 24268;
	// 829E7C90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E7C94: 48000008  b 0x829e7c9c
	pc = 0x829E7C9C; continue 'dispatch;
	// 829E7C98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E7C9C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E7CA0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829E7CA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7CAC: 4BFFF8AD  bl 0x829e7558
	ctx.lr = 0x829E7CB0;
	sub_829E7558(ctx, base);
	// 829E7CB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E7CB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7CB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7CBC: 4B8D8345  bl 0x822c0000
	ctx.lr = 0x829E7CC0;
	sub_822C0000(ctx, base);
	// 829E7CC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E7CC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E7CC8: 487C04F4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7CD0 size=164
    let mut pc: u32 = 0x829E7CD0;
    'dispatch: loop {
        match pc {
            0x829E7CD0 => {
    //   block [0x829E7CD0..0x829E7D74)
	// 829E7CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7CD4: 487C0495  bl 0x831a8168
	ctx.lr = 0x829E7CD8;
	sub_831A8130(ctx, base);
	// 829E7CD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7CDC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E7CE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E7CE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E7CE8: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829E7CEC: 41820038  beq 0x829e7d24
	if ctx.cr[0].eq {
	pc = 0x829E7D24; continue 'dispatch;
	}
	// 829E7CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7CF4: 487C1C95  bl 0x831a9988
	ctx.lr = 0x829E7CF8;
	sub_831A9988(ctx, base);
	// 829E7CF8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E7CFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E7D00: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829E7D04: 487C03F5  bl 0x831a80f8
	ctx.lr = 0x829E7D08;
	sub_831A80F8(ctx, base);
	// 829E7D08: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E7D0C: 41820018  beq 0x829e7d24
	if ctx.cr[0].eq {
	pc = 0x829E7D24; continue 'dispatch;
	}
	// 829E7D10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7D14: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E7D18: 4BFFFEB9  bl 0x829e7bd0
	ctx.lr = 0x829E7D1C;
	sub_829E7BD0(ctx, base);
	// 829E7D1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E7D20: 4800004C  b 0x829e7d6c
	pc = 0x829E7D6C; continue 'dispatch;
	// 829E7D24: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E7D28: 419A0034  beq cr6, 0x829e7d5c
	if ctx.cr[6].eq {
	pc = 0x829E7D5C; continue 'dispatch;
	}
	// 829E7D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7D30: 487C1C59  bl 0x831a9988
	ctx.lr = 0x829E7D34;
	sub_831A9988(ctx, base);
	// 829E7D34: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829E7D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E7D3C: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829E7D40: 487C03B9  bl 0x831a80f8
	ctx.lr = 0x829E7D44;
	sub_831A80F8(ctx, base);
	// 829E7D44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E7D48: 41820014  beq 0x829e7d5c
	if ctx.cr[0].eq {
	pc = 0x829E7D5C; continue 'dispatch;
	}
	// 829E7D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7D50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E7D54: 4BFFFEF5  bl 0x829e7c48
	ctx.lr = 0x829E7D58;
	sub_829E7C48(ctx, base);
	// 829E7D58: 4BFFFFC4  b 0x829e7d1c
	pc = 0x829E7D1C; continue 'dispatch;
	// 829E7D5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E7D60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E7D64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7D68: 4BB2A8B1  bl 0x82512618
	ctx.lr = 0x829E7D6C;
	sub_82512618(ctx, base);
	// 829E7D6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E7D70: 487C0448  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7D78 size=76
    let mut pc: u32 = 0x829E7D78;
    'dispatch: loop {
        match pc {
            0x829E7D78 => {
    //   block [0x829E7D78..0x829E7DC4)
	// 829E7D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E7D80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E7D84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E7D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7D8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E7D90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E7D94: 4BFFFA3D  bl 0x829e77d0
	ctx.lr = 0x829E7D98;
	sub_829E77D0(ctx, base);
	// 829E7D98: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E7D9C: 4182000C  beq 0x829e7da8
	if ctx.cr[0].eq {
	pc = 0x829E7DA8; continue 'dispatch;
	}
	// 829E7DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7DA4: 4840A635  bl 0x82df23d8
	ctx.lr = 0x829E7DA8;
	sub_82DF23D8(ctx, base);
	// 829E7DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7DAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E7DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E7DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E7DB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E7DBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E7DC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E7DC8 size=128
    let mut pc: u32 = 0x829E7DC8;
    'dispatch: loop {
        match pc {
            0x829E7DC8 => {
    //   block [0x829E7DC8..0x829E7E48)
	// 829E7DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7DCC: 487C03A1  bl 0x831a816c
	ctx.lr = 0x829E7DD0;
	sub_831A8130(ctx, base);
	// 829E7DD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7DD4: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829E7DD8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E7DDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E7DE0: 3BEBD8C8  addi r31, r11, -0x2738
	ctx.r[31].s64 = ctx.r[11].s64 + -10040;
	// 829E7DE4: 816AD8D0  lwz r11, -0x2730(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10032 as u32) ) } as u64;
	// 829E7DE8: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829E7DEC: 40820024  bne 0x829e7e10
	if !ctx.cr[0].eq {
	pc = 0x829E7E10; continue 'dispatch;
	}
	// 829E7DF0: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829E7DF4: 3D00829E  lis r8, -0x7d62
	ctx.r[8].s64 = -2103574528;
	// 829E7DF8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829E7DFC: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829E7E00: 39087620  addi r8, r8, 0x7620
	ctx.r[8].s64 = ctx.r[8].s64 + 30240;
	// 829E7E04: 916AD8D0  stw r11, -0x2730(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10032 as u32), ctx.r[11].u32 ) };
	// 829E7E08: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829E7E0C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829E7E10: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829E7E14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829E7E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7E1C: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829E7E20: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829E7E24: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E7E28: 4BC6C799  bl 0x826545c0
	ctx.lr = 0x829E7E2C;
	sub_826545C0(ctx, base);
	// 829E7E2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E7E30: 4182000C  beq 0x829e7e3c
	if ctx.cr[0].eq {
	pc = 0x829E7E3C; continue 'dispatch;
	}
	// 829E7E34: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829E7E38: 48000008  b 0x829e7e40
	pc = 0x829E7E40; continue 'dispatch;
	// 829E7E3C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829E7E40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E7E44: 487C0378  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E7E48 size=176
    let mut pc: u32 = 0x829E7E48;
    'dispatch: loop {
        match pc {
            0x829E7E48 => {
    //   block [0x829E7E48..0x829E7EF8)
	// 829E7E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7E4C: 487C0321  bl 0x831a816c
	ctx.lr = 0x829E7E50;
	sub_831A8130(ctx, base);
	// 829E7E50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7E54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E7E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E7E5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829E7E60: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E7E64: 388B5F58  addi r4, r11, 0x5f58
	ctx.r[4].s64 = ctx.r[11].s64 + 24408;
	// 829E7E68: 38A00117  li r5, 0x117
	ctx.r[5].s64 = 279;
	// 829E7E6C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829E7E70: 4840A579  bl 0x82df23e8
	ctx.lr = 0x829E7E74;
	sub_82DF23E8(ctx, base);
	// 829E7E74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E7E78: 41820010  beq 0x829e7e88
	if ctx.cr[0].eq {
	pc = 0x829E7E88; continue 'dispatch;
	}
	// 829E7E7C: 4BC150F5  bl 0x825fcf70
	ctx.lr = 0x829E7E80;
	sub_825FCF70(ctx, base);
	// 829E7E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E7E84: 48000008  b 0x829e7e8c
	pc = 0x829E7E8C; continue 'dispatch;
	// 829E7E88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E7E8C: 3BDF0150  addi r30, r31, 0x150
	ctx.r[30].s64 = ctx.r[31].s64 + 336;
	// 829E7E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7E94: 4BC13965  bl 0x825fb7f8
	ctx.lr = 0x829E7E98;
	sub_825FB7F8(ctx, base);
	// 829E7E98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E7E9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E7EA0: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E7EA4: 4842E99D  bl 0x82e16840
	ctx.lr = 0x829E7EA8;
	sub_82E16840(ctx, base);
	// 829E7EA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E7EAC: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 829E7EB0: 4842F4B1  bl 0x82e17360
	ctx.lr = 0x829E7EB4;
	sub_82E17360(ctx, base);
	// 829E7EB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829E7EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E7EBC: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 829E7EC0: 83DF0150  lwz r30, 0x150(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 829E7EC4: 4841166D  bl 0x82df9530
	ctx.lr = 0x829E7EC8;
	sub_82DF9530(ctx, base);
	// 829E7EC8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E7ECC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 829E7ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E7ED4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7ED8: 4842F871  bl 0x82e17748
	ctx.lr = 0x829E7EDC;
	sub_82E17748(ctx, base);
	// 829E7EDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E7EE0: 809F0158  lwz r4, 0x158(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829E7EE4: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 829E7EE8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E7EEC: 4845694D  bl 0x82e3e838
	ctx.lr = 0x829E7EF0;
	sub_82E3E838(ctx, base);
	// 829E7EF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E7EF4: 487C02C8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E7EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E7EF8 size=3044
    let mut pc: u32 = 0x829E7EF8;
    'dispatch: loop {
        match pc {
            0x829E7EF8 => {
    //   block [0x829E7EF8..0x829E8ADC)
	// 829E7EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E7EFC: 487C0259  bl 0x831a8154
	ctx.lr = 0x829E7F00;
	sub_831A8130(ctx, base);
	// 829E7F00: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 829E7F04: 487C0B65  bl 0x831a8a68
	ctx.lr = 0x829E7F08;
	sub_831A8A40(ctx, base);
	// 829E7F08: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 829E7F0C: 487C2CE9  bl 0x831aabf4
	ctx.lr = 0x829E7F10;
	sub_831AA9A0(ctx, base);
	// 829E7F10: 9421FAF0  stwu r1, -0x510(r1)
	ea = ctx.r[1].u32.wrapping_add(-1296 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E7F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E7F18: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 829E7F1C: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 829E7F20: D361052C  stfs f27, 0x52c(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1324 as u32), tmp.u32 ) };
	// 829E7F24: 4BFE0BBD  bl 0x829c8ae0
	ctx.lr = 0x829E7F28;
	sub_829C8AE0(ctx, base);
	// 829E7F28: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E7F2C: 8161017C  lwz r11, 0x17c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(380 as u32) ) } as u64;
	// 829E7F30: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 829E7F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E7F38: 555EDFFE  rlwinm r30, r10, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 829E7F3C: 419A000C  beq cr6, 0x829e7f48
	if ctx.cr[6].eq {
	pc = 0x829E7F48; continue 'dispatch;
	}
	// 829E7F40: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 829E7F44: 4B8D894D  bl 0x822c0890
	ctx.lr = 0x829E7F48;
	sub_822C0890(ctx, base);
	// 829E7F48: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E7F4C: 41820010  beq 0x829e7f5c
	if ctx.cr[0].eq {
	pc = 0x829E7F5C; continue 'dispatch;
	}
	// 829E7F50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E7F54: 4BB2867D  bl 0x825105d0
	ctx.lr = 0x829E7F58;
	sub_825105D0(ctx, base);
	// 829E7F58: 48000B6C  b 0x829e8ac4
	pc = 0x829E8AC4; continue 'dispatch;
	// 829E7F5C: C01F0120  lfs f0, 0x120(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E7F60: 3B3F0110  addi r25, r31, 0x110
	ctx.r[25].s64 = ctx.r[31].s64 + 272;
	// 829E7F64: EC1B002A  fadds f0, f27, f0
	ctx.f[0].f64 = ((ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64;
	// 829E7F68: D01F0120  stfs f0, 0x120(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 829E7F6C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 829E7F70: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829E7F74: 484954DD  bl 0x82e7d450
	ctx.lr = 0x829E7F78;
	sub_82E7D450(ctx, base);
	// 829E7F78: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829E7F7C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829E7F80: 897F0134  lbz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 829E7F84: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829E7F88: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 829E7F8C: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 829E7F90: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 829E7F94: C34ACEE4  lfs f26, -0x311c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 829E7F98: C3299584  lfs f25, -0x6a7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27260 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 829E7F9C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829E7FA0: C3A8D0F8  lfs f29, -0x2f08(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829E7FA4: C387BBEC  lfs f28, -0x4414(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17428 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829E7FA8: C3E608A4  lfs f31, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829E7FAC: C3C508A8  lfs f30, 0x8a8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829E7FB0: 419807DC  blt cr6, 0x829e878c
	if ctx.cr[6].lt {
	pc = 0x829E878C; continue 'dispatch;
	}
	// 829E7FB4: 419A0064  beq cr6, 0x829e8018
	if ctx.cr[6].eq {
	pc = 0x829E8018; continue 'dispatch;
	}
	// 829E7FB8: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829E7FBC: 40980834  bge cr6, 0x829e87f0
	if !ctx.cr[6].lt {
	pc = 0x829E87F0; continue 'dispatch;
	}
	// 829E7FC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E8AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E8AE0 size=1952
    let mut pc: u32 = 0x829E8AE0;
    'dispatch: loop {
        match pc {
            0x829E8AE0 => {
    //   block [0x829E8AE0..0x829E9280)
	// 829E8AE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E8AE4: 487BF679  bl 0x831a815c
	ctx.lr = 0x829E8AE8;
	sub_831A8130(ctx, base);
	// 829E8AE8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829E8AEC: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E8AF0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 829E8AF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E8AF8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829E8AFC: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 829E8B00: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829E8B04: 4BB28ED5  bl 0x825119d8
	ctx.lr = 0x829E8B08;
	sub_825119D8(ctx, base);
	// 829E8B08: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E8B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8B10: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E8B14: 4840AEF5  bl 0x82df3a08
	ctx.lr = 0x829E8B18;
	sub_82DF3A08(ctx, base);
	// 829E8B18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E8B1C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E8B20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8B24: 4BB1FC5D  bl 0x82508780
	ctx.lr = 0x829E8B28;
	sub_82508780(ctx, base);
	// 829E8B28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8B2C: 4840A8FD  bl 0x82df3428
	ctx.lr = 0x829E8B30;
	sub_82DF3428(ctx, base);
	// 829E8B30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E8B34: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829E8B38: 409A0008  bne cr6, 0x829e8b40
	if !ctx.cr[6].eq {
	pc = 0x829E8B40; continue 'dispatch;
	}
	// 829E8B3C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829E8B40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829E8B44: 4BB1FC5D  bl 0x825087a0
	ctx.lr = 0x829E8B48;
	sub_825087A0(ctx, base);
	// 829E8B48: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829E8B4C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8B50: 48441F99  bl 0x82e2aae8
	ctx.lr = 0x829E8B54;
	sub_82E2AAE8(ctx, base);
	// 829E8B54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E8B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8B5C: 388B6040  addi r4, r11, 0x6040
	ctx.r[4].s64 = ctx.r[11].s64 + 24640;
	// 829E8B60: 4840AEA9  bl 0x82df3a08
	ctx.lr = 0x829E8B64;
	sub_82DF3A08(ctx, base);
	// 829E8B64: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E8B68: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8B6C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 829E8B70: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E8B74: 484462FD  bl 0x82e2ee70
	ctx.lr = 0x829E8B78;
	sub_82E2EE70(ctx, base);
	// 829E8B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8B7C: 4840A8AD  bl 0x82df3428
	ctx.lr = 0x829E8B80;
	sub_82DF3428(ctx, base);
	// 829E8B80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E8B84: 3B6B5F58  addi r27, r11, 0x5f58
	ctx.r[27].s64 = ctx.r[11].s64 + 24408;
	// 829E8B88: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 829E8B8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8B90: 419A00CC  beq cr6, 0x829e8c5c
	if ctx.cr[6].eq {
	pc = 0x829E8C5C; continue 'dispatch;
	}
	// 829E8B94: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E8B98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E8B9C: 38A000B4  li r5, 0xb4
	ctx.r[5].s64 = 180;
	// 829E8BA0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 829E8BA4: 48409845  bl 0x82df23e8
	ctx.lr = 0x829E8BA8;
	sub_82DF23E8(ctx, base);
	// 829E8BA8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E8BAC: 41820014  beq 0x829e8bc0
	if ctx.cr[0].eq {
	pc = 0x829E8BC0; continue 'dispatch;
	}
	// 829E8BB0: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 829E8BB4: 4842DCDD  bl 0x82e16890
	ctx.lr = 0x829E8BB8;
	sub_82E16890(ctx, base);
	// 829E8BB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E8BBC: 48000008  b 0x829e8bc4
	pc = 0x829E8BC4; continue 'dispatch;
	// 829E8BC0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829E8BC4: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829E8BC8: 4B9747A9  bl 0x8235d370
	ctx.lr = 0x829E8BCC;
	sub_8235D370(ctx, base);
	// 829E8BCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8BD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E8BD4: 83DF00E4  lwz r30, 0xe4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E8BD8: 4BB29541  bl 0x82512118
	ctx.lr = 0x829E8BDC;
	sub_82512118(ctx, base);
	// 829E8BDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E8BE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E8BE4: 4842C4CD  bl 0x82e150b0
	ctx.lr = 0x829E8BE8;
	sub_82E150B0(ctx, base);
	// 829E8BE8: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E8BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8BF0: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 829E8BF4: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 829E8BF8: 4BB291A1  bl 0x82511d98
	ctx.lr = 0x829E8BFC;
	sub_82511D98(ctx, base);
	// 829E8BFC: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829E8C00: 815F00E4  lwz r10, 0xe4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E8C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8C08: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 829E8C0C: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 829E8C10: 419A0024  beq cr6, 0x829e8c34
	if ctx.cr[6].eq {
	pc = 0x829E8C34; continue 'dispatch;
	}
	// 829E8C14: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E8C18: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E8C1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E8C20: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E8C24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E8C28: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E8C2C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E8C30: 4082FFE8  bne 0x829e8c18
	if !ctx.cr[0].eq {
	pc = 0x829E8C18; continue 'dispatch;
	}
	// 829E8C34: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829E8C38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829E8C3C: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 829E8C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8C44: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 829E8C48: 4BB27DB1  bl 0x825109f8
	ctx.lr = 0x829E8C4C;
	sub_825109F8(ctx, base);
	// 829E8C4C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829E8C50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E8C54: 419A0008  beq cr6, 0x829e8c5c
	if ctx.cr[6].eq {
	pc = 0x829E8C5C; continue 'dispatch;
	}
	// 829E8C58: 4B8D7C39  bl 0x822c0890
	ctx.lr = 0x829E8C5C;
	sub_822C0890(ctx, base);
	// 829E8C5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E8C60: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829E8C64: C06B603C  lfs f3, 0x603c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24636 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 829E8C68: FC401890  fmr f2, f3
	ctx.f[2].f64 = ctx.f[3].f64;
	// 829E8C6C: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 829E8C70: 48493301  bl 0x82e7bf70
	ctx.lr = 0x829E8C74;
	sub_82E7BF70(ctx, base);
	// 829E8C74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829E8C78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E8C7C: 38A000BF  li r5, 0xbf
	ctx.r[5].s64 = 191;
	// 829E8C80: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 829E8C84: 48409765  bl 0x82df23e8
	ctx.lr = 0x829E8C88;
	sub_82DF23E8(ctx, base);
	// 829E8C88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E8C8C: 41820014  beq 0x829e8ca0
	if ctx.cr[0].eq {
	pc = 0x829E8CA0; continue 'dispatch;
	}
	// 829E8C90: 38810150  addi r4, r1, 0x150
	ctx.r[4].s64 = ctx.r[1].s64 + 336;
	// 829E8C94: 4842A45D  bl 0x82e130f0
	ctx.lr = 0x829E8C98;
	sub_82E130F0(ctx, base);
	// 829E8C98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E8C9C: 48000008  b 0x829e8ca4
	pc = 0x829E8CA4; continue 'dispatch;
	// 829E8CA0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 829E8CA4: 3BDF0144  addi r30, r31, 0x144
	ctx.r[30].s64 = ctx.r[31].s64 + 324;
	// 829E8CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E8CAC: 4B8F90A5  bl 0x822e1d50
	ctx.lr = 0x829E8CB0;
	sub_822E1D50(ctx, base);
	// 829E8CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E8CB4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829E8CB8: 833F0144  lwz r25, 0x144(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 829E8CBC: 4BB2945D  bl 0x82512118
	ctx.lr = 0x829E8CC0;
	sub_82512118(ctx, base);
	// 829E8CC0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829E8CC4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8CC8: 4842A169  bl 0x82e12e30
	ctx.lr = 0x829E8CCC;
	sub_82E12E30(ctx, base);
	// 829E8CCC: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 829E8CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E8CD4: 419A0008  beq cr6, 0x829e8cdc
	if ctx.cr[6].eq {
	pc = 0x829E8CDC; continue 'dispatch;
	}
	// 829E8CD8: 4B8D7BB9  bl 0x822c0890
	ctx.lr = 0x829E8CDC;
	sub_822C0890(ctx, base);
	// 829E8CDC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E8CE0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8CE8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829E8CEC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829E8CF0: 419A0024  beq cr6, 0x829e8d14
	if ctx.cr[6].eq {
	pc = 0x829E8D14; continue 'dispatch;
	}
	// 829E8CF4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E8CF8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E8CFC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E8D00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E8D04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E8D08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E8D0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E8D10: 4082FFE8  bne 0x829e8cf8
	if !ctx.cr[0].eq {
	pc = 0x829E8CF8; continue 'dispatch;
	}
	// 829E8D14: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E8D18: 807F00E4  lwz r3, 0xe4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E8D1C: 4842C395  bl 0x82e150b0
	ctx.lr = 0x829E8D20;
	sub_82E150B0(ctx, base);
	// 829E8D20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E8D24: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8D28: 484571E1  bl 0x82e3ff08
	ctx.lr = 0x829E8D2C;
	sub_82E3FF08(ctx, base);
	// 829E8D2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E8D30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8D34: 388B6028  addi r4, r11, 0x6028
	ctx.r[4].s64 = ctx.r[11].s64 + 24616;
	// 829E8D38: 4840ACD1  bl 0x82df3a08
	ctx.lr = 0x829E8D3C;
	sub_82DF3A08(ctx, base);
	// 829E8D3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E8D40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8D44: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 829E8D48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E8D4C: 48445A55  bl 0x82e2e7a0
	ctx.lr = 0x829E8D50;
	sub_82E2E7A0(ctx, base);
	// 829E8D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8D54: 4840A6D5  bl 0x82df3428
	ctx.lr = 0x829E8D58;
	sub_82DF3428(ctx, base);
	// 829E8D58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E8D5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8D60: 388B6010  addi r4, r11, 0x6010
	ctx.r[4].s64 = ctx.r[11].s64 + 24592;
	// 829E8D64: 4840ACA5  bl 0x82df3a08
	ctx.lr = 0x829E8D68;
	sub_82DF3A08(ctx, base);
	// 829E8D68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E8D6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829E8D70: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829E8D74: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829E8D78: 48457CF1  bl 0x82e40a68
	ctx.lr = 0x829E8D7C;
	sub_82E40A68(ctx, base);
	// 829E8D7C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E8D80: 395F0158  addi r10, r31, 0x158
	ctx.r[10].s64 = ctx.r[31].s64 + 344;
	// 829E8D84: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829E8D88: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 829E8D8C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8D90: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 829E8D94: 4B8DB6CD  bl 0x822c4460
	ctx.lr = 0x829E8D98;
	sub_822C4460(ctx, base);
	// 829E8D98: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 829E8D9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E8DA0: 419A0008  beq cr6, 0x829e8da8
	if ctx.cr[6].eq {
	pc = 0x829E8DA8; continue 'dispatch;
	}
	// 829E8DA4: 4B8D7AED  bl 0x822c0890
	ctx.lr = 0x829E8DA8;
	sub_822C0890(ctx, base);
	// 829E8DA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E8DAC: 4840A67D  bl 0x82df3428
	ctx.lr = 0x829E8DB0;
	sub_82DF3428(ctx, base);
	// 829E8DB0: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 829E8DB4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829E8DB8: 394A7E48  addi r10, r10, 0x7e48
	ctx.r[10].s64 = ctx.r[10].s64 + 32328;
	// 829E8DBC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 829E8DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E8DC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E8DC8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 829E8DCC: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 829E8DD0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 829E8DD4: 419A0024  beq cr6, 0x829e8df8
	if ctx.cr[6].eq {
	pc = 0x829E8DF8; continue 'dispatch;
	}
	// 829E8DD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E8DDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E8DE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E8DE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E8DE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E8DEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E8DF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E8DF4: 4082FFE8  bne 0x829e8ddc
	if !ctx.cr[0].eq {
	pc = 0x829E8DDC; continue 'dispatch;
	}
	// 829E8DF8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 829E8DFC: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 829E8E00: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 829E8E04: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 829E8E08: 93410130  stw r26, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[26].u32 ) };
	// 829E8E0C: 4BFFEFBD  bl 0x829e7dc8
	ctx.lr = 0x829E8E10;
	sub_829E7DC8(ctx, base);
	// 829E8E10: 38A10130  addi r5, r1, 0x130
	ctx.r[5].s64 = ctx.r[1].s64 + 304;
	// 829E8E14: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829E8E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8E1C: 4BB28025  bl 0x82510e40
	ctx.lr = 0x829E8E20;
	sub_82510E40(ctx, base);
	// 829E8E20: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829E8E24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E8E28: 419A0008  beq cr6, 0x829e8e30
	if ctx.cr[6].eq {
	pc = 0x829E8E30; continue 'dispatch;
	}
	// 829E8E2C: 4B8D7A65  bl 0x822c0890
	ctx.lr = 0x829E8E30;
	sub_822C0890(ctx, base);
	// 829E8E30: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829E8E34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E8E38: 419A0008  beq cr6, 0x829e8e40
	if ctx.cr[6].eq {
	pc = 0x829E8E40; continue 'dispatch;
	}
	// 829E8E3C: 4B8D7A55  bl 0x822c0890
	ctx.lr = 0x829E8E40;
	sub_822C0890(ctx, base);
	// 829E8E40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E8E44: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829E8E48: 4BB21B09  bl 0x8250a950
	ctx.lr = 0x829E8E4C;
	sub_8250A950(ctx, base);
	// 829E8E4C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829E8E50: 48408E41  bl 0x82df1c90
	ctx.lr = 0x829E8E54;
	sub_82DF1C90(ctx, base);
	// 829E8E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E8E58: 4BB29C41  bl 0x82512a98
	ctx.lr = 0x829E8E5C;
	sub_82512A98(ctx, base);
	// 829E8E5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 829E8E60: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E8E64: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E8E68: 396BB6F0  addi r11, r11, -0x4910
	ctx.r[11].s64 = ctx.r[11].s64 + -18704;
	// 829E8E6C: 394A6000  addi r10, r10, 0x6000
	ctx.r[10].s64 = ctx.r[10].s64 + 24576;
	// 829E8E70: 39010120  addi r8, r1, 0x120
	ctx.r[8].s64 = ctx.r[1].s64 + 288;
	// 829E8E74: 38E10110  addi r7, r1, 0x110
	ctx.r[7].s64 = ctx.r[1].s64 + 272;
	// 829E8E78: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 829E8E7C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E8E80: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829E8E84: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829E8E88: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E9280 size=128
    let mut pc: u32 = 0x829E9280;
    'dispatch: loop {
        match pc {
            0x829E9280 => {
    //   block [0x829E9280..0x829E9300)
	// 829E9280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9288: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E928C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9298: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E929C: 4BB2746D  bl 0x82510708
	ctx.lr = 0x829E92A0;
	sub_82510708(ctx, base);
	// 829E92A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E92A4: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E92A8: 4BFFEC51  bl 0x829e7ef8
	ctx.lr = 0x829E92AC;
	sub_829E7EF8(ctx, base);
	// 829E92AC: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E92B0: C01F0160  lfs f0, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E92B4: 809F0158  lwz r4, 0x158(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829E92B8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 829E92BC: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829E92C0: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E92C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829E92C8: 4198000C  blt cr6, 0x829e92d4
	if ctx.cr[6].lt {
	pc = 0x829E92D4; continue 'dispatch;
	}
	// 829E92CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829E92D0: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 829E92D4: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E92D8: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 829E92DC: C1BF0160  lfs f13, 0x160(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829E92E0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829E92E4: 48455555  bl 0x82e3e838
	ctx.lr = 0x829E92E8;
	sub_82E3E838(ctx, base);
	// 829E92E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E92EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E92F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E92F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E92F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E92FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9300 size=92
    let mut pc: u32 = 0x829E9300;
    'dispatch: loop {
        match pc {
            0x829E9300 => {
    //   block [0x829E9300..0x829E935C)
	// 829E9300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E930C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9314: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E9318: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E931C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9320: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E9324: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E9328: 4840A6E1  bl 0x82df3a08
	ctx.lr = 0x829E932C;
	sub_82DF3A08(ctx, base);
	// 829E932C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E9330: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E9334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E9338: 4BB1F449  bl 0x82508780
	ctx.lr = 0x829E933C;
	sub_82508780(ctx, base);
	// 829E933C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9340: 4840A0E9  bl 0x82df3428
	ctx.lr = 0x829E9344;
	sub_82DF3428(ctx, base);
	// 829E9344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E9348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E934C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E9350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E9354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E9358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E9360 size=20
    let mut pc: u32 = 0x829E9360;
    'dispatch: loop {
        match pc {
            0x829E9360 => {
    //   block [0x829E9360..0x829E9374)
	// 829E9360: 816300C8  lwz r11, 0xc8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 829E9364: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829E9368: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829E936C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 829E9370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9378 size=172
    let mut pc: u32 = 0x829E9378;
    'dispatch: loop {
        match pc {
            0x829E9378 => {
    //   block [0x829E9378..0x829E9424)
	// 829E9378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E937C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E9384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9388: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E938C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E9390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E9394: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829E9398: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E939C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E93A0: 4B8D7599  bl 0x822c0938
	ctx.lr = 0x829E93A4;
	sub_822C0938(ctx, base);
	// 829E93A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E93A8: 41820028  beq 0x829e93d0
	if ctx.cr[0].eq {
	pc = 0x829E93D0; continue 'dispatch;
	}
	// 829E93AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E93B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829E93B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E93B8: 392B6050  addi r9, r11, 0x6050
	ctx.r[9].s64 = ctx.r[11].s64 + 24656;
	// 829E93BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829E93C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E93C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E93C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829E93CC: 48000008  b 0x829e93d4
	pc = 0x829E93D4; continue 'dispatch;
	// 829E93D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E93D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E93D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E93DC: 409A002C  bne cr6, 0x829e9408
	if !ctx.cr[6].eq {
	pc = 0x829E9408; continue 'dispatch;
	}
	// 829E93E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E93E4: 4B8D6E85  bl 0x822c0268
	ctx.lr = 0x829E93E8;
	sub_822C0268(ctx, base);
	// 829E93E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E93EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E93F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E93F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829E93F8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E93FC: 816BD40C  lwz r11, -0x2bf4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11252 as u32) ) } as u64;
	// 829E9400: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E9404: 4B8D6BFD  bl 0x822c0000
	ctx.lr = 0x829E9408;
	sub_822C0000(ctx, base);
	// 829E9408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E940C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E9410: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E9414: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E9418: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E941C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E9420: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9428 size=196
    let mut pc: u32 = 0x829E9428;
    'dispatch: loop {
        match pc {
            0x829E9428 => {
    //   block [0x829E9428..0x829E94EC)
	// 829E9428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E942C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E9434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E943C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E9440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E9444: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829E9448: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E944C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E9450: 4B8D74E9  bl 0x822c0938
	ctx.lr = 0x829E9454;
	sub_822C0938(ctx, base);
	// 829E9454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E9458: 41820028  beq 0x829e9480
	if ctx.cr[0].eq {
	pc = 0x829E9480; continue 'dispatch;
	}
	// 829E945C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E9460: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829E9464: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829E9468: 392B6064  addi r9, r11, 0x6064
	ctx.r[9].s64 = ctx.r[11].s64 + 24676;
	// 829E946C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829E9470: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829E9474: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829E9478: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829E947C: 48000008  b 0x829e9484
	pc = 0x829E9484; continue 'dispatch;
	// 829E9480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829E9484: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E9488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E948C: 409A0044  bne cr6, 0x829e94d0
	if !ctx.cr[6].eq {
	pc = 0x829E94D0; continue 'dispatch;
	}
	// 829E9490: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E9494: 419A001C  beq cr6, 0x829e94b0
	if ctx.cr[6].eq {
	pc = 0x829E94B0; continue 'dispatch;
	}
	// 829E9498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E949C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E94A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E94A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E94A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829E94AC: 4E800421  bctrl
	ctx.lr = 0x829E94B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829E94B0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829E94B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829E94B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E94BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829E94C0: 816BD40C  lwz r11, -0x2bf4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11252 as u32) ) } as u64;
	// 829E94C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E94C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829E94CC: 4B8D6B35  bl 0x822c0000
	ctx.lr = 0x829E94D0;
	sub_822C0000(ctx, base);
	// 829E94D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E94D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E94D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E94DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E94E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E94E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E94E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E94F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E94F0 size=776
    let mut pc: u32 = 0x829E94F0;
    'dispatch: loop {
        match pc {
            0x829E94F0 => {
    //   block [0x829E94F0..0x829E97F8)
	// 829E94F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E94F4: 487BEC71  bl 0x831a8164
	ctx.lr = 0x829E94F8;
	sub_831A8130(ctx, base);
	// 829E94F8: DBA1FFB8  stfd f29, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[29].u64 ) };
	// 829E94FC: DBC1FFC0  stfd f30, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 829E9500: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829E9504: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E97F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E97F8 size=640
    let mut pc: u32 = 0x829E97F8;
    'dispatch: loop {
        match pc {
            0x829E97F8 => {
    //   block [0x829E97F8..0x829E9A78)
	// 829E97F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E97FC: 487BE955  bl 0x831a8150
	ctx.lr = 0x829E9800;
	sub_831A8130(ctx, base);
	// 829E9800: DBA1FF90  stfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[29].u64 ) };
	// 829E9804: DBC1FF98  stfd f30, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 829E9808: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 829E980C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9810: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E9814: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829E9818: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829E981C: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 829E9820: 3BCB6078  addi r30, r11, 0x6078
	ctx.r[30].s64 = ctx.r[11].s64 + 24696;
	// 829E9824: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 829E9828: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829E982C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 829E9830: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E9834: 38A00057  li r5, 0x57
	ctx.r[5].s64 = 87;
	// 829E9838: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E983C: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829E9840: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 829E9844: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 829E9848: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 829E984C: 4B8D6B8D  bl 0x822c03d8
	ctx.lr = 0x829E9850;
	sub_822C03D8(ctx, base);
	// 829E9850: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E9854: 4182005C  beq 0x829e98b0
	if ctx.cr[0].eq {
	pc = 0x829E98B0; continue 'dispatch;
	}
	// 829E9858: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E985C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829E9860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9864: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829E9868: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829E986C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829E9870: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829E9874: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829E9878: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 829E987C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 829E9880: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829E9884: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829E9888: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 829E988C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 829E9890: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 829E9894: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 829E9898: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 829E989C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 829E98A0: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 829E98A4: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 829E98A8: 99430040  stb r10, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u8 ) };
	// 829E98AC: 48000008  b 0x829e98b4
	pc = 0x829E98B4; continue 'dispatch;
	// 829E98B0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E98B4: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829E98B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E98BC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829E98C0: 4BFFFAB9  bl 0x829e9378
	ctx.lr = 0x829E98C4;
	sub_829E9378(ctx, base);
	// 829E98C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E98C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E98CC: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829E98D0: 4B8D6731  bl 0x822c0000
	ctx.lr = 0x829E98D4;
	sub_822C0000(ctx, base);
	// 829E98D4: 817D00C4  lwz r11, 0xc4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(196 as u32) ) } as u64;
	// 829E98D8: 3BFD00C0  addi r31, r29, 0xc0
	ctx.r[31].s64 = ctx.r[29].s64 + 192;
	// 829E98DC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829E98E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E98E4: 82EB0000  lwz r23, 0(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E98E8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 829E98EC: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E98F0: 4BCDFFE1  bl 0x826c98d0
	ctx.lr = 0x829E98F4;
	sub_826C98D0(ctx, base);
	// 829E98F4: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 829E98F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E98FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9900: 4811EA21  bl 0x82b08320
	ctx.lr = 0x829E9904;
	sub_82B08320(ctx, base);
	// 829E9904: 92D70004  stw r22, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 829E9908: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E990C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E9910: 92CB0000  stw r22, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 829E9914: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E9918: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 829E991C: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 829E9920: 48408AC9  bl 0x82df23e8
	ctx.lr = 0x829E9924;
	sub_82DF23E8(ctx, base);
	// 829E9924: 82E10064  lwz r23, 0x64(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E9928: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E992C: 41820068  beq 0x829e9994
	if ctx.cr[0].eq {
	pc = 0x829E9994; continue 'dispatch;
	}
	// 829E9930: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829E9934: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 829E9938: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 829E993C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829E9940: 419A0024  beq cr6, 0x829e9964
	if ctx.cr[6].eq {
	pc = 0x829E9964; continue 'dispatch;
	}
	// 829E9944: 39770004  addi r11, r23, 4
	ctx.r[11].s64 = ctx.r[23].s64 + 4;
	// 829E9948: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E994C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E9950: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E9954: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E9958: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E995C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E9960: 4082FFE8  bne 0x829e9948
	if !ctx.cr[0].eq {
	pc = 0x829E9948; continue 'dispatch;
	}
	// 829E9964: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 829E9968: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 829E996C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 829E9970: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 829E9974: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 829E9978: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829E997C: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 829E9980: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 829E9984: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829E9988: 4BFFDCE1  bl 0x829e7668
	ctx.lr = 0x829E998C;
	sub_829E7668(ctx, base);
	// 829E998C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9990: 48000008  b 0x829e9998
	pc = 0x829E9998; continue 'dispatch;
	// 829E9994: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E9998: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829E999C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E99A0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829E99A4: 4BFFFA85  bl 0x829e9428
	ctx.lr = 0x829E99A8;
	sub_829E9428(ctx, base);
	// 829E99A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E99AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E99B0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829E99B4: 4B8D664D  bl 0x822c0000
	ctx.lr = 0x829E99B8;
	sub_822C0000(ctx, base);
	// 829E99B8: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E99BC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829E99C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E99C4: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 829E99C8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829E99CC: 419A0024  beq cr6, 0x829e99f0
	if ctx.cr[6].eq {
	pc = 0x829E99F0; continue 'dispatch;
	}
	// 829E99D0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829E99D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E99D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E99DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E99E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E99E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E99E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E99EC: 4082FFE8  bne 0x829e99d4
	if !ctx.cr[0].eq {
	pc = 0x829E99D4; continue 'dispatch;
	}
	// 829E99F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E99F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E99F8: 4BB25AD1  bl 0x8250f4c8
	ctx.lr = 0x829E99FC;
	sub_8250F4C8(ctx, base);
	// 829E99FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9A00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9A04: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 829E9A08: 409A0008  bne cr6, 0x829e9a10
	if !ctx.cr[6].eq {
	pc = 0x829E9A10; continue 'dispatch;
	}
	// 829E9A0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829E9A10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829E9A14: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E9A18: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 829E9A1C: 4BB25AFD  bl 0x8250f518
	ctx.lr = 0x829E9A20;
	sub_8250F518(ctx, base);
	// 829E9A20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E9A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9A28: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829E9A2C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829E9A30: 4BB23AD9  bl 0x8250d508
	ctx.lr = 0x829E9A34;
	sub_8250D508(ctx, base);
	// 829E9A34: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829E9A38: 48408259  bl 0x82df1c90
	ctx.lr = 0x829E9A3C;
	sub_82DF1C90(ctx, base);
	// 829E9A3C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829E9A40: 48408251  bl 0x82df1c90
	ctx.lr = 0x829E9A44;
	sub_82DF1C90(ctx, base);
	// 829E9A44: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829E9A48: 419A000C  beq cr6, 0x829e9a54
	if ctx.cr[6].eq {
	pc = 0x829E9A54; continue 'dispatch;
	}
	// 829E9A4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E9A50: 4B8D6E41  bl 0x822c0890
	ctx.lr = 0x829E9A54;
	sub_822C0890(ctx, base);
	// 829E9A54: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 829E9A58: 419A000C  beq cr6, 0x829e9a64
	if ctx.cr[6].eq {
	pc = 0x829E9A64; continue 'dispatch;
	}
	// 829E9A5C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829E9A60: 4B8D6E31  bl 0x822c0890
	ctx.lr = 0x829E9A64;
	sub_822C0890(ctx, base);
	// 829E9A64: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 829E9A68: CBA1FF90  lfd f29, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 829E9A6C: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 829E9A70: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 829E9A74: 487BE72C  b 0x831a81a0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E9A78 size=80
    let mut pc: u32 = 0x829E9A78;
    'dispatch: loop {
        match pc {
            0x829E9A78 => {
    //   block [0x829E9A78..0x829E9AC8)
	// 829E9A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9A80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9A84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9A88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9A8C: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E9A90: 896B0020  lbz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 829E9A94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E9A98: 41820008  beq 0x829e9aa0
	if ctx.cr[0].eq {
	pc = 0x829E9AA0; continue 'dispatch;
	}
	// 829E9A9C: 4BB26B35  bl 0x825105d0
	ctx.lr = 0x829E9AA0;
	sub_825105D0(ctx, base);
	// 829E9AA0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E9AA4: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 829E9AA8: 813F00F8  lwz r9, 0xf8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829E9AAC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829E9AC8 size=48
    let mut pc: u32 = 0x829E9AC8;
    'dispatch: loop {
        match pc {
            0x829E9AC8 => {
    //   block [0x829E9AC8..0x829E9AF8)
	// 829E9AC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829E9ACC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 829E9AD0: 99640018  stb r11, 0x18(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 829E9AD4: 812300E4  lwz r9, 0xe4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 829E9AD8: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E9AF8 size=68
    let mut pc: u32 = 0x829E9AF8;
    'dispatch: loop {
        match pc {
            0x829E9AF8 => {
    //   block [0x829E9AF8..0x829E9B3C)
	// 829E9AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9AFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9B00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E9B04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9B08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9B0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9B10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E9B14: 4BB26BF5  bl 0x82510708
	ctx.lr = 0x829E9B18;
	sub_82510708(ctx, base);
	// 829E9B18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9B1C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E9B20: 4BFFFF59  bl 0x829e9a78
	ctx.lr = 0x829E9B24;
	sub_829E9A78(ctx, base);
	// 829E9B24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E9B28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E9B2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E9B30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E9B34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E9B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E9B40 size=220
    let mut pc: u32 = 0x829E9B40;
    'dispatch: loop {
        match pc {
            0x829E9B40 => {
    //   block [0x829E9B40..0x829E9C1C)
	// 829E9B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9B44: 487BE625  bl 0x831a8168
	ctx.lr = 0x829E9B48;
	sub_831A8130(ctx, base);
	// 829E9B48: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829E9B4C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829E9B50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9B54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E9B58: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829E9B5C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829E9B60: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 829E9B64: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E9B68: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829E9B6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9B70: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9B74: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 829E9B78: 4BB286E9  bl 0x82512260
	ctx.lr = 0x829E9B7C;
	sub_82512260(ctx, base);
	// 829E9B7C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E9B80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E9B84: 392A6114  addi r9, r10, 0x6114
	ctx.r[9].s64 = ctx.r[10].s64 + 24852;
	// 829E9B88: 396B60D4  addi r11, r11, 0x60d4
	ctx.r[11].s64 = ctx.r[11].s64 + 24788;
	// 829E9B8C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829E9B90: 395F00E4  addi r10, r31, 0xe4
	ctx.r[10].s64 = ctx.r[31].s64 + 228;
	// 829E9B94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E9B98: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 829E9B9C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9BA0: 915F00E4  stw r10, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 829E9BA4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9BA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829E9BAC: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 829E9BB0: 419A0024  beq cr6, 0x829e9bd4
	if ctx.cr[6].eq {
	pc = 0x829E9BD4; continue 'dispatch;
	}
	// 829E9BB4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 829E9BB8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 829E9BBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E9BC0: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 829E9BC4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829E9BC8: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E9BCC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E9BD0: 4082FFE8  bne 0x829e9bb8
	if !ctx.cr[0].eq {
	pc = 0x829E9BB8; continue 'dispatch;
	}
	// 829E9BD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829E9BD8: 915F00EC  stw r10, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 829E9BDC: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 829E9BE0: 915F00F4  stw r10, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 829E9BE4: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 829E9BE8: D3DF0108  stfs f30, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 829E9BEC: D3FF0104  stfs f31, 0x104(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 829E9BF0: 93BF00FC  stw r29, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	// 829E9BF4: 939F0100  stw r28, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[28].u32 ) };
	// 829E9BF8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9BFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9C00: 419A0008  beq cr6, 0x829e9c08
	if ctx.cr[6].eq {
	pc = 0x829E9C08; continue 'dispatch;
	}
	// 829E9C04: 4B8D6C8D  bl 0x822c0890
	ctx.lr = 0x829E9C08;
	sub_822C0890(ctx, base);
	// 829E9C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9C0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E9C10: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829E9C14: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829E9C18: 487BE5A0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829E9C20 size=8
    let mut pc: u32 = 0x829E9C20;
    'dispatch: loop {
        match pc {
            0x829E9C20 => {
    //   block [0x829E9C20..0x829E9C28)
	// 829E9C20: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829E9C24: 480000B4  b 0x829e9cd8
	sub_829E9CD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9C28 size=172
    let mut pc: u32 = 0x829E9C28;
    'dispatch: loop {
        match pc {
            0x829E9C28 => {
    //   block [0x829E9C28..0x829E9CD4)
	// 829E9C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9C2C: 487BE53D  bl 0x831a8168
	ctx.lr = 0x829E9C30;
	sub_831A8130(ctx, base);
	// 829E9C30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9C34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9C38: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E9C3C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E9C40: 396B60D4  addi r11, r11, 0x60d4
	ctx.r[11].s64 = ctx.r[11].s64 + 24788;
	// 829E9C44: 394A6114  addi r10, r10, 0x6114
	ctx.r[10].s64 = ctx.r[10].s64 + 24852;
	// 829E9C48: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829E9C4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829E9C50: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829E9C54: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 829E9C58: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829E9C5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9C60: 939F00F8  stw r28, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u32 ) };
	// 829E9C64: 419A0008  beq cr6, 0x829e9c6c
	if ctx.cr[6].eq {
	pc = 0x829E9C6C; continue 'dispatch;
	}
	// 829E9C68: 4B8FE601  bl 0x822e8268
	ctx.lr = 0x829E9C6C;
	sub_822E8268(ctx, base);
	// 829E9C6C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 829E9C70: 3BDF00F4  addi r30, r31, 0xf4
	ctx.r[30].s64 = ctx.r[31].s64 + 244;
	// 829E9C74: 939F00F4  stw r28, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[28].u32 ) };
	// 829E9C78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9C7C: 419A0008  beq cr6, 0x829e9c84
	if ctx.cr[6].eq {
	pc = 0x829E9C84; continue 'dispatch;
	}
	// 829E9C80: 4B8FE5E9  bl 0x822e8268
	ctx.lr = 0x829E9C84;
	sub_822E8268(ctx, base);
	// 829E9C84: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9C8C: 419A0008  beq cr6, 0x829e9c94
	if ctx.cr[6].eq {
	pc = 0x829E9C94; continue 'dispatch;
	}
	// 829E9C90: 4B8FE5D9  bl 0x822e8268
	ctx.lr = 0x829E9C94;
	sub_822E8268(ctx, base);
	// 829E9C94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9C9C: 419A0008  beq cr6, 0x829e9ca4
	if ctx.cr[6].eq {
	pc = 0x829E9CA4; continue 'dispatch;
	}
	// 829E9CA0: 4B8FE5C9  bl 0x822e8268
	ctx.lr = 0x829E9CA4;
	sub_822E8268(ctx, base);
	// 829E9CA4: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 829E9CA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9CAC: 419A0008  beq cr6, 0x829e9cb4
	if ctx.cr[6].eq {
	pc = 0x829E9CB4; continue 'dispatch;
	}
	// 829E9CB0: 4B8D6BE1  bl 0x822c0890
	ctx.lr = 0x829E9CB4;
	sub_822C0890(ctx, base);
	// 829E9CB4: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829E9CB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9CBC: 419A0008  beq cr6, 0x829e9cc4
	if ctx.cr[6].eq {
	pc = 0x829E9CC4; continue 'dispatch;
	}
	// 829E9CC0: 4B8D6BD1  bl 0x822c0890
	ctx.lr = 0x829E9CC4;
	sub_822C0890(ctx, base);
	// 829E9CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9CC8: 4B965689  bl 0x8234f350
	ctx.lr = 0x829E9CCC;
	sub_8234F350(ctx, base);
	// 829E9CCC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E9CD0: 487BE4E8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9CD8 size=76
    let mut pc: u32 = 0x829E9CD8;
    'dispatch: loop {
        match pc {
            0x829E9CD8 => {
    //   block [0x829E9CD8..0x829E9D24)
	// 829E9CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829E9CE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829E9CE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829E9CE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9CEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9CF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E9CF4: 4BFFFF35  bl 0x829e9c28
	ctx.lr = 0x829E9CF8;
	sub_829E9C28(ctx, base);
	// 829E9CF8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E9CFC: 4182000C  beq 0x829e9d08
	if ctx.cr[0].eq {
	pc = 0x829E9D08; continue 'dispatch;
	}
	// 829E9D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9D04: 484086D5  bl 0x82df23d8
	ctx.lr = 0x829E9D08;
	sub_82DF23D8(ctx, base);
	// 829E9D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9D0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829E9D10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829E9D14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829E9D18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829E9D1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829E9D20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E9D28 size=224
    let mut pc: u32 = 0x829E9D28;
    'dispatch: loop {
        match pc {
            0x829E9D28 => {
    //   block [0x829E9D28..0x829E9E08)
	// 829E9D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9D2C: 487BE43D  bl 0x831a8168
	ctx.lr = 0x829E9D30;
	sub_831A8130(ctx, base);
	// 829E9D30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9D34: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829E9D38: 39400011  li r10, 0x11
	ctx.r[10].s64 = 17;
	// 829E9D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9D40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829E9D44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829E9D48: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829E9D4C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 829E9D50: 4BB27D99  bl 0x82511ae8
	ctx.lr = 0x829E9D54;
	sub_82511AE8(ctx, base);
	// 829E9D54: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829E9D58: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829E9D5C: 388B85E4  addi r4, r11, -0x7a1c
	ctx.r[4].s64 = ctx.r[11].s64 + -31260;
	// 829E9D60: 38DF0100  addi r6, r31, 0x100
	ctx.r[6].s64 = ctx.r[31].s64 + 256;
	// 829E9D64: 38BF00FC  addi r5, r31, 0xfc
	ctx.r[5].s64 = ctx.r[31].s64 + 252;
	// 829E9D68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829E9D6C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 829E9D70: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 829E9D74: 4BEB8B1D  bl 0x828a2890
	ctx.lr = 0x829E9D78;
	sub_828A2890(ctx, base);
	// 829E9D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9D7C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829E9D80: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829E9D84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9D88: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829E9D8C: 419A0024  beq cr6, 0x829e9db0
	if ctx.cr[6].eq {
	pc = 0x829E9DB0; continue 'dispatch;
	}
	// 829E9D90: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829E9D94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829E9D98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E9D9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829E9DA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829E9DA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829E9DA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829E9DAC: 4082FFE8  bne 0x829e9d94
	if !ctx.cr[0].eq {
	pc = 0x829E9D94; continue 'dispatch;
	}
	// 829E9DB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E9DB4: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829E9DB8: 4861E371  bl 0x83008128
	ctx.lr = 0x829E9DBC;
	sub_83008128(ctx, base);
	// 829E9DBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829E9DC0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E9DC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829E9DC8: 388A6128  addi r4, r10, 0x6128
	ctx.r[4].s64 = ctx.r[10].s64 + 24872;
	// 829E9DCC: 38A0008D  li r5, 0x8d
	ctx.r[5].s64 = 141;
	// 829E9DD0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829E9DD4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E9DD8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829E9DDC: 4846EC65  bl 0x82e58a40
	ctx.lr = 0x829E9DE0;
	sub_82E58A40(ctx, base);
	// 829E9DE0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829E9DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9DE8: 419A0008  beq cr6, 0x829e9df0
	if ctx.cr[6].eq {
	pc = 0x829E9DF0; continue 'dispatch;
	}
	// 829E9DEC: 4B8D6AA5  bl 0x822c0890
	ctx.lr = 0x829E9DF0;
	sub_822C0890(ctx, base);
	// 829E9DF0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829E9DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9DF8: 419A0008  beq cr6, 0x829e9e00
	if ctx.cr[6].eq {
	pc = 0x829E9E00; continue 'dispatch;
	}
	// 829E9DFC: 4B8D6A95  bl 0x822c0890
	ctx.lr = 0x829E9E00;
	sub_822C0890(ctx, base);
	// 829E9E00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829E9E04: 487BE3B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829E9E08 size=164
    let mut pc: u32 = 0x829E9E08;
    'dispatch: loop {
        match pc {
            0x829E9E08 => {
    //   block [0x829E9E08..0x829E9EAC)
	// 829E9E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9E0C: 487BE35D  bl 0x831a8168
	ctx.lr = 0x829E9E10;
	sub_831A8130(ctx, base);
	// 829E9E10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9E14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829E9E18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E9E1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829E9E20: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829E9E24: 41820038  beq 0x829e9e5c
	if ctx.cr[0].eq {
	pc = 0x829E9E5C; continue 'dispatch;
	}
	// 829E9E28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9E2C: 487BFB5D  bl 0x831a9988
	ctx.lr = 0x829E9E30;
	sub_831A9988(ctx, base);
	// 829E9E30: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829E9E34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E9E38: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829E9E3C: 487BE2BD  bl 0x831a80f8
	ctx.lr = 0x829E9E40;
	sub_831A80F8(ctx, base);
	// 829E9E40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E9E44: 41820018  beq 0x829e9e5c
	if ctx.cr[0].eq {
	pc = 0x829E9E5C; continue 'dispatch;
	}
	// 829E9E48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9E4C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E9E50: 4BFFFED9  bl 0x829e9d28
	ctx.lr = 0x829E9E54;
	sub_829E9D28(ctx, base);
	// 829E9E54: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829E9E58: 4800004C  b 0x829e9ea4
	pc = 0x829E9EA4; continue 'dispatch;
	// 829E9E5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829E9E60: 419A0034  beq cr6, 0x829e9e94
	if ctx.cr[6].eq {
	pc = 0x829E9E94; continue 'dispatch;
	}
	// 829E9E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829E9E68: 487BFB21  bl 0x831a9988
	ctx.lr = 0x829E9E6C;
	sub_831A9988(ctx, base);
	// 829E9E6C: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 829E9E70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829E9E74: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 829E9E78: 487BE281  bl 0x831a80f8
	ctx.lr = 0x829E9E7C;
	sub_831A80F8(ctx, base);
	// 829E9E7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829E9E80: 41820014  beq 0x829e9e94
	if ctx.cr[0].eq {
	pc = 0x829E9E94; continue 'dispatch;
	}
	// 829E9E84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9E88: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829E9E8C: 4BFFFC3D  bl 0x829e9ac8
	ctx.lr = 0x829E9E90;
	sub_829E9AC8(ctx, base);
	// 829E9E90: 4BFFFFC4  b 0x829e9e54
	pc = 0x829E9E54; continue 'dispatch;
	// 829E9E94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829E9E98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9E9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E9EA0: 4BB28779  bl 0x82512618
	ctx.lr = 0x829E9EA4;
	sub_82512618(ctx, base);
	// 829E9EA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829E9EA8: 487BE310  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829E9EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829E9EB0 size=636
    let mut pc: u32 = 0x829E9EB0;
    'dispatch: loop {
        match pc {
            0x829E9EB0 => {
    //   block [0x829E9EB0..0x829EA12C)
	// 829E9EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829E9EB4: 487BE2AD  bl 0x831a8160
	ctx.lr = 0x829E9EB8;
	sub_831A8130(ctx, base);
	// 829E9EB8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829E9EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829E9EC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829E9EC4: 4BB27B15  bl 0x825119d8
	ctx.lr = 0x829E9EC8;
	sub_825119D8(ctx, base);
	// 829E9EC8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829E9ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9ED0: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829E9ED4: 48409B35  bl 0x82df3a08
	ctx.lr = 0x829E9ED8;
	sub_82DF3A08(ctx, base);
	// 829E9ED8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829E9EDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E9EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E9EE4: 4BB1E89D  bl 0x82508780
	ctx.lr = 0x829E9EE8;
	sub_82508780(ctx, base);
	// 829E9EE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829E9EEC: 4840953D  bl 0x82df3428
	ctx.lr = 0x829E9EF0;
	sub_82DF3428(ctx, base);
	// 829E9EF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829E9EF4: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829E9EF8: 409A0008  bne cr6, 0x829e9f00
	if !ctx.cr[6].eq {
	pc = 0x829E9F00; continue 'dispatch;
	}
	// 829E9EFC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829E9F00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829E9F04: 4BB1E89D  bl 0x825087a0
	ctx.lr = 0x829E9F08;
	sub_825087A0(ctx, base);
	// 829E9F08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829E9F0C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829E9F10: 388B6128  addi r4, r11, 0x6128
	ctx.r[4].s64 = ctx.r[11].s64 + 24872;
	// 829E9F14: 38A00063  li r5, 0x63
	ctx.r[5].s64 = 99;
	// 829E9F18: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 829E9F1C: 484084CD  bl 0x82df23e8
	ctx.lr = 0x829E9F20;
	sub_82DF23E8(ctx, base);
	// 829E9F20: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829E9F24: 41820010  beq 0x829e9f34
	if ctx.cr[0].eq {
	pc = 0x829E9F34; continue 'dispatch;
	}
	// 829E9F28: 4BBA0D71  bl 0x8258ac98
	ctx.lr = 0x829E9F2C;
	sub_8258AC98(ctx, base);
	// 829E9F2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E9F30: 48000008  b 0x829e9f38
	pc = 0x829E9F38; continue 'dispatch;
	// 829E9F34: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829E9F38: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829E9F3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E9F40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E9F44: 4B91CA4D  bl 0x82306990
	ctx.lr = 0x829E9F48;
	sub_82306990(ctx, base);
	// 829E9F48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E9F4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829E9F50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829E9F54: 4B8D60AD  bl 0x822c0000
	ctx.lr = 0x829E9F58;
	sub_822C0000(ctx, base);
	// 829E9F58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829E9F5C: 3B5F00EC  addi r26, r31, 0xec
	ctx.r[26].s64 = ctx.r[31].s64 + 236;
	// 829E9F60: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829E9F64: 387A0004  addi r3, r26, 4
	ctx.r[3].s64 = ctx.r[26].s64 + 4;
	// 829E9F68: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829E9F6C: 4B8DA4F5  bl 0x822c4460
	ctx.lr = 0x829E9F70;
	sub_822C4460(ctx, base);
	// 829E9F70: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829E9F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829E9F78: 419A0008  beq cr6, 0x829e9f80
	if ctx.cr[6].eq {
	pc = 0x829E9F80; continue 'dispatch;
	}
	// 829E9F7C: 4B8D6915  bl 0x822c0890
	ctx.lr = 0x829E9F80;
	sub_822C0890(ctx, base);
	// 829E9F80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829E9F84: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9F88: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E9F8C: 4BB2553D  bl 0x8250f4c8
	ctx.lr = 0x829E9F90;
	sub_8250F4C8(ctx, base);
	// 829E9F90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829E9F98: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829E9F9C: 409A0008  bne cr6, 0x829e9fa4
	if !ctx.cr[6].eq {
	pc = 0x829E9FA4; continue 'dispatch;
	}
	// 829E9FA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829E9FA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829E9FA8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829E9FAC: 4BB1EBF5  bl 0x82508ba0
	ctx.lr = 0x829E9FB0;
	sub_82508BA0(ctx, base);
	// 829E9FB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829E9FB4: 48407CDD  bl 0x82df1c90
	ctx.lr = 0x829E9FB8;
	sub_82DF1C90(ctx, base);
	// 829E9FB8: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829E9FBC: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 829E9FC0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829E9FC4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 829E9FC8: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 829E9FCC: 484B6765  bl 0x82ea0730
	ctx.lr = 0x829E9FD0;
	sub_82EA0730(ctx, base);
	// 829E9FD0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 829E9FD4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829E9FD8: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 829E9FDC: C02A60CC  lfs f1, 0x60cc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24780 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829E9FE0: 48530211  bl 0x82f1a1f0
	ctx.lr = 0x829E9FE4;
	sub_82F1A1F0(ctx, base);
	// 829E9FE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829E9FE8: 3BBF00F4  addi r29, r31, 0xf4
	ctx.r[29].s64 = ctx.r[31].s64 + 244;
	// 829E9FEC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829E9FF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829E9FF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829E9FF8: 4B8FCC59  bl 0x822e6c50
	ctx.lr = 0x829E9FFC;
	sub_822E6C50(ctx, base);
	// 829E9FFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829EA000: 419A000C  beq cr6, 0x829ea00c
	if ctx.cr[6].eq {
	pc = 0x829EA00C; continue 'dispatch;
	}
	// 829EA004: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EA008: 4B8FE261  bl 0x822e8268
	ctx.lr = 0x829EA00C;
	sub_822E8268(ctx, base);
	// 829EA00C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829EA010: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 829EA014: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 829EA018: 484B6719  bl 0x82ea0730
	ctx.lr = 0x829EA01C;
	sub_82EA0730(ctx, base);
	// 829EA01C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 829EA020: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 829EA024: 80BF00E4  lwz r5, 0xe4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829EA028: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA02C: 485395E5  bl 0x82f23610
	ctx.lr = 0x829EA030;
	sub_82F23610(ctx, base);
	// 829EA030: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA034: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829EA038: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 829EA03C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EA040: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EA044: 4B8FCC0D  bl 0x822e6c50
	ctx.lr = 0x829EA048;
	sub_822E6C50(ctx, base);
	// 829EA048: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829EA04C: 419A000C  beq cr6, 0x829ea058
	if ctx.cr[6].eq {
	pc = 0x829EA058; continue 'dispatch;
	}
	// 829EA050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EA054: 4B8FE215  bl 0x822e8268
	ctx.lr = 0x829EA058;
	sub_822E8268(ctx, base);
	// 829EA058: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA05C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA060: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 829EA064: 419A0008  beq cr6, 0x829ea06c
	if ctx.cr[6].eq {
	pc = 0x829EA06C; continue 'dispatch;
	}
	// 829EA068: 4B8FE1E1  bl 0x822e8248
	ctx.lr = 0x829EA06C;
	sub_822E8248(ctx, base);
	// 829EA06C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EA070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA074: 388B616C  addi r4, r11, 0x616c
	ctx.r[4].s64 = ctx.r[11].s64 + 24940;
	// 829EA078: 4840F4B9  bl 0x82df9530
	ctx.lr = 0x829EA07C;
	sub_82DF9530(ctx, base);
	// 829EA07C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA080: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA088: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 829EA08C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829EA090: 419A0024  beq cr6, 0x829ea0b4
	if ctx.cr[6].eq {
	pc = 0x829EA0B4; continue 'dispatch;
	}
	// 829EA094: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829EA098: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EA09C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EA0A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EA0A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EA0A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EA0AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EA0B0: 4082FFE8  bne 0x829ea098
	if !ctx.cr[0].eq {
	pc = 0x829EA098; continue 'dispatch;
	}
	// 829EA0B4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829EA0B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EA0BC: 808B6784  lwz r4, 0x6784(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26500 as u32) ) } as u64;
	// 829EA0C0: 4B8FAE71  bl 0x822e4f30
	ctx.lr = 0x829EA0C4;
	sub_822E4F30(ctx, base);
	// 829EA0C4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829EA0C8: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 829EA0CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA0D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829EA0D4: 80AB6888  lwz r5, 0x6888(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26760 as u32) ) } as u64;
	// 829EA0D8: 808A67D4  lwz r4, 0x67d4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26580 as u32) ) } as u64;
	// 829EA0DC: 4B90D6C5  bl 0x822f77a0
	ctx.lr = 0x829EA0E0;
	sub_822F77A0(ctx, base);
	// 829EA0E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829EA0E4: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829EA0E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EA0EC: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829EA0F0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829EA0F4: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 829EA0F8: 4BAA2191  bl 0x8248c288
	ctx.lr = 0x829EA0FC;
	sub_8248C288(ctx, base);
	// 829EA0FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829EA100: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829EA104: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EA108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA10C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829EA110: 4BB28F51  bl 0x82513060
	ctx.lr = 0x829EA114;
	sub_82513060(ctx, base);
	// 829EA114: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EA118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA11C: 419A0008  beq cr6, 0x829ea124
	if ctx.cr[6].eq {
	pc = 0x829EA124; continue 'dispatch;
	}
	// 829EA120: 4B8FE149  bl 0x822e8268
	ctx.lr = 0x829EA124;
	sub_822E8268(ctx, base);
	// 829EA124: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EA128: 487BE088  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA130 size=136
    let mut pc: u32 = 0x829EA130;
    'dispatch: loop {
        match pc {
            0x829EA130 => {
    //   block [0x829EA130..0x829EA1B8)
	// 829EA130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA134: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA138: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EA13C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EA140: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA144: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA148: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EA14C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829EA150: 409A0020  bne cr6, 0x829ea170
	if !ctx.cr[6].eq {
	pc = 0x829EA170; continue 'dispatch;
	}
	// 829EA154: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EA158: 419A0048  beq cr6, 0x829ea1a0
	if ctx.cr[6].eq {
	pc = 0x829EA1A0; continue 'dispatch;
	}
	// 829EA15C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829EA160: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829EA164: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829EA168: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829EA16C: 48000034  b 0x829ea1a0
	pc = 0x829EA1A0; continue 'dispatch;
	// 829EA170: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829EA174: 419A002C  beq cr6, 0x829ea1a0
	if ctx.cr[6].eq {
	pc = 0x829EA1A0; continue 'dispatch;
	}
	// 829EA178: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EA17C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA180: 388BD4F8  addi r4, r11, -0x2b08
	ctx.r[4].s64 = ctx.r[11].s64 + -11016;
	// 829EA184: 487BDF75  bl 0x831a80f8
	ctx.lr = 0x829EA188;
	sub_831A80F8(ctx, base);
	// 829EA188: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EA18C: 4182000C  beq 0x829ea198
	if ctx.cr[0].eq {
	pc = 0x829EA198; continue 'dispatch;
	}
	// 829EA190: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829EA194: 4800000C  b 0x829ea1a0
	pc = 0x829EA1A0; continue 'dispatch;
	// 829EA198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EA19C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EA1A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EA1A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EA1A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EA1AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EA1B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EA1B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EA1B8 size=72
    let mut pc: u32 = 0x829EA1B8;
    'dispatch: loop {
        match pc {
            0x829EA1B8 => {
    //   block [0x829EA1B8..0x829EA200)
	// 829EA1B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA1BC: 487BDFB1  bl 0x831a816c
	ctx.lr = 0x829EA1C0;
	sub_831A8130(ctx, base);
	// 829EA1C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA1C4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829EA1C8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829EA1CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA1D0: 9BFD0018  stb r31, 0x18(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[31].u8 ) };
	// 829EA1D4: 4BB27915  bl 0x82511ae8
	ctx.lr = 0x829EA1D8;
	sub_82511AE8(ctx, base);
	// 829EA1D8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 829EA1DC: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA200 size=72
    let mut pc: u32 = 0x829EA200;
    'dispatch: loop {
        match pc {
            0x829EA200 => {
    //   block [0x829EA200..0x829EA248)
	// 829EA200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA208: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA20C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829EA210: 419A001C  beq cr6, 0x829ea22c
	if ctx.cr[6].eq {
	pc = 0x829EA22C; continue 'dispatch;
	}
	// 829EA214: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EA218: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EA21C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829EA220: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA224: 4BFFFF0D  bl 0x829ea130
	ctx.lr = 0x829EA228;
	sub_829EA130(ctx, base);
	// 829EA228: 48000010  b 0x829ea238
	pc = 0x829EA238; continue 'dispatch;
	// 829EA22C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EA230: 396BD4F8  addi r11, r11, -0x2b08
	ctx.r[11].s64 = ctx.r[11].s64 + -11016;
	// 829EA234: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EA238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EA23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EA240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EA244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EA248 size=200
    let mut pc: u32 = 0x829EA248;
    'dispatch: loop {
        match pc {
            0x829EA248 => {
    //   block [0x829EA248..0x829EA310)
	// 829EA248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA24C: 487BDF1D  bl 0x831a8168
	ctx.lr = 0x829EA250;
	sub_831A8130(ctx, base);
	// 829EA250: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 829EA254: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829EA258: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829EA25C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA260: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829EA264: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829EA268: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EA26C: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 829EA270: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829EA274: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 829EA278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA27C: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 829EA280: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 829EA284: 4BB27FDD  bl 0x82512260
	ctx.lr = 0x829EA288;
	sub_82512260(ctx, base);
	// 829EA288: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EA28C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EA290: 394A61CC  addi r10, r10, 0x61cc
	ctx.r[10].s64 = ctx.r[10].s64 + 25036;
	// 829EA294: 392B618C  addi r9, r11, 0x618c
	ctx.r[9].s64 = ctx.r[11].s64 + 24972;
	// 829EA298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EA29C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EA2A0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EA2A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EA2A8: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829EA2AC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829EA2B0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829EA2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA2B8: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829EA2BC: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 829EA2C0: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 829EA2C4: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EA2C8: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 829EA2CC: D01F00FC  stfs f0, 0xfc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 829EA2D0: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 829EA2D4: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 829EA2D8: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 829EA2DC: C0096180  lfs f0, 0x6180(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24960 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EA2E0: 9BDF0108  stb r30, 0x108(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[30].u8 ) };
	// 829EA2E4: D3FF0110  stfs f31, 0x110(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 829EA2E8: 93BF0118  stw r29, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[29].u32 ) };
	// 829EA2EC: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 829EA2F0: 939F011C  stw r28, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[28].u32 ) };
	// 829EA2F4: D3DF0120  stfs f30, 0x120(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 829EA2F8: D3BF0124  stfs f29, 0x124(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 829EA2FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EA300: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829EA304: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829EA308: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829EA30C: 487BDEAC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EA310 size=8
    let mut pc: u32 = 0x829EA310;
    'dispatch: loop {
        match pc {
            0x829EA310 => {
    //   block [0x829EA310..0x829EA318)
	// 829EA310: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829EA314: 48000144  b 0x829ea458
	sub_829EA458(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA318 size=188
    let mut pc: u32 = 0x829EA318;
    'dispatch: loop {
        match pc {
            0x829EA318 => {
    //   block [0x829EA318..0x829EA3D4)
	// 829EA318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA31C: 487BDE4D  bl 0x831a8168
	ctx.lr = 0x829EA320;
	sub_831A8130(ctx, base);
	// 829EA320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA328: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EA32C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EA330: 396B618C  addi r11, r11, 0x618c
	ctx.r[11].s64 = ctx.r[11].s64 + 24972;
	// 829EA334: 394A61CC  addi r10, r10, 0x61cc
	ctx.r[10].s64 = ctx.r[10].s64 + 25036;
	// 829EA338: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829EA33C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EA340: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EA344: 3BBF00F8  addi r29, r31, 0xf8
	ctx.r[29].s64 = ctx.r[31].s64 + 248;
	// 829EA348: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829EA34C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA350: 939F00F8  stw r28, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[28].u32 ) };
	// 829EA354: 419A0008  beq cr6, 0x829ea35c
	if ctx.cr[6].eq {
	pc = 0x829EA35C; continue 'dispatch;
	}
	// 829EA358: 4B8FDF11  bl 0x822e8268
	ctx.lr = 0x829EA35C;
	sub_822E8268(ctx, base);
	// 829EA35C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 829EA360: 3BDF00F4  addi r30, r31, 0xf4
	ctx.r[30].s64 = ctx.r[31].s64 + 244;
	// 829EA364: 939F00F4  stw r28, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[28].u32 ) };
	// 829EA368: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA36C: 419A0008  beq cr6, 0x829ea374
	if ctx.cr[6].eq {
	pc = 0x829EA374; continue 'dispatch;
	}
	// 829EA370: 4B8FDEF9  bl 0x822e8268
	ctx.lr = 0x829EA374;
	sub_822E8268(ctx, base);
	// 829EA374: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 829EA378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA37C: 419A0008  beq cr6, 0x829ea384
	if ctx.cr[6].eq {
	pc = 0x829EA384; continue 'dispatch;
	}
	// 829EA380: 4B8D6511  bl 0x822c0890
	ctx.lr = 0x829EA384;
	sub_822C0890(ctx, base);
	// 829EA384: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA38C: 419A0008  beq cr6, 0x829ea394
	if ctx.cr[6].eq {
	pc = 0x829EA394; continue 'dispatch;
	}
	// 829EA390: 4B8FDED9  bl 0x822e8268
	ctx.lr = 0x829EA394;
	sub_822E8268(ctx, base);
	// 829EA394: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA398: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA39C: 419A0008  beq cr6, 0x829ea3a4
	if ctx.cr[6].eq {
	pc = 0x829EA3A4; continue 'dispatch;
	}
	// 829EA3A0: 4B8FDEC9  bl 0x822e8268
	ctx.lr = 0x829EA3A4;
	sub_822E8268(ctx, base);
	// 829EA3A4: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 829EA3A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA3AC: 419A0008  beq cr6, 0x829ea3b4
	if ctx.cr[6].eq {
	pc = 0x829EA3B4; continue 'dispatch;
	}
	// 829EA3B0: 4B8D64E1  bl 0x822c0890
	ctx.lr = 0x829EA3B4;
	sub_822C0890(ctx, base);
	// 829EA3B4: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829EA3B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA3BC: 419A0008  beq cr6, 0x829ea3c4
	if ctx.cr[6].eq {
	pc = 0x829EA3C4; continue 'dispatch;
	}
	// 829EA3C0: 4B8D64D1  bl 0x822c0890
	ctx.lr = 0x829EA3C4;
	sub_822C0890(ctx, base);
	// 829EA3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA3C8: 4B964F89  bl 0x8234f350
	ctx.lr = 0x829EA3CC;
	sub_8234F350(ctx, base);
	// 829EA3CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA3D0: 487BDDE8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EA3D8 size=20
    let mut pc: u32 = 0x829EA3D8;
    'dispatch: loop {
        match pc {
            0x829EA3D8 => {
    //   block [0x829EA3D8..0x829EA3EC)
	// 829EA3D8: 8144015C  lwz r10, 0x15c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(348 as u32) ) } as u64;
	// 829EA3DC: 39240158  addi r9, r4, 0x158
	ctx.r[9].s64 = ctx.r[4].s64 + 344;
	// 829EA3E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA3E4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EA3E8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA3EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829EA3EC size=104
    let mut pc: u32 = 0x829EA3EC;
    'dispatch: loop {
        match pc {
            0x829EA3EC => {
    //   block [0x829EA3EC..0x829EA454)
	// 829EA3EC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829EA3F0: C1AAC3C8  lfs f13, -0x3c38(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EA3F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EA3F8: C0030114  lfs f0, 0x114(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EA3FC: 810A0080  lwz r8, 0x80(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 829EA400: 9101FFE0  stw r8, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u32 ) };
	// 829EA404: 8901FFE0  lbz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 829EA408: F901FFE8  std r8, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[8].u64 ) };
	// 829EA40C: C981FFE8  lfd f12, -0x18(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EA410: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 829EA414: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 829EA418: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 829EA41C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EA420: 41980008  blt cr6, 0x829ea428
	if ctx.cr[6].lt {
	pc = 0x829EA428; continue 'dispatch;
	}
	// 829EA424: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 829EA428: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 829EA42C: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 829EA430: 8901FFF7  lbz r8, -9(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(-9 as u32) ) } as u64;
	// 829EA434: 9901FFE0  stb r8, -0x20(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u8 ) };
	// 829EA438: 8101FFE0  lwz r8, -0x20(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 829EA43C: 910A0080  stw r8, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 829EA440: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA444: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA448: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EA44C: 409AFFA8  bne cr6, 0x829ea3f4
	if !ctx.cr[6].eq {
	pc = 0x829EA3F4; continue 'dispatch;
	}
	// 829EA450: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA458 size=76
    let mut pc: u32 = 0x829EA458;
    'dispatch: loop {
        match pc {
            0x829EA458 => {
    //   block [0x829EA458..0x829EA4A4)
	// 829EA458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EA464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EA468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA46C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA470: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EA474: 4BFFFEA5  bl 0x829ea318
	ctx.lr = 0x829EA478;
	sub_829EA318(ctx, base);
	// 829EA478: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EA47C: 4182000C  beq 0x829ea488
	if ctx.cr[0].eq {
	pc = 0x829EA488; continue 'dispatch;
	}
	// 829EA480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA484: 48407F55  bl 0x82df23d8
	ctx.lr = 0x829EA488;
	sub_82DF23D8(ctx, base);
	// 829EA488: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA48C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EA490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EA494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EA498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EA49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EA4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EA4A8 size=512
    let mut pc: u32 = 0x829EA4A8;
    'dispatch: loop {
        match pc {
            0x829EA4A8 => {
    //   block [0x829EA4A8..0x829EA6A8)
	// 829EA4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA4AC: 487BDCC1  bl 0x831a816c
	ctx.lr = 0x829EA4B0;
	sub_831A8130(ctx, base);
	// 829EA4B0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EA6A8 size=224
    let mut pc: u32 = 0x829EA6A8;
    'dispatch: loop {
        match pc {
            0x829EA6A8 => {
    //   block [0x829EA6A8..0x829EA788)
	// 829EA6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA6AC: 487BDABD  bl 0x831a8168
	ctx.lr = 0x829EA6B0;
	sub_831A8130(ctx, base);
	// 829EA6B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA6B4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829EA6B8: 39400011  li r10, 0x11
	ctx.r[10].s64 = 17;
	// 829EA6BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA6C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EA6C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EA6C8: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829EA6CC: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 829EA6D0: 4BB27419  bl 0x82511ae8
	ctx.lr = 0x829EA6D4;
	sub_82511AE8(ctx, base);
	// 829EA6D4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829EA6D8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 829EA6DC: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829EA6E0: 38DF011C  addi r6, r31, 0x11c
	ctx.r[6].s64 = ctx.r[31].s64 + 284;
	// 829EA6E4: 38BF0118  addi r5, r31, 0x118
	ctx.r[5].s64 = ctx.r[31].s64 + 280;
	// 829EA6E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EA6EC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 829EA6F0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 829EA6F4: 4BEB819D  bl 0x828a2890
	ctx.lr = 0x829EA6F8;
	sub_828A2890(ctx, base);
	// 829EA6F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EA6FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829EA700: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EA704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EA708: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829EA70C: 419A0024  beq cr6, 0x829ea730
	if ctx.cr[6].eq {
	pc = 0x829EA730; continue 'dispatch;
	}
	// 829EA710: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829EA714: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EA718: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EA71C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EA720: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EA724: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EA728: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EA72C: 4082FFE8  bne 0x829ea714
	if !ctx.cr[0].eq {
	pc = 0x829EA714; continue 'dispatch;
	}
	// 829EA730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EA734: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829EA738: 4861D9F1  bl 0x83008128
	ctx.lr = 0x829EA73C;
	sub_83008128(ctx, base);
	// 829EA73C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EA740: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EA744: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829EA748: 388A61E0  addi r4, r10, 0x61e0
	ctx.r[4].s64 = ctx.r[10].s64 + 25056;
	// 829EA74C: 38A00128  li r5, 0x128
	ctx.r[5].s64 = 296;
	// 829EA750: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829EA754: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EA758: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829EA75C: 4846E2E5  bl 0x82e58a40
	ctx.lr = 0x829EA760;
	sub_82E58A40(ctx, base);
	// 829EA760: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EA764: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA768: 419A0008  beq cr6, 0x829ea770
	if ctx.cr[6].eq {
	pc = 0x829EA770; continue 'dispatch;
	}
	// 829EA76C: 4B8D6125  bl 0x822c0890
	ctx.lr = 0x829EA770;
	sub_822C0890(ctx, base);
	// 829EA770: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EA774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA778: 419A0008  beq cr6, 0x829ea780
	if ctx.cr[6].eq {
	pc = 0x829EA780; continue 'dispatch;
	}
	// 829EA77C: 4B8D6115  bl 0x822c0890
	ctx.lr = 0x829EA780;
	sub_822C0890(ctx, base);
	// 829EA780: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EA784: 487BDA34  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA788 size=164
    let mut pc: u32 = 0x829EA788;
    'dispatch: loop {
        match pc {
            0x829EA788 => {
    //   block [0x829EA788..0x829EA82C)
	// 829EA788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA78C: 487BD9DD  bl 0x831a8168
	ctx.lr = 0x829EA790;
	sub_831A8130(ctx, base);
	// 829EA790: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA794: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829EA798: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA79C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EA7A0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829EA7A4: 41820038  beq 0x829ea7dc
	if ctx.cr[0].eq {
	pc = 0x829EA7DC; continue 'dispatch;
	}
	// 829EA7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA7AC: 487BF1DD  bl 0x831a9988
	ctx.lr = 0x829EA7B0;
	sub_831A9988(ctx, base);
	// 829EA7B0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829EA7B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA7B8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829EA7BC: 487BD93D  bl 0x831a80f8
	ctx.lr = 0x829EA7C0;
	sub_831A80F8(ctx, base);
	// 829EA7C0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EA7C4: 41820018  beq 0x829ea7dc
	if ctx.cr[0].eq {
	pc = 0x829EA7DC; continue 'dispatch;
	}
	// 829EA7C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA7CC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EA7D0: 4BFFFED9  bl 0x829ea6a8
	ctx.lr = 0x829EA7D4;
	sub_829EA6A8(ctx, base);
	// 829EA7D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EA7D8: 4800004C  b 0x829ea824
	pc = 0x829EA824; continue 'dispatch;
	// 829EA7DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829EA7E0: 419A0034  beq cr6, 0x829ea814
	if ctx.cr[6].eq {
	pc = 0x829EA814; continue 'dispatch;
	}
	// 829EA7E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA7E8: 487BF1A1  bl 0x831a9988
	ctx.lr = 0x829EA7EC;
	sub_831A9988(ctx, base);
	// 829EA7EC: 3D60832A  lis r11, -0x7cd6
	ctx.r[11].s64 = -2094399488;
	// 829EA7F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EA7F4: 386BDF04  addi r3, r11, -0x20fc
	ctx.r[3].s64 = ctx.r[11].s64 + -8444;
	// 829EA7F8: 487BD901  bl 0x831a80f8
	ctx.lr = 0x829EA7FC;
	sub_831A80F8(ctx, base);
	// 829EA7FC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EA800: 41820014  beq 0x829ea814
	if ctx.cr[0].eq {
	pc = 0x829EA814; continue 'dispatch;
	}
	// 829EA804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA808: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EA80C: 4BFFF9AD  bl 0x829ea1b8
	ctx.lr = 0x829EA810;
	sub_829EA1B8(ctx, base);
	// 829EA810: 4BFFFFC4  b 0x829ea7d4
	pc = 0x829EA7D4; continue 'dispatch;
	// 829EA814: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EA818: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EA81C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EA820: 4BB27DF9  bl 0x82512618
	ctx.lr = 0x829EA824;
	sub_82512618(ctx, base);
	// 829EA824: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA828: 487BD990  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EA830 size=112
    let mut pc: u32 = 0x829EA830;
    'dispatch: loop {
        match pc {
            0x829EA830 => {
    //   block [0x829EA830..0x829EA8A0)
	// 829EA830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EA838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EA83C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EA840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA848: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EA84C: 4BB25EBD  bl 0x82510708
	ctx.lr = 0x829EA850;
	sub_82510708(ctx, base);
	// 829EA850: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EA854: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EA858: C19F00FC  lfs f12, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EA85C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 829EA860: C1AB6180  lfs f13, 0x6180(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24960 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EA864: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EA868: 40980014  bge cr6, 0x829ea87c
	if !ctx.cr[6].lt {
	pc = 0x829EA87C; continue 'dispatch;
	}
	// 829EA86C: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EA870: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829EA874: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829EA878: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 829EA87C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA880: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EA884: 4BFFFC25  bl 0x829ea4a8
	ctx.lr = 0x829EA888;
	sub_829EA4A8(ctx, base);
	// 829EA888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EA88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EA890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EA894: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EA898: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EA89C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EA8A0 size=128
    let mut pc: u32 = 0x829EA8A0;
    'dispatch: loop {
        match pc {
            0x829EA8A0 => {
    //   block [0x829EA8A0..0x829EA920)
	// 829EA8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA8A4: 487BD8C9  bl 0x831a816c
	ctx.lr = 0x829EA8A8;
	sub_831A8130(ctx, base);
	// 829EA8A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA8AC: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829EA8B0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829EA8B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA8B8: 3BEBD8D4  addi r31, r11, -0x272c
	ctx.r[31].s64 = ctx.r[11].s64 + -10028;
	// 829EA8BC: 816AD8DC  lwz r11, -0x2724(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10020 as u32) ) } as u64;
	// 829EA8C0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829EA8C4: 40820024  bne 0x829ea8e8
	if !ctx.cr[0].eq {
	pc = 0x829EA8E8; continue 'dispatch;
	}
	// 829EA8C8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829EA8CC: 3D00829F  lis r8, -0x7d61
	ctx.r[8].s64 = -2103508992;
	// 829EA8D0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829EA8D4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829EA8D8: 3908A200  addi r8, r8, -0x5e00
	ctx.r[8].s64 = ctx.r[8].s64 + -24064;
	// 829EA8DC: 916AD8DC  stw r11, -0x2724(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-10020 as u32), ctx.r[11].u32 ) };
	// 829EA8E0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829EA8E4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829EA8E8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EA8EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829EA8F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EA8F4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829EA8F8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829EA8FC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA900: 4BC69CC1  bl 0x826545c0
	ctx.lr = 0x829EA904;
	sub_826545C0(ctx, base);
	// 829EA904: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EA908: 4182000C  beq 0x829ea914
	if ctx.cr[0].eq {
	pc = 0x829EA914; continue 'dispatch;
	}
	// 829EA90C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EA910: 48000008  b 0x829ea918
	pc = 0x829EA918; continue 'dispatch;
	// 829EA914: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829EA918: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EA91C: 487BD8A0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EA920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EA920 size=1212
    let mut pc: u32 = 0x829EA920;
    'dispatch: loop {
        match pc {
            0x829EA920 => {
    //   block [0x829EA920..0x829EADDC)
	// 829EA920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EA924: 487BD835  bl 0x831a8158
	ctx.lr = 0x829EA928;
	sub_831A8130(ctx, base);
	// 829EA928: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 829EA92C: 487BE149  bl 0x831a8a74
	ctx.lr = 0x829EA930;
	sub_831A8A40(ctx, base);
	// 829EA930: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EA934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EA938: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 829EA93C: 4BB2709D  bl 0x825119d8
	ctx.lr = 0x829EA940;
	sub_825119D8(ctx, base);
	// 829EA940: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829EA944: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA948: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829EA94C: 484090BD  bl 0x82df3a08
	ctx.lr = 0x829EA950;
	sub_82DF3A08(ctx, base);
	// 829EA950: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EA954: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EA958: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829EA95C: 4BB1DE25  bl 0x82508780
	ctx.lr = 0x829EA960;
	sub_82508780(ctx, base);
	// 829EA960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EA964: 48408AC5  bl 0x82df3428
	ctx.lr = 0x829EA968;
	sub_82DF3428(ctx, base);
	// 829EA968: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829EA96C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EA970: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829EA974: 409A0008  bne cr6, 0x829ea97c
	if !ctx.cr[6].eq {
	pc = 0x829EA97C; continue 'dispatch;
	}
	// 829EA978: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829EA97C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829EA980: 4BB1DE21  bl 0x825087a0
	ctx.lr = 0x829EA984;
	sub_825087A0(ctx, base);
	// 829EA984: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EA988: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EA98C: 388B61E0  addi r4, r11, 0x61e0
	ctx.r[4].s64 = ctx.r[11].s64 + 25056;
	// 829EA990: 38A0007B  li r5, 0x7b
	ctx.r[5].s64 = 123;
	// 829EA994: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 829EA998: 48407A51  bl 0x82df23e8
	ctx.lr = 0x829EA99C;
	sub_82DF23E8(ctx, base);
	// 829EA99C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EA9A0: 41820010  beq 0x829ea9b0
	if ctx.cr[0].eq {
	pc = 0x829EA9B0; continue 'dispatch;
	}
	// 829EA9A4: 4BBA02F5  bl 0x8258ac98
	ctx.lr = 0x829EA9A8;
	sub_8258AC98(ctx, base);
	// 829EA9A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EA9AC: 48000008  b 0x829ea9b4
	pc = 0x829EA9B4; continue 'dispatch;
	// 829EA9B0: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 829EA9B4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829EA9B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EA9BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EA9C0: 4B91BFD1  bl 0x82306990
	ctx.lr = 0x829EA9C4;
	sub_82306990(ctx, base);
	// 829EA9C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829EA9C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EA9CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EA9D0: 4B8D5631  bl 0x822c0000
	ctx.lr = 0x829EA9D4;
	sub_822C0000(ctx, base);
	// 829EA9D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EA9D8: 3B5F0100  addi r26, r31, 0x100
	ctx.r[26].s64 = ctx.r[31].s64 + 256;
	// 829EA9DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 829EA9E0: 387A0004  addi r3, r26, 4
	ctx.r[3].s64 = ctx.r[26].s64 + 4;
	// 829EA9E4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 829EA9E8: 4B8D9A79  bl 0x822c4460
	ctx.lr = 0x829EA9EC;
	sub_822C4460(ctx, base);
	// 829EA9EC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EA9F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EA9F4: 419A0008  beq cr6, 0x829ea9fc
	if ctx.cr[6].eq {
	pc = 0x829EA9FC; continue 'dispatch;
	}
	// 829EA9F8: 4B8D5E99  bl 0x822c0890
	ctx.lr = 0x829EA9FC;
	sub_822C0890(ctx, base);
	// 829EA9FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAA00: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAA04: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829EAA08: 4BB24AC1  bl 0x8250f4c8
	ctx.lr = 0x829EAA0C;
	sub_8250F4C8(ctx, base);
	// 829EAA0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EAA14: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829EAA18: 409A0008  bne cr6, 0x829eaa20
	if !ctx.cr[6].eq {
	pc = 0x829EAA20; continue 'dispatch;
	}
	// 829EAA1C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829EAA20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829EAA24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EAA28: 4BB1E179  bl 0x82508ba0
	ctx.lr = 0x829EAA2C;
	sub_82508BA0(ctx, base);
	// 829EAA2C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829EAA30: 48407261  bl 0x82df1c90
	ctx.lr = 0x829EAA34;
	sub_82DF1C90(ctx, base);
	// 829EAA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAA38: 4BB28061  bl 0x82512a98
	ctx.lr = 0x829EAA3C;
	sub_82512A98(ctx, base);
	// 829EAA3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAA40: 4BB270A9  bl 0x82511ae8
	ctx.lr = 0x829EAA44;
	sub_82511AE8(ctx, base);
	// 829EAA44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EAA48: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829EAA4C: 4849158D  bl 0x82e7bfd8
	ctx.lr = 0x829EAA50;
	sub_82E7BFD8(ctx, base);
	// 829EAA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAA54: 4BB27105  bl 0x82511b58
	ctx.lr = 0x829EAA58;
	sub_82511B58(ctx, base);
	// 829EAA58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EAA5C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829EAA60: 48491849  bl 0x82e7c2a8
	ctx.lr = 0x829EAA64;
	sub_82E7C2A8(ctx, base);
	// 829EAA64: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EAA68: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 829EAA6C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829EAA70: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 829EAA74: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 829EAA78: 484B5CB9  bl 0x82ea0730
	ctx.lr = 0x829EAA7C;
	sub_82EA0730(ctx, base);
	// 829EAA7C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EAA80: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 829EAA84: 396B6260  addi r11, r11, 0x6260
	ctx.r[11].s64 = ctx.r[11].s64 + 25184;
	// 829EAA88: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 829EAA8C: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 829EAA90: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 829EAA94: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 829EAA98: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EADE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EADE0 size=132
    let mut pc: u32 = 0x829EADE0;
    'dispatch: loop {
        match pc {
            0x829EADE0 => {
    //   block [0x829EADE0..0x829EAE64)
	// 829EADE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EADE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EADE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EADEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EADF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EADF4: 816301C8  lwz r11, 0x1c8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(456 as u32) ) } as u64;
	// 829EADF8: 3BE301C8  addi r31, r3, 0x1c8
	ctx.r[31].s64 = ctx.r[3].s64 + 456;
	// 829EADFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EAE00: 419A004C  beq cr6, 0x829eae4c
	if ctx.cr[6].eq {
	pc = 0x829EAE4C; continue 'dispatch;
	}
	// 829EAE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EAE08: 4BB1FB49  bl 0x8250a950
	ctx.lr = 0x829EAE0C;
	sub_8250A950(ctx, base);
	// 829EAE0C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EAE10: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EAE14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EAE18: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829EAE1C: 409A0008  bne cr6, 0x829eae24
	if !ctx.cr[6].eq {
	pc = 0x829EAE24; continue 'dispatch;
	}
	// 829EAE20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EAE24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAE28: 4BDE8B49  bl 0x827d3970
	ctx.lr = 0x829EAE2C;
	sub_827D3970(ctx, base);
	// 829EAE2C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829EAE30: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EAE34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EAE38: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 829EAE3C: 419A0008  beq cr6, 0x829eae44
	if ctx.cr[6].eq {
	pc = 0x829EAE44; continue 'dispatch;
	}
	// 829EAE40: 4B8D5A51  bl 0x822c0890
	ctx.lr = 0x829EAE44;
	sub_822C0890(ctx, base);
	// 829EAE44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EAE48: 48406E49  bl 0x82df1c90
	ctx.lr = 0x829EAE4C;
	sub_82DF1C90(ctx, base);
	// 829EAE4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EAE50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EAE54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EAE58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EAE5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EAE60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EAE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EAE68 size=144
    let mut pc: u32 = 0x829EAE68;
    'dispatch: loop {
        match pc {
            0x829EAE68 => {
    //   block [0x829EAE68..0x829EAEF8)
	// 829EAE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EAE6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EAE70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EAE74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EAE78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EAE7C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829EAE80: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EAE84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EAE88: 814AD8E0  lwz r10, -0x2720(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10016 as u32) ) } as u64;
	// 829EAE8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EAE90: 419A0014  beq cr6, 0x829eaea4
	if ctx.cr[6].eq {
	pc = 0x829EAEA4; continue 'dispatch;
	}
	// 829EAE94: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829EAE98: 814AD8E4  lwz r10, -0x271c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10012 as u32) ) } as u64;
	// 829EAE9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EAEA0: 409A0040  bne cr6, 0x829eaee0
	if !ctx.cr[6].eq {
	pc = 0x829EAEE0; continue 'dispatch;
	}
	// 829EAEA4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829EAEA8: 4861D281  bl 0x83008128
	ctx.lr = 0x829EAEAC;
	sub_83008128(ctx, base);
	// 829EAEAC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829EAEB0: 3BFE01F8  addi r31, r30, 0x1f8
	ctx.r[31].s64 = ctx.r[30].s64 + 504;
	// 829EAEB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EAEB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAEBC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EAEC0: 4B989251  bl 0x82374110
	ctx.lr = 0x829EAEC4;
	sub_82374110(ctx, base);
	// 829EAEC4: 817E01FC  lwz r11, 0x1fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(508 as u32) ) } as u64;
	// 829EAEC8: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EAECC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829EAED0: 419A0010  beq cr6, 0x829eaee0
	if ctx.cr[6].eq {
	pc = 0x829EAEE0; continue 'dispatch;
	}
	// 829EAED4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAED8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EAEDC: 4B9352AD  bl 0x82320188
	ctx.lr = 0x829EAEE0;
	sub_82320188(ctx, base);
	// 829EAEE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EAEE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EAEE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EAEEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EAEF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EAEF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EAEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EAEF8 size=104
    let mut pc: u32 = 0x829EAEF8;
    'dispatch: loop {
        match pc {
            0x829EAEF8 => {
    //   block [0x829EAEF8..0x829EAF60)
	// 829EAEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EAEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EAF00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EAF04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EAF08: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829EAF0C: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EAF10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EAF14: 814AD8E0  lwz r10, -0x2720(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10016 as u32) ) } as u64;
	// 829EAF18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EAF1C: 419A0014  beq cr6, 0x829eaf30
	if ctx.cr[6].eq {
	pc = 0x829EAF30; continue 'dispatch;
	}
	// 829EAF20: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829EAF24: 814AD8E4  lwz r10, -0x271c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10012 as u32) ) } as u64;
	// 829EAF28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EAF2C: 409A0020  bne cr6, 0x829eaf4c
	if !ctx.cr[6].eq {
	pc = 0x829EAF4C; continue 'dispatch;
	}
	// 829EAF30: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829EAF34: 4861D1F5  bl 0x83008128
	ctx.lr = 0x829EAF38;
	sub_83008128(ctx, base);
	// 829EAF38: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 829EAF3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829EAF40: 389F01F8  addi r4, r31, 0x1f8
	ctx.r[4].s64 = ctx.r[31].s64 + 504;
	// 829EAF44: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EAF48: 4BB65A11  bl 0x82550958
	ctx.lr = 0x829EAF4C;
	sub_82550958(ctx, base);
	// 829EAF4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EAF50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EAF54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EAF58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EAF5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EAF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EAF60 size=164
    let mut pc: u32 = 0x829EAF60;
    'dispatch: loop {
        match pc {
            0x829EAF60 => {
    //   block [0x829EAF60..0x829EB004)
	// 829EAF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EAF64: 487BD205  bl 0x831a8168
	ctx.lr = 0x829EAF68;
	sub_831A8130(ctx, base);
	// 829EAF68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EAF6C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829EAF70: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EAF74: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EAF78: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829EAF7C: 41820038  beq 0x829eafb4
	if ctx.cr[0].eq {
	pc = 0x829EAFB4; continue 'dispatch;
	}
	// 829EAF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAF84: 487BEA05  bl 0x831a9988
	ctx.lr = 0x829EAF88;
	sub_831A9988(ctx, base);
	// 829EAF88: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829EAF8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EAF90: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829EAF94: 487BD165  bl 0x831a80f8
	ctx.lr = 0x829EAF98;
	sub_831A80F8(ctx, base);
	// 829EAF98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EAF9C: 41820018  beq 0x829eafb4
	if ctx.cr[0].eq {
	pc = 0x829EAFB4; continue 'dispatch;
	}
	// 829EAFA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAFA4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EAFA8: 4BFFFF51  bl 0x829eaef8
	ctx.lr = 0x829EAFAC;
	sub_829EAEF8(ctx, base);
	// 829EAFAC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EAFB0: 4800004C  b 0x829eaffc
	pc = 0x829EAFFC; continue 'dispatch;
	// 829EAFB4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829EAFB8: 419A0034  beq cr6, 0x829eafec
	if ctx.cr[6].eq {
	pc = 0x829EAFEC; continue 'dispatch;
	}
	// 829EAFBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EAFC0: 487BE9C9  bl 0x831a9988
	ctx.lr = 0x829EAFC4;
	sub_831A9988(ctx, base);
	// 829EAFC4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 829EAFC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EAFCC: 386B0B88  addi r3, r11, 0xb88
	ctx.r[3].s64 = ctx.r[11].s64 + 2952;
	// 829EAFD0: 487BD129  bl 0x831a80f8
	ctx.lr = 0x829EAFD4;
	sub_831A80F8(ctx, base);
	// 829EAFD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EAFD8: 41820014  beq 0x829eafec
	if ctx.cr[0].eq {
	pc = 0x829EAFEC; continue 'dispatch;
	}
	// 829EAFDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAFE0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EAFE4: 4BFFFE85  bl 0x829eae68
	ctx.lr = 0x829EAFE8;
	sub_829EAE68(ctx, base);
	// 829EAFE8: 4BFFFFC4  b 0x829eafac
	pc = 0x829EAFAC; continue 'dispatch;
	// 829EAFEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EAFF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EAFF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EAFF8: 4BB27621  bl 0x82512618
	ctx.lr = 0x829EAFFC;
	sub_82512618(ctx, base);
	// 829EAFFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EB000: 487BD1B8  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB008 size=172
    let mut pc: u32 = 0x829EB008;
    'dispatch: loop {
        match pc {
            0x829EB008 => {
    //   block [0x829EB008..0x829EB0B4)
	// 829EB008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB00C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EB010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EB014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EB018: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB01C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829EB020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EB024: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829EB028: 4BB27239  bl 0x82512260
	ctx.lr = 0x829EB02C;
	sub_82512260(ctx, base);
	// 829EB02C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EB030: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EB034: 396B6294  addi r11, r11, 0x6294
	ctx.r[11].s64 = ctx.r[11].s64 + 25236;
	// 829EB038: 394A627C  addi r10, r10, 0x627c
	ctx.r[10].s64 = ctx.r[10].s64 + 25212;
	// 829EB03C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EB040: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829EB044: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EB048: 4BB272E9  bl 0x82512330
	ctx.lr = 0x829EB04C;
	sub_82512330(ctx, base);
	// 829EB04C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EB050: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EB054: 93DF01C8  stw r30, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u32 ) };
	// 829EB058: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EB05C: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 829EB060: 387F01F8  addi r3, r31, 0x1f8
	ctx.r[3].s64 = ctx.r[31].s64 + 504;
	// 829EB064: 93DF01D0  stw r30, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[30].u32 ) };
	// 829EB068: 93DF01D4  stw r30, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[30].u32 ) };
	// 829EB06C: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EB070: 995F01DC  stb r10, 0x1dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[10].u8 ) };
	// 829EB074: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 829EB078: 93DF01E0  stw r30, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[30].u32 ) };
	// 829EB07C: 93DF01E4  stw r30, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[30].u32 ) };
	// 829EB080: 93DF01E8  stw r30, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[30].u32 ) };
	// 829EB084: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 829EB088: 93DF01F0  stw r30, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[30].u32 ) };
	// 829EB08C: 93DF01F4  stw r30, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[30].u32 ) };
	// 829EB090: 4BA49F81  bl 0x82435010
	ctx.lr = 0x829EB094;
	sub_82435010(ctx, base);
	// 829EB094: 93DF0204  stw r30, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[30].u32 ) };
	// 829EB098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB09C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EB0A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EB0A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EB0A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EB0AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EB0B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EB0B8 size=8
    let mut pc: u32 = 0x829EB0B8;
    'dispatch: loop {
        match pc {
            0x829EB0B8 => {
    //   block [0x829EB0B8..0x829EB0C0)
	// 829EB0B8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829EB0BC: 48000BD4  b 0x829ebc90
	sub_829EBC90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EB0C0 size=184
    let mut pc: u32 = 0x829EB0C0;
    'dispatch: loop {
        match pc {
            0x829EB0C0 => {
    //   block [0x829EB0C0..0x829EB178)
	// 829EB0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB0C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EB0C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EB0CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB0D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EB0D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EB0D8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EB0DC: 396B6294  addi r11, r11, 0x6294
	ctx.r[11].s64 = ctx.r[11].s64 + 25236;
	// 829EB0E0: 394A627C  addi r10, r10, 0x627c
	ctx.r[10].s64 = ctx.r[10].s64 + 25212;
	// 829EB0E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EB0E8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EB0EC: 807F0204  lwz r3, 0x204(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) } as u64;
	// 829EB0F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EB0F4: 419A0008  beq cr6, 0x829eb0fc
	if ctx.cr[6].eq {
	pc = 0x829EB0FC; continue 'dispatch;
	}
	// 829EB0F8: 4B8FD171  bl 0x822e8268
	ctx.lr = 0x829EB0FC;
	sub_822E8268(ctx, base);
	// 829EB0FC: 387F01F8  addi r3, r31, 0x1f8
	ctx.r[3].s64 = ctx.r[31].s64 + 504;
	// 829EB100: 4B935DF1  bl 0x82320ef0
	ctx.lr = 0x829EB104;
	sub_82320EF0(ctx, base);
	// 829EB104: 807F01F4  lwz r3, 0x1f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(500 as u32) ) } as u64;
	// 829EB108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EB10C: 419A0008  beq cr6, 0x829eb114
	if ctx.cr[6].eq {
	pc = 0x829EB114; continue 'dispatch;
	}
	// 829EB110: 4B8D5781  bl 0x822c0890
	ctx.lr = 0x829EB114;
	sub_822C0890(ctx, base);
	// 829EB114: 807F01EC  lwz r3, 0x1ec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) } as u64;
	// 829EB118: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EB11C: 419A0008  beq cr6, 0x829eb124
	if ctx.cr[6].eq {
	pc = 0x829EB124; continue 'dispatch;
	}
	// 829EB120: 4B8D5771  bl 0x822c0890
	ctx.lr = 0x829EB124;
	sub_822C0890(ctx, base);
	// 829EB124: 807F01E4  lwz r3, 0x1e4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(484 as u32) ) } as u64;
	// 829EB128: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EB12C: 419A0008  beq cr6, 0x829eb134
	if ctx.cr[6].eq {
	pc = 0x829EB134; continue 'dispatch;
	}
	// 829EB130: 4B8D5761  bl 0x822c0890
	ctx.lr = 0x829EB134;
	sub_822C0890(ctx, base);
	// 829EB134: 807F01D4  lwz r3, 0x1d4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 829EB138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EB13C: 419A0008  beq cr6, 0x829eb144
	if ctx.cr[6].eq {
	pc = 0x829EB144; continue 'dispatch;
	}
	// 829EB140: 4B8D5751  bl 0x822c0890
	ctx.lr = 0x829EB144;
	sub_822C0890(ctx, base);
	// 829EB144: 807F01CC  lwz r3, 0x1cc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 829EB148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EB14C: 419A0008  beq cr6, 0x829eb154
	if ctx.cr[6].eq {
	pc = 0x829EB154; continue 'dispatch;
	}
	// 829EB150: 4B8D5741  bl 0x822c0890
	ctx.lr = 0x829EB154;
	sub_822C0890(ctx, base);
	// 829EB154: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829EB158: 4B9641F9  bl 0x8234f350
	ctx.lr = 0x829EB15C;
	sub_8234F350(ctx, base);
	// 829EB15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB160: 4B9641F1  bl 0x8234f350
	ctx.lr = 0x829EB164;
	sub_8234F350(ctx, base);
	// 829EB164: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EB168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EB16C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EB170: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EB174: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB178 size=1492
    let mut pc: u32 = 0x829EB178;
    'dispatch: loop {
        match pc {
            0x829EB178 => {
    //   block [0x829EB178..0x829EB74C)
	// 829EB178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB17C: 487BCFD9  bl 0x831a8154
	ctx.lr = 0x829EB180;
	sub_831A8130(ctx, base);
	// 829EB180: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB184: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829EB188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EB18C: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 829EB190: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 829EB194: 4BB26845  bl 0x825119d8
	ctx.lr = 0x829EB198;
	sub_825119D8(ctx, base);
	// 829EB198: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829EB19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB1A0: 4BB241D1  bl 0x8250f370
	ctx.lr = 0x829EB1A4;
	sub_8250F370(ctx, base);
	// 829EB1A4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829EB1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EB1AC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829EB1B0: 48408859  bl 0x82df3a08
	ctx.lr = 0x829EB1B4;
	sub_82DF3A08(ctx, base);
	// 829EB1B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EB1B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EB1BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829EB1C0: 4BB1D5C1  bl 0x82508780
	ctx.lr = 0x829EB1C4;
	sub_82508780(ctx, base);
	// 829EB1C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EB1C8: 48408261  bl 0x82df3428
	ctx.lr = 0x829EB1CC;
	sub_82DF3428(ctx, base);
	// 829EB1CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EB1D0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829EB1D4: 409A0008  bne cr6, 0x829eb1dc
	if !ctx.cr[6].eq {
	pc = 0x829EB1DC; continue 'dispatch;
	}
	// 829EB1D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EB1DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829EB1E0: 4BB1D5C1  bl 0x825087a0
	ctx.lr = 0x829EB1E4;
	sub_825087A0(ctx, base);
	// 829EB1E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EB1E8: 4BB278B1  bl 0x82512a98
	ctx.lr = 0x829EB1EC;
	sub_82512A98(ctx, base);
	// 829EB1EC: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829EB1F0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EB1F4: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EB1F8: 396B4BC0  addi r11, r11, 0x4bc0
	ctx.r[11].s64 = ctx.r[11].s64 + 19392;
	// 829EB1FC: 394A6350  addi r10, r10, 0x6350
	ctx.r[10].s64 = ctx.r[10].s64 + 25424;
	// 829EB200: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 829EB204: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 829EB208: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 829EB20C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829EB210: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829EB214: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829EB218: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EB750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EB750 size=1120
    let mut pc: u32 = 0x829EB750;
    'dispatch: loop {
        match pc {
            0x829EB750 => {
    //   block [0x829EB750..0x829EBBB0)
	// 829EB750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EB754: 487BCA01  bl 0x831a8154
	ctx.lr = 0x829EB758;
	sub_831A8130(ctx, base);
	// 829EB758: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 829EB75C: 487BD31D  bl 0x831a8a78
	ctx.lr = 0x829EB760;
	sub_831A8A40(ctx, base);
	// 829EB760: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EB764: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EB768: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EB76C: 3BCBD5FC  addi r30, r11, -0x2a04
	ctx.r[30].s64 = ctx.r[11].s64 + -10756;
	// 829EB770: C01D01D8  lfs f0, 0x1d8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EB774: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 829EB778: C1ABD5FC  lfs f13, -0x2a04(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10756 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EB77C: D01D01D8  stfs f0, 0x1d8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 829EB780: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 829EB784: 4198000C  blt cr6, 0x829eb790
	if ctx.cr[6].lt {
	pc = 0x829EB790; continue 'dispatch;
	}
	// 829EB788: 4BB24E49  bl 0x825105d0
	ctx.lr = 0x829EB78C;
	sub_825105D0(ctx, base);
	// 829EB78C: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EB790: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EB794: 893D01DC  lbz r9, 0x1dc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(476 as u32) ) } as u64;
	// 829EB798: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829EB79C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EB7A0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EB7A4: 3BEB6270  addi r31, r11, 0x6270
	ctx.r[31].s64 = ctx.r[11].s64 + 25200;
	// 829EB7A8: C3AA08A8  lfs f29, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829EB7AC: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829EB7B0: 41820020  beq 0x829eb7d0
	if ctx.cr[0].eq {
	pc = 0x829EB7D0; continue 'dispatch;
	}
	// 829EB7B4: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EB7B8: 807D0204  lwz r3, 0x204(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(516 as u32) ) } as u64;
	// 829EB7BC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 829EB7C0: C1BD01D8  lfs f13, 0x1d8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EB7C4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829EB7C8: 48532EA9  bl 0x82f1e670
	ctx.lr = 0x829EB7CC;
	sub_82F1E670(ctx, base);
	// 829EB7CC: 480000C0  b 0x829eb88c
	pc = 0x829EB88C; continue 'dispatch;
	// 829EB7D0: 817D01E0  lwz r11, 0x1e0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(480 as u32) ) } as u64;
	// 829EB7D4: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 829EB7D8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 829EB7DC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829EB7E0: 13CB50C7  vcmpequd (lvx128) v30, v11, v10
	tmp.u32 = ctx.r[11].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EBBB0 size=220
    let mut pc: u32 = 0x829EBBB0;
    'dispatch: loop {
        match pc {
            0x829EBBB0 => {
    //   block [0x829EBBB0..0x829EBC8C)
	// 829EBBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBBB4: 487BC5B5  bl 0x831a8168
	ctx.lr = 0x829EBBB8;
	sub_831A8130(ctx, base);
	// 829EBBB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBBBC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829EBBC0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EBBC4: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829EBBC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBBCC: 4BB26695  bl 0x82512260
	ctx.lr = 0x829EBBD0;
	sub_82512260(ctx, base);
	// 829EBBD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EBBD4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EBBD8: 396B6294  addi r11, r11, 0x6294
	ctx.r[11].s64 = ctx.r[11].s64 + 25236;
	// 829EBBDC: 394A627C  addi r10, r10, 0x627c
	ctx.r[10].s64 = ctx.r[10].s64 + 25212;
	// 829EBBE0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EBBE4: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829EBBE8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EBBEC: 4BB26745  bl 0x82512330
	ctx.lr = 0x829EBBF0;
	sub_82512330(ctx, base);
	// 829EBBF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EBBF4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EBBF8: 93DF01C8  stw r30, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[30].u32 ) };
	// 829EBBFC: 397F01E0  addi r11, r31, 0x1e0
	ctx.r[11].s64 = ctx.r[31].s64 + 480;
	// 829EBC00: 93DF01CC  stw r30, 0x1cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), ctx.r[30].u32 ) };
	// 829EBC04: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 829EBC08: 93DF01D0  stw r30, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[30].u32 ) };
	// 829EBC0C: 93DF01D4  stw r30, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[30].u32 ) };
	// 829EBC10: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EBC14: 9BDF01DC  stb r30, 0x1dc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), ctx.r[30].u8 ) };
	// 829EBC18: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 829EBC1C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBC20: 917F01E0  stw r11, 0x1e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 829EBC24: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EBC28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EBC2C: 917F01E4  stw r11, 0x1e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 829EBC30: 419A0024  beq cr6, 0x829ebc54
	if ctx.cr[6].eq {
	pc = 0x829EBC54; continue 'dispatch;
	}
	// 829EBC34: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829EBC38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EBC3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EBC40: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EBC44: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EBC48: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EBC4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EBC50: 4082FFE8  bne 0x829ebc38
	if !ctx.cr[0].eq {
	pc = 0x829EBC38; continue 'dispatch;
	}
	// 829EBC54: 93DF01E8  stw r30, 0x1e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), ctx.r[30].u32 ) };
	// 829EBC58: 387F01F8  addi r3, r31, 0x1f8
	ctx.r[3].s64 = ctx.r[31].s64 + 504;
	// 829EBC5C: 93DF01EC  stw r30, 0x1ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), ctx.r[30].u32 ) };
	// 829EBC60: 93DF01F0  stw r30, 0x1f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(496 as u32), ctx.r[30].u32 ) };
	// 829EBC64: 93DF01F4  stw r30, 0x1f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(500 as u32), ctx.r[30].u32 ) };
	// 829EBC68: 4BA493A9  bl 0x82435010
	ctx.lr = 0x829EBC6C;
	sub_82435010(ctx, base);
	// 829EBC6C: 93DF0204  stw r30, 0x204(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), ctx.r[30].u32 ) };
	// 829EBC70: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBC74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EBC78: 419A0008  beq cr6, 0x829ebc80
	if ctx.cr[6].eq {
	pc = 0x829EBC80; continue 'dispatch;
	}
	// 829EBC7C: 4B8D4C15  bl 0x822c0890
	ctx.lr = 0x829EBC80;
	sub_822C0890(ctx, base);
	// 829EBC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBC84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EBC88: 487BC530  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EBC90 size=76
    let mut pc: u32 = 0x829EBC90;
    'dispatch: loop {
        match pc {
            0x829EBC90 => {
    //   block [0x829EBC90..0x829EBCDC)
	// 829EBC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EBC98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EBC9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EBCA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBCA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBCA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EBCAC: 4BFFF415  bl 0x829eb0c0
	ctx.lr = 0x829EBCB0;
	sub_829EB0C0(ctx, base);
	// 829EBCB0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EBCB4: 4182000C  beq 0x829ebcc0
	if ctx.cr[0].eq {
	pc = 0x829EBCC0; continue 'dispatch;
	}
	// 829EBCB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBCBC: 4840671D  bl 0x82df23d8
	ctx.lr = 0x829EBCC0;
	sub_82DF23D8(ctx, base);
	// 829EBCC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBCC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EBCC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EBCCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EBCD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EBCD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EBCD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EBCE0 size=68
    let mut pc: u32 = 0x829EBCE0;
    'dispatch: loop {
        match pc {
            0x829EBCE0 => {
    //   block [0x829EBCE0..0x829EBD24)
	// 829EBCE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBCE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EBCE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EBCEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EBCF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBCF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBCF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EBCFC: 4BB24A0D  bl 0x82510708
	ctx.lr = 0x829EBD00;
	sub_82510708(ctx, base);
	// 829EBD00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBD04: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EBD08: 4BFFFA49  bl 0x829eb750
	ctx.lr = 0x829EBD0C;
	sub_829EB750(ctx, base);
	// 829EBD0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EBD10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EBD14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EBD18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EBD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EBD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EBD28 size=132
    let mut pc: u32 = 0x829EBD28;
    'dispatch: loop {
        match pc {
            0x829EBD28 => {
    //   block [0x829EBD28..0x829EBDAC)
	// 829EBD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBD2C: 487BC439  bl 0x831a8164
	ctx.lr = 0x829EBD30;
	sub_831A8130(ctx, base);
	// 829EBD30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBD38: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829EBD3C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 829EBD40: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 829EBD44: 4BF99D0D  bl 0x82985a50
	ctx.lr = 0x829EBD48;
	sub_82985A50(ctx, base);
	// 829EBD48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EBD4C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EBD50: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 829EBD54: 394A638C  addi r10, r10, 0x638c
	ctx.r[10].s64 = ctx.r[10].s64 + 25484;
	// 829EBD58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EBD5C: 3BDF0118  addi r30, r31, 0x118
	ctx.r[30].s64 = ctx.r[31].s64 + 280;
	// 829EBD60: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EBD64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EBD68: 486C6159  bl 0x830b1ec0
	ctx.lr = 0x829EBD6C;
	sub_830B1EC0(ctx, base);
	// 829EBD6C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EBD70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EBD74: 396BD3E4  addi r11, r11, -0x2c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -11292;
	// 829EBD78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EBD7C: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 829EBD80: 486C6219  bl 0x830b1f98
	ctx.lr = 0x829EBD84;
	sub_830B1F98(ctx, base);
	// 829EBD84: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 829EBD88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EBD8C: 93BF0124  stw r29, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[29].u32 ) };
	// 829EBD90: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 829EBD94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBD98: 937F0128  stw r27, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[27].u32 ) };
	// 829EBD9C: 939F012C  stw r28, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[28].u32 ) };
	// 829EBDA0: 995F0130  stb r10, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[10].u8 ) };
	// 829EBDA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EBDA8: 487BC40C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EBDB0 size=8
    let mut pc: u32 = 0x829EBDB0;
    'dispatch: loop {
        match pc {
            0x829EBDB0 => {
    //   block [0x829EBDB0..0x829EBDB8)
	// 829EBDB0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829EBDB4: 48000B1C  b 0x829ec8d0
	sub_829EC8D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBDB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EBDB8 size=80
    let mut pc: u32 = 0x829EBDB8;
    'dispatch: loop {
        match pc {
            0x829EBDB8 => {
    //   block [0x829EBDB8..0x829EBE08)
	// 829EBDB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBDBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EBDC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EBDC4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBDC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBDCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EBDD0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EBDD4: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 829EBDD8: 394A638C  addi r10, r10, 0x638c
	ctx.r[10].s64 = ctx.r[10].s64 + 25484;
	// 829EBDDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EBDE0: 387F0118  addi r3, r31, 0x118
	ctx.r[3].s64 = ctx.r[31].s64 + 280;
	// 829EBDE4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EBDE8: 486C60F1  bl 0x830b1ed8
	ctx.lr = 0x829EBDEC;
	sub_830B1ED8(ctx, base);
	// 829EBDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBDF0: 4BF99AC9  bl 0x829858b8
	ctx.lr = 0x829EBDF4;
	sub_829858B8(ctx, base);
	// 829EBDF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EBDF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EBDFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EBE00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EBE04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EBE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EBE08 size=936
    let mut pc: u32 = 0x829EBE08;
    'dispatch: loop {
        match pc {
            0x829EBE08 => {
    //   block [0x829EBE08..0x829EC1B0)
	// 829EBE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EBE0C: 487BC35D  bl 0x831a8168
	ctx.lr = 0x829EBE10;
	sub_831A8130(ctx, base);
	// 829EBE10: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829EBE14: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829EBE18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EBE1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBE20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBE24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EBE28: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829EBE2C: 486C6095  bl 0x830b1ec0
	ctx.lr = 0x829EBE30;
	sub_830B1EC0(ctx, base);
	// 829EBE30: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EBE34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EBE38: 396BD3E4  addi r11, r11, -0x2c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -11292;
	// 829EBE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBE40: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EBE44: 486C6155  bl 0x830b1f98
	ctx.lr = 0x829EBE48;
	sub_830B1F98(ctx, base);
	// 829EBE48: 7BAB0020  clrldi r11, r29, 0x20
	ctx.r[11].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 829EBE4C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829EBE50: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 829EBE54: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 829EBE58: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829EBE5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EBE60: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829EBE64: 41980188  blt cr6, 0x829ebfec
	if ctx.cr[6].lt {
	pc = 0x829EBFEC; continue 'dispatch;
	}
	// 829EBE68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBE6C: 4BF998ED  bl 0x82985758
	ctx.lr = 0x829EBE70;
	sub_82985758(ctx, base);
	// 829EBE70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EBE74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBE78: 486C61B1  bl 0x830b2028
	ctx.lr = 0x829EBE7C;
	sub_830B2028(ctx, base);
	// 829EBE7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EBE80: 486C6059  bl 0x830b1ed8
	ctx.lr = 0x829EBE84;
	sub_830B1ED8(ctx, base);
	// 829EBE84: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829EBE88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBE8C: 3BCBC6F0  addi r30, r11, -0x3910
	ctx.r[30].s64 = ctx.r[11].s64 + -14608;
	// 829EBE90: 486C6099  bl 0x830b1f28
	ctx.lr = 0x829EBE94;
	sub_830B1F28(ctx, base);
	// 829EBE94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EBE98: 486C6A11  bl 0x830b28a8
	ctx.lr = 0x829EBE9C;
	sub_830B28A8(ctx, base);
	// 829EBE9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBEA0: 486C6089  bl 0x830b1f28
	ctx.lr = 0x829EBEA4;
	sub_830B1F28(ctx, base);
	// 829EBEA4: 486C62C5  bl 0x830b2168
	ctx.lr = 0x829EBEA8;
	sub_830B2168(ctx, base);
	// 829EBEA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBEAC: 486C607D  bl 0x830b1f28
	ctx.lr = 0x829EBEB0;
	sub_830B1F28(ctx, base);
	// 829EBEB0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829EBEB4: 480F748D  bl 0x82ae3340
	ctx.lr = 0x829EBEB8;
	sub_82AE3340(ctx, base);
	// 829EBEB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBEBC: 486C606D  bl 0x830b1f28
	ctx.lr = 0x829EBEC0;
	sub_830B1F28(ctx, base);
	// 829EBEC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EBEC4: 486C62C5  bl 0x830b2188
	ctx.lr = 0x829EBEC8;
	sub_830B2188(ctx, base);
	// 829EBEC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBECC: 486C605D  bl 0x830b1f28
	ctx.lr = 0x829EBED0;
	sub_830B1F28(ctx, base);
	// 829EBED0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EBED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBED8: 486C6051  bl 0x830b1f28
	ctx.lr = 0x829EBEDC;
	sub_830B1F28(ctx, base);
	// 829EBEDC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829EBEE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EBEE4: 486C625D  bl 0x830b2140
	ctx.lr = 0x829EBEE8;
	sub_830B2140(ctx, base);
	// 829EBEE8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829EBEEC: 486C626D  bl 0x830b2158
	ctx.lr = 0x829EBEF0;
	sub_830B2158(ctx, base);
	// 829EBEF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBEF4: 486C6035  bl 0x830b1f28
	ctx.lr = 0x829EBEF8;
	sub_830B1F28(ctx, base);
	// 829EBEF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EBEFC: 486C624D  bl 0x830b2148
	ctx.lr = 0x829EBF00;
	sub_830B2148(ctx, base);
	// 829EBF00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF04: 486C6025  bl 0x830b1f28
	ctx.lr = 0x829EBF08;
	sub_830B1F28(ctx, base);
	// 829EBF08: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 829EBF0C: 397D6384  addi r11, r29, 0x6384
	ctx.r[11].s64 = ctx.r[29].s64 + 25476;
	// 829EBF10: C02BFFFC  lfs f1, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EBF14: 486C61F5  bl 0x830b2108
	ctx.lr = 0x829EBF18;
	sub_830B2108(ctx, base);
	// 829EBF18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF1C: 486C600D  bl 0x830b1f28
	ctx.lr = 0x829EBF20;
	sub_830B1F28(ctx, base);
	// 829EBF20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EBF24: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EBF28: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829EBF2C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EBF30: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EBF34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EBF38: 4E800421  bctrl
	ctx.lr = 0x829EBF3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EBF3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF40: 486C5FE9  bl 0x830b1f28
	ctx.lr = 0x829EBF44;
	sub_830B1F28(ctx, base);
	// 829EBF44: 486C6235  bl 0x830b2178
	ctx.lr = 0x829EBF48;
	sub_830B2178(ctx, base);
	// 829EBF48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EBF4C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EBF50: 4BF99841  bl 0x82985790
	ctx.lr = 0x829EBF54;
	sub_82985790(ctx, base);
	// 829EBF54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EBF58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF5C: 486C60CD  bl 0x830b2028
	ctx.lr = 0x829EBF60;
	sub_830B2028(ctx, base);
	// 829EBF60: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EBF64: 486C5F75  bl 0x830b1ed8
	ctx.lr = 0x829EBF68;
	sub_830B1ED8(ctx, base);
	// 829EBF68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF6C: 486C5FBD  bl 0x830b1f28
	ctx.lr = 0x829EBF70;
	sub_830B1F28(ctx, base);
	// 829EBF70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EBF74: 486C6935  bl 0x830b28a8
	ctx.lr = 0x829EBF78;
	sub_830B28A8(ctx, base);
	// 829EBF78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF7C: 486C5FAD  bl 0x830b1f28
	ctx.lr = 0x829EBF80;
	sub_830B1F28(ctx, base);
	// 829EBF80: 486C61E9  bl 0x830b2168
	ctx.lr = 0x829EBF84;
	sub_830B2168(ctx, base);
	// 829EBF84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF88: 486C5FA1  bl 0x830b1f28
	ctx.lr = 0x829EBF8C;
	sub_830B1F28(ctx, base);
	// 829EBF8C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829EBF90: 480F73B1  bl 0x82ae3340
	ctx.lr = 0x829EBF94;
	sub_82AE3340(ctx, base);
	// 829EBF94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBF98: 486C5F91  bl 0x830b1f28
	ctx.lr = 0x829EBF9C;
	sub_830B1F28(ctx, base);
	// 829EBF9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EBFA0: 486C61E9  bl 0x830b2188
	ctx.lr = 0x829EBFA4;
	sub_830B2188(ctx, base);
	// 829EBFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBFA8: 486C5F81  bl 0x830b1f28
	ctx.lr = 0x829EBFAC;
	sub_830B1F28(ctx, base);
	// 829EBFAC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EBFB0: 486C6199  bl 0x830b2148
	ctx.lr = 0x829EBFB4;
	sub_830B2148(ctx, base);
	// 829EBFB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBFB8: 486C5F71  bl 0x830b1f28
	ctx.lr = 0x829EBFBC;
	sub_830B1F28(ctx, base);
	// 829EBFBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EBFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBFC4: 486C5F65  bl 0x830b1f28
	ctx.lr = 0x829EBFC8;
	sub_830B1F28(ctx, base);
	// 829EBFC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EBFCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EBFD0: 486C6171  bl 0x830b2140
	ctx.lr = 0x829EBFD4;
	sub_830B2140(ctx, base);
	// 829EBFD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EBFD8: 486C6181  bl 0x830b2158
	ctx.lr = 0x829EBFDC;
	sub_830B2158(ctx, base);
	// 829EBFDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBFE0: 486C5F49  bl 0x830b1f28
	ctx.lr = 0x829EBFE4;
	sub_830B1F28(ctx, base);
	// 829EBFE4: C03D6384  lfs f1, 0x6384(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25476 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EBFE8: 48000184  b 0x829ec16c
	pc = 0x829EC16C; continue 'dispatch;
	// 829EBFEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EBFF0: 4BF99769  bl 0x82985758
	ctx.lr = 0x829EBFF4;
	sub_82985758(ctx, base);
	// 829EBFF4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EBFF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EBFFC: 486C602D  bl 0x830b2028
	ctx.lr = 0x829EC000;
	sub_830B2028(ctx, base);
	// 829EC000: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC004: 486C5ED5  bl 0x830b1ed8
	ctx.lr = 0x829EC008;
	sub_830B1ED8(ctx, base);
	// 829EC008: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829EC00C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC010: 3BCBC6F0  addi r30, r11, -0x3910
	ctx.r[30].s64 = ctx.r[11].s64 + -14608;
	// 829EC014: 486C5F15  bl 0x830b1f28
	ctx.lr = 0x829EC018;
	sub_830B1F28(ctx, base);
	// 829EC018: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC01C: 486C688D  bl 0x830b28a8
	ctx.lr = 0x829EC020;
	sub_830B28A8(ctx, base);
	// 829EC020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC024: 486C5F05  bl 0x830b1f28
	ctx.lr = 0x829EC028;
	sub_830B1F28(ctx, base);
	// 829EC028: 486C6141  bl 0x830b2168
	ctx.lr = 0x829EC02C;
	sub_830B2168(ctx, base);
	// 829EC02C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC030: 486C5EF9  bl 0x830b1f28
	ctx.lr = 0x829EC034;
	sub_830B1F28(ctx, base);
	// 829EC034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC038: 480F7309  bl 0x82ae3340
	ctx.lr = 0x829EC03C;
	sub_82AE3340(ctx, base);
	// 829EC03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC040: 486C5EE9  bl 0x830b1f28
	ctx.lr = 0x829EC044;
	sub_830B1F28(ctx, base);
	// 829EC044: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC048: 486C6141  bl 0x830b2188
	ctx.lr = 0x829EC04C;
	sub_830B2188(ctx, base);
	// 829EC04C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC050: 486C5ED9  bl 0x830b1f28
	ctx.lr = 0x829EC054;
	sub_830B1F28(ctx, base);
	// 829EC054: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EC058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC05C: 486C5ECD  bl 0x830b1f28
	ctx.lr = 0x829EC060;
	sub_830B1F28(ctx, base);
	// 829EC060: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829EC064: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EC068: 486C60D9  bl 0x830b2140
	ctx.lr = 0x829EC06C;
	sub_830B2140(ctx, base);
	// 829EC06C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829EC070: 486C60D9  bl 0x830b2148
	ctx.lr = 0x829EC074;
	sub_830B2148(ctx, base);
	// 829EC074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC078: 486C5EB1  bl 0x830b1f28
	ctx.lr = 0x829EC07C;
	sub_830B1F28(ctx, base);
	// 829EC07C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC080: 486C60D9  bl 0x830b2158
	ctx.lr = 0x829EC084;
	sub_830B2158(ctx, base);
	// 829EC084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC088: 486C5EA1  bl 0x830b1f28
	ctx.lr = 0x829EC08C;
	sub_830B1F28(ctx, base);
	// 829EC08C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EC090: 3BAB6384  addi r29, r11, 0x6384
	ctx.r[29].s64 = ctx.r[11].s64 + 25476;
	// 829EC094: C02B6384  lfs f1, 0x6384(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25476 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EC098: 486C6071  bl 0x830b2108
	ctx.lr = 0x829EC09C;
	sub_830B2108(ctx, base);
	// 829EC09C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC0A0: 486C5E89  bl 0x830b1f28
	ctx.lr = 0x829EC0A4;
	sub_830B1F28(ctx, base);
	// 829EC0A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC0A8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC0AC: C3CB08A4  lfs f30, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829EC0B0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC0B4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC0B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC0BC: 4E800421  bctrl
	ctx.lr = 0x829EC0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC0C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC0C4: 486C5E65  bl 0x830b1f28
	ctx.lr = 0x829EC0C8;
	sub_830B1F28(ctx, base);
	// 829EC0C8: 486C60B1  bl 0x830b2178
	ctx.lr = 0x829EC0CC;
	sub_830B2178(ctx, base);
	// 829EC0CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC0D0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829EC0D4: 4BF996BD  bl 0x82985790
	ctx.lr = 0x829EC0D8;
	sub_82985790(ctx, base);
	// 829EC0D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC0DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC0E0: 486C5F49  bl 0x830b2028
	ctx.lr = 0x829EC0E4;
	sub_830B2028(ctx, base);
	// 829EC0E4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829EC0E8: 486C5DF1  bl 0x830b1ed8
	ctx.lr = 0x829EC0EC;
	sub_830B1ED8(ctx, base);
	// 829EC0EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC0F0: 486C5E39  bl 0x830b1f28
	ctx.lr = 0x829EC0F4;
	sub_830B1F28(ctx, base);
	// 829EC0F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC0F8: 486C67B1  bl 0x830b28a8
	ctx.lr = 0x829EC0FC;
	sub_830B28A8(ctx, base);
	// 829EC0FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC100: 486C5E29  bl 0x830b1f28
	ctx.lr = 0x829EC104;
	sub_830B1F28(ctx, base);
	// 829EC104: 486C6065  bl 0x830b2168
	ctx.lr = 0x829EC108;
	sub_830B2168(ctx, base);
	// 829EC108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC10C: 486C5E1D  bl 0x830b1f28
	ctx.lr = 0x829EC110;
	sub_830B1F28(ctx, base);
	// 829EC110: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC114: 480F722D  bl 0x82ae3340
	ctx.lr = 0x829EC118;
	sub_82AE3340(ctx, base);
	// 829EC118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC11C: 486C5E0D  bl 0x830b1f28
	ctx.lr = 0x829EC120;
	sub_830B1F28(ctx, base);
	// 829EC120: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC124: 486C6065  bl 0x830b2188
	ctx.lr = 0x829EC128;
	sub_830B2188(ctx, base);
	// 829EC128: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC12C: 486C5DFD  bl 0x830b1f28
	ctx.lr = 0x829EC130;
	sub_830B1F28(ctx, base);
	// 829EC130: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EC134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC138: 486C5DF1  bl 0x830b1f28
	ctx.lr = 0x829EC13C;
	sub_830B1F28(ctx, base);
	// 829EC13C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EC140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC144: 486C5FFD  bl 0x830b2140
	ctx.lr = 0x829EC148;
	sub_830B2140(ctx, base);
	// 829EC148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EC14C: 486C5FFD  bl 0x830b2148
	ctx.lr = 0x829EC150;
	sub_830B2148(ctx, base);
	// 829EC150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC154: 486C5DD5  bl 0x830b1f28
	ctx.lr = 0x829EC158;
	sub_830B1F28(ctx, base);
	// 829EC158: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC15C: 486C5FFD  bl 0x830b2158
	ctx.lr = 0x829EC160;
	sub_830B2158(ctx, base);
	// 829EC160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC164: 486C5DC5  bl 0x830b1f28
	ctx.lr = 0x829EC168;
	sub_830B1F28(ctx, base);
	// 829EC168: C03DFFFC  lfs f1, -4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EC16C: 486C5F9D  bl 0x830b2108
	ctx.lr = 0x829EC170;
	sub_830B2108(ctx, base);
	// 829EC170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC174: 486C5DB5  bl 0x830b1f28
	ctx.lr = 0x829EC178;
	sub_830B1F28(ctx, base);
	// 829EC178: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC17C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC180: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC184: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC188: 4E800421  bctrl
	ctx.lr = 0x829EC18C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC18C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC190: 486C5D99  bl 0x830b1f28
	ctx.lr = 0x829EC194;
	sub_830B1F28(ctx, base);
	// 829EC194: 486C5FE5  bl 0x830b2178
	ctx.lr = 0x829EC198;
	sub_830B2178(ctx, base);
	// 829EC198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC19C: 486C5D3D  bl 0x830b1ed8
	ctx.lr = 0x829EC1A0;
	sub_830B1ED8(ctx, base);
	// 829EC1A0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 829EC1A4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829EC1A8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829EC1AC: 487BC00C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC1B0 size=1028
    let mut pc: u32 = 0x829EC1B0;
    'dispatch: loop {
        match pc {
            0x829EC1B0 => {
    //   block [0x829EC1B0..0x829EC5B4)
	// 829EC1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC1B4: 487BBFB5  bl 0x831a8168
	ctx.lr = 0x829EC1B8;
	sub_831A8130(ctx, base);
	// 829EC1B8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 829EC1BC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 829EC1C0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829EC1C4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC1C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EC1CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC1D0: 486C5CF1  bl 0x830b1ec0
	ctx.lr = 0x829EC1D4;
	sub_830B1EC0(ctx, base);
	// 829EC1D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EC1D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC1DC: 396BD3E4  addi r11, r11, -0x2c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -11292;
	// 829EC1E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC1E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EC1E8: 486C5DB1  bl 0x830b1f98
	ctx.lr = 0x829EC1EC;
	sub_830B1F98(ctx, base);
	// 829EC1EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC1F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC1F4: 4BF9952D  bl 0x82985720
	ctx.lr = 0x829EC1F8;
	sub_82985720(ctx, base);
	// 829EC1F8: 486C5D31  bl 0x830b1f28
	ctx.lr = 0x829EC1FC;
	sub_830B1F28(ctx, base);
	// 829EC1FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EC200: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC204: 38ABF72C  addi r5, r11, -0x8d4
	ctx.r[5].s64 = ctx.r[11].s64 + -2260;
	// 829EC208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC20C: 486C915D  bl 0x830b5368
	ctx.lr = 0x829EC210;
	sub_830B5368(ctx, base);
	// 829EC210: 3BFE0118  addi r31, r30, 0x118
	ctx.r[31].s64 = ctx.r[30].s64 + 280;
	// 829EC214: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC21C: 486C5E0D  bl 0x830b2028
	ctx.lr = 0x829EC220;
	sub_830B2028(ctx, base);
	// 829EC220: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC224: 486C5CB5  bl 0x830b1ed8
	ctx.lr = 0x829EC228;
	sub_830B1ED8(ctx, base);
	// 829EC228: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC22C: 486C5CAD  bl 0x830b1ed8
	ctx.lr = 0x829EC230;
	sub_830B1ED8(ctx, base);
	// 829EC230: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC234: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EC238: 4BF99521  bl 0x82985758
	ctx.lr = 0x829EC23C;
	sub_82985758(ctx, base);
	// 829EC23C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC244: 486C5DE5  bl 0x830b2028
	ctx.lr = 0x829EC248;
	sub_830B2028(ctx, base);
	// 829EC248: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EC24C: 486C5C8D  bl 0x830b1ed8
	ctx.lr = 0x829EC250;
	sub_830B1ED8(ctx, base);
	// 829EC250: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829EC254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC258: 3BABC6F0  addi r29, r11, -0x3910
	ctx.r[29].s64 = ctx.r[11].s64 + -14608;
	// 829EC25C: 486C5CCD  bl 0x830b1f28
	ctx.lr = 0x829EC260;
	sub_830B1F28(ctx, base);
	// 829EC260: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EC264: 486C6645  bl 0x830b28a8
	ctx.lr = 0x829EC268;
	sub_830B28A8(ctx, base);
	// 829EC268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC26C: 486C5CBD  bl 0x830b1f28
	ctx.lr = 0x829EC270;
	sub_830B1F28(ctx, base);
	// 829EC270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC274: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829EC278: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC27C: 486C5ECD  bl 0x830b2148
	ctx.lr = 0x829EC280;
	sub_830B2148(ctx, base);
	// 829EC280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC284: 486C5CA5  bl 0x830b1f28
	ctx.lr = 0x829EC288;
	sub_830B1F28(ctx, base);
	// 829EC288: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 829EC28C: C03C637C  lfs f1, 0x637c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EC290: 486C5EC9  bl 0x830b2158
	ctx.lr = 0x829EC294;
	sub_830B2158(ctx, base);
	// 829EC294: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC298: 486C5C91  bl 0x830b1f28
	ctx.lr = 0x829EC29C;
	sub_830B1F28(ctx, base);
	// 829EC29C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC2A0: 486C5E91  bl 0x830b2130
	ctx.lr = 0x829EC2A4;
	sub_830B2130(ctx, base);
	// 829EC2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC2A8: 486C5C81  bl 0x830b1f28
	ctx.lr = 0x829EC2AC;
	sub_830B1F28(ctx, base);
	// 829EC2AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC2B0: 486C6CF9  bl 0x830b2fa8
	ctx.lr = 0x829EC2B4;
	sub_830B2FA8(ctx, base);
	// 829EC2B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC2B8: 486C5C71  bl 0x830b1f28
	ctx.lr = 0x829EC2BC;
	sub_830B1F28(ctx, base);
	// 829EC2BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC2C0: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829EC2C4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC2C8: 486C5E41  bl 0x830b2108
	ctx.lr = 0x829EC2CC;
	sub_830B2108(ctx, base);
	// 829EC2CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC2D0: 486C5C59  bl 0x830b1f28
	ctx.lr = 0x829EC2D4;
	sub_830B1F28(ctx, base);
	// 829EC2D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC2D8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC2DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC2E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC2E4: 4E800421  bctrl
	ctx.lr = 0x829EC2E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC2E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC2EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC2F0: 4BF994A1  bl 0x82985790
	ctx.lr = 0x829EC2F4;
	sub_82985790(ctx, base);
	// 829EC2F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC2F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC2FC: 486C5D2D  bl 0x830b2028
	ctx.lr = 0x829EC300;
	sub_830B2028(ctx, base);
	// 829EC300: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EC304: 486C5BD5  bl 0x830b1ed8
	ctx.lr = 0x829EC308;
	sub_830B1ED8(ctx, base);
	// 829EC308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC30C: 486C5C1D  bl 0x830b1f28
	ctx.lr = 0x829EC310;
	sub_830B1F28(ctx, base);
	// 829EC310: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EC314: 486C6595  bl 0x830b28a8
	ctx.lr = 0x829EC318;
	sub_830B28A8(ctx, base);
	// 829EC318: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC31C: 486C5C0D  bl 0x830b1f28
	ctx.lr = 0x829EC320;
	sub_830B1F28(ctx, base);
	// 829EC320: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC324: 486C5E25  bl 0x830b2148
	ctx.lr = 0x829EC328;
	sub_830B2148(ctx, base);
	// 829EC328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC32C: 486C5BFD  bl 0x830b1f28
	ctx.lr = 0x829EC330;
	sub_830B1F28(ctx, base);
	// 829EC330: C03C637C  lfs f1, 0x637c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(25468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EC334: 486C5E25  bl 0x830b2158
	ctx.lr = 0x829EC338;
	sub_830B2158(ctx, base);
	// 829EC338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC33C: 486C5BED  bl 0x830b1f28
	ctx.lr = 0x829EC340;
	sub_830B1F28(ctx, base);
	// 829EC340: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC344: 486C5DED  bl 0x830b2130
	ctx.lr = 0x829EC348;
	sub_830B2130(ctx, base);
	// 829EC348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC34C: 486C5BDD  bl 0x830b1f28
	ctx.lr = 0x829EC350;
	sub_830B1F28(ctx, base);
	// 829EC350: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC354: 486C6C55  bl 0x830b2fa8
	ctx.lr = 0x829EC358;
	sub_830B2FA8(ctx, base);
	// 829EC358: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC35C: 486C5BCD  bl 0x830b1f28
	ctx.lr = 0x829EC360;
	sub_830B1F28(ctx, base);
	// 829EC360: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC364: 486C5DA5  bl 0x830b2108
	ctx.lr = 0x829EC368;
	sub_830B2108(ctx, base);
	// 829EC368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC36C: 486C5BBD  bl 0x830b1f28
	ctx.lr = 0x829EC370;
	sub_830B1F28(ctx, base);
	// 829EC370: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC374: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC378: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC37C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC380: 4E800421  bctrl
	ctx.lr = 0x829EC384;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC388: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829EC38C: 4BF993CD  bl 0x82985758
	ctx.lr = 0x829EC390;
	sub_82985758(ctx, base);
	// 829EC390: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC394: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829EC398: 4BF993F9  bl 0x82985790
	ctx.lr = 0x829EC39C;
	sub_82985790(ctx, base);
	// 829EC39C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC3A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829EC3A4: 4BF99425  bl 0x829857c8
	ctx.lr = 0x829EC3A8;
	sub_829857C8(ctx, base);
	// 829EC3A8: 817E0124  lwz r11, 0x124(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(292 as u32) ) } as u64;
	// 829EC3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC3B0: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 829EC3B4: C8010078  lfd f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 829EC3B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829EC3BC: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829EC3C0: 486C5B69  bl 0x830b1f28
	ctx.lr = 0x829EC3C4;
	sub_830B1F28(ctx, base);
	// 829EC3C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EC3C8: 3BABF720  addi r29, r11, -0x8e0
	ctx.r[29].s64 = ctx.r[11].s64 + -2272;
	// 829EC3CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EC3D0: 486C64D9  bl 0x830b28a8
	ctx.lr = 0x829EC3D4;
	sub_830B28A8(ctx, base);
	// 829EC3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC3D8: 486C5B51  bl 0x830b1f28
	ctx.lr = 0x829EC3DC;
	sub_830B1F28(ctx, base);
	// 829EC3DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC3E0: 480F6F61  bl 0x82ae3340
	ctx.lr = 0x829EC3E4;
	sub_82AE3340(ctx, base);
	// 829EC3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC3E8: 486C5B41  bl 0x830b1f28
	ctx.lr = 0x829EC3EC;
	sub_830B1F28(ctx, base);
	// 829EC3EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC3F0: 486C5D99  bl 0x830b2188
	ctx.lr = 0x829EC3F4;
	sub_830B2188(ctx, base);
	// 829EC3F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC3F8: 486C5B31  bl 0x830b1f28
	ctx.lr = 0x829EC3FC;
	sub_830B1F28(ctx, base);
	// 829EC3FC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC400: 486C5D59  bl 0x830b2158
	ctx.lr = 0x829EC404;
	sub_830B2158(ctx, base);
	// 829EC404: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC408: 486C5B21  bl 0x830b1f28
	ctx.lr = 0x829EC40C;
	sub_830B1F28(ctx, base);
	// 829EC40C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC410: 486C5D21  bl 0x830b2130
	ctx.lr = 0x829EC414;
	sub_830B2130(ctx, base);
	// 829EC414: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC418: 486C5B11  bl 0x830b1f28
	ctx.lr = 0x829EC41C;
	sub_830B1F28(ctx, base);
	// 829EC41C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EC420: 486C6B89  bl 0x830b2fa8
	ctx.lr = 0x829EC424;
	sub_830B2FA8(ctx, base);
	// 829EC424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC428: 486C5B01  bl 0x830b1f28
	ctx.lr = 0x829EC42C;
	sub_830B1F28(ctx, base);
	// 829EC42C: 486C5D3D  bl 0x830b2168
	ctx.lr = 0x829EC430;
	sub_830B2168(ctx, base);
	// 829EC430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC434: 486C5AF5  bl 0x830b1f28
	ctx.lr = 0x829EC438;
	sub_830B1F28(ctx, base);
	// 829EC438: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC43C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC440: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC448: 4E800421  bctrl
	ctx.lr = 0x829EC44C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC450: 817E012C  lwz r11, 0x12c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(300 as u32) ) } as u64;
	// 829EC454: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 829EC458: C8010078  lfd f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 829EC45C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829EC460: FFA00018  frsp f29, f0
	ctx.f[29].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829EC464: 486C5AC5  bl 0x830b1f28
	ctx.lr = 0x829EC468;
	sub_830B1F28(ctx, base);
	// 829EC468: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EC46C: 388BD4F8  addi r4, r11, -0x2b08
	ctx.r[4].s64 = ctx.r[11].s64 + -11016;
	// 829EC470: 486C6439  bl 0x830b28a8
	ctx.lr = 0x829EC474;
	sub_830B28A8(ctx, base);
	// 829EC474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC478: 486C5AB1  bl 0x830b1f28
	ctx.lr = 0x829EC47C;
	sub_830B1F28(ctx, base);
	// 829EC47C: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829EC480: 486C5CB1  bl 0x830b2130
	ctx.lr = 0x829EC484;
	sub_830B2130(ctx, base);
	// 829EC484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC488: 486C5AA1  bl 0x830b1f28
	ctx.lr = 0x829EC48C;
	sub_830B1F28(ctx, base);
	// 829EC48C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC490: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC494: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC49C: 4E800421  bctrl
	ctx.lr = 0x829EC4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC4A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EC4A4: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 829EC4A8: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 829EC4AC: 3B8BD528  addi r28, r11, -0x2ad8
	ctx.r[28].s64 = ctx.r[11].s64 + -10968;
	// 829EC4B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EC4B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC4B8: 486C5B71  bl 0x830b2028
	ctx.lr = 0x829EC4BC;
	sub_830B2028(ctx, base);
	// 829EC4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC4C0: 486C5A69  bl 0x830b1f28
	ctx.lr = 0x829EC4C4;
	sub_830B1F28(ctx, base);
	// 829EC4C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC4C8: 480F6E79  bl 0x82ae3340
	ctx.lr = 0x829EC4CC;
	sub_82AE3340(ctx, base);
	// 829EC4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC4D0: 486C5A59  bl 0x830b1f28
	ctx.lr = 0x829EC4D4;
	sub_830B1F28(ctx, base);
	// 829EC4D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EC4D8: 486C5CB1  bl 0x830b2188
	ctx.lr = 0x829EC4DC;
	sub_830B2188(ctx, base);
	// 829EC4DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC4E0: 486C5A49  bl 0x830b1f28
	ctx.lr = 0x829EC4E4;
	sub_830B1F28(ctx, base);
	// 829EC4E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EC4E8: 486C63C1  bl 0x830b28a8
	ctx.lr = 0x829EC4EC;
	sub_830B28A8(ctx, base);
	// 829EC4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC4F0: 486C5A39  bl 0x830b1f28
	ctx.lr = 0x829EC4F4;
	sub_830B1F28(ctx, base);
	// 829EC4F4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC4F8: 486C5C61  bl 0x830b2158
	ctx.lr = 0x829EC4FC;
	sub_830B2158(ctx, base);
	// 829EC4FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC500: 486C5A29  bl 0x830b1f28
	ctx.lr = 0x829EC504;
	sub_830B1F28(ctx, base);
	// 829EC504: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829EC508: 486C5C29  bl 0x830b2130
	ctx.lr = 0x829EC50C;
	sub_830B2130(ctx, base);
	// 829EC50C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC510: 486C5A19  bl 0x830b1f28
	ctx.lr = 0x829EC514;
	sub_830B1F28(ctx, base);
	// 829EC514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC518: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC51C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC524: 4E800421  bctrl
	ctx.lr = 0x829EC528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC52C: 486C59FD  bl 0x830b1f28
	ctx.lr = 0x829EC530;
	sub_830B1F28(ctx, base);
	// 829EC530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829EC534: 486C6375  bl 0x830b28a8
	ctx.lr = 0x829EC538;
	sub_830B28A8(ctx, base);
	// 829EC538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC53C: 486C59ED  bl 0x830b1f28
	ctx.lr = 0x829EC540;
	sub_830B1F28(ctx, base);
	// 829EC540: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC544: 486C5BED  bl 0x830b2130
	ctx.lr = 0x829EC548;
	sub_830B2130(ctx, base);
	// 829EC548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC54C: 486C59DD  bl 0x830b1f28
	ctx.lr = 0x829EC550;
	sub_830B1F28(ctx, base);
	// 829EC550: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC554: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC558: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC55C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC560: 4E800421  bctrl
	ctx.lr = 0x829EC564;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC564: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC568: 486C59C1  bl 0x830b1f28
	ctx.lr = 0x829EC56C;
	sub_830B1F28(ctx, base);
	// 829EC56C: 486C5C0D  bl 0x830b2178
	ctx.lr = 0x829EC570;
	sub_830B2178(ctx, base);
	// 829EC570: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829EC574: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829EC578: 4082FF38  bne 0x829ec4b0
	if !ctx.cr[0].eq {
	pc = 0x829EC4B0; continue 'dispatch;
	}
	// 829EC57C: 3BE10098  addi r31, r1, 0x98
	ctx.r[31].s64 = ctx.r[1].s64 + 152;
	// 829EC580: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 829EC584: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 829EC588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC58C: 486C594D  bl 0x830b1ed8
	ctx.lr = 0x829EC590;
	sub_830B1ED8(ctx, base);
	// 829EC590: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829EC594: 4080FFF0  bge 0x829ec584
	if !ctx.cr[0].lt {
	pc = 0x829EC584; continue 'dispatch;
	}
	// 829EC598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC59C: 486C593D  bl 0x830b1ed8
	ctx.lr = 0x829EC5A0;
	sub_830B1ED8(ctx, base);
	// 829EC5A0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829EC5A4: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 829EC5A8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829EC5AC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829EC5B0: 487BBC08  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EC5B8 size=184
    let mut pc: u32 = 0x829EC5B8;
    'dispatch: loop {
        match pc {
            0x829EC5B8 => {
    //   block [0x829EC5B8..0x829EC670)
	// 829EC5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC5BC: 487BBBAD  bl 0x831a8168
	ctx.lr = 0x829EC5C0;
	sub_831A8130(ctx, base);
	// 829EC5C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC5C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EC5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC5CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EC5D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829EC5D4: 4BAFE4B5  bl 0x824eaa88
	ctx.lr = 0x829EC5D8;
	sub_824EAA88(ctx, base);
	// 829EC5D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC5DC: 4BAFCA55  bl 0x824e9030
	ctx.lr = 0x829EC5E0;
	sub_824E9030(ctx, base);
	// 829EC5E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829EC5E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC5E8: 484056A9  bl 0x82df1c90
	ctx.lr = 0x829EC5EC;
	sub_82DF1C90(ctx, base);
	// 829EC5EC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC5F0: 41820020  beq 0x829ec610
	if ctx.cr[0].eq {
	pc = 0x829EC610; continue 'dispatch;
	}
	// 829EC5F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC5F8: 4BAFE491  bl 0x824eaa88
	ctx.lr = 0x829EC5FC;
	sub_824EAA88(ctx, base);
	// 829EC5FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC600: 4BAFC7D1  bl 0x824e8dd0
	ctx.lr = 0x829EC604;
	sub_824E8DD0(ctx, base);
	// 829EC604: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC608: 48405689  bl 0x82df1c90
	ctx.lr = 0x829EC60C;
	sub_82DF1C90(ctx, base);
	// 829EC60C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829EC610: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829EC614: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829EC618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC61C: 4BFFF7ED  bl 0x829ebe08
	ctx.lr = 0x829EC620;
	sub_829EBE08(ctx, base);
	// 829EC620: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 829EC624: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 829EC628: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 829EC62C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC630: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC634: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 829EC638: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 829EC63C: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 829EC640: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 829EC644: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 829EC648: 915F00C4  stw r10, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[10].u32 ) };
	// 829EC64C: 4182001C  beq 0x829ec668
	if ctx.cr[0].eq {
	pc = 0x829EC668; continue 'dispatch;
	}
	// 829EC650: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC654: 4BAFE435  bl 0x824eaa88
	ctx.lr = 0x829EC658;
	sub_824EAA88(ctx, base);
	// 829EC658: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC65C: 4BAFC89D  bl 0x824e8ef8
	ctx.lr = 0x829EC660;
	sub_824E8EF8(ctx, base);
	// 829EC660: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC664: 4840562D  bl 0x82df1c90
	ctx.lr = 0x829EC668;
	sub_82DF1C90(ctx, base);
	// 829EC668: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EC66C: 487BBB4C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC670 size=232
    let mut pc: u32 = 0x829EC670;
    'dispatch: loop {
        match pc {
            0x829EC670 => {
    //   block [0x829EC670..0x829EC758)
	// 829EC670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC674: 487BBAF5  bl 0x831a8168
	ctx.lr = 0x829EC678;
	sub_831A8130(ctx, base);
	// 829EC678: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829EC67C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EC684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC688: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829EC68C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EC690: 4BAFE3F9  bl 0x824eaa88
	ctx.lr = 0x829EC694;
	sub_824EAA88(ctx, base);
	// 829EC694: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC698: 4BAFC999  bl 0x824e9030
	ctx.lr = 0x829EC69C;
	sub_824E9030(ctx, base);
	// 829EC69C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829EC6A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC6A4: 484055ED  bl 0x82df1c90
	ctx.lr = 0x829EC6A8;
	sub_82DF1C90(ctx, base);
	// 829EC6A8: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC6AC: 41820020  beq 0x829ec6cc
	if ctx.cr[0].eq {
	pc = 0x829EC6CC; continue 'dispatch;
	}
	// 829EC6B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC6B4: 4BAFE3D5  bl 0x824eaa88
	ctx.lr = 0x829EC6B8;
	sub_824EAA88(ctx, base);
	// 829EC6B8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC6BC: 4BAFC715  bl 0x824e8dd0
	ctx.lr = 0x829EC6C0;
	sub_824E8DD0(ctx, base);
	// 829EC6C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC6C4: 484055CD  bl 0x82df1c90
	ctx.lr = 0x829EC6C8;
	sub_82DF1C90(ctx, base);
	// 829EC6C8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829EC6CC: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EC6D0: 3BFF0118  addi r31, r31, 0x118
	ctx.r[31].s64 = ctx.r[31].s64 + 280;
	// 829EC6D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829EC6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC6DC: 3BAAD4F8  addi r29, r10, -0x2b08
	ctx.r[29].s64 = ctx.r[10].s64 + -11016;
	// 829EC6E0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 829EC6E4: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 829EC6E8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829EC6EC: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829EC6F0: 486C5839  bl 0x830b1f28
	ctx.lr = 0x829EC6F4;
	sub_830B1F28(ctx, base);
	// 829EC6F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EC6F8: 486C61B1  bl 0x830b28a8
	ctx.lr = 0x829EC6FC;
	sub_830B28A8(ctx, base);
	// 829EC6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC700: 486C5829  bl 0x830b1f28
	ctx.lr = 0x829EC704;
	sub_830B1F28(ctx, base);
	// 829EC704: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EC708: 486C5A29  bl 0x830b2130
	ctx.lr = 0x829EC70C;
	sub_830B2130(ctx, base);
	// 829EC70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC710: 486C5819  bl 0x830b1f28
	ctx.lr = 0x829EC714;
	sub_830B1F28(ctx, base);
	// 829EC714: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EC718: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC71C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EC720: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EC724: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EC728: 4E800421  bctrl
	ctx.lr = 0x829EC72C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EC72C: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC730: 4182001C  beq 0x829ec74c
	if ctx.cr[0].eq {
	pc = 0x829EC74C; continue 'dispatch;
	}
	// 829EC734: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EC738: 4BAFE351  bl 0x824eaa88
	ctx.lr = 0x829EC73C;
	sub_824EAA88(ctx, base);
	// 829EC73C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC740: 4BAFC7B9  bl 0x824e8ef8
	ctx.lr = 0x829EC744;
	sub_824E8EF8(ctx, base);
	// 829EC744: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EC748: 48405549  bl 0x82df1c90
	ctx.lr = 0x829EC74C;
	sub_82DF1C90(ctx, base);
	// 829EC74C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829EC750: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829EC754: 487BBA64  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EC758 size=148
    let mut pc: u32 = 0x829EC758;
    'dispatch: loop {
        match pc {
            0x829EC758 => {
    //   block [0x829EC758..0x829EC7EC)
	// 829EC758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC75C: 487BBA11  bl 0x831a816c
	ctx.lr = 0x829EC760;
	sub_831A8130(ctx, base);
	// 829EC760: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EC768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC76C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EC770: 4BAFE319  bl 0x824eaa88
	ctx.lr = 0x829EC774;
	sub_824EAA88(ctx, base);
	// 829EC774: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC778: 4BAFC8B9  bl 0x824e9030
	ctx.lr = 0x829EC77C;
	sub_824E9030(ctx, base);
	// 829EC77C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EC780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC784: 4840550D  bl 0x82df1c90
	ctx.lr = 0x829EC788;
	sub_82DF1C90(ctx, base);
	// 829EC788: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC78C: 41820020  beq 0x829ec7ac
	if ctx.cr[0].eq {
	pc = 0x829EC7AC; continue 'dispatch;
	}
	// 829EC790: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC794: 4BAFE2F5  bl 0x824eaa88
	ctx.lr = 0x829EC798;
	sub_824EAA88(ctx, base);
	// 829EC798: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC79C: 4BAFC635  bl 0x824e8dd0
	ctx.lr = 0x829EC7A0;
	sub_824E8DD0(ctx, base);
	// 829EC7A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC7A4: 484054ED  bl 0x82df1c90
	ctx.lr = 0x829EC7A8;
	sub_82DF1C90(ctx, base);
	// 829EC7A8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829EC7AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829EC7B0: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829EC7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC7B8: 4BFFF651  bl 0x829ebe08
	ctx.lr = 0x829EC7BC;
	sub_829EBE08(ctx, base);
	// 829EC7BC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 829EC7C0: 57CA063F  clrlwi. r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829EC7C4: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 829EC7C8: 4182001C  beq 0x829ec7e4
	if ctx.cr[0].eq {
	pc = 0x829EC7E4; continue 'dispatch;
	}
	// 829EC7CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC7D0: 4BAFE2B9  bl 0x824eaa88
	ctx.lr = 0x829EC7D4;
	sub_824EAA88(ctx, base);
	// 829EC7D4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC7D8: 4BAFC721  bl 0x824e8ef8
	ctx.lr = 0x829EC7DC;
	sub_824E8EF8(ctx, base);
	// 829EC7DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC7E0: 484054B1  bl 0x82df1c90
	ctx.lr = 0x829EC7E4;
	sub_82DF1C90(ctx, base);
	// 829EC7E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EC7E8: 487BB9D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EC7F0 size=220
    let mut pc: u32 = 0x829EC7F0;
    'dispatch: loop {
        match pc {
            0x829EC7F0 => {
    //   block [0x829EC7F0..0x829EC8CC)
	// 829EC7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC7F4: 487BB975  bl 0x831a8168
	ctx.lr = 0x829EC7F8;
	sub_831A8130(ctx, base);
	// 829EC7F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC7FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EC800: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EC804: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EC808: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829EC80C: 41820038  beq 0x829ec844
	if ctx.cr[0].eq {
	pc = 0x829EC844; continue 'dispatch;
	}
	// 829EC810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC814: 487BD175  bl 0x831a9988
	ctx.lr = 0x829EC818;
	sub_831A9988(ctx, base);
	// 829EC818: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EC81C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC820: 386BB284  addi r3, r11, -0x4d7c
	ctx.r[3].s64 = ctx.r[11].s64 + -19836;
	// 829EC824: 487BB8D5  bl 0x831a80f8
	ctx.lr = 0x829EC828;
	sub_831A80F8(ctx, base);
	// 829EC828: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC82C: 41820018  beq 0x829ec844
	if ctx.cr[0].eq {
	pc = 0x829EC844; continue 'dispatch;
	}
	// 829EC830: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC834: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EC838: 4BFFFD81  bl 0x829ec5b8
	ctx.lr = 0x829EC83C;
	sub_829EC5B8(ctx, base);
	// 829EC83C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829EC840: 48000084  b 0x829ec8c4
	pc = 0x829EC8C4; continue 'dispatch;
	// 829EC844: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC848: 419A006C  beq cr6, 0x829ec8b4
	if ctx.cr[6].eq {
	pc = 0x829EC8B4; continue 'dispatch;
	}
	// 829EC84C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC850: 487BD139  bl 0x831a9988
	ctx.lr = 0x829EC854;
	sub_831A9988(ctx, base);
	// 829EC854: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EC858: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC85C: 386BC460  addi r3, r11, -0x3ba0
	ctx.r[3].s64 = ctx.r[11].s64 + -15264;
	// 829EC860: 487BB899  bl 0x831a80f8
	ctx.lr = 0x829EC864;
	sub_831A80F8(ctx, base);
	// 829EC864: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC868: 41820014  beq 0x829ec87c
	if ctx.cr[0].eq {
	pc = 0x829EC87C; continue 'dispatch;
	}
	// 829EC86C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC870: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EC874: 4BFFFDFD  bl 0x829ec670
	ctx.lr = 0x829EC878;
	sub_829EC670(ctx, base);
	// 829EC878: 4BFFFFC4  b 0x829ec83c
	pc = 0x829EC83C; continue 'dispatch;
	// 829EC87C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829EC880: 419A0034  beq cr6, 0x829ec8b4
	if ctx.cr[6].eq {
	pc = 0x829EC8B4; continue 'dispatch;
	}
	// 829EC884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC888: 487BD101  bl 0x831a9988
	ctx.lr = 0x829EC88C;
	sub_831A9988(ctx, base);
	// 829EC88C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EC890: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EC894: 386BC498  addi r3, r11, -0x3b68
	ctx.r[3].s64 = ctx.r[11].s64 + -15208;
	// 829EC898: 487BB861  bl 0x831a80f8
	ctx.lr = 0x829EC89C;
	sub_831A80F8(ctx, base);
	// 829EC89C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC8A0: 41820014  beq 0x829ec8b4
	if ctx.cr[0].eq {
	pc = 0x829EC8B4; continue 'dispatch;
	}
	// 829EC8A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC8A8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829EC8AC: 4BFFFEAD  bl 0x829ec758
	ctx.lr = 0x829EC8B0;
	sub_829EC758(ctx, base);
	// 829EC8B0: 4BFFFF8C  b 0x829ec83c
	pc = 0x829EC83C; continue 'dispatch;
	// 829EC8B4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829EC8B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EC8BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EC8C0: 4BF99789  bl 0x82986048
	ctx.lr = 0x829EC8C4;
	sub_82986048(ctx, base);
	// 829EC8C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EC8C8: 487BB8F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EC8D0 size=76
    let mut pc: u32 = 0x829EC8D0;
    'dispatch: loop {
        match pc {
            0x829EC8D0 => {
    //   block [0x829EC8D0..0x829EC91C)
	// 829EC8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC8D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EC8D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EC8DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EC8E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC8E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EC8E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EC8EC: 4BFFF4CD  bl 0x829ebdb8
	ctx.lr = 0x829EC8F0;
	sub_829EBDB8(ctx, base);
	// 829EC8F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC8F4: 4182000C  beq 0x829ec900
	if ctx.cr[0].eq {
	pc = 0x829EC900; continue 'dispatch;
	}
	// 829EC8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC8FC: 48405ADD  bl 0x82df23d8
	ctx.lr = 0x829EC900;
	sub_82DF23D8(ctx, base);
	// 829EC900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EC904: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EC908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EC90C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EC910: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EC914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EC918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EC920 size=140
    let mut pc: u32 = 0x829EC920;
    'dispatch: loop {
        match pc {
            0x829EC920 => {
    //   block [0x829EC920..0x829EC9AC)
	// 829EC920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC924: 487BB849  bl 0x831a816c
	ctx.lr = 0x829EC928;
	sub_831A8130(ctx, base);
	// 829EC928: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC92C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EC930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC934: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EC938: 4BAFE151  bl 0x824eaa88
	ctx.lr = 0x829EC93C;
	sub_824EAA88(ctx, base);
	// 829EC93C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC940: 4BAFC6F1  bl 0x824e9030
	ctx.lr = 0x829EC944;
	sub_824E9030(ctx, base);
	// 829EC944: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EC948: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EC94C: 48405345  bl 0x82df1c90
	ctx.lr = 0x829EC950;
	sub_82DF1C90(ctx, base);
	// 829EC950: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC954: 41820020  beq 0x829ec974
	if ctx.cr[0].eq {
	pc = 0x829EC974; continue 'dispatch;
	}
	// 829EC958: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC95C: 4BAFE12D  bl 0x824eaa88
	ctx.lr = 0x829EC960;
	sub_824EAA88(ctx, base);
	// 829EC960: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC964: 4BAFC46D  bl 0x824e8dd0
	ctx.lr = 0x829EC968;
	sub_824E8DD0(ctx, base);
	// 829EC968: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EC96C: 48405325  bl 0x82df1c90
	ctx.lr = 0x829EC970;
	sub_82DF1C90(ctx, base);
	// 829EC970: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829EC974: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EC978: 4BF98AA9  bl 0x82985420
	ctx.lr = 0x829EC97C;
	sub_82985420(ctx, base);
	// 829EC97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EC980: 4BFFF831  bl 0x829ec1b0
	ctx.lr = 0x829EC984;
	sub_829EC1B0(ctx, base);
	// 829EC984: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC988: 4182001C  beq 0x829ec9a4
	if ctx.cr[0].eq {
	pc = 0x829EC9A4; continue 'dispatch;
	}
	// 829EC98C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC990: 4BAFE0F9  bl 0x824eaa88
	ctx.lr = 0x829EC994;
	sub_824EAA88(ctx, base);
	// 829EC994: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC998: 4BAFC561  bl 0x824e8ef8
	ctx.lr = 0x829EC99C;
	sub_824E8EF8(ctx, base);
	// 829EC99C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EC9A0: 484052F1  bl 0x82df1c90
	ctx.lr = 0x829EC9A4;
	sub_82DF1C90(ctx, base);
	// 829EC9A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829EC9A8: 487BB814  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EC9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EC9B0 size=1488
    let mut pc: u32 = 0x829EC9B0;
    'dispatch: loop {
        match pc {
            0x829EC9B0 => {
    //   block [0x829EC9B0..0x829ECF80)
	// 829EC9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EC9B4: 487BB7B1  bl 0x831a8164
	ctx.lr = 0x829EC9B8;
	sub_831A8130(ctx, base);
	// 829EC9B8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 829EC9BC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EC9C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EC9C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EC9C8: 4BB23D41  bl 0x82510708
	ctx.lr = 0x829EC9CC;
	sub_82510708(ctx, base);
	// 829EC9CC: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 829EC9D0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829EC9D4: 4BAFE0B5  bl 0x824eaa88
	ctx.lr = 0x829EC9D8;
	sub_824EAA88(ctx, base);
	// 829EC9D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EC9DC: 4BAFC655  bl 0x824e9030
	ctx.lr = 0x829EC9E0;
	sub_824E9030(ctx, base);
	// 829EC9E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EC9E4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 829EC9E8: 484052A9  bl 0x82df1c90
	ctx.lr = 0x829EC9EC;
	sub_82DF1C90(ctx, base);
	// 829EC9EC: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EC9F0: 41820020  beq 0x829eca10
	if ctx.cr[0].eq {
	pc = 0x829ECA10; continue 'dispatch;
	}
	// 829EC9F4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829EC9F8: 4BAFE091  bl 0x824eaa88
	ctx.lr = 0x829EC9FC;
	sub_824EAA88(ctx, base);
	// 829EC9FC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECA00: 4BAFC3D1  bl 0x824e8dd0
	ctx.lr = 0x829ECA04;
	sub_824E8DD0(ctx, base);
	// 829ECA04: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829ECA08: 48405289  bl 0x82df1c90
	ctx.lr = 0x829ECA0C;
	sub_82DF1C90(ctx, base);
	// 829ECA0C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 829ECA10: 817F00C4  lwz r11, 0xc4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 829ECA14: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829ECA18: 419A0300  beq cr6, 0x829ecd18
	if ctx.cr[6].eq {
	pc = 0x829ECD18; continue 'dispatch;
	}
	// 829ECA1C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 829ECA20: 419A01FC  beq cr6, 0x829ecc1c
	if ctx.cr[6].eq {
	pc = 0x829ECC1C; continue 'dispatch;
	}
	// 829ECA24: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 829ECA28: 419A0088  beq cr6, 0x829ecab0
	if ctx.cr[6].eq {
	pc = 0x829ECAB0; continue 'dispatch;
	}
	// 829ECA2C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 829ECA30: 409A0524  bne cr6, 0x829ecf54
	if !ctx.cr[6].eq {
	pc = 0x829ECF54; continue 'dispatch;
	}
	// 829ECA34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECA38: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829ECA3C: 4BF98D8D  bl 0x829857c8
	ctx.lr = 0x829ECA40;
	sub_829857C8(ctx, base);
	// 829ECA40: 486C54E9  bl 0x830b1f28
	ctx.lr = 0x829ECA44;
	sub_830B1F28(ctx, base);
	// 829ECA44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829ECA48: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829ECA4C: 83CB009C  lwz r30, 0x9c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 829ECA50: 486C5489  bl 0x830b1ed8
	ctx.lr = 0x829ECA54;
	sub_830B1ED8(ctx, base);
	// 829ECA54: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829ECA58: 419A04FC  beq cr6, 0x829ecf54
	if ctx.cr[6].eq {
	pc = 0x829ECF54; continue 'dispatch;
	}
	// 829ECA5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECA60: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829ECA64: 4BF98CBD  bl 0x82985720
	ctx.lr = 0x829ECA68;
	sub_82985720(ctx, base);
	// 829ECA68: 486C54C1  bl 0x830b1f28
	ctx.lr = 0x829ECA6C;
	sub_830B1F28(ctx, base);
	// 829ECA6C: 486C9945  bl 0x830b63b0
	ctx.lr = 0x829ECA70;
	sub_830B63B0(ctx, base);
	// 829ECA70: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829ECA74: 486C5465  bl 0x830b1ed8
	ctx.lr = 0x829ECA78;
	sub_830B1ED8(ctx, base);
	// 829ECA78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECA7C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 829ECA80: 4BF98CA1  bl 0x82985720
	ctx.lr = 0x829ECA84;
	sub_82985720(ctx, base);
	// 829ECA84: 486C54A5  bl 0x830b1f28
	ctx.lr = 0x829ECA88;
	sub_830B1F28(ctx, base);
	// 829ECA88: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ECA8C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829ECA90: 486C9C51  bl 0x830b66e0
	ctx.lr = 0x829ECA94;
	sub_830B66E0(ctx, base);
	// 829ECA94: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 829ECA98: 486C5441  bl 0x830b1ed8
	ctx.lr = 0x829ECA9C;
	sub_830B1ED8(ctx, base);
	// 829ECA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECAA0: 4BF98981  bl 0x82985420
	ctx.lr = 0x829ECAA4;
	sub_82985420(ctx, base);
	// 829ECAA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECAA8: 4BFFF709  bl 0x829ec1b0
	ctx.lr = 0x829ECAAC;
	sub_829EC1B0(ctx, base);
	// 829ECAAC: 480004A8  b 0x829ecf54
	pc = 0x829ECF54; continue 'dispatch;
	// 829ECAB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECAB4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829ECAB8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829ECABC: 4BF98C9D  bl 0x82985758
	ctx.lr = 0x829ECAC0;
	sub_82985758(ctx, base);
	// 829ECAC0: 486C5469  bl 0x830b1f28
	ctx.lr = 0x829ECAC4;
	sub_830B1F28(ctx, base);
	// 829ECAC4: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 829ECAC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECACC: 419A0028  beq cr6, 0x829ecaf4
	if ctx.cr[6].eq {
	pc = 0x829ECAF4; continue 'dispatch;
	}
	// 829ECAD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECAD4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829ECAD8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 829ECADC: 4BF98CB5  bl 0x82985790
	ctx.lr = 0x829ECAE0;
	sub_82985790(ctx, base);
	// 829ECAE0: 486C5449  bl 0x830b1f28
	ctx.lr = 0x829ECAE4;
	sub_830B1F28(ctx, base);
	// 829ECAE4: 8163009C  lwz r11, 0x9c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(156 as u32) ) } as u64;
	// 829ECAE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECAEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829ECAF0: 409A0008  bne cr6, 0x829ecaf8
	if !ctx.cr[6].eq {
	pc = 0x829ECAF8; continue 'dispatch;
	}
	// 829ECAF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829ECAF8: 57CA07BD  rlwinm. r10, r30, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829ECAFC: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829ECB00: 41820010  beq 0x829ecb10
	if ctx.cr[0].eq {
	pc = 0x829ECB10; continue 'dispatch;
	}
	// 829ECB04: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829ECB08: 57DE07FA  rlwinm r30, r30, 0, 0x1f, 0x1d
	ctx.r[30].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 829ECB0C: 486C53CD  bl 0x830b1ed8
	ctx.lr = 0x829ECB10;
	sub_830B1ED8(ctx, base);
	// 829ECB10: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECB14: 4182000C  beq 0x829ecb20
	if ctx.cr[0].eq {
	pc = 0x829ECB20; continue 'dispatch;
	}
	// 829ECB18: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829ECB1C: 486C53BD  bl 0x830b1ed8
	ctx.lr = 0x829ECB20;
	sub_830B1ED8(ctx, base);
	// 829ECB20: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECB24: 41820430  beq 0x829ecf54
	if ctx.cr[0].eq {
	pc = 0x829ECF54; continue 'dispatch;
	}
	// 829ECB28: 387F0118  addi r3, r31, 0x118
	ctx.r[3].s64 = ctx.r[31].s64 + 280;
	// 829ECB2C: 486C53FD  bl 0x830b1f28
	ctx.lr = 0x829ECB30;
	sub_830B1F28(ctx, base);
	// 829ECB30: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829ECB34: 486C6475  bl 0x830b2fa8
	ctx.lr = 0x829ECB38;
	sub_830B2FA8(ctx, base);
	// 829ECB38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECB3C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829ECB40: 4BF98C19  bl 0x82985758
	ctx.lr = 0x829ECB44;
	sub_82985758(ctx, base);
	// 829ECB44: 486C53E5  bl 0x830b1f28
	ctx.lr = 0x829ECB48;
	sub_830B1F28(ctx, base);
	// 829ECB48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829ECB4C: 486C645D  bl 0x830b2fa8
	ctx.lr = 0x829ECB50;
	sub_830B2FA8(ctx, base);
	// 829ECB50: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 829ECB54: 486C5385  bl 0x830b1ed8
	ctx.lr = 0x829ECB58;
	sub_830B1ED8(ctx, base);
	// 829ECB58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECB5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829ECB60: 4BF98C31  bl 0x82985790
	ctx.lr = 0x829ECB64;
	sub_82985790(ctx, base);
	// 829ECB64: 486C53C5  bl 0x830b1f28
	ctx.lr = 0x829ECB68;
	sub_830B1F28(ctx, base);
	// 829ECB68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829ECB6C: 486C643D  bl 0x830b2fa8
	ctx.lr = 0x829ECB70;
	sub_830B2FA8(ctx, base);
	// 829ECB70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829ECB74: 486C5365  bl 0x830b1ed8
	ctx.lr = 0x829ECB78;
	sub_830B1ED8(ctx, base);
	// 829ECB78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECB7C: 486C5345  bl 0x830b1ec0
	ctx.lr = 0x829ECB80;
	sub_830B1EC0(ctx, base);
	// 829ECB80: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829ECB84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829ECB88: 396BD3E4  addi r11, r11, -0x2c1c
	ctx.r[11].s64 = ctx.r[11].s64 + -11292;
	// 829ECB8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECB90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829ECB94: 486C5405  bl 0x830b1f98
	ctx.lr = 0x829ECB98;
	sub_830B1F98(ctx, base);
	// 829ECB98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECB9C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829ECBA0: 4BF98C29  bl 0x829857c8
	ctx.lr = 0x829ECBA4;
	sub_829857C8(ctx, base);
	// 829ECBA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829ECBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECBAC: 486C547D  bl 0x830b2028
	ctx.lr = 0x829ECBB0;
	sub_830B2028(ctx, base);
	// 829ECBB0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 829ECBB4: 486C5325  bl 0x830b1ed8
	ctx.lr = 0x829ECBB8;
	sub_830B1ED8(ctx, base);
	// 829ECBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECBBC: 486C536D  bl 0x830b1f28
	ctx.lr = 0x829ECBC0;
	sub_830B1F28(ctx, base);
	// 829ECBC0: 486C55A9  bl 0x830b2168
	ctx.lr = 0x829ECBC4;
	sub_830B2168(ctx, base);
	// 829ECBC4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829ECBC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECBCC: 3BCBD528  addi r30, r11, -0x2ad8
	ctx.r[30].s64 = ctx.r[11].s64 + -10968;
	// 829ECBD0: 486C5359  bl 0x830b1f28
	ctx.lr = 0x829ECBD4;
	sub_830B1F28(ctx, base);
	// 829ECBD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829ECBD8: 486C5CD1  bl 0x830b28a8
	ctx.lr = 0x829ECBDC;
	sub_830B28A8(ctx, base);
	// 829ECBDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECBE0: 486C5349  bl 0x830b1f28
	ctx.lr = 0x829ECBE4;
	sub_830B1F28(ctx, base);
	// 829ECBE4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 829ECBE8: 480F6759  bl 0x82ae3340
	ctx.lr = 0x829ECBEC;
	sub_82AE3340(ctx, base);
	// 829ECBEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECBF0: 486C5339  bl 0x830b1f28
	ctx.lr = 0x829ECBF4;
	sub_830B1F28(ctx, base);
	// 829ECBF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829ECBF8: 486C5591  bl 0x830b2188
	ctx.lr = 0x829ECBFC;
	sub_830B2188(ctx, base);
	// 829ECBFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECC00: 486C5329  bl 0x830b1f28
	ctx.lr = 0x829ECC04;
	sub_830B1F28(ctx, base);
	// 829ECC04: 486C5575  bl 0x830b2178
	ctx.lr = 0x829ECC08;
	sub_830B2178(ctx, base);
	// 829ECC08: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 829ECC0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829ECC10: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 829ECC14: 486C52C5  bl 0x830b1ed8
	ctx.lr = 0x829ECC18;
	sub_830B1ED8(ctx, base);
	// 829ECC18: 4800033C  b 0x829ecf54
	pc = 0x829ECF54; continue 'dispatch;
	// 829ECC1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829ECC20: 4BF98111  bl 0x82984d30
	ctx.lr = 0x829ECC24;
	sub_82984D30(ctx, base);
	// 829ECC24: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829ECC28: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829ECC2C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ECC30: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 829ECC34: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 829ECC38: 419A0024  beq cr6, 0x829ecc5c
	if ctx.cr[6].eq {
	pc = 0x829ECC5C; continue 'dispatch;
	}
	// 829ECC3C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829ECC40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829ECC44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829ECC48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829ECC4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829ECC50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829ECC54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829ECC58: 4082FFE8  bne 0x829ecc40
	if !ctx.cr[0].eq {
	pc = 0x829ECC40; continue 'dispatch;
	}
	// 829ECC5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECC60: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 829ECC64: 4BF9872D  bl 0x82985390
	ctx.lr = 0x829ECC68;
	sub_82985390(ctx, base);
	// 829ECC68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829ECC6C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829ECC70: 388B63D0  addi r4, r11, 0x63d0
	ctx.r[4].s64 = ctx.r[11].s64 + 25552;
	// 829ECC74: 38A00066  li r5, 0x66
	ctx.r[5].s64 = 102;
	// 829ECC78: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829ECC7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829ECC80: 4846A369  bl 0x82e56fe8
	ctx.lr = 0x829ECC84;
	sub_82E56FE8(ctx, base);
	// 829ECC84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 829ECC88: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829ECC8C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829ECC90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ECC94: 557EDFFE  rlwinm r30, r11, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829ECC98: 419A0008  beq cr6, 0x829ecca0
	if ctx.cr[6].eq {
	pc = 0x829ECCA0; continue 'dispatch;
	}
	// 829ECC9C: 4B8D3BF5  bl 0x822c0890
	ctx.lr = 0x829ECCA0;
	sub_822C0890(ctx, base);
	// 829ECCA0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECCA4: 41820018  beq 0x829eccbc
	if ctx.cr[0].eq {
	pc = 0x829ECCBC; continue 'dispatch;
	}
	// 829ECCA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829ECCAC: 419A02A8  beq cr6, 0x829ecf54
	if ctx.cr[6].eq {
	pc = 0x829ECF54; continue 'dispatch;
	}
	// 829ECCB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829ECCB4: 4B8D3BDD  bl 0x822c0890
	ctx.lr = 0x829ECCB8;
	sub_822C0890(ctx, base);
	// 829ECCB8: 4800029C  b 0x829ecf54
	pc = 0x829ECF54; continue 'dispatch;
	// 829ECCBC: C01C001C  lfs f0, 0x1c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ECCC0: 817F0128  lwz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 829ECCC4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 829ECCC8: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 829ECCCC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829ECCD0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829ECCD4: 409AFFD4  bne cr6, 0x829ecca8
	if !ctx.cr[6].eq {
	pc = 0x829ECCA8; continue 'dispatch;
	}
	// 829ECCD8: C1BC0018  lfs f13, 0x18(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829ECCDC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829ECCE0: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 829ECCE4: 809F0120  lwz r4, 0x120(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 829ECCE8: C00B637C  lfs f0, 0x637c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25468 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ECCEC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 829ECCF0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 829ECCF4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 829ECCF8: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829ECCFC: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829ECD00: 419AFFA8  beq cr6, 0x829ecca8
	if ctx.cr[6].eq {
	pc = 0x829ECCA8; continue 'dispatch;
	}
	// 829ECD04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829ECD08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECD0C: 4BFFF0FD  bl 0x829ebe08
	ctx.lr = 0x829ECD10;
	sub_829EBE08(ctx, base);
	// 829ECD10: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 829ECD14: 4BFFFF94  b 0x829ecca8
	pc = 0x829ECCA8; continue 'dispatch;
	// 829ECD18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECD1C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829ECD20: 4BF98A71  bl 0x82985790
	ctx.lr = 0x829ECD24;
	sub_82985790(ctx, base);
	// 829ECD24: 486C525D  bl 0x830b1f80
	ctx.lr = 0x829ECD28;
	sub_830B1F80(ctx, base);
	// 829ECD28: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829ECD2C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829ECD30: 486C51A9  bl 0x830b1ed8
	ctx.lr = 0x829ECD34;
	sub_830B1ED8(ctx, base);
	// 829ECD34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829ECD38: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 829ECD3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829ECD40: 3FA0820A  lis r29, -0x7df6
	ctx.r[29].s64 = -2113273856;
	// 829ECD44: 3BCBC6F0  addi r30, r11, -0x3910
	ctx.r[30].s64 = ctx.r[11].s64 + -14608;
	// 829ECD48: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829ECD4C: 419A0098  beq cr6, 0x829ecde4
	if ctx.cr[6].eq {
	pc = 0x829ECDE4; continue 'dispatch;
	}
	// 829ECD50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECD54: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829ECD58: 4BF98A39  bl 0x82985790
	ctx.lr = 0x829ECD5C;
	sub_82985790(ctx, base);
	// 829ECD5C: 486C51CD  bl 0x830b1f28
	ctx.lr = 0x829ECD60;
	sub_830B1F28(ctx, base);
	// 829ECD60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829ECD64: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829ECD68: 838B009C  lwz r28, 0x9c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 829ECD6C: 486C516D  bl 0x830b1ed8
	ctx.lr = 0x829ECD70;
	sub_830B1ED8(ctx, base);
	// 829ECD70: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829ECD74: 419A0070  beq cr6, 0x829ecde4
	if ctx.cr[6].eq {
	pc = 0x829ECDE4; continue 'dispatch;
	}
	// 829ECD78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECD7C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829ECD80: 4BF98A11  bl 0x82985790
	ctx.lr = 0x829ECD84;
	sub_82985790(ctx, base);
	// 829ECD84: 486C51A5  bl 0x830b1f28
	ctx.lr = 0x829ECD88;
	sub_830B1F28(ctx, base);
	// 829ECD88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829ECD8C: 486C5B1D  bl 0x830b28a8
	ctx.lr = 0x829ECD90;
	sub_830B28A8(ctx, base);
	// 829ECD90: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829ECD94: 486C5145  bl 0x830b1ed8
	ctx.lr = 0x829ECD98;
	sub_830B1ED8(ctx, base);
	// 829ECD98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECD9C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829ECDA0: 4BF989F1  bl 0x82985790
	ctx.lr = 0x829ECDA4;
	sub_82985790(ctx, base);
	// 829ECDA4: 486C5185  bl 0x830b1f28
	ctx.lr = 0x829ECDA8;
	sub_830B1F28(ctx, base);
	// 829ECDA8: C03D637C  lfs f1, 0x637c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829ECDAC: 486C5385  bl 0x830b2130
	ctx.lr = 0x829ECDB0;
	sub_830B2130(ctx, base);
	// 829ECDB0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829ECDB4: 486C5125  bl 0x830b1ed8
	ctx.lr = 0x829ECDB8;
	sub_830B1ED8(ctx, base);
	// 829ECDB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECDBC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829ECDC0: 4BF989D1  bl 0x82985790
	ctx.lr = 0x829ECDC4;
	sub_82985790(ctx, base);
	// 829ECDC4: 486C5165  bl 0x830b1f28
	ctx.lr = 0x829ECDC8;
	sub_830B1F28(ctx, base);
	// 829ECDC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECDCC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829ECDD0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECDD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829ECDD8: 4E800421  bctrl
	ctx.lr = 0x829ECDDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829ECDDC: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 829ECDE0: 486C50F9  bl 0x830b1ed8
	ctx.lr = 0x829ECDE4;
	sub_830B1ED8(ctx, base);
	// 829ECDE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECDE8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829ECDEC: 4BF9896D  bl 0x82985758
	ctx.lr = 0x829ECDF0;
	sub_82985758(ctx, base);
	// 829ECDF0: 486C5191  bl 0x830b1f80
	ctx.lr = 0x829ECDF4;
	sub_830B1F80(ctx, base);
	// 829ECDF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 829ECDF8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829ECDFC: 486C50DD  bl 0x830b1ed8
	ctx.lr = 0x829ECE00;
	sub_830B1ED8(ctx, base);
	// 829ECE00: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829ECE04: 419A0150  beq cr6, 0x829ecf54
	if ctx.cr[6].eq {
	pc = 0x829ECF54; continue 'dispatch;
	}
	// 829ECE08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECE0C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829ECE10: 4BF98949  bl 0x82985758
	ctx.lr = 0x829ECE14;
	sub_82985758(ctx, base);
	// 829ECE14: 486C5115  bl 0x830b1f28
	ctx.lr = 0x829ECE18;
	sub_830B1F28(ctx, base);
	// 829ECE18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829ECE1C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 829ECE20: 838B009C  lwz r28, 0x9c(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) } as u64;
	// 829ECE24: 486C50B5  bl 0x830b1ed8
	ctx.lr = 0x829ECE28;
	sub_830B1ED8(ctx, base);
	// 829ECE28: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829ECE2C: 419A0128  beq cr6, 0x829ecf54
	if ctx.cr[6].eq {
	pc = 0x829ECF54; continue 'dispatch;
	}
	// 829ECE30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECE34: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829ECE38: 4BF98921  bl 0x82985758
	ctx.lr = 0x829ECE3C;
	sub_82985758(ctx, base);
	// 829ECE3C: 486C50ED  bl 0x830b1f28
	ctx.lr = 0x829ECE40;
	sub_830B1F28(ctx, base);
	// 829ECE40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829ECE44: 486C5A65  bl 0x830b28a8
	ctx.lr = 0x829ECE48;
	sub_830B28A8(ctx, base);
	// 829ECE48: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829ECE4C: 486C508D  bl 0x830b1ed8
	ctx.lr = 0x829ECE50;
	sub_830B1ED8(ctx, base);
	// 829ECE50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECE54: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829ECE58: 4BF98901  bl 0x82985758
	ctx.lr = 0x829ECE5C;
	sub_82985758(ctx, base);
	// 829ECE5C: 486C50CD  bl 0x830b1f28
	ctx.lr = 0x829ECE60;
	sub_830B1F28(ctx, base);
	// 829ECE60: C03D637C  lfs f1, 0x637c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(25468 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829ECE64: 486C52CD  bl 0x830b2130
	ctx.lr = 0x829ECE68;
	sub_830B2130(ctx, base);
	// 829ECE68: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 829ECE6C: 486C506D  bl 0x830b1ed8
	ctx.lr = 0x829ECE70;
	sub_830B1ED8(ctx, base);
	// 829ECE70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829ECE74: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829ECE78: 4BF988E1  bl 0x82985758
	ctx.lr = 0x829ECE7C;
	sub_82985758(ctx, base);
	// 829ECE7C: 486C50AD  bl 0x830b1f28
	ctx.lr = 0x829ECE80;
	sub_830B1F28(ctx, base);
	// 829ECE80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECE84: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829ECE88: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829ECE8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829ECE90: 4E800421  bctrl
	ctx.lr = 0x829ECE94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829ECE94: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 829ECE98: 486C5041  bl 0x830b1ed8
	ctx.lr = 0x829ECE9C;
	sub_830B1ED8(ctx, base);
	// 829ECE9C: 387F0118  addi r3, r31, 0x118
	ctx.r[3].s64 = ctx.r[31].s64 + 280;
	// 829ECEA0: 486C5089  bl 0x830b1f28
	ctx.lr = 0x829ECEA4;
	sub_830B1F28(ctx, base);
	// 829ECEA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829ECEA8: 486C6101  bl 0x830b2fa8
	ctx.lr = 0x829ECEAC;
	sub_830B2FA8(ctx, base);
	// 829ECEAC: 897F0130  lbz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 829ECEB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829ECEB4: 40820098  bne 0x829ecf4c
	if !ctx.cr[0].eq {
	pc = 0x829ECF4C; continue 'dispatch;
	}
	// 829ECEB8: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 829ECEBC: 4BF98CFD  bl 0x82985bb8
	ctx.lr = 0x829ECEC0;
	sub_82985BB8(ctx, base);
	// 829ECEC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECEC4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 829ECEC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829ECECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ECED0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829ECED4: 419A0024  beq cr6, 0x829ecef8
	if ctx.cr[6].eq {
	pc = 0x829ECEF8; continue 'dispatch;
	}
	// 829ECED8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829ECEDC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829ECEE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829ECEE4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829ECEE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829ECEEC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829ECEF0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829ECEF4: 4082FFE8  bne 0x829ecedc
	if !ctx.cr[0].eq {
	pc = 0x829ECEDC; continue 'dispatch;
	}
	// 829ECEF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829ECEFC: 3BC10068  addi r30, r1, 0x68
	ctx.r[30].s64 = ctx.r[1].s64 + 104;
	// 829ECF00: 4BF98491  bl 0x82985390
	ctx.lr = 0x829ECF04;
	sub_82985390(ctx, base);
	// 829ECF04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829ECF08: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829ECF0C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829ECF10: 388B63D0  addi r4, r11, 0x63d0
	ctx.r[4].s64 = ctx.r[11].s64 + 25552;
	// 829ECF14: 38A0005A  li r5, 0x5a
	ctx.r[5].s64 = 90;
	// 829ECF18: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829ECF1C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829ECF20: 4846BB21  bl 0x82e58a40
	ctx.lr = 0x829ECF24;
	sub_82E58A40(ctx, base);
	// 829ECF24: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829ECF28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ECF2C: 419A0008  beq cr6, 0x829ecf34
	if ctx.cr[6].eq {
	pc = 0x829ECF34; continue 'dispatch;
	}
	// 829ECF30: 4B8D3961  bl 0x822c0890
	ctx.lr = 0x829ECF34;
	sub_822C0890(ctx, base);
	// 829ECF34: 8061010C  lwz r3, 0x10c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 829ECF38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ECF3C: 419A0008  beq cr6, 0x829ecf44
	if ctx.cr[6].eq {
	pc = 0x829ECF44; continue 'dispatch;
	}
	// 829ECF40: 4B8D3951  bl 0x822c0890
	ctx.lr = 0x829ECF44;
	sub_822C0890(ctx, base);
	// 829ECF44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829ECF48: 997F0130  stb r11, 0x130(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u8 ) };
	// 829ECF4C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 829ECF50: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 829ECF54: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ECF58: 4182001C  beq 0x829ecf74
	if ctx.cr[0].eq {
	pc = 0x829ECF74; continue 'dispatch;
	}
	// 829ECF5C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829ECF60: 4BAFDB29  bl 0x824eaa88
	ctx.lr = 0x829ECF64;
	sub_824EAA88(ctx, base);
	// 829ECF64: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829ECF68: 4BAFBF91  bl 0x824e8ef8
	ctx.lr = 0x829ECF6C;
	sub_824E8EF8(ctx, base);
	// 829ECF6C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 829ECF70: 48404D21  bl 0x82df1c90
	ctx.lr = 0x829ECF74;
	sub_82DF1C90(ctx, base);
	// 829ECF74: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 829ECF78: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 829ECF7C: 487BB238  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ECF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829ECF80 size=92
    let mut pc: u32 = 0x829ECF80;
    'dispatch: loop {
        match pc {
            0x829ECF80 => {
    //   block [0x829ECF80..0x829ECFDC)
	// 829ECF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ECF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829ECF88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829ECF8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829ECF90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ECF94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ECF98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829ECF9C: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 829ECFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ECFA4: 419A000C  beq cr6, 0x829ecfb0
	if ctx.cr[6].eq {
	pc = 0x829ECFB0; continue 'dispatch;
	}
	// 829ECFA8: 48405431  bl 0x82df23d8
	ctx.lr = 0x829ECFAC;
	sub_82DF23D8(ctx, base);
	// 829ECFAC: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 829ECFB0: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ECFB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829ECFB8: 419A000C  beq cr6, 0x829ecfc4
	if ctx.cr[6].eq {
	pc = 0x829ECFC4; continue 'dispatch;
	}
	// 829ECFBC: 4B8D32AD  bl 0x822c0268
	ctx.lr = 0x829ECFC0;
	sub_822C0268(ctx, base);
	// 829ECFC0: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 829ECFC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829ECFC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829ECFCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829ECFD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829ECFD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829ECFD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ECFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829ECFE0 size=4
    let mut pc: u32 = 0x829ECFE0;
    'dispatch: loop {
        match pc {
            0x829ECFE0 => {
    //   block [0x829ECFE0..0x829ECFE4)
	// 829ECFE0: 4BFFFFA0  b 0x829ecf80
	sub_829ECF80(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ECFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ECFE8 size=1044
    let mut pc: u32 = 0x829ECFE8;
    'dispatch: loop {
        match pc {
            0x829ECFE8 => {
    //   block [0x829ECFE8..0x829ED3FC)
	// 829ECFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ECFEC: 487BB161  bl 0x831a814c
	ctx.lr = 0x829ECFF0;
	sub_831A8130(ctx, base);
	// 829ECFF0: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 829ECFF4: 487BBA7D  bl 0x831a8a70
	ctx.lr = 0x829ECFF8;
	sub_831A8A40(ctx, base);
	// 829ECFF8: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ECFFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED000: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829ED004: 480F688D  bl 0x82ae3890
	ctx.lr = 0x829ED008;
	sub_82AE3890(ctx, base);
	// 829ED008: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829ED00C: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ED010: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 829ED014: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829ED018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED01C: 409903D0  ble cr6, 0x829ed3ec
	if !ctx.cr[6].gt {
	pc = 0x829ED3EC; continue 'dispatch;
	}
	// 829ED020: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ED024: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829ED028: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829ED02C: 3D008207  lis r8, -0x7df9
	ctx.r[8].s64 = -2113470464;
	// 829ED030: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829ED034: C34B08A8  lfs f26, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 829ED038: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 829ED03C: C36A9450  lfs f27, -0x6bb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829ED040: 3B000020  li r24, 0x20
	ctx.r[24].s64 = 32;
	// 829ED044: C3C99534  lfs f30, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829ED048: 3B200030  li r25, 0x30
	ctx.r[25].s64 = 48;
	// 829ED04C: C3881E70  lfs f28, 0x1e70(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(7792 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829ED050: C3A708A4  lfs f29, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829ED054: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 829ED058: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ED05C: 485C218D  bl 0x82faf1e8
	ctx.lr = 0x829ED060;
	sub_82FAF1E8(ctx, base);
	// 829ED060: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 829ED064: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829ED068: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 829ED06C: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 829ED070: 577D3032  slwi r29, r27, 6
	ctx.r[29].u32 = ctx.r[27].u32.wrapping_shl(6);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 829ED074: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 829ED078: 7F8AEA14  add r28, r10, r29
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 829ED07C: 13FE48C7  vcmpequd (lvx128) v31, v30, v9
	tmp.u32 = ctx.r[30].u32 + ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED080: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED400 size=336
    let mut pc: u32 = 0x829ED400;
    'dispatch: loop {
        match pc {
            0x829ED400 => {
    //   block [0x829ED400..0x829ED550)
	// 829ED400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED404: 487BAD41  bl 0x831a8144
	ctx.lr = 0x829ED408;
	sub_831A8130(ctx, base);
	// 829ED408: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED40C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829ED410: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829ED414: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 829ED418: 480F6479  bl 0x82ae3890
	ctx.lr = 0x829ED41C;
	sub_82AE3890(ctx, base);
	// 829ED41C: 7C771B79  or. r23, r3, r3
	ctx.r[23].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 829ED420: 41820128  beq 0x829ed548
	if ctx.cr[0].eq {
	pc = 0x829ED548; continue 'dispatch;
	}
	// 829ED424: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 829ED428: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829ED42C: 83FB0024  lwz r31, 0x24(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ED430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829ED434: 40990108  ble cr6, 0x829ed53c
	if !ctx.cr[6].gt {
	pc = 0x829ED53C; continue 'dispatch;
	}
	// 829ED438: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829ED43C: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 829ED440: 3B200020  li r25, 0x20
	ctx.r[25].s64 = 32;
	// 829ED444: 3B400030  li r26, 0x30
	ctx.r[26].s64 = 48;
	// 829ED448: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829ED44C: 809F0054  lwz r4, 0x54(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ED450: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829ED454: 485C2235  bl 0x82faf688
	ctx.lr = 0x829ED458;
	sub_82FAF688(ctx, base);
	// 829ED458: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829ED45C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829ED460: 38850010  addi r4, r5, 0x10
	ctx.r[4].s64 = ctx.r[5].s64 + 16;
	// 829ED464: 4B91A315  bl 0x82307778
	ctx.lr = 0x829ED468;
	sub_82307778(ctx, base);
	// 829ED468: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 829ED46C: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 829ED470: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 829ED474: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 829ED478: 38E100C0  addi r7, r1, 0xc0
	ctx.r[7].s64 = ctx.r[1].s64 + 192;
	// 829ED47C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 829ED480: 3AA10070  addi r21, r1, 0x70
	ctx.r[21].s64 = ctx.r[1].s64 + 112;
	// 829ED484: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED488: 3A810080  addi r20, r1, 0x80
	ctx.r[20].s64 = ctx.r[1].s64 + 128;
	// 829ED48C: 13DD4C07  vcmpneb. (lvlx128) v30, v29, v9
	tmp.u32 = ctx.r[29].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED490: 3A610090  addi r19, r1, 0x90
	ctx.r[19].s64 = ctx.r[1].s64 + 144;
	// 829ED494: 13B94407  vcmpneb. (lvlx128) v29, v25, v8
	tmp.u32 = ctx.r[25].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED498: 139A3C07  vcmpneb. (lvlx128) v28, v26, v7
	tmp.u32 = ctx.r[26].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED49C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED550 size=284
    let mut pc: u32 = 0x829ED550;
    'dispatch: loop {
        match pc {
            0x829ED550 => {
    //   block [0x829ED550..0x829ED66C)
	// 829ED550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED554: 487BAC11  bl 0x831a8164
	ctx.lr = 0x829ED558;
	sub_831A8130(ctx, base);
	// 829ED558: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 829ED55C: 487BB51D  bl 0x831a8a78
	ctx.lr = 0x829ED560;
	sub_831A8A40(ctx, base);
	// 829ED560: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED564: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829ED568: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829ED56C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829ED570: 3B8B6424  addi r28, r11, 0x6424
	ctx.r[28].s64 = ctx.r[11].s64 + 25636;
	// 829ED574: C1BB0018  lfs f13, 0x18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829ED578: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED57C: EFC06828  fsubs f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829ED580: C01CFFFC  lfs f0, -4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED584: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 829ED588: 40980008  bge cr6, 0x829ed590
	if !ctx.cr[6].lt {
	pc = 0x829ED590; continue 'dispatch;
	}
	// 829ED58C: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 829ED590: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829ED594: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829ED598: 396BD690  addi r11, r11, -0x2970
	ctx.r[11].s64 = ctx.r[11].s64 + -10608;
	// 829ED59C: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 829ED5A0: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829ED5A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829ED5A8: C38A6428  lfs f28, 0x6428(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25640 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829ED5AC: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829ED5B0: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829ED5B4: FF1E6000  fcmpu cr6, f30, f12
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[12].f64);
	// 829ED5B8: 4098008C  bge cr6, 0x829ed644
	if !ctx.cr[6].lt {
	pc = 0x829ED644; continue 'dispatch;
	}
	// 829ED5BC: C1BEFFFC  lfs f13, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829ED5C0: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED5C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829ED5C8: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829ED5CC: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829ED5D0: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 829ED5D4: ED600032  fmuls f11, f0, f0
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 829ED5D8: EFED5B7A  fmadds f31, f13, f13, f11
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 829ED5DC: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 829ED5E0: 40980064  bge cr6, 0x829ed644
	if !ctx.cr[6].lt {
	pc = 0x829ED644; continue 'dispatch;
	}
	// 829ED5E4: ED6CF028  fsubs f11, f12, f30
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[30].f64) as f32) as f64);
	// 829ED5E8: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 829ED5EC: FF1F5800  fcmpu cr6, f31, f11
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[11].f64);
	// 829ED5F0: 4198000C  blt cr6, 0x829ed5fc
	if ctx.cr[6].lt {
	pc = 0x829ED5FC; continue 'dispatch;
	}
	// 829ED5F4: FFC06090  fmr f30, f12
	ctx.f[30].f64 = ctx.f[12].f64;
	// 829ED5F8: 4800004C  b 0x829ed644
	pc = 0x829ED644; continue 'dispatch;
	// 829ED5FC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 829ED600: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829ED604: D3A10064  stfs f29, 0x64(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 829ED608: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 829ED60C: D3A1006C  stfs f29, 0x6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 829ED610: 4848FE81  bl 0x82e7d490
	ctx.lr = 0x829ED614;
	sub_82E7D490(ctx, base);
	// 829ED614: EDA0F82C  fsqrts f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[31].f64).sqrt() as f32) as f64;
	// 829ED618: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829ED61C: C01C0000  lfs f0, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED620: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829ED670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829ED670 size=1112
    let mut pc: u32 = 0x829ED670;
    'dispatch: loop {
        match pc {
            0x829ED670 => {
    //   block [0x829ED670..0x829EDAC8)
	// 829ED670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829ED674: 487BAACD  bl 0x831a8140
	ctx.lr = 0x829ED678;
	sub_831A8130(ctx, base);
	// 829ED678: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 829ED67C: 487BB3ED  bl 0x831a8a68
	ctx.lr = 0x829ED680;
	sub_831A8A40(ctx, base);
	// 829ED680: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829ED684: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829ED688: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 829ED68C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 829ED690: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829ED694: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 829ED698: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829ED69C: 4082041C  bne 0x829edab8
	if !ctx.cr[0].eq {
	pc = 0x829EDAB8; continue 'dispatch;
	}
	// 829ED6A0: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829ED6A4: 41820014  beq 0x829ed6b8
	if ctx.cr[0].eq {
	pc = 0x829ED6B8; continue 'dispatch;
	}
	// 829ED6A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829ED6AC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 829ED6B0: 4BFFFD51  bl 0x829ed400
	ctx.lr = 0x829ED6B4;
	sub_829ED400(ctx, base);
	// 829ED6B4: 48000404  b 0x829edab8
	pc = 0x829EDAB8; continue 'dispatch;
	// 829ED6B8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 829ED6BC: 480F61D5  bl 0x82ae3890
	ctx.lr = 0x829ED6C0;
	sub_82AE3890(ctx, base);
	// 829ED6C0: 7C781B79  or. r24, r3, r3
	ctx.r[24].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 829ED6C4: 418203F4  beq 0x829edab8
	if ctx.cr[0].eq {
	pc = 0x829EDAB8; continue 'dispatch;
	}
	// 829ED6C8: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 829ED6CC: C01F0008  lfs f0, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829ED6D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829ED6D4: C3FF000C  lfs f31, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829ED6D8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829ED6DC: C37F0000  lfs f27, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 829ED6E0: C31F0010  lfs f24, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 829ED6E4: EF400732  fmuls f26, f0, f28
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 829ED6E8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829ED6EC: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 829ED6F0: 485C1F99  bl 0x82faf688
	ctx.lr = 0x829ED6F4;
	sub_82FAF688(ctx, base);
	// 829ED6F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829ED6F8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829ED6FC: 38850010  addi r4, r5, 0x10
	ctx.r[4].s64 = ctx.r[5].s64 + 16;
	// 829ED700: 4B91A079  bl 0x82307778
	ctx.lr = 0x829ED704;
	sub_82307778(ctx, base);
	// 829ED704: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 829ED708: 39410100  addi r10, r1, 0x100
	ctx.r[10].s64 = ctx.r[1].s64 + 256;
	// 829ED70C: 39210100  addi r9, r1, 0x100
	ctx.r[9].s64 = ctx.r[1].s64 + 256;
	// 829ED710: 39010100  addi r8, r1, 0x100
	ctx.r[8].s64 = ctx.r[1].s64 + 256;
	// 829ED714: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 829ED718: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 829ED71C: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED720: 3B600030  li r27, 0x30
	ctx.r[27].s64 = 48;
	// 829ED724: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 829ED728: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 829ED72C: 3B2100C0  addi r25, r1, 0xc0
	ctx.r[25].s64 = ctx.r[1].s64 + 192;
	// 829ED730: 13DA5407  vcmpneb. (lvlx128) v30, v26, v10
	tmp.u32 = ctx.r[26].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED734: 3AE100D0  addi r23, r1, 0xd0
	ctx.r[23].s64 = ctx.r[1].s64 + 208;
	// 829ED738: 13BC4C07  vcmpneb. (lvlx128) v29, v28, v9
	tmp.u32 = ctx.r[28].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED73C: 139B4407  vcmpneb. (lvlx128) v28, v27, v8
	tmp.u32 = ctx.r[27].u32 + ctx.r[8].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829ED740: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EDAC8 size=552
    let mut pc: u32 = 0x829EDAC8;
    'dispatch: loop {
        match pc {
            0x829EDAC8 => {
    //   block [0x829EDAC8..0x829EDCF0)
	// 829EDAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDACC: 487BA691  bl 0x831a815c
	ctx.lr = 0x829EDAD0;
	sub_831A8130(ctx, base);
	// 829EDAD0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 829EDAD4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 829EDAD8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EDAE0: 3D4002AA  lis r10, 0x2aa
	ctx.r[10].s64 = 44695552;
	// 829EDAE4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 829EDAE8: 614AAAAA  ori r10, r10, 0xaaaa
	ctx.r[10].u64 = ctx.r[10].u64 | 43690;
	// 829EDAEC: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 829EDAF0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EDAF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EDAF8: 1C6B0060  mulli r3, r11, 0x60
	ctx.r[3].s64 = ctx.r[11].s64 * 96;
	// 829EDAFC: 40990008  ble cr6, 0x829edb04
	if !ctx.cr[6].gt {
	pc = 0x829EDB04; continue 'dispatch;
	}
	// 829EDB00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EDB04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EDB08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EDB0C: 3BCB6430  addi r30, r11, 0x6430
	ctx.r[30].s64 = ctx.r[11].s64 + 25648;
	// 829EDB10: 38A00148  li r5, 0x148
	ctx.r[5].s64 = 328;
	// 829EDB14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EDB18: 4B8D28C1  bl 0x822c03d8
	ctx.lr = 0x829EDB1C;
	sub_822C03D8(ctx, base);
	// 829EDB1C: 3D4003FF  lis r10, 0x3ff
	ctx.r[10].s64 = 67043328;
	// 829EDB20: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 829EDB24: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 829EDB28: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 829EDB2C: 55633032  slwi r3, r11, 6
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829EDB30: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829EDB34: 40990008  ble cr6, 0x829edb3c
	if !ctx.cr[6].gt {
	pc = 0x829EDB3C; continue 'dispatch;
	}
	// 829EDB38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EDB3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EDB40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EDB44: 38A0014A  li r5, 0x14a
	ctx.r[5].s64 = 330;
	// 829EDB48: 484048A1  bl 0x82df23e8
	ctx.lr = 0x829EDB4C;
	sub_82DF23E8(ctx, base);
	// 829EDB4C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EDB50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EDB54: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 829EDB58: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 829EDB5C: 80BF0028  lwz r5, 0x28(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 829EDB60: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDB64: 484277D5  bl 0x82e15338
	ctx.lr = 0x829EDB68;
	sub_82E15338(ctx, base);
	// 829EDB68: 839F0028  lwz r28, 0x28(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 829EDB6C: 939E0054  stw r28, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 829EDB70: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EDB74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDB78: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829EDB7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EDB80: 4E800421  bctrl
	ctx.lr = 0x829EDB84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EDB84: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 829EDB88: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDB8C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 829EDB90: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EDB94: 3B7C0001  addi r27, r28, 1
	ctx.r[27].s64 = ctx.r[28].s64 + 1;
	// 829EDB98: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EDB9C: 3BBE0060  addi r29, r30, 0x60
	ctx.r[29].s64 = ctx.r[30].s64 + 96;
	// 829EDBA0: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829EDBA4: 939E0054  stw r28, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 829EDBA8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 829EDBAC: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 829EDBB0: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 829EDBB4: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 829EDBB8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EDCF0 size=92
    let mut pc: u32 = 0x829EDCF0;
    'dispatch: loop {
        match pc {
            0x829EDCF0 => {
    //   block [0x829EDCF0..0x829EDD4C)
	// 829EDCF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDCF4: 487BA471  bl 0x831a8164
	ctx.lr = 0x829EDCF8;
	sub_831A8130(ctx, base);
	// 829EDCF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDCFC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829EDD00: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 829EDD04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EDD08: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 829EDD0C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 829EDD10: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 829EDD14: 487BA7FD  bl 0x831a8510
	ctx.lr = 0x829EDD18;
	sub_831A8510(ctx, base);
	// 829EDD18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EDD1C: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 829EDD20: 3D400200  lis r10, 0x200
	ctx.r[10].s64 = 33554432;
	// 829EDD24: 939F002C  stw r28, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[28].u32 ) };
	// 829EDD28: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 829EDD2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EDD30: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 829EDD34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EDD38: 937F0034  stw r27, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[27].u32 ) };
	// 829EDD3C: 4BFFFD8D  bl 0x829edac8
	ctx.lr = 0x829EDD40;
	sub_829EDAC8(ctx, base);
	// 829EDD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EDD44: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EDD48: 487BA46C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EDD50 size=12
    let mut pc: u32 = 0x829EDD50;
    'dispatch: loop {
        match pc {
            0x829EDD50 => {
    //   block [0x829EDD50..0x829EDD5C)
	// 829EDD50: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829EDD54: 806BD8F4  lwz r3, -0x270c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9996 as u32) ) } as u64;
	// 829EDD58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829EDD60 size=28
    let mut pc: u32 = 0x829EDD60;
    'dispatch: loop {
        match pc {
            0x829EDD60 => {
    //   block [0x829EDD60..0x829EDD7C)
	// 829EDD60: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 829EDD64: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EDD68: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 829EDD6C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EDD70: C00A1980  lfs f0, 0x1980(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(6528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDD74: 7C0B1D2E  stfsx f0, r11, r3
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 829EDD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829EDD80 size=28
    let mut pc: u32 = 0x829EDD80;
    'dispatch: loop {
        match pc {
            0x829EDD80 => {
    //   block [0x829EDD80..0x829EDD9C)
	// 829EDD80: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 829EDD84: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829EDD88: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 829EDD8C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EDD90: C00A9534  lfs f0, -0x6acc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDD94: 7C0B1D2E  stfsx f0, r11, r3
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), tmp.u32) };
	// 829EDD98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EDDA0 size=28
    let mut pc: u32 = 0x829EDDA0;
    'dispatch: loop {
        match pc {
            0x829EDDA0 => {
    //   block [0x829EDDA0..0x829EDDBC)
	// 829EDDA0: 548B043E  clrlwi r11, r4, 0x10
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000FFFFu64;
	// 829EDDA4: A123021A  lhz r9, 0x21a(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(538 as u32) ) } as u64;
	// 829EDDA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EDDAC: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 829EDDB0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 829EDDB4: B163021A  sth r11, 0x21a(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829EDDB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EDDC0 size=28
    let mut pc: u32 = 0x829EDDC0;
    'dispatch: loop {
        match pc {
            0x829EDDC0 => {
    //   block [0x829EDDC0..0x829EDDDC)
	// 829EDDC0: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EDDC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EDDC8: A123021A  lhz r9, 0x21a(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(538 as u32) ) } as u64;
	// 829EDDCC: 7D4B5830  slw r11, r10, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[10].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 829EDDD0: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 829EDDD4: B163021A  sth r11, 0x21a(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829EDDD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x829EDDE0 size=100
    let mut pc: u32 = 0x829EDDE0;
    'dispatch: loop {
        match pc {
            0x829EDDE0 => {
    //   block [0x829EDDE0..0x829EDE44)
	// 829EDDE0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 829EDDE4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EDDE8: 394BD6D4  addi r10, r11, -0x292c
	ctx.r[10].s64 = ctx.r[11].s64 + -10540;
	// 829EDDEC: C00908A4  lfs f0, 0x8a4(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDDF0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 829EDDF4: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829EDDF8: A92B0000  lha r9, 0(r11)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 829EDDFC: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EDE00: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 829EDE04: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EDE08: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 829EDE0C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 829EDE10: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 829EDE14: 390A0006  addi r8, r10, 6
	ctx.r[8].s64 = ctx.r[10].s64 + 6;
	// 829EDE18: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 829EDE1C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829EDE20: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 829EDE24: 4198FFD4  blt cr6, 0x829eddf8
	if ctx.cr[6].lt {
	pc = 0x829EDDF8; continue 'dispatch;
	}
	// 829EDE28: A9630308  lha r11, 0x308(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(776 as u32) ) } as i16) as i64;
	// 829EDE2C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 829EDE30: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EDE34: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 829EDE38: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 829EDE3C: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 829EDE40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EDE48 size=28
    let mut pc: u32 = 0x829EDE48;
    'dispatch: loop {
        match pc {
            0x829EDE48 => {
    //   block [0x829EDE48..0x829EDE64)
	// 829EDE48: A963000C  lha r11, 0xc(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as i16) as i64;
	// 829EDE4C: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 829EDE50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EDE54: 41810008  bgt 0x829ede5c
	if ctx.cr[0].gt {
	pc = 0x829EDE5C; continue 'dispatch;
	}
	// 829EDE58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EDE5C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 829EDE60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EDE68 size=116
    let mut pc: u32 = 0x829EDE68;
    'dispatch: loop {
        match pc {
            0x829EDE68 => {
    //   block [0x829EDE68..0x829EDEDC)
	// 829EDE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDE6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EDE70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EDE74: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDE78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EDE7C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EDE80: 419A0040  beq cr6, 0x829edec0
	if ctx.cr[6].eq {
	pc = 0x829EDEC0; continue 'dispatch;
	}
	// 829EDE84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 829EDE88: 0CDF0000  twi 6, r31, 0
	// 829EDE8C: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 829EDE90: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 829EDE94: 4098002C  bge cr6, 0x829edec0
	if !ctx.cr[6].lt {
	pc = 0x829EDEC0; continue 'dispatch;
	}
	// 829EDE98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EDE9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EDEA0: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 829EDEA4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 829EDEA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EDEAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EDEB0: 4B8D6401  bl 0x822c42b0
	ctx.lr = 0x829EDEB4;
	sub_822C42B0(ctx, base);
	// 829EDEB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EDEB8: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 829EDEBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829EDEC0: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 829EDEC4: 4B8D2A75  bl 0x822c0938
	ctx.lr = 0x829EDEC8;
	sub_822C0938(ctx, base);
	// 829EDEC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EDECC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EDED0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EDED4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EDED8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EDEE0 size=136
    let mut pc: u32 = 0x829EDEE0;
    'dispatch: loop {
        match pc {
            0x829EDEE0 => {
    //   block [0x829EDEE0..0x829EDF68)
	// 829EDEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EDEE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EDEEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EDEF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDEF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EDEF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EDEFC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 829EDF00: 409A0020  bne cr6, 0x829edf20
	if !ctx.cr[6].eq {
	pc = 0x829EDF20; continue 'dispatch;
	}
	// 829EDF04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EDF08: 419A0048  beq cr6, 0x829edf50
	if ctx.cr[6].eq {
	pc = 0x829EDF50; continue 'dispatch;
	}
	// 829EDF0C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829EDF10: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 829EDF14: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 829EDF18: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 829EDF1C: 48000034  b 0x829edf50
	pc = 0x829EDF50; continue 'dispatch;
	// 829EDF20: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 829EDF24: 419A002C  beq cr6, 0x829edf50
	if ctx.cr[6].eq {
	pc = 0x829EDF50; continue 'dispatch;
	}
	// 829EDF28: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EDF2C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDF30: 388BDE08  addi r4, r11, -0x21f8
	ctx.r[4].s64 = ctx.r[11].s64 + -8696;
	// 829EDF34: 487BA1C5  bl 0x831a80f8
	ctx.lr = 0x829EDF38;
	sub_831A80F8(ctx, base);
	// 829EDF38: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EDF3C: 4182000C  beq 0x829edf48
	if ctx.cr[0].eq {
	pc = 0x829EDF48; continue 'dispatch;
	}
	// 829EDF40: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 829EDF44: 4800000C  b 0x829edf50
	pc = 0x829EDF50; continue 'dispatch;
	// 829EDF48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EDF4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EDF50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EDF54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EDF58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EDF5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EDF60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EDF64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EDF68 size=56
    let mut pc: u32 = 0x829EDF68;
    'dispatch: loop {
        match pc {
            0x829EDF68 => {
    //   block [0x829EDF68..0x829EDFA0)
	// 829EDF68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EDF6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829EDF70: 394B0334  addi r10, r11, 0x334
	ctx.r[10].s64 = ctx.r[11].s64 + 820;
	// 829EDF74: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829EDF78: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EDF7C: A92900F0  lha r9, 0xf0(r9)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(240 as u32) ) } as i16) as i64;
	// 829EDF80: 2C090000  cmpwi r9, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 829EDF84: 41810008  bgt 0x829edf8c
	if ctx.cr[0].gt {
	pc = 0x829EDF8C; continue 'dispatch;
	}
	// 829EDF88: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 829EDF8C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EDF90: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829EDF94: 4082FFE4  bne 0x829edf78
	if !ctx.cr[0].eq {
	pc = 0x829EDF78; continue 'dispatch;
	}
	// 829EDF98: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 829EDF9C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EDFA0 size=8
    let mut pc: u32 = 0x829EDFA0;
    'dispatch: loop {
        match pc {
            0x829EDFA0 => {
    //   block [0x829EDFA0..0x829EDFA8)
	// 829EDFA0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 829EDFA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EDFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EDFA8 size=160
    let mut pc: u32 = 0x829EDFA8;
    'dispatch: loop {
        match pc {
            0x829EDFA8 => {
    //   block [0x829EDFA8..0x829EE048)
	// 829EDFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EDFAC: 487BA1BD  bl 0x831a8168
	ctx.lr = 0x829EDFB0;
	sub_831A8130(ctx, base);
	// 829EDFB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EDFB4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829EDFB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EDFBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EDFC0: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829EDFC4: 41820034  beq 0x829edff8
	if ctx.cr[0].eq {
	pc = 0x829EDFF8; continue 'dispatch;
	}
	// 829EDFC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EDFCC: 487BB9BD  bl 0x831a9988
	ctx.lr = 0x829EDFD0;
	sub_831A9988(ctx, base);
	// 829EDFD0: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829EDFD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EDFD8: 386B6584  addi r3, r11, 0x6584
	ctx.r[3].s64 = ctx.r[11].s64 + 25988;
	// 829EDFDC: 487BA11D  bl 0x831a80f8
	ctx.lr = 0x829EDFE0;
	sub_831A80F8(ctx, base);
	// 829EDFE0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EDFE4: 41820014  beq 0x829edff8
	if ctx.cr[0].eq {
	pc = 0x829EDFF8; continue 'dispatch;
	}
	// 829EDFE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EDFEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EDFF0: 48013E61  bl 0x82a01e50
	ctx.lr = 0x829EDFF4;
	sub_82A01E50(ctx, base);
	// 829EDFF4: 4800004C  b 0x829ee040
	pc = 0x829EE040; continue 'dispatch;
	// 829EDFF8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829EDFFC: 419A0034  beq cr6, 0x829ee030
	if ctx.cr[6].eq {
	pc = 0x829EE030; continue 'dispatch;
	}
	// 829EE000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE004: 487BB985  bl 0x831a9988
	ctx.lr = 0x829EE008;
	sub_831A9988(ctx, base);
	// 829EE008: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829EE00C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EE010: 386B63C0  addi r3, r11, 0x63c0
	ctx.r[3].s64 = ctx.r[11].s64 + 25536;
	// 829EE014: 487BA0E5  bl 0x831a80f8
	ctx.lr = 0x829EE018;
	sub_831A80F8(ctx, base);
	// 829EE018: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EE01C: 41820014  beq 0x829ee030
	if ctx.cr[0].eq {
	pc = 0x829EE030; continue 'dispatch;
	}
	// 829EE020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EE024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE028: 48013669  bl 0x82a01690
	ctx.lr = 0x829EE02C;
	sub_82A01690(ctx, base);
	// 829EE02C: 48000014  b 0x829ee040
	pc = 0x829EE040; continue 'dispatch;
	// 829EE030: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EE034: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EE038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE03C: 4879044D  bl 0x8317e488
	ctx.lr = 0x829EE040;
	sub_8317E488(ctx, base);
	// 829EE040: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EE044: 487BA174  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE048 size=84
    let mut pc: u32 = 0x829EE048;
    'dispatch: loop {
        match pc {
            0x829EE048 => {
    //   block [0x829EE048..0x829EE09C)
	// 829EE048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE054: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 829EE058: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE05C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE060: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 829EE064: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 829EE068: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829EE06C: 48410775  bl 0x82dfe7e0
	ctx.lr = 0x829EE070;
	sub_82DFE7E0(ctx, base);
	// 829EE070: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EE074: 41820010  beq 0x829ee084
	if ctx.cr[0].eq {
	pc = 0x829EE084; continue 'dispatch;
	}
	// 829EE078: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829EE07C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829EE080: 481C7471  bl 0x82bb54f0
	ctx.lr = 0x829EE084;
	sub_82BB54F0(ctx, base);
	// 829EE084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE08C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE090: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EE0A0 size=72
    let mut pc: u32 = 0x829EE0A0;
    'dispatch: loop {
        match pc {
            0x829EE0A0 => {
    //   block [0x829EE0A0..0x829EE0E8)
	// 829EE0A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829EE0A4: 39430334  addi r10, r3, 0x334
	ctx.r[10].s64 = ctx.r[3].s64 + 820;
	// 829EE0A8: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829EE0AC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE0B0: A90800F0  lha r8, 0xf0(r8)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(240 as u32) ) } as i16) as i64;
	// 829EE0B4: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 829EE0B8: 41810008  bgt 0x829ee0c0
	if ctx.cr[0].gt {
	pc = 0x829EE0C0; continue 'dispatch;
	}
	// 829EE0BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829EE0C0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EE0C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829EE0C8: 4082FFE4  bne 0x829ee0ac
	if !ctx.cr[0].eq {
	pc = 0x829EE0AC; continue 'dispatch;
	}
	// 829EE0CC: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 829EE0D0: 40990008  ble cr6, 0x829ee0d8
	if !ctx.cr[6].gt {
	pc = 0x829EE0D8; continue 'dispatch;
	}
	// 829EE0D4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829EE0D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE0DC: 396B6530  addi r11, r11, 0x6530
	ctx.r[11].s64 = ctx.r[11].s64 + 25904;
	// 829EE0E0: 7C6958AE  lbzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 829EE0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EE0E8 size=292
    let mut pc: u32 = 0x829EE0E8;
    'dispatch: loop {
        match pc {
            0x829EE0E8 => {
    //   block [0x829EE0E8..0x829EE20C)
	// 829EE0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE0F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE0F4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 829EE0F8: 487BA981  bl 0x831a8a78
	ctx.lr = 0x829EE0FC;
	sub_831A8A40(ctx, base);
	// 829EE0FC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE104: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 829EE108: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 829EE10C: C01F0398  lfs f0, 0x398(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(920 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE110: EFE00072  fmuls f31, f0, f1
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 829EE114: C01F0394  lfs f0, 0x394(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE118: C1BF0390  lfs f13, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EE11C: EFA06828  fsubs f29, f0, f13
	ctx.f[29].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 829EE120: C00BDFAC  lfs f0, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE124: C1AA4C58  lfs f13, 0x4c58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(19544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EE128: EF800372  fmuls f28, f0, f13
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 829EE12C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829EE130: 40990008  ble cr6, 0x829ee138
	if !ctx.cr[6].gt {
	pc = 0x829EE138; continue 'dispatch;
	}
	// 829EE134: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 829EE138: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829EE13C: 487BAC8D  bl 0x831a8dc8
	ctx.lr = 0x829EE140;
	sub_831A8DC8(ctx, base);
	// 829EE140: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829EE144: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EE148: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829EE14C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829EE150: 4099004C  ble cr6, 0x829ee19c
	if !ctx.cr[6].gt {
	pc = 0x829EE19C; continue 'dispatch;
	}
	// 829EE154: EC3DF828  fsubs f1, f29, f31
	ctx.f[1].f64 = (((ctx.f[29].f64 - ctx.f[31].f64) as f32) as f64);
	// 829EE158: 487BAC71  bl 0x831a8dc8
	ctx.lr = 0x829EE15C;
	sub_831A8DC8(ctx, base);
	// 829EE15C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829EE160: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829EE164: 4098002C  bge cr6, 0x829ee190
	if !ctx.cr[6].lt {
	pc = 0x829EE190; continue 'dispatch;
	}
	// 829EE168: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 829EE16C: 487BAD3D  bl 0x831a8ea8
	ctx.lr = 0x829EE170;
	sub_831A8EA8(ctx, base);
	// 829EE170: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829EE174: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 829EE178: 487BAD31  bl 0x831a8ea8
	ctx.lr = 0x829EE17C;
	sub_831A8EA8(ctx, base);
	// 829EE17C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829EE180: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 829EE184: 41990038  bgt cr6, 0x829ee1bc
	if ctx.cr[6].gt {
	pc = 0x829EE1BC; continue 'dispatch;
	}
	// 829EE188: C01F0394  lfs f0, 0x394(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE18C: 4800002C  b 0x829ee1b8
	pc = 0x829EE1B8; continue 'dispatch;
	// 829EE190: C01F0390  lfs f0, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE194: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 829EE198: 48000020  b 0x829ee1b8
	pc = 0x829EE1B8; continue 'dispatch;
	// 829EE19C: EC3FE82A  fadds f1, f31, f29
	ctx.f[1].f64 = ((ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64;
	// 829EE1A0: 487BAC29  bl 0x831a8dc8
	ctx.lr = 0x829EE1A4;
	sub_831A8DC8(ctx, base);
	// 829EE1A4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 829EE1A8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 829EE1AC: 4199FFBC  bgt cr6, 0x829ee168
	if ctx.cr[6].gt {
	pc = 0x829EE168; continue 'dispatch;
	}
	// 829EE1B0: C01F0390  lfs f0, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE1B4: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 829EE1B8: D01F0390  stfs f0, 0x390(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), tmp.u32 ) };
	// 829EE1BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EE1C0: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829EE1C4: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829EE1C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EE1CC: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829EE1D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EE1D4: C03F0390  lfs f1, 0x390(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EE1D8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE1DC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829EE1E0: 4848EA61  bl 0x82e7cc40
	ctx.lr = 0x829EE1E4;
	sub_82E7CC40(ctx, base);
	// 829EE1E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EE1E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE1EC: 4BB23905  bl 0x82511af0
	ctx.lr = 0x829EE1F0;
	sub_82511AF0(ctx, base);
	// 829EE1F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829EE1F4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 829EE1F8: 487BA8CD  bl 0x831a8ac4
	ctx.lr = 0x829EE1FC;
	sub_831A8A8C(ctx, base);
	// 829EE1FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE200: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE204: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE208: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EE210 size=80
    let mut pc: u32 = 0x829EE210;
    'dispatch: loop {
        match pc {
            0x829EE210 => {
    //   block [0x829EE210..0x829EE260)
	// 829EE210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE218: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE21C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE220: 816300E4  lwz r11, 0xe4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(228 as u32) ) } as u64;
	// 829EE224: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE228: 388300E4  addi r4, r3, 0xe4
	ctx.r[4].s64 = ctx.r[3].s64 + 228;
	// 829EE22C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829EE230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE234: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE23C: 4E800421  bctrl
	ctx.lr = 0x829EE240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE240: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 829EE244: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EE260 size=184
    let mut pc: u32 = 0x829EE260;
    'dispatch: loop {
        match pc {
            0x829EE260 => {
    //   block [0x829EE260..0x829EE318)
	// 829EE260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE268: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE26C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE270: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE274: 8964000E  lbz r11, 0xe(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(14 as u32) ) } as u64;
	// 829EE278: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829EE27C: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 829EE280: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829EE284: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 829EE288: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829EE28C: 394AD704  addi r10, r10, -0x28fc
	ctx.r[10].s64 = ctx.r[10].s64 + -10492;
	// 829EE290: 3CE0832E  lis r7, -0x7cd2
	ctx.r[7].s64 = -2094137344;
	// 829EE294: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 829EE298: 3929D8F8  addi r9, r9, -0x2708
	ctx.r[9].s64 = ctx.r[9].s64 + -9992;
	// 829EE29C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 829EE2A0: 3908D710  addi r8, r8, -0x28f0
	ctx.r[8].s64 = ctx.r[8].s64 + -10480;
	// 829EE2A4: 7D8B542E  lfsx f12, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EE2A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EE2AC: 80640010  lwz r3, 0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 829EE2B0: C007D700  lfs f0, -0x2900(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10496 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE2B4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829EE2B8: C1A69450  lfs f13, -0x6bb0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EE2BC: EDA0637A  fmadds f13, f0, f13, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 829EE2C0: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EE2C4: 7D6B442E  lfsx f11, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829EE2C8: C00508A4  lfs f0, 0x8a4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EE2CC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829EE2D0: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829EE2D4: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829EE2D8: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829EE2DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE2E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 829EE2E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE2E8: 4E800421  bctrl
	ctx.lr = 0x829EE2EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE2EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EE2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE2F4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829EE2F8: 4848D9D1  bl 0x82e7bcc8
	ctx.lr = 0x829EE2FC;
	sub_82E7BCC8(ctx, base);
	// 829EE2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE300: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EE304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE30C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE310: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE314: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE318 size=196
    let mut pc: u32 = 0x829EE318;
    'dispatch: loop {
        match pc {
            0x829EE318 => {
    //   block [0x829EE318..0x829EE3DC)
	// 829EE318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE31C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE32C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE330: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE334: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE338: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE33C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE340: 4B8D25F9  bl 0x822c0938
	ctx.lr = 0x829EE344;
	sub_822C0938(ctx, base);
	// 829EE344: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE348: 41820028  beq 0x829ee370
	if ctx.cr[0].eq {
	pc = 0x829EE370; continue 'dispatch;
	}
	// 829EE34C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE350: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE354: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE358: 392B6564  addi r9, r11, 0x6564
	ctx.r[9].s64 = ctx.r[11].s64 + 25956;
	// 829EE35C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE360: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE364: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE368: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE36C: 48000008  b 0x829ee374
	pc = 0x829EE374; continue 'dispatch;
	// 829EE370: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE374: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE37C: 409A0044  bne cr6, 0x829ee3c0
	if !ctx.cr[6].eq {
	pc = 0x829EE3C0; continue 'dispatch;
	}
	// 829EE380: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE384: 419A001C  beq cr6, 0x829ee3a0
	if ctx.cr[6].eq {
	pc = 0x829EE3A0; continue 'dispatch;
	}
	// 829EE388: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE38C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE394: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE39C: 4E800421  bctrl
	ctx.lr = 0x829EE3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE3A0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE3A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE3A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE3AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE3B0: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE3B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE3B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE3BC: 4B8D1C45  bl 0x822c0000
	ctx.lr = 0x829EE3C0;
	sub_822C0000(ctx, base);
	// 829EE3C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE3C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE3C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE3CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE3D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE3D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE3D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE3E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE3E0 size=196
    let mut pc: u32 = 0x829EE3E0;
    'dispatch: loop {
        match pc {
            0x829EE3E0 => {
    //   block [0x829EE3E0..0x829EE4A4)
	// 829EE3E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE3E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE3E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE3EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE3F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE3F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE3F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE3FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE400: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE404: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE408: 4B8D2531  bl 0x822c0938
	ctx.lr = 0x829EE40C;
	sub_822C0938(ctx, base);
	// 829EE40C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE410: 41820028  beq 0x829ee438
	if ctx.cr[0].eq {
	pc = 0x829EE438; continue 'dispatch;
	}
	// 829EE414: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE418: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE41C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE420: 392B6578  addi r9, r11, 0x6578
	ctx.r[9].s64 = ctx.r[11].s64 + 25976;
	// 829EE424: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE428: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE42C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE430: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE434: 48000008  b 0x829ee43c
	pc = 0x829EE43C; continue 'dispatch;
	// 829EE438: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE43C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE444: 409A0044  bne cr6, 0x829ee488
	if !ctx.cr[6].eq {
	pc = 0x829EE488; continue 'dispatch;
	}
	// 829EE448: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE44C: 419A001C  beq cr6, 0x829ee468
	if ctx.cr[6].eq {
	pc = 0x829EE468; continue 'dispatch;
	}
	// 829EE450: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE454: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE45C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE464: 4E800421  bctrl
	ctx.lr = 0x829EE468;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE468: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE46C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE470: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE474: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE478: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE47C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE480: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE484: 4B8D1B7D  bl 0x822c0000
	ctx.lr = 0x829EE488;
	sub_822C0000(ctx, base);
	// 829EE488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE48C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE490: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE494: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE498: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE49C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE4A8 size=196
    let mut pc: u32 = 0x829EE4A8;
    'dispatch: loop {
        match pc {
            0x829EE4A8 => {
    //   block [0x829EE4A8..0x829EE56C)
	// 829EE4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE4B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE4BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE4C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE4C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE4C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE4CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE4D0: 4B8D2469  bl 0x822c0938
	ctx.lr = 0x829EE4D4;
	sub_822C0938(ctx, base);
	// 829EE4D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE4D8: 41820028  beq 0x829ee500
	if ctx.cr[0].eq {
	pc = 0x829EE500; continue 'dispatch;
	}
	// 829EE4DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE4E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE4E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE4E8: 392B658C  addi r9, r11, 0x658c
	ctx.r[9].s64 = ctx.r[11].s64 + 25996;
	// 829EE4EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE4F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE4F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE4F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE4FC: 48000008  b 0x829ee504
	pc = 0x829EE504; continue 'dispatch;
	// 829EE500: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE504: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE50C: 409A0044  bne cr6, 0x829ee550
	if !ctx.cr[6].eq {
	pc = 0x829EE550; continue 'dispatch;
	}
	// 829EE510: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE514: 419A001C  beq cr6, 0x829ee530
	if ctx.cr[6].eq {
	pc = 0x829EE530; continue 'dispatch;
	}
	// 829EE518: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE51C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE524: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE528: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE52C: 4E800421  bctrl
	ctx.lr = 0x829EE530;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE530: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE534: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE53C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE540: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE544: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE548: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE54C: 4B8D1AB5  bl 0x822c0000
	ctx.lr = 0x829EE550;
	sub_822C0000(ctx, base);
	// 829EE550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE558: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE55C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE560: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE564: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE568: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE570 size=196
    let mut pc: u32 = 0x829EE570;
    'dispatch: loop {
        match pc {
            0x829EE570 => {
    //   block [0x829EE570..0x829EE634)
	// 829EE570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE57C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE584: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE588: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE58C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE590: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE594: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE598: 4B8D23A1  bl 0x822c0938
	ctx.lr = 0x829EE59C;
	sub_822C0938(ctx, base);
	// 829EE59C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE5A0: 41820028  beq 0x829ee5c8
	if ctx.cr[0].eq {
	pc = 0x829EE5C8; continue 'dispatch;
	}
	// 829EE5A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE5A8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE5AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE5B0: 392B65A0  addi r9, r11, 0x65a0
	ctx.r[9].s64 = ctx.r[11].s64 + 26016;
	// 829EE5B4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE5B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE5BC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE5C0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE5C4: 48000008  b 0x829ee5cc
	pc = 0x829EE5CC; continue 'dispatch;
	// 829EE5C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE5CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE5D4: 409A0044  bne cr6, 0x829ee618
	if !ctx.cr[6].eq {
	pc = 0x829EE618; continue 'dispatch;
	}
	// 829EE5D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE5DC: 419A001C  beq cr6, 0x829ee5f8
	if ctx.cr[6].eq {
	pc = 0x829EE5F8; continue 'dispatch;
	}
	// 829EE5E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE5E4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE5EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE5F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE5F4: 4E800421  bctrl
	ctx.lr = 0x829EE5F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE5F8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE5FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE604: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE608: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE60C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE610: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE614: 4B8D19ED  bl 0x822c0000
	ctx.lr = 0x829EE618;
	sub_822C0000(ctx, base);
	// 829EE618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE61C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE628: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE638 size=196
    let mut pc: u32 = 0x829EE638;
    'dispatch: loop {
        match pc {
            0x829EE638 => {
    //   block [0x829EE638..0x829EE6FC)
	// 829EE638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE64C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE650: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE654: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE658: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE65C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE660: 4B8D22D9  bl 0x822c0938
	ctx.lr = 0x829EE664;
	sub_822C0938(ctx, base);
	// 829EE664: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE668: 41820028  beq 0x829ee690
	if ctx.cr[0].eq {
	pc = 0x829EE690; continue 'dispatch;
	}
	// 829EE66C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE670: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE674: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE678: 392B65B4  addi r9, r11, 0x65b4
	ctx.r[9].s64 = ctx.r[11].s64 + 26036;
	// 829EE67C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE680: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE684: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE688: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE68C: 48000008  b 0x829ee694
	pc = 0x829EE694; continue 'dispatch;
	// 829EE690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE694: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE69C: 409A0044  bne cr6, 0x829ee6e0
	if !ctx.cr[6].eq {
	pc = 0x829EE6E0; continue 'dispatch;
	}
	// 829EE6A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE6A4: 419A001C  beq cr6, 0x829ee6c0
	if ctx.cr[6].eq {
	pc = 0x829EE6C0; continue 'dispatch;
	}
	// 829EE6A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE6AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE6B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE6B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE6BC: 4E800421  bctrl
	ctx.lr = 0x829EE6C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE6C0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE6C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE6C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE6CC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE6D0: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE6D4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE6D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE6DC: 4B8D1925  bl 0x822c0000
	ctx.lr = 0x829EE6E0;
	sub_822C0000(ctx, base);
	// 829EE6E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE6E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE6E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE6EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE6F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE6F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE6F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE700 size=196
    let mut pc: u32 = 0x829EE700;
    'dispatch: loop {
        match pc {
            0x829EE700 => {
    //   block [0x829EE700..0x829EE7C4)
	// 829EE700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE70C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE714: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE71C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE720: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE724: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE728: 4B8D2211  bl 0x822c0938
	ctx.lr = 0x829EE72C;
	sub_822C0938(ctx, base);
	// 829EE72C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE730: 41820028  beq 0x829ee758
	if ctx.cr[0].eq {
	pc = 0x829EE758; continue 'dispatch;
	}
	// 829EE734: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE738: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE73C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE740: 392B65C8  addi r9, r11, 0x65c8
	ctx.r[9].s64 = ctx.r[11].s64 + 26056;
	// 829EE744: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE748: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE74C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE750: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE754: 48000008  b 0x829ee75c
	pc = 0x829EE75C; continue 'dispatch;
	// 829EE758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE75C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE764: 409A0044  bne cr6, 0x829ee7a8
	if !ctx.cr[6].eq {
	pc = 0x829EE7A8; continue 'dispatch;
	}
	// 829EE768: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE76C: 419A001C  beq cr6, 0x829ee788
	if ctx.cr[6].eq {
	pc = 0x829EE788; continue 'dispatch;
	}
	// 829EE770: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE774: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE77C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE780: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE784: 4E800421  bctrl
	ctx.lr = 0x829EE788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE788: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE78C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE790: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE794: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE798: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE79C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE7A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE7A4: 4B8D185D  bl 0x822c0000
	ctx.lr = 0x829EE7A8;
	sub_822C0000(ctx, base);
	// 829EE7A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE7AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE7B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE7B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE7B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE7BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE7C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE7C8 size=196
    let mut pc: u32 = 0x829EE7C8;
    'dispatch: loop {
        match pc {
            0x829EE7C8 => {
    //   block [0x829EE7C8..0x829EE88C)
	// 829EE7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE7CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE7D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE7D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE7D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE7DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE7E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE7E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE7E8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE7EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE7F0: 4B8D2149  bl 0x822c0938
	ctx.lr = 0x829EE7F4;
	sub_822C0938(ctx, base);
	// 829EE7F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE7F8: 41820028  beq 0x829ee820
	if ctx.cr[0].eq {
	pc = 0x829EE820; continue 'dispatch;
	}
	// 829EE7FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE800: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE804: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE808: 392B65DC  addi r9, r11, 0x65dc
	ctx.r[9].s64 = ctx.r[11].s64 + 26076;
	// 829EE80C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE810: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE814: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE818: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE81C: 48000008  b 0x829ee824
	pc = 0x829EE824; continue 'dispatch;
	// 829EE820: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE824: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE82C: 409A0044  bne cr6, 0x829ee870
	if !ctx.cr[6].eq {
	pc = 0x829EE870; continue 'dispatch;
	}
	// 829EE830: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE834: 419A001C  beq cr6, 0x829ee850
	if ctx.cr[6].eq {
	pc = 0x829EE850; continue 'dispatch;
	}
	// 829EE838: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE83C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE844: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE848: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE84C: 4E800421  bctrl
	ctx.lr = 0x829EE850;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE850: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE854: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE85C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE860: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE864: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE868: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE86C: 4B8D1795  bl 0x822c0000
	ctx.lr = 0x829EE870;
	sub_822C0000(ctx, base);
	// 829EE870: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE874: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE87C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE880: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE884: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE890 size=196
    let mut pc: u32 = 0x829EE890;
    'dispatch: loop {
        match pc {
            0x829EE890 => {
    //   block [0x829EE890..0x829EE954)
	// 829EE890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE898: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE89C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE8A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE8A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE8A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE8AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE8B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE8B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE8B8: 4B8D2081  bl 0x822c0938
	ctx.lr = 0x829EE8BC;
	sub_822C0938(ctx, base);
	// 829EE8BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE8C0: 41820028  beq 0x829ee8e8
	if ctx.cr[0].eq {
	pc = 0x829EE8E8; continue 'dispatch;
	}
	// 829EE8C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE8C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE8CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE8D0: 392B65F0  addi r9, r11, 0x65f0
	ctx.r[9].s64 = ctx.r[11].s64 + 26096;
	// 829EE8D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE8D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE8DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE8E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE8E4: 48000008  b 0x829ee8ec
	pc = 0x829EE8EC; continue 'dispatch;
	// 829EE8E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE8EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE8F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE8F4: 409A0044  bne cr6, 0x829ee938
	if !ctx.cr[6].eq {
	pc = 0x829EE938; continue 'dispatch;
	}
	// 829EE8F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE8FC: 419A001C  beq cr6, 0x829ee918
	if ctx.cr[6].eq {
	pc = 0x829EE918; continue 'dispatch;
	}
	// 829EE900: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE904: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE90C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE914: 4E800421  bctrl
	ctx.lr = 0x829EE918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE918: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE91C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE924: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE928: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE92C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE930: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE934: 4B8D16CD  bl 0x822c0000
	ctx.lr = 0x829EE938;
	sub_822C0000(ctx, base);
	// 829EE938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EE93C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EE940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EE944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EE948: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EE94C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EE950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EE958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EE958 size=196
    let mut pc: u32 = 0x829EE958;
    'dispatch: loop {
        match pc {
            0x829EE958 => {
    //   block [0x829EE958..0x829EEA1C)
	// 829EE958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EE95C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EE960: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EE964: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EE968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EE96C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EE970: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE974: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EE978: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EE97C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE980: 4B8D1FB9  bl 0x822c0938
	ctx.lr = 0x829EE984;
	sub_822C0938(ctx, base);
	// 829EE984: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EE988: 41820028  beq 0x829ee9b0
	if ctx.cr[0].eq {
	pc = 0x829EE9B0; continue 'dispatch;
	}
	// 829EE98C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EE990: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EE994: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EE998: 392B6604  addi r9, r11, 0x6604
	ctx.r[9].s64 = ctx.r[11].s64 + 26116;
	// 829EE99C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EE9A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EE9A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EE9A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EE9AC: 48000008  b 0x829ee9b4
	pc = 0x829EE9B4; continue 'dispatch;
	// 829EE9B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EE9B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EE9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EE9BC: 409A0044  bne cr6, 0x829eea00
	if !ctx.cr[6].eq {
	pc = 0x829EEA00; continue 'dispatch;
	}
	// 829EE9C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EE9C4: 419A001C  beq cr6, 0x829ee9e0
	if ctx.cr[6].eq {
	pc = 0x829EE9E0; continue 'dispatch;
	}
	// 829EE9C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EE9CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EE9D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EE9D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EE9D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EE9DC: 4E800421  bctrl
	ctx.lr = 0x829EE9E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EE9E0: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EE9E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EE9E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EE9EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EE9F0: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EE9F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EE9F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EE9FC: 4B8D1605  bl 0x822c0000
	ctx.lr = 0x829EEA00;
	sub_822C0000(ctx, base);
	// 829EEA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEA04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEA08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEA0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEA10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEA14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEA18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEA20 size=196
    let mut pc: u32 = 0x829EEA20;
    'dispatch: loop {
        match pc {
            0x829EEA20 => {
    //   block [0x829EEA20..0x829EEAE4)
	// 829EEA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEA24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEA28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEA2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEA30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEA34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEA38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEA3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEA40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEA44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEA48: 4B8D1EF1  bl 0x822c0938
	ctx.lr = 0x829EEA4C;
	sub_822C0938(ctx, base);
	// 829EEA4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EEA50: 41820028  beq 0x829eea78
	if ctx.cr[0].eq {
	pc = 0x829EEA78; continue 'dispatch;
	}
	// 829EEA54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEA58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EEA5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EEA60: 392B6618  addi r9, r11, 0x6618
	ctx.r[9].s64 = ctx.r[11].s64 + 26136;
	// 829EEA64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EEA68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EEA6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EEA70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EEA74: 48000008  b 0x829eea7c
	pc = 0x829EEA7C; continue 'dispatch;
	// 829EEA78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEA7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEA80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEA84: 409A0044  bne cr6, 0x829eeac8
	if !ctx.cr[6].eq {
	pc = 0x829EEAC8; continue 'dispatch;
	}
	// 829EEA88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEA8C: 419A001C  beq cr6, 0x829eeaa8
	if ctx.cr[6].eq {
	pc = 0x829EEAA8; continue 'dispatch;
	}
	// 829EEA90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEA94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EEA98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEA9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEAA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EEAA4: 4E800421  bctrl
	ctx.lr = 0x829EEAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EEAA8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EEAAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EEAB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EEAB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EEAB8: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EEABC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EEAC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EEAC4: 4B8D153D  bl 0x822c0000
	ctx.lr = 0x829EEAC8;
	sub_822C0000(ctx, base);
	// 829EEAC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEACC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEAD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEAD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEAD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEAE8 size=196
    let mut pc: u32 = 0x829EEAE8;
    'dispatch: loop {
        match pc {
            0x829EEAE8 => {
    //   block [0x829EEAE8..0x829EEBAC)
	// 829EEAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEAEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEAF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEAF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEAF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEAFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEB00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEB04: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEB08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEB0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEB10: 4B8D1E29  bl 0x822c0938
	ctx.lr = 0x829EEB14;
	sub_822C0938(ctx, base);
	// 829EEB14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EEB18: 41820028  beq 0x829eeb40
	if ctx.cr[0].eq {
	pc = 0x829EEB40; continue 'dispatch;
	}
	// 829EEB1C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEB20: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EEB24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EEB28: 392B662C  addi r9, r11, 0x662c
	ctx.r[9].s64 = ctx.r[11].s64 + 26156;
	// 829EEB2C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EEB30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EEB34: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EEB38: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EEB3C: 48000008  b 0x829eeb44
	pc = 0x829EEB44; continue 'dispatch;
	// 829EEB40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEB44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEB48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEB4C: 409A0044  bne cr6, 0x829eeb90
	if !ctx.cr[6].eq {
	pc = 0x829EEB90; continue 'dispatch;
	}
	// 829EEB50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEB54: 419A001C  beq cr6, 0x829eeb70
	if ctx.cr[6].eq {
	pc = 0x829EEB70; continue 'dispatch;
	}
	// 829EEB58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEB5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EEB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEB64: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEB68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EEB6C: 4E800421  bctrl
	ctx.lr = 0x829EEB70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EEB70: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EEB74: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EEB78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EEB7C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EEB80: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EEB84: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EEB88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EEB8C: 4B8D1475  bl 0x822c0000
	ctx.lr = 0x829EEB90;
	sub_822C0000(ctx, base);
	// 829EEB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEB94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEB98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEB9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEBA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEBA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEBA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEBB0 size=196
    let mut pc: u32 = 0x829EEBB0;
    'dispatch: loop {
        match pc {
            0x829EEBB0 => {
    //   block [0x829EEBB0..0x829EEC74)
	// 829EEBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEBB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEBB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEBBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEBC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEBC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEBC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEBCC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEBD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEBD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEBD8: 4B8D1D61  bl 0x822c0938
	ctx.lr = 0x829EEBDC;
	sub_822C0938(ctx, base);
	// 829EEBDC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EEBE0: 41820028  beq 0x829eec08
	if ctx.cr[0].eq {
	pc = 0x829EEC08; continue 'dispatch;
	}
	// 829EEBE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEBE8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EEBEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EEBF0: 392B6640  addi r9, r11, 0x6640
	ctx.r[9].s64 = ctx.r[11].s64 + 26176;
	// 829EEBF4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EEBF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EEBFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EEC00: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EEC04: 48000008  b 0x829eec0c
	pc = 0x829EEC0C; continue 'dispatch;
	// 829EEC08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEC0C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEC14: 409A0044  bne cr6, 0x829eec58
	if !ctx.cr[6].eq {
	pc = 0x829EEC58; continue 'dispatch;
	}
	// 829EEC18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEC1C: 419A001C  beq cr6, 0x829eec38
	if ctx.cr[6].eq {
	pc = 0x829EEC38; continue 'dispatch;
	}
	// 829EEC20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEC24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EEC28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEC2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EEC30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EEC34: 4E800421  bctrl
	ctx.lr = 0x829EEC38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EEC38: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EEC3C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EEC40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EEC44: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EEC48: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EEC4C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EEC50: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EEC54: 4B8D13AD  bl 0x822c0000
	ctx.lr = 0x829EEC58;
	sub_822C0000(ctx, base);
	// 829EEC58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEC5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEC60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEC64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEC68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEC6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEC70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEC78 size=196
    let mut pc: u32 = 0x829EEC78;
    'dispatch: loop {
        match pc {
            0x829EEC78 => {
    //   block [0x829EEC78..0x829EED3C)
	// 829EEC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEC88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEC8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEC90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEC94: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEC98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEC9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EECA0: 4B8D1C99  bl 0x822c0938
	ctx.lr = 0x829EECA4;
	sub_822C0938(ctx, base);
	// 829EECA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EECA8: 41820028  beq 0x829eecd0
	if ctx.cr[0].eq {
	pc = 0x829EECD0; continue 'dispatch;
	}
	// 829EECAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EECB0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EECB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EECB8: 392B6654  addi r9, r11, 0x6654
	ctx.r[9].s64 = ctx.r[11].s64 + 26196;
	// 829EECBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EECC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EECC4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EECC8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EECCC: 48000008  b 0x829eecd4
	pc = 0x829EECD4; continue 'dispatch;
	// 829EECD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EECD4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EECD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EECDC: 409A0044  bne cr6, 0x829eed20
	if !ctx.cr[6].eq {
	pc = 0x829EED20; continue 'dispatch;
	}
	// 829EECE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EECE4: 419A001C  beq cr6, 0x829eed00
	if ctx.cr[6].eq {
	pc = 0x829EED00; continue 'dispatch;
	}
	// 829EECE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EECEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EECF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EECF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EECF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EECFC: 4E800421  bctrl
	ctx.lr = 0x829EED00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EED00: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EED04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EED08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EED0C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EED10: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EED14: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EED18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EED1C: 4B8D12E5  bl 0x822c0000
	ctx.lr = 0x829EED20;
	sub_822C0000(ctx, base);
	// 829EED20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EED24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EED28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EED2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EED30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EED34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EED38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EED40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EED40 size=196
    let mut pc: u32 = 0x829EED40;
    'dispatch: loop {
        match pc {
            0x829EED40 => {
    //   block [0x829EED40..0x829EEE04)
	// 829EED40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EED44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EED48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EED4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EED50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EED54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EED58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EED5C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EED60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EED64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EED68: 4B8D1BD1  bl 0x822c0938
	ctx.lr = 0x829EED6C;
	sub_822C0938(ctx, base);
	// 829EED6C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EED70: 41820028  beq 0x829eed98
	if ctx.cr[0].eq {
	pc = 0x829EED98; continue 'dispatch;
	}
	// 829EED74: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EED78: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EED7C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EED80: 392B6668  addi r9, r11, 0x6668
	ctx.r[9].s64 = ctx.r[11].s64 + 26216;
	// 829EED84: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EED88: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EED8C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EED90: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EED94: 48000008  b 0x829eed9c
	pc = 0x829EED9C; continue 'dispatch;
	// 829EED98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EED9C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEDA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEDA4: 409A0044  bne cr6, 0x829eede8
	if !ctx.cr[6].eq {
	pc = 0x829EEDE8; continue 'dispatch;
	}
	// 829EEDA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEDAC: 419A001C  beq cr6, 0x829eedc8
	if ctx.cr[6].eq {
	pc = 0x829EEDC8; continue 'dispatch;
	}
	// 829EEDB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEDB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EEDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEDBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEDC0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EEDC4: 4E800421  bctrl
	ctx.lr = 0x829EEDC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EEDC8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EEDCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EEDD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EEDD4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EEDD8: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EEDDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EEDE0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EEDE4: 4B8D121D  bl 0x822c0000
	ctx.lr = 0x829EEDE8;
	sub_822C0000(ctx, base);
	// 829EEDE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEDEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEDF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEDF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEDF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEDFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEE00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEE08 size=196
    let mut pc: u32 = 0x829EEE08;
    'dispatch: loop {
        match pc {
            0x829EEE08 => {
    //   block [0x829EEE08..0x829EEECC)
	// 829EEE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEE10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEE14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEE18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEE1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEE20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEE24: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEE28: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEE2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEE30: 4B8D1B09  bl 0x822c0938
	ctx.lr = 0x829EEE34;
	sub_822C0938(ctx, base);
	// 829EEE34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EEE38: 41820028  beq 0x829eee60
	if ctx.cr[0].eq {
	pc = 0x829EEE60; continue 'dispatch;
	}
	// 829EEE3C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEE40: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EEE44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EEE48: 392B667C  addi r9, r11, 0x667c
	ctx.r[9].s64 = ctx.r[11].s64 + 26236;
	// 829EEE4C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EEE50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EEE54: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EEE58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EEE5C: 48000008  b 0x829eee64
	pc = 0x829EEE64; continue 'dispatch;
	// 829EEE60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEE64: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEE6C: 409A0044  bne cr6, 0x829eeeb0
	if !ctx.cr[6].eq {
	pc = 0x829EEEB0; continue 'dispatch;
	}
	// 829EEE70: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEE74: 419A001C  beq cr6, 0x829eee90
	if ctx.cr[6].eq {
	pc = 0x829EEE90; continue 'dispatch;
	}
	// 829EEE78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEE7C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EEE80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEE84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEE88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EEE8C: 4E800421  bctrl
	ctx.lr = 0x829EEE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EEE90: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EEE94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EEE98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EEE9C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EEEA0: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EEEA4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EEEA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EEEAC: 4B8D1155  bl 0x822c0000
	ctx.lr = 0x829EEEB0;
	sub_822C0000(ctx, base);
	// 829EEEB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEEB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEEB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEEBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEEC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEEC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEEC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEED0 size=196
    let mut pc: u32 = 0x829EEED0;
    'dispatch: loop {
        match pc {
            0x829EEED0 => {
    //   block [0x829EEED0..0x829EEF94)
	// 829EEED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEEDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEEE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEEE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEEEC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEEF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEEF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEEF8: 4B8D1A41  bl 0x822c0938
	ctx.lr = 0x829EEEFC;
	sub_822C0938(ctx, base);
	// 829EEEFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EEF00: 41820028  beq 0x829eef28
	if ctx.cr[0].eq {
	pc = 0x829EEF28; continue 'dispatch;
	}
	// 829EEF04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEF08: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EEF0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EEF10: 392B6690  addi r9, r11, 0x6690
	ctx.r[9].s64 = ctx.r[11].s64 + 26256;
	// 829EEF14: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EEF18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EEF1C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EEF20: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EEF24: 48000008  b 0x829eef2c
	pc = 0x829EEF2C; continue 'dispatch;
	// 829EEF28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEF2C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEF34: 409A0044  bne cr6, 0x829eef78
	if !ctx.cr[6].eq {
	pc = 0x829EEF78; continue 'dispatch;
	}
	// 829EEF38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EEF3C: 419A001C  beq cr6, 0x829eef58
	if ctx.cr[6].eq {
	pc = 0x829EEF58; continue 'dispatch;
	}
	// 829EEF40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEF44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EEF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EEF4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EEF50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EEF54: 4E800421  bctrl
	ctx.lr = 0x829EEF58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EEF58: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EEF5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EEF60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EEF64: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EEF68: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EEF6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EEF70: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EEF74: 4B8D108D  bl 0x822c0000
	ctx.lr = 0x829EEF78;
	sub_822C0000(ctx, base);
	// 829EEF78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EEF7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EEF80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EEF84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EEF88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EEF8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EEF90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EEF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EEF98 size=196
    let mut pc: u32 = 0x829EEF98;
    'dispatch: loop {
        match pc {
            0x829EEF98 => {
    //   block [0x829EEF98..0x829EF05C)
	// 829EEF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EEF9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EEFA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EEFA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EEFA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EEFAC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EEFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEFB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EEFB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EEFBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEFC0: 4B8D1979  bl 0x822c0938
	ctx.lr = 0x829EEFC4;
	sub_822C0938(ctx, base);
	// 829EEFC4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EEFC8: 41820028  beq 0x829eeff0
	if ctx.cr[0].eq {
	pc = 0x829EEFF0; continue 'dispatch;
	}
	// 829EEFCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EEFD0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EEFD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EEFD8: 392B66A4  addi r9, r11, 0x66a4
	ctx.r[9].s64 = ctx.r[11].s64 + 26276;
	// 829EEFDC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EEFE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EEFE4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EEFE8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EEFEC: 48000008  b 0x829eeff4
	pc = 0x829EEFF4; continue 'dispatch;
	// 829EEFF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EEFF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EEFF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EEFFC: 409A0044  bne cr6, 0x829ef040
	if !ctx.cr[6].eq {
	pc = 0x829EF040; continue 'dispatch;
	}
	// 829EF000: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EF004: 419A001C  beq cr6, 0x829ef020
	if ctx.cr[6].eq {
	pc = 0x829EF020; continue 'dispatch;
	}
	// 829EF008: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF00C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EF010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF014: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EF01C: 4E800421  bctrl
	ctx.lr = 0x829EF020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF020: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EF024: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EF028: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF02C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EF030: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EF034: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EF038: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EF03C: 4B8D0FC5  bl 0x822c0000
	ctx.lr = 0x829EF040;
	sub_822C0000(ctx, base);
	// 829EF040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF044: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EF048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF04C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF050: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EF054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EF058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF060 size=196
    let mut pc: u32 = 0x829EF060;
    'dispatch: loop {
        match pc {
            0x829EF060 => {
    //   block [0x829EF060..0x829EF124)
	// 829EF060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EF06C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF074: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EF078: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EF07C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829EF080: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EF084: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EF088: 4B8D18B1  bl 0x822c0938
	ctx.lr = 0x829EF08C;
	sub_822C0938(ctx, base);
	// 829EF08C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EF090: 41820028  beq 0x829ef0b8
	if ctx.cr[0].eq {
	pc = 0x829EF0B8; continue 'dispatch;
	}
	// 829EF094: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EF098: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829EF09C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EF0A0: 392B66B8  addi r9, r11, 0x66b8
	ctx.r[9].s64 = ctx.r[11].s64 + 26296;
	// 829EF0A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EF0A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EF0AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829EF0B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829EF0B4: 48000008  b 0x829ef0bc
	pc = 0x829EF0BC; continue 'dispatch;
	// 829EF0B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EF0BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EF0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF0C4: 409A0044  bne cr6, 0x829ef108
	if !ctx.cr[6].eq {
	pc = 0x829EF108; continue 'dispatch;
	}
	// 829EF0C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EF0CC: 419A001C  beq cr6, 0x829ef0e8
	if ctx.cr[6].eq {
	pc = 0x829EF0E8; continue 'dispatch;
	}
	// 829EF0D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF0D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829EF0D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF0DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF0E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EF0E4: 4E800421  bctrl
	ctx.lr = 0x829EF0E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF0E8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EF0EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829EF0F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF0F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829EF0F8: 816BD71C  lwz r11, -0x28e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10468 as u32) ) } as u64;
	// 829EF0FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829EF100: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829EF104: 4B8D0EFD  bl 0x822c0000
	ctx.lr = 0x829EF108;
	sub_822C0000(ctx, base);
	// 829EF108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF10C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EF110: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF114: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF118: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EF11C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EF120: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF128 size=348
    let mut pc: u32 = 0x829EF128;
    'dispatch: loop {
        match pc {
            0x829EF128 => {
    //   block [0x829EF128..0x829EF284)
	// 829EF128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF134: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF13C: 897F0330  lbz r11, 0x330(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(816 as u32) ) } as u64;
	// 829EF140: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829EF144: 41980108  blt cr6, 0x829ef24c
	if ctx.cr[6].lt {
	pc = 0x829EF24C; continue 'dispatch;
	}
	// 829EF148: 409A0124  bne cr6, 0x829ef26c
	if !ctx.cr[6].eq {
	pc = 0x829EF26C; continue 'dispatch;
	}
	// 829EF14C: 817F0310  lwz r11, 0x310(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) } as u64;
	// 829EF150: 556B07BE  clrlwi r11, r11, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 829EF154: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829EF158: 917F0310  stw r11, 0x310(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(784 as u32), ctx.r[11].u32 ) };
	// 829EF15C: 4182000C  beq 0x829ef168
	if ctx.cr[0].eq {
	pc = 0x829EF168; continue 'dispatch;
	}
	// 829EF160: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 829EF164: 4800010C  b 0x829ef270
	pc = 0x829EF270; continue 'dispatch;
	// 829EF168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF16C: 4BB2297D  bl 0x82511ae8
	ctx.lr = 0x829EF170;
	sub_82511AE8(ctx, base);
	// 829EF170: 39600320  li r11, 0x320
	ctx.r[11].s64 = 800;
	// 829EF174: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829EF178: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829EF17C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF288 size=228
    let mut pc: u32 = 0x829EF288;
    'dispatch: loop {
        match pc {
            0x829EF288 => {
    //   block [0x829EF288..0x829EF36C)
	// 829EF288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF28C: 487B8EE1  bl 0x831a816c
	ctx.lr = 0x829EF290;
	sub_831A8130(ctx, base);
	// 829EF290: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF294: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EF298: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EF29C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 829EF2A0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 829EF2A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EF2A8: 815F01CC  lwz r10, 0x1cc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) } as u64;
	// 829EF2AC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF2B0: C1A92960  lfs f13, 0x2960(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10592 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829EF2B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829EF2B8: C1889524  lfs f12, -0x6adc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829EF2BC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829EF2C0: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 829EF2C4: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 829EF2C8: D01E000C  stfs f0, 0xc(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 829EF2CC: 41980094  blt cr6, 0x829ef360
	if ctx.cr[6].lt {
	pc = 0x829EF360; continue 'dispatch;
	}
	// 829EF2D0: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829EF2D4: 555D003E  slwi r29, r10, 0
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 829EF2D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF2DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EF2E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EF2E4: 4E800421  bctrl
	ctx.lr = 0x829EF2E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF2E8: 7F1D1800  cmpw cr6, r29, r3
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[3].s32, &mut ctx.xer);
	// 829EF2EC: 40980074  bge cr6, 0x829ef360
	if !ctx.cr[6].lt {
	pc = 0x829EF360; continue 'dispatch;
	}
	// 829EF2F0: 807F0160  lwz r3, 0x160(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 829EF2F4: 480F459D  bl 0x82ae3890
	ctx.lr = 0x829EF2F8;
	sub_82AE3890(ctx, base);
	// 829EF2F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EF2FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829EF300: 485C0389  bl 0x82faf688
	ctx.lr = 0x829EF304;
	sub_82FAF688(ctx, base);
	// 829EF304: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EF308: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829EF30C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 829EF310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF314: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 829EF318: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EF370 size=20
    let mut pc: u32 = 0x829EF370;
    'dispatch: loop {
        match pc {
            0x829EF370 => {
    //   block [0x829EF370..0x829EF384)
	// 829EF370: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EF374: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829EF378: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 829EF37C: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 829EF380: 4BB22A18  b 0x82511d98
	sub_82511D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EF388 size=96
    let mut pc: u32 = 0x829EF388;
    'dispatch: loop {
        match pc {
            0x829EF388 => {
    //   block [0x829EF388..0x829EF3E8)
	// 829EF388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF390: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF394: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EF3E8 size=100
    let mut pc: u32 = 0x829EF3E8;
    'dispatch: loop {
        match pc {
            0x829EF3E8 => {
    //   block [0x829EF3E8..0x829EF44C)
	// 829EF3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF3F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF3F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829EF3F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EF3FC: 89440454  lbz r10, 0x454(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1108 as u32) ) } as u64;
	// 829EF400: C00B964C  lfs f0, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829EF404: D0040458  stfs f0, 0x458(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(1112 as u32), tmp.u32 ) };
	// 829EF408: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EF40C: 41820030  beq 0x829ef43c
	if ctx.cr[0].eq {
	pc = 0x829EF43C; continue 'dispatch;
	}
	// 829EF410: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF414: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EF418: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF41C: 38AA6748  addi r5, r10, 0x6748
	ctx.r[5].s64 = ctx.r[10].s64 + 26440;
	// 829EF420: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829EF424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829EF428: 4E800421  bctrl
	ctx.lr = 0x829EF42C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829EF42C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EF430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF434: 419A0008  beq cr6, 0x829ef43c
	if ctx.cr[6].eq {
	pc = 0x829EF43C; continue 'dispatch;
	}
	// 829EF438: 4B8D1459  bl 0x822c0890
	ctx.lr = 0x829EF43C;
	sub_822C0890(ctx, base);
	// 829EF43C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EF440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF448: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF450 size=64
    let mut pc: u32 = 0x829EF450;
    'dispatch: loop {
        match pc {
            0x829EF450 => {
    //   block [0x829EF450..0x829EF490)
	// 829EF450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF454: 487B8D19  bl 0x831a816c
	ctx.lr = 0x829EF458;
	sub_831A8130(ctx, base);
	// 829EF458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF45C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF460: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829EF464: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 829EF468: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF46C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829EF470: 4BFFF1C9  bl 0x829ee638
	ctx.lr = 0x829EF474;
	sub_829EE638(ctx, base);
	// 829EF474: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829EF478: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829EF47C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF480: 4B8D0B81  bl 0x822c0000
	ctx.lr = 0x829EF484;
	sub_822C0000(ctx, base);
	// 829EF484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF488: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EF48C: 487B8D30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF490 size=72
    let mut pc: u32 = 0x829EF490;
    'dispatch: loop {
        match pc {
            0x829EF490 => {
    //   block [0x829EF490..0x829EF4D8)
	// 829EF490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF498: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF49C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 829EF4A0: 419A001C  beq cr6, 0x829ef4bc
	if ctx.cr[6].eq {
	pc = 0x829EF4BC; continue 'dispatch;
	}
	// 829EF4A4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829EF4A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EF4AC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829EF4B0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EF4B4: 4BFFEA2D  bl 0x829edee0
	ctx.lr = 0x829EF4B8;
	sub_829EDEE0(ctx, base);
	// 829EF4B8: 48000010  b 0x829ef4c8
	pc = 0x829EF4C8; continue 'dispatch;
	// 829EF4BC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829EF4C0: 396BDE08  addi r11, r11, -0x21f8
	ctx.r[11].s64 = ctx.r[11].s64 + -8696;
	// 829EF4C4: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EF4C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EF4CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF4D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF4D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF4D8 size=480
    let mut pc: u32 = 0x829EF4D8;
    'dispatch: loop {
        match pc {
            0x829EF4D8 => {
    //   block [0x829EF4D8..0x829EF6B8)
	// 829EF4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF4DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EF4E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EF4E4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF4EC: 817F0248  lwz r11, 0x248(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 829EF4F0: 815F0244  lwz r10, 0x244(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829EF4F4: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829EF4F8: 419A01AC  beq cr6, 0x829ef6a4
	if ctx.cr[6].eq {
	pc = 0x829EF6A4; continue 'dispatch;
	}
	// 829EF4FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EF500: 419800C8  blt cr6, 0x829ef5c8
	if ctx.cr[6].lt {
	pc = 0x829EF5C8; continue 'dispatch;
	}
	// 829EF504: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF508: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EF50C: 4BB2005D  bl 0x8250f568
	ctx.lr = 0x829EF510;
	sub_8250F568(ctx, base);
	// 829EF510: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF514: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF518: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829EF51C: 409A0008  bne cr6, 0x829ef524
	if !ctx.cr[6].eq {
	pc = 0x829EF524; continue 'dispatch;
	}
	// 829EF520: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EF524: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EF528: 4BDBB9B9  bl 0x827aaee0
	ctx.lr = 0x829EF52C;
	sub_827AAEE0(ctx, base);
	// 829EF52C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EF530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EF534: 80BF0248  lwz r5, 0x248(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 829EF538: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF53C: 4BDB832D  bl 0x827a7868
	ctx.lr = 0x829EF540;
	sub_827A7868(ctx, base);
	// 829EF540: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EF544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF548: 419A0008  beq cr6, 0x829ef550
	if ctx.cr[6].eq {
	pc = 0x829EF550; continue 'dispatch;
	}
	// 829EF54C: 4B8D1345  bl 0x822c0890
	ctx.lr = 0x829EF550;
	sub_822C0890(ctx, base);
	// 829EF550: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829EF554: 4840273D  bl 0x82df1c90
	ctx.lr = 0x829EF558;
	sub_82DF1C90(ctx, base);
	// 829EF558: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EF55C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF560: 419A0058  beq cr6, 0x829ef5b8
	if ctx.cr[6].eq {
	pc = 0x829EF5B8; continue 'dispatch;
	}
	// 829EF564: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829EF568: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF56C: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 829EF570: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829EF574: 4BB1FFF5  bl 0x8250f568
	ctx.lr = 0x829EF578;
	sub_8250F568(ctx, base);
	// 829EF578: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF57C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF580: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829EF584: 409A0008  bne cr6, 0x829ef58c
	if !ctx.cr[6].eq {
	pc = 0x829EF58C; continue 'dispatch;
	}
	// 829EF588: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EF58C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829EF590: 4BDBB8D1  bl 0x827aae60
	ctx.lr = 0x829EF594;
	sub_827AAE60(ctx, base);
	// 829EF594: 809F0248  lwz r4, 0x248(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(584 as u32) ) } as u64;
	// 829EF598: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF59C: 4BDC801D  bl 0x827b75b8
	ctx.lr = 0x829EF5A0;
	sub_827B75B8(ctx, base);
	// 829EF5A0: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829EF5A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF5A8: 419A0008  beq cr6, 0x829ef5b0
	if ctx.cr[6].eq {
	pc = 0x829EF5B0; continue 'dispatch;
	}
	// 829EF5AC: 4B8D12E5  bl 0x822c0890
	ctx.lr = 0x829EF5B0;
	sub_822C0890(ctx, base);
	// 829EF5B0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829EF5B4: 484026DD  bl 0x82df1c90
	ctx.lr = 0x829EF5B8;
	sub_82DF1C90(ctx, base);
	// 829EF5B8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EF5BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF5C0: 419A0008  beq cr6, 0x829ef5c8
	if ctx.cr[6].eq {
	pc = 0x829EF5C8; continue 'dispatch;
	}
	// 829EF5C4: 4B8D12CD  bl 0x822c0890
	ctx.lr = 0x829EF5C8;
	sub_822C0890(ctx, base);
	// 829EF5C8: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829EF5CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829EF5D0: 419800CC  blt cr6, 0x829ef69c
	if ctx.cr[6].lt {
	pc = 0x829EF69C; continue 'dispatch;
	}
	// 829EF5D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF5D8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829EF5DC: 4BB1FF8D  bl 0x8250f568
	ctx.lr = 0x829EF5E0;
	sub_8250F568(ctx, base);
	// 829EF5E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF5E8: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829EF5EC: 409A0008  bne cr6, 0x829ef5f4
	if !ctx.cr[6].eq {
	pc = 0x829EF5F4; continue 'dispatch;
	}
	// 829EF5F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EF5F4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829EF5F8: 4BDBB8E9  bl 0x827aaee0
	ctx.lr = 0x829EF5FC;
	sub_827AAEE0(ctx, base);
	// 829EF5FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829EF600: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829EF604: 80BF0244  lwz r5, 0x244(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829EF608: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF60C: 4BDB825D  bl 0x827a7868
	ctx.lr = 0x829EF610;
	sub_827A7868(ctx, base);
	// 829EF610: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 829EF614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF618: 419A0008  beq cr6, 0x829ef620
	if ctx.cr[6].eq {
	pc = 0x829EF620; continue 'dispatch;
	}
	// 829EF61C: 4B8D1275  bl 0x822c0890
	ctx.lr = 0x829EF620;
	sub_822C0890(ctx, base);
	// 829EF620: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829EF624: 4840266D  bl 0x82df1c90
	ctx.lr = 0x829EF628;
	sub_82DF1C90(ctx, base);
	// 829EF628: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 829EF62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF630: 419A005C  beq cr6, 0x829ef68c
	if ctx.cr[6].eq {
	pc = 0x829EF68C; continue 'dispatch;
	}
	// 829EF634: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829EF638: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF63C: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 829EF640: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829EF644: 4BB1FF25  bl 0x8250f568
	ctx.lr = 0x829EF648;
	sub_8250F568(ctx, base);
	// 829EF648: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF64C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829EF650: 388BFF40  addi r4, r11, -0xc0
	ctx.r[4].s64 = ctx.r[11].s64 + -192;
	// 829EF654: 409A0008  bne cr6, 0x829ef65c
	if !ctx.cr[6].eq {
	pc = 0x829EF65C; continue 'dispatch;
	}
	// 829EF658: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EF65C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829EF660: 4BDBB801  bl 0x827aae60
	ctx.lr = 0x829EF664;
	sub_827AAE60(ctx, base);
	// 829EF664: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829EF668: 809F0244  lwz r4, 0x244(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829EF66C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EF670: 4BDC8439  bl 0x827b7aa8
	ctx.lr = 0x829EF674;
	sub_827B7AA8(ctx, base);
	// 829EF674: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829EF678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF67C: 419A0008  beq cr6, 0x829ef684
	if ctx.cr[6].eq {
	pc = 0x829EF684; continue 'dispatch;
	}
	// 829EF680: 4B8D1211  bl 0x822c0890
	ctx.lr = 0x829EF684;
	sub_822C0890(ctx, base);
	// 829EF684: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 829EF688: 48402609  bl 0x82df1c90
	ctx.lr = 0x829EF68C;
	sub_82DF1C90(ctx, base);
	// 829EF68C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EF690: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EF694: 419A0008  beq cr6, 0x829ef69c
	if ctx.cr[6].eq {
	pc = 0x829EF69C; continue 'dispatch;
	}
	// 829EF698: 4B8D11F9  bl 0x822c0890
	ctx.lr = 0x829EF69C;
	sub_822C0890(ctx, base);
	// 829EF69C: 817F0244  lwz r11, 0x244(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(580 as u32) ) } as u64;
	// 829EF6A0: 917F0248  stw r11, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[11].u32 ) };
	// 829EF6A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829EF6A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EF6AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EF6B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EF6B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EF6B8 size=456
    let mut pc: u32 = 0x829EF6B8;
    'dispatch: loop {
        match pc {
            0x829EF6B8 => {
    //   block [0x829EF6B8..0x829EF880)
	// 829EF6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF6BC: 487B8AB1  bl 0x831a816c
	ctx.lr = 0x829EF6C0;
	sub_831A8130(ctx, base);
	// 829EF6C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EF6C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EF6C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EF6CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF6D0: 4BFFFA59  bl 0x829ef128
	ctx.lr = 0x829EF6D4;
	sub_829EF128(ctx, base);
	// 829EF6D4: 817F0310  lwz r11, 0x310(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(784 as u32) ) } as u64;
	// 829EF6D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EF6DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829EF6E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF6E4: 917F0310  stw r11, 0x310(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(784 as u32), ctx.r[11].u32 ) };
	// 829EF6E8: 4BFFFA41  bl 0x829ef128
	ctx.lr = 0x829EF6EC;
	sub_829EF128(ctx, base);
	// 829EF6EC: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 829EF6F0: 4198000C  blt cr6, 0x829ef6fc
	if ctx.cr[6].lt {
	pc = 0x829EF6FC; continue 'dispatch;
	}
	// 829EF6F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EF6F8: 917F0310  stw r11, 0x310(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(784 as u32), ctx.r[11].u32 ) };
	// 829EF6FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EF700: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 829EF704: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EF708: 388B675C  addi r4, r11, 0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + 26460;
	// 829EF70C: 41980120  blt cr6, 0x829ef82c
	if ctx.cr[6].lt {
	pc = 0x829EF82C; continue 'dispatch;
	}
	// 829EF710: 419A00E0  beq cr6, 0x829ef7f0
	if ctx.cr[6].eq {
	pc = 0x829EF7F0; continue 'dispatch;
	}
	// 829EF714: 2B1D0003  cmplwi cr6, r29, 3
	ctx.cr[6].compare_u32(ctx.r[29].u32, 3 as u32, &mut ctx.xer);
	// 829EF718: 4198009C  blt cr6, 0x829ef7b4
	if ctx.cr[6].lt {
	pc = 0x829EF7B4; continue 'dispatch;
	}
	// 829EF71C: 419A005C  beq cr6, 0x829ef778
	if ctx.cr[6].eq {
	pc = 0x829EF778; continue 'dispatch;
	}
	// 829EF720: 2B1D0005  cmplwi cr6, r29, 5
	ctx.cr[6].compare_u32(ctx.r[29].u32, 5 as u32, &mut ctx.xer);
	// 829EF724: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829EF728: 41980048  blt cr6, 0x829ef770
	if ctx.cr[6].lt {
	pc = 0x829EF770; continue 'dispatch;
	}
	// 829EF72C: 38A00AB7  li r5, 0xab7
	ctx.r[5].s64 = 2743;
	// 829EF730: 48402CB9  bl 0x82df23e8
	ctx.lr = 0x829EF734;
	sub_82DF23E8(ctx, base);
	// 829EF734: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829EF738: 4182001C  beq 0x829ef754
	if ctx.cr[0].eq {
	pc = 0x829EF754; continue 'dispatch;
	}
	// 829EF73C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EF740: 4846D1E9  bl 0x82e5c928
	ctx.lr = 0x829EF744;
	sub_82E5C928(ctx, base);
	// 829EF744: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EF748: 396B671C  addi r11, r11, 0x671c
	ctx.r[11].s64 = ctx.r[11].s64 + 26396;
	// 829EF74C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EF750: 48000008  b 0x829ef758
	pc = 0x829EF758; continue 'dispatch;
	// 829EF754: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF758: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EF75C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 829EF760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF764: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF768: 4BFFF381  bl 0x829eeae8
	ctx.lr = 0x829EF76C;
	sub_829EEAE8(ctx, base);
	// 829EF76C: 480000F8  b 0x829ef864
	pc = 0x829EF864; continue 'dispatch;
	// 829EF770: 38A00AB3  li r5, 0xab3
	ctx.r[5].s64 = 2739;
	// 829EF774: 4BFFFFBC  b 0x829ef730
	pc = 0x829EF730; continue 'dispatch;
	// 829EF778: 38A00AB1  li r5, 0xab1
	ctx.r[5].s64 = 2737;
	// 829EF77C: 38600110  li r3, 0x110
	ctx.r[3].s64 = 272;
	// 829EF780: 48402C69  bl 0x82df23e8
	ctx.lr = 0x829EF784;
	sub_82DF23E8(ctx, base);
	// 829EF784: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EF788: 41820010  beq 0x829ef798
	if ctx.cr[0].eq {
	pc = 0x829EF798; continue 'dispatch;
	}
	// 829EF78C: 48008175  bl 0x829f7900
	ctx.lr = 0x829EF790;
	sub_829F7900(ctx, base);
	// 829EF790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF794: 48000008  b 0x829ef79c
	pc = 0x829EF79C; continue 'dispatch;
	// 829EF798: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF79C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EF7A0: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 829EF7A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF7A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF7AC: 4BFFF275  bl 0x829eea20
	ctx.lr = 0x829EF7B0;
	sub_829EEA20(ctx, base);
	// 829EF7B0: 480000B4  b 0x829ef864
	pc = 0x829EF864; continue 'dispatch;
	// 829EF7B4: 38A00AAF  li r5, 0xaaf
	ctx.r[5].s64 = 2735;
	// 829EF7B8: 386000D0  li r3, 0xd0
	ctx.r[3].s64 = 208;
	// 829EF7BC: 48402C2D  bl 0x82df23e8
	ctx.lr = 0x829EF7C0;
	sub_82DF23E8(ctx, base);
	// 829EF7C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EF7C4: 41820010  beq 0x829ef7d4
	if ctx.cr[0].eq {
	pc = 0x829EF7D4; continue 'dispatch;
	}
	// 829EF7C8: 4800AEA9  bl 0x829fa670
	ctx.lr = 0x829EF7CC;
	sub_829FA670(ctx, base);
	// 829EF7CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF7D0: 48000008  b 0x829ef7d8
	pc = 0x829EF7D8; continue 'dispatch;
	// 829EF7D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF7D8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EF7DC: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 829EF7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF7E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF7E8: 4BFFF171  bl 0x829ee958
	ctx.lr = 0x829EF7EC;
	sub_829EE958(ctx, base);
	// 829EF7EC: 48000078  b 0x829ef864
	pc = 0x829EF864; continue 'dispatch;
	// 829EF7F0: 38A00AAD  li r5, 0xaad
	ctx.r[5].s64 = 2733;
	// 829EF7F4: 386000F8  li r3, 0xf8
	ctx.r[3].s64 = 248;
	// 829EF7F8: 48402BF1  bl 0x82df23e8
	ctx.lr = 0x829EF7FC;
	sub_82DF23E8(ctx, base);
	// 829EF7FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EF800: 41820010  beq 0x829ef810
	if ctx.cr[0].eq {
	pc = 0x829EF810; continue 'dispatch;
	}
	// 829EF804: 4800EDB5  bl 0x829fe5b8
	ctx.lr = 0x829EF808;
	sub_829FE5B8(ctx, base);
	// 829EF808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF80C: 48000008  b 0x829ef814
	pc = 0x829EF814; continue 'dispatch;
	// 829EF810: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF814: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EF818: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 829EF81C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF820: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF824: 4BFFF06D  bl 0x829ee890
	ctx.lr = 0x829EF828;
	sub_829EE890(ctx, base);
	// 829EF828: 4800003C  b 0x829ef864
	pc = 0x829EF864; continue 'dispatch;
	// 829EF82C: 38A00AAB  li r5, 0xaab
	ctx.r[5].s64 = 2731;
	// 829EF830: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 829EF834: 48402BB5  bl 0x82df23e8
	ctx.lr = 0x829EF838;
	sub_82DF23E8(ctx, base);
	// 829EF838: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EF83C: 41820010  beq 0x829ef84c
	if ctx.cr[0].eq {
	pc = 0x829EF84C; continue 'dispatch;
	}
	// 829EF840: 4800D339  bl 0x829fcb78
	ctx.lr = 0x829EF844;
	sub_829FCB78(ctx, base);
	// 829EF844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EF848: 48000008  b 0x829ef850
	pc = 0x829EF850; continue 'dispatch;
	// 829EF84C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EF850: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EF854: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 829EF858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF860: 4BFFEF69  bl 0x829ee7c8
	ctx.lr = 0x829EF864;
	sub_829EE7C8(ctx, base);
	// 829EF864: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EF868: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EF86C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EF870: 4B8D0791  bl 0x822c0000
	ctx.lr = 0x829EF874;
	sub_822C0000(ctx, base);
	// 829EF874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EF878: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EF87C: 487B8940  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EF880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EF880 size=664
    let mut pc: u32 = 0x829EF880;
    'dispatch: loop {
        match pc {
            0x829EF880 => {
    //   block [0x829EF880..0x829EFB18)
	// 829EF880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EF884: 487B88E5  bl 0x831a8168
	ctx.lr = 0x829EF888;
	sub_831A8130(ctx, base);
	// 829EF888: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829EF88C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EFB18 size=292
    let mut pc: u32 = 0x829EFB18;
    'dispatch: loop {
        match pc {
            0x829EFB18 => {
    //   block [0x829EFB18..0x829EFC3C)
	// 829EFB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EFB20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EFB24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EFB28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFB2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829EFB30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 829EFB34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829EFB38: 997E045C  stb r11, 0x45c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1116 as u32), ctx.r[11].u8 ) };
	// 829EFB3C: 4BB20005  bl 0x8250fb40
	ctx.lr = 0x829EFB40;
	sub_8250FB40(ctx, base);
	// 829EFB40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EFB44: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EFB48: 388B675C  addi r4, r11, 0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + 26460;
	// 829EFB4C: 38A00C4A  li r5, 0xc4a
	ctx.r[5].s64 = 3146;
	// 829EFB50: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 829EFB54: 48402895  bl 0x82df23e8
	ctx.lr = 0x829EFB58;
	sub_82DF23E8(ctx, base);
	// 829EFB58: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829EFB5C: 4182001C  beq 0x829efb78
	if ctx.cr[0].eq {
	pc = 0x829EFB78; continue 'dispatch;
	}
	// 829EFB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFB64: 4846CDC5  bl 0x82e5c928
	ctx.lr = 0x829EFB68;
	sub_82E5C928(ctx, base);
	// 829EFB68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EFB6C: 396B671C  addi r11, r11, 0x671c
	ctx.r[11].s64 = ctx.r[11].s64 + 26396;
	// 829EFB70: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EFB74: 48000008  b 0x829efb7c
	pc = 0x829EFB7C; continue 'dispatch;
	// 829EFB78: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EFB7C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829EFB80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFB84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EFB88: 4BFFEF61  bl 0x829eeae8
	ctx.lr = 0x829EFB8C;
	sub_829EEAE8(ctx, base);
	// 829EFB8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EFB90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFB94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EFB98: 4B8D0469  bl 0x822c0000
	ctx.lr = 0x829EFB9C;
	sub_822C0000(ctx, base);
	// 829EFB9C: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EFBA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EFBA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EFBA8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 829EFBAC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829EFBB0: 419A0024  beq cr6, 0x829efbd4
	if ctx.cr[6].eq {
	pc = 0x829EFBD4; continue 'dispatch;
	}
	// 829EFBB4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829EFBB8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829EFBBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EFBC0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829EFBC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829EFBC8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EFBCC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EFBD0: 4082FFE8  bne 0x829efbb8
	if !ctx.cr[0].eq {
	pc = 0x829EFBB8; continue 'dispatch;
	}
	// 829EFBD4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829EFBD8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829EFBDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EFBE0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829EFBE4: 389E00E8  addi r4, r30, 0xe8
	ctx.r[4].s64 = ctx.r[30].s64 + 232;
	// 829EFBE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829EFBEC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EFBF0: 4846EAB9  bl 0x82e5e6a8
	ctx.lr = 0x829EFBF4;
	sub_82E5E6A8(ctx, base);
	// 829EFBF4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829EFBF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFBFC: 419A0008  beq cr6, 0x829efc04
	if ctx.cr[6].eq {
	pc = 0x829EFC04; continue 'dispatch;
	}
	// 829EFC00: 4B8D0C91  bl 0x822c0890
	ctx.lr = 0x829EFC04;
	sub_822C0890(ctx, base);
	// 829EFC04: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829EFC08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFC0C: 419A0008  beq cr6, 0x829efc14
	if ctx.cr[6].eq {
	pc = 0x829EFC14; continue 'dispatch;
	}
	// 829EFC10: 4B8D0C81  bl 0x822c0890
	ctx.lr = 0x829EFC14;
	sub_822C0890(ctx, base);
	// 829EFC14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EFC18: 419A000C  beq cr6, 0x829efc24
	if ctx.cr[6].eq {
	pc = 0x829EFC24; continue 'dispatch;
	}
	// 829EFC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFC20: 4B8D0C71  bl 0x822c0890
	ctx.lr = 0x829EFC24;
	sub_822C0890(ctx, base);
	// 829EFC24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EFC28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EFC2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EFC30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EFC34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EFC38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFC40 size=200
    let mut pc: u32 = 0x829EFC40;
    'dispatch: loop {
        match pc {
            0x829EFC40 => {
    //   block [0x829EFC40..0x829EFD08)
	// 829EFC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFC44: 487B8525  bl 0x831a8168
	ctx.lr = 0x829EFC48;
	sub_831A8130(ctx, base);
	// 829EFC48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFC4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFC50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EFC54: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829EFC58: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 829EFC5C: 4BB226D5  bl 0x82512330
	ctx.lr = 0x829EFC60;
	sub_82512330(ctx, base);
	// 829EFC60: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829EFC64: 4BF571ED  bl 0x82946e50
	ctx.lr = 0x829EFC68;
	sub_82946E50(ctx, base);
	// 829EFC68: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EFC6C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829EFC70: 396B67D4  addi r11, r11, 0x67d4
	ctx.r[11].s64 = ctx.r[11].s64 + 26580;
	// 829EFC74: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829EFC78: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EFC7C: 394A67BC  addi r10, r10, 0x67bc
	ctx.r[10].s64 = ctx.r[10].s64 + 26556;
	// 829EFC80: 392967A0  addi r9, r9, 0x67a0
	ctx.r[9].s64 = ctx.r[9].s64 + 26528;
	// 829EFC84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829EFC88: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829EFC8C: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 829EFC90: 395F00F4  addi r10, r31, 0xf4
	ctx.r[10].s64 = ctx.r[31].s64 + 244;
	// 829EFC94: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829EFC98: 393E0004  addi r9, r30, 4
	ctx.r[9].s64 = ctx.r[30].s64 + 4;
	// 829EFC9C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 829EFCA0: B39F00F0  sth r28, 0xf0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[28].u16 ) };
	// 829EFCA4: 9BBF00F2  stb r29, 0xf2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(242 as u32), ctx.r[29].u8 ) };
	// 829EFCA8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFCAC: 915F00F4  stw r10, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 829EFCB0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EFCB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829EFCB8: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 829EFCBC: 419A0024  beq cr6, 0x829efce0
	if ctx.cr[6].eq {
	pc = 0x829EFCE0; continue 'dispatch;
	}
	// 829EFCC0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 829EFCC4: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 829EFCC8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EFCCC: 7D005028  lwarx r8, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 829EFCD0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 829EFCD4: 7D00512D  stwcx. r8, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829EFCD8: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829EFCDC: 4082FFE8  bne 0x829efcc4
	if !ctx.cr[0].eq {
	pc = 0x829EFCC4; continue 'dispatch;
	}
	// 829EFCE0: 997F00FC  stb r11, 0xfc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u8 ) };
	// 829EFCE4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 829EFCE8: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 829EFCEC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFCF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFCF4: 419A0008  beq cr6, 0x829efcfc
	if ctx.cr[6].eq {
	pc = 0x829EFCFC; continue 'dispatch;
	}
	// 829EFCF8: 4B8D0B99  bl 0x822c0890
	ctx.lr = 0x829EFCFC;
	sub_822C0890(ctx, base);
	// 829EFCFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFD00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EFD04: 487B84B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EFD08 size=8
    let mut pc: u32 = 0x829EFD08;
    'dispatch: loop {
        match pc {
            0x829EFD08 => {
    //   block [0x829EFD08..0x829EFD10)
	// 829EFD08: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829EFD0C: 48001ABC  b 0x829f17c8
	sub_829F17C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFD10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829EFD10 size=8
    let mut pc: u32 = 0x829EFD10;
    'dispatch: loop {
        match pc {
            0x829EFD10 => {
    //   block [0x829EFD10..0x829EFD18)
	// 829EFD10: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829EFD14: 48001AB4  b 0x829f17c8
	sub_829F17C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFD18 size=116
    let mut pc: u32 = 0x829EFD18;
    'dispatch: loop {
        match pc {
            0x829EFD18 => {
    //   block [0x829EFD18..0x829EFD8C)
	// 829EFD18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFD1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EFD20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EFD24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFD28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFD2C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 829EFD30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFD34: 419A0008  beq cr6, 0x829efd3c
	if ctx.cr[6].eq {
	pc = 0x829EFD3C; continue 'dispatch;
	}
	// 829EFD38: 4B8D0B59  bl 0x822c0890
	ctx.lr = 0x829EFD3C;
	sub_822C0890(ctx, base);
	// 829EFD3C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 829EFD40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFD44: 419A0008  beq cr6, 0x829efd4c
	if ctx.cr[6].eq {
	pc = 0x829EFD4C; continue 'dispatch;
	}
	// 829EFD48: 4B8D0B49  bl 0x822c0890
	ctx.lr = 0x829EFD4C;
	sub_822C0890(ctx, base);
	// 829EFD4C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 829EFD50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFD54: 419A0008  beq cr6, 0x829efd5c
	if ctx.cr[6].eq {
	pc = 0x829EFD5C; continue 'dispatch;
	}
	// 829EFD58: 4B8D0B39  bl 0x822c0890
	ctx.lr = 0x829EFD5C;
	sub_822C0890(ctx, base);
	// 829EFD5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829EFD60: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 829EFD64: 409A0008  bne cr6, 0x829efd6c
	if !ctx.cr[6].eq {
	pc = 0x829EFD6C; continue 'dispatch;
	}
	// 829EFD68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829EFD6C: 4BF570E5  bl 0x82946e50
	ctx.lr = 0x829EFD70;
	sub_82946E50(ctx, base);
	// 829EFD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFD74: 4B95F5DD  bl 0x8234f350
	ctx.lr = 0x829EFD78;
	sub_8234F350(ctx, base);
	// 829EFD78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829EFD7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EFD80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EFD84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EFD88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFD90 size=112
    let mut pc: u32 = 0x829EFD90;
    'dispatch: loop {
        match pc {
            0x829EFD90 => {
    //   block [0x829EFD90..0x829EFE00)
	// 829EFD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829EFD98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829EFD9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829EFDA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFDA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EFDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFDAC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829EFDB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EFDB4: 4BBEEFC5  bl 0x825ded78
	ctx.lr = 0x829EFDB8;
	sub_825DED78(ctx, base);
	// 829EFDB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829EFDBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829EFDC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829EFDC4: 4B8D023D  bl 0x822c0000
	ctx.lr = 0x829EFDC8;
	sub_822C0000(ctx, base);
	// 829EFDC8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829EFDCC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829EFDD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EFDD4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829EFDD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829EFDDC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829EFDE0: 419A0008  beq cr6, 0x829efde8
	if ctx.cr[6].eq {
	pc = 0x829EFDE8; continue 'dispatch;
	}
	// 829EFDE4: 4B8D0AAD  bl 0x822c0890
	ctx.lr = 0x829EFDE8;
	sub_822C0890(ctx, base);
	// 829EFDE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EFDEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829EFDF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829EFDF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829EFDF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829EFDFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFE00 size=120
    let mut pc: u32 = 0x829EFE00;
    'dispatch: loop {
        match pc {
            0x829EFE00 => {
    //   block [0x829EFE00..0x829EFE78)
	// 829EFE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFE04: 487B8369  bl 0x831a816c
	ctx.lr = 0x829EFE08;
	sub_831A8130(ctx, base);
	// 829EFE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFE0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EFE10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EFE14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EFE18: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EFE1C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829EFE20: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829EFE24: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829EFE28: 484025C1  bl 0x82df23e8
	ctx.lr = 0x829EFE2C;
	sub_82DF23E8(ctx, base);
	// 829EFE2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EFE30: 41820014  beq 0x829efe44
	if ctx.cr[0].eq {
	pc = 0x829EFE44; continue 'dispatch;
	}
	// 829EFE34: 889F0000  lbz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFE38: 48161351  bl 0x82b51188
	ctx.lr = 0x829EFE3C;
	sub_82B51188(ctx, base);
	// 829EFE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFE40: 48000008  b 0x829efe48
	pc = 0x829EFE48; continue 'dispatch;
	// 829EFE44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EFE48: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EFE4C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829EFE50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFE54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFE58: 4BFFEEE9  bl 0x829eed40
	ctx.lr = 0x829EFE5C;
	sub_829EED40(ctx, base);
	// 829EFE5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EFE60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFE64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFE68: 4B8D0199  bl 0x822c0000
	ctx.lr = 0x829EFE6C;
	sub_822C0000(ctx, base);
	// 829EFE6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EFE70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EFE74: 487B8348  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFE78 size=152
    let mut pc: u32 = 0x829EFE78;
    'dispatch: loop {
        match pc {
            0x829EFE78 => {
    //   block [0x829EFE78..0x829EFF10)
	// 829EFE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFE7C: 487B82ED  bl 0x831a8168
	ctx.lr = 0x829EFE80;
	sub_831A8130(ctx, base);
	// 829EFE80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFE84: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EFE88: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EFE8C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829EFE90: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EFE94: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EFE98: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829EFE9C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829EFEA0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829EFEA4: 48402545  bl 0x82df23e8
	ctx.lr = 0x829EFEA8;
	sub_82DF23E8(ctx, base);
	// 829EFEA8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829EFEAC: 41820030  beq 0x829efedc
	if ctx.cr[0].eq {
	pc = 0x829EFEDC; continue 'dispatch;
	}
	// 829EFEB0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFEB8: 8BDC0000  lbz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFEBC: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 829EFEC0: 484697C1  bl 0x82e59680
	ctx.lr = 0x829EFEC4;
	sub_82E59680(ctx, base);
	// 829EFEC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829EFEC8: 9B9F0018  stb r28, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 829EFECC: 9BDF0019  stb r30, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	// 829EFED0: 396B6544  addi r11, r11, 0x6544
	ctx.r[11].s64 = ctx.r[11].s64 + 25924;
	// 829EFED4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829EFED8: 48000008  b 0x829efee0
	pc = 0x829EFEE0; continue 'dispatch;
	// 829EFEDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EFEE0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EFEE4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829EFEE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFEEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFEF0: 4BFFEF19  bl 0x829eee08
	ctx.lr = 0x829EFEF4;
	sub_829EEE08(ctx, base);
	// 829EFEF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EFEF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFEFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFF00: 4B8D0101  bl 0x822c0000
	ctx.lr = 0x829EFF04;
	sub_822C0000(ctx, base);
	// 829EFF04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EFF08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829EFF0C: 487B82AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829EFF10 size=120
    let mut pc: u32 = 0x829EFF10;
    'dispatch: loop {
        match pc {
            0x829EFF10 => {
    //   block [0x829EFF10..0x829EFF88)
	// 829EFF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFF14: 487B8259  bl 0x831a816c
	ctx.lr = 0x829EFF18;
	sub_831A8130(ctx, base);
	// 829EFF18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFF1C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EFF20: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829EFF24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829EFF28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EFF2C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829EFF30: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829EFF34: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829EFF38: 484024B1  bl 0x82df23e8
	ctx.lr = 0x829EFF3C;
	sub_82DF23E8(ctx, base);
	// 829EFF3C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829EFF40: 41820014  beq 0x829eff54
	if ctx.cr[0].eq {
	pc = 0x829EFF54; continue 'dispatch;
	}
	// 829EFF44: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829EFF48: 481695D1  bl 0x82b59518
	ctx.lr = 0x829EFF4C;
	sub_82B59518(ctx, base);
	// 829EFF4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFF50: 48000008  b 0x829eff58
	pc = 0x829EFF58; continue 'dispatch;
	// 829EFF54: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EFF58: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EFF5C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829EFF60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFF64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFF68: 4BFFEF69  bl 0x829eeed0
	ctx.lr = 0x829EFF6C;
	sub_829EEED0(ctx, base);
	// 829EFF6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829EFF70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829EFF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829EFF78: 4B8D0089  bl 0x822c0000
	ctx.lr = 0x829EFF7C;
	sub_822C0000(ctx, base);
	// 829EFF7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829EFF80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829EFF84: 487B8238  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829EFF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829EFF88 size=176
    let mut pc: u32 = 0x829EFF88;
    'dispatch: loop {
        match pc {
            0x829EFF88 => {
    //   block [0x829EFF88..0x829F0038)
	// 829EFF88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829EFF8C: 487B81D9  bl 0x831a8164
	ctx.lr = 0x829EFF90;
	sub_831A8130(ctx, base);
	// 829EFF90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829EFF94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829EFF98: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829EFF9C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829EFFA0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829EFFA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829EFFA8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829EFFAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829EFFB0: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829EFFB4: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829EFFB8: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 829EFFBC: 4840242D  bl 0x82df23e8
	ctx.lr = 0x829EFFC0;
	sub_82DF23E8(ctx, base);
	// 829EFFC0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829EFFC4: 41820030  beq 0x829efff4
	if ctx.cr[0].eq {
	pc = 0x829EFFF4; continue 'dispatch;
	}
	// 829EFFC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829EFFCC: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFFD0: 48403A39  bl 0x82df3a08
	ctx.lr = 0x829EFFD4;
	sub_82DF3A08(ctx, base);
	// 829EFFD4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 829EFFD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829EFFDC: 88BC0000  lbz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 829EFFE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829EFFE4: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 829EFFE8: 4816BB09  bl 0x82b5baf0
	ctx.lr = 0x829EFFEC;
	sub_82B5BAF0(ctx, base);
	// 829EFFEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829EFFF0: 48000008  b 0x829efff8
	pc = 0x829EFFF8; continue 'dispatch;
	// 829EFFF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829EFFF8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829EFFFC: 3BBB0004  addi r29, r27, 4
	ctx.r[29].s64 = ctx.r[27].s64 + 4;
	// 829F0000: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0008: 4BA5DEB9  bl 0x8244dec0
	ctx.lr = 0x829F000C;
	sub_8244DEC0(ctx, base);
	// 829F000C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F0010: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0018: 4B8CFFE9  bl 0x822c0000
	ctx.lr = 0x829F001C;
	sub_822C0000(ctx, base);
	// 829F001C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F0020: 4182000C  beq 0x829f002c
	if ctx.cr[0].eq {
	pc = 0x829F002C; continue 'dispatch;
	}
	// 829F0024: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F0028: 48403401  bl 0x82df3428
	ctx.lr = 0x829F002C;
	sub_82DF3428(ctx, base);
	// 829F002C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F0030: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F0034: 487B8180  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0038 size=132
    let mut pc: u32 = 0x829F0038;
    'dispatch: loop {
        match pc {
            0x829F0038 => {
    //   block [0x829F0038..0x829F00BC)
	// 829F0038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F003C: 487B8131  bl 0x831a816c
	ctx.lr = 0x829F0040;
	sub_831A8130(ctx, base);
	// 829F0040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0044: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F0048: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F004C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F0050: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829F0054: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829F0058: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829F005C: 4840238D  bl 0x82df23e8
	ctx.lr = 0x829F0060;
	sub_82DF23E8(ctx, base);
	// 829F0060: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829F0064: 41820024  beq 0x829f0088
	if ctx.cr[0].eq {
	pc = 0x829F0088; continue 'dispatch;
	}
	// 829F0068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F006C: 48469615  bl 0x82e59680
	ctx.lr = 0x829F0070;
	sub_82E59680(ctx, base);
	// 829F0070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F0074: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F0078: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 829F007C: 396A653C  addi r11, r10, 0x653c
	ctx.r[11].s64 = ctx.r[10].s64 + 25916;
	// 829F0080: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F0084: 48000008  b 0x829f008c
	pc = 0x829F008C; continue 'dispatch;
	// 829F0088: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F008C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F0090: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829F0094: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F009C: 4BFFEEFD  bl 0x829eef98
	ctx.lr = 0x829F00A0;
	sub_829EEF98(ctx, base);
	// 829F00A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F00A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F00A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F00AC: 4B8CFF55  bl 0x822c0000
	ctx.lr = 0x829F00B0;
	sub_822C0000(ctx, base);
	// 829F00B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F00B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F00B8: 487B8104  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F00C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F00C0 size=136
    let mut pc: u32 = 0x829F00C0;
    'dispatch: loop {
        match pc {
            0x829F00C0 => {
    //   block [0x829F00C0..0x829F0148)
	// 829F00C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F00C4: 487B80A9  bl 0x831a816c
	ctx.lr = 0x829F00C8;
	sub_831A8130(ctx, base);
	// 829F00C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F00CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F00D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F00D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F00D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F00DC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829F00E0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 829F00E4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 829F00E8: 48402301  bl 0x82df23e8
	ctx.lr = 0x829F00EC;
	sub_82DF23E8(ctx, base);
	// 829F00EC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829F00F0: 41820024  beq 0x829f0114
	if ctx.cr[0].eq {
	pc = 0x829F0114; continue 'dispatch;
	}
	// 829F00F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F00F8: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F00FC: 48469585  bl 0x82e59680
	ctx.lr = 0x829F0100;
	sub_82E59680(ctx, base);
	// 829F0100: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F0104: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 829F0108: 396B653C  addi r11, r11, 0x653c
	ctx.r[11].s64 = ctx.r[11].s64 + 25916;
	// 829F010C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F0110: 48000008  b 0x829f0118
	pc = 0x829F0118; continue 'dispatch;
	// 829F0114: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F0118: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F011C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829F0120: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F0128: 4BFFEE71  bl 0x829eef98
	ctx.lr = 0x829F012C;
	sub_829EEF98(ctx, base);
	// 829F012C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F0130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F0138: 4B8CFEC9  bl 0x822c0000
	ctx.lr = 0x829F013C;
	sub_822C0000(ctx, base);
	// 829F013C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F0144: 487B8078  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F0148 size=124
    let mut pc: u32 = 0x829F0148;
    'dispatch: loop {
        match pc {
            0x829F0148 => {
    //   block [0x829F0148..0x829F01C4)
	// 829F0148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F014C: 487B8021  bl 0x831a816c
	ctx.lr = 0x829F0150;
	sub_831A8130(ctx, base);
	// 829F0150: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0154: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F0158: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F015C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F0160: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 829F0164: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 829F0168: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 829F016C: 4840227D  bl 0x82df23e8
	ctx.lr = 0x829F0170;
	sub_82DF23E8(ctx, base);
	// 829F0170: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829F0174: 4182001C  beq 0x829f0190
	if ctx.cr[0].eq {
	pc = 0x829F0190; continue 'dispatch;
	}
	// 829F0178: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F017C: 48469505  bl 0x82e59680
	ctx.lr = 0x829F0180;
	sub_82E59680(ctx, base);
	// 829F0180: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F0184: 396B655C  addi r11, r11, 0x655c
	ctx.r[11].s64 = ctx.r[11].s64 + 25948;
	// 829F0188: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F018C: 48000008  b 0x829f0194
	pc = 0x829F0194; continue 'dispatch;
	// 829F0190: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F0194: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F0198: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 829F019C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F01A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F01A4: 4BFFEEBD  bl 0x829ef060
	ctx.lr = 0x829F01A8;
	sub_829EF060(ctx, base);
	// 829F01A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F01AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F01B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F01B4: 4B8CFE4D  bl 0x822c0000
	ctx.lr = 0x829F01B8;
	sub_822C0000(ctx, base);
	// 829F01B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F01BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F01C0: 487B7FFC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F01C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F01C8 size=2880
    let mut pc: u32 = 0x829F01C8;
    'dispatch: loop {
        match pc {
            0x829F01C8 => {
    //   block [0x829F01C8..0x829F0D08)
	// 829F01C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F01CC: 487B7F99  bl 0x831a8164
	ctx.lr = 0x829F01D0;
	sub_831A8130(ctx, base);
	// 829F01D0: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 829F01D4: 487B88A5  bl 0x831a8a78
	ctx.lr = 0x829F01D8;
	sub_831A8A40(ctx, base);
	// 829F01D8: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F01DC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F01E0: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 829F01E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F01E8: 3B8BD6C4  addi r28, r11, -0x293c
	ctx.r[28].s64 = ctx.r[11].s64 + -10556;
	// 829F01EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F01F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F01F4: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 829F01F8: C38A08A8  lfs f28, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 829F01FC: 3BDB01D0  addi r30, r27, 0x1d0
	ctx.r[30].s64 = ctx.r[27].s64 + 464;
	// 829F0200: 3BFB01F0  addi r31, r27, 0x1f0
	ctx.r[31].s64 = ctx.r[27].s64 + 496;
	// 829F0204: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F0208: C3DF0000  lfs f30, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F020C: C01F0010  lfs f0, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0210: EC00F77A  fmadds f0, f0, f29, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64);
	// 829F0214: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829F0218: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 829F021C: 40990008  ble cr6, 0x829f0224
	if !ctx.cr[6].gt {
	pc = 0x829F0224; continue 'dispatch;
	}
	// 829F0220: D39F0000  stfs f28, 0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829F0224: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0228: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F022C: 40980008  bge cr6, 0x829f0234
	if !ctx.cr[6].lt {
	pc = 0x829F0234; continue 'dispatch;
	}
	// 829F0230: D3FF0000  stfs f31, 0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 829F0234: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F0238: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F023C: 48156785  bl 0x82b469c0
	ctx.lr = 0x829F0240;
	sub_82B469C0(ctx, base);
	// 829F0240: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 829F0244: 4199002C  bgt cr6, 0x829f0270
	if ctx.cr[6].gt {
	pc = 0x829F0270; continue 'dispatch;
	}
	// 829F0248: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F024C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F0250: 40990020  ble cr6, 0x829f0270
	if !ctx.cr[6].gt {
	pc = 0x829F0270; continue 'dispatch;
	}
	// 829F0254: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0258: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F025C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0260: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0264: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0268: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F026C: 4E800421  bctrl
	ctx.lr = 0x829F0270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F0270: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0274: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F0278: 41990014  bgt cr6, 0x829f028c
	if ctx.cr[6].gt {
	pc = 0x829F028C; continue 'dispatch;
	}
	// 829F027C: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 829F0280: 4099000C  ble cr6, 0x829f028c
	if !ctx.cr[6].gt {
	pc = 0x829F028C; continue 'dispatch;
	}
	// 829F0284: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0288: 48156441  bl 0x82b466c8
	ctx.lr = 0x829F028C;
	sub_82B466C8(ctx, base);
	// 829F028C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 829F0290: 397C0010  addi r11, r28, 0x10
	ctx.r[11].s64 = ctx.r[28].s64 + 16;
	// 829F0294: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829F0298: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 829F029C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 829F02A0: 4198FF68  blt cr6, 0x829f0208
	if ctx.cr[6].lt {
	pc = 0x829F0208; continue 'dispatch;
	}
	// 829F02A4: C01B0458  lfs f0, 0x458(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F02A8: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 829F02AC: D01B0458  stfs f0, 0x458(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(1112 as u32), tmp.u32 ) };
	// 829F02B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F02B4: 40980008  bge cr6, 0x829f02bc
	if !ctx.cr[6].lt {
	pc = 0x829F02BC; continue 'dispatch;
	}
	// 829F02B8: D3FB0458  stfs f31, 0x458(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(1112 as u32), tmp.u32 ) };
	// 829F02BC: C01B0240  lfs f0, 0x240(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(576 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F02C0: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 829F02C4: D01B0240  stfs f0, 0x240(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 829F02C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F02CC: 40980008  bge cr6, 0x829f02d4
	if !ctx.cr[6].lt {
	pc = 0x829F02D4; continue 'dispatch;
	}
	// 829F02D0: D3FB0240  stfs f31, 0x240(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 829F02D4: A97B0308  lha r11, 0x308(r27)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(776 as u32) ) } as i16) as i64;
	// 829F02D8: C01B030C  lfs f0, 0x30c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F02DC: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 829F02E0: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 829F02E4: 4181000C  bgt 0x829f02f0
	if ctx.cr[0].gt {
	pc = 0x829F02F0; continue 'dispatch;
	}
	// 829F02E8: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 829F02EC: D01B030C  stfs f0, 0x30c(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(780 as u32), tmp.u32 ) };
	// 829F02F0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 829F02F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F02F8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829F02FC: 3BCB675C  addi r30, r11, 0x675c
	ctx.r[30].s64 = ctx.r[11].s64 + 26460;
	// 829F0300: C3AA0824  lfs f29, 0x824(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2084 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 829F0304: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 829F0308: 419903B4  bgt cr6, 0x829f06bc
	if ctx.cr[6].gt {
	pc = 0x829F06BC; continue 'dispatch;
	}
	// 829F030C: C01B030C  lfs f0, 0x30c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0310: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 829F0314: 40990170  ble cr6, 0x829f0484
	if !ctx.cr[6].gt {
	pc = 0x829F0484; continue 'dispatch;
	}
	// 829F0318: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 829F031C: 4BBA775D  bl 0x82597a78
	ctx.lr = 0x829F0320;
	sub_82597A78(ctx, base);
	// 829F0320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0324: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 829F0328: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F032C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0330: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 829F0334: 419A0024  beq cr6, 0x829f0358
	if ctx.cr[6].eq {
	pc = 0x829F0358; continue 'dispatch;
	}
	// 829F0338: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F033C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F0340: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0344: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F0348: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F034C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F0350: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0354: 4082FFE8  bne 0x829f033c
	if !ctx.cr[0].eq {
	pc = 0x829F033C; continue 'dispatch;
	}
	// 829F0358: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F035C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 829F0360: 4BB1F169  bl 0x8250f4c8
	ctx.lr = 0x829F0364;
	sub_8250F4C8(ctx, base);
	// 829F0364: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F036C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F0370: 409A0008  bne cr6, 0x829f0378
	if !ctx.cr[6].eq {
	pc = 0x829F0378; continue 'dispatch;
	}
	// 829F0374: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F0378: 3BFB0028  addi r31, r27, 0x28
	ctx.r[31].s64 = ctx.r[27].s64 + 40;
	// 829F037C: 3B810098  addi r28, r1, 0x98
	ctx.r[28].s64 = ctx.r[1].s64 + 152;
	// 829F0380: 4BB18AE1  bl 0x82508e60
	ctx.lr = 0x829F0384;
	sub_82508E60(ctx, base);
	// 829F0384: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F0388: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F038C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F0390: 38A00853  li r5, 0x853
	ctx.r[5].s64 = 2131;
	// 829F0394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F0398: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F039C: 484686A5  bl 0x82e58a40
	ctx.lr = 0x829F03A0;
	sub_82E58A40(ctx, base);
	// 829F03A0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 829F03A4: 484018ED  bl 0x82df1c90
	ctx.lr = 0x829F03A8;
	sub_82DF1C90(ctx, base);
	// 829F03A8: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 829F03AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F03B0: 419A0008  beq cr6, 0x829f03b8
	if ctx.cr[6].eq {
	pc = 0x829F03B8; continue 'dispatch;
	}
	// 829F03B4: 4B8D04DD  bl 0x822c0890
	ctx.lr = 0x829F03B8;
	sub_822C0890(ctx, base);
	// 829F03B8: 8061018C  lwz r3, 0x18c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(396 as u32) ) } as u64;
	// 829F03BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F03C0: 419A0008  beq cr6, 0x829f03c8
	if ctx.cr[6].eq {
	pc = 0x829F03C8; continue 'dispatch;
	}
	// 829F03C4: 4B8D04CD  bl 0x822c0890
	ctx.lr = 0x829F03C8;
	sub_822C0890(ctx, base);
	// 829F03C8: 396000FA  li r11, 0xfa
	ctx.r[11].s64 = 250;
	// 829F03CC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 829F03D0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F03D4: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 829F03D8: 4BF9AB91  bl 0x8298af68
	ctx.lr = 0x829F03DC;
	sub_8298AF68(ctx, base);
	// 829F03DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F03E0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829F03E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F03E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F03EC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 829F03F0: 419A0024  beq cr6, 0x829f0414
	if ctx.cr[6].eq {
	pc = 0x829F0414; continue 'dispatch;
	}
	// 829F03F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F03F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F03FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0400: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F0404: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F0408: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F040C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0410: 4082FFE8  bne 0x829f03f8
	if !ctx.cr[0].eq {
	pc = 0x829F03F8; continue 'dispatch;
	}
	// 829F0414: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F0418: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829F041C: 4BB1F0AD  bl 0x8250f4c8
	ctx.lr = 0x829F0420;
	sub_8250F4C8(ctx, base);
	// 829F0420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0428: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F042C: 409A0008  bne cr6, 0x829f0434
	if !ctx.cr[6].eq {
	pc = 0x829F0434; continue 'dispatch;
	}
	// 829F0430: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F0434: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F0438: 3B810070  addi r28, r1, 0x70
	ctx.r[28].s64 = ctx.r[1].s64 + 112;
	// 829F043C: 4BB185DD  bl 0x82508a18
	ctx.lr = 0x829F0440;
	sub_82508A18(ctx, base);
	// 829F0440: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F0444: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F0448: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F044C: 38A00856  li r5, 0x856
	ctx.r[5].s64 = 2134;
	// 829F0450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F0454: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F0458: 484685E9  bl 0x82e58a40
	ctx.lr = 0x829F045C;
	sub_82E58A40(ctx, base);
	// 829F045C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829F0460: 48401831  bl 0x82df1c90
	ctx.lr = 0x829F0464;
	sub_82DF1C90(ctx, base);
	// 829F0464: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F0468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F046C: 419A0008  beq cr6, 0x829f0474
	if ctx.cr[6].eq {
	pc = 0x829F0474; continue 'dispatch;
	}
	// 829F0470: 4B8D0421  bl 0x822c0890
	ctx.lr = 0x829F0474;
	sub_822C0890(ctx, base);
	// 829F0474: 80610174  lwz r3, 0x174(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) } as u64;
	// 829F0478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F047C: 419A0008  beq cr6, 0x829f0484
	if ctx.cr[6].eq {
	pc = 0x829F0484; continue 'dispatch;
	}
	// 829F0480: 4B8D0411  bl 0x822c0890
	ctx.lr = 0x829F0484;
	sub_822C0890(ctx, base);
	// 829F0484: C01B030C  lfs f0, 0x30c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(780 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0488: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 829F048C: 40990230  ble cr6, 0x829f06bc
	if !ctx.cr[6].gt {
	pc = 0x829F06BC; continue 'dispatch;
	}
	// 829F0490: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829F0494: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829F0498: 392BD910  addi r9, r11, -0x26f0
	ctx.r[9].s64 = ctx.r[11].s64 + -9968;
	// 829F049C: 394AD720  addi r10, r10, -0x28e0
	ctx.r[10].s64 = ctx.r[10].s64 + -10464;
	// 829F04A0: 390101A0  addi r8, r1, 0x1a0
	ctx.r[8].s64 = ctx.r[1].s64 + 416;
	// 829F04A4: C00BD910  lfs f0, -0x26f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9968 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F04A8: 388101A0  addi r4, r1, 0x1a0
	ctx.r[4].s64 = ctx.r[1].s64 + 416;
	// 829F04AC: D00100D0  stfs f0, 0xd0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 829F04B0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 829F04B4: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F04B8: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F04BC: C1A90008  lfs f13, 8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F04C0: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F04C4: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 829F04C8: D1A100D8  stfs f13, 0xd8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 829F04CC: D18100DC  stfs f12, 0xdc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F0D08 size=472
    let mut pc: u32 = 0x829F0D08;
    'dispatch: loop {
        match pc {
            0x829F0D08 => {
    //   block [0x829F0D08..0x829F0EE0)
	// 829F0D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F0D0C: 487B745D  bl 0x831a8168
	ctx.lr = 0x829F0D10;
	sub_831A8130(ctx, base);
	// 829F0D10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0D14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F0D18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F0D1C: 3BDF0320  addi r30, r31, 0x320
	ctx.r[30].s64 = ctx.r[31].s64 + 800;
	// 829F0D20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F0D24: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 829F0D28: 4B92C4A9  bl 0x8231d1d0
	ctx.lr = 0x829F0D2C;
	sub_8231D1D0(ctx, base);
	// 829F0D2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0D30: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F0D34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0D38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0D3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F0D40: 419A0024  beq cr6, 0x829f0d64
	if ctx.cr[6].eq {
	pc = 0x829F0D64; continue 'dispatch;
	}
	// 829F0D44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F0D48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F0D4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0D50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F0D54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F0D58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F0D5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0D60: 4082FFE8  bne 0x829f0d48
	if !ctx.cr[0].eq {
	pc = 0x829F0D48; continue 'dispatch;
	}
	// 829F0D64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0D68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0D6C: 4BB1E75D  bl 0x8250f4c8
	ctx.lr = 0x829F0D70;
	sub_8250F4C8(ctx, base);
	// 829F0D70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0D74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F0D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0D7C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F0D80: 409A0008  bne cr6, 0x829f0d88
	if !ctx.cr[6].eq {
	pc = 0x829F0D88; continue 'dispatch;
	}
	// 829F0D84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F0D88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F0D8C: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 829F0D90: 4BB17C89  bl 0x82508a18
	ctx.lr = 0x829F0D94;
	sub_82508A18(ctx, base);
	// 829F0D94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F0D98: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F0D9C: 388B675C  addi r4, r11, 0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + 26460;
	// 829F0DA0: 38A008FA  li r5, 0x8fa
	ctx.r[5].s64 = 2298;
	// 829F0DA4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F0DA8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F0DAC: 4846623D  bl 0x82e56fe8
	ctx.lr = 0x829F0DB0;
	sub_82E56FE8(ctx, base);
	// 829F0DB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0DB4: 48400EDD  bl 0x82df1c90
	ctx.lr = 0x829F0DB8;
	sub_82DF1C90(ctx, base);
	// 829F0DB8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F0DBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F0DC0: 419A0008  beq cr6, 0x829f0dc8
	if ctx.cr[6].eq {
	pc = 0x829F0DC8; continue 'dispatch;
	}
	// 829F0DC4: 4B8CFACD  bl 0x822c0890
	ctx.lr = 0x829F0DC8;
	sub_822C0890(ctx, base);
	// 829F0DC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F0DCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F0DD0: 419A0008  beq cr6, 0x829f0dd8
	if ctx.cr[6].eq {
	pc = 0x829F0DD8; continue 'dispatch;
	}
	// 829F0DD4: 4B8CFABD  bl 0x822c0890
	ctx.lr = 0x829F0DD8;
	sub_822C0890(ctx, base);
	// 829F0DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F0DDC: 4BB20D0D  bl 0x82511ae8
	ctx.lr = 0x829F0DE0;
	sub_82511AE8(ctx, base);
	// 829F0DE0: 13C018C7  vcmpequd (lvx128) v30, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F0DE4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F0DE8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F0EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F0EE0 size=392
    let mut pc: u32 = 0x829F0EE0;
    'dispatch: loop {
        match pc {
            0x829F0EE0 => {
    //   block [0x829F0EE0..0x829F1068)
	// 829F0EE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F0EE4: 487B7285  bl 0x831a8168
	ctx.lr = 0x829F0EE8;
	sub_831A8130(ctx, base);
	// 829F0EE8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 829F0EEC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F0EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F0EF4: 897F023C  lbz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 829F0EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0EFC: 409A0010  bne cr6, 0x829f0f0c
	if !ctx.cr[6].eq {
	pc = 0x829F0F0C; continue 'dispatch;
	}
	// 829F0F00: A17F021A  lhz r11, 0x21a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(538 as u32) ) } as u64;
	// 829F0F04: 616B1000  ori r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 4096;
	// 829F0F08: B17F021A  sth r11, 0x21a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829F0F0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F0F10: C01F0240  lfs f0, 0x240(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(576 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F0F14: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F0F18: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F0F1C: 41990140  bgt cr6, 0x829f105c
	if ctx.cr[6].gt {
	pc = 0x829F105C; continue 'dispatch;
	}
	// 829F0F20: A13F0218  lhz r9, 0x218(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 829F0F24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F0F28: 397F021C  addi r11, r31, 0x21c
	ctx.r[11].s64 = ctx.r[31].s64 + 540;
	// 829F0F2C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 829F0F30: 7FAAF030  slw r10, r29, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[29].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 829F0F34: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 829F0F38: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 829F0F3C: 419A0024  beq cr6, 0x829f0f60
	if ctx.cr[6].eq {
	pc = 0x829F0F60; continue 'dispatch;
	}
	// 829F0F40: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0F44: A15F021A  lhz r10, 0x21a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(538 as u32) ) } as u64;
	// 829F0F48: 7D075038  and r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 829F0F4C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829F0F50: 409A0010  bne cr6, 0x829f0f60
	if !ctx.cr[6].eq {
	pc = 0x829F0F60; continue 'dispatch;
	}
	// 829F0F54: A10B0010  lhz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F0F58: 7D0A5039  and. r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829F0F5C: 41820018  beq 0x829f0f74
	if ctx.cr[0].eq {
	pc = 0x829F0F74; continue 'dispatch;
	}
	// 829F0F60: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 829F0F64: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 829F0F68: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 829F0F6C: 4198FFC4  blt cr6, 0x829f0f30
	if ctx.cr[6].lt {
	pc = 0x829F0F30; continue 'dispatch;
	}
	// 829F0F70: 480000EC  b 0x829f105c
	pc = 0x829F105C; continue 'dispatch;
	// 829F0F74: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 829F0F78: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F0F7C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F0F80: 396BD6DC  addi r11, r11, -0x2924
	ctx.r[11].s64 = ctx.r[11].s64 + -10532;
	// 829F0F84: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F0F88: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F0F8C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F0F90: 4BFFEFF9  bl 0x829eff88
	ctx.lr = 0x829F0F94;
	sub_829EFF88(ctx, base);
	// 829F0F94: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0F98: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F0F9C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F0FA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0FA4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F0FA8: 419A0024  beq cr6, 0x829f0fcc
	if ctx.cr[6].eq {
	pc = 0x829F0FCC; continue 'dispatch;
	}
	// 829F0FAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F0FB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F0FB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0FB8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F0FBC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F0FC0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F0FC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F0FC8: 4082FFE8  bne 0x829f0fb0
	if !ctx.cr[0].eq {
	pc = 0x829F0FB0; continue 'dispatch;
	}
	// 829F0FCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F0FD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F0FD4: 4BB1E4F5  bl 0x8250f4c8
	ctx.lr = 0x829F0FD8;
	sub_8250F4C8(ctx, base);
	// 829F0FD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F0FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F0FE0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F0FE4: 409A0008  bne cr6, 0x829f0fec
	if !ctx.cr[6].eq {
	pc = 0x829F0FEC; continue 'dispatch;
	}
	// 829F0FE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F0FEC: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 829F0FF0: 4BB17629  bl 0x82508618
	ctx.lr = 0x829F0FF4;
	sub_82508618(ctx, base);
	// 829F0FF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F0FF8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F0FFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F1000: 388B675C  addi r4, r11, 0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + 26460;
	// 829F1004: 38A00990  li r5, 0x990
	ctx.r[5].s64 = 2448;
	// 829F1008: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F100C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 829F1010: 48467A31  bl 0x82e58a40
	ctx.lr = 0x829F1014;
	sub_82E58A40(ctx, base);
	// 829F1014: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F1018: 48400C79  bl 0x82df1c90
	ctx.lr = 0x829F101C;
	sub_82DF1C90(ctx, base);
	// 829F101C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F1020: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1024: 419A0008  beq cr6, 0x829f102c
	if ctx.cr[6].eq {
	pc = 0x829F102C; continue 'dispatch;
	}
	// 829F1028: 4B8CF869  bl 0x822c0890
	ctx.lr = 0x829F102C;
	sub_822C0890(ctx, base);
	// 829F102C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F1030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1034: 419A0008  beq cr6, 0x829f103c
	if ctx.cr[6].eq {
	pc = 0x829F103C; continue 'dispatch;
	}
	// 829F1038: 4B8CF859  bl 0x822c0890
	ctx.lr = 0x829F103C;
	sub_822C0890(ctx, base);
	// 829F103C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F1040: A17F0218  lhz r11, 0x218(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 829F1044: 7FAAF030  slw r10, r29, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[29].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 829F1048: 9BDF023C  stb r30, 0x23c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[30].u8 ) };
	// 829F104C: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 829F1050: C0096534  lfs f0, 0x6534(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F1054: D01F0240  stfs f0, 0x240(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 829F1058: B17F0218  sth r11, 0x218(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u16 ) };
	// 829F105C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829F1060: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 829F1064: 487B7154  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1068 size=284
    let mut pc: u32 = 0x829F1068;
    'dispatch: loop {
        match pc {
            0x829F1068 => {
    //   block [0x829F1068..0x829F1184)
	// 829F1068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F106C: 487B7101  bl 0x831a816c
	ctx.lr = 0x829F1070;
	sub_831A8130(ctx, base);
	// 829F1070: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1078: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F107C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1080: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F1084: 4BB1E445  bl 0x8250f4c8
	ctx.lr = 0x829F1088;
	sub_8250F4C8(ctx, base);
	// 829F1088: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F108C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1090: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F1094: 409A0008  bne cr6, 0x829f109c
	if !ctx.cr[6].eq {
	pc = 0x829F109C; continue 'dispatch;
	}
	// 829F1098: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F109C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F10A0: 4BB17979  bl 0x82508a18
	ctx.lr = 0x829F10A4;
	sub_82508A18(ctx, base);
	// 829F10A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F10A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F10AC: 4861707D  bl 0x83008128
	ctx.lr = 0x829F10B0;
	sub_83008128(ctx, base);
	// 829F10B0: 7D7D1850  subf r11, r29, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[29].s64;
	// 829F10B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F10B8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829F10BC: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F10C0: 48400BD1  bl 0x82df1c90
	ctx.lr = 0x829F10C4;
	sub_82DF1C90(ctx, base);
	// 829F10C4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F10C8: 408200B4  bne 0x829f117c
	if !ctx.cr[0].eq {
	pc = 0x829F117C; continue 'dispatch;
	}
	// 829F10CC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829F10D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F10D4: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829F10D8: 4BB20A11  bl 0x82511ae8
	ctx.lr = 0x829F10DC;
	sub_82511AE8(ctx, base);
	// 829F10DC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829F10E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829F10E4: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829F10E8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F10EC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829F10F0: 4BE1ADA1  bl 0x8280be90
	ctx.lr = 0x829F10F4;
	sub_8280BE90(ctx, base);
	// 829F10F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F10F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F10FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1104: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F1108: 419A0024  beq cr6, 0x829f112c
	if ctx.cr[6].eq {
	pc = 0x829F112C; continue 'dispatch;
	}
	// 829F110C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F1110: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F1114: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1118: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F111C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F1120: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F1124: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1128: 4082FFE8  bne 0x829f1110
	if !ctx.cr[0].eq {
	pc = 0x829F1110; continue 'dispatch;
	}
	// 829F112C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1130: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829F1134: 48616FF5  bl 0x83008128
	ctx.lr = 0x829F1138;
	sub_83008128(ctx, base);
	// 829F1138: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F113C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1140: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F1144: 388A675C  addi r4, r10, 0x675c
	ctx.r[4].s64 = ctx.r[10].s64 + 26460;
	// 829F1148: 38A00B2B  li r5, 0xb2b
	ctx.r[5].s64 = 2859;
	// 829F114C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F1150: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F1154: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829F1158: 484678E9  bl 0x82e58a40
	ctx.lr = 0x829F115C;
	sub_82E58A40(ctx, base);
	// 829F115C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F1160: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1164: 419A0008  beq cr6, 0x829f116c
	if ctx.cr[6].eq {
	pc = 0x829F116C; continue 'dispatch;
	}
	// 829F1168: 4B8CF729  bl 0x822c0890
	ctx.lr = 0x829F116C;
	sub_822C0890(ctx, base);
	// 829F116C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F1170: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1174: 419A0008  beq cr6, 0x829f117c
	if ctx.cr[6].eq {
	pc = 0x829F117C; continue 'dispatch;
	}
	// 829F1178: 4B8CF719  bl 0x822c0890
	ctx.lr = 0x829F117C;
	sub_822C0890(ctx, base);
	// 829F117C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F1180: 487B703C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1188 size=284
    let mut pc: u32 = 0x829F1188;
    'dispatch: loop {
        match pc {
            0x829F1188 => {
    //   block [0x829F1188..0x829F12A4)
	// 829F1188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F118C: 487B6FE1  bl 0x831a816c
	ctx.lr = 0x829F1190;
	sub_831A8130(ctx, base);
	// 829F1190: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1198: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F119C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F11A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F11A4: 4BB1E325  bl 0x8250f4c8
	ctx.lr = 0x829F11A8;
	sub_8250F4C8(ctx, base);
	// 829F11A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F11AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F11B0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F11B4: 409A0008  bne cr6, 0x829f11bc
	if !ctx.cr[6].eq {
	pc = 0x829F11BC; continue 'dispatch;
	}
	// 829F11B8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F11BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F11C0: 4BB17859  bl 0x82508a18
	ctx.lr = 0x829F11C4;
	sub_82508A18(ctx, base);
	// 829F11C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F11C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F11CC: 48616F5D  bl 0x83008128
	ctx.lr = 0x829F11D0;
	sub_83008128(ctx, base);
	// 829F11D0: 7D7D1850  subf r11, r29, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[29].s64;
	// 829F11D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F11D8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 829F11DC: 557DDFFE  rlwinm r29, r11, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 829F11E0: 48400AB1  bl 0x82df1c90
	ctx.lr = 0x829F11E4;
	sub_82DF1C90(ctx, base);
	// 829F11E4: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F11E8: 408200B4  bne 0x829f129c
	if !ctx.cr[0].eq {
	pc = 0x829F129C; continue 'dispatch;
	}
	// 829F11EC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829F11F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F11F4: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 829F11F8: 4BB208F1  bl 0x82511ae8
	ctx.lr = 0x829F11FC;
	sub_82511AE8(ctx, base);
	// 829F11FC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 829F1200: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829F1204: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 829F1208: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F120C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 829F1210: 4BE1AC81  bl 0x8280be90
	ctx.lr = 0x829F1214;
	sub_8280BE90(ctx, base);
	// 829F1214: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1218: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F121C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1224: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F1228: 419A0024  beq cr6, 0x829f124c
	if ctx.cr[6].eq {
	pc = 0x829F124C; continue 'dispatch;
	}
	// 829F122C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F1230: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F1234: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1238: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F123C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F1240: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F1244: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1248: 4082FFE8  bne 0x829f1230
	if !ctx.cr[0].eq {
	pc = 0x829F1230; continue 'dispatch;
	}
	// 829F124C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1250: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 829F1254: 48616ED5  bl 0x83008128
	ctx.lr = 0x829F1258;
	sub_83008128(ctx, base);
	// 829F1258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F125C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1260: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F1264: 388A675C  addi r4, r10, 0x675c
	ctx.r[4].s64 = ctx.r[10].s64 + 26460;
	// 829F1268: 38A00B37  li r5, 0xb37
	ctx.r[5].s64 = 2871;
	// 829F126C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F1270: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F1274: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829F1278: 484677C9  bl 0x82e58a40
	ctx.lr = 0x829F127C;
	sub_82E58A40(ctx, base);
	// 829F127C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F1280: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1284: 419A0008  beq cr6, 0x829f128c
	if ctx.cr[6].eq {
	pc = 0x829F128C; continue 'dispatch;
	}
	// 829F1288: 4B8CF609  bl 0x822c0890
	ctx.lr = 0x829F128C;
	sub_822C0890(ctx, base);
	// 829F128C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F1290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1294: 419A0008  beq cr6, 0x829f129c
	if ctx.cr[6].eq {
	pc = 0x829F129C; continue 'dispatch;
	}
	// 829F1298: 4B8CF5F9  bl 0x822c0890
	ctx.lr = 0x829F129C;
	sub_822C0890(ctx, base);
	// 829F129C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F12A0: 487B6F1C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F12A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F12A8 size=196
    let mut pc: u32 = 0x829F12A8;
    'dispatch: loop {
        match pc {
            0x829F12A8 => {
    //   block [0x829F12A8..0x829F136C)
	// 829F12A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F12AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F12B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F12B4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F12B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F12BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F12C0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 829F12C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F12C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F12CC: 4BFFEB35  bl 0x829efe00
	ctx.lr = 0x829F12D0;
	sub_829EFE00(ctx, base);
	// 829F12D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F12D4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F12D8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F12DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F12E0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F12E4: 419A0024  beq cr6, 0x829f1308
	if ctx.cr[6].eq {
	pc = 0x829F1308; continue 'dispatch;
	}
	// 829F12E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F12EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F12F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F12F4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F12F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F12FC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F1300: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1304: 4082FFE8  bne 0x829f12ec
	if !ctx.cr[0].eq {
	pc = 0x829F12EC; continue 'dispatch;
	}
	// 829F1308: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F130C: 80DF0300  lwz r6, 0x300(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(768 as u32) ) } as u64;
	// 829F1310: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1314: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 829F1318: 388A675C  addi r4, r10, 0x675c
	ctx.r[4].s64 = ctx.r[10].s64 + 26460;
	// 829F131C: 38A00B3E  li r5, 0xb3e
	ctx.r[5].s64 = 2878;
	// 829F1320: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F1324: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F1328: 48467719  bl 0x82e58a40
	ctx.lr = 0x829F132C;
	sub_82E58A40(ctx, base);
	// 829F132C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F1330: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1334: 419A0008  beq cr6, 0x829f133c
	if ctx.cr[6].eq {
	pc = 0x829F133C; continue 'dispatch;
	}
	// 829F1338: 4B8CF559  bl 0x822c0890
	ctx.lr = 0x829F133C;
	sub_822C0890(ctx, base);
	// 829F133C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F1340: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1344: 419A0008  beq cr6, 0x829f134c
	if ctx.cr[6].eq {
	pc = 0x829F134C; continue 'dispatch;
	}
	// 829F1348: 4B8CF549  bl 0x822c0890
	ctx.lr = 0x829F134C;
	sub_822C0890(ctx, base);
	// 829F134C: A17F021A  lhz r11, 0x21a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(538 as u32) ) } as u64;
	// 829F1350: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829F1354: B17F021A  sth r11, 0x21a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829F1358: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F135C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1364: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1370 size=332
    let mut pc: u32 = 0x829F1370;
    'dispatch: loop {
        match pc {
            0x829F1370 => {
    //   block [0x829F1370..0x829F14BC)
	// 829F1370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1378: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F137C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1380: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1388: 38840040  addi r4, r4, 0x40
	ctx.r[4].s64 = ctx.r[4].s64 + 64;
	// 829F138C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F1390: 4848AC49  bl 0x82e7bfd8
	ctx.lr = 0x829F1394;
	sub_82E7BFD8(ctx, base);
	// 829F1394: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 829F1398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F139C: 388B5558  addi r4, r11, 0x5558
	ctx.r[4].s64 = ctx.r[11].s64 + 21848;
	// 829F13A0: 48402669  bl 0x82df3a08
	ctx.lr = 0x829F13A4;
	sub_82DF3A08(ctx, base);
	// 829F13A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F13A8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F13AC: 4BB1E11D  bl 0x8250f4c8
	ctx.lr = 0x829F13B0;
	sub_8250F4C8(ctx, base);
	// 829F13B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F13B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F13B8: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829F13BC: 409A0008  bne cr6, 0x829f13c4
	if !ctx.cr[6].eq {
	pc = 0x829F13C4; continue 'dispatch;
	}
	// 829F13C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F13C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F13C8: 4BB19589  bl 0x8250a950
	ctx.lr = 0x829F13CC;
	sub_8250A950(ctx, base);
	// 829F13CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F13D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F13D4: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F13D8: 409A0008  bne cr6, 0x829f13e0
	if !ctx.cr[6].eq {
	pc = 0x829F13E0; continue 'dispatch;
	}
	// 829F13DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F13E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F13E4: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829F13E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F13EC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 829F13F0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F13F4: 4BDE375D  bl 0x827d4b50
	ctx.lr = 0x829F13F8;
	sub_827D4B50(ctx, base);
	// 829F13F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F13FC: 48400895  bl 0x82df1c90
	ctx.lr = 0x829F1400;
	sub_82DF1C90(ctx, base);
	// 829F1400: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F1404: 4840088D  bl 0x82df1c90
	ctx.lr = 0x829F1408;
	sub_82DF1C90(ctx, base);
	// 829F1408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F140C: 4840201D  bl 0x82df3428
	ctx.lr = 0x829F1410;
	sub_82DF3428(ctx, base);
	// 829F1410: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F1414: 4BFFEC25  bl 0x829f0038
	ctx.lr = 0x829F1418;
	sub_829F0038(ctx, base);
	// 829F1418: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F141C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F1420: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1428: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F142C: 419A0024  beq cr6, 0x829f1450
	if ctx.cr[6].eq {
	pc = 0x829F1450; continue 'dispatch;
	}
	// 829F1430: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F1434: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F1438: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F143C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F1440: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F1444: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F1448: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F144C: 4082FFE8  bne 0x829f1434
	if !ctx.cr[0].eq {
	pc = 0x829F1434; continue 'dispatch;
	}
	// 829F1450: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 829F1454: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829F1458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F145C: 48617B5D  bl 0x83008fb8
	ctx.lr = 0x829F1460;
	sub_83008FB8(ctx, base);
	// 829F1460: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F1464: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1468: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F146C: 388A675C  addi r4, r10, 0x675c
	ctx.r[4].s64 = ctx.r[10].s64 + 26460;
	// 829F1470: 38A00B52  li r5, 0xb52
	ctx.r[5].s64 = 2898;
	// 829F1474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1478: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F147C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829F1480: 484675C1  bl 0x82e58a40
	ctx.lr = 0x829F1484;
	sub_82E58A40(ctx, base);
	// 829F1484: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F1488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F148C: 419A0008  beq cr6, 0x829f1494
	if ctx.cr[6].eq {
	pc = 0x829F1494; continue 'dispatch;
	}
	// 829F1490: 4B8CF401  bl 0x822c0890
	ctx.lr = 0x829F1494;
	sub_822C0890(ctx, base);
	// 829F1494: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F1498: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F149C: 419A0008  beq cr6, 0x829f14a4
	if ctx.cr[6].eq {
	pc = 0x829F14A4; continue 'dispatch;
	}
	// 829F14A0: 4B8CF3F1  bl 0x822c0890
	ctx.lr = 0x829F14A4;
	sub_822C0890(ctx, base);
	// 829F14A4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829F14A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F14AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F14B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F14B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F14B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F14C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F14C0 size=340
    let mut pc: u32 = 0x829F14C0;
    'dispatch: loop {
        match pc {
            0x829F14C0 => {
    //   block [0x829F14C0..0x829F1614)
	// 829F14C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F14C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F14C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F14CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F14D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F14D4: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F14D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F14DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 829F14E0: 4098009C  bge cr6, 0x829f157c
	if !ctx.cr[6].lt {
	pc = 0x829F157C; continue 'dispatch;
	}
	// 829F14E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 829F14E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F14EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F14F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F14F4: 4BFFEBCD  bl 0x829f00c0
	ctx.lr = 0x829F14F8;
	sub_829F00C0(ctx, base);
	// 829F14F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F14FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F1500: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1508: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 829F150C: 419A0024  beq cr6, 0x829f1530
	if ctx.cr[6].eq {
	pc = 0x829F1530; continue 'dispatch;
	}
	// 829F1510: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F1514: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F1518: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F151C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F1520: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F1524: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F1528: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F152C: 4082FFE8  bne 0x829f1514
	if !ctx.cr[0].eq {
	pc = 0x829F1514; continue 'dispatch;
	}
	// 829F1530: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 829F1534: 3BC10058  addi r30, r1, 0x58
	ctx.r[30].s64 = ctx.r[1].s64 + 88;
	// 829F1538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F153C: 48617A7D  bl 0x83008fb8
	ctx.lr = 0x829F1540;
	sub_83008FB8(ctx, base);
	// 829F1540: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F1544: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1548: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F154C: 388A675C  addi r4, r10, 0x675c
	ctx.r[4].s64 = ctx.r[10].s64 + 26460;
	// 829F1550: 38A00B5A  li r5, 0xb5a
	ctx.r[5].s64 = 2906;
	// 829F1554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1558: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F155C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 829F1560: 484674E1  bl 0x82e58a40
	ctx.lr = 0x829F1564;
	sub_82E58A40(ctx, base);
	// 829F1564: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F1568: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F156C: 419A0008  beq cr6, 0x829f1574
	if ctx.cr[6].eq {
	pc = 0x829F1574; continue 'dispatch;
	}
	// 829F1570: 4B8CF321  bl 0x822c0890
	ctx.lr = 0x829F1574;
	sub_822C0890(ctx, base);
	// 829F1574: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F1578: 48000078  b 0x829f15f0
	pc = 0x829F15F0; continue 'dispatch;
	// 829F157C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F1580: C1BF0458  lfs f13, 0x458(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F1584: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F1588: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 829F158C: 41990070  bgt cr6, 0x829f15fc
	if ctx.cr[6].gt {
	pc = 0x829F15FC; continue 'dispatch;
	}
	// 829F1590: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1594: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 829F1598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F159C: 38AA5814  addi r5, r10, 0x5814
	ctx.r[5].s64 = ctx.r[10].s64 + 22548;
	// 829F15A0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 829F15A4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829F15A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F15AC: 4E800421  bctrl
	ctx.lr = 0x829F15B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F15B0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F15B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F15B8: 419A0008  beq cr6, 0x829f15c0
	if ctx.cr[6].eq {
	pc = 0x829F15C0; continue 'dispatch;
	}
	// 829F15BC: 4B8CF2D5  bl 0x822c0890
	ctx.lr = 0x829F15C0;
	sub_822C0890(ctx, base);
	// 829F15C0: 897F0454  lbz r11, 0x454(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(1108 as u32) ) } as u64;
	// 829F15C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F15C8: 41820034  beq 0x829f15fc
	if ctx.cr[0].eq {
	pc = 0x829F15FC; continue 'dispatch;
	}
	// 829F15CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F15D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F15D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F15D8: 38AA6748  addi r5, r10, 0x6748
	ctx.r[5].s64 = ctx.r[10].s64 + 26440;
	// 829F15DC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F15E0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829F15E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F15E8: 4E800421  bctrl
	ctx.lr = 0x829F15EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F15EC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F15F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F15F4: 419A0008  beq cr6, 0x829f15fc
	if ctx.cr[6].eq {
	pc = 0x829F15FC; continue 'dispatch;
	}
	// 829F15F8: 4B8CF299  bl 0x822c0890
	ctx.lr = 0x829F15FC;
	sub_822C0890(ctx, base);
	// 829F15FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F1600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1608: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F160C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1618 size=68
    let mut pc: u32 = 0x829F1618;
    'dispatch: loop {
        match pc {
            0x829F1618 => {
    //   block [0x829F1618..0x829F165C)
	// 829F1618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F161C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1620: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1624: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1628: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F162C: A17F021A  lhz r11, 0x21a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(538 as u32) ) } as u64;
	// 829F1630: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 829F1634: B17F021A  sth r11, 0x21a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829F1638: 4BFFF8A9  bl 0x829f0ee0
	ctx.lr = 0x829F163C;
	sub_829F0EE0(ctx, base);
	// 829F163C: A17F021A  lhz r11, 0x21a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(538 as u32) ) } as u64;
	// 829F1640: 716BFFDF  andi. r11, r11, 0xffdf
	ctx.r[11].u64 = ctx.r[11].u64 & 65503;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1644: B17F021A  sth r11, 0x21a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829F1648: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F164C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1650: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1654: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1660 size=356
    let mut pc: u32 = 0x829F1660;
    'dispatch: loop {
        match pc {
            0x829F1660 => {
    //   block [0x829F1660..0x829F17C4)
	// 829F1660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F166C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1670: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 829F1674: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1678: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F167C: 897E0455  lbz r11, 0x455(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1109 as u32) ) } as u64;
	// 829F1680: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F1684: 40820124  bne 0x829f17a8
	if !ctx.cr[0].eq {
	pc = 0x829F17A8; continue 'dispatch;
	}
	// 829F1688: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F168C: C01E0240  lfs f0, 0x240(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(576 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F1690: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F1694: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 829F1698: 41990110  bgt cr6, 0x829f17a8
	if ctx.cr[6].gt {
	pc = 0x829F17A8; continue 'dispatch;
	}
	// 829F169C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 829F16A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F16A4: 9BFE0455  stb r31, 0x455(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1109 as u32), ctx.r[31].u8 ) };
	// 829F16A8: 4BACA489  bl 0x824bbb30
	ctx.lr = 0x829F16AC;
	sub_824BBB30(ctx, base);
	// 829F16AC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F16B0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 829F16B4: D3E10088  stfs f31, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829F16B8: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 829F16BC: 9BE1008C  stb r31, 0x8c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u8 ) };
	// 829F16C0: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 829F16C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F16C8: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 829F16CC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829F16D0: C00BA1C4  lfs f0, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F16D4: 388A6478  addi r4, r10, 0x6478
	ctx.r[4].s64 = ctx.r[10].s64 + 25720;
	// 829F16D8: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829F16DC: 4840219D  bl 0x82df3878
	ctx.lr = 0x829F16E0;
	sub_82DF3878(ctx, base);
	// 829F16E0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 829F16E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F16E8: 4BB35C89  bl 0x82527370
	ctx.lr = 0x829F16EC;
	sub_82527370(ctx, base);
	// 829F16EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F16F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F16F4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F16F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F16FC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F1700: 419A0024  beq cr6, 0x829f1724
	if ctx.cr[6].eq {
	pc = 0x829F1724; continue 'dispatch;
	}
	// 829F1704: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F1708: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F170C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1710: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F1714: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F1718: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F171C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1720: 4082FFE8  bne 0x829f1708
	if !ctx.cr[0].eq {
	pc = 0x829F1708; continue 'dispatch;
	}
	// 829F1724: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F1728: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F172C: 4BB1DD9D  bl 0x8250f4c8
	ctx.lr = 0x829F1730;
	sub_8250F4C8(ctx, base);
	// 829F1730: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1738: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 829F173C: 409A0008  bne cr6, 0x829f1744
	if !ctx.cr[6].eq {
	pc = 0x829F1744; continue 'dispatch;
	}
	// 829F1740: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F1744: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 829F1748: 4BB16E51  bl 0x82508598
	ctx.lr = 0x829F174C;
	sub_82508598(ctx, base);
	// 829F174C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F1750: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F1754: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 829F1758: 388B675C  addi r4, r11, 0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + 26460;
	// 829F175C: 38A00C36  li r5, 0xc36
	ctx.r[5].s64 = 3126;
	// 829F1760: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 829F1764: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 829F1768: 484672D9  bl 0x82e58a40
	ctx.lr = 0x829F176C;
	sub_82E58A40(ctx, base);
	// 829F176C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F1770: 48400521  bl 0x82df1c90
	ctx.lr = 0x829F1774;
	sub_82DF1C90(ctx, base);
	// 829F1774: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F1778: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F177C: 419A0008  beq cr6, 0x829f1784
	if ctx.cr[6].eq {
	pc = 0x829F1784; continue 'dispatch;
	}
	// 829F1780: 4B8CF111  bl 0x822c0890
	ctx.lr = 0x829F1784;
	sub_822C0890(ctx, base);
	// 829F1784: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F1788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F178C: 419A0008  beq cr6, 0x829f1794
	if ctx.cr[6].eq {
	pc = 0x829F1794; continue 'dispatch;
	}
	// 829F1790: 4B8CF101  bl 0x822c0890
	ctx.lr = 0x829F1794;
	sub_822C0890(ctx, base);
	// 829F1794: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 829F1798: 48401C91  bl 0x82df3428
	ctx.lr = 0x829F179C;
	sub_82DF3428(ctx, base);
	// 829F179C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F17A0: C00B6534  lfs f0, 0x6534(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F17A4: D01E0240  stfs f0, 0x240(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 829F17A8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 829F17AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F17B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F17B4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 829F17B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F17BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F17C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F17C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F17C8 size=76
    let mut pc: u32 = 0x829F17C8;
    'dispatch: loop {
        match pc {
            0x829F17C8 => {
    //   block [0x829F17C8..0x829F1814)
	// 829F17C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F17CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F17D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F17D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F17D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F17DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F17E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F17E4: 4BFFE535  bl 0x829efd18
	ctx.lr = 0x829F17E8;
	sub_829EFD18(ctx, base);
	// 829F17E8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F17EC: 4182000C  beq 0x829f17f8
	if ctx.cr[0].eq {
	pc = 0x829F17F8; continue 'dispatch;
	}
	// 829F17F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F17F4: 48400BE5  bl 0x82df23d8
	ctx.lr = 0x829F17F8;
	sub_82DF23D8(ctx, base);
	// 829F17F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F17FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F1800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F1804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F1808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F180C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F1810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F1818 size=204
    let mut pc: u32 = 0x829F1818;
    'dispatch: loop {
        match pc {
            0x829F1818 => {
    //   block [0x829F1818..0x829F18E4)
	// 829F1818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F181C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F1820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F1824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F1828: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F182C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1830: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F1834: 4BB20835  bl 0x82512068
	ctx.lr = 0x829F1838;
	sub_82512068(ctx, base);
	// 829F1838: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 829F183C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F1840: 4BB16E41  bl 0x82508680
	ctx.lr = 0x829F1844;
	sub_82508680(ctx, base);
	// 829F1844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F1848: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 829F184C: 4BF1C345  bl 0x8290db90
	ctx.lr = 0x829F1850;
	sub_8290DB90(ctx, base);
	// 829F1850: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1854: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 829F1858: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F185C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1860: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F1864: 419A0024  beq cr6, 0x829f1888
	if ctx.cr[6].eq {
	pc = 0x829F1888; continue 'dispatch;
	}
	// 829F1868: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F186C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F1870: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1874: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F1878: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F187C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F1880: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F1884: 4082FFE8  bne 0x829f186c
	if !ctx.cr[0].eq {
	pc = 0x829F186C; continue 'dispatch;
	}
	// 829F1888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F188C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1890: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 829F1894: 388A675C  addi r4, r10, 0x675c
	ctx.r[4].s64 = ctx.r[10].s64 + 26460;
	// 829F1898: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829F189C: 38A00D0D  li r5, 0xd0d
	ctx.r[5].s64 = 3341;
	// 829F18A0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F18A4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 829F18A8: 48467199  bl 0x82e58a40
	ctx.lr = 0x829F18AC;
	sub_82E58A40(ctx, base);
	// 829F18AC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F18B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F18B4: 419A0008  beq cr6, 0x829f18bc
	if ctx.cr[6].eq {
	pc = 0x829F18BC; continue 'dispatch;
	}
	// 829F18B8: 4B8CEFD9  bl 0x822c0890
	ctx.lr = 0x829F18BC;
	sub_822C0890(ctx, base);
	// 829F18BC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 829F18C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F18C4: 419A0008  beq cr6, 0x829f18cc
	if ctx.cr[6].eq {
	pc = 0x829F18CC; continue 'dispatch;
	}
	// 829F18C8: 4B8CEFC9  bl 0x822c0890
	ctx.lr = 0x829F18CC;
	sub_822C0890(ctx, base);
	// 829F18CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F18D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F18D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F18D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F18DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F18E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F18E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F18E8 size=1316
    let mut pc: u32 = 0x829F18E8;
    'dispatch: loop {
        match pc {
            0x829F18E8 => {
    //   block [0x829F18E8..0x829F1E0C)
	// 829F18E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F18EC: 487B6875  bl 0x831a8160
	ctx.lr = 0x829F18F0;
	sub_831A8130(ctx, base);
	// 829F18F0: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 829F18F4: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 829F18F8: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F18FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F1900: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 829F1904: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 829F1908: A97F00F0  lha r11, 0xf0(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as i16) as i64;
	// 829F190C: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 829F1910: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F1914: 7D4A0735  extsh. r10, r10
	ctx.r[10].s64 = ctx.r[10].s16 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829F1918: B15F00F0  sth r10, 0xf0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u16 ) };
	// 829F191C: 41810060  bgt 0x829f197c
	if ctx.cr[0].gt {
	pc = 0x829F197C; continue 'dispatch;
	}
	// 829F1920: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829F1924: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1928: B15F00F0  sth r10, 0xf0(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u16 ) };
	// 829F192C: 409900E8  ble cr6, 0x829f1a14
	if !ctx.cr[6].gt {
	pc = 0x829F1A14; continue 'dispatch;
	}
	// 829F1930: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1934: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F1938: 9B7F00FC  stb r27, 0xfc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[27].u8 ) };
	// 829F193C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1940: 38AA6844  addi r5, r10, 0x6844
	ctx.r[5].s64 = ctx.r[10].s64 + 26692;
	// 829F1944: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 829F1948: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829F194C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F1950: 4E800421  bctrl
	ctx.lr = 0x829F1954;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F1954: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 829F1958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F195C: 419A0008  beq cr6, 0x829f1964
	if ctx.cr[6].eq {
	pc = 0x829F1964; continue 'dispatch;
	}
	// 829F1960: 4B8CEF31  bl 0x822c0890
	ctx.lr = 0x829F1964;
	sub_822C0890(ctx, base);
	// 829F1964: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F1968: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 829F196C: 4BA9D9DD  bl 0x8248f348
	ctx.lr = 0x829F1970;
	sub_8248F348(ctx, base);
	// 829F1970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1974: 4BB20315  bl 0x82511c88
	ctx.lr = 0x829F1978;
	sub_82511C88(ctx, base);
	// 829F1978: 4800009C  b 0x829f1a14
	pc = 0x829F1A14; continue 'dispatch;
	// 829F197C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829F1980: 4BAF9109  bl 0x824eaa88
	ctx.lr = 0x829F1984;
	sub_824EAA88(ctx, base);
	// 829F1984: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F1988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F198C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1990: 4BB1DA39  bl 0x8250f3c8
	ctx.lr = 0x829F1994;
	sub_8250F3C8(ctx, base);
	// 829F1994: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F199C: 4BAF9675  bl 0x824eb010
	ctx.lr = 0x829F19A0;
	sub_824EB010(ctx, base);
	// 829F19A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F19A4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829F19A8: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F19AC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 829F19B0: 41980008  blt cr6, 0x829f19b8
	if ctx.cr[6].lt {
	pc = 0x829F19B8; continue 'dispatch;
	}
	// 829F19B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 829F19B8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 829F19BC: 484002D5  bl 0x82df1c90
	ctx.lr = 0x829F19C0;
	sub_82DF1C90(ctx, base);
	// 829F19C0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F19C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F19C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F19CC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829F19D0: 41820020  beq 0x829f19f0
	if ctx.cr[0].eq {
	pc = 0x829F19F0; continue 'dispatch;
	}
	// 829F19D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F19D8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 829F19DC: 38AA6830  addi r5, r10, 0x6830
	ctx.r[5].s64 = ctx.r[10].s64 + 26672;
	// 829F19E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F19E4: 4E800421  bctrl
	ctx.lr = 0x829F19E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F19E8: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 829F19EC: 4800001C  b 0x829f1a08
	pc = 0x829F1A08; continue 'dispatch;
	// 829F19F0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F19F4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 829F19F8: 38AA681C  addi r5, r10, 0x681c
	ctx.r[5].s64 = ctx.r[10].s64 + 26652;
	// 829F19FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F1A00: 4E800421  bctrl
	ctx.lr = 0x829F1A04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F1A04: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 829F1A08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F1A0C: 419A0008  beq cr6, 0x829f1a14
	if ctx.cr[6].eq {
	pc = 0x829F1A14; continue 'dispatch;
	}
	// 829F1A10: 4B8CEE81  bl 0x822c0890
	ctx.lr = 0x829F1A14;
	sub_822C0890(ctx, base);
	// 829F1A14: 389C0040  addi r4, r28, 0x40
	ctx.r[4].s64 = ctx.r[28].s64 + 64;
	// 829F1A18: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 829F1A1C: 4848A5BD  bl 0x82e7bfd8
	ctx.lr = 0x829F1A20;
	sub_82E7BFD8(ctx, base);
	// 829F1A20: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 829F1A24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1A28: 388B0454  addi r4, r11, 0x454
	ctx.r[4].s64 = ctx.r[11].s64 + 1108;
	// 829F1A2C: 48401FDD  bl 0x82df3a08
	ctx.lr = 0x829F1A30;
	sub_82DF3A08(ctx, base);
	// 829F1A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1A34: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829F1A38: 4BB1DA91  bl 0x8250f4c8
	ctx.lr = 0x829F1A3C;
	sub_8250F4C8(ctx, base);
	// 829F1A3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1A44: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829F1A48: 409A0008  bne cr6, 0x829f1a50
	if !ctx.cr[6].eq {
	pc = 0x829F1A50; continue 'dispatch;
	}
	// 829F1A4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F1A50: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829F1A54: 4BB18EFD  bl 0x8250a950
	ctx.lr = 0x829F1A58;
	sub_8250A950(ctx, base);
	// 829F1A58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F1A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F1A60: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F1A64: 409A0008  bne cr6, 0x829f1a6c
	if !ctx.cr[6].eq {
	pc = 0x829F1A6C; continue 'dispatch;
	}
	// 829F1A68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 829F1A6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F1A70: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829F1A74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F1A78: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 829F1A7C: C3EB08A8  lfs f31, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F1A80: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F1A84: 4BDE30CD  bl 0x827d4b50
	ctx.lr = 0x829F1A88;
	sub_827D4B50(ctx, base);
	// 829F1A88: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 829F1A8C: 48400205  bl 0x82df1c90
	ctx.lr = 0x829F1A90;
	sub_82DF1C90(ctx, base);
	// 829F1A90: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 829F1A94: 484001FD  bl 0x82df1c90
	ctx.lr = 0x829F1A98;
	sub_82DF1C90(ctx, base);
	// 829F1A98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F1A9C: 4840198D  bl 0x82df3428
	ctx.lr = 0x829F1AA0;
	sub_82DF3428(ctx, base);
	// 829F1AA0: 817F00E4  lwz r11, 0xe4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) } as u64;
	// 829F1AA4: 389F00E4  addi r4, r31, 0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + 228;
	// 829F1AA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F1AAC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F1AB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F1AB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F1AB8: 4E800421  bctrl
	ctx.lr = 0x829F1ABC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F1ABC: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 829F1AC0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F1AC4: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 829F1AC8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F1E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F1E10 size=892
    let mut pc: u32 = 0x829F1E10;
    'dispatch: loop {
        match pc {
            0x829F1E10 => {
    //   block [0x829F1E10..0x829F218C)
	// 829F1E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F1E14: 487B6355  bl 0x831a8168
	ctx.lr = 0x829F1E18;
	sub_831A8130(ctx, base);
	// 829F1E18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F1E1C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 829F1E20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F1E24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F1E28: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F1E2C: 41820038  beq 0x829f1e64
	if ctx.cr[0].eq {
	pc = 0x829F1E64; continue 'dispatch;
	}
	// 829F1E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1E34: 487B7B55  bl 0x831a9988
	ctx.lr = 0x829F1E38;
	sub_831A9988(ctx, base);
	// 829F1E38: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 829F1E3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1E40: 386B2380  addi r3, r11, 0x2380
	ctx.r[3].s64 = ctx.r[11].s64 + 9088;
	// 829F1E44: 487B62B5  bl 0x831a80f8
	ctx.lr = 0x829F1E48;
	sub_831A80F8(ctx, base);
	// 829F1E48: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1E4C: 41820018  beq 0x829f1e64
	if ctx.cr[0].eq {
	pc = 0x829F1E64; continue 'dispatch;
	}
	// 829F1E50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1E54: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1E58: 4BFFD531  bl 0x829ef388
	ctx.lr = 0x829F1E5C;
	sub_829EF388(ctx, base);
	// 829F1E5C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829F1E60: 48000324  b 0x829f2184
	pc = 0x829F2184; continue 'dispatch;
	// 829F1E64: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1E68: 419A030C  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1E70: 487B7B19  bl 0x831a9988
	ctx.lr = 0x829F1E74;
	sub_831A9988(ctx, base);
	// 829F1E74: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 829F1E78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1E7C: 386B7660  addi r3, r11, 0x7660
	ctx.r[3].s64 = ctx.r[11].s64 + 30304;
	// 829F1E80: 487B6279  bl 0x831a80f8
	ctx.lr = 0x829F1E84;
	sub_831A80F8(ctx, base);
	// 829F1E84: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1E88: 41820014  beq 0x829f1e9c
	if ctx.cr[0].eq {
	pc = 0x829F1E9C; continue 'dispatch;
	}
	// 829F1E8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1E90: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1E94: 4BFFF1D5  bl 0x829f1068
	ctx.lr = 0x829F1E98;
	sub_829F1068(ctx, base);
	// 829F1E98: 4BFFFFC4  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1E9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1EA0: 419A02D4  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1EA8: 487B7AE1  bl 0x831a9988
	ctx.lr = 0x829F1EAC;
	sub_831A9988(ctx, base);
	// 829F1EAC: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829F1EB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1EB4: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 829F1EB8: 487B6241  bl 0x831a80f8
	ctx.lr = 0x829F1EBC;
	sub_831A80F8(ctx, base);
	// 829F1EBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1EC0: 41820014  beq 0x829f1ed4
	if ctx.cr[0].eq {
	pc = 0x829F1ED4; continue 'dispatch;
	}
	// 829F1EC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1EC8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1ECC: 4BFFF2BD  bl 0x829f1188
	ctx.lr = 0x829F1ED0;
	sub_829F1188(ctx, base);
	// 829F1ED0: 4BFFFF8C  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1ED4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1ED8: 419A029C  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1EE0: 487B7AA9  bl 0x831a9988
	ctx.lr = 0x829F1EE4;
	sub_831A9988(ctx, base);
	// 829F1EE4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829F1EE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1EEC: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 829F1EF0: 487B6209  bl 0x831a80f8
	ctx.lr = 0x829F1EF4;
	sub_831A80F8(ctx, base);
	// 829F1EF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1EF8: 41820014  beq 0x829f1f0c
	if ctx.cr[0].eq {
	pc = 0x829F1F0C; continue 'dispatch;
	}
	// 829F1EFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1F00: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1F04: 4BC78DED  bl 0x8266acf0
	ctx.lr = 0x829F1F08;
	sub_8266ACF0(ctx, base);
	// 829F1F08: 4BFFFF54  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1F0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1F10: 419A0264  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1F18: 487B7A71  bl 0x831a9988
	ctx.lr = 0x829F1F1C;
	sub_831A9988(ctx, base);
	// 829F1F1C: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829F1F20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1F24: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829F1F28: 487B61D1  bl 0x831a80f8
	ctx.lr = 0x829F1F2C;
	sub_831A80F8(ctx, base);
	// 829F1F2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1F30: 41820014  beq 0x829f1f44
	if ctx.cr[0].eq {
	pc = 0x829F1F44; continue 'dispatch;
	}
	// 829F1F34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1F38: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1F3C: 4BFFF435  bl 0x829f1370
	ctx.lr = 0x829F1F40;
	sub_829F1370(ctx, base);
	// 829F1F40: 4BFFFF1C  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1F44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1F48: 419A022C  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1F50: 487B7A39  bl 0x831a9988
	ctx.lr = 0x829F1F54;
	sub_831A9988(ctx, base);
	// 829F1F54: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F1F58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1F5C: 386BD740  addi r3, r11, -0x28c0
	ctx.r[3].s64 = ctx.r[11].s64 + -10432;
	// 829F1F60: 487B6199  bl 0x831a80f8
	ctx.lr = 0x829F1F64;
	sub_831A80F8(ctx, base);
	// 829F1F64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1F68: 41820014  beq 0x829f1f7c
	if ctx.cr[0].eq {
	pc = 0x829F1F7C; continue 'dispatch;
	}
	// 829F1F6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1F70: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1F74: 4BFFF54D  bl 0x829f14c0
	ctx.lr = 0x829F1F78;
	sub_829F14C0(ctx, base);
	// 829F1F78: 4BFFFEE4  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1F7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1F80: 419A01F4  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1F84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1F88: 487B7A01  bl 0x831a9988
	ctx.lr = 0x829F1F8C;
	sub_831A9988(ctx, base);
	// 829F1F8C: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F1F90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1F94: 386BE00C  addi r3, r11, -0x1ff4
	ctx.r[3].s64 = ctx.r[11].s64 + -8180;
	// 829F1F98: 487B6161  bl 0x831a80f8
	ctx.lr = 0x829F1F9C;
	sub_831A80F8(ctx, base);
	// 829F1F9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1FA0: 41820014  beq 0x829f1fb4
	if ctx.cr[0].eq {
	pc = 0x829F1FB4; continue 'dispatch;
	}
	// 829F1FA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1FA8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1FAC: 4BFFF2FD  bl 0x829f12a8
	ctx.lr = 0x829F1FB0;
	sub_829F12A8(ctx, base);
	// 829F1FB0: 4BFFFEAC  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1FB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1FB8: 419A01BC  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1FBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1FC0: 487B79C9  bl 0x831a9988
	ctx.lr = 0x829F1FC4;
	sub_831A9988(ctx, base);
	// 829F1FC4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F1FC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F1FCC: 386BDFE0  addi r3, r11, -0x2020
	ctx.r[3].s64 = ctx.r[11].s64 + -8224;
	// 829F1FD0: 487B6129  bl 0x831a80f8
	ctx.lr = 0x829F1FD4;
	sub_831A80F8(ctx, base);
	// 829F1FD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F1FD8: 41820014  beq 0x829f1fec
	if ctx.cr[0].eq {
	pc = 0x829F1FEC; continue 'dispatch;
	}
	// 829F1FDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F1FE0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F1FE4: 4BFFD89D  bl 0x829ef880
	ctx.lr = 0x829F1FE8;
	sub_829EF880(ctx, base);
	// 829F1FE8: 4BFFFE74  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F1FEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F1FF0: 419A0184  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F1FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F1FF8: 487B7991  bl 0x831a9988
	ctx.lr = 0x829F1FFC;
	sub_831A9988(ctx, base);
	// 829F1FFC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F2000: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F2004: 386BDFB8  addi r3, r11, -0x2048
	ctx.r[3].s64 = ctx.r[11].s64 + -8264;
	// 829F2008: 487B60F1  bl 0x831a80f8
	ctx.lr = 0x829F200C;
	sub_831A80F8(ctx, base);
	// 829F200C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2010: 41820014  beq 0x829f2024
	if ctx.cr[0].eq {
	pc = 0x829F2024; continue 'dispatch;
	}
	// 829F2014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2018: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F201C: 4BFFBDA5  bl 0x829eddc0
	ctx.lr = 0x829F2020;
	sub_829EDDC0(ctx, base);
	// 829F2020: 4BFFFE3C  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F2024: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F2028: 419A014C  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F202C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2030: 487B7959  bl 0x831a9988
	ctx.lr = 0x829F2034;
	sub_831A9988(ctx, base);
	// 829F2034: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F2038: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F203C: 386BDF8C  addi r3, r11, -0x2074
	ctx.r[3].s64 = ctx.r[11].s64 + -8308;
	// 829F2040: 487B60B9  bl 0x831a80f8
	ctx.lr = 0x829F2044;
	sub_831A80F8(ctx, base);
	// 829F2044: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2048: 41820014  beq 0x829f205c
	if ctx.cr[0].eq {
	pc = 0x829F205C; continue 'dispatch;
	}
	// 829F204C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2050: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F2054: 4BFFF5C5  bl 0x829f1618
	ctx.lr = 0x829F2058;
	sub_829F1618(ctx, base);
	// 829F2058: 4BFFFE04  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F205C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F2060: 419A0114  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F2064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2068: 487B7921  bl 0x831a9988
	ctx.lr = 0x829F206C;
	sub_831A9988(ctx, base);
	// 829F206C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 829F2070: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F2074: 386B2F78  addi r3, r11, 0x2f78
	ctx.r[3].s64 = ctx.r[11].s64 + 12152;
	// 829F2078: 487B6081  bl 0x831a80f8
	ctx.lr = 0x829F207C;
	sub_831A80F8(ctx, base);
	// 829F207C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2080: 41820014  beq 0x829f2094
	if ctx.cr[0].eq {
	pc = 0x829F2094; continue 'dispatch;
	}
	// 829F2084: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2088: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F208C: 4BFFBD55  bl 0x829edde0
	ctx.lr = 0x829F2090;
	sub_829EDDE0(ctx, base);
	// 829F2090: 4BFFFDCC  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F2094: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F2098: 419A00DC  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F209C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F20A0: 487B78E9  bl 0x831a9988
	ctx.lr = 0x829F20A4;
	sub_831A9988(ctx, base);
	// 829F20A4: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F20A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F20AC: 386BD834  addi r3, r11, -0x27cc
	ctx.r[3].s64 = ctx.r[11].s64 + -10188;
	// 829F20B0: 487B6049  bl 0x831a80f8
	ctx.lr = 0x829F20B4;
	sub_831A80F8(ctx, base);
	// 829F20B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F20B8: 41820014  beq 0x829f20cc
	if ctx.cr[0].eq {
	pc = 0x829F20CC; continue 'dispatch;
	}
	// 829F20BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F20C0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F20C4: 4BFFD325  bl 0x829ef3e8
	ctx.lr = 0x829F20C8;
	sub_829EF3E8(ctx, base);
	// 829F20C8: 4BFFFD94  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F20CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F20D0: 419A00A4  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F20D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F20D8: 487B78B1  bl 0x831a9988
	ctx.lr = 0x829F20DC;
	sub_831A9988(ctx, base);
	// 829F20DC: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F20E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F20E4: 386BDF60  addi r3, r11, -0x20a0
	ctx.r[3].s64 = ctx.r[11].s64 + -8352;
	// 829F20E8: 487B6011  bl 0x831a80f8
	ctx.lr = 0x829F20EC;
	sub_831A80F8(ctx, base);
	// 829F20EC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F20F0: 41820014  beq 0x829f2104
	if ctx.cr[0].eq {
	pc = 0x829F2104; continue 'dispatch;
	}
	// 829F20F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F20F8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F20FC: 4BFFF565  bl 0x829f1660
	ctx.lr = 0x829F2100;
	sub_829F1660(ctx, base);
	// 829F2100: 4BFFFD5C  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F2104: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F2108: 419A006C  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F210C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2110: 487B7879  bl 0x831a9988
	ctx.lr = 0x829F2114;
	sub_831A9988(ctx, base);
	// 829F2114: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829F2118: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F211C: 386B59B0  addi r3, r11, 0x59b0
	ctx.r[3].s64 = ctx.r[11].s64 + 22960;
	// 829F2120: 487B5FD9  bl 0x831a80f8
	ctx.lr = 0x829F2124;
	sub_831A80F8(ctx, base);
	// 829F2124: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2128: 41820014  beq 0x829f213c
	if ctx.cr[0].eq {
	pc = 0x829F213C; continue 'dispatch;
	}
	// 829F212C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2130: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F2134: 4BFFD9E5  bl 0x829efb18
	ctx.lr = 0x829F2138;
	sub_829EFB18(ctx, base);
	// 829F2138: 4BFFFD24  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F213C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F2140: 419A0034  beq cr6, 0x829f2174
	if ctx.cr[6].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F2144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2148: 487B7841  bl 0x831a9988
	ctx.lr = 0x829F214C;
	sub_831A9988(ctx, base);
	// 829F214C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829F2150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F2154: 386B5984  addi r3, r11, 0x5984
	ctx.r[3].s64 = ctx.r[11].s64 + 22916;
	// 829F2158: 487B5FA1  bl 0x831a80f8
	ctx.lr = 0x829F215C;
	sub_831A80F8(ctx, base);
	// 829F215C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2160: 41820014  beq 0x829f2174
	if ctx.cr[0].eq {
	pc = 0x829F2174; continue 'dispatch;
	}
	// 829F2164: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2168: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F216C: 4B8CDE95  bl 0x822c0000
	ctx.lr = 0x829F2170;
	sub_822C0000(ctx, base);
	// 829F2170: 4BFFFCEC  b 0x829f1e5c
	pc = 0x829F1E5C; continue 'dispatch;
	// 829F2174: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 829F2178: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F217C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2180: 4BB20499  bl 0x82512618
	ctx.lr = 0x829F2184;
	sub_82512618(ctx, base);
	// 829F2184: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F2188: 487B6030  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2190 size=164
    let mut pc: u32 = 0x829F2190;
    'dispatch: loop {
        match pc {
            0x829F2190 => {
    //   block [0x829F2190..0x829F2234)
	// 829F2190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F2194: 487B5FD5  bl 0x831a8168
	ctx.lr = 0x829F2198;
	sub_831A8130(ctx, base);
	// 829F2198: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F219C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 829F21A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F21A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F21A8: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829F21AC: 41820038  beq 0x829f21e4
	if ctx.cr[0].eq {
	pc = 0x829F21E4; continue 'dispatch;
	}
	// 829F21B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F21B4: 487B77D5  bl 0x831a9988
	ctx.lr = 0x829F21B8;
	sub_831A9988(ctx, base);
	// 829F21B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 829F21BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F21C0: 386B5C00  addi r3, r11, 0x5c00
	ctx.r[3].s64 = ctx.r[11].s64 + 23552;
	// 829F21C4: 487B5F35  bl 0x831a80f8
	ctx.lr = 0x829F21C8;
	sub_831A80F8(ctx, base);
	// 829F21C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F21CC: 41820018  beq 0x829f21e4
	if ctx.cr[0].eq {
	pc = 0x829F21E4; continue 'dispatch;
	}
	// 829F21D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F21D4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F21D8: 4BFFC039  bl 0x829ee210
	ctx.lr = 0x829F21DC;
	sub_829EE210(ctx, base);
	// 829F21DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 829F21E0: 4800004C  b 0x829f222c
	pc = 0x829F222C; continue 'dispatch;
	// 829F21E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829F21E8: 419A0034  beq cr6, 0x829f221c
	if ctx.cr[6].eq {
	pc = 0x829F221C; continue 'dispatch;
	}
	// 829F21EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F21F0: 487B7799  bl 0x831a9988
	ctx.lr = 0x829F21F4;
	sub_831A9988(ctx, base);
	// 829F21F4: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 829F21F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F21FC: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 829F2200: 487B5EF9  bl 0x831a80f8
	ctx.lr = 0x829F2204;
	sub_831A80F8(ctx, base);
	// 829F2204: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2208: 41820014  beq 0x829f221c
	if ctx.cr[0].eq {
	pc = 0x829F221C; continue 'dispatch;
	}
	// 829F220C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2210: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 829F2214: 4BFFF6D5  bl 0x829f18e8
	ctx.lr = 0x829F2218;
	sub_829F18E8(ctx, base);
	// 829F2218: 4BFFFFC4  b 0x829f21dc
	pc = 0x829F21DC; continue 'dispatch;
	// 829F221C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 829F2220: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2228: 4878C261  bl 0x8317e488
	ctx.lr = 0x829F222C;
	sub_8317E488(ctx, base);
	// 829F222C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F2230: 487B5F88  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2238 size=848
    let mut pc: u32 = 0x829F2238;
    'dispatch: loop {
        match pc {
            0x829F2238 => {
    //   block [0x829F2238..0x829F2588)
	// 829F2238: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F223C: 487B5F1D  bl 0x831a8158
	ctx.lr = 0x829F2240;
	sub_831A8130(ctx, base);
	// 829F2240: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F2248: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 829F224C: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 829F2250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2254: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 829F2258: 484019A9  bl 0x82df3c00
	ctx.lr = 0x829F225C;
	sub_82DF3C00(ctx, base);
	// 829F225C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2260: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2264: 409A000C  bne cr6, 0x829f2270
	if !ctx.cr[6].eq {
	pc = 0x829F2270; continue 'dispatch;
	}
	// 829F2268: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829F226C: 48000010  b 0x829f227c
	pc = 0x829F227C; continue 'dispatch;
	// 829F2270: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F2274: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F2278: 7D681670  srawi r8, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F227C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 829F2280: 419A02F8  beq cr6, 0x829f2578
	if ctx.cr[6].eq {
	pc = 0x829F2578; continue 'dispatch;
	}
	// 829F2284: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2288: 409A000C  bne cr6, 0x829f2294
	if !ctx.cr[6].eq {
	pc = 0x829F2294; continue 'dispatch;
	}
	// 829F228C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F2290: 48000010  b 0x829f22a0
	pc = 0x829F22A0; continue 'dispatch;
	// 829F2294: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2298: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F229C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F22A0: 3D203FFF  lis r9, 0x3fff
	ctx.r[9].s64 = 1073676288;
	// 829F22A4: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 829F22A8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 829F22AC: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 829F22B0: 4098000C  bge cr6, 0x829f22bc
	if !ctx.cr[6].lt {
	pc = 0x829F22BC; continue 'dispatch;
	}
	// 829F22B4: 481C5A6D  bl 0x82bb7d20
	ctx.lr = 0x829F22B8;
	sub_82BB7D20(ctx, base);
	// 829F22B8: 480002C0  b 0x829f2578
	pc = 0x829F2578; continue 'dispatch;
	// 829F22BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F22C0: 409A000C  bne cr6, 0x829f22cc
	if !ctx.cr[6].eq {
	pc = 0x829F22CC; continue 'dispatch;
	}
	// 829F22C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F22C8: 48000010  b 0x829f22d8
	pc = 0x829F22D8; continue 'dispatch;
	// 829F22CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F22D0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F22D4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F22D8: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 829F22DC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F22E0: 40980168  bge cr6, 0x829f2448
	if !ctx.cr[6].lt {
	pc = 0x829F2448; continue 'dispatch;
	}
	// 829F22E4: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F22E8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 829F22EC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 829F22F0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 829F22F4: 41980008  blt cr6, 0x829f22fc
	if ctx.cr[6].lt {
	pc = 0x829F22FC; continue 'dispatch;
	}
	// 829F22F8: 7F2B4214  add r25, r11, r8
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 829F22FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2300: 409A000C  bne cr6, 0x829f230c
	if !ctx.cr[6].eq {
	pc = 0x829F230C; continue 'dispatch;
	}
	// 829F2304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F2308: 48000010  b 0x829f2318
	pc = 0x829F2318; continue 'dispatch;
	// 829F230C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2310: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F2314: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F2318: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 829F231C: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F2320: 40980024  bge cr6, 0x829f2344
	if !ctx.cr[6].lt {
	pc = 0x829F2344; continue 'dispatch;
	}
	// 829F2324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F2328: 409A000C  bne cr6, 0x829f2334
	if !ctx.cr[6].eq {
	pc = 0x829F2334; continue 'dispatch;
	}
	// 829F232C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F2330: 48000010  b 0x829f2340
	pc = 0x829F2340; continue 'dispatch;
	// 829F2334: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2338: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 829F233C: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F2340: 7F2BC214  add r25, r11, r24
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 829F2344: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F2348: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 829F234C: 4BFFBB1D  bl 0x829ede68
	ctx.lr = 0x829F2350;
	sub_829EDE68(ctx, base);
	// 829F2350: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F2354: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2358: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 829F235C: 48000020  b 0x829f237c
	pc = 0x829F237C; continue 'dispatch;
	// 829F2360: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F2364: 419A0010  beq cr6, 0x829f2374
	if ctx.cr[6].eq {
	pc = 0x829F2374; continue 'dispatch;
	}
	// 829F2368: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F236C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F2370: 48401891  bl 0x82df3c00
	ctx.lr = 0x829F2374;
	sub_82DF3C00(ctx, base);
	// 829F2374: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 829F2378: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 829F237C: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829F2380: 409AFFE0  bne cr6, 0x829f2360
	if !ctx.cr[6].eq {
	pc = 0x829F2360; continue 'dispatch;
	}
	// 829F2384: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829F2388: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 829F238C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F2390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2394: 4B8FC49D  bl 0x822ee830
	ctx.lr = 0x829F2398;
	sub_822EE830(ctx, base);
	// 829F2398: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F239C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F23A0: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F23A4: 419A002C  beq cr6, 0x829f23d0
	if ctx.cr[6].eq {
	pc = 0x829F23D0; continue 'dispatch;
	}
	// 829F23A8: 7F9ED050  subf r28, r30, r26
	ctx.r[28].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	// 829F23AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F23B0: 419A0010  beq cr6, 0x829f23c0
	if ctx.cr[6].eq {
	pc = 0x829F23C0; continue 'dispatch;
	}
	// 829F23B4: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 829F23B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F23BC: 48401845  bl 0x82df3c00
	ctx.lr = 0x829F23C0;
	sub_82DF3C00(ctx, base);
	// 829F23C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 829F23C4: 7D7CF214  add r11, r28, r30
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 829F23C8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F23CC: 409AFFE0  bne cr6, 0x829f23ac
	if !ctx.cr[6].eq {
	pc = 0x829F23AC; continue 'dispatch;
	}
	// 829F23D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F23D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F23D8: 409A000C  bne cr6, 0x829f23e4
	if !ctx.cr[6].eq {
	pc = 0x829F23E4; continue 'dispatch;
	}
	// 829F23DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829F23E0: 48000010  b 0x829f23f0
	pc = 0x829F23F0; continue 'dispatch;
	// 829F23E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F23E8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F23EC: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 829F23F0: 7F8AC214  add r28, r10, r24
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 829F23F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F23F8: 419A0030  beq cr6, 0x829f2428
	if ctx.cr[6].eq {
	pc = 0x829F2428; continue 'dispatch;
	}
	// 829F23FC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2400: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 829F2404: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F2408: 419A0018  beq cr6, 0x829f2420
	if ctx.cr[6].eq {
	pc = 0x829F2420; continue 'dispatch;
	}
	// 829F240C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2410: 48401019  bl 0x82df3428
	ctx.lr = 0x829F2414;
	sub_82DF3428(ctx, base);
	// 829F2414: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 829F2418: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F241C: 409AFFF0  bne cr6, 0x829f240c
	if !ctx.cr[6].eq {
	pc = 0x829F240C; continue 'dispatch;
	}
	// 829F2420: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2424: 4B8CDE45  bl 0x822c0268
	ctx.lr = 0x829F2428;
	sub_822C0268(ctx, base);
	// 829F2428: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F242C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 829F2430: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F2434: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 829F2438: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 829F243C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 829F2440: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829F2444: 48000134  b 0x829f2578
	pc = 0x829F2578; continue 'dispatch;
	// 829F2448: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F244C: 7D7AF050  subf r11, r26, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 829F2450: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F2454: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 829F2458: 40980090  bge cr6, 0x829f24e8
	if !ctx.cr[6].lt {
	pc = 0x829F24E8; continue 'dispatch;
	}
	// 829F245C: 571D103A  slwi r29, r24, 2
	ctx.r[29].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 829F2460: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F2464: 7F9DD214  add r28, r29, r26
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[26].u64;
	// 829F2468: 419A002C  beq cr6, 0x829f2494
	if ctx.cr[6].eq {
	pc = 0x829F2494; continue 'dispatch;
	}
	// 829F246C: 7F7DE050  subf r27, r29, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 829F2470: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829F2474: 419A0010  beq cr6, 0x829f2484
	if ctx.cr[6].eq {
	pc = 0x829F2484; continue 'dispatch;
	}
	// 829F2478: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F247C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F2480: 48401781  bl 0x82df3c00
	ctx.lr = 0x829F2484;
	sub_82DF3C00(ctx, base);
	// 829F2484: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 829F2488: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 829F248C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F2490: 409AFFE0  bne cr6, 0x829f2470
	if !ctx.cr[6].eq {
	pc = 0x829F2470; continue 'dispatch;
	}
	// 829F2494: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2498: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 829F249C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F24A0: 7D7A2050  subf r11, r26, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[26].s64;
	// 829F24A4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F24A8: 7CABC050  subf r5, r11, r24
	ctx.r[5].s64 = ctx.r[24].s64 - ctx.r[11].s64;
	// 829F24AC: 4B8FC385  bl 0x822ee830
	ctx.lr = 0x829F24B0;
	sub_822EE830(ctx, base);
	// 829F24B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F24B4: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 829F24B8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 829F24BC: 7FDD5850  subf r30, r29, r11
	ctx.r[30].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 829F24C0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829F24C4: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F24C8: 419A00B0  beq cr6, 0x829f2578
	if ctx.cr[6].eq {
	pc = 0x829F2578; continue 'dispatch;
	}
	// 829F24CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F24D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F24D4: 484016FD  bl 0x82df3bd0
	ctx.lr = 0x829F24D8;
	sub_82DF3BD0(ctx, base);
	// 829F24D8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 829F24DC: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F24E0: 409AFFEC  bne cr6, 0x829f24cc
	if !ctx.cr[6].eq {
	pc = 0x829F24CC; continue 'dispatch;
	}
	// 829F24E4: 48000094  b 0x829f2578
	pc = 0x829F2578; continue 'dispatch;
	// 829F24E8: 5719103A  slwi r25, r24, 2
	ctx.r[25].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 829F24EC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 829F24F0: 7FB9F050  subf r29, r25, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 829F24F4: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 829F24F8: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F24FC: 419A0028  beq cr6, 0x829f2524
	if ctx.cr[6].eq {
	pc = 0x829F2524; continue 'dispatch;
	}
	// 829F2500: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 829F2504: 419A0010  beq cr6, 0x829f2514
	if ctx.cr[6].eq {
	pc = 0x829F2514; continue 'dispatch;
	}
	// 829F2508: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 829F250C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 829F2510: 484016F1  bl 0x82df3c00
	ctx.lr = 0x829F2514;
	sub_82DF3C00(ctx, base);
	// 829F2514: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 829F2518: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 829F251C: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F2520: 409AFFE0  bne cr6, 0x829f2500
	if !ctx.cr[6].eq {
	pc = 0x829F2500; continue 'dispatch;
	}
	// 829F2524: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 829F2528: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 829F252C: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F2530: 419A0020  beq cr6, 0x829f2550
	if ctx.cr[6].eq {
	pc = 0x829F2550; continue 'dispatch;
	}
	// 829F2534: 7FDDF050  subf r30, r29, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 829F2538: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 829F253C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2540: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 829F2544: 4840168D  bl 0x82df3bd0
	ctx.lr = 0x829F2548;
	sub_82DF3BD0(ctx, base);
	// 829F2548: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 829F254C: 409AFFEC  bne cr6, 0x829f2538
	if !ctx.cr[6].eq {
	pc = 0x829F2538; continue 'dispatch;
	}
	// 829F2550: 7FD9D214  add r30, r25, r26
	ctx.r[30].u64 = ctx.r[25].u64 + ctx.r[26].u64;
	// 829F2554: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 829F2558: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F255C: 419A001C  beq cr6, 0x829f2578
	if ctx.cr[6].eq {
	pc = 0x829F2578; continue 'dispatch;
	}
	// 829F2560: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F2564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2568: 48401669  bl 0x82df3bd0
	ctx.lr = 0x829F256C;
	sub_82DF3BD0(ctx, base);
	// 829F256C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 829F2570: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 829F2574: 409AFFEC  bne cr6, 0x829f2560
	if !ctx.cr[6].eq {
	pc = 0x829F2560; continue 'dispatch;
	}
	// 829F2578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F257C: 48400EAD  bl 0x82df3428
	ctx.lr = 0x829F2580;
	sub_82DF3428(ctx, base);
	// 829F2580: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 829F2584: 487B5C24  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2588 size=148
    let mut pc: u32 = 0x829F2588;
    'dispatch: loop {
        match pc {
            0x829F2588 => {
    //   block [0x829F2588..0x829F261C)
	// 829F2588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F258C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F2590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F2594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F2598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F259C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F25A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F25A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F25A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F25AC: 409A000C  bne cr6, 0x829f25b8
	if !ctx.cr[6].eq {
	pc = 0x829F25B8; continue 'dispatch;
	}
	// 829F25B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F25B4: 48000010  b 0x829f25c4
	pc = 0x829F25C4; continue 'dispatch;
	// 829F25B8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F25BC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F25C0: 7D641E70  srawi r4, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 829F25C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F25C8: 4B8D3A79  bl 0x822c6040
	ctx.lr = 0x829F25CC;
	sub_822C6040(ctx, base);
	// 829F25CC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F25D0: 41820030  beq 0x829f2600
	if ctx.cr[0].eq {
	pc = 0x829F2600; continue 'dispatch;
	}
	// 829F25D4: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829F25D8: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F25DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829F25E0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F25E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829F25E8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F25EC: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F25F0: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 829F25F4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F25F8: 48091D21  bl 0x82a84318
	ctx.lr = 0x829F25FC;
	sub_82A84318(ctx, base);
	// 829F25FC: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 829F2600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F2608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F260C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F2610: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F2614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F2618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2620 size=128
    let mut pc: u32 = 0x829F2620;
    'dispatch: loop {
        match pc {
            0x829F2620 => {
    //   block [0x829F2620..0x829F26A0)
	// 829F2620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F2624: 487B5B49  bl 0x831a816c
	ctx.lr = 0x829F2628;
	sub_831A8130(ctx, base);
	// 829F2628: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F262C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829F2630: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 829F2634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F2638: 3BEBD920  addi r31, r11, -0x26e0
	ctx.r[31].s64 = ctx.r[11].s64 + -9952;
	// 829F263C: 816AD928  lwz r11, -0x26d8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-9944 as u32) ) } as u64;
	// 829F2640: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F2644: 40820024  bne 0x829f2668
	if !ctx.cr[0].eq {
	pc = 0x829F2668; continue 'dispatch;
	}
	// 829F2648: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 829F264C: 3D00829F  lis r8, -0x7d61
	ctx.r[8].s64 = -2103508992;
	// 829F2650: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 829F2654: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 829F2658: 3908F490  addi r8, r8, -0xb70
	ctx.r[8].s64 = ctx.r[8].s64 + -2928;
	// 829F265C: 916AD928  stw r11, -0x26d8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-9944 as u32), ctx.r[11].u32 ) };
	// 829F2660: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 829F2664: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 829F2668: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829F266C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 829F2670: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2674: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 829F2678: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 829F267C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F2680: 4BC61F41  bl 0x826545c0
	ctx.lr = 0x829F2684;
	sub_826545C0(ctx, base);
	// 829F2684: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F2688: 4182000C  beq 0x829f2694
	if ctx.cr[0].eq {
	pc = 0x829F2694; continue 'dispatch;
	}
	// 829F268C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F2690: 48000008  b 0x829f2698
	pc = 0x829F2698; continue 'dispatch;
	// 829F2694: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 829F2698: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F269C: 487B5B20  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F26A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F26A0 size=180
    let mut pc: u32 = 0x829F26A0;
    'dispatch: loop {
        match pc {
            0x829F26A0 => {
    //   block [0x829F26A0..0x829F2754)
	// 829F26A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F26A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F26A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F26AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F26B0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F26B4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 829F26B8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 829F26BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F26C0: 409A000C  bne cr6, 0x829f26cc
	if !ctx.cr[6].eq {
	pc = 0x829F26CC; continue 'dispatch;
	}
	// 829F26C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829F26C8: 48000010  b 0x829f26d8
	pc = 0x829F26D8; continue 'dispatch;
	// 829F26CC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F26D0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F26D4: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 829F26D8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829F26DC: 4098002C  bge cr6, 0x829f2708
	if !ctx.cr[6].lt {
	pc = 0x829F2708; continue 'dispatch;
	}
	// 829F26E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F26E4: 419A0010  beq cr6, 0x829f26f4
	if ctx.cr[6].eq {
	pc = 0x829F26F4; continue 'dispatch;
	}
	// 829F26E8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F26EC: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F26F0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 829F26F4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 829F26F8: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F26FC: 7CAB4850  subf r5, r11, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 829F2700: 4BFFFB39  bl 0x829f2238
	ctx.lr = 0x829F2704;
	sub_829F2238(ctx, base);
	// 829F2704: 48000034  b 0x829f2738
	pc = 0x829F2738; continue 'dispatch;
	// 829F2708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F270C: 419A002C  beq cr6, 0x829f2738
	if ctx.cr[6].eq {
	pc = 0x829F2738; continue 'dispatch;
	}
	// 829F2710: 80C30008  lwz r6, 8(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2714: 7D4B3050  subf r10, r11, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 829F2718: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 829F271C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829F2720: 40980018  bge cr6, 0x829f2738
	if !ctx.cr[6].lt {
	pc = 0x829F2738; continue 'dispatch;
	}
	// 829F2724: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F2728: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F272C: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F2730: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2734: 4B9DFC2D  bl 0x823d2360
	ctx.lr = 0x829F2738;
	sub_823D2360(ctx, base);
	// 829F2738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F273C: 48400CED  bl 0x82df3428
	ctx.lr = 0x829F2740;
	sub_82DF3428(ctx, base);
	// 829F2740: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F2744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F2748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F274C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F2750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2758 size=204
    let mut pc: u32 = 0x829F2758;
    'dispatch: loop {
        match pc {
            0x829F2758 => {
    //   block [0x829F2758..0x829F2824)
	// 829F2758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F275C: 487B5A11  bl 0x831a816c
	ctx.lr = 0x829F2760;
	sub_831A8130(ctx, base);
	// 829F2760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F2768: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 829F276C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829F2770: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2778: 409A000C  bne cr6, 0x829f2784
	if !ctx.cr[6].eq {
	pc = 0x829F2784; continue 'dispatch;
	}
	// 829F277C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 829F2780: 48000010  b 0x829f2790
	pc = 0x829F2790; continue 'dispatch;
	// 829F2784: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2788: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F278C: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 829F2790: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 829F2794: 40980030  bge cr6, 0x829f27c4
	if !ctx.cr[6].lt {
	pc = 0x829F27C4; continue 'dispatch;
	}
	// 829F2798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F279C: 419A0010  beq cr6, 0x829f27ac
	if ctx.cr[6].eq {
	pc = 0x829F27AC; continue 'dispatch;
	}
	// 829F27A0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F27A4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F27A8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 829F27AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 829F27B0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F27B4: 7CAB4850  subf r5, r11, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 829F27B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F27BC: 4B8E30ED  bl 0x822d58a8
	ctx.lr = 0x829F27C0;
	sub_822D58A8(ctx, base);
	// 829F27C0: 4800004C  b 0x829f280c
	pc = 0x829F280C; continue 'dispatch;
	// 829F27C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F27C8: 419A0044  beq cr6, 0x829f280c
	if ctx.cr[6].eq {
	pc = 0x829F280C; continue 'dispatch;
	}
	// 829F27CC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F27D0: 7D4B2050  subf r10, r11, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 829F27D4: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 829F27D8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829F27DC: 40980030  bge cr6, 0x829f280c
	if !ctx.cr[6].lt {
	pc = 0x829F280C; continue 'dispatch;
	}
	// 829F27E0: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F27E4: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 829F27E8: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 829F27EC: 419A0020  beq cr6, 0x829f280c
	if ctx.cr[6].eq {
	pc = 0x829F280C; continue 'dispatch;
	}
	// 829F27F0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 829F27F4: 4B8D2B5D  bl 0x822c5350
	ctx.lr = 0x829F27F8;
	sub_822C5350(ctx, base);
	// 829F27F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F27FC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2800: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 829F2804: 4BDDFB45  bl 0x827d2348
	ctx.lr = 0x829F2808;
	sub_827D2348(ctx, base);
	// 829F2808: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 829F280C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F2814: 419A0008  beq cr6, 0x829f281c
	if ctx.cr[6].eq {
	pc = 0x829F281C; continue 'dispatch;
	}
	// 829F2818: 4B8CE079  bl 0x822c0890
	ctx.lr = 0x829F281C;
	sub_822C0890(ctx, base);
	// 829F281C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F2820: 487B599C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F2828 size=628
    let mut pc: u32 = 0x829F2828;
    'dispatch: loop {
        match pc {
            0x829F2828 => {
    //   block [0x829F2828..0x829F2A9C)
	// 829F2828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F282C: 487B5929  bl 0x831a8154
	ctx.lr = 0x829F2830;
	sub_831A8130(ctx, base);
	// 829F2830: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2834: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 829F2838: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 829F283C: 4BB1F82D  bl 0x82512068
	ctx.lr = 0x829F2840;
	sub_82512068(ctx, base);
	// 829F2840: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 829F2844: 3B3A0364  addi r25, r26, 0x364
	ctx.r[25].s64 = ctx.r[26].s64 + 868;
	// 829F2848: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 829F284C: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 829F2850: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2858: 419A009C  beq cr6, 0x829f28f4
	if ctx.cr[6].eq {
	pc = 0x829F28F4; continue 'dispatch;
	}
	// 829F285C: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2860: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F2864: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 829F2868: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F286C: 40980088  bge cr6, 0x829f28f4
	if !ctx.cr[6].lt {
	pc = 0x829F28F4; continue 'dispatch;
	}
	// 829F2870: 817A0148  lwz r11, 0x148(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(328 as u32) ) } as u64;
	// 829F2874: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F2878: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F287C: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 829F2880: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 829F2884: 4B8D4325  bl 0x822c6ba8
	ctx.lr = 0x829F2888;
	sub_822C6BA8(ctx, base);
	// 829F2888: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 829F288C: 579B2036  slwi r27, r28, 4
	ctx.r[27].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 829F2890: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 829F2894: 817A0368  lwz r11, 0x368(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(872 as u32) ) } as u64;
	// 829F2898: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 829F289C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F28A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F28A4: 419A0044  beq cr6, 0x829f28e8
	if ctx.cr[6].eq {
	pc = 0x829F28E8; continue 'dispatch;
	}
	// 829F28A8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F28AC: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829F28B0: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 829F28B4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829F28B8: 40980030  bge cr6, 0x829f28e8
	if !ctx.cr[6].lt {
	pc = 0x829F28E8; continue 'dispatch;
	}
	// 829F28BC: 815A0148  lwz r10, 0x148(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(328 as u32) ) } as u64;
	// 829F28C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F28C4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829F28C8: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F28CC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F28D0: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 829F28D4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 829F28D8: 481C0831  bl 0x82bb3108
	ctx.lr = 0x829F28DC;
	sub_82BB3108(ctx, base);
	// 829F28DC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 829F28E0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829F28E4: 4BFFFFB0  b 0x829f2894
	pc = 0x829F2894; continue 'dispatch;
	// 829F28E8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 829F28EC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 829F28F0: 4BFFFF60  b 0x829f2850
	pc = 0x829F2850; continue 'dispatch;
	// 829F28F4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829F28F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F28FC: 4BB18055  bl 0x8250a950
	ctx.lr = 0x829F2900;
	sub_8250A950(ctx, base);
	// 829F2900: 807A03A4  lwz r3, 0x3a4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(932 as u32) ) } as u64;
	// 829F2904: 3BFA03A4  addi r31, r26, 0x3a4
	ctx.r[31].s64 = ctx.r[26].s64 + 932;
	// 829F2908: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F290C: 419A0040  beq cr6, 0x829f294c
	if ctx.cr[6].eq {
	pc = 0x829F294C; continue 'dispatch;
	}
	// 829F2910: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F2914: 4848EE2D  bl 0x82e81740
	ctx.lr = 0x829F2918;
	sub_82E81740(ctx, base);
	// 829F2918: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F291C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2920: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F2924: 409A0008  bne cr6, 0x829f292c
	if !ctx.cr[6].eq {
	pc = 0x829F292C; continue 'dispatch;
	}
	// 829F2928: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829F292C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2930: 4BDE1041  bl 0x827d3970
	ctx.lr = 0x829F2934;
	sub_827D3970(ctx, base);
	// 829F2934: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 829F2938: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F293C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F2940: 92FF0004  stw r23, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 829F2944: 419A0008  beq cr6, 0x829f294c
	if ctx.cr[6].eq {
	pc = 0x829F294C; continue 'dispatch;
	}
	// 829F2948: 4B8CDF49  bl 0x822c0890
	ctx.lr = 0x829F294C;
	sub_822C0890(ctx, base);
	// 829F294C: 807A0380  lwz r3, 0x380(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(896 as u32) ) } as u64;
	// 829F2950: 3BFA0380  addi r31, r26, 0x380
	ctx.r[31].s64 = ctx.r[26].s64 + 896;
	// 829F2954: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F2958: 419A0040  beq cr6, 0x829f2998
	if ctx.cr[6].eq {
	pc = 0x829F2998; continue 'dispatch;
	}
	// 829F295C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F2960: 4848EDE1  bl 0x82e81740
	ctx.lr = 0x829F2964;
	sub_82E81740(ctx, base);
	// 829F2964: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F2968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F296C: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F2970: 409A0008  bne cr6, 0x829f2978
	if !ctx.cr[6].eq {
	pc = 0x829F2978; continue 'dispatch;
	}
	// 829F2974: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829F2978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F297C: 4BDE0FF5  bl 0x827d3970
	ctx.lr = 0x829F2980;
	sub_827D3970(ctx, base);
	// 829F2980: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 829F2984: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F298C: 92FF0004  stw r23, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 829F2990: 419A0008  beq cr6, 0x829f2998
	if ctx.cr[6].eq {
	pc = 0x829F2998; continue 'dispatch;
	}
	// 829F2994: 4B8CDEFD  bl 0x822c0890
	ctx.lr = 0x829F2998;
	sub_822C0890(ctx, base);
	// 829F2998: 807A0388  lwz r3, 0x388(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(904 as u32) ) } as u64;
	// 829F299C: 3BFA0388  addi r31, r26, 0x388
	ctx.r[31].s64 = ctx.r[26].s64 + 904;
	// 829F29A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F29A4: 419A0040  beq cr6, 0x829f29e4
	if ctx.cr[6].eq {
	pc = 0x829F29E4; continue 'dispatch;
	}
	// 829F29A8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F29AC: 4848ED95  bl 0x82e81740
	ctx.lr = 0x829F29B0;
	sub_82E81740(ctx, base);
	// 829F29B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F29B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F29B8: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F29BC: 409A0008  bne cr6, 0x829f29c4
	if !ctx.cr[6].eq {
	pc = 0x829F29C4; continue 'dispatch;
	}
	// 829F29C0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829F29C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F29C8: 4BDE0FA9  bl 0x827d3970
	ctx.lr = 0x829F29CC;
	sub_827D3970(ctx, base);
	// 829F29CC: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 829F29D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F29D4: 92FF0004  stw r23, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 829F29D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F29DC: 419A0008  beq cr6, 0x829f29e4
	if ctx.cr[6].eq {
	pc = 0x829F29E4; continue 'dispatch;
	}
	// 829F29E0: 4B8CDEB1  bl 0x822c0890
	ctx.lr = 0x829F29E4;
	sub_822C0890(ctx, base);
	// 829F29E4: 3BFA03AC  addi r31, r26, 0x3ac
	ctx.r[31].s64 = ctx.r[26].s64 + 940;
	// 829F29E8: 3BC00014  li r30, 0x14
	ctx.r[30].s64 = 20;
	// 829F29EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F29F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F29F4: 419A0040  beq cr6, 0x829f2a34
	if ctx.cr[6].eq {
	pc = 0x829F2A34; continue 'dispatch;
	}
	// 829F29F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F29FC: 4848ED45  bl 0x82e81740
	ctx.lr = 0x829F2A00;
	sub_82E81740(ctx, base);
	// 829F2A00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F2A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2A08: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F2A0C: 409A0008  bne cr6, 0x829f2a14
	if !ctx.cr[6].eq {
	pc = 0x829F2A14; continue 'dispatch;
	}
	// 829F2A10: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829F2A14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2A18: 4BDE0F59  bl 0x827d3970
	ctx.lr = 0x829F2A1C;
	sub_827D3970(ctx, base);
	// 829F2A1C: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 829F2A20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2A24: 92FF0004  stw r23, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 829F2A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F2A2C: 419A0008  beq cr6, 0x829f2a34
	if ctx.cr[6].eq {
	pc = 0x829F2A34; continue 'dispatch;
	}
	// 829F2A30: 4B8CDE61  bl 0x822c0890
	ctx.lr = 0x829F2A34;
	sub_822C0890(ctx, base);
	// 829F2A34: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 829F2A38: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829F2A3C: 4082FFB0  bne 0x829f29ec
	if !ctx.cr[0].eq {
	pc = 0x829F29EC; continue 'dispatch;
	}
	// 829F2A40: 807A044C  lwz r3, 0x44c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1100 as u32) ) } as u64;
	// 829F2A44: 3BFA044C  addi r31, r26, 0x44c
	ctx.r[31].s64 = ctx.r[26].s64 + 1100;
	// 829F2A48: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 829F2A4C: 419A0040  beq cr6, 0x829f2a8c
	if ctx.cr[6].eq {
	pc = 0x829F2A8C; continue 'dispatch;
	}
	// 829F2A50: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F2A54: 4848ECED  bl 0x82e81740
	ctx.lr = 0x829F2A58;
	sub_82E81740(ctx, base);
	// 829F2A58: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F2A5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F2A60: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F2A64: 409A0008  bne cr6, 0x829f2a6c
	if !ctx.cr[6].eq {
	pc = 0x829F2A6C; continue 'dispatch;
	}
	// 829F2A68: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829F2A6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F2A70: 4BDE0F01  bl 0x827d3970
	ctx.lr = 0x829F2A74;
	sub_827D3970(ctx, base);
	// 829F2A74: 92FF0000  stw r23, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	// 829F2A78: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F2A7C: 92FF0004  stw r23, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 829F2A80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F2A84: 419A0008  beq cr6, 0x829f2a8c
	if ctx.cr[6].eq {
	pc = 0x829F2A8C; continue 'dispatch;
	}
	// 829F2A88: 4B8CDE09  bl 0x822c0890
	ctx.lr = 0x829F2A8C;
	sub_822C0890(ctx, base);
	// 829F2A8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2A90: 483FF201  bl 0x82df1c90
	ctx.lr = 0x829F2A94;
	sub_82DF1C90(ctx, base);
	// 829F2A94: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829F2A98: 487B570C  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F2AA0 size=1300
    let mut pc: u32 = 0x829F2AA0;
    'dispatch: loop {
        match pc {
            0x829F2AA0 => {
    //   block [0x829F2AA0..0x829F2FB4)
	// 829F2AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F2AA4: 487B56AD  bl 0x831a8150
	ctx.lr = 0x829F2AA8;
	sub_831A8130(ctx, base);
	// 829F2AA8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 829F2AAC: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2AB0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829F2AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F2AB8: 7F16C378  mr r22, r24
	ctx.r[22].u64 = ctx.r[24].u64;
	// 829F2ABC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 829F2AC0: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 829F2AC4: 4BB1EF15  bl 0x825119d8
	ctx.lr = 0x829F2AC8;
	sub_825119D8(ctx, base);
	// 829F2AC8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F2ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F2AD0: 4BB1C8A1  bl 0x8250f370
	ctx.lr = 0x829F2AD4;
	sub_8250F370(ctx, base);
	// 829F2AD4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 829F2AD8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F2ADC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 829F2AE0: 48400F29  bl 0x82df3a08
	ctx.lr = 0x829F2AE4;
	sub_82DF3A08(ctx, base);
	// 829F2AE4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F2AE8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829F2AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2AF0: 4BB15C91  bl 0x82508780
	ctx.lr = 0x829F2AF4;
	sub_82508780(ctx, base);
	// 829F2AF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F2AF8: 48400931  bl 0x82df3428
	ctx.lr = 0x829F2AFC;
	sub_82DF3428(ctx, base);
	// 829F2AFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F2B00: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 829F2B04: 409A0008  bne cr6, 0x829f2b0c
	if !ctx.cr[6].eq {
	pc = 0x829F2B0C; continue 'dispatch;
	}
	// 829F2B08: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829F2B0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2B10: 4BB15C91  bl 0x825087a0
	ctx.lr = 0x829F2B14;
	sub_825087A0(ctx, base);
	// 829F2B14: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 829F2B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F2B1C: 4BB15B65  bl 0x82508680
	ctx.lr = 0x829F2B20;
	sub_82508680(ctx, base);
	// 829F2B20: 907F0108  stw r3, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[3].u32 ) };
	// 829F2B24: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829F2B28: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 829F2B2C: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 829F2B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2B34: 80AB6840  lwz r5, 0x6840(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26688 as u32) ) } as u64;
	// 829F2B38: 808A6784  lwz r4, 0x6784(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26500 as u32) ) } as u64;
	// 829F2B3C: 80DE6838  lwz r6, 0x6838(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26680 as u32) ) } as u64;
	// 829F2B40: 4B904CD9  bl 0x822f7818
	ctx.lr = 0x829F2B44;
	sub_822F7818(ctx, base);
	// 829F2B44: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829F2B48: 3FA08335  lis r29, -0x7ccb
	ctx.r[29].s64 = -2093678592;
	// 829F2B4C: 808B6874  lwz r4, 0x6874(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26740 as u32) ) } as u64;
	// 829F2B50: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 829F2B54: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F2B58: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F2B5C: 80DD67C0  lwz r6, 0x67c0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26560 as u32) ) } as u64;
	// 829F2B60: 80BC67D4  lwz r5, 0x67d4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26580 as u32) ) } as u64;
	// 829F2B64: 4B904CB5  bl 0x822f7818
	ctx.lr = 0x829F2B68;
	sub_822F7818(ctx, base);
	// 829F2B68: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F2B6C: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 829F2B70: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F2B74: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829F2B78: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F2B7C: 4BA9970D  bl 0x8248c288
	ctx.lr = 0x829F2B80;
	sub_8248C288(ctx, base);
	// 829F2B80: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F2B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F2B88: 809E6838  lwz r4, 0x6838(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26680 as u32) ) } as u64;
	// 829F2B8C: 4B8F23A5  bl 0x822e4f30
	ctx.lr = 0x829F2B90;
	sub_822E4F30(ctx, base);
	// 829F2B90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F2B94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 829F2B98: 80BD67C0  lwz r5, 0x67c0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(26560 as u32) ) } as u64;
	// 829F2B9C: 809C67D4  lwz r4, 0x67d4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26580 as u32) ) } as u64;
	// 829F2BA0: 4B904C01  bl 0x822f77a0
	ctx.lr = 0x829F2BA4;
	sub_822F77A0(ctx, base);
	// 829F2BA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 829F2BA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F2BAC: E89E0000  ld r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 829F2BB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F2BB4: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 829F2BB8: 4BA996D1  bl 0x8248c288
	ctx.lr = 0x829F2BBC;
	sub_8248C288(ctx, base);
	// 829F2BBC: 897F00F2  lbz r11, 0xf2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(242 as u32) ) } as u64;
	// 829F2BC0: 3D40832E  lis r10, -0x7cd2
	ctx.r[10].s64 = -2094137344;
	// 829F2BC4: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F2BC8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 829F2BCC: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 829F2BD0: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 829F2BD4: 3D00832E  lis r8, -0x7cd2
	ctx.r[8].s64 = -2094137344;
	// 829F2BD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 829F2BDC: 394AD704  addi r10, r10, -0x28fc
	ctx.r[10].s64 = ctx.r[10].s64 + -10492;
	// 829F2BE0: 3929D8F8  addi r9, r9, -0x2708
	ctx.r[9].s64 = ctx.r[9].s64 + -9992;
	// 829F2BE4: 3908D710  addi r8, r8, -0x28f0
	ctx.r[8].s64 = ctx.r[8].s64 + -10480;
	// 829F2BE8: 3CE0832E  lis r7, -0x7cd2
	ctx.r[7].s64 = -2094137344;
	// 829F2BEC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 829F2BF0: 7DAB542E  lfsx f13, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 829F2BF4: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 829F2BF8: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 829F2BFC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 829F2C00: 7D6B442E  lfsx f11, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 829F2C04: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 829F2C08: C007D700  lfs f0, -0x2900(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10496 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F2C0C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F2C10: C3E608A4  lfs f31, 0x8a4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F2C14: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 829F2C18: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 829F2C1C: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 829F2C20: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 829F2C24: 7C7CE82E  lwzx r3, r28, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 829F2C28: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 829F2C2C: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 829F2C30: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 829F2C34: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 829F2C38: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 829F2C3C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 829F2C40: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 829F2C44: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 829F2C48: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 829F2C4C: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 829F2C50: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F2FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F2FB8 size=980
    let mut pc: u32 = 0x829F2FB8;
    'dispatch: loop {
        match pc {
            0x829F2FB8 => {
    //   block [0x829F2FB8..0x829F338C)
	// 829F2FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F2FBC: 487B5179  bl 0x831a8134
	ctx.lr = 0x829F2FC0;
	sub_831A8130(ctx, base);
	// 829F2FC0: DBC1FF60  stfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 829F2FC4: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 829F2FC8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F2FCC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F2FD0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829F2FD4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 829F2FD8: 3A190334  addi r16, r25, 0x334
	ctx.r[16].s64 = ctx.r[25].s64 + 820;
	// 829F2FDC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F2FE0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F2FE4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F2FE8: C3C808A4  lfs f30, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 829F2FEC: C3E708A8  lfs f31, 0x8a8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2216 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 829F2FF0: 39E00003  li r15, 3
	ctx.r[15].s64 = 3;
	// 829F2FF4: 7E168378  mr r22, r16
	ctx.r[22].u64 = ctx.r[16].u64;
	// 829F2FF8: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	// 829F2FFC: 3AA00002  li r21, 2
	ctx.r[21].s64 = 2;
	// 829F3000: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 829F3004: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 829F3008: 3A2B675C  addi r17, r11, 0x675c
	ctx.r[17].s64 = ctx.r[11].s64 + 26460;
	// 829F300C: 3A6A6874  addi r19, r10, 0x6874
	ctx.r[19].s64 = ctx.r[10].s64 + 26740;
	// 829F3010: 3A496858  addi r18, r9, 0x6858
	ctx.r[18].s64 = ctx.r[9].s64 + 26712;
	// 829F3014: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3018: 896B00FC  lbz r11, 0xfc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(252 as u32) ) } as u64;
	// 829F301C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F3020: 41820350  beq 0x829f3370
	if ctx.cr[0].eq {
	pc = 0x829F3370; continue 'dispatch;
	}
	// 829F3024: 81790148  lwz r11, 0x148(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(328 as u32) ) } as u64;
	// 829F3028: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F302C: 4840B7B5  bl 0x82dfe7e0
	ctx.lr = 0x829F3030;
	sub_82DFE7E0(ctx, base);
	// 829F3030: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3034: 4182033C  beq 0x829f3370
	if ctx.cr[0].eq {
	pc = 0x829F3370; continue 'dispatch;
	}
	// 829F3038: 3B590364  addi r26, r25, 0x364
	ctx.r[26].s64 = ctx.r[25].s64 + 868;
	// 829F303C: 9AE10054  stb r23, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u8 ) };
	// 829F3040: 9AE10055  stb r23, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[23].u8 ) };
	// 829F3044: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 829F3048: 9AE10056  stb r23, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[23].u8 ) };
	// 829F304C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 829F3050: 9AA10057  stb r21, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[21].u8 ) };
	// 829F3054: 9A810058  stb r20, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[20].u8 ) };
	// 829F3058: 9B010059  stb r24, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[24].u8 ) };
	// 829F305C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3064: 419A00C4  beq cr6, 0x829f3128
	if ctx.cr[6].eq {
	pc = 0x829F3128; continue 'dispatch;
	}
	// 829F3068: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F306C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 829F3070: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 829F3074: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F3078: 409800B0  bge cr6, 0x829f3128
	if !ctx.cr[6].lt {
	pc = 0x829F3128; continue 'dispatch;
	}
	// 829F307C: 81790148  lwz r11, 0x148(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(328 as u32) ) } as u64;
	// 829F3080: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F3084: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F3088: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 829F308C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 829F3090: 4B8D3B19  bl 0x822c6ba8
	ctx.lr = 0x829F3094;
	sub_822C6BA8(ctx, base);
	// 829F3094: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	// 829F3098: 579B2036  slwi r27, r28, 4
	ctx.r[27].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 829F309C: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 829F30A0: 81790368  lwz r11, 0x368(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(872 as u32) ) } as u64;
	// 829F30A4: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 829F30A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F30AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F30B0: 419A006C  beq cr6, 0x829f311c
	if ctx.cr[6].eq {
	pc = 0x829F311C; continue 'dispatch;
	}
	// 829F30B4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F30B8: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829F30BC: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 829F30C0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829F30C4: 40980058  bge cr6, 0x829f311c
	if !ctx.cr[6].lt {
	pc = 0x829F311C; continue 'dispatch;
	}
	// 829F30C8: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 829F30CC: 7D5D50AE  lbzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 829F30D0: 7D4A0775  extsb. r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 829F30D4: 4180001C  blt 0x829f30f0
	if ctx.cr[0].lt {
	pc = 0x829F30F0; continue 'dispatch;
	}
	// 829F30D8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 829F30DC: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 829F30E0: 814A0334  lwz r10, 0x334(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(820 as u32) ) } as u64;
	// 829F30E4: A94A00F0  lha r10, 0xf0(r10)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(240 as u32) ) } as i16) as i64;
	// 829F30E8: 2C0A0000  cmpwi r10, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 829F30EC: 40810024  ble 0x829f3110
	if !ctx.cr[0].gt {
	pc = 0x829F3110; continue 'dispatch;
	}
	// 829F30F0: 81590148  lwz r10, 0x148(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(328 as u32) ) } as u64;
	// 829F30F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F30F8: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 829F30FC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F3100: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F3104: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 829F3108: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 829F310C: 481BFFFD  bl 0x82bb3108
	ctx.lr = 0x829F3110;
	sub_82BB3108(ctx, base);
	// 829F3110: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 829F3114: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829F3118: 4BFFFF88  b 0x829f30a0
	pc = 0x829F30A0; continue 'dispatch;
	// 829F311C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 829F3120: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 829F3124: 4BFFFF38  b 0x829f305c
	pc = 0x829F305C; continue 'dispatch;
	// 829F3128: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F312C: 396B00E8  addi r11, r11, 0xe8
	ctx.r[11].s64 = ctx.r[11].s64 + 232;
	// 829F3130: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 829F3134: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F3138: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F313C: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 829F3140: 419A0008  beq cr6, 0x829f3148
	if ctx.cr[6].eq {
	pc = 0x829F3148; continue 'dispatch;
	}
	// 829F3144: 4B8CD74D  bl 0x822c0890
	ctx.lr = 0x829F3148;
	sub_822C0890(ctx, base);
	// 829F3148: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 829F314C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3150: 484008B9  bl 0x82df3a08
	ctx.lr = 0x829F3154;
	sub_82DF3A08(ctx, base);
	// 829F3154: 8176001C  lwz r11, 0x1c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(28 as u32) ) } as u64;
	// 829F3158: 81560018  lwz r10, 0x18(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(24 as u32) ) } as u64;
	// 829F315C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3160: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 829F3164: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 829F3168: 419A0024  beq cr6, 0x829f318c
	if ctx.cr[6].eq {
	pc = 0x829F318C; continue 'dispatch;
	}
	// 829F316C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 829F3170: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F3174: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F3178: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F317C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F3180: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F3184: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F3188: 4082FFE8  bne 0x829f3170
	if !ctx.cr[0].eq {
	pc = 0x829F3170; continue 'dispatch;
	}
	// 829F318C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829F3190: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F3194: 4BB1C335  bl 0x8250f4c8
	ctx.lr = 0x829F3198;
	sub_8250F4C8(ctx, base);
	// 829F3198: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F319C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F31A0: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 829F31A4: 409A0008  bne cr6, 0x829f31ac
	if !ctx.cr[6].eq {
	pc = 0x829F31AC; continue 'dispatch;
	}
	// 829F31A8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 829F31AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F31B0: 4BB177A1  bl 0x8250a950
	ctx.lr = 0x829F31B4;
	sub_8250A950(ctx, base);
	// 829F31B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F31B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F31BC: 386BFF40  addi r3, r11, -0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + -192;
	// 829F31C0: 409A0008  bne cr6, 0x829f31c8
	if !ctx.cr[6].eq {
	pc = 0x829F31C8; continue 'dispatch;
	}
	// 829F31C4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 829F31C8: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 829F31CC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 829F31D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F31D4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 829F31D8: 4BDE0FC9  bl 0x827d41a0
	ctx.lr = 0x829F31DC;
	sub_827D41A0(ctx, base);
	// 829F31DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 829F31E0: 483FEAB1  bl 0x82df1c90
	ctx.lr = 0x829F31E4;
	sub_82DF1C90(ctx, base);
	// 829F31E4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 829F31E8: 483FEAA9  bl 0x82df1c90
	ctx.lr = 0x829F31EC;
	sub_82DF1C90(ctx, base);
	// 829F31EC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 829F31F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F31F4: 419A0008  beq cr6, 0x829f31fc
	if ctx.cr[6].eq {
	pc = 0x829F31FC; continue 'dispatch;
	}
	// 829F31F8: 4B8CD699  bl 0x822c0890
	ctx.lr = 0x829F31FC;
	sub_822C0890(ctx, base);
	// 829F31FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3200: 48400229  bl 0x82df3428
	ctx.lr = 0x829F3204;
	sub_82DF3428(ctx, base);
	// 829F3204: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3208: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 829F320C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 829F3210: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 829F3214: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 829F3218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F321C: 4E800421  bctrl
	ctx.lr = 0x829F3220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F3220: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 829F3224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3228: 419A0008  beq cr6, 0x829f3230
	if ctx.cr[6].eq {
	pc = 0x829F3230; continue 'dispatch;
	}
	// 829F322C: 4B8CD665  bl 0x822c0890
	ctx.lr = 0x829F3230;
	sub_822C0890(ctx, base);
	// 829F3230: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 829F3234: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F3238: 38A00DE7  li r5, 0xde7
	ctx.r[5].s64 = 3559;
	// 829F323C: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 829F3240: 483FF1A9  bl 0x82df23e8
	ctx.lr = 0x829F3244;
	sub_82DF23E8(ctx, base);
	// 829F3244: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F3248: 41820014  beq 0x829f325c
	if ctx.cr[0].eq {
	pc = 0x829F325C; continue 'dispatch;
	}
	// 829F324C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 829F3250: 4800D851  bl 0x82a00aa0
	ctx.lr = 0x829F3254;
	sub_82A00AA0(ctx, base);
	// 829F3254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3258: 48000008  b 0x829f3260
	pc = 0x829F3260; continue 'dispatch;
	// 829F325C: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 829F3260: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 829F3264: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F3268: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829F326C: 4BFFBA0D  bl 0x829eec78
	ctx.lr = 0x829F3270;
	sub_829EEC78(ctx, base);
	// 829F3270: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F3274: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F3278: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 829F327C: 4B8CCD85  bl 0x822c0000
	ctx.lr = 0x829F3280;
	sub_822C0000(ctx, base);
	// 829F3280: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 829F3284: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 829F3288: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F328C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 829F3290: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 829F3294: 419A0024  beq cr6, 0x829f32b8
	if ctx.cr[6].eq {
	pc = 0x829F32B8; continue 'dispatch;
	}
	// 829F3298: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 829F329C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F32A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F32A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F32A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F32AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F32B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F32B4: 4082FFE8  bne 0x829f329c
	if !ctx.cr[0].eq {
	pc = 0x829F329C; continue 'dispatch;
	}
	// 829F32B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829F32BC: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 829F32C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F32C4: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 829F32C8: 389900E8  addi r4, r25, 0xe8
	ctx.r[4].s64 = ctx.r[25].s64 + 232;
	// 829F32CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 829F32D0: 4846B3D9  bl 0x82e5e6a8
	ctx.lr = 0x829F32D4;
	sub_82E5E6A8(ctx, base);
	// 829F32D4: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 829F32D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F32DC: 419A0008  beq cr6, 0x829f32e4
	if ctx.cr[6].eq {
	pc = 0x829F32E4; continue 'dispatch;
	}
	// 829F32E0: 4B8CD5B1  bl 0x822c0890
	ctx.lr = 0x829F32E4;
	sub_822C0890(ctx, base);
	// 829F32E4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F32E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F32EC: 419A0008  beq cr6, 0x829f32f4
	if ctx.cr[6].eq {
	pc = 0x829F32F4; continue 'dispatch;
	}
	// 829F32F0: 4B8CD5A1  bl 0x822c0890
	ctx.lr = 0x829F32F4;
	sub_822C0890(ctx, base);
	// 829F32F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F32F8: 419A000C  beq cr6, 0x829f3304
	if ctx.cr[6].eq {
	pc = 0x829F3304; continue 'dispatch;
	}
	// 829F32FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3300: 4B8CD591  bl 0x822c0890
	ctx.lr = 0x829F3304;
	sub_822C0890(ctx, base);
	// 829F3304: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 829F3308: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	// 829F330C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829F3310: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3314: A90800F0  lha r8, 0xf0(r8)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(240 as u32) ) } as i16) as i64;
	// 829F3318: 2C080000  cmpwi r8, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 829F331C: 41810008  bgt 0x829f3324
	if ctx.cr[0].gt {
	pc = 0x829F3324; continue 'dispatch;
	}
	// 829F3320: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829F3324: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3328: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F332C: 4082FFE4  bne 0x829f3310
	if !ctx.cr[0].eq {
	pc = 0x829F3310; continue 'dispatch;
	}
	// 829F3330: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 829F3334: 40990008  ble cr6, 0x829f333c
	if !ctx.cr[6].gt {
	pc = 0x829F333C; continue 'dispatch;
	}
	// 829F3338: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 829F333C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 829F3340: 41980024  blt cr6, 0x829f3364
	if ctx.cr[6].lt {
	pc = 0x829F3364; continue 'dispatch;
	}
	// 829F3344: 419A0018  beq cr6, 0x829f335c
	if ctx.cr[6].eq {
	pc = 0x829F335C; continue 'dispatch;
	}
	// 829F3348: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 829F334C: 4098001C  bge cr6, 0x829f3368
	if !ctx.cr[6].lt {
	pc = 0x829F3368; continue 'dispatch;
	}
	// 829F3350: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829F3354: 91790244  stw r11, 0x244(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(580 as u32), ctx.r[11].u32 ) };
	// 829F3358: 48000010  b 0x829f3368
	pc = 0x829F3368; continue 'dispatch;
	// 829F335C: 92B90244  stw r21, 0x244(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(580 as u32), ctx.r[21].u32 ) };
	// 829F3360: 48000008  b 0x829f3368
	pc = 0x829F3368; continue 'dispatch;
	// 829F3364: 92990244  stw r20, 0x244(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(580 as u32), ctx.r[20].u32 ) };
	// 829F3368: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F336C: 9B0B00FC  stb r24, 0xfc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[24].u8 ) };
	// 829F3370: 35EFFFFF  addic. r15, r15, -1
	ctx.xer.ca = (ctx.r[15].u32 > (!(-1 as u32)));
	ctx.r[15].s64 = ctx.r[15].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[15].s32, 0, &mut ctx.xer);
	// 829F3374: 3AD60008  addi r22, r22, 8
	ctx.r[22].s64 = ctx.r[22].s64 + 8;
	// 829F3378: 4082FC9C  bne 0x829f3014
	if !ctx.cr[0].eq {
	pc = 0x829F3014; continue 'dispatch;
	}
	// 829F337C: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 829F3380: CBC1FF60  lfd f30, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 829F3384: CBE1FF68  lfd f31, -0x98(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 829F3388: 487B4DFC  b 0x831a8184
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F3390 size=312
    let mut pc: u32 = 0x829F3390;
    'dispatch: loop {
        match pc {
            0x829F3390 => {
    //   block [0x829F3390..0x829F34C8)
	// 829F3390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3394: 487B4DD5  bl 0x831a8168
	ctx.lr = 0x829F3398;
	sub_831A8130(ctx, base);
	// 829F3398: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F339C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F33A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F33A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 829F33A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F33AC: 388B675C  addi r4, r11, 0x675c
	ctx.r[4].s64 = ctx.r[11].s64 + 26460;
	// 829F33B0: 38A006DA  li r5, 0x6da
	ctx.r[5].s64 = 1754;
	// 829F33B4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 829F33B8: 483FF031  bl 0x82df23e8
	ctx.lr = 0x829F33BC;
	sub_82DF23E8(ctx, base);
	// 829F33BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829F33C0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F33C4: 41820010  beq 0x829f33d4
	if ctx.cr[0].eq {
	pc = 0x829F33D4; continue 'dispatch;
	}
	// 829F33C8: 4BC09BA9  bl 0x825fcf70
	ctx.lr = 0x829F33CC;
	sub_825FCF70(ctx, base);
	// 829F33CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F33D0: 48000008  b 0x829f33d8
	pc = 0x829F33D8; continue 'dispatch;
	// 829F33D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 829F33D8: 3BDF0158  addi r30, r31, 0x158
	ctx.r[30].s64 = ctx.r[31].s64 + 344;
	// 829F33DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F33E0: 4BC08419  bl 0x825fb7f8
	ctx.lr = 0x829F33E4;
	sub_825FB7F8(ctx, base);
	// 829F33E4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 829F33E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F33EC: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 829F33F0: 48423451  bl 0x82e16840
	ctx.lr = 0x829F33F4;
	sub_82E16840(ctx, base);
	// 829F33F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 829F33F8: 807F0158  lwz r3, 0x158(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829F33FC: 48423F65  bl 0x82e17360
	ctx.lr = 0x829F3400;
	sub_82E17360(ctx, base);
	// 829F3400: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F3404: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3408: 3BCB688C  addi r30, r11, 0x688c
	ctx.r[30].s64 = ctx.r[11].s64 + 26764;
	// 829F340C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F3410: 83BF0158  lwz r29, 0x158(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829F3414: 4840611D  bl 0x82df9530
	ctx.lr = 0x829F3418;
	sub_82DF9530(ctx, base);
	// 829F3418: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F341C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 829F3420: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F3424: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3428: 48424321  bl 0x82e17748
	ctx.lr = 0x829F342C;
	sub_82E17748(ctx, base);
	// 829F342C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F3430: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3434: 83DF0158  lwz r30, 0x158(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829F3438: 484060F9  bl 0x82df9530
	ctx.lr = 0x829F343C;
	sub_82DF9530(ctx, base);
	// 829F343C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 829F3440: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 829F3444: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 829F3448: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F344C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3450: C02B0B54  lfs f1, 0xb54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2900 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F3454: 484236D5  bl 0x82e16b28
	ctx.lr = 0x829F3458;
	sub_82E16B28(ctx, base);
	// 829F3458: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829F345C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 829F3460: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 829F3464: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 829F3468: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829F346C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F3470: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 829F3474: 4BFFF2E5  bl 0x829f2758
	ctx.lr = 0x829F3478;
	sub_829F2758(ctx, base);
	// 829F3478: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829F347C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3480: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F3484: 483FFC6D  bl 0x82df30f0
	ctx.lr = 0x829F3488;
	sub_82DF30F0(ctx, base);
	// 829F3488: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 829F348C: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 829F3490: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 829F3494: 4BFFF20D  bl 0x829f26a0
	ctx.lr = 0x829F3498;
	sub_829F26A0(ctx, base);
	// 829F3498: 397F016C  addi r11, r31, 0x16c
	ctx.r[11].s64 = ctx.r[31].s64 + 364;
	// 829F349C: 815F016C  lwz r10, 0x16c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 829F34A0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 829F34A4: 817F0158  lwz r11, 0x158(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) } as u64;
	// 829F34A8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F34AC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F34B0: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 829F34B4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 829F34B8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F34BC: 4B8D0FA5  bl 0x822c4460
	ctx.lr = 0x829F34C0;
	sub_822C4460(ctx, base);
	// 829F34C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F34C4: 487B4CF4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F34C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F34C8 size=156
    let mut pc: u32 = 0x829F34C8;
    'dispatch: loop {
        match pc {
            0x829F34C8 => {
    //   block [0x829F34C8..0x829F3564)
	// 829F34C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F34CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F34D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F34D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F34D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F34DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F34E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F34E4: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F34E8: 4BFFCCE1  bl 0x829f01c8
	ctx.lr = 0x829F34EC;
	sub_829F01C8(ctx, base);
	// 829F34EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F34F0: 4BFFD819  bl 0x829f0d08
	ctx.lr = 0x829F34F4;
	sub_829F0D08(ctx, base);
	// 829F34F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F34F8: 4BFFFAC1  bl 0x829f2fb8
	ctx.lr = 0x829F34FC;
	sub_829F2FB8(ctx, base);
	// 829F34FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 829F3500: 395F0334  addi r10, r31, 0x334
	ctx.r[10].s64 = ctx.r[31].s64 + 820;
	// 829F3504: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 829F3508: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F350C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 829F3510: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3514: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F3518: A12700F0  lhz r9, 0xf0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(240 as u32) ) } as u64;
	// 829F351C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 829F3520: 7D290734  extsh r9, r9
	ctx.r[9].s64 = ctx.r[9].s16 as i64;
	// 829F3524: 4082FFE4  bne 0x829f3508
	if !ctx.cr[0].eq {
	pc = 0x829F3508; continue 'dispatch;
	}
	// 829F3528: B13F0308  sth r9, 0x308(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(776 as u32), ctx.r[9].u16 ) };
	// 829F352C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F3530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3534: 4BB1D1D5  bl 0x82510708
	ctx.lr = 0x829F3538;
	sub_82510708(ctx, base);
	// 829F3538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F353C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829F3540: 48469939  bl 0x82e5ce78
	ctx.lr = 0x829F3544;
	sub_82E5CE78(ctx, base);
	// 829F3544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3548: 4BFFD999  bl 0x829f0ee0
	ctx.lr = 0x829F354C;
	sub_829F0EE0(ctx, base);
	// 829F354C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F3550: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F3554: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F3558: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F355C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F3560: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F3568 size=96
    let mut pc: u32 = 0x829F3568;
    'dispatch: loop {
        match pc {
            0x829F3568 => {
    //   block [0x829F3568..0x829F35C8)
	// 829F3568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F356C: 487B4C01  bl 0x831a816c
	ctx.lr = 0x829F3570;
	sub_831A8130(ctx, base);
	// 829F3570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3578: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F357C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 829F3580: 419A0030  beq cr6, 0x829f35b0
	if ctx.cr[6].eq {
	pc = 0x829F35B0; continue 'dispatch;
	}
	// 829F3584: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 829F3588: 48000010  b 0x829f3598
	pc = 0x829F3598; continue 'dispatch;
	// 829F358C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F3590: 4BABDD11  bl 0x824b12a0
	ctx.lr = 0x829F3594;
	sub_824B12A0(ctx, base);
	// 829F3594: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 829F3598: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 829F359C: 409AFFF0  bne cr6, 0x829f358c
	if !ctx.cr[6].eq {
	pc = 0x829F358C; continue 'dispatch;
	}
	// 829F35A0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 829F35A4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 829F35A8: 806B110C  lwz r3, 0x110c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4364 as u32) ) } as u64;
	// 829F35AC: 483FEBDD  bl 0x82df2188
	ctx.lr = 0x829F35B0;
	sub_82DF2188(ctx, base);
	// 829F35B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F35B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F35B8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 829F35BC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 829F35C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F35C4: 487B4BF8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F35C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F35C8 size=616
    let mut pc: u32 = 0x829F35C8;
    'dispatch: loop {
        match pc {
            0x829F35C8 => {
    //   block [0x829F35C8..0x829F3830)
	// 829F35C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F35CC: 487B4B95  bl 0x831a8160
	ctx.lr = 0x829F35D0;
	sub_831A8130(ctx, base);
	// 829F35D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F35D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F35D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F35DC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F35E0: 396B6914  addi r11, r11, 0x6914
	ctx.r[11].s64 = ctx.r[11].s64 + 26900;
	// 829F35E4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F35E8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829F35EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F35F0: 394A6900  addi r10, r10, 0x6900
	ctx.r[10].s64 = ctx.r[10].s64 + 26880;
	// 829F35F4: 392968B4  addi r9, r9, 0x68b4
	ctx.r[9].s64 = ctx.r[9].s64 + 26804;
	// 829F35F8: 396868A0  addi r11, r8, 0x68a0
	ctx.r[11].s64 = ctx.r[8].s64 + 26784;
	// 829F35FC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 829F3600: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 829F3604: 3B7F00E4  addi r27, r31, 0xe4
	ctx.r[27].s64 = ctx.r[31].s64 + 228;
	// 829F3608: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829F360C: 3B5F00E8  addi r26, r31, 0xe8
	ctx.r[26].s64 = ctx.r[31].s64 + 232;
	// 829F3610: 807F0464  lwz r3, 0x464(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1124 as u32) ) } as u64;
	// 829F3614: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3618: 419A0008  beq cr6, 0x829f3620
	if ctx.cr[6].eq {
	pc = 0x829F3620; continue 'dispatch;
	}
	// 829F361C: 4B8CD275  bl 0x822c0890
	ctx.lr = 0x829F3620;
	sub_822C0890(ctx, base);
	// 829F3620: 807F0450  lwz r3, 0x450(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1104 as u32) ) } as u64;
	// 829F3624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3628: 419A0008  beq cr6, 0x829f3630
	if ctx.cr[6].eq {
	pc = 0x829F3630; continue 'dispatch;
	}
	// 829F362C: 4B8CD265  bl 0x822c0890
	ctx.lr = 0x829F3630;
	sub_822C0890(ctx, base);
	// 829F3630: 397F044C  addi r11, r31, 0x44c
	ctx.r[11].s64 = ctx.r[31].s64 + 1100;
	// 829F3634: 3BA00013  li r29, 0x13
	ctx.r[29].s64 = 19;
	// 829F3638: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829F363C: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829F3640: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3648: 419A0008  beq cr6, 0x829f3650
	if ctx.cr[6].eq {
	pc = 0x829F3650; continue 'dispatch;
	}
	// 829F364C: 4B8CD245  bl 0x822c0890
	ctx.lr = 0x829F3650;
	sub_822C0890(ctx, base);
	// 829F3650: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F3654: 4080FFE8  bge 0x829f363c
	if !ctx.cr[0].lt {
	pc = 0x829F363C; continue 'dispatch;
	}
	// 829F3658: 807F03A8  lwz r3, 0x3a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(936 as u32) ) } as u64;
	// 829F365C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3660: 419A0008  beq cr6, 0x829f3668
	if ctx.cr[6].eq {
	pc = 0x829F3668; continue 'dispatch;
	}
	// 829F3664: 4B8CD22D  bl 0x822c0890
	ctx.lr = 0x829F3668;
	sub_822C0890(ctx, base);
	// 829F3668: 807F03A0  lwz r3, 0x3a0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(928 as u32) ) } as u64;
	// 829F366C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3670: 419A0008  beq cr6, 0x829f3678
	if ctx.cr[6].eq {
	pc = 0x829F3678; continue 'dispatch;
	}
	// 829F3674: 4B8CD21D  bl 0x822c0890
	ctx.lr = 0x829F3678;
	sub_822C0890(ctx, base);
	// 829F3678: 807F038C  lwz r3, 0x38c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(908 as u32) ) } as u64;
	// 829F367C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3680: 419A0008  beq cr6, 0x829f3688
	if ctx.cr[6].eq {
	pc = 0x829F3688; continue 'dispatch;
	}
	// 829F3684: 4B8CD20D  bl 0x822c0890
	ctx.lr = 0x829F3688;
	sub_822C0890(ctx, base);
	// 829F3688: 807F0384  lwz r3, 0x384(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(900 as u32) ) } as u64;
	// 829F368C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3690: 419A0008  beq cr6, 0x829f3698
	if ctx.cr[6].eq {
	pc = 0x829F3698; continue 'dispatch;
	}
	// 829F3694: 4B8CD1FD  bl 0x822c0890
	ctx.lr = 0x829F3698;
	sub_822C0890(ctx, base);
	// 829F3698: 387F0364  addi r3, r31, 0x364
	ctx.r[3].s64 = ctx.r[31].s64 + 868;
	// 829F369C: 4BFFFECD  bl 0x829f3568
	ctx.lr = 0x829F36A0;
	sub_829F3568(ctx, base);
	// 829F36A0: 3BDF0018  addi r30, r31, 0x18
	ctx.r[30].s64 = ctx.r[31].s64 + 24;
	// 829F36A4: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 829F36A8: 397E034C  addi r11, r30, 0x34c
	ctx.r[11].s64 = ctx.r[30].s64 + 844;
	// 829F36AC: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 829F36B0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 829F36B4: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F36B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F36BC: 419A0008  beq cr6, 0x829f36c4
	if ctx.cr[6].eq {
	pc = 0x829F36C4; continue 'dispatch;
	}
	// 829F36C0: 4B8CD1D1  bl 0x822c0890
	ctx.lr = 0x829F36C4;
	sub_822C0890(ctx, base);
	// 829F36C4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829F36C8: 4080FFE8  bge 0x829f36b0
	if !ctx.cr[0].lt {
	pc = 0x829F36B0; continue 'dispatch;
	}
	// 829F36CC: 397E0334  addi r11, r30, 0x334
	ctx.r[11].s64 = ctx.r[30].s64 + 820;
	// 829F36D0: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 829F36D4: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829F36D8: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829F36DC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F36E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F36E4: 419A0008  beq cr6, 0x829f36ec
	if ctx.cr[6].eq {
	pc = 0x829F36EC; continue 'dispatch;
	}
	// 829F36E8: 4B8CD1A9  bl 0x822c0890
	ctx.lr = 0x829F36EC;
	sub_822C0890(ctx, base);
	// 829F36EC: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F36F0: 4080FFE8  bge 0x829f36d8
	if !ctx.cr[0].lt {
	pc = 0x829F36D8; continue 'dispatch;
	}
	// 829F36F4: 397F0300  addi r11, r31, 0x300
	ctx.r[11].s64 = ctx.r[31].s64 + 768;
	// 829F36F8: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 829F36FC: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829F3700: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829F3704: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F370C: 419A0008  beq cr6, 0x829f3714
	if ctx.cr[6].eq {
	pc = 0x829F3714; continue 'dispatch;
	}
	// 829F3710: 4B8CD181  bl 0x822c0890
	ctx.lr = 0x829F3714;
	sub_822C0890(ctx, base);
	// 829F3714: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F3718: 4080FFE8  bge 0x829f3700
	if !ctx.cr[0].lt {
	pc = 0x829F3700; continue 'dispatch;
	}
	// 829F371C: 397F02A8  addi r11, r31, 0x2a8
	ctx.r[11].s64 = ctx.r[31].s64 + 680;
	// 829F3720: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 829F3724: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829F3728: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829F372C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3734: 419A0008  beq cr6, 0x829f373c
	if ctx.cr[6].eq {
	pc = 0x829F373C; continue 'dispatch;
	}
	// 829F3738: 4B8CD159  bl 0x822c0890
	ctx.lr = 0x829F373C;
	sub_822C0890(ctx, base);
	// 829F373C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F3740: 4080FFE8  bge 0x829f3728
	if !ctx.cr[0].lt {
	pc = 0x829F3728; continue 'dispatch;
	}
	// 829F3744: 807F0214  lwz r3, 0x214(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 829F3748: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F374C: 419A0008  beq cr6, 0x829f3754
	if ctx.cr[6].eq {
	pc = 0x829F3754; continue 'dispatch;
	}
	// 829F3750: 4B8CD141  bl 0x822c0890
	ctx.lr = 0x829F3754;
	sub_822C0890(ctx, base);
	// 829F3754: 397F01F0  addi r11, r31, 0x1f0
	ctx.r[11].s64 = ctx.r[31].s64 + 496;
	// 829F3758: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 829F375C: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829F3760: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829F3764: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3768: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F376C: 419A0008  beq cr6, 0x829f3774
	if ctx.cr[6].eq {
	pc = 0x829F3774; continue 'dispatch;
	}
	// 829F3770: 4B8CD121  bl 0x822c0890
	ctx.lr = 0x829F3774;
	sub_822C0890(ctx, base);
	// 829F3774: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F3778: 4080FFE8  bge 0x829f3760
	if !ctx.cr[0].lt {
	pc = 0x829F3760; continue 'dispatch;
	}
	// 829F377C: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 829F3780: 3B800005  li r28, 5
	ctx.r[28].s64 = 5;
	// 829F3784: 397E019C  addi r11, r30, 0x19c
	ctx.r[11].s64 = ctx.r[30].s64 + 412;
	// 829F3788: 3BAB0004  addi r29, r11, 4
	ctx.r[29].s64 = ctx.r[11].s64 + 4;
	// 829F378C: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 829F3790: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F3794: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3798: 419A0008  beq cr6, 0x829f37a0
	if ctx.cr[6].eq {
	pc = 0x829F37A0; continue 'dispatch;
	}
	// 829F379C: 4B8CD0F5  bl 0x822c0890
	ctx.lr = 0x829F37A0;
	sub_822C0890(ctx, base);
	// 829F37A0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 829F37A4: 4080FFE8  bge 0x829f378c
	if !ctx.cr[0].lt {
	pc = 0x829F378C; continue 'dispatch;
	}
	// 829F37A8: 397E016C  addi r11, r30, 0x16c
	ctx.r[11].s64 = ctx.r[30].s64 + 364;
	// 829F37AC: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 829F37B0: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 829F37B4: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 829F37B8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F37BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F37C0: 419A0008  beq cr6, 0x829f37c8
	if ctx.cr[6].eq {
	pc = 0x829F37C8; continue 'dispatch;
	}
	// 829F37C4: 4B8CD0CD  bl 0x822c0890
	ctx.lr = 0x829F37C8;
	sub_822C0890(ctx, base);
	// 829F37C8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 829F37CC: 4080FFE8  bge 0x829f37b4
	if !ctx.cr[0].lt {
	pc = 0x829F37B4; continue 'dispatch;
	}
	// 829F37D0: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 829F37D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F37D8: 419A0008  beq cr6, 0x829f37e0
	if ctx.cr[6].eq {
	pc = 0x829F37E0; continue 'dispatch;
	}
	// 829F37DC: 4B8CD0B5  bl 0x822c0890
	ctx.lr = 0x829F37E0;
	sub_822C0890(ctx, base);
	// 829F37E0: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 829F37E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F37E8: 419A0008  beq cr6, 0x829f37f0
	if ctx.cr[6].eq {
	pc = 0x829F37F0; continue 'dispatch;
	}
	// 829F37EC: 4B8CD0A5  bl 0x822c0890
	ctx.lr = 0x829F37F0;
	sub_822C0890(ctx, base);
	// 829F37F0: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 829F37F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F37F8: 419A0008  beq cr6, 0x829f3800
	if ctx.cr[6].eq {
	pc = 0x829F3800; continue 'dispatch;
	}
	// 829F37FC: 4B8CD095  bl 0x822c0890
	ctx.lr = 0x829F3800;
	sub_822C0890(ctx, base);
	// 829F3800: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 829F3804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3808: 419A0008  beq cr6, 0x829f3810
	if ctx.cr[6].eq {
	pc = 0x829F3810; continue 'dispatch;
	}
	// 829F380C: 4B8CD085  bl 0x822c0890
	ctx.lr = 0x829F3810;
	sub_822C0890(ctx, base);
	// 829F3810: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 829F3814: 4846A035  bl 0x82e5d848
	ctx.lr = 0x829F3818;
	sub_82E5D848(ctx, base);
	// 829F3818: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F381C: 4BDB3E3D  bl 0x827a7658
	ctx.lr = 0x829F3820;
	sub_827A7658(ctx, base);
	// 829F3820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3824: 4B95BB2D  bl 0x8234f350
	ctx.lr = 0x829F3828;
	sub_8234F350(ctx, base);
	// 829F3828: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 829F382C: 487B4984  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F3830 size=8
    let mut pc: u32 = 0x829F3830;
    'dispatch: loop {
        match pc {
            0x829F3830 => {
    //   block [0x829F3830..0x829F3838)
	// 829F3830: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 829F3834: 480002DC  b 0x829f3b10
	sub_829F3B10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F3838 size=8
    let mut pc: u32 = 0x829F3838;
    'dispatch: loop {
        match pc {
            0x829F3838 => {
    //   block [0x829F3838..0x829F3840)
	// 829F3838: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 829F383C: 480002D4  b 0x829f3b10
	sub_829F3B10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F3840 size=8
    let mut pc: u32 = 0x829F3840;
    'dispatch: loop {
        match pc {
            0x829F3840 => {
    //   block [0x829F3840..0x829F3848)
	// 829F3840: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 829F3844: 480002CC  b 0x829f3b10
	sub_829F3B10(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F3848 size=712
    let mut pc: u32 = 0x829F3848;
    'dispatch: loop {
        match pc {
            0x829F3848 => {
    //   block [0x829F3848..0x829F3B10)
	// 829F3848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F384C: 487B491D  bl 0x831a8168
	ctx.lr = 0x829F3850;
	sub_831A8130(ctx, base);
	// 829F3850: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3854: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 829F3858: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 829F385C: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 829F3860: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 829F3864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3868: 4BB1E9F9  bl 0x82512260
	ctx.lr = 0x829F386C;
	sub_82512260(ctx, base);
	// 829F386C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 829F3870: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 829F3874: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 829F3878: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 829F387C: 4846A055  bl 0x82e5d8d0
	ctx.lr = 0x829F3880;
	sub_82E5D8D0(ctx, base);
	// 829F3880: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F3884: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 829F3888: 396B654C  addi r11, r11, 0x654c
	ctx.r[11].s64 = ctx.r[11].s64 + 25932;
	// 829F388C: 394A6914  addi r10, r10, 0x6914
	ctx.r[10].s64 = ctx.r[10].s64 + 26900;
	// 829F3890: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 829F3894: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 829F3898: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 829F389C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 829F38A0: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829F38A4: 39296900  addi r9, r9, 0x6900
	ctx.r[9].s64 = ctx.r[9].s64 + 26880;
	// 829F38A8: 394768A0  addi r10, r7, 0x68a0
	ctx.r[10].s64 = ctx.r[7].s64 + 26784;
	// 829F38AC: 390868B4  addi r8, r8, 0x68b4
	ctx.r[8].s64 = ctx.r[8].s64 + 26804;
	// 829F38B0: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 829F38B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F38B8: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 829F38BC: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 829F38C0: 395F016C  addi r10, r31, 0x16c
	ctx.r[10].s64 = ctx.r[31].s64 + 364;
	// 829F38C4: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 829F38C8: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 829F38CC: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 829F38D0: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 829F38D4: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 829F38D8: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 829F38DC: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 829F38E0: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 829F38E4: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 829F38E8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F38EC: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F38F0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F38F4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F38F8: 4080FFF0  bge 0x829f38e8
	if !ctx.cr[0].lt {
	pc = 0x829F38E8; continue 'dispatch;
	}
	// 829F38FC: 395F019C  addi r10, r31, 0x19c
	ctx.r[10].s64 = ctx.r[31].s64 + 412;
	// 829F3900: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 829F3904: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F3908: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F390C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F3910: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F3914: 4080FFF0  bge 0x829f3904
	if !ctx.cr[0].lt {
	pc = 0x829F3904; continue 'dispatch;
	}
	// 829F3918: 395F01D0  addi r10, r31, 0x1d0
	ctx.r[10].s64 = ctx.r[31].s64 + 464;
	// 829F391C: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 829F3920: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F3924: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F3928: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F392C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F3930: 4080FFF0  bge 0x829f3920
	if !ctx.cr[0].lt {
	pc = 0x829F3920; continue 'dispatch;
	}
	// 829F3934: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 829F3938: 917F0210  stw r11, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 829F393C: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 829F3940: 917F0214  stw r11, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[11].u32 ) };
	// 829F3944: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 829F3948: B17F0218  sth r11, 0x218(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u16 ) };
	// 829F394C: B17F021A  sth r11, 0x21a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(538 as u32), ctx.r[11].u16 ) };
	// 829F3950: 395F0250  addi r10, r31, 0x250
	ctx.r[10].s64 = ctx.r[31].s64 + 592;
	// 829F3954: 991F023C  stb r8, 0x23c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[8].u8 ) };
	// 829F3958: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 829F395C: C0076534  lfs f0, 0x6534(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(25908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F3960: 90DF0244  stw r6, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[6].u32 ) };
	// 829F3964: D01F0240  stfs f0, 0x240(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 829F3968: 911F0248  stw r8, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[8].u32 ) };
	// 829F396C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F3970: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F3974: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F3978: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F397C: 4080FFF0  bge 0x829f396c
	if !ctx.cr[0].lt {
	pc = 0x829F396C; continue 'dispatch;
	}
	// 829F3980: 395F02A8  addi r10, r31, 0x2a8
	ctx.r[10].s64 = ctx.r[31].s64 + 680;
	// 829F3984: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 829F3988: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F398C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F3990: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F3994: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F3998: 4080FFF0  bge 0x829f3988
	if !ctx.cr[0].lt {
	pc = 0x829F3988; continue 'dispatch;
	}
	// 829F399C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 829F39A0: 917F0310  stw r11, 0x310(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(784 as u32), ctx.r[11].u32 ) };
	// 829F39A4: 39200064  li r9, 0x64
	ctx.r[9].s64 = 100;
	// 829F39A8: 997F0330  stb r11, 0x330(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(816 as u32), ctx.r[11].u8 ) };
	// 829F39AC: 395F0334  addi r10, r31, 0x334
	ctx.r[10].s64 = ctx.r[31].s64 + 820;
	// 829F39B0: B13F0308  sth r9, 0x308(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(776 as u32), ctx.r[9].u16 ) };
	// 829F39B4: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829F39B8: C00808A4  lfs f0, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 829F39BC: D01F030C  stfs f0, 0x30c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(780 as u32), tmp.u32 ) };
	// 829F39C0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F39C4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F39C8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F39CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F39D0: 4080FFF0  bge 0x829f39c0
	if !ctx.cr[0].lt {
	pc = 0x829F39C0; continue 'dispatch;
	}
	// 829F39D4: 395F034C  addi r10, r31, 0x34c
	ctx.r[10].s64 = ctx.r[31].s64 + 844;
	// 829F39D8: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 829F39DC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F39E0: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F39E4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F39E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F39EC: 4080FFF0  bge 0x829f39dc
	if !ctx.cr[0].lt {
	pc = 0x829F39DC; continue 'dispatch;
	}
	// 829F39F0: 917F0368  stw r11, 0x368(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(872 as u32), ctx.r[11].u32 ) };
	// 829F39F4: 395F03AC  addi r10, r31, 0x3ac
	ctx.r[10].s64 = ctx.r[31].s64 + 940;
	// 829F39F8: 917F036C  stw r11, 0x36c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(876 as u32), ctx.r[11].u32 ) };
	// 829F39FC: 39200013  li r9, 0x13
	ctx.r[9].s64 = 19;
	// 829F3A00: 917F0370  stw r11, 0x370(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(880 as u32), ctx.r[11].u32 ) };
	// 829F3A04: 917F0380  stw r11, 0x380(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(896 as u32), ctx.r[11].u32 ) };
	// 829F3A08: 917F0384  stw r11, 0x384(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(900 as u32), ctx.r[11].u32 ) };
	// 829F3A0C: 917F0388  stw r11, 0x388(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(904 as u32), ctx.r[11].u32 ) };
	// 829F3A10: 917F038C  stw r11, 0x38c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(908 as u32), ctx.r[11].u32 ) };
	// 829F3A14: D01F0390  stfs f0, 0x390(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(912 as u32), tmp.u32 ) };
	// 829F3A18: D01F0394  stfs f0, 0x394(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(916 as u32), tmp.u32 ) };
	// 829F3A1C: D01F0398  stfs f0, 0x398(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(920 as u32), tmp.u32 ) };
	// 829F3A20: 917F039C  stw r11, 0x39c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(924 as u32), ctx.r[11].u32 ) };
	// 829F3A24: 917F03A0  stw r11, 0x3a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(928 as u32), ctx.r[11].u32 ) };
	// 829F3A28: 917F03A4  stw r11, 0x3a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(932 as u32), ctx.r[11].u32 ) };
	// 829F3A2C: 917F03A8  stw r11, 0x3a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(936 as u32), ctx.r[11].u32 ) };
	// 829F3A30: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F3A34: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F3A38: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 829F3A3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 829F3A40: 4080FFF0  bge 0x829f3a30
	if !ctx.cr[0].lt {
	pc = 0x829F3A30; continue 'dispatch;
	}
	// 829F3A44: 917F044C  stw r11, 0x44c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1100 as u32), ctx.r[11].u32 ) };
	// 829F3A48: 395F022C  addi r10, r31, 0x22c
	ctx.r[10].s64 = ctx.r[31].s64 + 556;
	// 829F3A4C: 917F0450  stw r11, 0x450(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1104 as u32), ctx.r[11].u32 ) };
	// 829F3A50: D01F0458  stfs f0, 0x458(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1112 as u32), tmp.u32 ) };
	// 829F3A54: 997F0454  stb r11, 0x454(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1108 as u32), ctx.r[11].u8 ) };
	// 829F3A58: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 829F3A5C: 997F0455  stb r11, 0x455(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1109 as u32), ctx.r[11].u8 ) };
	// 829F3A60: 997F045C  stb r11, 0x45c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1116 as u32), ctx.r[11].u8 ) };
	// 829F3A64: 917F0460  stw r11, 0x460(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1120 as u32), ctx.r[11].u32 ) };
	// 829F3A68: 917F0464  stw r11, 0x464(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1124 as u32), ctx.r[11].u32 ) };
	// 829F3A6C: B16AFFF0  sth r11, -0x10(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(-16 as u32), ctx.r[11].u16 ) };
	// 829F3A70: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 829F3A74: B16A0000  sth r11, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 829F3A78: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 829F3A7C: 4082FFF0  bne 0x829f3a6c
	if !ctx.cr[0].eq {
	pc = 0x829F3A6C; continue 'dispatch;
	}
	// 829F3A80: A17F021C  lhz r11, 0x21c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) } as u64;
	// 829F3A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3A88: A15F021E  lhz r10, 0x21e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(542 as u32) ) } as u64;
	// 829F3A8C: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 829F3A90: A13F0220  lhz r9, 0x220(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) } as u64;
	// 829F3A94: A11F0222  lhz r8, 0x222(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(546 as u32) ) } as u64;
	// 829F3A98: 614A1400  ori r10, r10, 0x1400
	ctx.r[10].u64 = ctx.r[10].u64 | 5120;
	// 829F3A9C: A0FF0224  lhz r7, 0x224(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 829F3AA0: 61290200  ori r9, r9, 0x200
	ctx.r[9].u64 = ctx.r[9].u64 | 512;
	// 829F3AA4: A0DF0234  lhz r6, 0x234(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 829F3AA8: 61080800  ori r8, r8, 0x800
	ctx.r[8].u64 = ctx.r[8].u64 | 2048;
	// 829F3AAC: A0BF0226  lhz r5, 0x226(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(550 as u32) ) } as u64;
	// 829F3AB0: 60E70020  ori r7, r7, 0x20
	ctx.r[7].u64 = ctx.r[7].u64 | 32;
	// 829F3AB4: A09F0236  lhz r4, 0x236(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(566 as u32) ) } as u64;
	// 829F3AB8: 60C60040  ori r6, r6, 0x40
	ctx.r[6].u64 = ctx.r[6].u64 | 64;
	// 829F3ABC: A3DF0228  lhz r30, 0x228(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 829F3AC0: 60A50222  ori r5, r5, 0x222
	ctx.r[5].u64 = ctx.r[5].u64 | 546;
	// 829F3AC4: A3BF0238  lhz r29, 0x238(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 829F3AC8: 60840004  ori r4, r4, 4
	ctx.r[4].u64 = ctx.r[4].u64 | 4;
	// 829F3ACC: A39F022A  lhz r28, 0x22a(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(554 as u32) ) } as u64;
	// 829F3AD0: 63DE0014  ori r30, r30, 0x14
	ctx.r[30].u64 = ctx.r[30].u64 | 20;
	// 829F3AD4: B17F021C  sth r11, 0x21c(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), ctx.r[11].u16 ) };
	// 829F3AD8: 63BD0008  ori r29, r29, 8
	ctx.r[29].u64 = ctx.r[29].u64 | 8;
	// 829F3ADC: 638B2000  ori r11, r28, 0x2000
	ctx.r[11].u64 = ctx.r[28].u64 | 8192;
	// 829F3AE0: B15F021E  sth r10, 0x21e(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(542 as u32), ctx.r[10].u16 ) };
	// 829F3AE4: B13F0220  sth r9, 0x220(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[9].u16 ) };
	// 829F3AE8: B11F0222  sth r8, 0x222(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(546 as u32), ctx.r[8].u16 ) };
	// 829F3AEC: B0FF0224  sth r7, 0x224(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[7].u16 ) };
	// 829F3AF0: B0DF0234  sth r6, 0x234(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[6].u16 ) };
	// 829F3AF4: B0BF0226  sth r5, 0x226(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(550 as u32), ctx.r[5].u16 ) };
	// 829F3AF8: B09F0236  sth r4, 0x236(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(566 as u32), ctx.r[4].u16 ) };
	// 829F3AFC: B3DF0228  sth r30, 0x228(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u16 ) };
	// 829F3B00: B3BF0238  sth r29, 0x238(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[29].u16 ) };
	// 829F3B04: B17F022A  sth r11, 0x22a(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(554 as u32), ctx.r[11].u16 ) };
	// 829F3B08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 829F3B0C: 487B46AC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F3B10 size=76
    let mut pc: u32 = 0x829F3B10;
    'dispatch: loop {
        match pc {
            0x829F3B10 => {
    //   block [0x829F3B10..0x829F3B5C)
	// 829F3B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3B14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F3B18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F3B1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F3B20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3B24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3B28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 829F3B2C: 4BFFFA9D  bl 0x829f35c8
	ctx.lr = 0x829F3B30;
	sub_829F35C8(ctx, base);
	// 829F3B30: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3B34: 4182000C  beq 0x829f3b40
	if ctx.cr[0].eq {
	pc = 0x829F3B40; continue 'dispatch;
	}
	// 829F3B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3B3C: 483FE89D  bl 0x82df23d8
	ctx.lr = 0x829F3B40;
	sub_82DF23D8(ctx, base);
	// 829F3B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3B44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F3B48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F3B4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F3B50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F3B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F3B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x829F3B60 size=424
    let mut pc: u32 = 0x829F3B60;
    'dispatch: loop {
        match pc {
            0x829F3B60 => {
    //   block [0x829F3B60..0x829F3D08)
	// 829F3B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3B64: 487B4601  bl 0x831a8164
	ctx.lr = 0x829F3B68;
	sub_831A8130(ctx, base);
	// 829F3B68: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3B6C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F3B70: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 829F3B74: 3BCB675C  addi r30, r11, 0x675c
	ctx.r[30].s64 = ctx.r[11].s64 + 26460;
	// 829F3B78: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 829F3B7C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F3B80: 38A001C0  li r5, 0x1c0
	ctx.r[5].s64 = 448;
	// 829F3B84: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 829F3B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F3B8C: 38600470  li r3, 0x470
	ctx.r[3].s64 = 1136;
	// 829F3B90: 483FE859  bl 0x82df23e8
	ctx.lr = 0x829F3B94;
	sub_82DF23E8(ctx, base);
	// 829F3B94: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F3B98: 41820010  beq 0x829f3ba8
	if ctx.cr[0].eq {
	pc = 0x829F3BA8; continue 'dispatch;
	}
	// 829F3B9C: 4BFFFCAD  bl 0x829f3848
	ctx.lr = 0x829F3BA0;
	sub_829F3848(ctx, base);
	// 829F3BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3BA4: 48000008  b 0x829f3bac
	pc = 0x829F3BAC; continue 'dispatch;
	// 829F3BA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F3BAC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 829F3BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F3BB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F3BB8: 4BFFA761  bl 0x829ee318
	ctx.lr = 0x829F3BBC;
	sub_829EE318(ctx, base);
	// 829F3BBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F3BC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F3BC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 829F3BC8: 4B8CC439  bl 0x822c0000
	ctx.lr = 0x829F3BCC;
	sub_822C0000(ctx, base);
	// 829F3BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 829F3BD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 829F3BD4: 38A001C1  li r5, 0x1c1
	ctx.r[5].s64 = 449;
	// 829F3BD8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 829F3BDC: 4B8CC7FD  bl 0x822c03d8
	ctx.lr = 0x829F3BE0;
	sub_822C03D8(ctx, base);
	// 829F3BE0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 829F3BE4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 829F3BE8: 418200B4  beq 0x829f3c9c
	if ctx.cr[0].eq {
	pc = 0x829F3C9C; continue 'dispatch;
	}
	// 829F3BEC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 829F3BF0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 829F3BF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F3BF8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 829F3BFC: 409A0008  bne cr6, 0x829f3c04
	if !ctx.cr[6].eq {
	pc = 0x829F3C04; continue 'dispatch;
	}
	// 829F3C00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F3C04: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 829F3C08: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F3C0C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 829F3C10: 419A0024  beq cr6, 0x829f3c34
	if ctx.cr[6].eq {
	pc = 0x829F3C34; continue 'dispatch;
	}
	// 829F3C14: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829F3C18: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 829F3C1C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F3C20: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 829F3C24: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 829F3C28: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F3C2C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F3C30: 4082FFE8  bne 0x829f3c18
	if !ctx.cr[0].eq {
	pc = 0x829F3C18; continue 'dispatch;
	}
	// 829F3C34: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 829F3C38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F3C3C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 829F3C40: 419A0024  beq cr6, 0x829f3c64
	if ctx.cr[6].eq {
	pc = 0x829F3C64; continue 'dispatch;
	}
	// 829F3C44: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 829F3C48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 829F3C4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F3C50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 829F3C54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 829F3C58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 829F3C5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 829F3C60: 4082FFE8  bne 0x829f3c48
	if !ctx.cr[0].eq {
	pc = 0x829F3C48; continue 'dispatch;
	}
	// 829F3C64: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 829F3C68: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 829F3C6C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 829F3C70: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 829F3C74: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 829F3C78: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 829F3C7C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 829F3C80: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 829F3C84: 4BDA52AD  bl 0x82798f30
	ctx.lr = 0x829F3C88;
	sub_82798F30(ctx, base);
	// 829F3C88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 829F3C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F3C90: 4BDA79D9  bl 0x8279b668
	ctx.lr = 0x829F3C94;
	sub_8279B668(ctx, base);
	// 829F3C94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 829F3C98: 48000008  b 0x829f3ca0
	pc = 0x829F3CA0; continue 'dispatch;
	// 829F3C9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 829F3CA0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 829F3CA4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 829F3CA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F3CAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F3CB0: 4BBA3FA1  bl 0x82597c50
	ctx.lr = 0x829F3CB4;
	sub_82597C50(ctx, base);
	// 829F3CB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 829F3CB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F3CBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F3CC0: 4B8CC341  bl 0x822c0000
	ctx.lr = 0x829F3CC4;
	sub_822C0000(ctx, base);
	// 829F3CC4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 829F3CC8: 41820024  beq 0x829f3cec
	if ctx.cr[0].eq {
	pc = 0x829F3CEC; continue 'dispatch;
	}
	// 829F3CCC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 829F3CD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3CD4: 419A0008  beq cr6, 0x829f3cdc
	if ctx.cr[6].eq {
	pc = 0x829F3CDC; continue 'dispatch;
	}
	// 829F3CD8: 4B8CCBB9  bl 0x822c0890
	ctx.lr = 0x829F3CDC;
	sub_822C0890(ctx, base);
	// 829F3CDC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 829F3CE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 829F3CE4: 419A0008  beq cr6, 0x829f3cec
	if ctx.cr[6].eq {
	pc = 0x829F3CEC; continue 'dispatch;
	}
	// 829F3CE8: 4B8CCBA9  bl 0x822c0890
	ctx.lr = 0x829F3CEC;
	sub_822C0890(ctx, base);
	// 829F3CEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 829F3CF0: 419A000C  beq cr6, 0x829f3cfc
	if ctx.cr[6].eq {
	pc = 0x829F3CFC; continue 'dispatch;
	}
	// 829F3CF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 829F3CF8: 4B8CCB99  bl 0x822c0890
	ctx.lr = 0x829F3CFC;
	sub_822C0890(ctx, base);
	// 829F3CFC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 829F3D00: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 829F3D04: 487B44B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F3D08 size=192
    let mut pc: u32 = 0x829F3D08;
    'dispatch: loop {
        match pc {
            0x829F3D08 => {
    //   block [0x829F3D08..0x829F3DC8)
	// 829F3D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3D0C: 487B4449  bl 0x831a8154
	ctx.lr = 0x829F3D10;
	sub_831A8130(ctx, base);
	// 829F3D10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F3D14: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 829F3D18: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 829F3D1C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 829F3D20: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 829F3D24: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F3D28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F3D2C: 40990094  ble cr6, 0x829f3dc0
	if !ctx.cr[6].gt {
	pc = 0x829F3DC0; continue 'dispatch;
	}
	// 829F3D30: 3AF90364  addi r23, r25, 0x364
	ctx.r[23].s64 = ctx.r[25].s64 + 868;
	// 829F3D34: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 829F3D38: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 829F3D3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 829F3D40: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 829F3D44: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 829F3D48: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 829F3D4C: 4BA37BE5  bl 0x8242b930
	ctx.lr = 0x829F3D50;
	sub_8242B930(ctx, base);
	// 829F3D50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F3D54: 4BABD54D  bl 0x824b12a0
	ctx.lr = 0x829F3D58;
	sub_824B12A0(ctx, base);
	// 829F3D58: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 829F3D5C: 579A1838  slwi r26, r28, 3
	ctx.r[26].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 829F3D60: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 829F3D64: 81780014  lwz r11, 0x14(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F3D68: 7D6BD02E  lwzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 829F3D6C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F3D70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 829F3D74: 419A0038  beq cr6, 0x829f3dac
	if ctx.cr[6].eq {
	pc = 0x829F3DAC; continue 'dispatch;
	}
	// 829F3D78: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 829F3D7C: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 829F3D80: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 829F3D84: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 829F3D88: 40980024  bge cr6, 0x829f3dac
	if !ctx.cr[6].lt {
	pc = 0x829F3DAC; continue 'dispatch;
	}
	// 829F3D8C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 829F3D90: 81790368  lwz r11, 0x368(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(872 as u32) ) } as u64;
	// 829F3D94: 7C8AF214  add r4, r10, r30
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 829F3D98: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 829F3D9C: 481BF36D  bl 0x82bb3108
	ctx.lr = 0x829F3DA0;
	sub_82BB3108(ctx, base);
	// 829F3DA0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 829F3DA4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 829F3DA8: 4BFFFFBC  b 0x829f3d64
	pc = 0x829F3D64; continue 'dispatch;
	// 829F3DAC: 8178000C  lwz r11, 0xc(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(12 as u32) ) } as u64;
	// 829F3DB0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 829F3DB4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 829F3DB8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 829F3DBC: 4198FF7C  blt cr6, 0x829f3d38
	if ctx.cr[6].lt {
	pc = 0x829F3D38; continue 'dispatch;
	}
	// 829F3DC0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 829F3DC4: 487B43E0  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F3DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x829F3DC8 size=14396
    let mut pc: u32 = 0x829F3DC8;
    'dispatch: loop {
        match pc {
            0x829F3DC8 => {
    //   block [0x829F3DC8..0x829F7604)
	// 829F3DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F3DCC: 487B4365  bl 0x831a8130
	ctx.lr = 0x829F3DD0;
	sub_831A8130(ctx, base);
	// 829F3DD0: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 829F3DD4: 487B4C75  bl 0x831a8a48
	ctx.lr = 0x829F3DD8;
	sub_831A8A40(ctx, base);
	// 829F3DD8: 3980FEB0  li r12, -0x150
	ctx.r[12].s64 = -336;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7608 size=52
    let mut pc: u32 = 0x829F7608;
    'dispatch: loop {
        match pc {
            0x829F7608 => {
    //   block [0x829F7608..0x829F763C)
	// 829F7608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F760C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7610: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7614: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7618: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F761C: 4875CFE5  bl 0x83154600
	ctx.lr = 0x829F7620;
	sub_83154600(ctx, base);
	// 829F7620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 829F7624: 4BFF825D  bl 0x829ef880
	ctx.lr = 0x829F7628;
	sub_829EF880(ctx, base);
	// 829F7628: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 829F762C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F7630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F7634: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7638: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_829F7640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x829F7640 size=196
    let mut pc: u32 = 0x829F7640;
    'dispatch: loop {
        match pc {
            0x829F7640 => {
    //   block [0x829F7640..0x829F7704)
	// 829F7640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 829F7644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 829F7648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 829F764C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 829F7650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 829F7654: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 829F7658: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F765C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 829F7660: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 829F7664: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F7668: 4B8C92D1  bl 0x822c0938
	ctx.lr = 0x829F766C;
	sub_822C0938(ctx, base);
	// 829F766C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 829F7670: 41820028  beq 0x829f7698
	if ctx.cr[0].eq {
	pc = 0x829F7698; continue 'dispatch;
	}
	// 829F7674: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 829F7678: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 829F767C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 829F7680: 392B7070  addi r9, r11, 0x7070
	ctx.r[9].s64 = ctx.r[11].s64 + 28784;
	// 829F7684: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 829F7688: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 829F768C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 829F7690: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 829F7694: 48000008  b 0x829f769c
	pc = 0x829F769C; continue 'dispatch;
	// 829F7698: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 829F769C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 829F76A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 829F76A4: 409A0044  bne cr6, 0x829f76e8
	if !ctx.cr[6].eq {
	pc = 0x829F76E8; continue 'dispatch;
	}
	// 829F76A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 829F76AC: 419A001C  beq cr6, 0x829f76c8
	if ctx.cr[6].eq {
	pc = 0x829F76C8; continue 'dispatch;
	}
	// 829F76B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F76B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 829F76B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 829F76BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 829F76C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 829F76C4: 4E800421  bctrl
	ctx.lr = 0x829F76C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 829F76C8: 3D60832E  lis r11, -0x7cd2
	ctx.r[11].s64 = -2094137344;
	// 829F76CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 829F76D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 829F76D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 829F76D8: 816BE058  lwz r11, -0x1fa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8104 as u32) ) } as u64;
	// 829F76DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 829F76E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 829F76E4: 4B8C891D  bl 0x822c0000
	ctx.lr = 0x829F76E8;
	sub_822C0000(ctx, base);
	// 829F76E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 829F76EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 829F76F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 829F76F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 829F76F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 829F76FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 829F7700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


