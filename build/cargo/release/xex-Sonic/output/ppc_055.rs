pub fn sub_825F8780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8780 size=196
    let mut pc: u32 = 0x825F8780;
    'dispatch: loop {
        match pc {
            0x825F8780 => {
    //   block [0x825F8780..0x825F8844)
	// 825F8780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F878C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8794: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8798: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F879C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825F87A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F87A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F87A8: 4BCC8191  bl 0x822c0938
	ctx.lr = 0x825F87AC;
	sub_822C0938(ctx, base);
	// 825F87AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F87B0: 41820028  beq 0x825f87d8
	if ctx.cr[0].eq {
	pc = 0x825F87D8; continue 'dispatch;
	}
	// 825F87B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F87B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825F87BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F87C0: 392B1480  addi r9, r11, 0x1480
	ctx.r[9].s64 = ctx.r[11].s64 + 5248;
	// 825F87C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F87C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F87CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825F87D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825F87D4: 48000008  b 0x825f87dc
	pc = 0x825F87DC; continue 'dispatch;
	// 825F87D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F87DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F87E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F87E4: 409A0044  bne cr6, 0x825f8828
	if !ctx.cr[6].eq {
	pc = 0x825F8828; continue 'dispatch;
	}
	// 825F87E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F87EC: 419A001C  beq cr6, 0x825f8808
	if ctx.cr[6].eq {
	pc = 0x825F8808; continue 'dispatch;
	}
	// 825F87F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F87F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F87F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F87FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8800: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825F8804: 4E800421  bctrl
	ctx.lr = 0x825F8808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825F8808: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F880C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F8810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F8814: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825F8818: 816BF6CC  lwz r11, -0x934(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2356 as u32) ) } as u64;
	// 825F881C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825F8820: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F8824: 4BCC77DD  bl 0x822c0000
	ctx.lr = 0x825F8828;
	sub_822C0000(ctx, base);
	// 825F8828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F882C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F8834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F8838: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F883C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F8848 size=212
    let mut pc: u32 = 0x825F8848;
    'dispatch: loop {
        match pc {
            0x825F8848 => {
    //   block [0x825F8848..0x825F891C)
	// 825F8848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F884C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F8854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F885C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8860: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F8864: 4BF19ACD  bl 0x82512330
	ctx.lr = 0x825F8868;
	sub_82512330(ctx, base);
	// 825F8868: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F886C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825F8870: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825F8874: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825F8878: 39291520  addi r9, r9, 0x1520
	ctx.r[9].s64 = ctx.r[9].s64 + 5408;
	// 825F887C: 390814D4  addi r8, r8, 0x14d4
	ctx.r[8].s64 = ctx.r[8].s64 + 5332;
	// 825F8880: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825F8884: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F8888: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825F888C: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825F8890: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F8894: 394A1494  addi r10, r10, 0x1494
	ctx.r[10].s64 = ctx.r[10].s64 + 5268;
	// 825F8898: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825F889C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825F88A0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825F88A4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 825F88A8: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825F88AC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825F88B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825F88B4: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 825F88B8: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825F88BC: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825F88C0: C009D5B8  lfs f0, -0x2a48(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F88C4: C1A89688  lfs f13, -0x6978(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27000 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F88C8: 93DF00F8  stw r30, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[30].u32 ) };
	// 825F88CC: C18708AC  lfs f12, 0x8ac(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2220 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825F88D0: 90DF00FC  stw r6, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[6].u32 ) };
	// 825F88D4: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 825F88D8: 915F0104  stw r10, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u32 ) };
	// 825F88DC: D1BF0118  stfs f13, 0x118(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 825F88E0: 915F0108  stw r10, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[10].u32 ) };
	// 825F88E4: D19F011C  stfs f12, 0x11c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 825F88E8: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825F88EC: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 825F88F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F88F4: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 825F88F8: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825F88FC: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 825F8900: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825F8904: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F890C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F8910: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F8914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F8920 size=8
    let mut pc: u32 = 0x825F8920;
    'dispatch: loop {
        match pc {
            0x825F8920 => {
    //   block [0x825F8920..0x825F8928)
	// 825F8920: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825F8924: 480005C4  b 0x825f8ee8
	sub_825F8EE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825F8928 size=8
    let mut pc: u32 = 0x825F8928;
    'dispatch: loop {
        match pc {
            0x825F8928 => {
    //   block [0x825F8928..0x825F8930)
	// 825F8928: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825F892C: 480005BC  b 0x825f8ee8
	sub_825F8EE8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8930 size=132
    let mut pc: u32 = 0x825F8930;
    'dispatch: loop {
        match pc {
            0x825F8930 => {
    //   block [0x825F8930..0x825F89B4)
	// 825F8930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8938: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F893C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8944: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825F8948: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F894C: 419A0008  beq cr6, 0x825f8954
	if ctx.cr[6].eq {
	pc = 0x825F8954; continue 'dispatch;
	}
	// 825F8950: 4BCC7F41  bl 0x822c0890
	ctx.lr = 0x825F8954;
	sub_822C0890(ctx, base);
	// 825F8954: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 825F8958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F895C: 419A0008  beq cr6, 0x825f8964
	if ctx.cr[6].eq {
	pc = 0x825F8964; continue 'dispatch;
	}
	// 825F8960: 4BCC7F31  bl 0x822c0890
	ctx.lr = 0x825F8964;
	sub_822C0890(ctx, base);
	// 825F8964: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825F8968: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F896C: 419A0008  beq cr6, 0x825f8974
	if ctx.cr[6].eq {
	pc = 0x825F8974; continue 'dispatch;
	}
	// 825F8970: 4BCC7F21  bl 0x822c0890
	ctx.lr = 0x825F8974;
	sub_822C0890(ctx, base);
	// 825F8974: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825F8978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F897C: 419A0008  beq cr6, 0x825f8984
	if ctx.cr[6].eq {
	pc = 0x825F8984; continue 'dispatch;
	}
	// 825F8980: 4BCC7F11  bl 0x822c0890
	ctx.lr = 0x825F8984;
	sub_822C0890(ctx, base);
	// 825F8984: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F8988: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 825F898C: 409A0008  bne cr6, 0x825f8994
	if !ctx.cr[6].eq {
	pc = 0x825F8994; continue 'dispatch;
	}
	// 825F8990: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F8994: 481AECC5  bl 0x827a7658
	ctx.lr = 0x825F8998;
	sub_827A7658(ctx, base);
	// 825F8998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F899C: 4BD569B5  bl 0x8234f350
	ctx.lr = 0x825F89A0;
	sub_8234F350(ctx, base);
	// 825F89A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825F89A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F89A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F89AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F89B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F89B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F89B8 size=468
    let mut pc: u32 = 0x825F89B8;
    'dispatch: loop {
        match pc {
            0x825F89B8 => {
    //   block [0x825F89B8..0x825F8B8C)
	// 825F89B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F89BC: 48BAF7AD  bl 0x831a8168
	ctx.lr = 0x825F89C0;
	sub_831A8130(ctx, base);
	// 825F89C0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825F89C4: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F89C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F89CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F89D0: 3B8B1530  addi r28, r11, 0x1530
	ctx.r[28].s64 = ctx.r[11].s64 + 5424;
	// 825F89D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F89D8: 38A001A6  li r5, 0x1a6
	ctx.r[5].s64 = 422;
	// 825F89DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825F89E0: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825F89E4: 487F9A05  bl 0x82df23e8
	ctx.lr = 0x825F89E8;
	sub_82DF23E8(ctx, base);
	// 825F89E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F89EC: 4182001C  beq 0x825f8a08
	if ctx.cr[0].eq {
	pc = 0x825F8A08; continue 'dispatch;
	}
	// 825F89F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F89F4: 48860C8D  bl 0x82e59680
	ctx.lr = 0x825F89F8;
	sub_82E59680(ctx, base);
	// 825F89F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F89FC: 396BF294  addi r11, r11, -0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + -3436;
	// 825F8A00: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8A04: 48000008  b 0x825f8a0c
	pc = 0x825F8A0C; continue 'dispatch;
	// 825F8A08: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F8A0C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F8A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8A14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8A18: 4BFE7EE9  bl 0x825e0900
	ctx.lr = 0x825F8A1C;
	sub_825E0900(ctx, base);
	// 825F8A1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F8A20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8A24: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8A28: 4BCC75D9  bl 0x822c0000
	ctx.lr = 0x825F8A2C;
	sub_822C0000(ctx, base);
	// 825F8A2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8A30: 4BF190B9  bl 0x82511ae8
	ctx.lr = 0x825F8A34;
	sub_82511AE8(ctx, base);
	// 825F8A34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F8A38: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F8A3C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825F8A40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8A44: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F8B90 size=468
    let mut pc: u32 = 0x825F8B90;
    'dispatch: loop {
        match pc {
            0x825F8B90 => {
    //   block [0x825F8B90..0x825F8D64)
	// 825F8B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8B94: 48BAF5D5  bl 0x831a8168
	ctx.lr = 0x825F8B98;
	sub_831A8130(ctx, base);
	// 825F8B98: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825F8B9C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8BA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F8BA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8BA8: 3B8B1530  addi r28, r11, 0x1530
	ctx.r[28].s64 = ctx.r[11].s64 + 5424;
	// 825F8BAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F8BB0: 38A001B3  li r5, 0x1b3
	ctx.r[5].s64 = 435;
	// 825F8BB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825F8BB8: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825F8BBC: 487F982D  bl 0x82df23e8
	ctx.lr = 0x825F8BC0;
	sub_82DF23E8(ctx, base);
	// 825F8BC0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F8BC4: 4182001C  beq 0x825f8be0
	if ctx.cr[0].eq {
	pc = 0x825F8BE0; continue 'dispatch;
	}
	// 825F8BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8BCC: 48860AB5  bl 0x82e59680
	ctx.lr = 0x825F8BD0;
	sub_82E59680(ctx, base);
	// 825F8BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F8BD4: 396BF294  addi r11, r11, -0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + -3436;
	// 825F8BD8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8BDC: 48000008  b 0x825f8be4
	pc = 0x825F8BE4; continue 'dispatch;
	// 825F8BE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F8BE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F8BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8BEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8BF0: 4BFE7D11  bl 0x825e0900
	ctx.lr = 0x825F8BF4;
	sub_825E0900(ctx, base);
	// 825F8BF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F8BF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8BFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8C00: 4BCC7401  bl 0x822c0000
	ctx.lr = 0x825F8C04;
	sub_822C0000(ctx, base);
	// 825F8C04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8C08: 4BF18EE1  bl 0x82511ae8
	ctx.lr = 0x825F8C0C;
	sub_82511AE8(ctx, base);
	// 825F8C0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F8C10: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F8C14: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825F8C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8C1C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8D68 size=112
    let mut pc: u32 = 0x825F8D68;
    'dispatch: loop {
        match pc {
            0x825F8D68 => {
    //   block [0x825F8D68..0x825F8DD8)
	// 825F8D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8D70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F8D74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8D7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F8D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8D84: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825F8D88: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8D8C: 4BFFF865  bl 0x825f85f0
	ctx.lr = 0x825F8D90;
	sub_825F85F0(ctx, base);
	// 825F8D90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F8D94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F8D98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8D9C: 4BCC7265  bl 0x822c0000
	ctx.lr = 0x825F8DA0;
	sub_822C0000(ctx, base);
	// 825F8DA0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F8DA4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F8DA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8DAC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F8DB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8DB4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F8DB8: 419A0008  beq cr6, 0x825f8dc0
	if ctx.cr[6].eq {
	pc = 0x825F8DC0; continue 'dispatch;
	}
	// 825F8DBC: 4BCC7AD5  bl 0x822c0890
	ctx.lr = 0x825F8DC0;
	sub_822C0890(ctx, base);
	// 825F8DC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8DC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F8DC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F8DCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F8DD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8DD8 size=112
    let mut pc: u32 = 0x825F8DD8;
    'dispatch: loop {
        match pc {
            0x825F8DD8 => {
    //   block [0x825F8DD8..0x825F8E48)
	// 825F8DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8DE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F8DE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8DE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8DEC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F8DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8DF4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825F8DF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8DFC: 4BFFF8BD  bl 0x825f86b8
	ctx.lr = 0x825F8E00;
	sub_825F86B8(ctx, base);
	// 825F8E00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F8E04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F8E08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F8E0C: 4BCC71F5  bl 0x822c0000
	ctx.lr = 0x825F8E10;
	sub_822C0000(ctx, base);
	// 825F8E10: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F8E14: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F8E18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825F8E1C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F8E20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8E24: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825F8E28: 419A0008  beq cr6, 0x825f8e30
	if ctx.cr[6].eq {
	pc = 0x825F8E30; continue 'dispatch;
	}
	// 825F8E2C: 4BCC7A65  bl 0x822c0890
	ctx.lr = 0x825F8E30;
	sub_822C0890(ctx, base);
	// 825F8E30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F8E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F8E3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F8E40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8E44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F8E48 size=160
    let mut pc: u32 = 0x825F8E48;
    'dispatch: loop {
        match pc {
            0x825F8E48 => {
    //   block [0x825F8E48..0x825F8EE8)
	// 825F8E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8E4C: 48BAF311  bl 0x831a815c
	ctx.lr = 0x825F8E50;
	sub_831A8130(ctx, base);
	// 825F8E50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8E54: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F8E58: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825F8E5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825F8E60: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825F8E64: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825F8E68: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F8E6C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825F8E70: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825F8E74: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 825F8E78: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825F8E7C: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825F8E80: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825F8E84: 487F9565  bl 0x82df23e8
	ctx.lr = 0x825F8E88;
	sub_82DF23E8(ctx, base);
	// 825F8E88: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F8E8C: 41820028  beq 0x825f8eb4
	if ctx.cr[0].eq {
	pc = 0x825F8EB4; continue 'dispatch;
	}
	// 825F8E90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F8E94: 893A0000  lbz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8E98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8E9C: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8EA0: 88FC0000  lbz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8EA4: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F8EA8: 4855D029  bl 0x82b55ed0
	ctx.lr = 0x825F8EAC;
	sub_82B55ED0(ctx, base);
	// 825F8EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8EB0: 48000008  b 0x825f8eb8
	pc = 0x825F8EB8; continue 'dispatch;
	// 825F8EB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F8EB8: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825F8EBC: 3BD90004  addi r30, r25, 4
	ctx.r[30].s64 = ctx.r[25].s64 + 4;
	// 825F8EC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8EC8: 4BFFF8B9  bl 0x825f8780
	ctx.lr = 0x825F8ECC;
	sub_825F8780(ctx, base);
	// 825F8ECC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F8ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F8ED4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8ED8: 4BCC7129  bl 0x822c0000
	ctx.lr = 0x825F8EDC;
	sub_822C0000(ctx, base);
	// 825F8EDC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825F8EE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825F8EE4: 48BAF2C8  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825F8EE8 size=76
    let mut pc: u32 = 0x825F8EE8;
    'dispatch: loop {
        match pc {
            0x825F8EE8 => {
    //   block [0x825F8EE8..0x825F8F34)
	// 825F8EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F8EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F8EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F8EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8EFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F8F00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F8F04: 4BFFFA2D  bl 0x825f8930
	ctx.lr = 0x825F8F08;
	sub_825F8930(ctx, base);
	// 825F8F08: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F8F0C: 4182000C  beq 0x825f8f18
	if ctx.cr[0].eq {
	pc = 0x825F8F18; continue 'dispatch;
	}
	// 825F8F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8F14: 487F94C5  bl 0x82df23d8
	ctx.lr = 0x825F8F18;
	sub_82DF23D8(ctx, base);
	// 825F8F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F8F1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F8F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F8F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F8F28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F8F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F8F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F8F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F8F38 size=896
    let mut pc: u32 = 0x825F8F38;
    'dispatch: loop {
        match pc {
            0x825F8F38 => {
    //   block [0x825F8F38..0x825F92B8)
	// 825F8F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F8F3C: 48BAF225  bl 0x831a8160
	ctx.lr = 0x825F8F40;
	sub_831A8130(ctx, base);
	// 825F8F40: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F8F44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F8F48: 2B04000F  cmplwi cr6, r4, 0xf
	ctx.cr[6].compare_u32(ctx.r[4].u32, 15 as u32, &mut ctx.xer);
	// 825F8F4C: 419A0024  beq cr6, 0x825f8f70
	if ctx.cr[6].eq {
	pc = 0x825F8F70; continue 'dispatch;
	}
	// 825F8F50: 2B04001E  cmplwi cr6, r4, 0x1e
	ctx.cr[6].compare_u32(ctx.r[4].u32, 30 as u32, &mut ctx.xer);
	// 825F8F54: 419A0014  beq cr6, 0x825f8f68
	if ctx.cr[6].eq {
	pc = 0x825F8F68; continue 'dispatch;
	}
	// 825F8F58: 3964FFD3  addi r11, r4, -0x2d
	ctx.r[11].s64 = ctx.r[4].s64 + -45;
	// 825F8F5C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825F8F60: 557BE7BC  rlwinm r27, r11, 0x1c, 0x1e, 0x1e
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825F8F64: 48000010  b 0x825f8f74
	pc = 0x825F8F74; continue 'dispatch;
	// 825F8F68: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825F8F6C: 48000008  b 0x825f8f74
	pc = 0x825F8F74; continue 'dispatch;
	// 825F8F70: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825F8F74: 817E00E8  lwz r11, 0xe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 825F8F78: 3BFE00E8  addi r31, r30, 0xe8
	ctx.r[31].s64 = ctx.r[30].s64 + 232;
	// 825F8F7C: 3F808335  lis r28, -0x7ccb
	ctx.r[28].s64 = -2093678592;
	// 825F8F80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F8F84: 419A0060  beq cr6, 0x825f8fe4
	if ctx.cr[6].eq {
	pc = 0x825F8FE4; continue 'dispatch;
	}
	// 825F8F88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F8F8C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F8F94: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F8F98: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825F8F9C: 419A0024  beq cr6, 0x825f8fc0
	if ctx.cr[6].eq {
	pc = 0x825F8FC0; continue 'dispatch;
	}
	// 825F8FA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F8FA4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F8FA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F8FAC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F8FB0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F8FB4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F8FB8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F8FBC: 4082FFE8  bne 0x825f8fa4
	if !ctx.cr[0].eq {
	pc = 0x825F8FA4; continue 'dispatch;
	}
	// 825F8FC0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F8FC4: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825F8FC8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825F8FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F8FD0: 4BF170F1  bl 0x825100c0
	ctx.lr = 0x825F8FD4;
	sub_825100C0(ctx, base);
	// 825F8FD4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F8FD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F8FDC: 419A0008  beq cr6, 0x825f8fe4
	if ctx.cr[6].eq {
	pc = 0x825F8FE4; continue 'dispatch;
	}
	// 825F8FE0: 4BCC78B1  bl 0x822c0890
	ctx.lr = 0x825F8FE4;
	sub_822C0890(ctx, base);
	// 825F8FE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F8FE8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F8FEC: 4BF164DD  bl 0x8250f4c8
	ctx.lr = 0x825F8FF0;
	sub_8250F4C8(ctx, base);
	// 825F8FF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F8FF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F8FF8: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F8FFC: 409A0008  bne cr6, 0x825f9004
	if !ctx.cr[6].eq {
	pc = 0x825F9004; continue 'dispatch;
	}
	// 825F9000: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F9004: 4BF0F525  bl 0x82508528
	ctx.lr = 0x825F9008;
	sub_82508528(ctx, base);
	// 825F9008: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F900C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825F9010: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9014: 48831AD5  bl 0x82e2aae8
	ctx.lr = 0x825F9018;
	sub_82E2AAE8(ctx, base);
	// 825F9018: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825F901C: 487F8C75  bl 0x82df1c90
	ctx.lr = 0x825F9020;
	sub_82DF1C90(ctx, base);
	// 825F9020: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825F9024: 3BABF68C  addi r29, r11, -0x974
	ctx.r[29].s64 = ctx.r[11].s64 + -2420;
	// 825F9028: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 825F902C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F9030: 41980024  blt cr6, 0x825f9054
	if ctx.cr[6].lt {
	pc = 0x825F9054; continue 'dispatch;
	}
	// 825F9034: 419A000C  beq cr6, 0x825f9040
	if ctx.cr[6].eq {
	pc = 0x825F9040; continue 'dispatch;
	}
	// 825F9038: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F903C: 48000020  b 0x825f905c
	pc = 0x825F905C; continue 'dispatch;
	// 825F9040: 817E0104  lwz r11, 0x104(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) } as u64;
	// 825F9044: 395D0028  addi r10, r29, 0x28
	ctx.r[10].s64 = ctx.r[29].s64 + 40;
	// 825F9048: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825F904C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825F9050: 4800000C  b 0x825f905c
	pc = 0x825F905C; continue 'dispatch;
	// 825F9054: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825F9058: 7C8BE82E  lwzx r4, r11, r29
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825F905C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F9060: 487FA9A9  bl 0x82df3a08
	ctx.lr = 0x825F9064;
	sub_82DF3A08(ctx, base);
	// 825F9064: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F9068: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F906C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825F9070: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F9074: 48835DFD  bl 0x82e2ee70
	ctx.lr = 0x825F9078;
	sub_82E2EE70(ctx, base);
	// 825F9078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F907C: 487FA3AD  bl 0x82df3428
	ctx.lr = 0x825F9080;
	sub_82DF3428(ctx, base);
	// 825F9080: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825F9084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9088: 419A00D0  beq cr6, 0x825f9158
	if ctx.cr[6].eq {
	pc = 0x825F9158; continue 'dispatch;
	}
	// 825F908C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9090: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F9094: 388B1530  addi r4, r11, 0x1530
	ctx.r[4].s64 = ctx.r[11].s64 + 5424;
	// 825F9098: 38A0010B  li r5, 0x10b
	ctx.r[5].s64 = 267;
	// 825F909C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825F90A0: 487F9349  bl 0x82df23e8
	ctx.lr = 0x825F90A4;
	sub_82DF23E8(ctx, base);
	// 825F90A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F90A8: 41820014  beq 0x825f90bc
	if ctx.cr[0].eq {
	pc = 0x825F90BC; continue 'dispatch;
	}
	// 825F90AC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825F90B0: 4881D7E1  bl 0x82e16890
	ctx.lr = 0x825F90B4;
	sub_82E16890(ctx, base);
	// 825F90B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F90B8: 48000008  b 0x825f90c0
	pc = 0x825F90C0; continue 'dispatch;
	// 825F90BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F90C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F90C4: 4BD642AD  bl 0x8235d370
	ctx.lr = 0x825F90C8;
	sub_8235D370(ctx, base);
	// 825F90C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F90CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F90D0: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F90D4: 4BF19045  bl 0x82512118
	ctx.lr = 0x825F90D8;
	sub_82512118(ctx, base);
	// 825F90D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F90DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F90E0: 4881BFD1  bl 0x82e150b0
	ctx.lr = 0x825F90E4;
	sub_82E150B0(ctx, base);
	// 825F90E4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F90E8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F90EC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F90F0: C04B74AC  lfs f2, 0x74ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(29868 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F90F4: C02A7DF0  lfs f1, 0x7df0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32240 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F90F8: 4881BF31  bl 0x82e15028
	ctx.lr = 0x825F90FC;
	sub_82E15028(ctx, base);
	// 825F90FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F9100: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9108: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825F910C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825F9110: 419A0024  beq cr6, 0x825f9134
	if ctx.cr[6].eq {
	pc = 0x825F9134; continue 'dispatch;
	}
	// 825F9114: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F9118: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F911C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9120: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F9124: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F9128: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F912C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9130: 4082FFE8  bne 0x825f9118
	if !ctx.cr[0].eq {
	pc = 0x825F9118; continue 'dispatch;
	}
	// 825F9134: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825F9138: 809C7058  lwz r4, 0x7058(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825F913C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825F9140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F9144: 4BF178B5  bl 0x825109f8
	ctx.lr = 0x825F9148;
	sub_825109F8(ctx, base);
	// 825F9148: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F914C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9150: 419A0008  beq cr6, 0x825f9158
	if ctx.cr[6].eq {
	pc = 0x825F9158; continue 'dispatch;
	}
	// 825F9154: 4BCC773D  bl 0x822c0890
	ctx.lr = 0x825F9158;
	sub_822C0890(ctx, base);
	// 825F9158: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F915C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F9160: 4BF16369  bl 0x8250f4c8
	ctx.lr = 0x825F9164;
	sub_8250F4C8(ctx, base);
	// 825F9164: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F916C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F9170: 409A0008  bne cr6, 0x825f9178
	if !ctx.cr[6].eq {
	pc = 0x825F9178; continue 'dispatch;
	}
	// 825F9174: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F9178: 4BF0F3B1  bl 0x82508528
	ctx.lr = 0x825F917C;
	sub_82508528(ctx, base);
	// 825F917C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F9180: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F9184: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9188: 4BCEE081  bl 0x822e7208
	ctx.lr = 0x825F918C;
	sub_822E7208(ctx, base);
	// 825F918C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F9190: 487F8B01  bl 0x82df1c90
	ctx.lr = 0x825F9194;
	sub_82DF1C90(ctx, base);
	// 825F9194: 817E00F8  lwz r11, 0xf8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(248 as u32) ) } as u64;
	// 825F9198: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F919C: 41980024  blt cr6, 0x825f91c0
	if ctx.cr[6].lt {
	pc = 0x825F91C0; continue 'dispatch;
	}
	// 825F91A0: 419A000C  beq cr6, 0x825f91ac
	if ctx.cr[6].eq {
	pc = 0x825F91AC; continue 'dispatch;
	}
	// 825F91A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F91A8: 48000020  b 0x825f91c8
	pc = 0x825F91C8; continue 'dispatch;
	// 825F91AC: 817E0104  lwz r11, 0x104(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) } as u64;
	// 825F91B0: 395D0030  addi r10, r29, 0x30
	ctx.r[10].s64 = ctx.r[29].s64 + 48;
	// 825F91B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825F91B8: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825F91BC: 4800000C  b 0x825f91c8
	pc = 0x825F91C8; continue 'dispatch;
	// 825F91C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F91C4: 388B1414  addi r4, r11, 0x1414
	ctx.r[4].s64 = ctx.r[11].s64 + 5140;
	// 825F91C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F91CC: 487FA83D  bl 0x82df3a08
	ctx.lr = 0x825F91D0;
	sub_82DF3A08(ctx, base);
	// 825F91D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F91D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F91D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825F91DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825F91E0: 4BCEE1B1  bl 0x822e7390
	ctx.lr = 0x825F91E4;
	sub_822E7390(ctx, base);
	// 825F91E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F91E8: 487FA241  bl 0x82df3428
	ctx.lr = 0x825F91EC;
	sub_82DF3428(ctx, base);
	// 825F91EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825F91F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F91F4: 4BFFF23D  bl 0x825f8430
	ctx.lr = 0x825F91F8;
	sub_825F8430(ctx, base);
	// 825F91F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F91FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F9200: 487FA809  bl 0x82df3a08
	ctx.lr = 0x825F9204;
	sub_82DF3A08(ctx, base);
	// 825F9204: 38DE0028  addi r6, r30, 0x28
	ctx.r[6].s64 = ctx.r[30].s64 + 40;
	// 825F9208: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825F920C: 80810078  lwz r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825F9210: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825F9214: 4BCF54C5  bl 0x822ee6d8
	ctx.lr = 0x825F9218;
	sub_822EE6D8(ctx, base);
	// 825F9218: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825F921C: 3BFE00F0  addi r31, r30, 0xf0
	ctx.r[31].s64 = ctx.r[30].s64 + 240;
	// 825F9220: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825F9224: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825F9228: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F922C: 917E00F0  stw r11, 0xf0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825F9230: 4BCCB231  bl 0x822c4460
	ctx.lr = 0x825F9234;
	sub_822C4460(ctx, base);
	// 825F9234: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825F9238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F923C: 419A0008  beq cr6, 0x825f9244
	if ctx.cr[6].eq {
	pc = 0x825F9244; continue 'dispatch;
	}
	// 825F9240: 4BCC7651  bl 0x822c0890
	ctx.lr = 0x825F9244;
	sub_822C0890(ctx, base);
	// 825F9244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F9248: 487FA1E1  bl 0x82df3428
	ctx.lr = 0x825F924C;
	sub_82DF3428(ctx, base);
	// 825F924C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825F9250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F9254: 4BF18B45  bl 0x82511d98
	ctx.lr = 0x825F9258;
	sub_82511D98(ctx, base);
	// 825F9258: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825F925C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9260: 4BCF46C1  bl 0x822ed920
	ctx.lr = 0x825F9264;
	sub_822ED920(ctx, base);
	// 825F9264: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825F9268: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F926C: 808B674C  lwz r4, 0x674c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26444 as u32) ) } as u64;
	// 825F9270: 4BE96131  bl 0x8248f3a0
	ctx.lr = 0x825F9274;
	sub_8248F3A0(ctx, base);
	// 825F9274: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F9278: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F927C: 4BF17AC5  bl 0x82510d40
	ctx.lr = 0x825F9280;
	sub_82510D40(ctx, base);
	// 825F9280: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825F9284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9288: 419A0008  beq cr6, 0x825f9290
	if ctx.cr[6].eq {
	pc = 0x825F9290; continue 'dispatch;
	}
	// 825F928C: 4BCC7605  bl 0x822c0890
	ctx.lr = 0x825F9290;
	sub_822C0890(ctx, base);
	// 825F9290: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F9294: 4BCEDF8D  bl 0x822e7220
	ctx.lr = 0x825F9298;
	sub_822E7220(ctx, base);
	// 825F9298: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F929C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F92A0: 419A0008  beq cr6, 0x825f92a8
	if ctx.cr[6].eq {
	pc = 0x825F92A8; continue 'dispatch;
	}
	// 825F92A4: 4BCC75ED  bl 0x822c0890
	ctx.lr = 0x825F92A8;
	sub_822C0890(ctx, base);
	// 825F92A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825F92AC: 48831855  bl 0x82e2ab00
	ctx.lr = 0x825F92B0;
	sub_82E2AB00(ctx, base);
	// 825F92B0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825F92B4: 48BAEEFC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F92B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F92B8 size=176
    let mut pc: u32 = 0x825F92B8;
    'dispatch: loop {
        match pc {
            0x825F92B8 => {
    //   block [0x825F92B8..0x825F9368)
	// 825F92B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F92BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825F92C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825F92C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825F92C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F92CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F92D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825F92D4: 817F0110  lwz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825F92D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F92DC: 419A0050  beq cr6, 0x825f932c
	if ctx.cr[6].eq {
	pc = 0x825F932C; continue 'dispatch;
	}
	// 825F92E0: 4BFFF6D9  bl 0x825f89b8
	ctx.lr = 0x825F92E4;
	sub_825F89B8(ctx, base);
	// 825F92E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F92E8: 4BFFF8A9  bl 0x825f8b90
	ctx.lr = 0x825F92EC;
	sub_825F8B90(ctx, base);
	// 825F92EC: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825F92F0: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 825F92F4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825F92F8: 419A0014  beq cr6, 0x825f930c
	if ctx.cr[6].eq {
	pc = 0x825F930C; continue 'dispatch;
	}
	// 825F92FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F9300: 4BFFFC39  bl 0x825f8f38
	ctx.lr = 0x825F9304;
	sub_825F8F38(ctx, base);
	// 825F9304: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825F9308: 909F0100  stw r4, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[4].u32 ) };
	// 825F930C: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825F9310: 815F0104  lwz r10, 0x104(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 825F9314: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825F9318: 419A0014  beq cr6, 0x825f932c
	if ctx.cr[6].eq {
	pc = 0x825F932C; continue 'dispatch;
	}
	// 825F931C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F9320: 4BFFFC19  bl 0x825f8f38
	ctx.lr = 0x825F9324;
	sub_825F8F38(ctx, base);
	// 825F9324: 817F0104  lwz r11, 0x104(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 825F9328: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825F932C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F9330: C1BE0000  lfs f13, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825F9334: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825F9338: C00BA1C4  lfs f0, -0x5e3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F933C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825F9340: 481D21D9  bl 0x827cb518
	ctx.lr = 0x825F9344;
	sub_827CB518(ctx, base);
	// 825F9344: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825F9348: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 825F934C: 481D21CD  bl 0x827cb518
	ctx.lr = 0x825F9350;
	sub_827CB518(ctx, base);
	// 825F9350: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825F9354: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825F9358: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825F935C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825F9360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825F9364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F9368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F9368 size=868
    let mut pc: u32 = 0x825F9368;
    'dispatch: loop {
        match pc {
            0x825F9368 => {
    //   block [0x825F9368..0x825F96CC)
	// 825F9368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F936C: 48BAEDFD  bl 0x831a8168
	ctx.lr = 0x825F9370;
	sub_831A8130(ctx, base);
	// 825F9370: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825F9374: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825F9378: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825F937C: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F9380: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F9384: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825F9388: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825F938C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825F9390: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825F9394: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825F9398: 41980150  blt cr6, 0x825f94e8
	if ctx.cr[6].lt {
	pc = 0x825F94E8; continue 'dispatch;
	}
	// 825F939C: 409A01B8  bne cr6, 0x825f9554
	if !ctx.cr[6].eq {
	pc = 0x825F9554; continue 'dispatch;
	}
	// 825F93A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F93A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F93A8: 388B1530  addi r4, r11, 0x1530
	ctx.r[4].s64 = ctx.r[11].s64 + 5424;
	// 825F93AC: 38A00145  li r5, 0x145
	ctx.r[5].s64 = 325;
	// 825F93B0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825F93B4: 4BCC7025  bl 0x822c03d8
	ctx.lr = 0x825F93B8;
	sub_822C03D8(ctx, base);
	// 825F93B8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825F93BC: 41820034  beq 0x825f93f0
	if ctx.cr[0].eq {
	pc = 0x825F93F0; continue 'dispatch;
	}
	// 825F93C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F93C4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F93C8: 388B1638  addi r4, r11, 0x1638
	ctx.r[4].s64 = ctx.r[11].s64 + 5688;
	// 825F93CC: 487FA63D  bl 0x82df3a08
	ctx.lr = 0x825F93D0;
	sub_82DF3A08(ctx, base);
	// 825F93D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F93D4: 38BE0020  addi r5, r30, 0x20
	ctx.r[5].s64 = ctx.r[30].s64 + 32;
	// 825F93D8: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 825F93DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F93E0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825F93E4: 4BFB302D  bl 0x825ac410
	ctx.lr = 0x825F93E8;
	sub_825AC410(ctx, base);
	// 825F93E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F93EC: 48000008  b 0x825f93f4
	pc = 0x825F93F4; continue 'dispatch;
	// 825F93F0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F93F4: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825F93F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F93FC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825F9400: 4BEF9FB9  bl 0x824f33b8
	ctx.lr = 0x825F9404;
	sub_824F33B8(ctx, base);
	// 825F9404: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F9408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F940C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825F9410: 4BCC6BF1  bl 0x822c0000
	ctx.lr = 0x825F9414;
	sub_822C0000(ctx, base);
	// 825F9414: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825F9418: 4182000C  beq 0x825f9424
	if ctx.cr[0].eq {
	pc = 0x825F9424; continue 'dispatch;
	}
	// 825F941C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F9420: 487FA009  bl 0x82df3428
	ctx.lr = 0x825F9424;
	sub_82DF3428(ctx, base);
	// 825F9424: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9428: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F942C: 388B162C  addi r4, r11, 0x162c
	ctx.r[4].s64 = ctx.r[11].s64 + 5676;
	// 825F9430: 487FA5D9  bl 0x82df3a08
	ctx.lr = 0x825F9434;
	sub_82DF3A08(ctx, base);
	// 825F9434: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825F9438: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825F943C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F9440: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F9444: 4BFB297D  bl 0x825abdc0
	ctx.lr = 0x825F9448;
	sub_825ABDC0(ctx, base);
	// 825F9448: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F944C: 487F9FDD  bl 0x82df3428
	ctx.lr = 0x825F9450;
	sub_82DF3428(ctx, base);
	// 825F9450: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9454: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F9458: 388B1620  addi r4, r11, 0x1620
	ctx.r[4].s64 = ctx.r[11].s64 + 5664;
	// 825F945C: 487FA5AD  bl 0x82df3a08
	ctx.lr = 0x825F9460;
	sub_82DF3A08(ctx, base);
	// 825F9460: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 825F9464: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825F9468: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F946C: 4BFB2955  bl 0x825abdc0
	ctx.lr = 0x825F9470;
	sub_825ABDC0(ctx, base);
	// 825F9470: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825F9474: 487F9FB5  bl 0x82df3428
	ctx.lr = 0x825F9478;
	sub_82DF3428(ctx, base);
	// 825F9478: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F947C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F9480: 388B1614  addi r4, r11, 0x1614
	ctx.r[4].s64 = ctx.r[11].s64 + 5652;
	// 825F9484: 487FA585  bl 0x82df3a08
	ctx.lr = 0x825F9488;
	sub_82DF3A08(ctx, base);
	// 825F9488: 83E1006C  lwz r31, 0x6c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F948C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 825F9490: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F9494: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 825F9498: 419A0024  beq cr6, 0x825f94bc
	if ctx.cr[6].eq {
	pc = 0x825F94BC; continue 'dispatch;
	}
	// 825F949C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825F94A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F94A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F94A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F94AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F94B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F94B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F94B8: 4082FFE8  bne 0x825f94a0
	if !ctx.cr[0].eq {
	pc = 0x825F94A0; continue 'dispatch;
	}
	// 825F94BC: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825F94C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825F94C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F94C8: 4BFA8C49  bl 0x825a2110
	ctx.lr = 0x825F94CC;
	sub_825A2110(ctx, base);
	// 825F94CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F94D0: 487F9F59  bl 0x82df3428
	ctx.lr = 0x825F94D4;
	sub_82DF3428(ctx, base);
	// 825F94D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825F94D8: 419A007C  beq cr6, 0x825f9554
	if ctx.cr[6].eq {
	pc = 0x825F9554; continue 'dispatch;
	}
	// 825F94DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F94E0: 4BCC73B1  bl 0x822c0890
	ctx.lr = 0x825F94E4;
	sub_822C0890(ctx, base);
	// 825F94E4: 48000070  b 0x825f9554
	pc = 0x825F9554; continue 'dispatch;
	// 825F94E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F94EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F94F0: 388B160C  addi r4, r11, 0x160c
	ctx.r[4].s64 = ctx.r[11].s64 + 5644;
	// 825F94F4: 487FA515  bl 0x82df3a08
	ctx.lr = 0x825F94F8;
	sub_82DF3A08(ctx, base);
	// 825F94F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F94FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9500: 388B1600  addi r4, r11, 0x1600
	ctx.r[4].s64 = ctx.r[11].s64 + 5632;
	// 825F9504: 487FA505  bl 0x82df3a08
	ctx.lr = 0x825F9508;
	sub_82DF3A08(ctx, base);
	// 825F9508: 3900000F  li r8, 0xf
	ctx.r[8].s64 = 15;
	// 825F950C: 38E0001E  li r7, 0x1e
	ctx.r[7].s64 = 30;
	// 825F9510: 38C0000F  li r6, 0xf
	ctx.r[6].s64 = 15;
	// 825F9514: 38BE0018  addi r5, r30, 0x18
	ctx.r[5].s64 = ctx.r[30].s64 + 24;
	// 825F9518: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F951C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825F9520: 4BFB4671  bl 0x825adb90
	ctx.lr = 0x825F9524;
	sub_825ADB90(ctx, base);
	// 825F9524: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F9528: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F952C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F9530: 4BFA8889  bl 0x825a1db8
	ctx.lr = 0x825F9534;
	sub_825A1DB8(ctx, base);
	// 825F9534: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 825F9538: 487F9EF1  bl 0x82df3428
	ctx.lr = 0x825F953C;
	sub_82DF3428(ctx, base);
	// 825F953C: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825F9540: 4BCCF779  bl 0x822c8cb8
	ctx.lr = 0x825F9544;
	sub_822C8CB8(ctx, base);
	// 825F9544: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9548: 487F9EE1  bl 0x82df3428
	ctx.lr = 0x825F954C;
	sub_82DF3428(ctx, base);
	// 825F954C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F9550: 487F9ED9  bl 0x82df3428
	ctx.lr = 0x825F9554;
	sub_82DF3428(ctx, base);
	// 825F9554: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9558: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F955C: 388B15E0  addi r4, r11, 0x15e0
	ctx.r[4].s64 = ctx.r[11].s64 + 5600;
	// 825F9560: 487FA4A9  bl 0x82df3a08
	ctx.lr = 0x825F9564;
	sub_82DF3A08(ctx, base);
	// 825F9564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F956C: 388B15C8  addi r4, r11, 0x15c8
	ctx.r[4].s64 = ctx.r[11].s64 + 5576;
	// 825F9570: 487FA499  bl 0x82df3a08
	ctx.lr = 0x825F9574;
	sub_82DF3A08(ctx, base);
	// 825F9574: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825F9578: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825F957C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825F9580: 38BE0034  addi r5, r30, 0x34
	ctx.r[5].s64 = ctx.r[30].s64 + 52;
	// 825F9584: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F9588: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825F958C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825F9590: C3AADD6C  lfs f29, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825F9594: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F9598: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F959C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825F95A0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F95A4: 4BFA9D05  bl 0x825a32a8
	ctx.lr = 0x825F95A8;
	sub_825A32A8(ctx, base);
	// 825F95A8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F95AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F95B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F95B4: 4BFA81BD  bl 0x825a1770
	ctx.lr = 0x825F95B8;
	sub_825A1770(ctx, base);
	// 825F95B8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825F95BC: 487F9E6D  bl 0x82df3428
	ctx.lr = 0x825F95C0;
	sub_82DF3428(ctx, base);
	// 825F95C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825F95C4: 4BCCF6F5  bl 0x822c8cb8
	ctx.lr = 0x825F95C8;
	sub_822C8CB8(ctx, base);
	// 825F95C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F95CC: 487F9E5D  bl 0x82df3428
	ctx.lr = 0x825F95D0;
	sub_82DF3428(ctx, base);
	// 825F95D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F95D4: 487F9E55  bl 0x82df3428
	ctx.lr = 0x825F95D8;
	sub_82DF3428(ctx, base);
	// 825F95D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F95DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F95E0: 388B15A4  addi r4, r11, 0x15a4
	ctx.r[4].s64 = ctx.r[11].s64 + 5540;
	// 825F95E4: 487FA425  bl 0x82df3a08
	ctx.lr = 0x825F95E8;
	sub_82DF3A08(ctx, base);
	// 825F95E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F95EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F95F0: 388B1590  addi r4, r11, 0x1590
	ctx.r[4].s64 = ctx.r[11].s64 + 5520;
	// 825F95F4: 487FA415  bl 0x82df3a08
	ctx.lr = 0x825F95F8;
	sub_82DF3A08(ctx, base);
	// 825F95F8: 38BE0038  addi r5, r30, 0x38
	ctx.r[5].s64 = ctx.r[30].s64 + 56;
	// 825F95FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F9600: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F9604: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825F9608: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 825F960C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 825F9610: 4BFA9C99  bl 0x825a32a8
	ctx.lr = 0x825F9614;
	sub_825A32A8(ctx, base);
	// 825F9614: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F9618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F961C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F9620: 4BFA8151  bl 0x825a1770
	ctx.lr = 0x825F9624;
	sub_825A1770(ctx, base);
	// 825F9624: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825F9628: 487F9E01  bl 0x82df3428
	ctx.lr = 0x825F962C;
	sub_82DF3428(ctx, base);
	// 825F962C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825F9630: 4BCCF689  bl 0x822c8cb8
	ctx.lr = 0x825F9634;
	sub_822C8CB8(ctx, base);
	// 825F9634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F9638: 487F9DF1  bl 0x82df3428
	ctx.lr = 0x825F963C;
	sub_82DF3428(ctx, base);
	// 825F963C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9640: 487F9DE9  bl 0x82df3428
	ctx.lr = 0x825F9644;
	sub_82DF3428(ctx, base);
	// 825F9644: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F964C: 388B157C  addi r4, r11, 0x157c
	ctx.r[4].s64 = ctx.r[11].s64 + 5500;
	// 825F9650: 487FA3B9  bl 0x82df3a08
	ctx.lr = 0x825F9654;
	sub_82DF3A08(ctx, base);
	// 825F9654: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F9658: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F965C: 388B34B0  addi r4, r11, 0x34b0
	ctx.r[4].s64 = ctx.r[11].s64 + 13488;
	// 825F9660: 487FA3A9  bl 0x82df3a08
	ctx.lr = 0x825F9664;
	sub_82DF3A08(ctx, base);
	// 825F9664: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825F9668: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825F966C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F9670: 38BE0028  addi r5, r30, 0x28
	ctx.r[5].s64 = ctx.r[30].s64 + 40;
	// 825F9674: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825F9678: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 825F967C: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825F9680: C04A9F64  lfs f2, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825F9684: 4BFA9C25  bl 0x825a32a8
	ctx.lr = 0x825F9688;
	sub_825A32A8(ctx, base);
	// 825F9688: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825F968C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825F9690: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825F9694: 4BFA80DD  bl 0x825a1770
	ctx.lr = 0x825F9698;
	sub_825A1770(ctx, base);
	// 825F9698: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825F969C: 487F9D8D  bl 0x82df3428
	ctx.lr = 0x825F96A0;
	sub_82DF3428(ctx, base);
	// 825F96A0: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825F96A4: 4BCCF615  bl 0x822c8cb8
	ctx.lr = 0x825F96A8;
	sub_822C8CB8(ctx, base);
	// 825F96A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825F96AC: 487F9D7D  bl 0x82df3428
	ctx.lr = 0x825F96B0;
	sub_82DF3428(ctx, base);
	// 825F96B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F96B4: 487F9D75  bl 0x82df3428
	ctx.lr = 0x825F96B8;
	sub_82DF3428(ctx, base);
	// 825F96B8: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 825F96BC: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825F96C0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825F96C4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825F96C8: 48BAEAF0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F96D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F96D0 size=564
    let mut pc: u32 = 0x825F96D0;
    'dispatch: loop {
        match pc {
            0x825F96D0 => {
    //   block [0x825F96D0..0x825F9904)
	// 825F96D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F96D4: 48BAEA89  bl 0x831a815c
	ctx.lr = 0x825F96D8;
	sub_831A8130(ctx, base);
	// 825F96D8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825F96DC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F96E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F96E4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F96E8: 3B8B1530  addi r28, r11, 0x1530
	ctx.r[28].s64 = ctx.r[11].s64 + 5424;
	// 825F96EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F96F0: 38A0015A  li r5, 0x15a
	ctx.r[5].s64 = 346;
	// 825F96F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825F96F8: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825F96FC: 487F8CED  bl 0x82df23e8
	ctx.lr = 0x825F9700;
	sub_82DF23E8(ctx, base);
	// 825F9700: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825F9704: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F9708: C3EBE830  lfs f31, -0x17d0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F970C: 41820014  beq 0x825f9720
	if ctx.cr[0].eq {
	pc = 0x825F9720; continue 'dispatch;
	}
	// 825F9710: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F9714: 481575C5  bl 0x82750cd8
	ctx.lr = 0x825F9718;
	sub_82750CD8(ctx, base);
	// 825F9718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F971C: 48000008  b 0x825f9724
	pc = 0x825F9724; continue 'dispatch;
	// 825F9720: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F9724: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825F9728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F972C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9730: 4BFE7109  bl 0x825e0838
	ctx.lr = 0x825F9734;
	sub_825E0838(ctx, base);
	// 825F9734: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F9738: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F973C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9740: 4BCC68C1  bl 0x822c0000
	ctx.lr = 0x825F9744;
	sub_822C0000(ctx, base);
	// 825F9744: 83410054  lwz r26, 0x54(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F9748: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F974C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825F9750: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 825F9754: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825F9758: 419A0024  beq cr6, 0x825f977c
	if ctx.cr[6].eq {
	pc = 0x825F977C; continue 'dispatch;
	}
	// 825F975C: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 825F9760: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F9764: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9768: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F976C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F9770: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F9774: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9778: 4082FFE8  bne 0x825f9760
	if !ctx.cr[0].eq {
	pc = 0x825F9760; continue 'dispatch;
	}
	// 825F977C: 3BFBFF1C  addi r31, r27, -0xe4
	ctx.r[31].s64 = ctx.r[27].s64 + -228;
	// 825F9780: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F9784: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F9788: 4BF15D41  bl 0x8250f4c8
	ctx.lr = 0x825F978C;
	sub_8250F4C8(ctx, base);
	// 825F978C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9794: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825F9798: 409A0008  bne cr6, 0x825f97a0
	if !ctx.cr[6].eq {
	pc = 0x825F97A0; continue 'dispatch;
	}
	// 825F979C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F97A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F97A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F97A8: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 825F97AC: 4BF15D6D  bl 0x8250f518
	ctx.lr = 0x825F97B0;
	sub_8250F518(ctx, base);
	// 825F97B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F97B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F97B8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825F97BC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825F97C0: 4BF13D49  bl 0x8250d508
	ctx.lr = 0x825F97C4;
	sub_8250D508(ctx, base);
	// 825F97C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825F97C8: 487F84C9  bl 0x82df1c90
	ctx.lr = 0x825F97CC;
	sub_82DF1C90(ctx, base);
	// 825F97CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F97D0: 487F84C1  bl 0x82df1c90
	ctx.lr = 0x825F97D4;
	sub_82DF1C90(ctx, base);
	// 825F97D4: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 825F97D8: 48A0F7E1  bl 0x83008fb8
	ctx.lr = 0x825F97DC;
	sub_83008FB8(ctx, base);
	// 825F97DC: 907B002C  stw r3, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 825F97E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F97E4: 4BFFF1D5  bl 0x825f89b8
	ctx.lr = 0x825F97E8;
	sub_825F89B8(ctx, base);
	// 825F97E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825F97EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F97F0: 38A0015F  li r5, 0x15f
	ctx.r[5].s64 = 351;
	// 825F97F4: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825F97F8: 487F8BF1  bl 0x82df23e8
	ctx.lr = 0x825F97FC;
	sub_82DF23E8(ctx, base);
	// 825F97FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F9800: 41820014  beq 0x825f9814
	if ctx.cr[0].eq {
	pc = 0x825F9814; continue 'dispatch;
	}
	// 825F9804: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F9808: 481574D1  bl 0x82750cd8
	ctx.lr = 0x825F980C;
	sub_82750CD8(ctx, base);
	// 825F980C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825F9810: 48000008  b 0x825f9818
	pc = 0x825F9818; continue 'dispatch;
	// 825F9814: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F9818: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825F981C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F9820: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9824: 4BFE7015  bl 0x825e0838
	ctx.lr = 0x825F9828;
	sub_825E0838(ctx, base);
	// 825F9828: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825F982C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F9830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825F9834: 4BCC67CD  bl 0x822c0000
	ctx.lr = 0x825F9838;
	sub_822C0000(ctx, base);
	// 825F9838: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F983C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825F9840: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F9844: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825F9848: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825F984C: 419A0024  beq cr6, 0x825f9870
	if ctx.cr[6].eq {
	pc = 0x825F9870; continue 'dispatch;
	}
	// 825F9850: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825F9854: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F9858: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F985C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F9860: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F9864: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F9868: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F986C: 4082FFE8  bne 0x825f9854
	if !ctx.cr[0].eq {
	pc = 0x825F9854; continue 'dispatch;
	}
	// 825F9870: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F9874: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F9878: 4BF15C51  bl 0x8250f4c8
	ctx.lr = 0x825F987C;
	sub_8250F4C8(ctx, base);
	// 825F987C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9884: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 825F9888: 409A0008  bne cr6, 0x825f9890
	if !ctx.cr[6].eq {
	pc = 0x825F9890; continue 'dispatch;
	}
	// 825F988C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825F9890: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F9894: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F9898: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 825F989C: 4BF15C7D  bl 0x8250f518
	ctx.lr = 0x825F98A0;
	sub_8250F518(ctx, base);
	// 825F98A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F98A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F98A8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825F98AC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825F98B0: 4BF13C59  bl 0x8250d508
	ctx.lr = 0x825F98B4;
	sub_8250D508(ctx, base);
	// 825F98B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F98B8: 487F83D9  bl 0x82df1c90
	ctx.lr = 0x825F98BC;
	sub_82DF1C90(ctx, base);
	// 825F98BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825F98C0: 487F83D1  bl 0x82df1c90
	ctx.lr = 0x825F98C4;
	sub_82DF1C90(ctx, base);
	// 825F98C4: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 825F98C8: 48A0F6F1  bl 0x83008fb8
	ctx.lr = 0x825F98CC;
	sub_83008FB8(ctx, base);
	// 825F98CC: 907B0030  stw r3, 0x30(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 825F98D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825F98D4: 4BFFF2BD  bl 0x825f8b90
	ctx.lr = 0x825F98D8;
	sub_825F8B90(ctx, base);
	// 825F98D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825F98DC: 419A000C  beq cr6, 0x825f98e8
	if ctx.cr[6].eq {
	pc = 0x825F98E8; continue 'dispatch;
	}
	// 825F98E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F98E4: 4BCC6FAD  bl 0x822c0890
	ctx.lr = 0x825F98E8;
	sub_822C0890(ctx, base);
	// 825F98E8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825F98EC: 419A000C  beq cr6, 0x825f98f8
	if ctx.cr[6].eq {
	pc = 0x825F98F8; continue 'dispatch;
	}
	// 825F98F0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825F98F4: 4BCC6F9D  bl 0x822c0890
	ctx.lr = 0x825F98F8;
	sub_822C0890(ctx, base);
	// 825F98F8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825F98FC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 825F9900: 48BAE8AC  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F9908 size=312
    let mut pc: u32 = 0x825F9908;
    'dispatch: loop {
        match pc {
            0x825F9908 => {
    //   block [0x825F9908..0x825F9A40)
	// 825F9908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F990C: 48BAE861  bl 0x831a816c
	ctx.lr = 0x825F9910;
	sub_831A8130(ctx, base);
	// 825F9910: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 825F9914: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F9918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F991C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825F9920: 4BDD9FE9  bl 0x823d3908
	ctx.lr = 0x825F9924;
	sub_823D3908(ctx, base);
	// 825F9924: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9928: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825F992C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F9930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9934: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825F9938: 419A0024  beq cr6, 0x825f995c
	if ctx.cr[6].eq {
	pc = 0x825F995C; continue 'dispatch;
	}
	// 825F993C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F9940: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F9944: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9948: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F994C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F9950: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F9954: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9958: 4082FFE8  bne 0x825f9940
	if !ctx.cr[0].eq {
	pc = 0x825F9940; continue 'dispatch;
	}
	// 825F995C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9960: 80DF002C  lwz r6, 0x2c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 825F9964: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F9968: 3BAB1530  addi r29, r11, 0x1530
	ctx.r[29].s64 = ctx.r[11].s64 + 5424;
	// 825F996C: 3BDFFF44  addi r30, r31, -0xbc
	ctx.r[30].s64 = ctx.r[31].s64 + -188;
	// 825F9970: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825F9974: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F9978: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F997C: 38A0016E  li r5, 0x16e
	ctx.r[5].s64 = 366;
	// 825F9980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F9984: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F9988: 4885F0B9  bl 0x82e58a40
	ctx.lr = 0x825F998C;
	sub_82E58A40(ctx, base);
	// 825F998C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825F9990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9994: 419A0008  beq cr6, 0x825f999c
	if ctx.cr[6].eq {
	pc = 0x825F999C; continue 'dispatch;
	}
	// 825F9998: 4BCC6EF9  bl 0x822c0890
	ctx.lr = 0x825F999C;
	sub_822C0890(ctx, base);
	// 825F999C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F99A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F99A4: 419A0008  beq cr6, 0x825f99ac
	if ctx.cr[6].eq {
	pc = 0x825F99AC; continue 'dispatch;
	}
	// 825F99A8: 4BCC6EE9  bl 0x822c0890
	ctx.lr = 0x825F99AC;
	sub_822C0890(ctx, base);
	// 825F99AC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825F99B0: 4BDD9F59  bl 0x823d3908
	ctx.lr = 0x825F99B4;
	sub_823D3908(ctx, base);
	// 825F99B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F99B8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825F99BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F99C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F99C4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825F99C8: 419A0024  beq cr6, 0x825f99ec
	if ctx.cr[6].eq {
	pc = 0x825F99EC; continue 'dispatch;
	}
	// 825F99CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F99D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F99D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F99D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F99DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F99E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F99E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F99E8: 4082FFE8  bne 0x825f99d0
	if !ctx.cr[0].eq {
	pc = 0x825F99D0; continue 'dispatch;
	}
	// 825F99EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825F99F0: 80DF0030  lwz r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 825F99F4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825F99F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825F99FC: 38A0016F  li r5, 0x16f
	ctx.r[5].s64 = 367;
	// 825F9A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825F9A04: 4885F03D  bl 0x82e58a40
	ctx.lr = 0x825F9A08;
	sub_82E58A40(ctx, base);
	// 825F9A08: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825F9A0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9A10: 419A0008  beq cr6, 0x825f9a18
	if ctx.cr[6].eq {
	pc = 0x825F9A18; continue 'dispatch;
	}
	// 825F9A14: 4BCC6E7D  bl 0x822c0890
	ctx.lr = 0x825F9A18;
	sub_822C0890(ctx, base);
	// 825F9A18: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825F9A1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9A20: 419A0008  beq cr6, 0x825f9a28
	if ctx.cr[6].eq {
	pc = 0x825F9A28; continue 'dispatch;
	}
	// 825F9A24: 4BCC6E6D  bl 0x822c0890
	ctx.lr = 0x825F9A28;
	sub_822C0890(ctx, base);
	// 825F9A28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825F9A2C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825F9A30: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825F9A34: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825F9A38: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825F9A3C: 48BAE780  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825F9A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825F9A40 size=1716
    let mut pc: u32 = 0x825F9A40;
    'dispatch: loop {
        match pc {
            0x825F9A40 => {
    //   block [0x825F9A40..0x825FA0F4)
	// 825F9A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825F9A44: 48BAE719  bl 0x831a815c
	ctx.lr = 0x825F9A48;
	sub_831A8130(ctx, base);
	// 825F9A48: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 825F9A4C: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825F9A50: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825F9A54: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825F9A58: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825F9A5C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825F9A60: 4BF15A69  bl 0x8250f4c8
	ctx.lr = 0x825F9A64;
	sub_8250F4C8(ctx, base);
	// 825F9A64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9A6C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825F9A70: 409A0008  bne cr6, 0x825f9a78
	if !ctx.cr[6].eq {
	pc = 0x825F9A78; continue 'dispatch;
	}
	// 825F9A74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825F9A78: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825F9A7C: 4BF0EF9D  bl 0x82508a18
	ctx.lr = 0x825F9A80;
	sub_82508A18(ctx, base);
	// 825F9A80: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825F9A84: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825F9A88: 487F8209  bl 0x82df1c90
	ctx.lr = 0x825F9A8C;
	sub_82DF1C90(ctx, base);
	// 825F9A8C: 39610130  addi r11, r1, 0x130
	ctx.r[11].s64 = ctx.r[1].s64 + 304;
	// 825F9A90: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825F9A94: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825F9A98: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825F9A9C: 4BDA57ED  bl 0x8239f288
	ctx.lr = 0x825F9AA0;
	sub_8239F288(ctx, base);
	// 825F9AA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825F9AA4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 825F9AA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825F9AAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825F9AB0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 825F9AB4: 419A0024  beq cr6, 0x825f9ad8
	if ctx.cr[6].eq {
	pc = 0x825F9AD8; continue 'dispatch;
	}
	// 825F9AB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825F9ABC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F9AC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9AC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F9AC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F9ACC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F9AD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9AD4: 4082FFE8  bne 0x825f9abc
	if !ctx.cr[0].eq {
	pc = 0x825F9ABC; continue 'dispatch;
	}
	// 825F9AD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825F9ADC: 3BBB0028  addi r29, r27, 0x28
	ctx.r[29].s64 = ctx.r[27].s64 + 40;
	// 825F9AE0: 3BCB1530  addi r30, r11, 0x1530
	ctx.r[30].s64 = ctx.r[11].s64 + 5424;
	// 825F9AE4: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 825F9AE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F9AEC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825F9AF0: 38A0017B  li r5, 0x17b
	ctx.r[5].s64 = 379;
	// 825F9AF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F9AF8: 4885D4F1  bl 0x82e56fe8
	ctx.lr = 0x825F9AFC;
	sub_82E56FE8(ctx, base);
	// 825F9AFC: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825F9B00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9B04: 419A0008  beq cr6, 0x825f9b0c
	if ctx.cr[6].eq {
	pc = 0x825F9B0C; continue 'dispatch;
	}
	// 825F9B08: 4BCC6D89  bl 0x822c0890
	ctx.lr = 0x825F9B0C;
	sub_822C0890(ctx, base);
	// 825F9B0C: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825F9B10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9B14: 419A0008  beq cr6, 0x825f9b1c
	if ctx.cr[6].eq {
	pc = 0x825F9B1C; continue 'dispatch;
	}
	// 825F9B18: 4BCC6D79  bl 0x822c0890
	ctx.lr = 0x825F9B1C;
	sub_822C0890(ctx, base);
	// 825F9B1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F9B20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825F9B24: 38A0017E  li r5, 0x17e
	ctx.r[5].s64 = 382;
	// 825F9B28: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 825F9B2C: 487F88BD  bl 0x82df23e8
	ctx.lr = 0x825F9B30;
	sub_82DF23E8(ctx, base);
	// 825F9B30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825F9B34: 41820010  beq 0x825f9b44
	if ctx.cr[0].eq {
	pc = 0x825F9B44; continue 'dispatch;
	}
	// 825F9B38: 4855D8A9  bl 0x82b573e0
	ctx.lr = 0x825F9B3C;
	sub_82B573E0(ctx, base);
	// 825F9B3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825F9B40: 48000008  b 0x825f9b48
	pc = 0x825F9B48; continue 'dispatch;
	// 825F9B44: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825F9B48: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825F9B4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F9B50: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F9B54: 4BE7B9DD  bl 0x82475530
	ctx.lr = 0x825F9B58;
	sub_82475530(ctx, base);
	// 825F9B58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825F9B5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825F9B60: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825F9B64: 4BCC649D  bl 0x822c0000
	ctx.lr = 0x825F9B68;
	sub_822C0000(ctx, base);
	// 825F9B68: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825F9B6C: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825F9B70: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 825F9B74: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 825F9B78: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 825F9B7C: 419A0024  beq cr6, 0x825f9ba0
	if ctx.cr[6].eq {
	pc = 0x825F9BA0; continue 'dispatch;
	}
	// 825F9B80: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 825F9B84: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825F9B88: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9B8C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825F9B90: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825F9B94: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825F9B98: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825F9B9C: 4082FFE8  bne 0x825f9b84
	if !ctx.cr[0].eq {
	pc = 0x825F9B84; continue 'dispatch;
	}
	// 825F9BA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825F9BA4: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 825F9BA8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825F9BAC: 38A0017F  li r5, 0x17f
	ctx.r[5].s64 = 383;
	// 825F9BB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825F9BB4: 4885D435  bl 0x82e56fe8
	ctx.lr = 0x825F9BB8;
	sub_82E56FE8(ctx, base);
	// 825F9BB8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825F9BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825F9BC0: 419A0008  beq cr6, 0x825f9bc8
	if ctx.cr[6].eq {
	pc = 0x825F9BC8; continue 'dispatch;
	}
	// 825F9BC4: 4BCC6CCD  bl 0x822c0890
	ctx.lr = 0x825F9BC8;
	sub_822C0890(ctx, base);
	// 825F9BC8: 817B00FC  lwz r11, 0xfc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(252 as u32) ) } as u64;
	// 825F9BCC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825F9BD0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825F9BD4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825F9BD8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 825F9BDC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825F9BE0: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825F9BE4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825F9BE8: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825F9BEC: C0099534  lfs f0, -0x6acc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F9BF0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825F9BF4: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 825F9BF8: D3E100B0  stfs f31, 0xb0(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 825F9BFC: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 825F9C00: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 825F9C04: C008CEE4  lfs f0, -0x311c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825F9C08: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825F9C0C: 48882D7D  bl 0x82e7c988
	ctx.lr = 0x825F9C10;
	sub_82E7C988(ctx, base);
	// 825F9C10: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825F9C14: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825F9C18: 4BF17F41  bl 0x82511b58
	ctx.lr = 0x825F9C1C;
	sub_82511B58(ctx, base);
	// 825F9C1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F9C20: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 825F9C24: 48882275  bl 0x82e7be98
	ctx.lr = 0x825F9C28;
	sub_82E7BE98(ctx, base);
	// 825F9C28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F9C2C: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 825F9C30: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825F9C34: 4BCCACCD  bl 0x822c4900
	ctx.lr = 0x825F9C38;
	sub_822C4900(ctx, base);
	// 825F9C38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825F9C3C: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 825F9C40: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825F9C44: 48882085  bl 0x82e7bcc8
	ctx.lr = 0x825F9C48;
	sub_82E7BCC8(ctx, base);
	// 825F9C48: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 825F9C4C: 39410130  addi r10, r1, 0x130
	ctx.r[10].s64 = ctx.r[1].s64 + 304;
	// 825F9C50: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 825F9C54: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825F9C58: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FA0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FA0F8 size=108
    let mut pc: u32 = 0x825FA0F8;
    'dispatch: loop {
        match pc {
            0x825FA0F8 => {
    //   block [0x825FA0F8..0x825FA164)
	// 825FA0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FA0FC: 48BAE071  bl 0x831a816c
	ctx.lr = 0x825FA100;
	sub_831A8130(ctx, base);
	// 825FA100: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FA104: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825FA108: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825FA10C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FA110: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FA114: 41820038  beq 0x825fa14c
	if ctx.cr[0].eq {
	pc = 0x825FA14C; continue 'dispatch;
	}
	// 825FA118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FA11C: 48BAF86D  bl 0x831a9988
	ctx.lr = 0x825FA120;
	sub_831A9988(ctx, base);
	// 825FA120: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825FA124: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FA128: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825FA12C: 48BADFCD  bl 0x831a80f8
	ctx.lr = 0x825FA130;
	sub_831A80F8(ctx, base);
	// 825FA130: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FA134: 41820018  beq 0x825fa14c
	if ctx.cr[0].eq {
	pc = 0x825FA14C; continue 'dispatch;
	}
	// 825FA138: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA13C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 825FA140: 4BFFF901  bl 0x825f9a40
	ctx.lr = 0x825FA144;
	sub_825F9A40(ctx, base);
	// 825FA144: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825FA148: 48000014  b 0x825fa15c
	pc = 0x825FA15C; continue 'dispatch;
	// 825FA14C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FA150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA154: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FA158: 4BF184C1  bl 0x82512618
	ctx.lr = 0x825FA15C;
	sub_82512618(ctx, base);
	// 825FA15C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FA160: 48BAE05C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FA168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FA168 size=480
    let mut pc: u32 = 0x825FA168;
    'dispatch: loop {
        match pc {
            0x825FA168 => {
    //   block [0x825FA168..0x825FA348)
	// 825FA168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FA16C: 48BADFF9  bl 0x831a8164
	ctx.lr = 0x825FA170;
	sub_831A8130(ctx, base);
	// 825FA170: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825FA174: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FA178: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FA17C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825FA180: 3BCB1530  addi r30, r11, 0x1530
	ctx.r[30].s64 = ctx.r[11].s64 + 5424;
	// 825FA184: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FA188: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FA18C: 38A0006C  li r5, 0x6c
	ctx.r[5].s64 = 108;
	// 825FA190: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FA194: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FA198: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 825FA19C: 487F824D  bl 0x82df23e8
	ctx.lr = 0x825FA1A0;
	sub_82DF23E8(ctx, base);
	// 825FA1A0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FA1A4: 41820014  beq 0x825fa1b8
	if ctx.cr[0].eq {
	pc = 0x825FA1B8; continue 'dispatch;
	}
	// 825FA1A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FA1AC: 4BFFE69D  bl 0x825f8848
	ctx.lr = 0x825FA1B0;
	sub_825F8848(ctx, base);
	// 825FA1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FA1B4: 48000008  b 0x825fa1bc
	pc = 0x825FA1BC; continue 'dispatch;
	// 825FA1B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FA1BC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FA1C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA1C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FA1C8: 4BFFE361  bl 0x825f8528
	ctx.lr = 0x825FA1CC;
	sub_825F8528(ctx, base);
	// 825FA1CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FA1D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA1D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FA1D8: 4BCC5E29  bl 0x822c0000
	ctx.lr = 0x825FA1DC;
	sub_822C0000(ctx, base);
	// 825FA1DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FA1E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FA1E4: 38A0006D  li r5, 0x6d
	ctx.r[5].s64 = 109;
	// 825FA1E8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825FA1EC: 4BCC61ED  bl 0x822c03d8
	ctx.lr = 0x825FA1F0;
	sub_822C03D8(ctx, base);
	// 825FA1F0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FA1F4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825FA1F8: 418200E0  beq 0x825fa2d8
	if ctx.cr[0].eq {
	pc = 0x825FA2D8; continue 'dispatch;
	}
	// 825FA1FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FA200: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FA204: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FA208: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825FA20C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825FA210: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FA214: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825FA218: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FA21C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825FA220: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825FA224: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825FA228: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825FA22C: 409A0008  bne cr6, 0x825fa234
	if !ctx.cr[6].eq {
	pc = 0x825FA234; continue 'dispatch;
	}
	// 825FA230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FA234: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FA238: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FA23C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825FA240: 419A0024  beq cr6, 0x825fa264
	if ctx.cr[6].eq {
	pc = 0x825FA264; continue 'dispatch;
	}
	// 825FA244: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FA248: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825FA24C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA250: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825FA254: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825FA258: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FA25C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA260: 4082FFE8  bne 0x825fa248
	if !ctx.cr[0].eq {
	pc = 0x825FA248; continue 'dispatch;
	}
	// 825FA264: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825FA268: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FA26C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825FA270: 419A0024  beq cr6, 0x825fa294
	if ctx.cr[6].eq {
	pc = 0x825FA294; continue 'dispatch;
	}
	// 825FA274: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FA278: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FA27C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA280: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FA284: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FA288: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FA28C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA290: 4082FFE8  bne 0x825fa278
	if !ctx.cr[0].eq {
	pc = 0x825FA278; continue 'dispatch;
	}
	// 825FA294: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825FA298: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825FA29C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825FA2A0: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FA2A4: 4888299D  bl 0x82e7cc40
	ctx.lr = 0x825FA2A8;
	sub_82E7CC40(ctx, base);
	// 825FA2A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825FA2AC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FA2B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825FA2B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FA2B8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825FA2BC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825FA2C0: 4819EC71  bl 0x82798f30
	ctx.lr = 0x825FA2C4;
	sub_82798F30(ctx, base);
	// 825FA2C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FA2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FA2CC: 481A139D  bl 0x8279b668
	ctx.lr = 0x825FA2D0;
	sub_8279B668(ctx, base);
	// 825FA2D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FA2D4: 48000008  b 0x825fa2dc
	pc = 0x825FA2DC; continue 'dispatch;
	// 825FA2D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FA2DC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FA2E0: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825FA2E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA2E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA2EC: 4BF9D965  bl 0x82597c50
	ctx.lr = 0x825FA2F0;
	sub_82597C50(ctx, base);
	// 825FA2F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FA2F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA2F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA2FC: 4BCC5D05  bl 0x822c0000
	ctx.lr = 0x825FA300;
	sub_822C0000(ctx, base);
	// 825FA300: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FA304: 41820024  beq 0x825fa328
	if ctx.cr[0].eq {
	pc = 0x825FA328; continue 'dispatch;
	}
	// 825FA308: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825FA30C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FA310: 419A0008  beq cr6, 0x825fa318
	if ctx.cr[6].eq {
	pc = 0x825FA318; continue 'dispatch;
	}
	// 825FA314: 4BCC657D  bl 0x822c0890
	ctx.lr = 0x825FA318;
	sub_822C0890(ctx, base);
	// 825FA318: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825FA31C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FA320: 419A0008  beq cr6, 0x825fa328
	if ctx.cr[6].eq {
	pc = 0x825FA328; continue 'dispatch;
	}
	// 825FA324: 4BCC656D  bl 0x822c0890
	ctx.lr = 0x825FA328;
	sub_822C0890(ctx, base);
	// 825FA328: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FA32C: 419A000C  beq cr6, 0x825fa338
	if ctx.cr[6].eq {
	pc = 0x825FA338; continue 'dispatch;
	}
	// 825FA330: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FA334: 4BCC655D  bl 0x822c0890
	ctx.lr = 0x825FA338;
	sub_822C0890(ctx, base);
	// 825FA338: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825FA33C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825FA340: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825FA344: 48BADE70  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FA348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FA348 size=488
    let mut pc: u32 = 0x825FA348;
    'dispatch: loop {
        match pc {
            0x825FA348 => {
    //   block [0x825FA348..0x825FA530)
	// 825FA348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FA34C: 48BADE1D  bl 0x831a8168
	ctx.lr = 0x825FA350;
	sub_831A8130(ctx, base);
	// 825FA350: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825FA354: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FA358: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FA35C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825FA360: 3BCB1530  addi r30, r11, 0x1530
	ctx.r[30].s64 = ctx.r[11].s64 + 5424;
	// 825FA364: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FA368: 38A00075  li r5, 0x75
	ctx.r[5].s64 = 117;
	// 825FA36C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FA370: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 825FA374: 487F8075  bl 0x82df23e8
	ctx.lr = 0x825FA378;
	sub_82DF23E8(ctx, base);
	// 825FA378: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FA37C: 41820014  beq 0x825fa390
	if ctx.cr[0].eq {
	pc = 0x825FA390; continue 'dispatch;
	}
	// 825FA380: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FA384: 4BFFE4C5  bl 0x825f8848
	ctx.lr = 0x825FA388;
	sub_825F8848(ctx, base);
	// 825FA388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FA38C: 48000008  b 0x825fa394
	pc = 0x825FA394; continue 'dispatch;
	// 825FA390: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FA394: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FA398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA39C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FA3A0: 4BFFE189  bl 0x825f8528
	ctx.lr = 0x825FA3A4;
	sub_825F8528(ctx, base);
	// 825FA3A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FA3A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA3AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FA3B0: 4BCC5C51  bl 0x822c0000
	ctx.lr = 0x825FA3B4;
	sub_822C0000(ctx, base);
	// 825FA3B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FA3B8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FA3BC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FA3C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825FA3C4: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FA3C8: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825FA3CC: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FA3D0: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825FA3D4: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825FA3D8: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825FA3DC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825FA3E0: 409A0008  bne cr6, 0x825fa3e8
	if !ctx.cr[6].eq {
	pc = 0x825FA3E8; continue 'dispatch;
	}
	// 825FA3E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FA3E8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FA3EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825FA3F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FA3F4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825FA3F8: 419A0024  beq cr6, 0x825fa41c
	if ctx.cr[6].eq {
	pc = 0x825FA41C; continue 'dispatch;
	}
	// 825FA3FC: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FA400: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825FA404: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA408: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825FA40C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825FA410: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FA414: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA418: 4082FFE8  bne 0x825fa400
	if !ctx.cr[0].eq {
	pc = 0x825FA400; continue 'dispatch;
	}
	// 825FA41C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825FA420: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FA424: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825FA428: 419A0024  beq cr6, 0x825fa44c
	if ctx.cr[6].eq {
	pc = 0x825FA44C; continue 'dispatch;
	}
	// 825FA42C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FA430: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FA434: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA438: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FA43C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FA440: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FA444: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FA448: 4082FFE8  bne 0x825fa430
	if !ctx.cr[0].eq {
	pc = 0x825FA430; continue 'dispatch;
	}
	// 825FA44C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825FA450: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FA454: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FA458: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FA45C: 488827E5  bl 0x82e7cc40
	ctx.lr = 0x825FA460;
	sub_82E7CC40(ctx, base);
	// 825FA460: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825FA464: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FA468: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FA46C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FA470: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825FA474: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825FA478: 4819EAB9  bl 0x82798f30
	ctx.lr = 0x825FA47C;
	sub_82798F30(ctx, base);
	// 825FA47C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825FA480: C1A100B0  lfs f13, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FA484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FA488: C18100B4  lfs f12, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FA48C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FA490: 38A00079  li r5, 0x79
	ctx.r[5].s64 = 121;
	// 825FA494: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825FA498: C00B6218  lfs f0, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FA49C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FA4A0: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 825FA4A4: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FA4A8: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 825FA4AC: 4BCC5F2D  bl 0x822c03d8
	ctx.lr = 0x825FA4B0;
	sub_822C03D8(ctx, base);
	// 825FA4B0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FA4B4: 41820014  beq 0x825fa4c8
	if ctx.cr[0].eq {
	pc = 0x825FA4C8; continue 'dispatch;
	}
	// 825FA4B8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825FA4BC: 481A11AD  bl 0x8279b668
	ctx.lr = 0x825FA4C0;
	sub_8279B668(ctx, base);
	// 825FA4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FA4C4: 48000008  b 0x825fa4cc
	pc = 0x825FA4CC; continue 'dispatch;
	// 825FA4C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FA4CC: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FA4D0: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825FA4D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA4DC: 4BF9D775  bl 0x82597c50
	ctx.lr = 0x825FA4E0;
	sub_82597C50(ctx, base);
	// 825FA4E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FA4E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FA4E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA4EC: 4BCC5B15  bl 0x822c0000
	ctx.lr = 0x825FA4F0;
	sub_822C0000(ctx, base);
	// 825FA4F0: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825FA4F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FA4F8: 419A0008  beq cr6, 0x825fa500
	if ctx.cr[6].eq {
	pc = 0x825FA500; continue 'dispatch;
	}
	// 825FA4FC: 4BCC6395  bl 0x822c0890
	ctx.lr = 0x825FA500;
	sub_822C0890(ctx, base);
	// 825FA500: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825FA504: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FA508: 419A0008  beq cr6, 0x825fa510
	if ctx.cr[6].eq {
	pc = 0x825FA510; continue 'dispatch;
	}
	// 825FA50C: 4BCC6385  bl 0x822c0890
	ctx.lr = 0x825FA510;
	sub_822C0890(ctx, base);
	// 825FA510: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FA514: 419A000C  beq cr6, 0x825fa520
	if ctx.cr[6].eq {
	pc = 0x825FA520; continue 'dispatch;
	}
	// 825FA518: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FA51C: 4BCC6375  bl 0x822c0890
	ctx.lr = 0x825FA520;
	sub_822C0890(ctx, base);
	// 825FA520: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FA524: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825FA528: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825FA52C: 48BADC8C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FA530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FA530 size=1396
    let mut pc: u32 = 0x825FA530;
    'dispatch: loop {
        match pc {
            0x825FA530 => {
    //   block [0x825FA530..0x825FAAA4)
	// 825FA530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FA534: 48BADC2D  bl 0x831a8160
	ctx.lr = 0x825FA538;
	sub_831A8130(ctx, base);
	// 825FA538: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825FA53C: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FA540: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FA544: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825FA548: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825FA54C: 4BF1748D  bl 0x825119d8
	ctx.lr = 0x825FA550;
	sub_825119D8(ctx, base);
	// 825FA550: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FA554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FA558: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825FA55C: 487F94AD  bl 0x82df3a08
	ctx.lr = 0x825FA560;
	sub_82DF3A08(ctx, base);
	// 825FA560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA564: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FA568: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FA56C: 4BF0E215  bl 0x82508780
	ctx.lr = 0x825FA570;
	sub_82508780(ctx, base);
	// 825FA570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FA574: 487F8EB5  bl 0x82df3428
	ctx.lr = 0x825FA578;
	sub_82DF3428(ctx, base);
	// 825FA578: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FA57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FA580: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 825FA584: 487F9485  bl 0x82df3a08
	ctx.lr = 0x825FA588;
	sub_82DF3A08(ctx, base);
	// 825FA588: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FA58C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FA590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA594: 4BF0E1ED  bl 0x82508780
	ctx.lr = 0x825FA598;
	sub_82508780(ctx, base);
	// 825FA598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FA59C: 487F8E8D  bl 0x82df3428
	ctx.lr = 0x825FA5A0;
	sub_82DF3428(ctx, base);
	// 825FA5A0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825FA5A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FA5A8: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825FA5AC: 409A0008  bne cr6, 0x825fa5b4
	if !ctx.cr[6].eq {
	pc = 0x825FA5B4; continue 'dispatch;
	}
	// 825FA5B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FA5B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FA5B8: 4BF0E1E9  bl 0x825087a0
	ctx.lr = 0x825FA5BC;
	sub_825087A0(ctx, base);
	// 825FA5BC: 817F00F8  lwz r11, 0xf8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825FA5C0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825FA5C4: 4098000C  bge cr6, 0x825fa5d0
	if !ctx.cr[6].lt {
	pc = 0x825FA5D0; continue 'dispatch;
	}
	// 825FA5C8: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825FA5CC: 2B0B002D  cmplwi cr6, r11, 0x2d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 45 as u32, &mut ctx.xer);
	// 825FA5D0: 409A000C  bne cr6, 0x825fa5dc
	if !ctx.cr[6].eq {
	pc = 0x825FA5DC; continue 'dispatch;
	}
	// 825FA5D4: 3960001E  li r11, 0x1e
	ctx.r[11].s64 = 30;
	// 825FA5D8: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 825FA5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FA5E0: 809F00FC  lwz r4, 0xfc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825FA5E4: 4BFFE955  bl 0x825f8f38
	ctx.lr = 0x825FA5E8;
	sub_825F8F38(ctx, base);
	// 825FA5E8: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825FA5EC: 815F00F8  lwz r10, 0xf8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825FA5F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825FA5F4: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 825FA5F8: 409A01E8  bne cr6, 0x825fa7e0
	if !ctx.cr[6].eq {
	pc = 0x825FA7E0; continue 'dispatch;
	}
	// 825FA5FC: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 825FA600: 419A0024  beq cr6, 0x825fa624
	if ctx.cr[6].eq {
	pc = 0x825FA624; continue 'dispatch;
	}
	// 825FA604: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 825FA608: 419A0014  beq cr6, 0x825fa61c
	if ctx.cr[6].eq {
	pc = 0x825FA61C; continue 'dispatch;
	}
	// 825FA60C: 396BFFD3  addi r11, r11, -0x2d
	ctx.r[11].s64 = ctx.r[11].s64 + -45;
	// 825FA610: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825FA614: 556BE7BC  rlwinm r11, r11, 0x1c, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825FA618: 48000010  b 0x825fa628
	pc = 0x825FA628; continue 'dispatch;
	// 825FA61C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825FA620: 48000008  b 0x825fa628
	pc = 0x825FA628; continue 'dispatch;
	// 825FA624: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825FA628: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825FA62C: 419800E0  blt cr6, 0x825fa70c
	if ctx.cr[6].lt {
	pc = 0x825FA70C; continue 'dispatch;
	}
	// 825FA630: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825FA634: 4098037C  bge cr6, 0x825fa9b0
	if !ctx.cr[6].lt {
	pc = 0x825FA9B0; continue 'dispatch;
	}
	// 825FA638: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FA63C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825FA640: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825FA644: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825FA648: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825FA64C: 488A60E5  bl 0x82ea0730
	ctx.lr = 0x825FA650;
	sub_82EA0730(ctx, base);
	// 825FA650: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FA654: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825FA658: 396B1700  addi r11, r11, 0x1700
	ctx.r[11].s64 = ctx.r[11].s64 + 5888;
	// 825FA65C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 825FA660: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 825FA664: B1230004  sth r9, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 825FA668: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825FA66C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FAAA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FAAA8 size=132
    let mut pc: u32 = 0x825FAAA8;
    'dispatch: loop {
        match pc {
            0x825FAAA8 => {
    //   block [0x825FAAA8..0x825FAB2C)
	// 825FAAA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FAAAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FAAB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FAAB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FAAB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FAABC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FAAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FAAC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FAAC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAACC: 388B17B4  addi r4, r11, 0x17b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6068;
	// 825FAAD0: 487F8F39  bl 0x82df3a08
	ctx.lr = 0x825FAAD4;
	sub_82DF3A08(ctx, base);
	// 825FAAD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FAAD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FAADC: 88BF006C  lbz r5, 0x6c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FAAE0: 4BFA6AA9  bl 0x825a1588
	ctx.lr = 0x825FAAE4;
	sub_825A1588(ctx, base);
	// 825FAAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAAE8: 487F8941  bl 0x82df3428
	ctx.lr = 0x825FAAEC;
	sub_82DF3428(ctx, base);
	// 825FAAEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FAAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAAF4: 388B179C  addi r4, r11, 0x179c
	ctx.r[4].s64 = ctx.r[11].s64 + 6044;
	// 825FAAF8: 487F8F11  bl 0x82df3a08
	ctx.lr = 0x825FAAFC;
	sub_82DF3A08(ctx, base);
	// 825FAAFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FAB00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FAB04: 88BF006C  lbz r5, 0x6c(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FAB08: 4BFA6A81  bl 0x825a1588
	ctx.lr = 0x825FAB0C;
	sub_825A1588(ctx, base);
	// 825FAB0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAB10: 487F8919  bl 0x82df3428
	ctx.lr = 0x825FAB14;
	sub_82DF3428(ctx, base);
	// 825FAB14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FAB18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FAB1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FAB20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FAB24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FAB28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FAB30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FAB30 size=116
    let mut pc: u32 = 0x825FAB30;
    'dispatch: loop {
        match pc {
            0x825FAB30 => {
    //   block [0x825FAB30..0x825FABA4)
	// 825FAB30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FAB34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FAB38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FAB3C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FAB40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FAB44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FAB48: 419A0040  beq cr6, 0x825fab88
	if ctx.cr[6].eq {
	pc = 0x825FAB88; continue 'dispatch;
	}
	// 825FAB4C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 825FAB50: 0CDF0000  twi 6, r31, 0
	// 825FAB54: 7D6BFB96  divwu r11, r11, r31
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 825FAB58: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825FAB5C: 4098002C  bge cr6, 0x825fab88
	if !ctx.cr[6].lt {
	pc = 0x825FAB88; continue 'dispatch;
	}
	// 825FAB60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FAB64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825FAB68: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 825FAB6C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825FAB70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAB74: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825FAB78: 4BCC9739  bl 0x822c42b0
	ctx.lr = 0x825FAB7C;
	sub_822C42B0(ctx, base);
	// 825FAB7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FAB80: 396B0818  addi r11, r11, 0x818
	ctx.r[11].s64 = ctx.r[11].s64 + 2072;
	// 825FAB84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825FAB88: 57E31838  slwi r3, r31, 3
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825FAB8C: 4BCC5DAD  bl 0x822c0938
	ctx.lr = 0x825FAB90;
	sub_822C0938(ctx, base);
	// 825FAB90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FAB94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FAB98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FAB9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FABA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FABA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FABA8 size=136
    let mut pc: u32 = 0x825FABA8;
    'dispatch: loop {
        match pc {
            0x825FABA8 => {
    //   block [0x825FABA8..0x825FAC30)
	// 825FABA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FABAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FABB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FABB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FABB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FABBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FABC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FABC4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825FABC8: 409A0020  bne cr6, 0x825fabe8
	if !ctx.cr[6].eq {
	pc = 0x825FABE8; continue 'dispatch;
	}
	// 825FABCC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FABD0: 419A0048  beq cr6, 0x825fac18
	if ctx.cr[6].eq {
	pc = 0x825FAC18; continue 'dispatch;
	}
	// 825FABD4: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 825FABD8: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825FABDC: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 825FABE0: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825FABE4: 48000034  b 0x825fac18
	pc = 0x825FAC18; continue 'dispatch;
	// 825FABE8: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825FABEC: 419A002C  beq cr6, 0x825fac18
	if ctx.cr[6].eq {
	pc = 0x825FAC18; continue 'dispatch;
	}
	// 825FABF0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FABF4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FABF8: 388BF958  addi r4, r11, -0x6a8
	ctx.r[4].s64 = ctx.r[11].s64 + -1704;
	// 825FABFC: 48BAD4FD  bl 0x831a80f8
	ctx.lr = 0x825FAC00;
	sub_831A80F8(ctx, base);
	// 825FAC00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FAC04: 4182000C  beq 0x825fac10
	if ctx.cr[0].eq {
	pc = 0x825FAC10; continue 'dispatch;
	}
	// 825FAC08: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825FAC0C: 4800000C  b 0x825fac18
	pc = 0x825FAC18; continue 'dispatch;
	// 825FAC10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAC14: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAC18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FAC1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FAC20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FAC24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FAC28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FAC2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FAC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FAC30 size=196
    let mut pc: u32 = 0x825FAC30;
    'dispatch: loop {
        match pc {
            0x825FAC30 => {
    //   block [0x825FAC30..0x825FACF4)
	// 825FAC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FAC34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FAC38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FAC3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FAC40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FAC44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FAC48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAC4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FAC50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FAC54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAC58: 4BCC5CE1  bl 0x822c0938
	ctx.lr = 0x825FAC5C;
	sub_822C0938(ctx, base);
	// 825FAC5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FAC60: 41820028  beq 0x825fac88
	if ctx.cr[0].eq {
	pc = 0x825FAC88; continue 'dispatch;
	}
	// 825FAC64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FAC68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FAC6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FAC70: 392B17C8  addi r9, r11, 0x17c8
	ctx.r[9].s64 = ctx.r[11].s64 + 6088;
	// 825FAC74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FAC78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FAC7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FAC80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FAC84: 48000008  b 0x825fac8c
	pc = 0x825FAC8C; continue 'dispatch;
	// 825FAC88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAC8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAC90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FAC94: 409A0044  bne cr6, 0x825facd8
	if !ctx.cr[6].eq {
	pc = 0x825FACD8; continue 'dispatch;
	}
	// 825FAC98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FAC9C: 419A001C  beq cr6, 0x825facb8
	if ctx.cr[6].eq {
	pc = 0x825FACB8; continue 'dispatch;
	}
	// 825FACA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FACA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FACA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FACAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FACB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FACB4: 4E800421  bctrl
	ctx.lr = 0x825FACB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FACB8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FACBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FACC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FACC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FACC8: 816BF840  lwz r11, -0x7c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1984 as u32) ) } as u64;
	// 825FACCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FACD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FACD4: 4BCC532D  bl 0x822c0000
	ctx.lr = 0x825FACD8;
	sub_822C0000(ctx, base);
	// 825FACD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FACDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FACE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FACE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FACE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FACEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FACF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FACF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FACF8 size=196
    let mut pc: u32 = 0x825FACF8;
    'dispatch: loop {
        match pc {
            0x825FACF8 => {
    //   block [0x825FACF8..0x825FADBC)
	// 825FACF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FACFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FAD00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FAD04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FAD08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FAD0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FAD10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAD14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FAD18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FAD1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAD20: 4BCC5C19  bl 0x822c0938
	ctx.lr = 0x825FAD24;
	sub_822C0938(ctx, base);
	// 825FAD24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FAD28: 41820028  beq 0x825fad50
	if ctx.cr[0].eq {
	pc = 0x825FAD50; continue 'dispatch;
	}
	// 825FAD2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FAD30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FAD34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FAD38: 392B17DC  addi r9, r11, 0x17dc
	ctx.r[9].s64 = ctx.r[11].s64 + 6108;
	// 825FAD3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FAD40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FAD44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FAD48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FAD4C: 48000008  b 0x825fad54
	pc = 0x825FAD54; continue 'dispatch;
	// 825FAD50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAD54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FAD5C: 409A0044  bne cr6, 0x825fada0
	if !ctx.cr[6].eq {
	pc = 0x825FADA0; continue 'dispatch;
	}
	// 825FAD60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FAD64: 419A001C  beq cr6, 0x825fad80
	if ctx.cr[6].eq {
	pc = 0x825FAD80; continue 'dispatch;
	}
	// 825FAD68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FAD6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FAD70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FAD74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FAD78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FAD7C: 4E800421  bctrl
	ctx.lr = 0x825FAD80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FAD80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FAD84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FAD88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAD8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FAD90: 816BF840  lwz r11, -0x7c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1984 as u32) ) } as u64;
	// 825FAD94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FAD98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FAD9C: 4BCC5265  bl 0x822c0000
	ctx.lr = 0x825FADA0;
	sub_822C0000(ctx, base);
	// 825FADA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FADA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FADA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FADAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FADB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FADB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FADB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FADC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FADC0 size=196
    let mut pc: u32 = 0x825FADC0;
    'dispatch: loop {
        match pc {
            0x825FADC0 => {
    //   block [0x825FADC0..0x825FAE84)
	// 825FADC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FADC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FADC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FADCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FADD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FADD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FADD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FADDC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FADE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FADE4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FADE8: 4BCC5B51  bl 0x822c0938
	ctx.lr = 0x825FADEC;
	sub_822C0938(ctx, base);
	// 825FADEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FADF0: 41820028  beq 0x825fae18
	if ctx.cr[0].eq {
	pc = 0x825FAE18; continue 'dispatch;
	}
	// 825FADF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FADF8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FADFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FAE00: 392B17F0  addi r9, r11, 0x17f0
	ctx.r[9].s64 = ctx.r[11].s64 + 6128;
	// 825FAE04: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FAE08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FAE0C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FAE10: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FAE14: 48000008  b 0x825fae1c
	pc = 0x825FAE1C; continue 'dispatch;
	// 825FAE18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAE1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAE20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FAE24: 409A0044  bne cr6, 0x825fae68
	if !ctx.cr[6].eq {
	pc = 0x825FAE68; continue 'dispatch;
	}
	// 825FAE28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FAE2C: 419A001C  beq cr6, 0x825fae48
	if ctx.cr[6].eq {
	pc = 0x825FAE48; continue 'dispatch;
	}
	// 825FAE30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FAE34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FAE38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FAE3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FAE40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FAE44: 4E800421  bctrl
	ctx.lr = 0x825FAE48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FAE48: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FAE4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FAE50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FAE54: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FAE58: 816BF840  lwz r11, -0x7c0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1984 as u32) ) } as u64;
	// 825FAE5C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FAE60: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FAE64: 4BCC519D  bl 0x822c0000
	ctx.lr = 0x825FAE68;
	sub_822C0000(ctx, base);
	// 825FAE68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FAE6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FAE70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FAE74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FAE78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FAE7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FAE80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FAE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FAE88 size=72
    let mut pc: u32 = 0x825FAE88;
    'dispatch: loop {
        match pc {
            0x825FAE88 => {
    //   block [0x825FAE88..0x825FAED0)
	// 825FAE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FAE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FAE90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FAE94: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 825FAE98: 419A001C  beq cr6, 0x825faeb4
	if ctx.cr[6].eq {
	pc = 0x825FAEB4; continue 'dispatch;
	}
	// 825FAE9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825FAEA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825FAEA4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825FAEA8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FAEAC: 4BFFFCFD  bl 0x825faba8
	ctx.lr = 0x825FAEB0;
	sub_825FABA8(ctx, base);
	// 825FAEB0: 48000010  b 0x825faec0
	pc = 0x825FAEC0; continue 'dispatch;
	// 825FAEB4: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FAEB8: 396BF958  addi r11, r11, -0x6a8
	ctx.r[11].s64 = ctx.r[11].s64 + -1704;
	// 825FAEBC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FAEC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FAEC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FAEC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FAECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FAED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FAED0 size=324
    let mut pc: u32 = 0x825FAED0;
    'dispatch: loop {
        match pc {
            0x825FAED0 => {
    //   block [0x825FAED0..0x825FB014)
	// 825FAED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FAED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FAED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FAEDC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825FAEE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FAEE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FAEE8: FFE02090  fmr f31, f4
	ctx.f[31].f64 = ctx.f[4].f64;
	// 825FAEEC: 4BF17375  bl 0x82512260
	ctx.lr = 0x825FAEF0;
	sub_82512260(ctx, base);
	// 825FAEF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FAEF4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FAEF8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825FAEFC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825FAF00: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825FAF04: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825FAF08: 394A1864  addi r10, r10, 0x1864
	ctx.r[10].s64 = ctx.r[10].s64 + 6244;
	// 825FAF0C: 39291850  addi r9, r9, 0x1850
	ctx.r[9].s64 = ctx.r[9].s64 + 6224;
	// 825FAF10: 39081804  addi r8, r8, 0x1804
	ctx.r[8].s64 = ctx.r[8].s64 + 6148;
	// 825FAF14: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825FAF18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FAF1C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825FAF20: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825FAF24: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FAF28: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825FAF2C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825FAF30: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825FAF34: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 825FAF38: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825FAF3C: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 825FAF40: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825FAF44: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 825FAF48: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 825FAF4C: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FAF50: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 825FAF54: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 825FAF58: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 825FAF5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825FAF60: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 825FAF64: C1A87BC8  lfs f13, 0x7bc8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(31688 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FAF68: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825FAF6C: C189E4E4  lfs f12, -0x1b1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6940 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FAF70: 917F010C  stw r11, 0x10c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[11].u32 ) };
	// 825FAF74: C1679D1C  lfs f11, -0x62e4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825FAF78: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825FAF7C: C14608A8  lfs f10, 0x8a8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2216 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825FAF80: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 825FAF84: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 825FAF88: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 825FAF8C: C12A89AC  lfs f9, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825FAF90: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 825FAF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FAF98: 917F0124  stw r11, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825FAF9C: 917F0128  stw r11, 0x128(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 825FAFA0: 917F012C  stw r11, 0x12c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825FAFA4: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 825FAFA8: D19F0134  stfs f12, 0x134(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 825FAFAC: D1BF0138  stfs f13, 0x138(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 825FAFB0: 997F0148  stb r11, 0x148(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u8 ) };
	// 825FAFB4: D17F013C  stfs f11, 0x13c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), tmp.u32 ) };
	// 825FAFB8: 997F0150  stb r11, 0x150(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u8 ) };
	// 825FAFBC: D01F0140  stfs f0, 0x140(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FAFC0: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 825FAFC4: D3FF0144  stfs f31, 0x144(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 825FAFC8: 997F0160  stb r11, 0x160(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u8 ) };
	// 825FAFCC: D15F014C  stfs f10, 0x14c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 825FAFD0: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825FAFD4: D13F0154  stfs f9, 0x154(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 825FAFD8: 997F017C  stb r11, 0x17c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u8 ) };
	// 825FAFDC: D1BF0158  stfs f13, 0x158(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 825FAFE0: 997F017D  stb r11, 0x17d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(381 as u32), ctx.r[11].u8 ) };
	// 825FAFE4: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FAFE8: 997F017E  stb r11, 0x17e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(382 as u32), ctx.r[11].u8 ) };
	// 825FAFEC: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 825FAFF0: 98BF018C  stb r5, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[5].u8 ) };
	// 825FAFF4: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FAFF8: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825FAFFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FB000: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FB004: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FB008: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FB00C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FB010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FB018 size=8
    let mut pc: u32 = 0x825FB018;
    'dispatch: loop {
        match pc {
            0x825FB018 => {
    //   block [0x825FB018..0x825FB020)
	// 825FB018: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825FB01C: 4800084C  b 0x825fb868
	sub_825FB868(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FB020 size=8
    let mut pc: u32 = 0x825FB020;
    'dispatch: loop {
        match pc {
            0x825FB020 => {
    //   block [0x825FB020..0x825FB028)
	// 825FB020: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825FB024: 48000844  b 0x825fb868
	sub_825FB868(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB028 size=248
    let mut pc: u32 = 0x825FB028;
    'dispatch: loop {
        match pc {
            0x825FB028 => {
    //   block [0x825FB028..0x825FB120)
	// 825FB028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FB030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FB034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FB038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB03C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB040: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FB044: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FB048: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825FB04C: 396B1864  addi r11, r11, 0x1864
	ctx.r[11].s64 = ctx.r[11].s64 + 6244;
	// 825FB050: 394A1850  addi r10, r10, 0x1850
	ctx.r[10].s64 = ctx.r[10].s64 + 6224;
	// 825FB054: 39291804  addi r9, r9, 0x1804
	ctx.r[9].s64 = ctx.r[9].s64 + 6148;
	// 825FB058: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FB05C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 825FB060: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 825FB064: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 825FB068: 807F0130  lwz r3, 0x130(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 825FB06C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB070: 419A0008  beq cr6, 0x825fb078
	if ctx.cr[6].eq {
	pc = 0x825FB078; continue 'dispatch;
	}
	// 825FB074: 4BCC581D  bl 0x822c0890
	ctx.lr = 0x825FB078;
	sub_822C0890(ctx, base);
	// 825FB078: 807F0128  lwz r3, 0x128(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 825FB07C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB080: 419A0008  beq cr6, 0x825fb088
	if ctx.cr[6].eq {
	pc = 0x825FB088; continue 'dispatch;
	}
	// 825FB084: 4BCC580D  bl 0x822c0890
	ctx.lr = 0x825FB088;
	sub_822C0890(ctx, base);
	// 825FB088: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825FB08C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB090: 419A0008  beq cr6, 0x825fb098
	if ctx.cr[6].eq {
	pc = 0x825FB098; continue 'dispatch;
	}
	// 825FB094: 4BCC57FD  bl 0x822c0890
	ctx.lr = 0x825FB098;
	sub_822C0890(ctx, base);
	// 825FB098: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825FB09C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB0A0: 419A0008  beq cr6, 0x825fb0a8
	if ctx.cr[6].eq {
	pc = 0x825FB0A8; continue 'dispatch;
	}
	// 825FB0A4: 4BCC57ED  bl 0x822c0890
	ctx.lr = 0x825FB0A8;
	sub_822C0890(ctx, base);
	// 825FB0A8: 807F010C  lwz r3, 0x10c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 825FB0AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB0B0: 419A0008  beq cr6, 0x825fb0b8
	if ctx.cr[6].eq {
	pc = 0x825FB0B8; continue 'dispatch;
	}
	// 825FB0B4: 4BCC57DD  bl 0x822c0890
	ctx.lr = 0x825FB0B8;
	sub_822C0890(ctx, base);
	// 825FB0B8: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 825FB0BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB0C0: 419A0008  beq cr6, 0x825fb0c8
	if ctx.cr[6].eq {
	pc = 0x825FB0C8; continue 'dispatch;
	}
	// 825FB0C4: 4BCC57CD  bl 0x822c0890
	ctx.lr = 0x825FB0C8;
	sub_822C0890(ctx, base);
	// 825FB0C8: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825FB0CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB0D0: 419A0008  beq cr6, 0x825fb0d8
	if ctx.cr[6].eq {
	pc = 0x825FB0D8; continue 'dispatch;
	}
	// 825FB0D4: 4BCC57BD  bl 0x822c0890
	ctx.lr = 0x825FB0D8;
	sub_822C0890(ctx, base);
	// 825FB0D8: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825FB0DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB0E0: 419A0008  beq cr6, 0x825fb0e8
	if ctx.cr[6].eq {
	pc = 0x825FB0E8; continue 'dispatch;
	}
	// 825FB0E4: 4BCC57AD  bl 0x822c0890
	ctx.lr = 0x825FB0E8;
	sub_822C0890(ctx, base);
	// 825FB0E8: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825FB0EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB0F0: 419A0008  beq cr6, 0x825fb0f8
	if ctx.cr[6].eq {
	pc = 0x825FB0F8; continue 'dispatch;
	}
	// 825FB0F4: 4BCC579D  bl 0x822c0890
	ctx.lr = 0x825FB0F8;
	sub_822C0890(ctx, base);
	// 825FB0F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB0FC: 481AC55D  bl 0x827a7658
	ctx.lr = 0x825FB100;
	sub_827A7658(ctx, base);
	// 825FB100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB104: 4BD5424D  bl 0x8234f350
	ctx.lr = 0x825FB108;
	sub_8234F350(ctx, base);
	// 825FB108: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FB10C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FB110: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FB114: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FB118: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FB11C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB120 size=112
    let mut pc: u32 = 0x825FB120;
    'dispatch: loop {
        match pc {
            0x825FB120 => {
    //   block [0x825FB120..0x825FB190)
	// 825FB120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FB128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FB12C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FB130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB134: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB138: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FB13C: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825FB140: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FB144: 4881811D  bl 0x82e13260
	ctx.lr = 0x825FB148;
	sub_82E13260(ctx, base);
	// 825FB148: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FB14C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825FB150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB154: 419A0020  beq cr6, 0x825fb174
	if ctx.cr[6].eq {
	pc = 0x825FB174; continue 'dispatch;
	}
	// 825FB158: 4854B571  bl 0x82b466c8
	ctx.lr = 0x825FB15C;
	sub_82B466C8(ctx, base);
	// 825FB15C: 93DF011C  stw r30, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[30].u32 ) };
	// 825FB160: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825FB164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB168: 93DF0120  stw r30, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[30].u32 ) };
	// 825FB16C: 419A0008  beq cr6, 0x825fb174
	if ctx.cr[6].eq {
	pc = 0x825FB174; continue 'dispatch;
	}
	// 825FB170: 4BCC5721  bl 0x822c0890
	ctx.lr = 0x825FB174;
	sub_822C0890(ctx, base);
	// 825FB174: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 825FB178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FB17C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FB180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FB184: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FB188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FB18C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB190 size=524
    let mut pc: u32 = 0x825FB190;
    'dispatch: loop {
        match pc {
            0x825FB190 => {
    //   block [0x825FB190..0x825FB39C)
	// 825FB190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB194: 48BACFC9  bl 0x831a815c
	ctx.lr = 0x825FB198;
	sub_831A8130(ctx, base);
	// 825FB198: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB19C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FB1A0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825FB1A4: 3B6B18A0  addi r27, r11, 0x18a0
	ctx.r[27].s64 = ctx.r[11].s64 + 6304;
	// 825FB1A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FB1AC: 38A00251  li r5, 0x251
	ctx.r[5].s64 = 593;
	// 825FB1B0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FB1B4: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825FB1B8: 487F7231  bl 0x82df23e8
	ctx.lr = 0x825FB1BC;
	sub_82DF23E8(ctx, base);
	// 825FB1BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FB1C0: 41820010  beq 0x825fb1d0
	if ctx.cr[0].eq {
	pc = 0x825FB1D0; continue 'dispatch;
	}
	// 825FB1C4: 48155C4D  bl 0x82750e10
	ctx.lr = 0x825FB1C8;
	sub_82750E10(ctx, base);
	// 825FB1C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB1CC: 48000008  b 0x825fb1d4
	pc = 0x825FB1D4; continue 'dispatch;
	// 825FB1D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB1D4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FB1D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB1DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB1E0: 4BFE5659  bl 0x825e0838
	ctx.lr = 0x825FB1E4;
	sub_825E0838(ctx, base);
	// 825FB1E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FB1E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB1EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB1F0: 4BCC4E11  bl 0x822c0000
	ctx.lr = 0x825FB1F4;
	sub_822C0000(ctx, base);
	// 825FB1F4: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FB1F8: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FB1FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FB200: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825FB204: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FB208: 419A0024  beq cr6, 0x825fb22c
	if ctx.cr[6].eq {
	pc = 0x825FB22C; continue 'dispatch;
	}
	// 825FB20C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FB210: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FB214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FB218: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FB21C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FB220: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FB224: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FB228: 4082FFE8  bne 0x825fb210
	if !ctx.cr[0].eq {
	pc = 0x825FB210; continue 'dispatch;
	}
	// 825FB22C: 3BDAFF1C  addi r30, r26, -0xe4
	ctx.r[30].s64 = ctx.r[26].s64 + -228;
	// 825FB230: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FB234: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FB238: 4BF14291  bl 0x8250f4c8
	ctx.lr = 0x825FB23C;
	sub_8250F4C8(ctx, base);
	// 825FB23C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FB244: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 825FB248: 409A0008  bne cr6, 0x825fb250
	if !ctx.cr[6].eq {
	pc = 0x825FB250; continue 'dispatch;
	}
	// 825FB24C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB250: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FB254: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FB258: 3B210050  addi r25, r1, 0x50
	ctx.r[25].s64 = ctx.r[1].s64 + 80;
	// 825FB25C: 4BF142BD  bl 0x8250f518
	ctx.lr = 0x825FB260;
	sub_8250F518(ctx, base);
	// 825FB260: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FB264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB268: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825FB26C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825FB270: 4BF12299  bl 0x8250d508
	ctx.lr = 0x825FB274;
	sub_8250D508(ctx, base);
	// 825FB274: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FB278: 487F6A19  bl 0x82df1c90
	ctx.lr = 0x825FB27C;
	sub_82DF1C90(ctx, base);
	// 825FB27C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FB280: 487F6A11  bl 0x82df1c90
	ctx.lr = 0x825FB284;
	sub_82DF1C90(ctx, base);
	// 825FB284: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 825FB288: 48A0DD31  bl 0x83008fb8
	ctx.lr = 0x825FB28C;
	sub_83008FB8(ctx, base);
	// 825FB28C: 907A0084  stw r3, 0x84(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 825FB290: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FB294: 419A000C  beq cr6, 0x825fb2a0
	if ctx.cr[6].eq {
	pc = 0x825FB2A0; continue 'dispatch;
	}
	// 825FB298: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FB29C: 4BCC55F5  bl 0x822c0890
	ctx.lr = 0x825FB2A0;
	sub_822C0890(ctx, base);
	// 825FB2A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FB2A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FB2A8: 38A00256  li r5, 0x256
	ctx.r[5].s64 = 598;
	// 825FB2AC: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825FB2B0: 487F7139  bl 0x82df23e8
	ctx.lr = 0x825FB2B4;
	sub_82DF23E8(ctx, base);
	// 825FB2B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FB2B8: 41820010  beq 0x825fb2c8
	if ctx.cr[0].eq {
	pc = 0x825FB2C8; continue 'dispatch;
	}
	// 825FB2BC: 48155B55  bl 0x82750e10
	ctx.lr = 0x825FB2C0;
	sub_82750E10(ctx, base);
	// 825FB2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB2C4: 48000008  b 0x825fb2cc
	pc = 0x825FB2CC; continue 'dispatch;
	// 825FB2C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB2CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FB2D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB2D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB2D8: 4BFE5561  bl 0x825e0838
	ctx.lr = 0x825FB2DC;
	sub_825E0838(ctx, base);
	// 825FB2DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FB2E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB2E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB2E8: 4BCC4D19  bl 0x822c0000
	ctx.lr = 0x825FB2EC;
	sub_822C0000(ctx, base);
	// 825FB2EC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FB2F0: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FB2F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FB2F8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825FB2FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FB300: 419A0024  beq cr6, 0x825fb324
	if ctx.cr[6].eq {
	pc = 0x825FB324; continue 'dispatch;
	}
	// 825FB304: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FB308: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FB30C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FB310: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FB314: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FB318: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FB31C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FB320: 4082FFE8  bne 0x825fb308
	if !ctx.cr[0].eq {
	pc = 0x825FB308; continue 'dispatch;
	}
	// 825FB324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FB328: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FB32C: 4BF1419D  bl 0x8250f4c8
	ctx.lr = 0x825FB330;
	sub_8250F4C8(ctx, base);
	// 825FB330: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FB338: 3BEBFFFC  addi r31, r11, -4
	ctx.r[31].s64 = ctx.r[11].s64 + -4;
	// 825FB33C: 409A0008  bne cr6, 0x825fb344
	if !ctx.cr[6].eq {
	pc = 0x825FB344; continue 'dispatch;
	}
	// 825FB340: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB344: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FB348: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FB34C: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 825FB350: 4BF141C9  bl 0x8250f518
	ctx.lr = 0x825FB354;
	sub_8250F518(ctx, base);
	// 825FB354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FB358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB35C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825FB360: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825FB364: 4BF121A5  bl 0x8250d508
	ctx.lr = 0x825FB368;
	sub_8250D508(ctx, base);
	// 825FB368: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FB36C: 487F6925  bl 0x82df1c90
	ctx.lr = 0x825FB370;
	sub_82DF1C90(ctx, base);
	// 825FB370: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FB374: 487F691D  bl 0x82df1c90
	ctx.lr = 0x825FB378;
	sub_82DF1C90(ctx, base);
	// 825FB378: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 825FB37C: 48A0DC3D  bl 0x83008fb8
	ctx.lr = 0x825FB380;
	sub_83008FB8(ctx, base);
	// 825FB380: 907A0088  stw r3, 0x88(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 825FB384: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FB388: 419A000C  beq cr6, 0x825fb394
	if ctx.cr[6].eq {
	pc = 0x825FB394; continue 'dispatch;
	}
	// 825FB38C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FB390: 4BCC5501  bl 0x822c0890
	ctx.lr = 0x825FB394;
	sub_822C0890(ctx, base);
	// 825FB394: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825FB398: 48BACE14  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FB3A0 size=520
    let mut pc: u32 = 0x825FB3A0;
    'dispatch: loop {
        match pc {
            0x825FB3A0 => {
    //   block [0x825FB3A0..0x825FB5A8)
	// 825FB3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB3A4: 48BACDC5  bl 0x831a8168
	ctx.lr = 0x825FB3A8;
	sub_831A8130(ctx, base);
	// 825FB3A8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB3AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FB3B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FB3B4: 4BF167A5  bl 0x82511b58
	ctx.lr = 0x825FB3B8;
	sub_82511B58(ctx, base);
	// 825FB3B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FB3BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FB3C0: 48880AD9  bl 0x82e7be98
	ctx.lr = 0x825FB3C4;
	sub_82E7BE98(ctx, base);
	// 825FB3C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FB3C8: 7FEA0034  cntlzw r10, r31
	ctx.r[10].u64 = if ctx.r[31].u32 == 0 { 32 } else { ctx.r[31].u32.leading_zeros() as u64 };
	// 825FB3CC: 3B8B18A0  addi r28, r11, 0x18a0
	ctx.r[28].s64 = ctx.r[11].s64 + 6304;
	// 825FB3D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FB3D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825FB3D8: 38A002A2  li r5, 0x2a2
	ctx.r[5].s64 = 674;
	// 825FB3DC: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 825FB3E0: 555DDFFE  rlwinm r29, r10, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825FB3E4: 487F7005  bl 0x82df23e8
	ctx.lr = 0x825FB3E8;
	sub_82DF23E8(ctx, base);
	// 825FB3E8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825FB3EC: 4182001C  beq 0x825fb408
	if ctx.cr[0].eq {
	pc = 0x825FB408; continue 'dispatch;
	}
	// 825FB3F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB3F4: 4885E28D  bl 0x82e59680
	ctx.lr = 0x825FB3F8;
	sub_82E59680(ctx, base);
	// 825FB3F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FB3FC: 396BF294  addi r11, r11, -0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + -3436;
	// 825FB400: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FB404: 48000008  b 0x825fb40c
	pc = 0x825FB40C; continue 'dispatch;
	// 825FB408: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB40C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FB410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB414: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB418: 4BFE54E9  bl 0x825e0900
	ctx.lr = 0x825FB41C;
	sub_825E0900(ctx, base);
	// 825FB41C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FB420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB424: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB428: 4BCC4BD9  bl 0x822c0000
	ctx.lr = 0x825FB42C;
	sub_822C0000(ctx, base);
	// 825FB42C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB430: 4BF166B9  bl 0x82511ae8
	ctx.lr = 0x825FB434;
	sub_82511AE8(ctx, base);
	// 825FB434: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FB438: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FB43C: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 825FB440: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB444: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB5A8 size=84
    let mut pc: u32 = 0x825FB5A8;
    'dispatch: loop {
        match pc {
            0x825FB5A8 => {
    //   block [0x825FB5A8..0x825FB5FC)
	// 825FB5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB5AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FB5B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FB5B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB5B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB5BC: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FB5C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB5C4: 419A0024  beq cr6, 0x825fb5e8
	if ctx.cr[6].eq {
	pc = 0x825FB5E8; continue 'dispatch;
	}
	// 825FB5C8: 4854B101  bl 0x82b466c8
	ctx.lr = 0x825FB5CC;
	sub_82B466C8(ctx, base);
	// 825FB5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FB5D0: 917F011C  stw r11, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 825FB5D4: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825FB5D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB5DC: 917F0120  stw r11, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 825FB5E0: 419A0008  beq cr6, 0x825fb5e8
	if ctx.cr[6].eq {
	pc = 0x825FB5E8; continue 'dispatch;
	}
	// 825FB5E4: 4BCC52AD  bl 0x822c0890
	ctx.lr = 0x825FB5E8;
	sub_822C0890(ctx, base);
	// 825FB5E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FB5EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FB5F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FB5F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FB5F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FB600 size=164
    let mut pc: u32 = 0x825FB600;
    'dispatch: loop {
        match pc {
            0x825FB600 => {
    //   block [0x825FB600..0x825FB6A4)
	// 825FB600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB604: 48BACB59  bl 0x831a815c
	ctx.lr = 0x825FB608;
	sub_831A8130(ctx, base);
	// 825FB608: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB60C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FB610: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825FB614: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FB618: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825FB61C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825FB620: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FB624: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825FB628: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825FB62C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825FB630: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825FB634: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825FB638: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825FB63C: 487F6DAD  bl 0x82df23e8
	ctx.lr = 0x825FB640;
	sub_82DF23E8(ctx, base);
	// 825FB640: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FB644: 4182002C  beq 0x825fb670
	if ctx.cr[0].eq {
	pc = 0x825FB670; continue 'dispatch;
	}
	// 825FB648: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FB64C: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB650: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FB654: 891B0000  lbz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB65C: C05C0000  lfs f2, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FB660: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FB664: 4855C575  bl 0x82b57bd8
	ctx.lr = 0x825FB668;
	sub_82B57BD8(ctx, base);
	// 825FB668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB66C: 48000008  b 0x825fb674
	pc = 0x825FB674; continue 'dispatch;
	// 825FB670: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB674: 93F90000  stw r31, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FB678: 3BD90004  addi r30, r25, 4
	ctx.r[30].s64 = ctx.r[25].s64 + 4;
	// 825FB67C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB684: 4BFFF73D  bl 0x825fadc0
	ctx.lr = 0x825FB688;
	sub_825FADC0(ctx, base);
	// 825FB688: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FB68C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB694: 4BCC496D  bl 0x822c0000
	ctx.lr = 0x825FB698;
	sub_822C0000(ctx, base);
	// 825FB698: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825FB69C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825FB6A0: 48BACB0C  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB6A8 size=168
    let mut pc: u32 = 0x825FB6A8;
    'dispatch: loop {
        match pc {
            0x825FB6A8 => {
    //   block [0x825FB6A8..0x825FB750)
	// 825FB6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB6AC: 48BACABD  bl 0x831a8168
	ctx.lr = 0x825FB6B0;
	sub_831A8130(ctx, base);
	// 825FB6B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB6B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825FB6B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FB6BC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825FB6C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825FB6C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FB6C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FB6CC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825FB6D0: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825FB6D4: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825FB6D8: 487F6D11  bl 0x82df23e8
	ctx.lr = 0x825FB6DC;
	sub_82DF23E8(ctx, base);
	// 825FB6DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825FB6E0: 4182002C  beq 0x825fb70c
	if ctx.cr[0].eq {
	pc = 0x825FB70C; continue 'dispatch;
	}
	// 825FB6E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FB6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FB6EC: 487F831D  bl 0x82df3a08
	ctx.lr = 0x825FB6F0;
	sub_82DF3A08(ctx, base);
	// 825FB6F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825FB6F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FB6F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB6FC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825FB700: 4855B2C9  bl 0x82b569c8
	ctx.lr = 0x825FB704;
	sub_82B569C8(ctx, base);
	// 825FB704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB708: 48000008  b 0x825fb710
	pc = 0x825FB710; continue 'dispatch;
	// 825FB70C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB710: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FB714: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 825FB718: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB71C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB720: 4BEBB9E1  bl 0x824b7100
	ctx.lr = 0x825FB724;
	sub_824B7100(ctx, base);
	// 825FB724: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FB728: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB72C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB730: 4BCC48D1  bl 0x822c0000
	ctx.lr = 0x825FB734;
	sub_822C0000(ctx, base);
	// 825FB734: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FB738: 4182000C  beq 0x825fb744
	if ctx.cr[0].eq {
	pc = 0x825FB744; continue 'dispatch;
	}
	// 825FB73C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FB740: 487F7CE9  bl 0x82df3428
	ctx.lr = 0x825FB744;
	sub_82DF3428(ctx, base);
	// 825FB744: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FB748: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FB74C: 48BACA6C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FB750 size=168
    let mut pc: u32 = 0x825FB750;
    'dispatch: loop {
        match pc {
            0x825FB750 => {
    //   block [0x825FB750..0x825FB7F8)
	// 825FB750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB754: 48BACA05  bl 0x831a8158
	ctx.lr = 0x825FB758;
	sub_831A8130(ctx, base);
	// 825FB758: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB75C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FB760: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825FB764: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FB768: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825FB76C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825FB770: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FB774: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825FB778: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825FB77C: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 825FB780: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825FB784: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825FB788: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 825FB78C: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 825FB790: 487F6C59  bl 0x82df23e8
	ctx.lr = 0x825FB794;
	sub_82DF23E8(ctx, base);
	// 825FB794: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FB798: 4182002C  beq 0x825fb7c4
	if ctx.cr[0].eq {
	pc = 0x825FB7C4; continue 'dispatch;
	}
	// 825FB79C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FB7A0: 89590000  lbz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB7A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB7A8: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB7AC: 891B0000  lbz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB7B0: C05C0000  lfs f2, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FB7B4: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FB7B8: 4855C421  bl 0x82b57bd8
	ctx.lr = 0x825FB7BC;
	sub_82B57BD8(ctx, base);
	// 825FB7BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB7C0: 48000008  b 0x825fb7c8
	pc = 0x825FB7C8; continue 'dispatch;
	// 825FB7C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FB7C8: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FB7CC: 3BD80004  addi r30, r24, 4
	ctx.r[30].s64 = ctx.r[24].s64 + 4;
	// 825FB7D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB7D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB7D8: 4BFFF5E9  bl 0x825fadc0
	ctx.lr = 0x825FB7DC;
	sub_825FADC0(ctx, base);
	// 825FB7DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FB7E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FB7E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB7E8: 4BCC4819  bl 0x822c0000
	ctx.lr = 0x825FB7EC;
	sub_822C0000(ctx, base);
	// 825FB7EC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825FB7F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825FB7F4: 48BAC9B4  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB7F8 size=112
    let mut pc: u32 = 0x825FB7F8;
    'dispatch: loop {
        match pc {
            0x825FB7F8 => {
    //   block [0x825FB7F8..0x825FB868)
	// 825FB7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FB800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FB804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FB808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB80C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FB810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB814: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825FB818: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB81C: 4BFFF4DD  bl 0x825facf8
	ctx.lr = 0x825FB820;
	sub_825FACF8(ctx, base);
	// 825FB820: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FB824: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FB828: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FB82C: 4BCC47D5  bl 0x822c0000
	ctx.lr = 0x825FB830;
	sub_822C0000(ctx, base);
	// 825FB830: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FB834: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FB838: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FB83C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FB840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB844: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FB848: 419A0008  beq cr6, 0x825fb850
	if ctx.cr[6].eq {
	pc = 0x825FB850; continue 'dispatch;
	}
	// 825FB84C: 4BCC5045  bl 0x822c0890
	ctx.lr = 0x825FB850;
	sub_822C0890(ctx, base);
	// 825FB850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FB854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FB858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FB85C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FB860: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FB864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FB868 size=76
    let mut pc: u32 = 0x825FB868;
    'dispatch: loop {
        match pc {
            0x825FB868 => {
    //   block [0x825FB868..0x825FB8B4)
	// 825FB868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FB870: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FB874: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FB878: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB87C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB880: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FB884: 4BFFF7A5  bl 0x825fb028
	ctx.lr = 0x825FB888;
	sub_825FB028(ctx, base);
	// 825FB888: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FB88C: 4182000C  beq 0x825fb898
	if ctx.cr[0].eq {
	pc = 0x825FB898; continue 'dispatch;
	}
	// 825FB890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB894: 487F6B45  bl 0x82df23d8
	ctx.lr = 0x825FB898;
	sub_82DF23D8(ctx, base);
	// 825FB898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB89C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FB8A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FB8A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FB8A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FB8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FB8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FB8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FB8B8 size=616
    let mut pc: u32 = 0x825FB8B8;
    'dispatch: loop {
        match pc {
            0x825FB8B8 => {
    //   block [0x825FB8B8..0x825FBB20)
	// 825FB8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FB8BC: 48BAC8AD  bl 0x831a8168
	ctx.lr = 0x825FB8C0;
	sub_831A8130(ctx, base);
	// 825FB8C0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825FB8C4: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FB8C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FB8CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FB8D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FB8D4: C01F0188  lfs f0, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FB8D8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FB8DC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825FB8E0: 41990234  bgt cr6, 0x825fbb14
	if ctx.cr[6].gt {
	pc = 0x825FBB14; continue 'dispatch;
	}
	// 825FB8E4: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 825FB8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FB8EC: 419A0024  beq cr6, 0x825fb910
	if ctx.cr[6].eq {
	pc = 0x825FB910; continue 'dispatch;
	}
	// 825FB8F0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825FB8F4: 419A001C  beq cr6, 0x825fb910
	if ctx.cr[6].eq {
	pc = 0x825FB910; continue 'dispatch;
	}
	// 825FB8F8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 825FB8FC: 419A0014  beq cr6, 0x825fb910
	if ctx.cr[6].eq {
	pc = 0x825FB910; continue 'dispatch;
	}
	// 825FB900: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825FB904: 419A000C  beq cr6, 0x825fb910
	if ctx.cr[6].eq {
	pc = 0x825FB910; continue 'dispatch;
	}
	// 825FB908: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 825FB90C: 409A0208  bne cr6, 0x825fbb14
	if !ctx.cr[6].eq {
	pc = 0x825FBB14; continue 'dispatch;
	}
	// 825FB910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FB914: 4BF16245  bl 0x82511b58
	ctx.lr = 0x825FB918;
	sub_82511B58(ctx, base);
	// 825FB918: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FB91C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825FB920: 48880579  bl 0x82e7be98
	ctx.lr = 0x825FB924;
	sub_82E7BE98(ctx, base);
	// 825FB924: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FB928: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825FB92C: 38ABF850  addi r5, r11, -0x7b0
	ctx.r[5].s64 = ctx.r[11].s64 + -1968;
	// 825FB930: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825FB934: 48880415  bl 0x82e7bd48
	ctx.lr = 0x825FB938;
	sub_82E7BD48(ctx, base);
	// 825FB938: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FB93C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825FB940: 38ABF860  addi r5, r11, -0x7a0
	ctx.r[5].s64 = ctx.r[11].s64 + -1952;
	// 825FB944: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825FB948: 48880401  bl 0x82e7bd48
	ctx.lr = 0x825FB94C;
	sub_82E7BD48(ctx, base);
	// 825FB94C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB950: 48A0C7D9  bl 0x83008128
	ctx.lr = 0x825FB954;
	sub_83008128(ctx, base);
	// 825FB954: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FB958: 907F0170  stw r3, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[3].u32 ) };
	// 825FB95C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825FB960: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825FB964: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 825FB968: 9B810051  stb r28, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[28].u8 ) };
	// 825FB96C: 389F0124  addi r4, r31, 0x124
	ctx.r[4].s64 = ctx.r[31].s64 + 292;
	// 825FB970: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FB974: 4BEAE7DD  bl 0x824aa150
	ctx.lr = 0x825FB978;
	sub_824AA150(ctx, base);
	// 825FB978: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FB97C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FB980: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FB984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FB988: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825FB98C: 419A0024  beq cr6, 0x825fb9b0
	if ctx.cr[6].eq {
	pc = 0x825FB9B0; continue 'dispatch;
	}
	// 825FB990: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FB994: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FB998: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FB99C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FB9A0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FB9A4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FB9A8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FB9AC: 4082FFE8  bne 0x825fb994
	if !ctx.cr[0].eq {
	pc = 0x825FB994; continue 'dispatch;
	}
	// 825FB9B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FB9B4: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825FB9B8: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 825FB9BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FB9C0: 3BAB18A0  addi r29, r11, 0x18a0
	ctx.r[29].s64 = ctx.r[11].s64 + 6304;
	// 825FB9C4: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825FB9C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FB9CC: 38A001FA  li r5, 0x1fa
	ctx.r[5].s64 = 506;
	// 825FB9D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FB9D4: 4885D06D  bl 0x82e58a40
	ctx.lr = 0x825FB9D8;
	sub_82E58A40(ctx, base);
	// 825FB9D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FB9DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB9E0: 419A0008  beq cr6, 0x825fb9e8
	if ctx.cr[6].eq {
	pc = 0x825FB9E8; continue 'dispatch;
	}
	// 825FB9E4: 4BCC4EAD  bl 0x822c0890
	ctx.lr = 0x825FB9E8;
	sub_822C0890(ctx, base);
	// 825FB9E8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FB9EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FB9F0: 419A0008  beq cr6, 0x825fb9f8
	if ctx.cr[6].eq {
	pc = 0x825FB9F8; continue 'dispatch;
	}
	// 825FB9F4: 4BCC4E9D  bl 0x822c0890
	ctx.lr = 0x825FB9F8;
	sub_822C0890(ctx, base);
	// 825FB9F8: D3FF0178  stfs f31, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FB9FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FBA00: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FBA04: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 825FBA08: 4BFFFCA1  bl 0x825fb6a8
	ctx.lr = 0x825FBA0C;
	sub_825FB6A8(ctx, base);
	// 825FBA0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FBA10: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825FBA14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FBA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FBA1C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825FBA20: 419A0024  beq cr6, 0x825fba44
	if ctx.cr[6].eq {
	pc = 0x825FBA44; continue 'dispatch;
	}
	// 825FBA24: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FBA28: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FBA2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FBA30: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FBA34: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FBA38: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FBA3C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FBA40: 4082FFE8  bne 0x825fba28
	if !ctx.cr[0].eq {
	pc = 0x825FBA28; continue 'dispatch;
	}
	// 825FBA44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FBA48: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825FBA4C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825FBA50: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FBA54: 38A001FE  li r5, 0x1fe
	ctx.r[5].s64 = 510;
	// 825FBA58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBA5C: 4885CFE5  bl 0x82e58a40
	ctx.lr = 0x825FBA60;
	sub_82E58A40(ctx, base);
	// 825FBA60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825FBA64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FBA68: 419A0008  beq cr6, 0x825fba70
	if ctx.cr[6].eq {
	pc = 0x825FBA70; continue 'dispatch;
	}
	// 825FBA6C: 4BCC4E25  bl 0x822c0890
	ctx.lr = 0x825FBA70;
	sub_822C0890(ctx, base);
	// 825FBA70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825FBA74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FBA78: 419A0008  beq cr6, 0x825fba80
	if ctx.cr[6].eq {
	pc = 0x825FBA80; continue 'dispatch;
	}
	// 825FBA7C: 4BCC4E15  bl 0x822c0890
	ctx.lr = 0x825FBA80;
	sub_822C0890(ctx, base);
	// 825FBA80: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FBA84: 3BDF011C  addi r30, r31, 0x11c
	ctx.r[30].s64 = ctx.r[31].s64 + 284;
	// 825FBA88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FBA8C: 419A0020  beq cr6, 0x825fbaac
	if ctx.cr[6].eq {
	pc = 0x825FBAAC; continue 'dispatch;
	}
	// 825FBA90: 4854AC39  bl 0x82b466c8
	ctx.lr = 0x825FBA94;
	sub_82B466C8(ctx, base);
	// 825FBA94: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825FBA98: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FBA9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FBAA0: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825FBAA4: 419A0008  beq cr6, 0x825fbaac
	if ctx.cr[6].eq {
	pc = 0x825FBAAC; continue 'dispatch;
	}
	// 825FBAA8: 4BCC4DE9  bl 0x822c0890
	ctx.lr = 0x825FBAAC;
	sub_822C0890(ctx, base);
	// 825FBAAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FBAB0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FBAB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FBAB8: 38AA18F4  addi r5, r10, 0x18f4
	ctx.r[5].s64 = ctx.r[10].s64 + 6388;
	// 825FBABC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825FBAC0: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 825FBAC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FBAC8: 4E800421  bctrl
	ctx.lr = 0x825FBACC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FBACC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FBAD0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825FBAD4: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825FBAD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FBADC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FBAE0: 4BCC8981  bl 0x822c4460
	ctx.lr = 0x825FBAE4;
	sub_822C4460(ctx, base);
	// 825FBAE4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825FBAE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FBAEC: 419A0008  beq cr6, 0x825fbaf4
	if ctx.cr[6].eq {
	pc = 0x825FBAF4; continue 'dispatch;
	}
	// 825FBAF0: 4BCC4DA1  bl 0x822c0890
	ctx.lr = 0x825FBAF4;
	sub_822C0890(ctx, base);
	// 825FBAF4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FBAF8: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FBAFC: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825FBB00: 48817761  bl 0x82e13260
	ctx.lr = 0x825FBB04;
	sub_82E13260(ctx, base);
	// 825FBB04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825FBB08: D3FF0180  stfs f31, 0x180(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 825FBB0C: 997F017D  stb r11, 0x17d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(381 as u32), ctx.r[11].u8 ) };
	// 825FBB10: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825FBB14: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825FBB18: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825FBB1C: 48BAC69C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FBB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FBB20 size=64
    let mut pc: u32 = 0x825FBB20;
    'dispatch: loop {
        match pc {
            0x825FBB20 => {
    //   block [0x825FBB20..0x825FBB60)
	// 825FBB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FBB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FBB28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FBB2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FBB30: 3BE3FF1C  addi r31, r3, -0xe4
	ctx.r[31].s64 = ctx.r[3].s64 + -228;
	// 825FBB34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FBB38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FBB3C: 4BFFF865  bl 0x825fb3a0
	ctx.lr = 0x825FBB40;
	sub_825FB3A0(ctx, base);
	// 825FBB40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FBB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FBB48: 4BFFF859  bl 0x825fb3a0
	ctx.lr = 0x825FBB4C;
	sub_825FB3A0(ctx, base);
	// 825FBB4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FBB50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FBB54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FBB58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FBB5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FBB60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FBB60 size=1388
    let mut pc: u32 = 0x825FBB60;
    'dispatch: loop {
        match pc {
            0x825FBB60 => {
    //   block [0x825FBB60..0x825FC0CC)
	// 825FBB60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FBB64: 48BAC605  bl 0x831a8168
	ctx.lr = 0x825FBB68;
	sub_831A8130(ctx, base);
	// 825FBB68: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 825FBB6C: 48BACF0D  bl 0x831a8a78
	ctx.lr = 0x825FBB70;
	sub_831A8A40(ctx, base);
	// 825FBB70: 9421FCB0  stwu r1, -0x350(r1)
	ea = ctx.r[1].u32.wrapping_add(-848 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FBB74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBB78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FBB7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FBB80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FBB84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBB88: 388B19C8  addi r4, r11, 0x19c8
	ctx.r[4].s64 = ctx.r[11].s64 + 6600;
	// 825FBB8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FBB90: 487F7E79  bl 0x82df3a08
	ctx.lr = 0x825FBB94;
	sub_82DF3A08(ctx, base);
	// 825FBB94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FBB98: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825FBB9C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FBBA0: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 825FBBA4: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825FBBA8: C38B964C  lfs f28, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 825FBBAC: C3EA9F64  lfs f31, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FBBB0: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 825FBBB4: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825FBBB8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FBBBC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FBBC0: 4BFA75F1  bl 0x825a31b0
	ctx.lr = 0x825FBBC4;
	sub_825A31B0(ctx, base);
	// 825FBBC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBBC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBBCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBBD0: 4BFA5BA1  bl 0x825a1770
	ctx.lr = 0x825FBBD4;
	sub_825A1770(ctx, base);
	// 825FBBD4: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 825FBBD8: 487F7851  bl 0x82df3428
	ctx.lr = 0x825FBBDC;
	sub_82DF3428(ctx, base);
	// 825FBBDC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825FBBE0: 4BCCD0D9  bl 0x822c8cb8
	ctx.lr = 0x825FBBE4;
	sub_822C8CB8(ctx, base);
	// 825FBBE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBBE8: 487F7841  bl 0x82df3428
	ctx.lr = 0x825FBBEC;
	sub_82DF3428(ctx, base);
	// 825FBBEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBBF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBBF4: 388B19B0  addi r4, r11, 0x19b0
	ctx.r[4].s64 = ctx.r[11].s64 + 6576;
	// 825FBBF8: 487F7E11  bl 0x82df3a08
	ctx.lr = 0x825FBBFC;
	sub_82DF3A08(ctx, base);
	// 825FBBFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FBC00: 389F0054  addi r4, r31, 0x54
	ctx.r[4].s64 = ctx.r[31].s64 + 84;
	// 825FBC04: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FBC08: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 825FBC0C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FBC10: C3AB9528  lfs f29, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825FBC14: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FBC18: 4BFA7599  bl 0x825a31b0
	ctx.lr = 0x825FBC1C;
	sub_825A31B0(ctx, base);
	// 825FBC1C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBC20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBC24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBC28: 4BFA5B49  bl 0x825a1770
	ctx.lr = 0x825FBC2C;
	sub_825A1770(ctx, base);
	// 825FBC2C: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 825FBC30: 487F77F9  bl 0x82df3428
	ctx.lr = 0x825FBC34;
	sub_82DF3428(ctx, base);
	// 825FBC34: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 825FBC38: 4BCCD081  bl 0x822c8cb8
	ctx.lr = 0x825FBC3C;
	sub_822C8CB8(ctx, base);
	// 825FBC3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBC40: 487F77E9  bl 0x82df3428
	ctx.lr = 0x825FBC44;
	sub_82DF3428(ctx, base);
	// 825FBC44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBC48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBC4C: 388B19A4  addi r4, r11, 0x19a4
	ctx.r[4].s64 = ctx.r[11].s64 + 6564;
	// 825FBC50: 487F7DB9  bl 0x82df3a08
	ctx.lr = 0x825FBC54;
	sub_82DF3A08(ctx, base);
	// 825FBC54: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 825FBC58: 38610280  addi r3, r1, 0x280
	ctx.r[3].s64 = ctx.r[1].s64 + 640;
	// 825FBC5C: FC60E090  fmr f3, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[28].f64;
	// 825FBC60: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FBC64: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FBC68: 4BFA7549  bl 0x825a31b0
	ctx.lr = 0x825FBC6C;
	sub_825A31B0(ctx, base);
	// 825FBC6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBC70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBC74: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBC78: 4BFA5AF9  bl 0x825a1770
	ctx.lr = 0x825FBC7C;
	sub_825A1770(ctx, base);
	// 825FBC7C: 386102B8  addi r3, r1, 0x2b8
	ctx.r[3].s64 = ctx.r[1].s64 + 696;
	// 825FBC80: 487F77A9  bl 0x82df3428
	ctx.lr = 0x825FBC84;
	sub_82DF3428(ctx, base);
	// 825FBC84: 38610298  addi r3, r1, 0x298
	ctx.r[3].s64 = ctx.r[1].s64 + 664;
	// 825FBC88: 4BCCD031  bl 0x822c8cb8
	ctx.lr = 0x825FBC8C;
	sub_822C8CB8(ctx, base);
	// 825FBC8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBC90: 487F7799  bl 0x82df3428
	ctx.lr = 0x825FBC94;
	sub_82DF3428(ctx, base);
	// 825FBC94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBC98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBC9C: 388B1998  addi r4, r11, 0x1998
	ctx.r[4].s64 = ctx.r[11].s64 + 6552;
	// 825FBCA0: 487F7D69  bl 0x82df3a08
	ctx.lr = 0x825FBCA4;
	sub_82DF3A08(ctx, base);
	// 825FBCA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBCA8: 389F005C  addi r4, r31, 0x5c
	ctx.r[4].s64 = ctx.r[31].s64 + 92;
	// 825FBCAC: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FBCB0: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 825FBCB4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825FBCB8: C04BD7BC  lfs f2, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FBCBC: C02A78D8  lfs f1, 0x78d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30936 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FBCC0: 4BFA74F1  bl 0x825a31b0
	ctx.lr = 0x825FBCC4;
	sub_825A31B0(ctx, base);
	// 825FBCC4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBCC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBCCC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBCD0: 4BFA5AA1  bl 0x825a1770
	ctx.lr = 0x825FBCD4;
	sub_825A1770(ctx, base);
	// 825FBCD4: 38610238  addi r3, r1, 0x238
	ctx.r[3].s64 = ctx.r[1].s64 + 568;
	// 825FBCD8: 487F7751  bl 0x82df3428
	ctx.lr = 0x825FBCDC;
	sub_82DF3428(ctx, base);
	// 825FBCDC: 38610218  addi r3, r1, 0x218
	ctx.r[3].s64 = ctx.r[1].s64 + 536;
	// 825FBCE0: 4BCCCFD9  bl 0x822c8cb8
	ctx.lr = 0x825FBCE4;
	sub_822C8CB8(ctx, base);
	// 825FBCE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBCE8: 487F7741  bl 0x82df3428
	ctx.lr = 0x825FBCEC;
	sub_82DF3428(ctx, base);
	// 825FBCEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBCF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBCF4: 388B1984  addi r4, r11, 0x1984
	ctx.r[4].s64 = ctx.r[11].s64 + 6532;
	// 825FBCF8: 487F7D11  bl 0x82df3a08
	ctx.lr = 0x825FBCFC;
	sub_82DF3A08(ctx, base);
	// 825FBCFC: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 825FBD00: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 825FBD04: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FBD08: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FBD0C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FBD10: 4BFA74A1  bl 0x825a31b0
	ctx.lr = 0x825FBD14;
	sub_825A31B0(ctx, base);
	// 825FBD14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBD18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBD1C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBD20: 4BFA5A51  bl 0x825a1770
	ctx.lr = 0x825FBD24;
	sub_825A1770(ctx, base);
	// 825FBD24: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825FBD28: 487F7701  bl 0x82df3428
	ctx.lr = 0x825FBD2C;
	sub_82DF3428(ctx, base);
	// 825FBD2C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825FBD30: 4BCCCF89  bl 0x822c8cb8
	ctx.lr = 0x825FBD34;
	sub_822C8CB8(ctx, base);
	// 825FBD34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBD38: 487F76F1  bl 0x82df3428
	ctx.lr = 0x825FBD3C;
	sub_82DF3428(ctx, base);
	// 825FBD3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBD40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBD44: 388BF5C0  addi r4, r11, -0xa40
	ctx.r[4].s64 = ctx.r[11].s64 + -2624;
	// 825FBD48: 487F7CC1  bl 0x82df3a08
	ctx.lr = 0x825FBD4C;
	sub_82DF3A08(ctx, base);
	// 825FBD4C: 389F0064  addi r4, r31, 0x64
	ctx.r[4].s64 = ctx.r[31].s64 + 100;
	// 825FBD50: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825FBD54: 4BFA721D  bl 0x825a2f70
	ctx.lr = 0x825FBD58;
	sub_825A2F70(ctx, base);
	// 825FBD58: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBD5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBD60: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBD64: 4BFA6425  bl 0x825a2188
	ctx.lr = 0x825FBD68;
	sub_825A2188(ctx, base);
	// 825FBD68: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825FBD6C: 487F76BD  bl 0x82df3428
	ctx.lr = 0x825FBD70;
	sub_82DF3428(ctx, base);
	// 825FBD70: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825FBD74: 4BCCCF45  bl 0x822c8cb8
	ctx.lr = 0x825FBD78;
	sub_822C8CB8(ctx, base);
	// 825FBD78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBD7C: 487F76AD  bl 0x82df3428
	ctx.lr = 0x825FBD80;
	sub_82DF3428(ctx, base);
	// 825FBD80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBD84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBD88: 388B1978  addi r4, r11, 0x1978
	ctx.r[4].s64 = ctx.r[11].s64 + 6520;
	// 825FBD8C: 487F7C7D  bl 0x82df3a08
	ctx.lr = 0x825FBD90;
	sub_82DF3A08(ctx, base);
	// 825FBD90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBD94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBD98: 388B196C  addi r4, r11, 0x196c
	ctx.r[4].s64 = ctx.r[11].s64 + 6508;
	// 825FBD9C: 487F7C6D  bl 0x82df3a08
	ctx.lr = 0x825FBDA0;
	sub_82DF3A08(ctx, base);
	// 825FBDA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825FBDA4: 38BF0068  addi r5, r31, 0x68
	ctx.r[5].s64 = ctx.r[31].s64 + 104;
	// 825FBDA8: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FBDAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FBDB0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 825FBDB4: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 825FBDB8: C04B9A8C  lfs f2, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FBDBC: 4BFB1CFD  bl 0x825adab8
	ctx.lr = 0x825FBDC0;
	sub_825ADAB8(ctx, base);
	// 825FBDC0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBDC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBDC8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBDCC: 4BFA5885  bl 0x825a1650
	ctx.lr = 0x825FBDD0;
	sub_825A1650(ctx, base);
	// 825FBDD0: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 825FBDD4: 487F7655  bl 0x82df3428
	ctx.lr = 0x825FBDD8;
	sub_82DF3428(ctx, base);
	// 825FBDD8: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 825FBDDC: 4BCCCEDD  bl 0x822c8cb8
	ctx.lr = 0x825FBDE0;
	sub_822C8CB8(ctx, base);
	// 825FBDE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBDE4: 487F7645  bl 0x82df3428
	ctx.lr = 0x825FBDE8;
	sub_82DF3428(ctx, base);
	// 825FBDE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBDEC: 487F763D  bl 0x82df3428
	ctx.lr = 0x825FBDF0;
	sub_82DF3428(ctx, base);
	// 825FBDF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBDF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBDF8: 388B1958  addi r4, r11, 0x1958
	ctx.r[4].s64 = ctx.r[11].s64 + 6488;
	// 825FBDFC: 487F7C0D  bl 0x82df3a08
	ctx.lr = 0x825FBE00;
	sub_82DF3A08(ctx, base);
	// 825FBE00: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBE04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBE08: 388B194C  addi r4, r11, 0x194c
	ctx.r[4].s64 = ctx.r[11].s64 + 6476;
	// 825FBE0C: 487F7BFD  bl 0x82df3a08
	ctx.lr = 0x825FBE10;
	sub_82DF3A08(ctx, base);
	// 825FBE10: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 825FBE14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FBE18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FBE1C: 4BFA7235  bl 0x825a3050
	ctx.lr = 0x825FBE20;
	sub_825A3050(ctx, base);
	// 825FBE20: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBE24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBE28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FBE2C: 4BFA635D  bl 0x825a2188
	ctx.lr = 0x825FBE30;
	sub_825A2188(ctx, base);
	// 825FBE30: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825FBE34: 487F75F5  bl 0x82df3428
	ctx.lr = 0x825FBE38;
	sub_82DF3428(ctx, base);
	// 825FBE38: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825FBE3C: 4BCCCE7D  bl 0x822c8cb8
	ctx.lr = 0x825FBE40;
	sub_822C8CB8(ctx, base);
	// 825FBE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBE44: 487F75E5  bl 0x82df3428
	ctx.lr = 0x825FBE48;
	sub_82DF3428(ctx, base);
	// 825FBE48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FBE4C: 487F75DD  bl 0x82df3428
	ctx.lr = 0x825FBE50;
	sub_82DF3428(ctx, base);
	// 825FBE50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBE54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBE58: 388B17B4  addi r4, r11, 0x17b4
	ctx.r[4].s64 = ctx.r[11].s64 + 6068;
	// 825FBE5C: 487F7BAD  bl 0x82df3a08
	ctx.lr = 0x825FBE60;
	sub_82DF3A08(ctx, base);
	// 825FBE60: 389F0070  addi r4, r31, 0x70
	ctx.r[4].s64 = ctx.r[31].s64 + 112;
	// 825FBE64: 38610240  addi r3, r1, 0x240
	ctx.r[3].s64 = ctx.r[1].s64 + 576;
	// 825FBE68: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FBE6C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FBE70: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 825FBE74: 4BFA733D  bl 0x825a31b0
	ctx.lr = 0x825FBE78;
	sub_825A31B0(ctx, base);
	// 825FBE78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBE7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBE80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FBE84: 4BFA58ED  bl 0x825a1770
	ctx.lr = 0x825FBE88;
	sub_825A1770(ctx, base);
	// 825FBE88: 38610278  addi r3, r1, 0x278
	ctx.r[3].s64 = ctx.r[1].s64 + 632;
	// 825FBE8C: 487F759D  bl 0x82df3428
	ctx.lr = 0x825FBE90;
	sub_82DF3428(ctx, base);
	// 825FBE90: 38610258  addi r3, r1, 0x258
	ctx.r[3].s64 = ctx.r[1].s64 + 600;
	// 825FBE94: 4BCCCE25  bl 0x822c8cb8
	ctx.lr = 0x825FBE98;
	sub_822C8CB8(ctx, base);
	// 825FBE98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBE9C: 487F758D  bl 0x82df3428
	ctx.lr = 0x825FBEA0;
	sub_82DF3428(ctx, base);
	// 825FBEA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBEA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBEA8: 388B179C  addi r4, r11, 0x179c
	ctx.r[4].s64 = ctx.r[11].s64 + 6044;
	// 825FBEAC: 487F7B5D  bl 0x82df3a08
	ctx.lr = 0x825FBEB0;
	sub_82DF3A08(ctx, base);
	// 825FBEB0: 389F0074  addi r4, r31, 0x74
	ctx.r[4].s64 = ctx.r[31].s64 + 116;
	// 825FBEB4: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 825FBEB8: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FBEBC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FBEC0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FBEC4: 4BFA72ED  bl 0x825a31b0
	ctx.lr = 0x825FBEC8;
	sub_825A31B0(ctx, base);
	// 825FBEC8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FBECC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FBED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FBED4: 4BFA589D  bl 0x825a1770
	ctx.lr = 0x825FBED8;
	sub_825A1770(ctx, base);
	// 825FBED8: 386102F8  addi r3, r1, 0x2f8
	ctx.r[3].s64 = ctx.r[1].s64 + 760;
	// 825FBEDC: 487F754D  bl 0x82df3428
	ctx.lr = 0x825FBEE0;
	sub_82DF3428(ctx, base);
	// 825FBEE0: 386102D8  addi r3, r1, 0x2d8
	ctx.r[3].s64 = ctx.r[1].s64 + 728;
	// 825FBEE4: 4BCCCDD5  bl 0x822c8cb8
	ctx.lr = 0x825FBEE8;
	sub_822C8CB8(ctx, base);
	// 825FBEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBEEC: 487F753D  bl 0x82df3428
	ctx.lr = 0x825FBEF0;
	sub_82DF3428(ctx, base);
	// 825FBEF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBEF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FBEF8: 388B18A0  addi r4, r11, 0x18a0
	ctx.r[4].s64 = ctx.r[11].s64 + 6304;
	// 825FBEFC: 38A0023C  li r5, 0x23c
	ctx.r[5].s64 = 572;
	// 825FBF00: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825FBF04: 4BCC44D5  bl 0x822c03d8
	ctx.lr = 0x825FBF08;
	sub_822C03D8(ctx, base);
	// 825FBF08: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825FBF0C: 41820034  beq 0x825fbf40
	if ctx.cr[0].eq {
	pc = 0x825FBF40; continue 'dispatch;
	}
	// 825FBF10: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBF14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBF18: 388B193C  addi r4, r11, 0x193c
	ctx.r[4].s64 = ctx.r[11].s64 + 6460;
	// 825FBF1C: 487F7AED  bl 0x82df3a08
	ctx.lr = 0x825FBF20;
	sub_82DF3A08(ctx, base);
	// 825FBF20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FBF24: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 825FBF28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FBF2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FBF30: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825FBF34: 4BFB04DD  bl 0x825ac410
	ctx.lr = 0x825FBF38;
	sub_825AC410(ctx, base);
	// 825FBF38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825FBF3C: 48000008  b 0x825fbf44
	pc = 0x825FBF44; continue 'dispatch;
	// 825FBF40: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825FBF44: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825FBF48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FBF4C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825FBF50: 4BEF7469  bl 0x824f33b8
	ctx.lr = 0x825FBF54;
	sub_824F33B8(ctx, base);
	// 825FBF54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825FBF58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FBF5C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825FBF60: 4BCC40A1  bl 0x822c0000
	ctx.lr = 0x825FBF64;
	sub_822C0000(ctx, base);
	// 825FBF64: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FBF68: 4182000C  beq 0x825fbf74
	if ctx.cr[0].eq {
	pc = 0x825FBF74; continue 'dispatch;
	}
	// 825FBF6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBF70: 487F74B9  bl 0x82df3428
	ctx.lr = 0x825FBF74;
	sub_82DF3428(ctx, base);
	// 825FBF74: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBF78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBF7C: 388B1938  addi r4, r11, 0x1938
	ctx.r[4].s64 = ctx.r[11].s64 + 6456;
	// 825FBF80: 487F7A89  bl 0x82df3a08
	ctx.lr = 0x825FBF84;
	sub_82DF3A08(ctx, base);
	// 825FBF84: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FBF88: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FBF8C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FBF90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FBF94: 4BFAFE2D  bl 0x825abdc0
	ctx.lr = 0x825FBF98;
	sub_825ABDC0(ctx, base);
	// 825FBF98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBF9C: 487F748D  bl 0x82df3428
	ctx.lr = 0x825FBFA0;
	sub_82DF3428(ctx, base);
	// 825FBFA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBFA8: 388B1934  addi r4, r11, 0x1934
	ctx.r[4].s64 = ctx.r[11].s64 + 6452;
	// 825FBFAC: 487F7A5D  bl 0x82df3a08
	ctx.lr = 0x825FBFB0;
	sub_82DF3A08(ctx, base);
	// 825FBFB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FBFB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FBFB8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FBFBC: 4BFAFE05  bl 0x825abdc0
	ctx.lr = 0x825FBFC0;
	sub_825ABDC0(ctx, base);
	// 825FBFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBFC4: 487F7465  bl 0x82df3428
	ctx.lr = 0x825FBFC8;
	sub_82DF3428(ctx, base);
	// 825FBFC8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBFCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBFD0: 388B1930  addi r4, r11, 0x1930
	ctx.r[4].s64 = ctx.r[11].s64 + 6448;
	// 825FBFD4: 487F7A35  bl 0x82df3a08
	ctx.lr = 0x825FBFD8;
	sub_82DF3A08(ctx, base);
	// 825FBFD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FBFDC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825FBFE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FBFE4: 4BFAFDDD  bl 0x825abdc0
	ctx.lr = 0x825FBFE8;
	sub_825ABDC0(ctx, base);
	// 825FBFE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBFEC: 487F743D  bl 0x82df3428
	ctx.lr = 0x825FBFF0;
	sub_82DF3428(ctx, base);
	// 825FBFF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FBFF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FBFF8: 388B1920  addi r4, r11, 0x1920
	ctx.r[4].s64 = ctx.r[11].s64 + 6432;
	// 825FBFFC: 487F7A0D  bl 0x82df3a08
	ctx.lr = 0x825FC000;
	sub_82DF3A08(ctx, base);
	// 825FC000: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FC004: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825FC008: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FC00C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825FC010: 419A0024  beq cr6, 0x825fc034
	if ctx.cr[6].eq {
	pc = 0x825FC034; continue 'dispatch;
	}
	// 825FC014: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FC018: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FC01C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC020: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FC024: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FC028: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FC02C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC030: 4082FFE8  bne 0x825fc018
	if !ctx.cr[0].eq {
	pc = 0x825FC018; continue 'dispatch;
	}
	// 825FC034: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825FC038: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FC03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FC040: 4BFA60D1  bl 0x825a2110
	ctx.lr = 0x825FC044;
	sub_825A2110(ctx, base);
	// 825FC044: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FC048: 487F73E1  bl 0x82df3428
	ctx.lr = 0x825FC04C;
	sub_82DF3428(ctx, base);
	// 825FC04C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FC054: 388B1914  addi r4, r11, 0x1914
	ctx.r[4].s64 = ctx.r[11].s64 + 6420;
	// 825FC058: 487F79B1  bl 0x82df3a08
	ctx.lr = 0x825FC05C;
	sub_82DF3A08(ctx, base);
	// 825FC05C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC060: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FC064: 388B1908  addi r4, r11, 0x1908
	ctx.r[4].s64 = ctx.r[11].s64 + 6408;
	// 825FC068: 487F79A1  bl 0x82df3a08
	ctx.lr = 0x825FC06C;
	sub_82DF3A08(ctx, base);
	// 825FC06C: 38BF007C  addi r5, r31, 0x7c
	ctx.r[5].s64 = ctx.r[31].s64 + 124;
	// 825FC070: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FC074: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825FC078: 4BFA6FD9  bl 0x825a3050
	ctx.lr = 0x825FC07C;
	sub_825A3050(ctx, base);
	// 825FC07C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FC080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FC084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FC088: 4BFA6101  bl 0x825a2188
	ctx.lr = 0x825FC08C;
	sub_825A2188(ctx, base);
	// 825FC08C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825FC090: 487F7399  bl 0x82df3428
	ctx.lr = 0x825FC094;
	sub_82DF3428(ctx, base);
	// 825FC094: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825FC098: 4BCCCC21  bl 0x822c8cb8
	ctx.lr = 0x825FC09C;
	sub_822C8CB8(ctx, base);
	// 825FC09C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FC0A0: 487F7389  bl 0x82df3428
	ctx.lr = 0x825FC0A4;
	sub_82DF3428(ctx, base);
	// 825FC0A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FC0A8: 487F7381  bl 0x82df3428
	ctx.lr = 0x825FC0AC;
	sub_82DF3428(ctx, base);
	// 825FC0AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FC0B0: 419A000C  beq cr6, 0x825fc0bc
	if ctx.cr[6].eq {
	pc = 0x825FC0BC; continue 'dispatch;
	}
	// 825FC0B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FC0B8: 4BCC47D9  bl 0x822c0890
	ctx.lr = 0x825FC0BC;
	sub_822C0890(ctx, base);
	// 825FC0BC: 38210350  addi r1, r1, 0x350
	ctx.r[1].s64 = ctx.r[1].s64 + 848;
	// 825FC0C0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 825FC0C4: 48BACA01  bl 0x831a8ac4
	ctx.lr = 0x825FC0C8;
	sub_831A8A8C(ctx, base);
	// 825FC0C8: 48BAC0F0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FC0D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FC0D0 size=996
    let mut pc: u32 = 0x825FC0D0;
    'dispatch: loop {
        match pc {
            0x825FC0D0 => {
    //   block [0x825FC0D0..0x825FC4B4)
	// 825FC0D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FC0D4: 48BAC085  bl 0x831a8158
	ctx.lr = 0x825FC0D8;
	sub_831A8130(ctx, base);
	// 825FC0D8: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FC0DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC0E0: D0210184  stfs f1, 0x184(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FC0E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FC0E8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825FC0EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FC0F0: 388B1A04  addi r4, r11, 0x1a04
	ctx.r[4].s64 = ctx.r[11].s64 + 6660;
	// 825FC0F4: 487F7915  bl 0x82df3a08
	ctx.lr = 0x825FC0F8;
	sub_82DF3A08(ctx, base);
	// 825FC0F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FC0FC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825FC100: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 825FC104: 485B720D  bl 0x82bb3310
	ctx.lr = 0x825FC108;
	sub_82BB3310(ctx, base);
	// 825FC108: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825FC10C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC110: 419A0008  beq cr6, 0x825fc118
	if ctx.cr[6].eq {
	pc = 0x825FC118; continue 'dispatch;
	}
	// 825FC114: 4BCC477D  bl 0x822c0890
	ctx.lr = 0x825FC118;
	sub_822C0890(ctx, base);
	// 825FC118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FC11C: 487F730D  bl 0x82df3428
	ctx.lr = 0x825FC120;
	sub_82DF3428(ctx, base);
	// 825FC120: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FC124: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825FC128: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FC12C: 9BDF017C  stb r30, 0x17c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[30].u8 ) };
	// 825FC130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC134: 419A0020  beq cr6, 0x825fc154
	if ctx.cr[6].eq {
	pc = 0x825FC154; continue 'dispatch;
	}
	// 825FC138: 4854A591  bl 0x82b466c8
	ctx.lr = 0x825FC13C;
	sub_82B466C8(ctx, base);
	// 825FC13C: 939F011C  stw r28, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[28].u32 ) };
	// 825FC140: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825FC144: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC148: 939F0120  stw r28, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 825FC14C: 419A0008  beq cr6, 0x825fc154
	if ctx.cr[6].eq {
	pc = 0x825FC154; continue 'dispatch;
	}
	// 825FC150: 4BCC4741  bl 0x822c0890
	ctx.lr = 0x825FC154;
	sub_822C0890(ctx, base);
	// 825FC154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC158: 4BF15A01  bl 0x82511b58
	ctx.lr = 0x825FC15C;
	sub_82511B58(ctx, base);
	// 825FC15C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC160: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825FC164: 4887FD35  bl 0x82e7be98
	ctx.lr = 0x825FC168;
	sub_82E7BE98(ctx, base);
	// 825FC168: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC16C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825FC170: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825FC174: 4887FB55  bl 0x82e7bcc8
	ctx.lr = 0x825FC178;
	sub_82E7BCC8(ctx, base);
	// 825FC178: 817F0164  lwz r11, 0x164(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 825FC17C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825FC180: 419801EC  blt cr6, 0x825fc36c
	if ctx.cr[6].lt {
	pc = 0x825FC36C; continue 'dispatch;
	}
	// 825FC184: 419A00FC  beq cr6, 0x825fc280
	if ctx.cr[6].eq {
	pc = 0x825FC280; continue 'dispatch;
	}
	// 825FC188: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825FC18C: 409802D4  bge cr6, 0x825fc460
	if !ctx.cr[6].lt {
	pc = 0x825FC460; continue 'dispatch;
	}
	// 825FC190: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825FC194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC198: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825FC19C: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 825FC1A0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825FC1A4: 3B7F0148  addi r27, r31, 0x148
	ctx.r[27].s64 = ctx.r[31].s64 + 328;
	// 825FC1A8: 3B410184  addi r26, r1, 0x184
	ctx.r[26].s64 = ctx.r[1].s64 + 388;
	// 825FC1AC: 3B210184  addi r25, r1, 0x184
	ctx.r[25].s64 = ctx.r[1].s64 + 388;
	// 825FC1B0: 3B0100B0  addi r24, r1, 0xb0
	ctx.r[24].s64 = ctx.r[1].s64 + 176;
	// 825FC1B4: 4BF15935  bl 0x82511ae8
	ctx.lr = 0x825FC1B8;
	sub_82511AE8(ctx, base);
	// 825FC1B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC1BC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825FC1C0: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825FC1C4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 825FC1C8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825FC1CC: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 825FC1D0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825FC1D4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825FC1D8: 4BFFF579  bl 0x825fb750
	ctx.lr = 0x825FC1DC;
	sub_825FB750(ctx, base);
	// 825FC1DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC1E0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825FC1E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FC1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FC1EC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825FC1F0: 419A0024  beq cr6, 0x825fc214
	if ctx.cr[6].eq {
	pc = 0x825FC214; continue 'dispatch;
	}
	// 825FC1F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FC1F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FC1FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC200: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FC204: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FC208: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FC20C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC210: 4082FFE8  bne 0x825fc1f8
	if !ctx.cr[0].eq {
	pc = 0x825FC1F8; continue 'dispatch;
	}
	// 825FC214: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FC218: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825FC21C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC220: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 825FC224: 388A18A0  addi r4, r10, 0x18a0
	ctx.r[4].s64 = ctx.r[10].s64 + 6304;
	// 825FC228: 38A0027E  li r5, 0x27e
	ctx.r[5].s64 = 638;
	// 825FC22C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825FC230: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC234: 4885C80D  bl 0x82e58a40
	ctx.lr = 0x825FC238;
	sub_82E58A40(ctx, base);
	// 825FC238: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FC23C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC240: 419A0008  beq cr6, 0x825fc248
	if ctx.cr[6].eq {
	pc = 0x825FC248; continue 'dispatch;
	}
	// 825FC244: 4BCC464D  bl 0x822c0890
	ctx.lr = 0x825FC248;
	sub_822C0890(ctx, base);
	// 825FC248: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825FC24C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC250: 419A0008  beq cr6, 0x825fc258
	if ctx.cr[6].eq {
	pc = 0x825FC258; continue 'dispatch;
	}
	// 825FC254: 4BCC463D  bl 0x822c0890
	ctx.lr = 0x825FC258;
	sub_822C0890(ctx, base);
	// 825FC258: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC25C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC260: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC264: 38AA19EC  addi r5, r10, 0x19ec
	ctx.r[5].s64 = ctx.r[10].s64 + 6636;
	// 825FC268: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825FC26C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FC270: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FC274: 4E800421  bctrl
	ctx.lr = 0x825FC278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FC278: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825FC27C: 480001D8  b 0x825fc454
	pc = 0x825FC454; continue 'dispatch;
	// 825FC280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC284: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FC288: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 825FC28C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825FC290: 3B7F0148  addi r27, r31, 0x148
	ctx.r[27].s64 = ctx.r[31].s64 + 328;
	// 825FC294: 3B410184  addi r26, r1, 0x184
	ctx.r[26].s64 = ctx.r[1].s64 + 388;
	// 825FC298: 3B210184  addi r25, r1, 0x184
	ctx.r[25].s64 = ctx.r[1].s64 + 388;
	// 825FC29C: 3B0100B0  addi r24, r1, 0xb0
	ctx.r[24].s64 = ctx.r[1].s64 + 176;
	// 825FC2A0: 4BF15849  bl 0x82511ae8
	ctx.lr = 0x825FC2A4;
	sub_82511AE8(ctx, base);
	// 825FC2A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC2A8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825FC2AC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825FC2B0: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 825FC2B4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825FC2B8: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 825FC2BC: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825FC2C0: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825FC2C4: 4BFFF48D  bl 0x825fb750
	ctx.lr = 0x825FC2C8;
	sub_825FB750(ctx, base);
	// 825FC2C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC2CC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FC2D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FC2D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FC2D8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825FC2DC: 419A0024  beq cr6, 0x825fc300
	if ctx.cr[6].eq {
	pc = 0x825FC300; continue 'dispatch;
	}
	// 825FC2E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FC2E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FC2E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC2EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FC2F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FC2F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FC2F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC2FC: 4082FFE8  bne 0x825fc2e4
	if !ctx.cr[0].eq {
	pc = 0x825FC2E4; continue 'dispatch;
	}
	// 825FC300: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FC304: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825FC308: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC30C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825FC310: 388A18A0  addi r4, r10, 0x18a0
	ctx.r[4].s64 = ctx.r[10].s64 + 6304;
	// 825FC314: 38A0027A  li r5, 0x27a
	ctx.r[5].s64 = 634;
	// 825FC318: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825FC31C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC320: 4885C721  bl 0x82e58a40
	ctx.lr = 0x825FC324;
	sub_82E58A40(ctx, base);
	// 825FC324: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FC328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC32C: 419A0008  beq cr6, 0x825fc334
	if ctx.cr[6].eq {
	pc = 0x825FC334; continue 'dispatch;
	}
	// 825FC330: 4BCC4561  bl 0x822c0890
	ctx.lr = 0x825FC334;
	sub_822C0890(ctx, base);
	// 825FC334: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825FC338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC33C: 419A0008  beq cr6, 0x825fc344
	if ctx.cr[6].eq {
	pc = 0x825FC344; continue 'dispatch;
	}
	// 825FC340: 4BCC4551  bl 0x822c0890
	ctx.lr = 0x825FC344;
	sub_822C0890(ctx, base);
	// 825FC344: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC348: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC34C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC350: 38AA19EC  addi r5, r10, 0x19ec
	ctx.r[5].s64 = ctx.r[10].s64 + 6636;
	// 825FC354: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825FC358: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FC35C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FC360: 4E800421  bctrl
	ctx.lr = 0x825FC364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FC364: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825FC368: 480000EC  b 0x825fc454
	pc = 0x825FC454; continue 'dispatch;
	// 825FC36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC370: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825FC374: 3BDF018C  addi r30, r31, 0x18c
	ctx.r[30].s64 = ctx.r[31].s64 + 396;
	// 825FC378: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 825FC37C: 3B7F0148  addi r27, r31, 0x148
	ctx.r[27].s64 = ctx.r[31].s64 + 328;
	// 825FC380: 3B410184  addi r26, r1, 0x184
	ctx.r[26].s64 = ctx.r[1].s64 + 388;
	// 825FC384: 3B210184  addi r25, r1, 0x184
	ctx.r[25].s64 = ctx.r[1].s64 + 388;
	// 825FC388: 3B0100B0  addi r24, r1, 0xb0
	ctx.r[24].s64 = ctx.r[1].s64 + 176;
	// 825FC38C: 4BF1575D  bl 0x82511ae8
	ctx.lr = 0x825FC390;
	sub_82511AE8(ctx, base);
	// 825FC390: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC394: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825FC398: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825FC39C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 825FC3A0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825FC3A4: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	// 825FC3A8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825FC3AC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825FC3B0: 4BFFF3A1  bl 0x825fb750
	ctx.lr = 0x825FC3B4;
	sub_825FB750(ctx, base);
	// 825FC3B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC3B8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825FC3BC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FC3C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FC3C4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825FC3C8: 419A0024  beq cr6, 0x825fc3ec
	if ctx.cr[6].eq {
	pc = 0x825FC3EC; continue 'dispatch;
	}
	// 825FC3CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FC3D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FC3D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC3D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FC3DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FC3E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FC3E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC3E8: 4082FFE8  bne 0x825fc3d0
	if !ctx.cr[0].eq {
	pc = 0x825FC3D0; continue 'dispatch;
	}
	// 825FC3EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FC3F0: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825FC3F4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC3F8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825FC3FC: 388A18A0  addi r4, r10, 0x18a0
	ctx.r[4].s64 = ctx.r[10].s64 + 6304;
	// 825FC400: 38A00276  li r5, 0x276
	ctx.r[5].s64 = 630;
	// 825FC404: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825FC408: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC40C: 4885C635  bl 0x82e58a40
	ctx.lr = 0x825FC410;
	sub_82E58A40(ctx, base);
	// 825FC410: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825FC414: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC418: 419A0008  beq cr6, 0x825fc420
	if ctx.cr[6].eq {
	pc = 0x825FC420; continue 'dispatch;
	}
	// 825FC41C: 4BCC4475  bl 0x822c0890
	ctx.lr = 0x825FC420;
	sub_822C0890(ctx, base);
	// 825FC420: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825FC424: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC428: 419A0008  beq cr6, 0x825fc430
	if ctx.cr[6].eq {
	pc = 0x825FC430; continue 'dispatch;
	}
	// 825FC42C: 4BCC4465  bl 0x822c0890
	ctx.lr = 0x825FC430;
	sub_822C0890(ctx, base);
	// 825FC430: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC434: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC43C: 38AA19D8  addi r5, r10, 0x19d8
	ctx.r[5].s64 = ctx.r[10].s64 + 6616;
	// 825FC440: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825FC444: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FC448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FC44C: 4E800421  bctrl
	ctx.lr = 0x825FC450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FC450: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825FC454: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC458: 419A0008  beq cr6, 0x825fc460
	if ctx.cr[6].eq {
	pc = 0x825FC460; continue 'dispatch;
	}
	// 825FC45C: 4BCC4435  bl 0x822c0890
	ctx.lr = 0x825FC460;
	sub_822C0890(ctx, base);
	// 825FC460: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FC464: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825FC468: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FC46C: 808B1674  lwz r4, 0x1674(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5748 as u32) ) } as u64;
	// 825FC470: 487F5789  bl 0x82df1bf8
	ctx.lr = 0x825FC474;
	sub_82DF1BF8(ctx, base);
	// 825FC474: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FC478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FC47C: 388B13BC  addi r4, r11, 0x13bc
	ctx.r[4].s64 = ctx.r[11].s64 + 5052;
	// 825FC480: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825FC484: 487FD0AD  bl 0x82df9530
	ctx.lr = 0x825FC488;
	sub_82DF9530(ctx, base);
	// 825FC488: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825FC48C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FC490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FC494: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC498: C02B0140  lfs f1, 0x140(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC49C: 4BF29FB5  bl 0x82526450
	ctx.lr = 0x825FC4A0;
	sub_82526450(ctx, base);
	// 825FC4A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FC4A4: 487F57ED  bl 0x82df1c90
	ctx.lr = 0x825FC4A8;
	sub_82DF1C90(ctx, base);
	// 825FC4A8: 9B9F018C  stb r28, 0x18c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[28].u8 ) };
	// 825FC4AC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 825FC4B0: 48BABCF8  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FC4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FC4B8 size=220
    let mut pc: u32 = 0x825FC4B8;
    'dispatch: loop {
        match pc {
            0x825FC4B8 => {
    //   block [0x825FC4B8..0x825FC594)
	// 825FC4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FC4BC: 48BABCAD  bl 0x831a8168
	ctx.lr = 0x825FC4C0;
	sub_831A8130(ctx, base);
	// 825FC4C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FC4C4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825FC4C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FC4CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FC4D0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825FC4D4: 41820038  beq 0x825fc50c
	if ctx.cr[0].eq {
	pc = 0x825FC50C; continue 'dispatch;
	}
	// 825FC4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC4DC: 48BAD4AD  bl 0x831a9988
	ctx.lr = 0x825FC4E0;
	sub_831A9988(ctx, base);
	// 825FC4E0: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825FC4E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC4E8: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825FC4EC: 48BABC0D  bl 0x831a80f8
	ctx.lr = 0x825FC4F0;
	sub_831A80F8(ctx, base);
	// 825FC4F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FC4F4: 41820018  beq 0x825fc50c
	if ctx.cr[0].eq {
	pc = 0x825FC50C; continue 'dispatch;
	}
	// 825FC4F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC4FC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825FC500: 4BFFF3B9  bl 0x825fb8b8
	ctx.lr = 0x825FC504;
	sub_825FB8B8(ctx, base);
	// 825FC504: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825FC508: 48000084  b 0x825fc58c
	pc = 0x825FC58C; continue 'dispatch;
	// 825FC50C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FC510: 419A006C  beq cr6, 0x825fc57c
	if ctx.cr[6].eq {
	pc = 0x825FC57C; continue 'dispatch;
	}
	// 825FC514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC518: 48BAD471  bl 0x831a9988
	ctx.lr = 0x825FC51C;
	sub_831A9988(ctx, base);
	// 825FC51C: 3D608327  lis r11, -0x7cd9
	ctx.r[11].s64 = -2094596096;
	// 825FC520: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC524: 386BF158  addi r3, r11, -0xea8
	ctx.r[3].s64 = ctx.r[11].s64 + -3752;
	// 825FC528: 48BABBD1  bl 0x831a80f8
	ctx.lr = 0x825FC52C;
	sub_831A80F8(ctx, base);
	// 825FC52C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FC530: 41820014  beq 0x825fc544
	if ctx.cr[0].eq {
	pc = 0x825FC544; continue 'dispatch;
	}
	// 825FC534: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC538: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825FC53C: 4BFFEBE5  bl 0x825fb120
	ctx.lr = 0x825FC540;
	sub_825FB120(ctx, base);
	// 825FC540: 4BFFFFC4  b 0x825fc504
	pc = 0x825FC504; continue 'dispatch;
	// 825FC544: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FC548: 419A0034  beq cr6, 0x825fc57c
	if ctx.cr[6].eq {
	pc = 0x825FC57C; continue 'dispatch;
	}
	// 825FC54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC550: 48BAD439  bl 0x831a9988
	ctx.lr = 0x825FC554;
	sub_831A9988(ctx, base);
	// 825FC554: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FC558: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC55C: 386BD788  addi r3, r11, -0x2878
	ctx.r[3].s64 = ctx.r[11].s64 + -10360;
	// 825FC560: 48BABB99  bl 0x831a80f8
	ctx.lr = 0x825FC564;
	sub_831A80F8(ctx, base);
	// 825FC564: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FC568: 41820014  beq 0x825fc57c
	if ctx.cr[0].eq {
	pc = 0x825FC57C; continue 'dispatch;
	}
	// 825FC56C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC570: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825FC574: 4BFFF035  bl 0x825fb5a8
	ctx.lr = 0x825FC578;
	sub_825FB5A8(ctx, base);
	// 825FC578: 4BFFFF8C  b 0x825fc504
	pc = 0x825FC504; continue 'dispatch;
	// 825FC57C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825FC580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FC588: 4BF16091  bl 0x82512618
	ctx.lr = 0x825FC58C;
	sub_82512618(ctx, base);
	// 825FC58C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FC590: 48BABC28  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FC598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FC598 size=1812
    let mut pc: u32 = 0x825FC598;
    'dispatch: loop {
        match pc {
            0x825FC598 => {
    //   block [0x825FC598..0x825FCCAC)
	// 825FC598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FC59C: 48BABBB9  bl 0x831a8154
	ctx.lr = 0x825FC5A0;
	sub_831A8130(ctx, base);
	// 825FC5A0: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 825FC5A4: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FC5A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FC5AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825FC5B0: 4BF14159  bl 0x82510708
	ctx.lr = 0x825FC5B4;
	sub_82510708(ctx, base);
	// 825FC5B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FC5B8: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC5BC: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FC5C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825FC5C4: 40990010  ble cr6, 0x825fc5d4
	if !ctx.cr[6].gt {
	pc = 0x825FC5D4; continue 'dispatch;
	}
	// 825FC5C8: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC5CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825FC5D0: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825FC5D4: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC5D8: 809F0110  lwz r4, 0x110(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825FC5DC: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC5E0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FC5E4: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 825FC5E8: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC5EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825FC5F0: 4198000C  blt cr6, 0x825fc5fc
	if ctx.cr[6].lt {
	pc = 0x825FC5FC; continue 'dispatch;
	}
	// 825FC5F4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825FC5F8: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 825FC5FC: C004001C  lfs f0, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC600: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 825FC604: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC608: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825FC60C: 4884222D  bl 0x82e3e838
	ctx.lr = 0x825FC610;
	sub_82E3E838(ctx, base);
	// 825FC610: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 825FC614: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FC618: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825FC61C: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 825FC620: 419905D4  bgt cr6, 0x825fcbf4
	if ctx.cr[6].gt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FC624: 3D808204  lis r12, -0x7dfc
	ctx.r[12].s64 = -2113667072;
	// 825FC628: 398C1788  addi r12, r12, 0x1788
	ctx.r[12].s64 = ctx.r[12].s64 + 6024;
	// 825FC62C: 5560083C  slwi r0, r11, 1
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825FC630: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825FC634: 3D808260  lis r12, -0x7da0
	ctx.r[12].s64 = -2107637760;
	// 825FC638: 398CC64C  addi r12, r12, -0x39b4
	ctx.r[12].s64 = ctx.r[12].s64 + -14772;
	// 825FC63C: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 825FC640: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 825FC644: 60000000  nop
	// 825FC648: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 825FC64C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FC650: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825FC654: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FC658: 808B167C  lwz r4, 0x167c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5756 as u32) ) } as u64;
	// 825FC65C: 487F559D  bl 0x82df1bf8
	ctx.lr = 0x825FC660;
	sub_82DF1BF8(ctx, base);
	// 825FC660: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825FC664: 4854ABDD  bl 0x82b47240
	ctx.lr = 0x825FC668;
	sub_82B47240(ctx, base);
	// 825FC668: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FC66C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FC670: 487F5621  bl 0x82df1c90
	ctx.lr = 0x825FC674;
	sub_82DF1C90(ctx, base);
	// 825FC674: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825FC678: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 825FC67C: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825FC680: 41820010  beq 0x825fc690
	if ctx.cr[0].eq {
	pc = 0x825FC690; continue 'dispatch;
	}
	// 825FC684: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 825FC688: 93DF0174  stw r30, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[30].u32 ) };
	// 825FC68C: 48000040  b 0x825fc6cc
	pc = 0x825FC6CC; continue 'dispatch;
	// 825FC690: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825FC694: 41820014  beq 0x825fc6a8
	if ctx.cr[0].eq {
	pc = 0x825FC6A8; continue 'dispatch;
	}
	// 825FC698: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 825FC69C: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 825FC6A0: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 825FC6A4: 48000024  b 0x825fc6c8
	pc = 0x825FC6C8; continue 'dispatch;
	// 825FC6A8: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FC6AC: 41820034  beq 0x825fc6e0
	if ctx.cr[0].eq {
	pc = 0x825FC6E0; continue 'dispatch;
	}
	// 825FC6B0: 897F0150  lbz r11, 0x150(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 825FC6B4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FC6B8: 41820028  beq 0x825fc6e0
	if ctx.cr[0].eq {
	pc = 0x825FC6E0; continue 'dispatch;
	}
	// 825FC6BC: 817F015C  lwz r11, 0x15c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 825FC6C0: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 825FC6C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825FC6C8: 915F0174  stw r10, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 825FC6CC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825FC6D0: D3FF0178  stfs f31, 0x178(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC6D4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825FC6D8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 825FC6DC: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 825FC6E0: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC6E4: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC6E8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FC6EC: C1BF014C  lfs f13, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC6F0: D01F0178  stfs f0, 0x178(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC6F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825FC6F8: 419804FC  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FC6FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC700: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC704: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825FC708: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825FC70C: 396B1758  addi r11, r11, 0x1758
	ctx.r[11].s64 = ctx.r[11].s64 + 5976;
	// 825FC710: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825FC714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC718: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 825FC71C: 3B6B0008  addi r27, r11, 8
	ctx.r[27].s64 = ctx.r[11].s64 + 8;
	// 825FC720: 3B4A6910  addi r26, r10, 0x6910
	ctx.r[26].s64 = ctx.r[10].s64 + 26896;
	// 825FC724: 3B210060  addi r25, r1, 0x60
	ctx.r[25].s64 = ctx.r[1].s64 + 96;
	// 825FC728: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC72C: 3B010050  addi r24, r1, 0x50
	ctx.r[24].s64 = ctx.r[1].s64 + 80;
	// 825FC730: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825FC734: 3AE10064  addi r23, r1, 0x64
	ctx.r[23].s64 = ctx.r[1].s64 + 100;
	// 825FC738: 4BF153B1  bl 0x82511ae8
	ctx.lr = 0x825FC73C;
	sub_82511AE8(ctx, base);
	// 825FC73C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC740: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825FC744: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825FC748: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825FC74C: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 825FC750: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 825FC754: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 825FC758: 4BFFEEA9  bl 0x825fb600
	ctx.lr = 0x825FC75C;
	sub_825FB600(ctx, base);
	// 825FC75C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC760: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FC764: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FC768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FC76C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825FC770: 419A0024  beq cr6, 0x825fc794
	if ctx.cr[6].eq {
	pc = 0x825FC794; continue 'dispatch;
	}
	// 825FC774: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FC778: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FC77C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC780: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FC784: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FC788: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FC78C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FC790: 4082FFE8  bne 0x825fc778
	if !ctx.cr[0].eq {
	pc = 0x825FC778; continue 'dispatch;
	}
	// 825FC794: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC798: 80DF0170  lwz r6, 0x170(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 825FC79C: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825FC7A0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FC7A4: 388B18A0  addi r4, r11, 0x18a0
	ctx.r[4].s64 = ctx.r[11].s64 + 6304;
	// 825FC7A8: 38A00147  li r5, 0x147
	ctx.r[5].s64 = 327;
	// 825FC7AC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 825FC7B0: 4885C291  bl 0x82e58a40
	ctx.lr = 0x825FC7B4;
	sub_82E58A40(ctx, base);
	// 825FC7B4: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FC7B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC7BC: 419A0008  beq cr6, 0x825fc7c4
	if ctx.cr[6].eq {
	pc = 0x825FC7C4; continue 'dispatch;
	}
	// 825FC7C0: 4BCC40D1  bl 0x822c0890
	ctx.lr = 0x825FC7C4;
	sub_822C0890(ctx, base);
	// 825FC7C4: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825FC7C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC7CC: 419A0008  beq cr6, 0x825fc7d4
	if ctx.cr[6].eq {
	pc = 0x825FC7D4; continue 'dispatch;
	}
	// 825FC7D0: 4BCC40C1  bl 0x822c0890
	ctx.lr = 0x825FC7D4;
	sub_822C0890(ctx, base);
	// 825FC7D4: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FC7D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC7DC: 419A0020  beq cr6, 0x825fc7fc
	if ctx.cr[6].eq {
	pc = 0x825FC7FC; continue 'dispatch;
	}
	// 825FC7E0: 48549EE9  bl 0x82b466c8
	ctx.lr = 0x825FC7E4;
	sub_82B466C8(ctx, base);
	// 825FC7E4: 939F011C  stw r28, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[28].u32 ) };
	// 825FC7E8: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825FC7EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC7F0: 939F0120  stw r28, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 825FC7F4: 419A0008  beq cr6, 0x825fc7fc
	if ctx.cr[6].eq {
	pc = 0x825FC7FC; continue 'dispatch;
	}
	// 825FC7F8: 4BCC4099  bl 0x822c0890
	ctx.lr = 0x825FC7FC;
	sub_822C0890(ctx, base);
	// 825FC7FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FC800: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC804: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FC808: 38AA1A14  addi r5, r10, 0x1a14
	ctx.r[5].s64 = ctx.r[10].s64 + 6676;
	// 825FC80C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825FC810: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FC814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FC818: 4E800421  bctrl
	ctx.lr = 0x825FC81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FC81C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825FC820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FC824: 419A0008  beq cr6, 0x825fc82c
	if ctx.cr[6].eq {
	pc = 0x825FC82C; continue 'dispatch;
	}
	// 825FC828: 4BCC4069  bl 0x822c0890
	ctx.lr = 0x825FC82C;
	sub_822C0890(ctx, base);
	// 825FC82C: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825FC830: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FC834: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 825FC838: 995F017E  stb r10, 0x17e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(382 as u32), ctx.r[10].u8 ) };
	// 825FC83C: C00B0018  lfs f0, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC840: 93DF0164  stw r30, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[30].u32 ) };
	// 825FC844: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FC848: 913F0174  stw r9, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[9].u32 ) };
	// 825FC84C: 480003A8  b 0x825fcbf4
	pc = 0x825FCBF4; continue 'dispatch;
	// 825FC850: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC854: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC858: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC85C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 825FC860: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FC864: D17F0178  stfs f11, 0x178(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC868: 3BCB1758  addi r30, r11, 0x1758
	ctx.r[30].s64 = ctx.r[11].s64 + 5976;
	// 825FC86C: C15F0140  lfs f10, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825FC870: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825FC874: 837F012C  lwz r27, 0x12c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FC878: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825FC87C: C00A614C  lfs f0, 0x614c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC880: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FC884: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC888: EDAD533C  fnmsubs f13, f13, f12, f10
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 825FC88C: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FC890: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FC894: 488800F5  bl 0x82e7c988
	ctx.lr = 0x825FC898;
	sub_82E7C988(ctx, base);
	// 825FC898: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC89C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825FC8A0: 488169C1  bl 0x82e13260
	ctx.lr = 0x825FC8A4;
	sub_82E13260(ctx, base);
	// 825FC8A4: C01EFFFC  lfs f0, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC8A8: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC8AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FC8B0: 41980344  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FC8B4: C01F013C  lfs f0, 0x13c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC8B8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 825FC8BC: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825FC8C0: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825FC8C4: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825FC8C8: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825FC8CC: C03F0140  lfs f1, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC8D0: 488800B9  bl 0x82e7c988
	ctx.lr = 0x825FC8D4;
	sub_82E7C988(ctx, base);
	// 825FC8D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC8D8: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 825FC8DC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825FC8E0: 4887F3E9  bl 0x82e7bcc8
	ctx.lr = 0x825FC8E4;
	sub_82E7BCC8(ctx, base);
	// 825FC8E4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825FC8E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FC8EC: C03F0144  lfs f1, 0x144(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC8F0: 4BFFF7E1  bl 0x825fc0d0
	ctx.lr = 0x825FC8F4;
	sub_825FC0D0(ctx, base);
	// 825FC8F4: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825FC8F8: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC8FC: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC900: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825FC904: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825FC908: 480002EC  b 0x825fcbf4
	pc = 0x825FCBF4; continue 'dispatch;
	// 825FC90C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC910: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC914: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC918: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FC91C: 396B1758  addi r11, r11, 0x1758
	ctx.r[11].s64 = ctx.r[11].s64 + 5976;
	// 825FC920: D1BF0178  stfs f13, 0x178(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC924: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC928: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FC92C: 419802C8  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FC930: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825FC934: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FC938: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 825FC93C: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC940: 995F017E  stb r10, 0x17e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(382 as u32), ctx.r[10].u8 ) };
	// 825FC944: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC948: 913F0174  stw r9, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[9].u32 ) };
	// 825FC94C: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FC950: 480002A4  b 0x825fcbf4
	pc = 0x825FCBF4; continue 'dispatch;
	// 825FC954: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC958: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825FC95C: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC960: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FC964: ED4D002A  fadds f10, f13, f0
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FC968: D15F0178  stfs f10, 0x178(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC96C: 3BCA1758  addi r30, r10, 0x1758
	ctx.r[30].s64 = ctx.r[10].s64 + 5976;
	// 825FC970: C13F0140  lfs f9, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825FC974: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FC978: 837F012C  lwz r27, 0x12c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FC97C: C00B614C  lfs f0, 0x614c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC980: 3D608212  lis r11, -0x7dee
	ctx.r[11].s64 = -2112749568;
	// 825FC984: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825FC988: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FC98C: C16A08A8  lfs f11, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825FC990: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FC994: C1ABDFAC  lfs f13, -0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC998: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 825FC99C: EDAD4B3C  fnmsubs f13, f13, f12, f9
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[9].f64) as f32) as f64);
	// 825FC9A0: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825FC9A4: 4887FFE5  bl 0x82e7c988
	ctx.lr = 0x825FC9A8;
	sub_82E7C988(ctx, base);
	// 825FC9A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FC9AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825FC9B0: 488168B1  bl 0x82e13260
	ctx.lr = 0x825FC9B4;
	sub_82E13260(ctx, base);
	// 825FC9B4: C01EFFFC  lfs f0, -4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC9B8: 4800021C  b 0x825fcbd4
	pc = 0x825FCBD4; continue 'dispatch;
	// 825FC9BC: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC9C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FC9C4: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FC9C8: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FC9CC: 3BCB1758  addi r30, r11, 0x1758
	ctx.r[30].s64 = ctx.r[11].s64 + 5976;
	// 825FC9D0: D1BF0178  stfs f13, 0x178(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FC9D4: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC9D8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FC9DC: 41980218  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FC9E0: C01F0134  lfs f0, 0x134(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FC9E4: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825FC9E8: C03F0138  lfs f1, 0x138(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(312 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FC9EC: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825FC9F0: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825FC9F4: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825FC9F8: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 825FC9FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FCA00: 4BFFF6D1  bl 0x825fc0d0
	ctx.lr = 0x825FCA04;
	sub_825FC0D0(ctx, base);
	// 825FCA04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825FCA08: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCA0C: 997F017E  stb r11, 0x17e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(382 as u32), ctx.r[11].u8 ) };
	// 825FCA10: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825FCA14: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCA18: D1BF0184  stfs f13, 0x184(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FCA1C: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 825FCA20: 480001D0  b 0x825fcbf0
	pc = 0x825FCBF0; continue 'dispatch;
	// 825FCA24: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCA28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FCA2C: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCA30: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FCA34: 3BCB1758  addi r30, r11, 0x1758
	ctx.r[30].s64 = ctx.r[11].s64 + 5976;
	// 825FCA38: D1BF0178  stfs f13, 0x178(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FCA3C: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCA40: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FCA44: 419801B0  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FCA48: C01F0154  lfs f0, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCA4C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825FCA50: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825FCA54: C03F0158  lfs f1, 0x158(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(344 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FCA58: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 825FCA5C: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825FCA60: D3E10088  stfs f31, 0x88(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825FCA64: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825FCA68: 4BFFFF94  b 0x825fc9fc
	pc = 0x825FC9FC; continue 'dispatch;
	// 825FCA6C: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCA70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FCA74: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCA78: 3D408212  lis r10, -0x7dee
	ctx.r[10].s64 = -2112749568;
	// 825FCA7C: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FCA80: D17F0178  stfs f11, 0x178(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FCA84: 3FC08204  lis r30, -0x7dfc
	ctx.r[30].s64 = -2113667072;
	// 825FCA88: 837F012C  lwz r27, 0x12c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FCA8C: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825FCA90: C00BD7BC  lfs f0, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCA94: 397E1758  addi r11, r30, 0x1758
	ctx.r[11].s64 = ctx.r[30].s64 + 5976;
	// 825FCA98: C1AADFAC  lfs f13, -0x2054(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCA9C: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FCAA0: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FCAA4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FCAA8: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 825FCAAC: 4887FEDD  bl 0x82e7c988
	ctx.lr = 0x825FCAB0;
	sub_82E7C988(ctx, base);
	// 825FCAB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FCAB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825FCAB8: 488167A9  bl 0x82e13260
	ctx.lr = 0x825FCABC;
	sub_82E13260(ctx, base);
	// 825FCABC: C01E1758  lfs f0, 0x1758(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(5976 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCAC0: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCAC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FCAC8: 4198012C  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FCACC: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FCAD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FCAD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FCAD8: 388B1A0C  addi r4, r11, 0x1a0c
	ctx.r[4].s64 = ctx.r[11].s64 + 6668;
	// 825FCADC: 487F6F2D  bl 0x82df3a08
	ctx.lr = 0x825FCAE0;
	sub_82DF3A08(ctx, base);
	// 825FCAE0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825FCAE4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825FCAE8: 809F00F0  lwz r4, 0xf0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 825FCAEC: 485B6825  bl 0x82bb3310
	ctx.lr = 0x825FCAF0;
	sub_82BB3310(ctx, base);
	// 825FCAF0: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825FCAF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FCAF8: 419A0008  beq cr6, 0x825fcb00
	if ctx.cr[6].eq {
	pc = 0x825FCB00; continue 'dispatch;
	}
	// 825FCAFC: 4BCC3D95  bl 0x822c0890
	ctx.lr = 0x825FCB00;
	sub_822C0890(ctx, base);
	// 825FCB00: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FCB04: 487F6925  bl 0x82df3428
	ctx.lr = 0x825FCB08;
	sub_82DF3428(ctx, base);
	// 825FCB08: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FCB0C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825FCB10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FCB14: 997F017C  stb r11, 0x17c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u8 ) };
	// 825FCB18: 419A0020  beq cr6, 0x825fcb38
	if ctx.cr[6].eq {
	pc = 0x825FCB38; continue 'dispatch;
	}
	// 825FCB1C: 48549BAD  bl 0x82b466c8
	ctx.lr = 0x825FCB20;
	sub_82B466C8(ctx, base);
	// 825FCB20: 939F011C  stw r28, 0x11c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), ctx.r[28].u32 ) };
	// 825FCB24: 807F0120  lwz r3, 0x120(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 825FCB28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FCB2C: 939F0120  stw r28, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[28].u32 ) };
	// 825FCB30: 419A0008  beq cr6, 0x825fcb38
	if ctx.cr[6].eq {
	pc = 0x825FCB38; continue 'dispatch;
	}
	// 825FCB34: 4BCC3D5D  bl 0x822c0890
	ctx.lr = 0x825FCB38;
	sub_822C0890(ctx, base);
	// 825FCB38: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 825FCB3C: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825FCB40: 480000B4  b 0x825fcbf4
	pc = 0x825FCBF4; continue 'dispatch;
	// 825FCB44: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCB48: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FCB4C: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCB50: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FCB54: 396B1758  addi r11, r11, 0x1758
	ctx.r[11].s64 = ctx.r[11].s64 + 5976;
	// 825FCB58: D1BF0178  stfs f13, 0x178(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FCB5C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCB60: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FCB64: 41980090  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FCB68: D3FF0178  stfs f31, 0x178(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FCB6C: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 825FCB70: 4BFFFFCC  b 0x825fcb3c
	pc = 0x825FCB3C; continue 'dispatch;
	// 825FCB74: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCB78: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 825FCB7C: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCB80: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FCB84: ED6D002A  fadds f11, f13, f0
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FCB88: D17F0178  stfs f11, 0x178(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 825FCB8C: 3D208212  lis r9, -0x7dee
	ctx.r[9].s64 = -2112749568;
	// 825FCB90: 83DF012C  lwz r30, 0x12c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FCB94: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825FCB98: C00B614C  lfs f0, 0x614c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCB9C: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 825FCBA0: C1AA08A8  lfs f13, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCBA4: 3B681758  addi r27, r8, 0x1758
	ctx.r[27].s64 = ctx.r[8].s64 + 5976;
	// 825FCBA8: C19B0004  lfs f12, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FCBAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FCBB0: C009DFAC  lfs f0, -0x2054(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCBB4: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 825FCBB8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FCBBC: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 825FCBC0: 4887FDC9  bl 0x82e7c988
	ctx.lr = 0x825FCBC4;
	sub_82E7C988(ctx, base);
	// 825FCBC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FCBC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FCBCC: 48816695  bl 0x82e13260
	ctx.lr = 0x825FCBD0;
	sub_82E13260(ctx, base);
	// 825FCBD0: C01BFFFC  lfs f0, -4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCBD4: C1BF0178  lfs f13, 0x178(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(376 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCBD8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FCBDC: 41980018  blt cr6, 0x825fcbf4
	if ctx.cr[6].lt {
	pc = 0x825FCBF4; continue 'dispatch;
	}
	// 825FCBE0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FCBE4: 807F012C  lwz r3, 0x12c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FCBE8: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825FCBEC: 48816675  bl 0x82e13260
	ctx.lr = 0x825FCBF0;
	sub_82E13260(ctx, base);
	// 825FCBF0: 939F0174  stw r28, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[28].u32 ) };
	// 825FCBF4: 897F017C  lbz r11, 0x17c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 825FCBF8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FCBFC: 41820010  beq 0x825fcc0c
	if ctx.cr[0].eq {
	pc = 0x825FCC0C; continue 'dispatch;
	}
	// 825FCC00: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FCC04: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 825FCC08: 485B88E9  bl 0x82bb54f0
	ctx.lr = 0x825FCC0C;
	sub_82BB54F0(ctx, base);
	// 825FCC0C: 897F017D  lbz r11, 0x17d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(381 as u32) ) } as u64;
	// 825FCC10: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FCC14: 41820048  beq 0x825fcc5c
	if ctx.cr[0].eq {
	pc = 0x825FCC5C; continue 'dispatch;
	}
	// 825FCC18: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCC1C: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCC20: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FCC24: C01F014C  lfs f0, 0x14c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCC28: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 825FCC2C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FCC30: 4198000C  blt cr6, 0x825fcc3c
	if ctx.cr[6].lt {
	pc = 0x825FCC3C; continue 'dispatch;
	}
	// 825FCC34: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 825FCC38: 9B9F017D  stb r28, 0x17d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(381 as u32), ctx.r[28].u8 ) };
	// 825FCC3C: C1BF0180  lfs f13, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCC40: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825FCC44: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 825FCC48: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCC4C: C1840018  lfs f12, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FCC50: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 825FCC54: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 825FCC58: 48000040  b 0x825fcc98
	pc = 0x825FCC98; continue 'dispatch;
	// 825FCC5C: 897F017E  lbz r11, 0x17e(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(382 as u32) ) } as u64;
	// 825FCC60: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FCC64: 4182003C  beq 0x825fcca0
	if ctx.cr[0].eq {
	pc = 0x825FCCA0; continue 'dispatch;
	}
	// 825FCC68: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCC6C: C1BF0184  lfs f13, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCC70: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 825FCC74: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FCC78: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825FCC7C: 4199000C  bgt cr6, 0x825fcc88
	if ctx.cr[6].gt {
	pc = 0x825FCC88; continue 'dispatch;
	}
	// 825FCC80: D3FF0184  stfs f31, 0x184(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 825FCC84: 9B9F017E  stb r28, 0x17e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(382 as u32), ctx.r[28].u8 ) };
	// 825FCC88: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825FCC8C: C01F0184  lfs f0, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FCC90: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FCC94: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FCC98: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825FCC9C: 48841B9D  bl 0x82e3e838
	ctx.lr = 0x825FCCA0;
	sub_82E3E838(ctx, base);
	// 825FCCA0: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 825FCCA4: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825FCCA8: 48BAB4FC  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FCCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FCCB0 size=480
    let mut pc: u32 = 0x825FCCB0;
    'dispatch: loop {
        match pc {
            0x825FCCB0 => {
    //   block [0x825FCCB0..0x825FCE90)
	// 825FCCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FCCB4: 48BAB4AD  bl 0x831a8160
	ctx.lr = 0x825FCCB8;
	sub_831A8130(ctx, base);
	// 825FCCB8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825FCCBC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FCCC0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FCCC4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825FCCC8: 3BCB18A0  addi r30, r11, 0x18a0
	ctx.r[30].s64 = ctx.r[11].s64 + 6304;
	// 825FCCCC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825FCCD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FCCD4: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 825FCCD8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825FCCDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FCCE0: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 825FCCE4: 487F5705  bl 0x82df23e8
	ctx.lr = 0x825FCCE8;
	sub_82DF23E8(ctx, base);
	// 825FCCE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FCCEC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825FCCF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FCCF4: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 825FCCF8: C3EA08A4  lfs f31, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FCCFC: 41820038  beq 0x825fcd34
	if ctx.cr[0].eq {
	pc = 0x825FCD34; continue 'dispatch;
	}
	// 825FCD00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FCD04: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 825FCD08: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 825FCD0C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825FCD10: 3D008338  lis r8, -0x7cc8
	ctx.r[8].s64 = -2093481984;
	// 825FCD14: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825FCD18: 38886910  addi r4, r8, 0x6910
	ctx.r[4].s64 = ctx.r[8].s64 + 26896;
	// 825FCD1C: C06B9D1C  lfs f3, -0x62e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25316 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825FCD20: C04A7BC8  lfs f2, 0x7bc8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FCD24: C029E4E4  lfs f1, -0x1b1c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6940 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FCD28: 4BFFE1A9  bl 0x825faed0
	ctx.lr = 0x825FCD2C;
	sub_825FAED0(ctx, base);
	// 825FCD2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FCD30: 48000008  b 0x825fcd38
	pc = 0x825FCD38; continue 'dispatch;
	// 825FCD34: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FCD38: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FCD3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FCD40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FCD44: 4BFFDEED  bl 0x825fac30
	ctx.lr = 0x825FCD48;
	sub_825FAC30(ctx, base);
	// 825FCD48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FCD4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FCD50: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FCD54: 4BCC32AD  bl 0x822c0000
	ctx.lr = 0x825FCD58;
	sub_822C0000(ctx, base);
	// 825FCD58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FCD5C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FCD60: 38A00061  li r5, 0x61
	ctx.r[5].s64 = 97;
	// 825FCD64: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825FCD68: 4BCC3671  bl 0x822c03d8
	ctx.lr = 0x825FCD6C;
	sub_822C03D8(ctx, base);
	// 825FCD6C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FCD70: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825FCD74: 418200AC  beq 0x825fce20
	if ctx.cr[0].eq {
	pc = 0x825FCE20; continue 'dispatch;
	}
	// 825FCD78: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FCD7C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825FCD80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825FCD84: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825FCD88: 409A0008  bne cr6, 0x825fcd90
	if !ctx.cr[6].eq {
	pc = 0x825FCD90; continue 'dispatch;
	}
	// 825FCD8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FCD90: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FCD94: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825FCD98: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825FCD9C: 419A0024  beq cr6, 0x825fcdc0
	if ctx.cr[6].eq {
	pc = 0x825FCDC0; continue 'dispatch;
	}
	// 825FCDA0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825FCDA4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825FCDA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FCDAC: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825FCDB0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825FCDB4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FCDB8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FCDBC: 4082FFE8  bne 0x825fcda4
	if !ctx.cr[0].eq {
	pc = 0x825FCDA4; continue 'dispatch;
	}
	// 825FCDC0: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825FCDC4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825FCDC8: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825FCDCC: 419A0024  beq cr6, 0x825fcdf0
	if ctx.cr[6].eq {
	pc = 0x825FCDF0; continue 'dispatch;
	}
	// 825FCDD0: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 825FCDD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FCDD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FCDDC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FCDE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FCDE4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FCDE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FCDEC: 4082FFE8  bne 0x825fcdd4
	if !ctx.cr[0].eq {
	pc = 0x825FCDD4; continue 'dispatch;
	}
	// 825FCDF0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825FCDF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FCDF8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825FCDFC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825FCE00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FCE04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FCE08: 4819C129  bl 0x82798f30
	ctx.lr = 0x825FCE0C;
	sub_82798F30(ctx, base);
	// 825FCE0C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FCE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FCE14: 4819E855  bl 0x8279b668
	ctx.lr = 0x825FCE18;
	sub_8279B668(ctx, base);
	// 825FCE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FCE1C: 48000008  b 0x825fce24
	pc = 0x825FCE24; continue 'dispatch;
	// 825FCE20: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FCE24: 93FA0000  stw r31, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FCE28: 3BDA0004  addi r30, r26, 4
	ctx.r[30].s64 = ctx.r[26].s64 + 4;
	// 825FCE2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FCE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FCE34: 4BF9AE1D  bl 0x82597c50
	ctx.lr = 0x825FCE38;
	sub_82597C50(ctx, base);
	// 825FCE38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FCE3C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FCE40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FCE44: 4BCC31BD  bl 0x822c0000
	ctx.lr = 0x825FCE48;
	sub_822C0000(ctx, base);
	// 825FCE48: 576B07FF  clrlwi. r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FCE4C: 41820024  beq 0x825fce70
	if ctx.cr[0].eq {
	pc = 0x825FCE70; continue 'dispatch;
	}
	// 825FCE50: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825FCE54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FCE58: 419A0008  beq cr6, 0x825fce60
	if ctx.cr[6].eq {
	pc = 0x825FCE60; continue 'dispatch;
	}
	// 825FCE5C: 4BCC3A35  bl 0x822c0890
	ctx.lr = 0x825FCE60;
	sub_822C0890(ctx, base);
	// 825FCE60: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825FCE64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FCE68: 419A0008  beq cr6, 0x825fce70
	if ctx.cr[6].eq {
	pc = 0x825FCE70; continue 'dispatch;
	}
	// 825FCE6C: 4BCC3A25  bl 0x822c0890
	ctx.lr = 0x825FCE70;
	sub_822C0890(ctx, base);
	// 825FCE70: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825FCE74: 419A000C  beq cr6, 0x825fce80
	if ctx.cr[6].eq {
	pc = 0x825FCE80; continue 'dispatch;
	}
	// 825FCE78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FCE7C: 4BCC3A15  bl 0x822c0890
	ctx.lr = 0x825FCE80;
	sub_822C0890(ctx, base);
	// 825FCE80: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825FCE84: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825FCE88: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825FCE8C: 48BAB324  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FCE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FCE90 size=128
    let mut pc: u32 = 0x825FCE90;
    'dispatch: loop {
        match pc {
            0x825FCE90 => {
    //   block [0x825FCE90..0x825FCF10)
	// 825FCE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FCE94: 48BAB2D9  bl 0x831a816c
	ctx.lr = 0x825FCE98;
	sub_831A8130(ctx, base);
	// 825FCE98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FCE9C: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 825FCEA0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FCEA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FCEA8: 3BEB7EF4  addi r31, r11, 0x7ef4
	ctx.r[31].s64 = ctx.r[11].s64 + 32500;
	// 825FCEAC: 816A7EFC  lwz r11, 0x7efc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32508 as u32) ) } as u64;
	// 825FCEB0: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825FCEB4: 40820024  bne 0x825fced8
	if !ctx.cr[0].eq {
	pc = 0x825FCED8; continue 'dispatch;
	}
	// 825FCEB8: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 825FCEBC: 3D008260  lis r8, -0x7da0
	ctx.r[8].s64 = -2107637760;
	// 825FCEC0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 825FCEC4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 825FCEC8: 3908AE88  addi r8, r8, -0x5178
	ctx.r[8].s64 = ctx.r[8].s64 + -20856;
	// 825FCECC: 916A7EFC  stw r11, 0x7efc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32508 as u32), ctx.r[11].u32 ) };
	// 825FCED0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825FCED4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825FCED8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825FCEDC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825FCEE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FCEE4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 825FCEE8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 825FCEEC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FCEF0: 480576D1  bl 0x826545c0
	ctx.lr = 0x825FCEF4;
	sub_826545C0(ctx, base);
	// 825FCEF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FCEF8: 4182000C  beq 0x825fcf04
	if ctx.cr[0].eq {
	pc = 0x825FCF04; continue 'dispatch;
	}
	// 825FCEFC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FCF00: 48000008  b 0x825fcf08
	pc = 0x825FCF08; continue 'dispatch;
	// 825FCF04: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825FCF08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FCF0C: 48BAB2B0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FCF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FCF10 size=96
    let mut pc: u32 = 0x825FCF10;
    'dispatch: loop {
        match pc {
            0x825FCF10 => {
    //   block [0x825FCF10..0x825FCF70)
	// 825FCF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FCF14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FCF18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FCF1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FCF20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FCF24: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FCF28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FCF2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FCF30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FCF34: 388B1A28  addi r4, r11, 0x1a28
	ctx.r[4].s64 = ctx.r[11].s64 + 6696;
	// 825FCF38: 487F6AD1  bl 0x82df3a08
	ctx.lr = 0x825FCF3C;
	sub_82DF3A08(ctx, base);
	// 825FCF3C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FCF40: 38BF018C  addi r5, r31, 0x18c
	ctx.r[5].s64 = ctx.r[31].s64 + 396;
	// 825FCF44: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FCF48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FCF4C: 4BFFB13D  bl 0x825f8088
	ctx.lr = 0x825FCF50;
	sub_825F8088(ctx, base);
	// 825FCF50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FCF54: 487F64D5  bl 0x82df3428
	ctx.lr = 0x825FCF58;
	sub_82DF3428(ctx, base);
	// 825FCF58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FCF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FCF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FCF64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FCF68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FCF6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FCF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FCF70 size=116
    let mut pc: u32 = 0x825FCF70;
    'dispatch: loop {
        match pc {
            0x825FCF70 => {
    //   block [0x825FCF70..0x825FCFE4)
	// 825FCF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FCF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FCF78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FCF7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FCF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FCF84: 48801815  bl 0x82dfe798
	ctx.lr = 0x825FCF88;
	sub_82DFE798(ctx, base);
	// 825FCF88: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FCF8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FCF90: 394A1A38  addi r10, r10, 0x1a38
	ctx.r[10].s64 = ctx.r[10].s64 + 6712;
	// 825FCF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FCF98: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825FCF9C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825FCFA0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825FCFA4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825FCFA8: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825FCFAC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825FCFB0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 825FCFB4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 825FCFB8: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825FCFBC: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 825FCFC0: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825FCFC4: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 825FCFC8: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 825FCFCC: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 825FCFD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FCFD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FCFD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FCFDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FCFE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FCFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FCFE8 size=116
    let mut pc: u32 = 0x825FCFE8;
    'dispatch: loop {
        match pc {
            0x825FCFE8 => {
    //   block [0x825FCFE8..0x825FD05C)
	// 825FCFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FCFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FCFF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FCFF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FCFF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FCFFC: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 825FD000: 483135A9  bl 0x829105a8
	ctx.lr = 0x825FD004;
	sub_829105A8(ctx, base);
	// 825FD004: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 825FD008: 483135A1  bl 0x829105a8
	ctx.lr = 0x825FD00C;
	sub_829105A8(ctx, base);
	// 825FD00C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 825FD010: 48313599  bl 0x829105a8
	ctx.lr = 0x825FD014;
	sub_829105A8(ctx, base);
	// 825FD014: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825FD018: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD01C: 419A0008  beq cr6, 0x825fd024
	if ctx.cr[6].eq {
	pc = 0x825FD024; continue 'dispatch;
	}
	// 825FD020: 4BCC3871  bl 0x822c0890
	ctx.lr = 0x825FD024;
	sub_822C0890(ctx, base);
	// 825FD024: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825FD028: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD02C: 419A0008  beq cr6, 0x825fd034
	if ctx.cr[6].eq {
	pc = 0x825FD034; continue 'dispatch;
	}
	// 825FD030: 4BCC3861  bl 0x822c0890
	ctx.lr = 0x825FD034;
	sub_822C0890(ctx, base);
	// 825FD034: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FD038: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825FD03C: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 825FD040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FD044: 487F63E5  bl 0x82df3428
	ctx.lr = 0x825FD048;
	sub_82DF3428(ctx, base);
	// 825FD048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FD04C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FD050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FD054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FD058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FD060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FD060 size=156
    let mut pc: u32 = 0x825FD060;
    'dispatch: loop {
        match pc {
            0x825FD060 => {
    //   block [0x825FD060..0x825FD0FC)
	// 825FD060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FD064: 48BAB109  bl 0x831a816c
	ctx.lr = 0x825FD068;
	sub_831A8130(ctx, base);
	// 825FD068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FD06C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD070: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FD074: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825FD078: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD07C: 388B18A0  addi r4, r11, 0x18a0
	ctx.r[4].s64 = ctx.r[11].s64 + 6304;
	// 825FD080: 38A002CD  li r5, 0x2cd
	ctx.r[5].s64 = 717;
	// 825FD084: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825FD088: 487F5361  bl 0x82df23e8
	ctx.lr = 0x825FD08C;
	sub_82DF23E8(ctx, base);
	// 825FD08C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FD090: 41820010  beq 0x825fd0a0
	if ctx.cr[0].eq {
	pc = 0x825FD0A0; continue 'dispatch;
	}
	// 825FD094: 4BFFFEDD  bl 0x825fcf70
	ctx.lr = 0x825FD098;
	sub_825FCF70(ctx, base);
	// 825FD098: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FD09C: 48000008  b 0x825fd0a4
	pc = 0x825FD0A4; continue 'dispatch;
	// 825FD0A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FD0A4: 3BDF0100  addi r30, r31, 0x100
	ctx.r[30].s64 = ctx.r[31].s64 + 256;
	// 825FD0A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD0AC: 4BFFE74D  bl 0x825fb7f8
	ctx.lr = 0x825FD0B0;
	sub_825FB7F8(ctx, base);
	// 825FD0B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FD0B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD0B8: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825FD0BC: 48819785  bl 0x82e16840
	ctx.lr = 0x825FD0C0;
	sub_82E16840(ctx, base);
	// 825FD0C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD0C4: 807F0100  lwz r3, 0x100(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 825FD0C8: 4881A299  bl 0x82e17360
	ctx.lr = 0x825FD0CC;
	sub_82E17360(ctx, base);
	// 825FD0CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FD0D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD0D4: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 825FD0D8: 83FF0100  lwz r31, 0x100(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 825FD0DC: 487FC455  bl 0x82df9530
	ctx.lr = 0x825FD0E0;
	sub_82DF9530(ctx, base);
	// 825FD0E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FD0E4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825FD0E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD0EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD0F0: 4881A659  bl 0x82e17748
	ctx.lr = 0x825FD0F4;
	sub_82E17748(ctx, base);
	// 825FD0F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FD0F8: 48BAB0C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FD100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FD100 size=400
    let mut pc: u32 = 0x825FD100;
    'dispatch: loop {
        match pc {
            0x825FD100 => {
    //   block [0x825FD100..0x825FD290)
	// 825FD100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FD104: 48BAB065  bl 0x831a8168
	ctx.lr = 0x825FD108;
	sub_831A8130(ctx, base);
	// 825FD108: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FD10C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD110: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FD114: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825FD118: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD11C: 388B18A0  addi r4, r11, 0x18a0
	ctx.r[4].s64 = ctx.r[11].s64 + 6304;
	// 825FD120: 38A002DF  li r5, 0x2df
	ctx.r[5].s64 = 735;
	// 825FD124: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825FD128: 487F52C1  bl 0x82df23e8
	ctx.lr = 0x825FD12C;
	sub_82DF23E8(ctx, base);
	// 825FD12C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FD130: 41820010  beq 0x825fd140
	if ctx.cr[0].eq {
	pc = 0x825FD140; continue 'dispatch;
	}
	// 825FD134: 4BFFFE3D  bl 0x825fcf70
	ctx.lr = 0x825FD138;
	sub_825FCF70(ctx, base);
	// 825FD138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FD13C: 48000008  b 0x825fd144
	pc = 0x825FD144; continue 'dispatch;
	// 825FD140: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FD144: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825FD148: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD14C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825FD150: 4BFFDBA9  bl 0x825facf8
	ctx.lr = 0x825FD154;
	sub_825FACF8(ctx, base);
	// 825FD154: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FD158: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD15C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825FD160: 4BCC2EA1  bl 0x822c0000
	ctx.lr = 0x825FD164;
	sub_822C0000(ctx, base);
	// 825FD164: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825FD168: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD16C: 807E00E8  lwz r3, 0xe8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 825FD170: 488196D1  bl 0x82e16840
	ctx.lr = 0x825FD174;
	sub_82E16840(ctx, base);
	// 825FD174: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD178: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FD17C: 4881A1E5  bl 0x82e17360
	ctx.lr = 0x825FD180;
	sub_82E17360(ctx, base);
	// 825FD180: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FD184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD188: 3BEB51D0  addi r31, r11, 0x51d0
	ctx.r[31].s64 = ctx.r[11].s64 + 20944;
	// 825FD18C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD190: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FD194: 487FC39D  bl 0x82df9530
	ctx.lr = 0x825FD198;
	sub_82DF9530(ctx, base);
	// 825FD198: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FD19C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825FD1A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FD1A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD1A8: 4881A5A1  bl 0x82e17748
	ctx.lr = 0x825FD1AC;
	sub_82E17748(ctx, base);
	// 825FD1AC: 897E0160  lbz r11, 0x160(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(352 as u32) ) } as u64;
	// 825FD1B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD1B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD1B8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FD1BC: 41820050  beq 0x825fd20c
	if ctx.cr[0].eq {
	pc = 0x825FD20C; continue 'dispatch;
	}
	// 825FD1C0: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FD1C4: 487FC36D  bl 0x82df9530
	ctx.lr = 0x825FD1C8;
	sub_82DF9530(ctx, base);
	// 825FD1C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD1CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825FD1D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD1D4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD1D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825FD1DC: C02B175C  lfs f1, 0x175c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5980 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FD1E0: 3BCB175C  addi r30, r11, 0x175c
	ctx.r[30].s64 = ctx.r[11].s64 + 5980;
	// 825FD1E4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD1E8: 488197C9  bl 0x82e169b0
	ctx.lr = 0x825FD1EC;
	sub_82E169B0(ctx, base);
	// 825FD1EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD1F4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FD1F8: 487FC339  bl 0x82df9530
	ctx.lr = 0x825FD1FC;
	sub_82DF9530(ctx, base);
	// 825FD1FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FD200: C03E0024  lfs f1, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FD204: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD208: 48000060  b 0x825fd268
	pc = 0x825FD268; continue 'dispatch;
	// 825FD20C: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FD210: 487FC321  bl 0x82df9530
	ctx.lr = 0x825FD214;
	sub_82DF9530(ctx, base);
	// 825FD214: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD218: 815E015C  lwz r10, 0x15c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 825FD21C: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD220: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD224: 3BAB175C  addi r29, r11, 0x175c
	ctx.r[29].s64 = ctx.r[11].s64 + 5980;
	// 825FD228: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825FD22C: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 825FD230: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825FD234: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FD238: 7C2B542E  lfsx f1, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FD23C: 48819775  bl 0x82e169b0
	ctx.lr = 0x825FD240;
	sub_82E169B0(ctx, base);
	// 825FD240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD244: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD248: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FD24C: 487FC2E5  bl 0x82df9530
	ctx.lr = 0x825FD250;
	sub_82DF9530(ctx, base);
	// 825FD250: 817E015C  lwz r11, 0x15c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(348 as u32) ) } as u64;
	// 825FD254: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825FD258: 393D0018  addi r9, r29, 0x18
	ctx.r[9].s64 = ctx.r[29].s64 + 24;
	// 825FD25C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825FD260: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD264: 7C2B4C2E  lfsx f1, r11, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FD268: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FD26C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825FD270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD274: 4881973D  bl 0x82e169b0
	ctx.lr = 0x825FD278;
	sub_82E169B0(ctx, base);
	// 825FD278: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FD27C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD280: 419A0008  beq cr6, 0x825fd288
	if ctx.cr[6].eq {
	pc = 0x825FD288; continue 'dispatch;
	}
	// 825FD284: 4BCC360D  bl 0x822c0890
	ctx.lr = 0x825FD288;
	sub_822C0890(ctx, base);
	// 825FD288: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825FD28C: 48BAAF2C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FD290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FD290 size=176
    let mut pc: u32 = 0x825FD290;
    'dispatch: loop {
        match pc {
            0x825FD290 => {
    //   block [0x825FD290..0x825FD340)
	// 825FD290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FD294: 48BAAED9  bl 0x831a816c
	ctx.lr = 0x825FD298;
	sub_831A8130(ctx, base);
	// 825FD298: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FD29C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD2A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FD2A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825FD2A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD2AC: 388B18A0  addi r4, r11, 0x18a0
	ctx.r[4].s64 = ctx.r[11].s64 + 6304;
	// 825FD2B0: 38A002B9  li r5, 0x2b9
	ctx.r[5].s64 = 697;
	// 825FD2B4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 825FD2B8: 487F5131  bl 0x82df23e8
	ctx.lr = 0x825FD2BC;
	sub_82DF23E8(ctx, base);
	// 825FD2BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FD2C0: 41820010  beq 0x825fd2d0
	if ctx.cr[0].eq {
	pc = 0x825FD2D0; continue 'dispatch;
	}
	// 825FD2C4: 4BFFFCAD  bl 0x825fcf70
	ctx.lr = 0x825FD2C8;
	sub_825FCF70(ctx, base);
	// 825FD2C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FD2CC: 48000008  b 0x825fd2d4
	pc = 0x825FD2D4; continue 'dispatch;
	// 825FD2D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FD2D4: 3BDF00F8  addi r30, r31, 0xf8
	ctx.r[30].s64 = ctx.r[31].s64 + 248;
	// 825FD2D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD2DC: 4BFFE51D  bl 0x825fb7f8
	ctx.lr = 0x825FD2E0;
	sub_825FB7F8(ctx, base);
	// 825FD2E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FD2E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD2E8: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825FD2EC: 48819555  bl 0x82e16840
	ctx.lr = 0x825FD2F0;
	sub_82E16840(ctx, base);
	// 825FD2F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD2F4: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825FD2F8: 4881A069  bl 0x82e17360
	ctx.lr = 0x825FD2FC;
	sub_82E17360(ctx, base);
	// 825FD2FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FD300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD304: 388B51D0  addi r4, r11, 0x51d0
	ctx.r[4].s64 = ctx.r[11].s64 + 20944;
	// 825FD308: 83DF00F8  lwz r30, 0xf8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825FD30C: 487FC225  bl 0x82df9530
	ctx.lr = 0x825FD310;
	sub_82DF9530(ctx, base);
	// 825FD310: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FD314: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825FD318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD31C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD320: 4881A429  bl 0x82e17748
	ctx.lr = 0x825FD324;
	sub_82E17748(ctx, base);
	// 825FD324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FD328: 809F0108  lwz r4, 0x108(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 825FD32C: 807F00F8  lwz r3, 0xf8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) } as u64;
	// 825FD330: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FD334: 48841505  bl 0x82e3e838
	ctx.lr = 0x825FD338;
	sub_82E3E838(ctx, base);
	// 825FD338: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FD33C: 48BAAE80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FD340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FD340 size=76
    let mut pc: u32 = 0x825FD340;
    'dispatch: loop {
        match pc {
            0x825FD340 => {
    //   block [0x825FD340..0x825FD38C)
	// 825FD340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FD344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FD348: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FD34C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FD350: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FD354: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FD358: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FD35C: 4BFFFC8D  bl 0x825fcfe8
	ctx.lr = 0x825FD360;
	sub_825FCFE8(ctx, base);
	// 825FD360: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FD364: 4182000C  beq 0x825fd370
	if ctx.cr[0].eq {
	pc = 0x825FD370; continue 'dispatch;
	}
	// 825FD368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD36C: 487F506D  bl 0x82df23d8
	ctx.lr = 0x825FD370;
	sub_82DF23D8(ctx, base);
	// 825FD370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FD378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FD37C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FD380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FD384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FD388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FD390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FD390 size=2012
    let mut pc: u32 = 0x825FD390;
    'dispatch: loop {
        match pc {
            0x825FD390 => {
    //   block [0x825FD390..0x825FDB6C)
	// 825FD390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FD394: 48BAADC5  bl 0x831a8158
	ctx.lr = 0x825FD398;
	sub_831A8130(ctx, base);
	// 825FD398: DBA1FFA0  stfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[29].u64 ) };
	// 825FD39C: DBC1FFA8  stfd f30, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 825FD3A0: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825FD3A4: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FD3A8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825FD3AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FD3B0: 7F78DB78  mr r24, r27
	ctx.r[24].u64 = ctx.r[27].u64;
	// 825FD3B4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 825FD3B8: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 825FD3BC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825FD3C0: 4BF14619  bl 0x825119d8
	ctx.lr = 0x825FD3C4;
	sub_825119D8(ctx, base);
	// 825FD3C4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FD3C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD3CC: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825FD3D0: 487F6639  bl 0x82df3a08
	ctx.lr = 0x825FD3D4;
	sub_82DF3A08(ctx, base);
	// 825FD3D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FD3D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FD3DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825FD3E0: 4BF0B3A1  bl 0x82508780
	ctx.lr = 0x825FD3E4;
	sub_82508780(ctx, base);
	// 825FD3E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD3E8: 487F6041  bl 0x82df3428
	ctx.lr = 0x825FD3EC;
	sub_82DF3428(ctx, base);
	// 825FD3EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FD3F0: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 825FD3F4: 409A0008  bne cr6, 0x825fd3fc
	if !ctx.cr[6].eq {
	pc = 0x825FD3FC; continue 'dispatch;
	}
	// 825FD3F8: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 825FD3FC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FD400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD404: 808BD05C  lwz r4, -0x2fa4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12196 as u32) ) } as u64;
	// 825FD408: 487F6601  bl 0x82df3a08
	ctx.lr = 0x825FD40C;
	sub_82DF3A08(ctx, base);
	// 825FD40C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825FD410: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FD414: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825FD418: 4BF0B3D9  bl 0x825087f0
	ctx.lr = 0x825FD41C;
	sub_825087F0(ctx, base);
	// 825FD41C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD420: 487F6009  bl 0x82df3428
	ctx.lr = 0x825FD424;
	sub_82DF3428(ctx, base);
	// 825FD424: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FD428: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 825FD42C: 409A0008  bne cr6, 0x825fd434
	if !ctx.cr[6].eq {
	pc = 0x825FD434; continue 'dispatch;
	}
	// 825FD430: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 825FD434: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FD438: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD43C: 808BD068  lwz r4, -0x2f98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12184 as u32) ) } as u64;
	// 825FD440: 487F65C9  bl 0x82df3a08
	ctx.lr = 0x825FD444;
	sub_82DF3A08(ctx, base);
	// 825FD444: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825FD448: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FD44C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825FD450: 4BF0B3A1  bl 0x825087f0
	ctx.lr = 0x825FD454;
	sub_825087F0(ctx, base);
	// 825FD454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD458: 487F5FD1  bl 0x82df3428
	ctx.lr = 0x825FD45C;
	sub_82DF3428(ctx, base);
	// 825FD45C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FD460: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD464: 4882D685  bl 0x82e2aae8
	ctx.lr = 0x825FD468;
	sub_82E2AAE8(ctx, base);
	// 825FD468: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FD46C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD470: 48842A99  bl 0x82e3ff08
	ctx.lr = 0x825FD474;
	sub_82E3FF08(ctx, base);
	// 825FD474: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FD478: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD47C: 3B8BF830  addi r28, r11, -0x7d0
	ctx.r[28].s64 = ctx.r[11].s64 + -2000;
	// 825FD480: 808BF830  lwz r4, -0x7d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2000 as u32) ) } as u64;
	// 825FD484: 487F6585  bl 0x82df3a08
	ctx.lr = 0x825FD488;
	sub_82DF3A08(ctx, base);
	// 825FD488: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD48C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FD490: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FD494: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825FD498: 488319D9  bl 0x82e2ee70
	ctx.lr = 0x825FD49C;
	sub_82E2EE70(ctx, base);
	// 825FD49C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD4A0: 487F5F89  bl 0x82df3428
	ctx.lr = 0x825FD4A4;
	sub_82DF3428(ctx, base);
	// 825FD4A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD4A8: 3B4B18A0  addi r26, r11, 0x18a0
	ctx.r[26].s64 = ctx.r[11].s64 + 6304;
	// 825FD4AC: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 825FD4B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FD4B4: 419A0434  beq cr6, 0x825fd8e8
	if ctx.cr[6].eq {
	pc = 0x825FD8E8; continue 'dispatch;
	}
	// 825FD4B8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825FD4BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD4C0: 38A000A3  li r5, 0xa3
	ctx.r[5].s64 = 163;
	// 825FD4C4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825FD4C8: 487F4F21  bl 0x82df23e8
	ctx.lr = 0x825FD4CC;
	sub_82DF23E8(ctx, base);
	// 825FD4CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FD4D0: 41820018  beq 0x825fd4e8
	if ctx.cr[0].eq {
	pc = 0x825FD4E8; continue 'dispatch;
	}
	// 825FD4D4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FD4D8: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825FD4DC: 48815C15  bl 0x82e130f0
	ctx.lr = 0x825FD4E0;
	sub_82E130F0(ctx, base);
	// 825FD4E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FD4E4: 48000008  b 0x825fd4ec
	pc = 0x825FD4EC; continue 'dispatch;
	// 825FD4E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FD4EC: 3BDF012C  addi r30, r31, 0x12c
	ctx.r[30].s64 = ctx.r[31].s64 + 300;
	// 825FD4F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD4F4: 4BCE485D  bl 0x822e1d50
	ctx.lr = 0x825FD4F8;
	sub_822E1D50(ctx, base);
	// 825FD4F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD4FC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825FD500: 83BF012C  lwz r29, 0x12c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) } as u64;
	// 825FD504: 4BF14C15  bl 0x82512118
	ctx.lr = 0x825FD508;
	sub_82512118(ctx, base);
	// 825FD508: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FD50C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD510: 48815921  bl 0x82e12e30
	ctx.lr = 0x825FD514;
	sub_82E12E30(ctx, base);
	// 825FD514: 806100E4  lwz r3, 0xe4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825FD518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD51C: 419A0008  beq cr6, 0x825fd524
	if ctx.cr[6].eq {
	pc = 0x825FD524; continue 'dispatch;
	}
	// 825FD520: 4BCC3371  bl 0x822c0890
	ctx.lr = 0x825FD524;
	sub_822C0890(ctx, base);
	// 825FD524: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825FD528: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD52C: 38A000A6  li r5, 0xa6
	ctx.r[5].s64 = 166;
	// 825FD530: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825FD534: 487F4EB5  bl 0x82df23e8
	ctx.lr = 0x825FD538;
	sub_82DF23E8(ctx, base);
	// 825FD538: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FD53C: 41820014  beq 0x825fd550
	if ctx.cr[0].eq {
	pc = 0x825FD550; continue 'dispatch;
	}
	// 825FD540: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 825FD544: 4881934D  bl 0x82e16890
	ctx.lr = 0x825FD548;
	sub_82E16890(ctx, base);
	// 825FD548: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FD54C: 48000008  b 0x825fd554
	pc = 0x825FD554; continue 'dispatch;
	// 825FD550: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FD554: 3BBF00E8  addi r29, r31, 0xe8
	ctx.r[29].s64 = ctx.r[31].s64 + 232;
	// 825FD558: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FD55C: 4BD5FE15  bl 0x8235d370
	ctx.lr = 0x825FD560;
	sub_8235D370(ctx, base);
	// 825FD560: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FD564: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FD56C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FD570: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FD574: 419A0024  beq cr6, 0x825fd598
	if ctx.cr[6].eq {
	pc = 0x825FD598; continue 'dispatch;
	}
	// 825FD578: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FD57C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FD580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD584: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FD588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FD58C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FD590: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD594: 4082FFE8  bne 0x825fd57c
	if !ctx.cr[0].eq {
	pc = 0x825FD57C; continue 'dispatch;
	}
	// 825FD598: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FD59C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD5A0: 48817B11  bl 0x82e150b0
	ctx.lr = 0x825FD5A4;
	sub_82E150B0(ctx, base);
	// 825FD5A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FD5A8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD5AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FD5B0: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 825FD5B4: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825FD5B8: 419A0024  beq cr6, 0x825fd5dc
	if ctx.cr[6].eq {
	pc = 0x825FD5DC; continue 'dispatch;
	}
	// 825FD5BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FD5C0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FD5C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD5C8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FD5CC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FD5D0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FD5D4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD5D8: 4082FFE8  bne 0x825fd5c0
	if !ctx.cr[0].eq {
	pc = 0x825FD5C0; continue 'dispatch;
	}
	// 825FD5DC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FD5E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FD5E4: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 825FD5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD5EC: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825FD5F0: 4BF13409  bl 0x825109f8
	ctx.lr = 0x825FD5F4;
	sub_825109F8(ctx, base);
	// 825FD5F4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825FD5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD5FC: 419A0008  beq cr6, 0x825fd604
	if ctx.cr[6].eq {
	pc = 0x825FD604; continue 'dispatch;
	}
	// 825FD600: 4BCC3291  bl 0x822c0890
	ctx.lr = 0x825FD604;
	sub_822C0890(ctx, base);
	// 825FD604: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD60C: 388B1AEC  addi r4, r11, 0x1aec
	ctx.r[4].s64 = ctx.r[11].s64 + 6892;
	// 825FD610: 487F63F9  bl 0x82df3a08
	ctx.lr = 0x825FD614;
	sub_82DF3A08(ctx, base);
	// 825FD614: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD618: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FD61C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FD620: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825FD624: 4883117D  bl 0x82e2e7a0
	ctx.lr = 0x825FD628;
	sub_82E2E7A0(ctx, base);
	// 825FD628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD62C: 487F5DFD  bl 0x82df3428
	ctx.lr = 0x825FD630;
	sub_82DF3428(ctx, base);
	// 825FD630: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD634: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD638: 388B1AD4  addi r4, r11, 0x1ad4
	ctx.r[4].s64 = ctx.r[11].s64 + 6868;
	// 825FD63C: 487F63CD  bl 0x82df3a08
	ctx.lr = 0x825FD640;
	sub_82DF3A08(ctx, base);
	// 825FD640: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD644: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FD648: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FD64C: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825FD650: 48843419  bl 0x82e40a68
	ctx.lr = 0x825FD654;
	sub_82E40A68(ctx, base);
	// 825FD654: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FD658: 395F0108  addi r10, r31, 0x108
	ctx.r[10].s64 = ctx.r[31].s64 + 264;
	// 825FD65C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825FD660: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825FD664: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD668: 917F0108  stw r11, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u32 ) };
	// 825FD66C: 4BCC6DF5  bl 0x822c4460
	ctx.lr = 0x825FD670;
	sub_822C4460(ctx, base);
	// 825FD670: 806100FC  lwz r3, 0xfc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 825FD674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD678: 419A0008  beq cr6, 0x825fd680
	if ctx.cr[6].eq {
	pc = 0x825FD680; continue 'dispatch;
	}
	// 825FD67C: 4BCC3215  bl 0x822c0890
	ctx.lr = 0x825FD680;
	sub_822C0890(ctx, base);
	// 825FD680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD684: 487F5DA5  bl 0x82df3428
	ctx.lr = 0x825FD688;
	sub_82DF3428(ctx, base);
	// 825FD688: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 825FD68C: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825FD690: 394AD290  addi r10, r10, -0x2d70
	ctx.r[10].s64 = ctx.r[10].s64 + -11632;
	// 825FD694: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825FD698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FD69C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FD6A0: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825FD6A4: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825FD6A8: 914100A8  stw r10, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	// 825FD6AC: 419A0024  beq cr6, 0x825fd6d0
	if ctx.cr[6].eq {
	pc = 0x825FD6D0; continue 'dispatch;
	}
	// 825FD6B0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FD6B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FD6B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD6BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FD6C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FD6C4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FD6C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD6CC: 4082FFE8  bne 0x825fd6b4
	if !ctx.cr[0].eq {
	pc = 0x825FD6B4; continue 'dispatch;
	}
	// 825FD6D0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825FD6D4: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 825FD6D8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825FD6DC: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 825FD6E0: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 825FD6E4: 4BFFF7AD  bl 0x825fce90
	ctx.lr = 0x825FD6E8;
	sub_825FCE90(ctx, base);
	// 825FD6E8: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 825FD6EC: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 825FD6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD6F4: 4BF1374D  bl 0x82510e40
	ctx.lr = 0x825FD6F8;
	sub_82510E40(ctx, base);
	// 825FD6F8: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825FD6FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD700: 419A0008  beq cr6, 0x825fd708
	if ctx.cr[6].eq {
	pc = 0x825FD708; continue 'dispatch;
	}
	// 825FD704: 4BCC318D  bl 0x822c0890
	ctx.lr = 0x825FD708;
	sub_822C0890(ctx, base);
	// 825FD708: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825FD70C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD710: 419A0008  beq cr6, 0x825fd718
	if ctx.cr[6].eq {
	pc = 0x825FD718; continue 'dispatch;
	}
	// 825FD714: 4BCC317D  bl 0x822c0890
	ctx.lr = 0x825FD718;
	sub_822C0890(ctx, base);
	// 825FD718: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD720: 388B1AA4  addi r4, r11, 0x1aa4
	ctx.r[4].s64 = ctx.r[11].s64 + 6820;
	// 825FD724: 487F62E5  bl 0x82df3a08
	ctx.lr = 0x825FD728;
	sub_82DF3A08(ctx, base);
	// 825FD728: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD72C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FD730: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FD734: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825FD738: 48831069  bl 0x82e2e7a0
	ctx.lr = 0x825FD73C;
	sub_82E2E7A0(ctx, base);
	// 825FD73C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD740: 487F5CE9  bl 0x82df3428
	ctx.lr = 0x825FD744;
	sub_82DF3428(ctx, base);
	// 825FD744: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD74C: 388B1A70  addi r4, r11, 0x1a70
	ctx.r[4].s64 = ctx.r[11].s64 + 6768;
	// 825FD750: 487F62B9  bl 0x82df3a08
	ctx.lr = 0x825FD754;
	sub_82DF3A08(ctx, base);
	// 825FD754: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD758: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FD75C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FD760: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 825FD764: 48843305  bl 0x82e40a68
	ctx.lr = 0x825FD768;
	sub_82E40A68(ctx, base);
	// 825FD768: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FD76C: 395F0110  addi r10, r31, 0x110
	ctx.r[10].s64 = ctx.r[31].s64 + 272;
	// 825FD770: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825FD774: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825FD778: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FD77C: 917F0110  stw r11, 0x110(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825FD780: 4BCC6CE1  bl 0x822c4460
	ctx.lr = 0x825FD784;
	sub_822C4460(ctx, base);
	// 825FD784: 806100EC  lwz r3, 0xec(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825FD788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD78C: 419A0008  beq cr6, 0x825fd794
	if ctx.cr[6].eq {
	pc = 0x825FD794; continue 'dispatch;
	}
	// 825FD790: 4BCC3101  bl 0x822c0890
	ctx.lr = 0x825FD794;
	sub_822C0890(ctx, base);
	// 825FD794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD798: 487F5C91  bl 0x82df3428
	ctx.lr = 0x825FD79C;
	sub_82DF3428(ctx, base);
	// 825FD79C: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 825FD7A0: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825FD7A4: 394AD060  addi r10, r10, -0x2fa0
	ctx.r[10].s64 = ctx.r[10].s64 + -12192;
	// 825FD7A8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825FD7AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FD7B0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FD7B4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 825FD7B8: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 825FD7BC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825FD7C0: 419A0024  beq cr6, 0x825fd7e4
	if ctx.cr[6].eq {
	pc = 0x825FD7E4; continue 'dispatch;
	}
	// 825FD7C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FD7C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FD7CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD7D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FD7D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FD7D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FD7DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD7E0: 4082FFE8  bne 0x825fd7c8
	if !ctx.cr[0].eq {
	pc = 0x825FD7C8; continue 'dispatch;
	}
	// 825FD7E4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825FD7E8: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 825FD7EC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825FD7F0: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 825FD7F4: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 825FD7F8: 4BFFF699  bl 0x825fce90
	ctx.lr = 0x825FD7FC;
	sub_825FCE90(ctx, base);
	// 825FD7FC: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 825FD800: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825FD804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD808: 4BF13639  bl 0x82510e40
	ctx.lr = 0x825FD80C;
	sub_82510E40(ctx, base);
	// 825FD80C: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825FD810: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD814: 419A0008  beq cr6, 0x825fd81c
	if ctx.cr[6].eq {
	pc = 0x825FD81C; continue 'dispatch;
	}
	// 825FD818: 4BCC3079  bl 0x822c0890
	ctx.lr = 0x825FD81C;
	sub_822C0890(ctx, base);
	// 825FD81C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825FD820: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD824: 419A0008  beq cr6, 0x825fd82c
	if ctx.cr[6].eq {
	pc = 0x825FD82C; continue 'dispatch;
	}
	// 825FD828: 4BCC3069  bl 0x822c0890
	ctx.lr = 0x825FD82C;
	sub_822C0890(ctx, base);
	// 825FD82C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FD830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD834: 388B1A40  addi r4, r11, 0x1a40
	ctx.r[4].s64 = ctx.r[11].s64 + 6720;
	// 825FD838: 487F61D1  bl 0x82df3a08
	ctx.lr = 0x825FD83C;
	sub_82DF3A08(ctx, base);
	// 825FD83C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD840: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FD844: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FD848: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FD84C: 48830F55  bl 0x82e2e7a0
	ctx.lr = 0x825FD850;
	sub_82E2E7A0(ctx, base);
	// 825FD850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FD854: 487F5BD5  bl 0x82df3428
	ctx.lr = 0x825FD858;
	sub_82DF3428(ctx, base);
	// 825FD858: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 825FD85C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FD860: 394AD100  addi r10, r10, -0x2f00
	ctx.r[10].s64 = ctx.r[10].s64 + -12032;
	// 825FD864: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 825FD868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FD86C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FD870: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 825FD874: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825FD878: 914100A0  stw r10, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 825FD87C: 419A0024  beq cr6, 0x825fd8a0
	if ctx.cr[6].eq {
	pc = 0x825FD8A0; continue 'dispatch;
	}
	// 825FD880: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FD884: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FD888: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD88C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FD890: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FD894: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FD898: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FD89C: 4082FFE8  bne 0x825fd884
	if !ctx.cr[0].eq {
	pc = 0x825FD884; continue 'dispatch;
	}
	// 825FD8A0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825FD8A4: 93E100B8  stw r31, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u32 ) };
	// 825FD8A8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825FD8AC: E8A100B8  ld r5, 0xb8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	// 825FD8B0: 936100C0  stw r27, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 825FD8B4: 4BFFF5DD  bl 0x825fce90
	ctx.lr = 0x825FD8B8;
	sub_825FCE90(ctx, base);
	// 825FD8B8: 38A100C0  addi r5, r1, 0xc0
	ctx.r[5].s64 = ctx.r[1].s64 + 192;
	// 825FD8BC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825FD8C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FD8C4: 4BF1357D  bl 0x82510e40
	ctx.lr = 0x825FD8C8;
	sub_82510E40(ctx, base);
	// 825FD8C8: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825FD8CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD8D0: 419A0008  beq cr6, 0x825fd8d8
	if ctx.cr[6].eq {
	pc = 0x825FD8D8; continue 'dispatch;
	}
	// 825FD8D4: 4BCC2FBD  bl 0x822c0890
	ctx.lr = 0x825FD8D8;
	sub_822C0890(ctx, base);
	// 825FD8D8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FD8DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD8E0: 419A0008  beq cr6, 0x825fd8e8
	if ctx.cr[6].eq {
	pc = 0x825FD8E8; continue 'dispatch;
	}
	// 825FD8E4: 4BCC2FAD  bl 0x822c0890
	ctx.lr = 0x825FD8E8;
	sub_822C0890(ctx, base);
	// 825FD8E8: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825FD8EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FD8F0: 419A0008  beq cr6, 0x825fd8f8
	if ctx.cr[6].eq {
	pc = 0x825FD8F8; continue 'dispatch;
	}
	// 825FD8F4: 4BCC2F9D  bl 0x822c0890
	ctx.lr = 0x825FD8F8;
	sub_822C0890(ctx, base);
	// 825FD8F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FD8FC: 4882D205  bl 0x82e2ab00
	ctx.lr = 0x825FD900;
	sub_82E2AB00(ctx, base);
	// 825FD900: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FD904: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FD908: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825FD90C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 825FD910: 9B61011C  stb r27, 0x11c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[27].u8 ) };
	// 825FD914: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825FD918: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825FD91C: 38E71A04  addi r7, r7, 0x1a04
	ctx.r[7].s64 = ctx.r[7].s64 + 6660;
	// 825FD920: C3AA08A8  lfs f29, 0x8a8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825FD924: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FD928: 93C1010C  stw r30, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[30].u32 ) };
	// 825FD92C: C3C89534  lfs f30, -0x6acc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825FD930: 90E10100  stw r7, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[7].u32 ) };
	// 825FD934: D3A10108  stfs f29, 0x108(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 825FD938: 91610104  stw r11, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 825FD93C: D3E10110  stfs f31, 0x110(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 825FD940: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 825FD944: D3C10114  stfs f30, 0x114(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 825FD948: D3C10118  stfs f30, 0x118(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 825FD94C: 48800F7D  bl 0x82dfe8c8
	ctx.lr = 0x825FD950;
	sub_82DFE8C8(ctx, base);
	// 825FD950: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 825FD954: 48800F75  bl 0x82dfe8c8
	ctx.lr = 0x825FD958;
	sub_82DFE8C8(ctx, base);
	// 825FD958: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 825FD95C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FD960: D3A10138  stfs f29, 0x138(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 825FD964: D3E10140  stfs f31, 0x140(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FD968: 93C1013C  stw r30, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[30].u32 ) };
	// 825FD96C: 394A1A0C  addi r10, r10, 0x1a0c
	ctx.r[10].s64 = ctx.r[10].s64 + 6668;
	// 825FD970: D3C10144  stfs f30, 0x144(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), tmp.u32 ) };
	// 825FD974: D3C10148  stfs f30, 0x148(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825FD978: 9B61014C  stb r27, 0x14c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[27].u8 ) };
	// 825FD97C: 91410130  stw r10, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[10].u32 ) };
	// 825FD980: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 825FD984: 91610134  stw r11, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 825FD988: 48800F41  bl 0x82dfe8c8
	ctx.lr = 0x825FD98C;
	sub_82DFE8C8(ctx, base);
	// 825FD98C: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825FD990: 48800F39  bl 0x82dfe8c8
	ctx.lr = 0x825FD994;
	sub_82DFE8C8(ctx, base);
	// 825FD994: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825FD998: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FD99C: 38A000F3  li r5, 0xf3
	ctx.r[5].s64 = 243;
	// 825FD9A0: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 825FD9A4: 487F4A45  bl 0x82df23e8
	ctx.lr = 0x825FD9A8;
	sub_82DF23E8(ctx, base);
	// 825FD9A8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825FD9AC: 4182003C  beq 0x825fd9e8
	if ctx.cr[0].eq {
	pc = 0x825FD9E8; continue 'dispatch;
	}
	// 825FD9B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FD9B4: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FD9B8: 487F6051  bl 0x82df3a08
	ctx.lr = 0x825FD9BC;
	sub_82DF3A08(ctx, base);
	// 825FD9BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FD9C0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825FD9C4: 3B000003  li r24, 3
	ctx.r[24].s64 = 3;
	// 825FD9C8: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 825FD9CC: 4BF11AFD  bl 0x8250f4c8
	ctx.lr = 0x825FD9D0;
	sub_8250F4C8(ctx, base);
	// 825FD9D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FD9D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD9D8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825FD9DC: 485B6225  bl 0x82bb3c00
	ctx.lr = 0x825FD9E0;
	sub_82BB3C00(ctx, base);
	// 825FD9E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FD9E4: 48000008  b 0x825fd9ec
	pc = 0x825FD9EC; continue 'dispatch;
	// 825FD9E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FD9EC: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 825FD9F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FD9F4: 4BD5F9ED  bl 0x8235d3e0
	ctx.lr = 0x825FD9F8;
	sub_8235D3E0(ctx, base);
	// 825FD9F8: 570B07BD  rlwinm. r11, r24, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FD9FC: 41820010  beq 0x825fda0c
	if ctx.cr[0].eq {
	pc = 0x825FDA0C; continue 'dispatch;
	}
	// 825FDA00: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 825FDA04: 571807FA  rlwinm r24, r24, 0, 0x1f, 0x1d
	ctx.r[24].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 825FDA08: 487F4289  bl 0x82df1c90
	ctx.lr = 0x825FDA0C;
	sub_82DF1C90(ctx, base);
	// 825FDA0C: 570B07FF  clrlwi. r11, r24, 0x1f
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FDA10: 4182000C  beq 0x825fda1c
	if ctx.cr[0].eq {
	pc = 0x825FDA1C; continue 'dispatch;
	}
	// 825FDA14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FDA18: 487F5A11  bl 0x82df3428
	ctx.lr = 0x825FDA1C;
	sub_82DF3428(ctx, base);
	// 825FDA1C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825FDA20: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDA24: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 825FDA28: 485B7539  bl 0x82bb4f60
	ctx.lr = 0x825FDA2C;
	sub_82BB4F60(ctx, base);
	// 825FDA2C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FDA30: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDA34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FDA38: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825FDA3C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 825FDA40: 419A0024  beq cr6, 0x825fda64
	if ctx.cr[6].eq {
	pc = 0x825FDA64; continue 'dispatch;
	}
	// 825FDA44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FDA48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FDA4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FDA50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FDA54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FDA58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FDA5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FDA60: 4082FFE8  bne 0x825fda48
	if !ctx.cr[0].eq {
	pc = 0x825FDA48; continue 'dispatch;
	}
	// 825FDA64: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825FDA68: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 825FDA6C: 48817505  bl 0x82e14f70
	ctx.lr = 0x825FDA70;
	sub_82E14F70(ctx, base);
	// 825FDA70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825FDA74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FDA78: 419A0008  beq cr6, 0x825fda80
	if ctx.cr[6].eq {
	pc = 0x825FDA80; continue 'dispatch;
	}
	// 825FDA7C: 4BCC2E15  bl 0x822c0890
	ctx.lr = 0x825FDA80;
	sub_822C0890(ctx, base);
	// 825FDA80: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDA84: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825FDA88: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825FDA8C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 825FDA90: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825FDA94: 488A2C9D  bl 0x82ea0730
	ctx.lr = 0x825FDA98;
	sub_82EA0730(ctx, base);
	// 825FDA98: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 825FDA9C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FDAA0: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 825FDAA4: C02A1750  lfs f1, 0x1750(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5968 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FDAA8: 4891C749  bl 0x82f1a1f0
	ctx.lr = 0x825FDAAC;
	sub_82F1A1F0(ctx, base);
	// 825FDAAC: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 825FDAB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FDAB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FDAB8: 388B3E10  addi r4, r11, 0x3e10
	ctx.r[4].s64 = ctx.r[11].s64 + 15888;
	// 825FDABC: 487FBA75  bl 0x82df9530
	ctx.lr = 0x825FDAC0;
	sub_82DF9530(ctx, base);
	// 825FDAC0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FDAC4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825FDAC8: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 825FDACC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FDAD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDAD4: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 825FDAD8: 4BF15611  bl 0x825130e8
	ctx.lr = 0x825FDADC;
	sub_825130E8(ctx, base);
	// 825FDADC: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 825FDAE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDAE4: 4BF142B5  bl 0x82511d98
	ctx.lr = 0x825FDAE8;
	sub_82511D98(ctx, base);
	// 825FDAE8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825FDAEC: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 825FDAF0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 825FDAF4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FDAF8: C04B29EC  lfs f2, 0x29ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10732 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FDAFC: 4887EC85  bl 0x82e7c780
	ctx.lr = 0x825FDB00;
	sub_82E7C780(ctx, base);
	// 825FDB00: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825FDB04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FDB08: 38A00106  li r5, 0x106
	ctx.r[5].s64 = 262;
	// 825FDB0C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825FDB10: 487F48D9  bl 0x82df23e8
	ctx.lr = 0x825FDB14;
	sub_82DF23E8(ctx, base);
	// 825FDB14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FDB18: 41820014  beq 0x825fdb2c
	if ctx.cr[0].eq {
	pc = 0x825FDB2C; continue 'dispatch;
	}
	// 825FDB1C: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 825FDB20: 488155D1  bl 0x82e130f0
	ctx.lr = 0x825FDB24;
	sub_82E130F0(ctx, base);
	// 825FDB24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FDB28: 48000008  b 0x825fdb30
	pc = 0x825FDB30; continue 'dispatch;
	// 825FDB2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825FDB30: 387F0124  addi r3, r31, 0x124
	ctx.r[3].s64 = ctx.r[31].s64 + 292;
	// 825FDB34: 4BCE421D  bl 0x822e1d50
	ctx.lr = 0x825FDB38;
	sub_822E1D50(ctx, base);
	// 825FDB38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FDB3C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825FDB40: 80BF0124  lwz r5, 0x124(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 825FDB44: 4BF0B05D  bl 0x82508ba0
	ctx.lr = 0x825FDB48;
	sub_82508BA0(ctx, base);
	// 825FDB48: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FDB4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FDB50: 419A0008  beq cr6, 0x825fdb58
	if ctx.cr[6].eq {
	pc = 0x825FDB58; continue 'dispatch;
	}
	// 825FDB54: 4BCEA715  bl 0x822e8268
	ctx.lr = 0x825FDB58;
	sub_822E8268(ctx, base);
	// 825FDB58: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 825FDB5C: CBA1FFA0  lfd f29, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825FDB60: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825FDB64: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825FDB68: 48BAA640  b 0x831a81a8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FDB70 size=168
    let mut pc: u32 = 0x825FDB70;
    'dispatch: loop {
        match pc {
            0x825FDB70 => {
    //   block [0x825FDB70..0x825FDC18)
	// 825FDB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDB78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FDB7C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDB80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FDB84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FDB88: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825FDB8C: C1BF0130  lfs f13, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FDB90: C00B1B00  lfs f0, 0x1b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDB94: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825FDB98: C19F0140  lfs f12, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FDB9C: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDBA0: EDAD607C  fnmsubs f13, f13, f1, f12
	ctx.f[13].f64 = -(((ctx.f[13].f64 * ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 825FDBA4: D1BF0140  stfs f13, 0x140(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FDBA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FDBAC: 40980020  bge cr6, 0x825fdbcc
	if !ctx.cr[6].lt {
	pc = 0x825FDBCC; continue 'dispatch;
	}
	// 825FDBB0: 897F013B  lbz r11, 0x13b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(315 as u32) ) } as u64;
	// 825FDBB4: D01F0140  stfs f0, 0x140(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FDBB8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FDBBC: 41820010  beq 0x825fdbcc
	if ctx.cr[0].eq {
	pc = 0x825FDBCC; continue 'dispatch;
	}
	// 825FDBC0: 4BF140C9  bl 0x82511c88
	ctx.lr = 0x825FDBC4;
	sub_82511C88(ctx, base);
	// 825FDBC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FDBC8: 997F013B  stb r11, 0x13b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(315 as u32), ctx.r[11].u8 ) };
	// 825FDBCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FDBD0: C01F0140  lfs f0, 0x140(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDBD4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825FDBD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FDBDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FDBE0: 83FF0110  lwz r31, 0x110(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825FDBE4: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDBE8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825FDBEC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825FDBF0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825FDBF4: 4887E3E5  bl 0x82e7bfd8
	ctx.lr = 0x825FDBF8;
	sub_82E7BFD8(ctx, base);
	// 825FDBF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FDBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDC00: 48815661  bl 0x82e13260
	ctx.lr = 0x825FDC04;
	sub_82E13260(ctx, base);
	// 825FDC04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825FDC08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FDC0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FDC10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FDC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FDC18 size=172
    let mut pc: u32 = 0x825FDC18;
    'dispatch: loop {
        match pc {
            0x825FDC18 => {
    //   block [0x825FDC18..0x825FDCC4)
	// 825FDC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDC20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FDC24: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825FDC28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDC2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FDC30: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825FDC34: 897F013B  lbz r11, 0x13b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(315 as u32) ) } as u64;
	// 825FDC38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FDC3C: 40820010  bne 0x825fdc4c
	if !ctx.cr[0].eq {
	pc = 0x825FDC4C; continue 'dispatch;
	}
	// 825FDC40: 4BF14069  bl 0x82511ca8
	ctx.lr = 0x825FDC44;
	sub_82511CA8(ctx, base);
	// 825FDC44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825FDC48: 997F013B  stb r11, 0x13b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(315 as u32), ctx.r[11].u8 ) };
	// 825FDC4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FDC50: C1BF0130  lfs f13, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FDC54: C19F0140  lfs f12, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FDC58: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FDC5C: C00B1B00  lfs f0, 0x1b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDC60: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825FDC64: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDC68: EDAD67FA  fmadds f13, f13, f31, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 825FDC6C: D1BF0140  stfs f13, 0x140(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FDC70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825FDC74: 40990008  ble cr6, 0x825fdc7c
	if !ctx.cr[6].gt {
	pc = 0x825FDC7C; continue 'dispatch;
	}
	// 825FDC78: D01F0140  stfs f0, 0x140(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FDC7C: C1BF0140  lfs f13, 0x140(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FDC80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FDC84: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825FDC88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FDC8C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825FDC90: 83FF0110  lwz r31, 0x110(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825FDC94: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825FDC98: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825FDC9C: 4887E33D  bl 0x82e7bfd8
	ctx.lr = 0x825FDCA0;
	sub_82E7BFD8(ctx, base);
	// 825FDCA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FDCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDCA8: 488155B9  bl 0x82e13260
	ctx.lr = 0x825FDCAC;
	sub_82E13260(ctx, base);
	// 825FDCAC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825FDCB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FDCB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FDCB8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FDCBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FDCC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FDCC8 size=104
    let mut pc: u32 = 0x825FDCC8;
    'dispatch: loop {
        match pc {
            0x825FDCC8 => {
    //   block [0x825FDCC8..0x825FDD30)
	// 825FDCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDCD0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FDCD4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDCD8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825FDCDC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FDCE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FDCE4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FDCE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FDCEC: C1AA9534  lfs f13, -0x6acc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FDCF0: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDCF4: D1AB0140  stfs f13, 0x140(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), tmp.u32 ) };
	// 825FDCF8: 83EB0110  lwz r31, 0x110(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) } as u64;
	// 825FDCFC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825FDD00: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825FDD04: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825FDD08: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825FDD0C: 4887E2CD  bl 0x82e7bfd8
	ctx.lr = 0x825FDD10;
	sub_82E7BFD8(ctx, base);
	// 825FDD10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FDD14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDD18: 48815549  bl 0x82e13260
	ctx.lr = 0x825FDD1C;
	sub_82E13260(ctx, base);
	// 825FDD1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825FDD20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FDD24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FDD28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FDD2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FDD30 size=196
    let mut pc: u32 = 0x825FDD30;
    'dispatch: loop {
        match pc {
            0x825FDD30 => {
    //   block [0x825FDD30..0x825FDDF4)
	// 825FDD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDD38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FDD3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FDD40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDD44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FDD48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FDD4C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FDD50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FDD54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FDD58: 4BCC2BE1  bl 0x822c0938
	ctx.lr = 0x825FDD5C;
	sub_822C0938(ctx, base);
	// 825FDD5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FDD60: 41820028  beq 0x825fdd88
	if ctx.cr[0].eq {
	pc = 0x825FDD88; continue 'dispatch;
	}
	// 825FDD64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FDD68: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FDD6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FDD70: 392B1B08  addi r9, r11, 0x1b08
	ctx.r[9].s64 = ctx.r[11].s64 + 6920;
	// 825FDD74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FDD78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FDD7C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FDD80: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FDD84: 48000008  b 0x825fdd8c
	pc = 0x825FDD8C; continue 'dispatch;
	// 825FDD88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FDD8C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FDD90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FDD94: 409A0044  bne cr6, 0x825fddd8
	if !ctx.cr[6].eq {
	pc = 0x825FDDD8; continue 'dispatch;
	}
	// 825FDD98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FDD9C: 419A001C  beq cr6, 0x825fddb8
	if ctx.cr[6].eq {
	pc = 0x825FDDB8; continue 'dispatch;
	}
	// 825FDDA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDDA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FDDA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDDAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FDDB4: 4E800421  bctrl
	ctx.lr = 0x825FDDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FDDB8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FDDBC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FDDC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FDDC4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FDDC8: 816BFA68  lwz r11, -0x598(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1432 as u32) ) } as u64;
	// 825FDDCC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FDDD0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FDDD4: 4BCC222D  bl 0x822c0000
	ctx.lr = 0x825FDDD8;
	sub_822C0000(ctx, base);
	// 825FDDD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FDDDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FDDE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FDDE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FDDE8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FDDEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FDDF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDDF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FDDF8 size=196
    let mut pc: u32 = 0x825FDDF8;
    'dispatch: loop {
        match pc {
            0x825FDDF8 => {
    //   block [0x825FDDF8..0x825FDEBC)
	// 825FDDF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDDFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDE00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FDE04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FDE08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDE0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FDE10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FDE14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FDE18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FDE1C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FDE20: 4BCC2B19  bl 0x822c0938
	ctx.lr = 0x825FDE24;
	sub_822C0938(ctx, base);
	// 825FDE24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FDE28: 41820028  beq 0x825fde50
	if ctx.cr[0].eq {
	pc = 0x825FDE50; continue 'dispatch;
	}
	// 825FDE2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FDE30: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FDE34: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FDE38: 392B1B1C  addi r9, r11, 0x1b1c
	ctx.r[9].s64 = ctx.r[11].s64 + 6940;
	// 825FDE3C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FDE40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FDE44: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FDE48: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FDE4C: 48000008  b 0x825fde54
	pc = 0x825FDE54; continue 'dispatch;
	// 825FDE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FDE54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FDE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FDE5C: 409A0044  bne cr6, 0x825fdea0
	if !ctx.cr[6].eq {
	pc = 0x825FDEA0; continue 'dispatch;
	}
	// 825FDE60: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FDE64: 419A001C  beq cr6, 0x825fde80
	if ctx.cr[6].eq {
	pc = 0x825FDE80; continue 'dispatch;
	}
	// 825FDE68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDE6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FDE70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FDE74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDE78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FDE7C: 4E800421  bctrl
	ctx.lr = 0x825FDE80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FDE80: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FDE84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FDE88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FDE8C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FDE90: 816BFA68  lwz r11, -0x598(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1432 as u32) ) } as u64;
	// 825FDE94: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FDE98: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FDE9C: 4BCC2165  bl 0x822c0000
	ctx.lr = 0x825FDEA0;
	sub_822C0000(ctx, base);
	// 825FDEA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FDEA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FDEA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FDEAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FDEB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FDEB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FDEB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDEC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FDEC0 size=168
    let mut pc: u32 = 0x825FDEC0;
    'dispatch: loop {
        match pc {
            0x825FDEC0 => {
    //   block [0x825FDEC0..0x825FDF68)
	// 825FDEC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDEC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDEC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDECC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825FDED0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825FDED4: 419A0044  beq cr6, 0x825fdf18
	if ctx.cr[6].eq {
	pc = 0x825FDF18; continue 'dispatch;
	}
	// 825FDED8: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 825FDEDC: 409A007C  bne cr6, 0x825fdf58
	if !ctx.cr[6].eq {
	pc = 0x825FDF58; continue 'dispatch;
	}
	// 825FDEE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDEE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825FDEE8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825FDEEC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825FDEF0: 99430144  stb r10, 0x144(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), ctx.r[10].u8 ) };
	// 825FDEF4: 99230145  stb r9, 0x145(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(325 as u32), ctx.r[9].u8 ) };
	// 825FDEF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FDEFC: 38A81B2C  addi r5, r8, 0x1b2c
	ctx.r[5].s64 = ctx.r[8].s64 + 6956;
	// 825FDF00: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FDF04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FDF08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FDF0C: 4E800421  bctrl
	ctx.lr = 0x825FDF10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FDF10: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FDF14: 48000038  b 0x825fdf4c
	pc = 0x825FDF4C; continue 'dispatch;
	// 825FDF18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDF1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FDF20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825FDF24: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825FDF28: 99430144  stb r10, 0x144(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), ctx.r[10].u8 ) };
	// 825FDF2C: 99230145  stb r9, 0x145(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(325 as u32), ctx.r[9].u8 ) };
	// 825FDF30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FDF34: 38A81B2C  addi r5, r8, 0x1b2c
	ctx.r[5].s64 = ctx.r[8].s64 + 6956;
	// 825FDF38: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FDF3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FDF40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FDF44: 4E800421  bctrl
	ctx.lr = 0x825FDF48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FDF48: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FDF4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FDF50: 419A0008  beq cr6, 0x825fdf58
	if ctx.cr[6].eq {
	pc = 0x825FDF58; continue 'dispatch;
	}
	// 825FDF54: 4BCC293D  bl 0x822c0890
	ctx.lr = 0x825FDF58;
	sub_822C0890(ctx, base);
	// 825FDF58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FDF5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FDF60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FDF64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FDF68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FDF68 size=348
    let mut pc: u32 = 0x825FDF68;
    'dispatch: loop {
        match pc {
            0x825FDF68 => {
    //   block [0x825FDF68..0x825FE0C4)
	// 825FDF68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FDF6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FDF70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FDF74: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825FDF78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FDF7C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825FDF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FDF84: C01F0128  lfs f0, 0x128(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FDF88: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825FDF8C: 40980018  bge cr6, 0x825fdfa4
	if !ctx.cr[6].lt {
	pc = 0x825FDFA4; continue 'dispatch;
	}
	// 825FDF90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FDF94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FDF98: 995F0146  stb r10, 0x146(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(326 as u32), ctx.r[10].u8 ) };
	// 825FDF9C: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FDFA0: 4800010C  b 0x825fe0ac
	pc = 0x825FE0AC; continue 'dispatch;
	// 825FDFA4: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FDFA8: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FDFAC: FF1F6000  fcmpu cr6, f31, f12
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[12].f64);
	// 825FDFB0: 40980068  bge cr6, 0x825fe018
	if !ctx.cr[6].lt {
	pc = 0x825FE018; continue 'dispatch;
	}
	// 825FDFB4: 897F0146  lbz r11, 0x146(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(326 as u32) ) } as u64;
	// 825FDFB8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FDFBC: 4182003C  beq 0x825fdff8
	if ctx.cr[0].eq {
	pc = 0x825FDFF8; continue 'dispatch;
	}
	// 825FDFC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FDFC4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FDFC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FDFCC: 38AA1B2C  addi r5, r10, 0x1b2c
	ctx.r[5].s64 = ctx.r[10].s64 + 6956;
	// 825FDFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FDFD4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FDFD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FDFDC: 4E800421  bctrl
	ctx.lr = 0x825FDFE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FDFE0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FDFE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FDFE8: 419A0008  beq cr6, 0x825fdff0
	if ctx.cr[6].eq {
	pc = 0x825FDFF0; continue 'dispatch;
	}
	// 825FDFEC: 4BCC28A5  bl 0x822c0890
	ctx.lr = 0x825FDFF0;
	sub_822C0890(ctx, base);
	// 825FDFF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FDFF4: 997F0146  stb r11, 0x146(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(326 as u32), ctx.r[11].u8 ) };
	// 825FDFF8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FDFFC: C01F0128  lfs f0, 0x128(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE000: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 825FE004: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FE008: C00B1B00  lfs f0, 0x1b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE00C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 825FE010: EC2C0032  fmuls f1, f12, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 825FE014: 48000098  b 0x825fe0ac
	pc = 0x825FE0AC; continue 'dispatch;
	// 825FE018: C19F012C  lfs f12, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FE01C: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 825FE020: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FE024: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825FE028: 40980018  bge cr6, 0x825fe040
	if !ctx.cr[6].lt {
	pc = 0x825FE040; continue 'dispatch;
	}
	// 825FE02C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE030: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FE034: 995F0146  stb r10, 0x146(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(326 as u32), ctx.r[10].u8 ) };
	// 825FE038: C02B1B00  lfs f1, 0x1b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6912 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FE03C: 48000070  b 0x825fe0ac
	pc = 0x825FE0AC; continue 'dispatch;
	// 825FE040: 897F0146  lbz r11, 0x146(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(326 as u32) ) } as u64;
	// 825FE044: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE048: 4182003C  beq 0x825fe084
	if ctx.cr[0].eq {
	pc = 0x825FE084; continue 'dispatch;
	}
	// 825FE04C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE050: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FE054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FE058: 38AA1B2C  addi r5, r10, 0x1b2c
	ctx.r[5].s64 = ctx.r[10].s64 + 6956;
	// 825FE05C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE060: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FE064: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FE068: 4E800421  bctrl
	ctx.lr = 0x825FE06C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FE06C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FE070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE074: 419A0008  beq cr6, 0x825fe07c
	if ctx.cr[6].eq {
	pc = 0x825FE07C; continue 'dispatch;
	}
	// 825FE078: 4BCC2819  bl 0x822c0890
	ctx.lr = 0x825FE07C;
	sub_822C0890(ctx, base);
	// 825FE07C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FE080: 997F0146  stb r11, 0x146(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(326 as u32), ctx.r[11].u8 ) };
	// 825FE084: C01F0128  lfs f0, 0x128(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE088: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE08C: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 825FE090: C19F0130  lfs f12, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FE094: C17F012C  lfs f11, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825FE098: C00B1B00  lfs f0, 0x1b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE09C: ED406024  fdivs f10, f0, f12
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 825FE0A0: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 825FE0A4: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 825FE0A8: EC2D02BC  fnmsubs f1, f13, f10, f0
	ctx.f[1].f64 = -(((ctx.f[13].f64 * ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 825FE0AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FE0B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FE0B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FE0B8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FE0BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FE0C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FE0C8 size=252
    let mut pc: u32 = 0x825FE0C8;
    'dispatch: loop {
        match pc {
            0x825FE0C8 => {
    //   block [0x825FE0C8..0x825FE1C4)
	// 825FE0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FE0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FE0D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE0D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE0DC: 4BF14255  bl 0x82512330
	ctx.lr = 0x825FE0E0;
	sub_82512330(ctx, base);
	// 825FE0E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE0E4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FE0E8: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825FE0EC: 394A1BAC  addi r10, r10, 0x1bac
	ctx.r[10].s64 = ctx.r[10].s64 + 7084;
	// 825FE0F0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825FE0F4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825FE0F8: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825FE0FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825FE100: 39291B98  addi r9, r9, 0x1b98
	ctx.r[9].s64 = ctx.r[9].s64 + 7064;
	// 825FE104: 39081B4C  addi r8, r8, 0x1b4c
	ctx.r[8].s64 = ctx.r[8].s64 + 6988;
	// 825FE108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FE10C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825FE110: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 825FE114: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 825FE118: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 825FE11C: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 825FE120: 390A6910  addi r8, r10, 0x6910
	ctx.r[8].s64 = ctx.r[10].s64 + 26896;
	// 825FE124: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 825FE128: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 825FE12C: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 825FE130: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 825FE134: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 825FE138: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 825FE13C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 825FE140: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 825FE144: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FE148: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825FE14C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FE1C8 size=8
    let mut pc: u32 = 0x825FE1C8;
    'dispatch: loop {
        match pc {
            0x825FE1C8 => {
    //   block [0x825FE1C8..0x825FE1D0)
	// 825FE1C8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825FE1CC: 480002BC  b 0x825fe488
	sub_825FE488(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FE1D0 size=8
    let mut pc: u32 = 0x825FE1D0;
    'dispatch: loop {
        match pc {
            0x825FE1D0 => {
    //   block [0x825FE1D0..0x825FE1D8)
	// 825FE1D0: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825FE1D4: 480002B4  b 0x825fe488
	sub_825FE488(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FE1D8 size=164
    let mut pc: u32 = 0x825FE1D8;
    'dispatch: loop {
        match pc {
            0x825FE1D8 => {
    //   block [0x825FE1D8..0x825FE27C)
	// 825FE1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE1DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FE1E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FE1E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE1E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE1EC: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 825FE1F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE1F4: 419A0008  beq cr6, 0x825fe1fc
	if ctx.cr[6].eq {
	pc = 0x825FE1FC; continue 'dispatch;
	}
	// 825FE1F8: 4BCC2699  bl 0x822c0890
	ctx.lr = 0x825FE1FC;
	sub_822C0890(ctx, base);
	// 825FE1FC: 807F011C  lwz r3, 0x11c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) } as u64;
	// 825FE200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE204: 419A0008  beq cr6, 0x825fe20c
	if ctx.cr[6].eq {
	pc = 0x825FE20C; continue 'dispatch;
	}
	// 825FE208: 4BCC2689  bl 0x822c0890
	ctx.lr = 0x825FE20C;
	sub_822C0890(ctx, base);
	// 825FE20C: 807F0114  lwz r3, 0x114(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 825FE210: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE214: 419A0008  beq cr6, 0x825fe21c
	if ctx.cr[6].eq {
	pc = 0x825FE21C; continue 'dispatch;
	}
	// 825FE218: 4BCC2679  bl 0x822c0890
	ctx.lr = 0x825FE21C;
	sub_822C0890(ctx, base);
	// 825FE21C: 807F00FC  lwz r3, 0xfc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 825FE220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE224: 419A0008  beq cr6, 0x825fe22c
	if ctx.cr[6].eq {
	pc = 0x825FE22C; continue 'dispatch;
	}
	// 825FE228: 4BCC2669  bl 0x822c0890
	ctx.lr = 0x825FE22C;
	sub_822C0890(ctx, base);
	// 825FE22C: 807F00F4  lwz r3, 0xf4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) } as u64;
	// 825FE230: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE234: 419A0008  beq cr6, 0x825fe23c
	if ctx.cr[6].eq {
	pc = 0x825FE23C; continue 'dispatch;
	}
	// 825FE238: 4BCC2659  bl 0x822c0890
	ctx.lr = 0x825FE23C;
	sub_822C0890(ctx, base);
	// 825FE23C: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 825FE240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE244: 419A0008  beq cr6, 0x825fe24c
	if ctx.cr[6].eq {
	pc = 0x825FE24C; continue 'dispatch;
	}
	// 825FE248: 4BCC2649  bl 0x822c0890
	ctx.lr = 0x825FE24C;
	sub_822C0890(ctx, base);
	// 825FE24C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FE250: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 825FE254: 409A0008  bne cr6, 0x825fe25c
	if !ctx.cr[6].eq {
	pc = 0x825FE25C; continue 'dispatch;
	}
	// 825FE258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825FE25C: 481A93FD  bl 0x827a7658
	ctx.lr = 0x825FE260;
	sub_827A7658(ctx, base);
	// 825FE260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE264: 4BD510ED  bl 0x8234f350
	ctx.lr = 0x825FE268;
	sub_8234F350(ctx, base);
	// 825FE268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FE26C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FE270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FE274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FE278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FE280 size=392
    let mut pc: u32 = 0x825FE280;
    'dispatch: loop {
        match pc {
            0x825FE280 => {
    //   block [0x825FE280..0x825FE408)
	// 825FE280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FE288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FE28C: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 825FE290: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825FE294: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825FE298: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE2A0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825FE2A4: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 825FE2A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 825FE2AC: 41980010  blt cr6, 0x825fe2bc
	if ctx.cr[6].lt {
	pc = 0x825FE2BC; continue 'dispatch;
	}
	// 825FE2B0: 419A005C  beq cr6, 0x825fe30c
	if ctx.cr[6].eq {
	pc = 0x825FE30C; continue 'dispatch;
	}
	// 825FE2B4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 825FE2B8: 40980034  bge cr6, 0x825fe2ec
	if !ctx.cr[6].lt {
	pc = 0x825FE2EC; continue 'dispatch;
	}
	// 825FE2BC: 897F0145  lbz r11, 0x145(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(325 as u32) ) } as u64;
	// 825FE2C0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE2C4: 41820010  beq 0x825fe2d4
	if ctx.cr[0].eq {
	pc = 0x825FE2D4; continue 'dispatch;
	}
	// 825FE2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE2CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FE2D0: 4BFFF8A1  bl 0x825fdb70
	ctx.lr = 0x825FE2D4;
	sub_825FDB70(ctx, base);
	// 825FE2D4: 897F0144  lbz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 825FE2D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE2DC: 41820010  beq 0x825fe2ec
	if ctx.cr[0].eq {
	pc = 0x825FE2EC; continue 'dispatch;
	}
	// 825FE2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE2E4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FE2E8: 4BFFF931  bl 0x825fdc18
	ctx.lr = 0x825FE2EC;
	sub_825FDC18(ctx, base);
	// 825FE2EC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825FE2F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FE2F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FE2F8: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 825FE2FC: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 825FE300: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FE304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FE308: 4E800020  blr
	return;
	// 825FE30C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FE310: C1BF0130  lfs f13, 0x130(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FE314: C19F012C  lfs f12, 0x12c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FE318: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FE31C: C17F0128  lfs f11, 0x128(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825FE320: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE324: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 825FE328: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FE32C: EFC0582A  fadds f30, f0, f11
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 825FE330: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 825FE334: 409A000C  bne cr6, 0x825fe340
	if !ctx.cr[6].eq {
	pc = 0x825FE340; continue 'dispatch;
	}
	// 825FE338: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FE33C: C3CBCC2C  lfs f30, -0x33d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13268 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825FE340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FE344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FE348: 4BF11181  bl 0x8250f4c8
	ctx.lr = 0x825FE34C;
	sub_8250F4C8(ctx, base);
	// 825FE34C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FE354: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825FE358: 409A0008  bne cr6, 0x825fe360
	if !ctx.cr[6].eq {
	pc = 0x825FE360; continue 'dispatch;
	}
	// 825FE35C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825FE360: 4BF0A1B9  bl 0x82508518
	ctx.lr = 0x825FE364;
	sub_82508518(ctx, base);
	// 825FE364: C01F0134  lfs f0, 0x134(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FE36C: EFA1002A  fadds f29, f1, f0
	ctx.f[29].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 825FE370: 487F3921  bl 0x82df1c90
	ctx.lr = 0x825FE374;
	sub_82DF1C90(ctx, base);
	// 825FE374: FC20E890  fmr f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[29].f64;
	// 825FE378: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 825FE37C: 48BAC495  bl 0x831aa810
	ctx.lr = 0x825FE380;
	sub_831AA810(ctx, base);
	// 825FE380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE384: FC200818  frsp f1, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (ctx.f[1].f64 as f32) as f64;
	// 825FE388: 4BFFFBE1  bl 0x825fdf68
	ctx.lr = 0x825FE38C;
	sub_825FDF68(ctx, base);
	// 825FE38C: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 825FE390: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FE394: C00B964C  lfs f0, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE398: 897F013B  lbz r11, 0x13b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(315 as u32) ) } as u64;
	// 825FE39C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE3A0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 825FE3A4: 41990018  bgt cr6, 0x825fe3bc
	if ctx.cr[6].gt {
	pc = 0x825FE3BC; continue 'dispatch;
	}
	// 825FE3A8: 41820028  beq 0x825fe3d0
	if ctx.cr[0].eq {
	pc = 0x825FE3D0; continue 'dispatch;
	}
	// 825FE3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE3B0: 4BF138D9  bl 0x82511c88
	ctx.lr = 0x825FE3B4;
	sub_82511C88(ctx, base);
	// 825FE3B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FE3B8: 48000014  b 0x825fe3cc
	pc = 0x825FE3CC; continue 'dispatch;
	// 825FE3BC: 40820014  bne 0x825fe3d0
	if !ctx.cr[0].eq {
	pc = 0x825FE3D0; continue 'dispatch;
	}
	// 825FE3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE3C4: 4BF138E5  bl 0x82511ca8
	ctx.lr = 0x825FE3C8;
	sub_82511CA8(ctx, base);
	// 825FE3C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825FE3CC: 997F013B  stb r11, 0x13b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(315 as u32), ctx.r[11].u8 ) };
	// 825FE3D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE3D4: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 825FE3D8: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825FE3DC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FE3E0: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825FE3E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FE3E8: C00B1B00  lfs f0, 0x1b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE3EC: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 825FE3F0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825FE3F4: 4887DBE5  bl 0x82e7bfd8
	ctx.lr = 0x825FE3F8;
	sub_82E7BFD8(ctx, base);
	// 825FE3F8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825FE3FC: 807F0110  lwz r3, 0x110(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825FE400: 48814E61  bl 0x82e13260
	ctx.lr = 0x825FE404;
	sub_82E13260(ctx, base);
	// 825FE404: 4BFFFEE8  b 0x825fe2ec
	pc = 0x825FE2EC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FE408 size=128
    let mut pc: u32 = 0x825FE408;
    'dispatch: loop {
        match pc {
            0x825FE408 => {
    //   block [0x825FE408..0x825FE488)
	// 825FE408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE40C: 48BA9D61  bl 0x831a816c
	ctx.lr = 0x825FE410;
	sub_831A8130(ctx, base);
	// 825FE410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE414: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FE418: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825FE41C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FE420: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825FE424: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FE428: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 825FE42C: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 825FE430: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825FE434: 487F3FB5  bl 0x82df23e8
	ctx.lr = 0x825FE438;
	sub_82DF23E8(ctx, base);
	// 825FE438: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE43C: 41820018  beq 0x825fe454
	if ctx.cr[0].eq {
	pc = 0x825FE454; continue 'dispatch;
	}
	// 825FE440: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE444: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE448: 485596B1  bl 0x82b57af8
	ctx.lr = 0x825FE44C;
	sub_82B57AF8(ctx, base);
	// 825FE44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE450: 48000008  b 0x825fe458
	pc = 0x825FE458; continue 'dispatch;
	// 825FE454: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FE458: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FE45C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 825FE460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FE464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE468: 4BFFF991  bl 0x825fddf8
	ctx.lr = 0x825FE46C;
	sub_825FDDF8(ctx, base);
	// 825FE46C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FE470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FE474: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE478: 4BCC1B89  bl 0x822c0000
	ctx.lr = 0x825FE47C;
	sub_822C0000(ctx, base);
	// 825FE47C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FE480: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FE484: 48BA9D38  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FE488 size=76
    let mut pc: u32 = 0x825FE488;
    'dispatch: loop {
        match pc {
            0x825FE488 => {
    //   block [0x825FE488..0x825FE4D4)
	// 825FE488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FE490: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FE494: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FE498: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE4A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FE4A4: 4BFFFD35  bl 0x825fe1d8
	ctx.lr = 0x825FE4A8;
	sub_825FE1D8(ctx, base);
	// 825FE4A8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FE4AC: 4182000C  beq 0x825fe4b8
	if ctx.cr[0].eq {
	pc = 0x825FE4B8; continue 'dispatch;
	}
	// 825FE4B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE4B4: 487F3F25  bl 0x82df23d8
	ctx.lr = 0x825FE4B8;
	sub_82DF23D8(ctx, base);
	// 825FE4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE4BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FE4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FE4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FE4C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FE4CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FE4D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FE4D8 size=364
    let mut pc: u32 = 0x825FE4D8;
    'dispatch: loop {
        match pc {
            0x825FE4D8 => {
    //   block [0x825FE4D8..0x825FE644)
	// 825FE4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE4DC: 48BA9C91  bl 0x831a816c
	ctx.lr = 0x825FE4E0;
	sub_831A8130(ctx, base);
	// 825FE4E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE4E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FE4E8: 897E0139  lbz r11, 0x139(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(313 as u32) ) } as u64;
	// 825FE4EC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE4F0: 418200FC  beq 0x825fe5ec
	if ctx.cr[0].eq {
	pc = 0x825FE5EC; continue 'dispatch;
	}
	// 825FE4F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FE4F8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FE4FC: 4BF10FCD  bl 0x8250f4c8
	ctx.lr = 0x825FE500;
	sub_8250F4C8(ctx, base);
	// 825FE500: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FE508: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 825FE50C: 409A0008  bne cr6, 0x825fe514
	if !ctx.cr[6].eq {
	pc = 0x825FE514; continue 'dispatch;
	}
	// 825FE510: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825FE514: 4BF0A015  bl 0x82508528
	ctx.lr = 0x825FE518;
	sub_82508528(ctx, base);
	// 825FE518: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FE51C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FE520: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE524: 4882C5C5  bl 0x82e2aae8
	ctx.lr = 0x825FE528;
	sub_82E2AAE8(ctx, base);
	// 825FE528: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FE52C: 487F3765  bl 0x82df1c90
	ctx.lr = 0x825FE530;
	sub_82DF1C90(ctx, base);
	// 825FE530: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE534: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FE538: 388B1C40  addi r4, r11, 0x1c40
	ctx.r[4].s64 = ctx.r[11].s64 + 7232;
	// 825FE53C: 487F54CD  bl 0x82df3a08
	ctx.lr = 0x825FE540;
	sub_82DF3A08(ctx, base);
	// 825FE540: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FE544: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FE548: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FE54C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE550: 48830921  bl 0x82e2ee70
	ctx.lr = 0x825FE554;
	sub_82E2EE70(ctx, base);
	// 825FE554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FE558: 487F4ED1  bl 0x82df3428
	ctx.lr = 0x825FE55C;
	sub_82DF3428(ctx, base);
	// 825FE55C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE560: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FE564: 388B1BE8  addi r4, r11, 0x1be8
	ctx.r[4].s64 = ctx.r[11].s64 + 7144;
	// 825FE568: 38A00093  li r5, 0x93
	ctx.r[5].s64 = 147;
	// 825FE56C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825FE570: 487F3E79  bl 0x82df23e8
	ctx.lr = 0x825FE574;
	sub_82DF23E8(ctx, base);
	// 825FE574: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE578: 41820014  beq 0x825fe58c
	if ctx.cr[0].eq {
	pc = 0x825FE58C; continue 'dispatch;
	}
	// 825FE57C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FE580: 48818311  bl 0x82e16890
	ctx.lr = 0x825FE584;
	sub_82E16890(ctx, base);
	// 825FE584: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FE588: 48000008  b 0x825fe590
	pc = 0x825FE590; continue 'dispatch;
	// 825FE58C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FE590: 3BFE00E8  addi r31, r30, 0xe8
	ctx.r[31].s64 = ctx.r[30].s64 + 232;
	// 825FE594: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE598: 4BD5EDD9  bl 0x8235d370
	ctx.lr = 0x825FE59C;
	sub_8235D370(ctx, base);
	// 825FE59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FE5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FE5A4: 83BE00E8  lwz r29, 0xe8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 825FE5A8: 4BF13B71  bl 0x82512118
	ctx.lr = 0x825FE5AC;
	sub_82512118(ctx, base);
	// 825FE5AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FE5B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FE5B4: 48816AFD  bl 0x82e150b0
	ctx.lr = 0x825FE5B8;
	sub_82E150B0(ctx, base);
	// 825FE5B8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FE5BC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FE5C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FE5C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE5C8: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825FE5CC: 4BF1258D  bl 0x82510b58
	ctx.lr = 0x825FE5D0;
	sub_82510B58(ctx, base);
	// 825FE5D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FE5D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE5D8: 419A0008  beq cr6, 0x825fe5e0
	if ctx.cr[6].eq {
	pc = 0x825FE5E0; continue 'dispatch;
	}
	// 825FE5DC: 4BCC22B5  bl 0x822c0890
	ctx.lr = 0x825FE5E0;
	sub_822C0890(ctx, base);
	// 825FE5E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FE5E4: 4882C51D  bl 0x82e2ab00
	ctx.lr = 0x825FE5E8;
	sub_82E2AB00(ctx, base);
	// 825FE5E8: 4800004C  b 0x825fe634
	pc = 0x825FE634; continue 'dispatch;
	// 825FE5EC: 817E00E8  lwz r11, 0xe8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 825FE5F0: 3BFE00E8  addi r31, r30, 0xe8
	ctx.r[31].s64 = ctx.r[30].s64 + 232;
	// 825FE5F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FE5F8: 419A003C  beq cr6, 0x825fe634
	if ctx.cr[6].eq {
	pc = 0x825FE634; continue 'dispatch;
	}
	// 825FE5FC: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FE600: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FE604: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FE608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE60C: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825FE610: 4BF11BE1  bl 0x825101f0
	ctx.lr = 0x825FE614;
	sub_825101F0(ctx, base);
	// 825FE614: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FE618: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825FE61C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FE620: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FE624: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE628: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FE62C: 419A0008  beq cr6, 0x825fe634
	if ctx.cr[6].eq {
	pc = 0x825FE634; continue 'dispatch;
	}
	// 825FE630: 4BCC2261  bl 0x822c0890
	ctx.lr = 0x825FE634;
	sub_822C0890(ctx, base);
	// 825FE634: 897E0139  lbz r11, 0x139(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(313 as u32) ) } as u64;
	// 825FE638: 997E013A  stb r11, 0x13a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(314 as u32), ctx.r[11].u8 ) };
	// 825FE63C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825FE640: 48BA9B7C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FE648 size=100
    let mut pc: u32 = 0x825FE648;
    'dispatch: loop {
        match pc {
            0x825FE648 => {
    //   block [0x825FE648..0x825FE6AC)
	// 825FE648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FE650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FE654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FE658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FE664: 4BF120A5  bl 0x82510708
	ctx.lr = 0x825FE668;
	sub_82510708(ctx, base);
	// 825FE668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE66C: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FE670: 4BFFFC11  bl 0x825fe280
	ctx.lr = 0x825FE674;
	sub_825FE280(ctx, base);
	// 825FE674: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FE678: C01F0148  lfs f0, 0x148(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FE67C: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FE680: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 825FE684: 40990010  ble cr6, 0x825fe694
	if !ctx.cr[6].gt {
	pc = 0x825FE694; continue 'dispatch;
	}
	// 825FE688: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FE68C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825FE690: D01F0148  stfs f0, 0x148(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), tmp.u32 ) };
	// 825FE694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FE698: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FE69C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FE6A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FE6A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FE6A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FE6B0 size=440
    let mut pc: u32 = 0x825FE6B0;
    'dispatch: loop {
        match pc {
            0x825FE6B0 => {
    //   block [0x825FE6B0..0x825FE868)
	// 825FE6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE6B4: 48BA9AAD  bl 0x831a8160
	ctx.lr = 0x825FE6B8;
	sub_831A8130(ctx, base);
	// 825FE6B8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE6BC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825FE6C0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 825FE6C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825FE6C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825FE6CC: 3B4B8614  addi r26, r11, -0x79ec
	ctx.r[26].s64 = ctx.r[11].s64 + -31212;
	// 825FE6D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825FE6D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825FE6D8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FE6DC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825FE6E0: 4BFFFD29  bl 0x825fe408
	ctx.lr = 0x825FE6E4;
	sub_825FE408(ctx, base);
	// 825FE6E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE6E8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FE6EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FE6F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FE6F4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825FE6F8: 419A0024  beq cr6, 0x825fe71c
	if ctx.cr[6].eq {
	pc = 0x825FE71C; continue 'dispatch;
	}
	// 825FE6FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FE700: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FE704: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FE708: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FE70C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FE710: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FE714: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FE718: 4082FFE8  bne 0x825fe700
	if !ctx.cr[0].eq {
	pc = 0x825FE700; continue 'dispatch;
	}
	// 825FE71C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FE720: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 825FE724: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825FE728: 48A09A01  bl 0x83008128
	ctx.lr = 0x825FE72C;
	sub_83008128(ctx, base);
	// 825FE72C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE730: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825FE734: 3BCB1BE8  addi r30, r11, 0x1be8
	ctx.r[30].s64 = ctx.r[11].s64 + 7144;
	// 825FE738: 38A000F7  li r5, 0xf7
	ctx.r[5].s64 = 247;
	// 825FE73C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FE740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE744: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825FE748: 488588A1  bl 0x82e56fe8
	ctx.lr = 0x825FE74C;
	sub_82E56FE8(ctx, base);
	// 825FE74C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FE750: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825FE754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FE758: 419A000C  beq cr6, 0x825fe764
	if ctx.cr[6].eq {
	pc = 0x825FE764; continue 'dispatch;
	}
	// 825FE75C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825FE760: 4BCC2131  bl 0x822c0890
	ctx.lr = 0x825FE764;
	sub_822C0890(ctx, base);
	// 825FE764: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FE768: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE76C: 419A0008  beq cr6, 0x825fe774
	if ctx.cr[6].eq {
	pc = 0x825FE774; continue 'dispatch;
	}
	// 825FE770: 4BCC2121  bl 0x822c0890
	ctx.lr = 0x825FE774;
	sub_822C0890(ctx, base);
	// 825FE774: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FE778: 418200E8  beq 0x825fe860
	if ctx.cr[0].eq {
	pc = 0x825FE860; continue 'dispatch;
	}
	// 825FE77C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FE780: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FE784: 418200DC  beq 0x825fe860
	if ctx.cr[0].eq {
	pc = 0x825FE860; continue 'dispatch;
	}
	// 825FE788: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FE78C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825FE790: 3B6B6910  addi r27, r11, 0x6910
	ctx.r[27].s64 = ctx.r[11].s64 + 26896;
	// 825FE794: 4BF13355  bl 0x82511ae8
	ctx.lr = 0x825FE798;
	sub_82511AE8(ctx, base);
	// 825FE798: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FE79C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825FE7A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FE7A4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825FE7A8: 4820D6E9  bl 0x8280be90
	ctx.lr = 0x825FE7AC;
	sub_8280BE90(ctx, base);
	// 825FE7AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE7B0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825FE7B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FE7B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FE7BC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825FE7C0: 419A0024  beq cr6, 0x825fe7e4
	if ctx.cr[6].eq {
	pc = 0x825FE7E4; continue 'dispatch;
	}
	// 825FE7C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FE7C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FE7CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FE7D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FE7D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FE7D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FE7DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FE7E0: 4082FFE8  bne 0x825fe7c8
	if !ctx.cr[0].eq {
	pc = 0x825FE7C8; continue 'dispatch;
	}
	// 825FE7E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FE7E8: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 825FE7EC: 48A0993D  bl 0x83008128
	ctx.lr = 0x825FE7F0;
	sub_83008128(ctx, base);
	// 825FE7F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FE7F4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825FE7F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FE7FC: 38A000F9  li r5, 0xf9
	ctx.r[5].s64 = 249;
	// 825FE800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FE804: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825FE808: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FE80C: 4885A235  bl 0x82e58a40
	ctx.lr = 0x825FE810;
	sub_82E58A40(ctx, base);
	// 825FE810: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825FE814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE818: 419A0008  beq cr6, 0x825fe820
	if ctx.cr[6].eq {
	pc = 0x825FE820; continue 'dispatch;
	}
	// 825FE81C: 4BCC2075  bl 0x822c0890
	ctx.lr = 0x825FE820;
	sub_822C0890(ctx, base);
	// 825FE820: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825FE824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE828: 419A0008  beq cr6, 0x825fe830
	if ctx.cr[6].eq {
	pc = 0x825FE830; continue 'dispatch;
	}
	// 825FE82C: 4BCC2065  bl 0x822c0890
	ctx.lr = 0x825FE830;
	sub_822C0890(ctx, base);
	// 825FE830: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FE834: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FE838: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825FE83C: 38AA1C64  addi r5, r10, 0x1c64
	ctx.r[5].s64 = ctx.r[10].s64 + 7268;
	// 825FE840: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825FE844: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825FE848: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FE84C: 4E800421  bctrl
	ctx.lr = 0x825FE850;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FE850: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825FE854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FE858: 419A0008  beq cr6, 0x825fe860
	if ctx.cr[6].eq {
	pc = 0x825FE860; continue 'dispatch;
	}
	// 825FE85C: 4BCC2035  bl 0x822c0890
	ctx.lr = 0x825FE860;
	sub_822C0890(ctx, base);
	// 825FE860: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825FE864: 48BA994C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FE868 size=84
    let mut pc: u32 = 0x825FE868;
    'dispatch: loop {
        match pc {
            0x825FE868 => {
    //   block [0x825FE868..0x825FE8BC)
	// 825FE868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FE870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FE874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE87C: 897F0056  lbz r11, 0x56(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(86 as u32) ) } as u64;
	// 825FE880: 895F0055  lbz r10, 0x55(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(85 as u32) ) } as u64;
	// 825FE884: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825FE888: 419A000C  beq cr6, 0x825fe894
	if ctx.cr[6].eq {
	pc = 0x825FE894; continue 'dispatch;
	}
	// 825FE88C: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 825FE890: 4BFFFC49  bl 0x825fe4d8
	ctx.lr = 0x825FE894;
	sub_825FE4D8(ctx, base);
	// 825FE894: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FE898: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 825FE89C: 409A000C  bne cr6, 0x825fe8a8
	if !ctx.cr[6].eq {
	pc = 0x825FE8A8; continue 'dispatch;
	}
	// 825FE8A0: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 825FE8A4: 4BFFF425  bl 0x825fdcc8
	ctx.lr = 0x825FE8A8;
	sub_825FDCC8(ctx, base);
	// 825FE8A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FE8AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FE8B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FE8B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FE8B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FE8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FE8C0 size=868
    let mut pc: u32 = 0x825FE8C0;
    'dispatch: loop {
        match pc {
            0x825FE8C0 => {
    //   block [0x825FE8C0..0x825FEC24)
	// 825FE8C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FE8C4: 48BA98A5  bl 0x831a8168
	ctx.lr = 0x825FE8C8;
	sub_831A8130(ctx, base);
	// 825FE8C8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 825FE8CC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 825FE8D0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825FE8D4: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FE8D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE8DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FE8E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FE8E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FE8E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE8EC: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 825FE8F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FE8F4: 487F5115  bl 0x82df3a08
	ctx.lr = 0x825FE8F8;
	sub_82DF3A08(ctx, base);
	// 825FE8F8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FE8FC: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 825FE900: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FE904: 389F0044  addi r4, r31, 0x44
	ctx.r[4].s64 = ctx.r[31].s64 + 68;
	// 825FE908: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 825FE90C: C3AB964C  lfs f29, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825FE910: C3EA6218  lfs f31, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FE914: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FE918: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825FE91C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FE920: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FE924: 4BFA488D  bl 0x825a31b0
	ctx.lr = 0x825FE928;
	sub_825A31B0(ctx, base);
	// 825FE928: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FE92C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE930: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FE934: 4BFA2E3D  bl 0x825a1770
	ctx.lr = 0x825FE938;
	sub_825A1770(ctx, base);
	// 825FE938: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 825FE93C: 487F4AED  bl 0x82df3428
	ctx.lr = 0x825FE940;
	sub_82DF3428(ctx, base);
	// 825FE940: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 825FE944: 4BCCA375  bl 0x822c8cb8
	ctx.lr = 0x825FE948;
	sub_822C8CB8(ctx, base);
	// 825FE948: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE94C: 487F4ADD  bl 0x82df3428
	ctx.lr = 0x825FE950;
	sub_82DF3428(ctx, base);
	// 825FE950: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE954: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE958: 388B1CE0  addi r4, r11, 0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + 7392;
	// 825FE95C: 487F50AD  bl 0x82df3a08
	ctx.lr = 0x825FE960;
	sub_82DF3A08(ctx, base);
	// 825FE960: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 825FE964: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825FE968: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FE96C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FE970: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FE974: 4BFA483D  bl 0x825a31b0
	ctx.lr = 0x825FE978;
	sub_825A31B0(ctx, base);
	// 825FE978: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FE97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE980: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FE984: 4BFA2DED  bl 0x825a1770
	ctx.lr = 0x825FE988;
	sub_825A1770(ctx, base);
	// 825FE988: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825FE98C: 487F4A9D  bl 0x82df3428
	ctx.lr = 0x825FE990;
	sub_82DF3428(ctx, base);
	// 825FE990: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825FE994: 4BCCA325  bl 0x822c8cb8
	ctx.lr = 0x825FE998;
	sub_822C8CB8(ctx, base);
	// 825FE998: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE99C: 487F4A8D  bl 0x82df3428
	ctx.lr = 0x825FE9A0;
	sub_82DF3428(ctx, base);
	// 825FE9A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE9A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE9A8: 388B1CD4  addi r4, r11, 0x1cd4
	ctx.r[4].s64 = ctx.r[11].s64 + 7380;
	// 825FE9AC: 487F505D  bl 0x82df3a08
	ctx.lr = 0x825FE9B0;
	sub_82DF3A08(ctx, base);
	// 825FE9B0: 389F004C  addi r4, r31, 0x4c
	ctx.r[4].s64 = ctx.r[31].s64 + 76;
	// 825FE9B4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825FE9B8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FE9BC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FE9C0: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 825FE9C4: 4BFA47ED  bl 0x825a31b0
	ctx.lr = 0x825FE9C8;
	sub_825A31B0(ctx, base);
	// 825FE9C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FE9CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FE9D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FE9D4: 4BFA2D9D  bl 0x825a1770
	ctx.lr = 0x825FE9D8;
	sub_825A1770(ctx, base);
	// 825FE9D8: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 825FE9DC: 487F4A4D  bl 0x82df3428
	ctx.lr = 0x825FE9E0;
	sub_82DF3428(ctx, base);
	// 825FE9E0: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 825FE9E4: 4BCCA2D5  bl 0x822c8cb8
	ctx.lr = 0x825FE9E8;
	sub_822C8CB8(ctx, base);
	// 825FE9E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE9EC: 487F4A3D  bl 0x82df3428
	ctx.lr = 0x825FE9F0;
	sub_82DF3428(ctx, base);
	// 825FE9F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FE9F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FE9F8: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 825FE9FC: 487F500D  bl 0x82df3a08
	ctx.lr = 0x825FEA00;
	sub_82DF3A08(ctx, base);
	// 825FEA00: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FEA04: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 825FEA08: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 825FEA0C: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 825FEA10: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825FEA14: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825FEA18: 4BFA4799  bl 0x825a31b0
	ctx.lr = 0x825FEA1C;
	sub_825A31B0(ctx, base);
	// 825FEA1C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FEA20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEA24: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FEA28: 4BFA2D49  bl 0x825a1770
	ctx.lr = 0x825FEA2C;
	sub_825A1770(ctx, base);
	// 825FEA2C: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 825FEA30: 487F49F9  bl 0x82df3428
	ctx.lr = 0x825FEA34;
	sub_82DF3428(ctx, base);
	// 825FEA34: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 825FEA38: 4BCCA281  bl 0x822c8cb8
	ctx.lr = 0x825FEA3C;
	sub_822C8CB8(ctx, base);
	// 825FEA3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FEA40: 487F49E9  bl 0x82df3428
	ctx.lr = 0x825FEA44;
	sub_82DF3428(ctx, base);
	// 825FEA44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEA48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEA4C: 388B1CC4  addi r4, r11, 0x1cc4
	ctx.r[4].s64 = ctx.r[11].s64 + 7364;
	// 825FEA50: 487F4FB9  bl 0x82df3a08
	ctx.lr = 0x825FEA54;
	sub_82DF3A08(ctx, base);
	// 825FEA54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEA58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FEA5C: 388B1CB8  addi r4, r11, 0x1cb8
	ctx.r[4].s64 = ctx.r[11].s64 + 7352;
	// 825FEA60: 487F4FA9  bl 0x82df3a08
	ctx.lr = 0x825FEA64;
	sub_82DF3A08(ctx, base);
	// 825FEA64: 38BF0055  addi r5, r31, 0x55
	ctx.r[5].s64 = ctx.r[31].s64 + 85;
	// 825FEA68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FEA6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FEA70: 4BFA45E1  bl 0x825a3050
	ctx.lr = 0x825FEA74;
	sub_825A3050(ctx, base);
	// 825FEA74: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825FEA78: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FEA7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEA80: 4BFA3709  bl 0x825a2188
	ctx.lr = 0x825FEA84;
	sub_825A2188(ctx, base);
	// 825FEA84: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825FEA88: 487F49A1  bl 0x82df3428
	ctx.lr = 0x825FEA8C;
	sub_82DF3428(ctx, base);
	// 825FEA8C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825FEA90: 4BCCA229  bl 0x822c8cb8
	ctx.lr = 0x825FEA94;
	sub_822C8CB8(ctx, base);
	// 825FEA94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FEA98: 487F4991  bl 0x82df3428
	ctx.lr = 0x825FEA9C;
	sub_82DF3428(ctx, base);
	// 825FEA9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEAA0: 487F4989  bl 0x82df3428
	ctx.lr = 0x825FEAA4;
	sub_82DF3428(ctx, base);
	// 825FEAA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEAA8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FEAAC: 388B1BE8  addi r4, r11, 0x1be8
	ctx.r[4].s64 = ctx.r[11].s64 + 7144;
	// 825FEAB0: 38A00154  li r5, 0x154
	ctx.r[5].s64 = 340;
	// 825FEAB4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825FEAB8: 4BCC1921  bl 0x822c03d8
	ctx.lr = 0x825FEABC;
	sub_822C03D8(ctx, base);
	// 825FEABC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825FEAC0: 41820034  beq 0x825feaf4
	if ctx.cr[0].eq {
	pc = 0x825FEAF4; continue 'dispatch;
	}
	// 825FEAC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEAC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEACC: 388B1CAC  addi r4, r11, 0x1cac
	ctx.r[4].s64 = ctx.r[11].s64 + 7340;
	// 825FEAD0: 487F4F39  bl 0x82df3a08
	ctx.lr = 0x825FEAD4;
	sub_82DF3A08(ctx, base);
	// 825FEAD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FEAD8: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 825FEADC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FEAE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FEAE4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825FEAE8: 4BFAD929  bl 0x825ac410
	ctx.lr = 0x825FEAEC;
	sub_825AC410(ctx, base);
	// 825FEAEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FEAF0: 48000008  b 0x825feaf8
	pc = 0x825FEAF8; continue 'dispatch;
	// 825FEAF4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FEAF8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825FEAFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FEB00: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825FEB04: 4BEF48B5  bl 0x824f33b8
	ctx.lr = 0x825FEB08;
	sub_824F33B8(ctx, base);
	// 825FEB08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FEB0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FEB10: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825FEB14: 4BCC14ED  bl 0x822c0000
	ctx.lr = 0x825FEB18;
	sub_822C0000(ctx, base);
	// 825FEB18: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FEB1C: 4182000C  beq 0x825feb28
	if ctx.cr[0].eq {
	pc = 0x825FEB28; continue 'dispatch;
	}
	// 825FEB20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEB24: 487F4905  bl 0x82df3428
	ctx.lr = 0x825FEB28;
	sub_82DF3428(ctx, base);
	// 825FEB28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEB2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEB30: 388B1CA0  addi r4, r11, 0x1ca0
	ctx.r[4].s64 = ctx.r[11].s64 + 7328;
	// 825FEB34: 487F4ED5  bl 0x82df3a08
	ctx.lr = 0x825FEB38;
	sub_82DF3A08(ctx, base);
	// 825FEB38: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825FEB3C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FEB40: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FEB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FEB48: 4BFAD279  bl 0x825abdc0
	ctx.lr = 0x825FEB4C;
	sub_825ABDC0(ctx, base);
	// 825FEB4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEB50: 487F48D9  bl 0x82df3428
	ctx.lr = 0x825FEB54;
	sub_82DF3428(ctx, base);
	// 825FEB54: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEB5C: 388B1C8C  addi r4, r11, 0x1c8c
	ctx.r[4].s64 = ctx.r[11].s64 + 7308;
	// 825FEB60: 487F4EA9  bl 0x82df3a08
	ctx.lr = 0x825FEB64;
	sub_82DF3A08(ctx, base);
	// 825FEB64: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FEB68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FEB6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FEB70: 4BFAD251  bl 0x825abdc0
	ctx.lr = 0x825FEB74;
	sub_825ABDC0(ctx, base);
	// 825FEB74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEB78: 487F48B1  bl 0x82df3428
	ctx.lr = 0x825FEB7C;
	sub_82DF3428(ctx, base);
	// 825FEB7C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEB80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEB84: 388B1C7C  addi r4, r11, 0x1c7c
	ctx.r[4].s64 = ctx.r[11].s64 + 7292;
	// 825FEB88: 487F4E81  bl 0x82df3a08
	ctx.lr = 0x825FEB8C;
	sub_82DF3A08(ctx, base);
	// 825FEB8C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FEB90: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825FEB94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FEB98: 4BFAD229  bl 0x825abdc0
	ctx.lr = 0x825FEB9C;
	sub_825ABDC0(ctx, base);
	// 825FEB9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEBA0: 487F4889  bl 0x82df3428
	ctx.lr = 0x825FEBA4;
	sub_82DF3428(ctx, base);
	// 825FEBA4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 825FEBA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEBAC: 388B44A0  addi r4, r11, 0x44a0
	ctx.r[4].s64 = ctx.r[11].s64 + 17568;
	// 825FEBB0: 487F4E59  bl 0x82df3a08
	ctx.lr = 0x825FEBB4;
	sub_82DF3A08(ctx, base);
	// 825FEBB4: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825FEBB8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825FEBBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FEBC0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825FEBC4: 419A0024  beq cr6, 0x825febe8
	if ctx.cr[6].eq {
	pc = 0x825FEBE8; continue 'dispatch;
	}
	// 825FEBC8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FEBCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FEBD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FEBD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FEBD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FEBDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FEBE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FEBE4: 4082FFE8  bne 0x825febcc
	if !ctx.cr[0].eq {
	pc = 0x825FEBCC; continue 'dispatch;
	}
	// 825FEBE8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825FEBEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FEBF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEBF4: 4BFA351D  bl 0x825a2110
	ctx.lr = 0x825FEBF8;
	sub_825A2110(ctx, base);
	// 825FEBF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEBFC: 487F482D  bl 0x82df3428
	ctx.lr = 0x825FEC00;
	sub_82DF3428(ctx, base);
	// 825FEC00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FEC04: 419A000C  beq cr6, 0x825fec10
	if ctx.cr[6].eq {
	pc = 0x825FEC10; continue 'dispatch;
	}
	// 825FEC08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FEC0C: 4BCC1C85  bl 0x822c0890
	ctx.lr = 0x825FEC10;
	sub_822C0890(ctx, base);
	// 825FEC10: 382101E0  addi r1, r1, 0x1e0
	ctx.r[1].s64 = ctx.r[1].s64 + 480;
	// 825FEC14: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825FEC18: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825FEC1C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825FEC20: 48BA9598  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FEC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FEC28 size=1324
    let mut pc: u32 = 0x825FEC28;
    'dispatch: loop {
        match pc {
            0x825FEC28 => {
    //   block [0x825FEC28..0x825FF154)
	// 825FEC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FEC2C: 48BA9521  bl 0x831a814c
	ctx.lr = 0x825FEC30;
	sub_831A8130(ctx, base);
	// 825FEC30: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 825FEC34: 9421FDC0  stwu r1, -0x240(r1)
	ea = ctx.r[1].u32.wrapping_add(-576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FEC38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FEC3C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825FEC40: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825FEC44: 4BF12D95  bl 0x825119d8
	ctx.lr = 0x825FEC48;
	sub_825119D8(ctx, base);
	// 825FEC48: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FEC4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEC50: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 825FEC54: 487F4DB5  bl 0x82df3a08
	ctx.lr = 0x825FEC58;
	sub_82DF3A08(ctx, base);
	// 825FEC58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FEC5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FEC60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEC64: 4BF09B1D  bl 0x82508780
	ctx.lr = 0x825FEC68;
	sub_82508780(ctx, base);
	// 825FEC68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FEC6C: 487F47BD  bl 0x82df3428
	ctx.lr = 0x825FEC70;
	sub_82DF3428(ctx, base);
	// 825FEC70: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 825FEC74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FEC78: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 825FEC7C: 409A0008  bne cr6, 0x825fec84
	if !ctx.cr[6].eq {
	pc = 0x825FEC84; continue 'dispatch;
	}
	// 825FEC80: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825FEC84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEC88: 4BF09B19  bl 0x825087a0
	ctx.lr = 0x825FEC8C;
	sub_825087A0(ctx, base);
	// 825FEC8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FEC90: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FEC94: 4882BE55  bl 0x82e2aae8
	ctx.lr = 0x825FEC98;
	sub_82E2AAE8(ctx, base);
	// 825FEC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FEC9C: 4BFFF83D  bl 0x825fe4d8
	ctx.lr = 0x825FECA0;
	sub_825FE4D8(ctx, base);
	// 825FECA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FECA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FECA8: 388B1D30  addi r4, r11, 0x1d30
	ctx.r[4].s64 = ctx.r[11].s64 + 7472;
	// 825FECAC: 487F4D5D  bl 0x82df3a08
	ctx.lr = 0x825FECB0;
	sub_82DF3A08(ctx, base);
	// 825FECB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FECB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FECB8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825FECBC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825FECC0: 488301B1  bl 0x82e2ee70
	ctx.lr = 0x825FECC4;
	sub_82E2EE70(ctx, base);
	// 825FECC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FECC8: 487F4761  bl 0x82df3428
	ctx.lr = 0x825FECCC;
	sub_82DF3428(ctx, base);
	// 825FECCC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FECD0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FECD4: 3ACB1BE8  addi r22, r11, 0x1be8
	ctx.r[22].s64 = ctx.r[11].s64 + 7144;
	// 825FECD8: 38A0005C  li r5, 0x5c
	ctx.r[5].s64 = 92;
	// 825FECDC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825FECE0: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 825FECE4: 487F3705  bl 0x82df23e8
	ctx.lr = 0x825FECE8;
	sub_82DF23E8(ctx, base);
	// 825FECE8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FECEC: 41820014  beq 0x825fed00
	if ctx.cr[0].eq {
	pc = 0x825FED00; continue 'dispatch;
	}
	// 825FECF0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825FECF4: 48817B9D  bl 0x82e16890
	ctx.lr = 0x825FECF8;
	sub_82E16890(ctx, base);
	// 825FECF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FECFC: 48000008  b 0x825fed04
	pc = 0x825FED04; continue 'dispatch;
	// 825FED00: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825FED04: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 825FED08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FED0C: 4BD5E665  bl 0x8235d370
	ctx.lr = 0x825FED10;
	sub_8235D370(ctx, base);
	// 825FED10: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825FED14: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FED18: 38A0005D  li r5, 0x5d
	ctx.r[5].s64 = 93;
	// 825FED1C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825FED20: 487F36C9  bl 0x82df23e8
	ctx.lr = 0x825FED24;
	sub_82DF23E8(ctx, base);
	// 825FED24: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FED28: 41820018  beq 0x825fed40
	if ctx.cr[0].eq {
	pc = 0x825FED40; continue 'dispatch;
	}
	// 825FED2C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FED30: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 825FED34: 488143BD  bl 0x82e130f0
	ctx.lr = 0x825FED38;
	sub_82E130F0(ctx, base);
	// 825FED38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FED3C: 48000008  b 0x825fed44
	pc = 0x825FED44; continue 'dispatch;
	// 825FED40: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825FED44: 3B3F0110  addi r25, r31, 0x110
	ctx.r[25].s64 = ctx.r[31].s64 + 272;
	// 825FED48: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825FED4C: 4BCE3005  bl 0x822e1d50
	ctx.lr = 0x825FED50;
	sub_822E1D50(ctx, base);
	// 825FED50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FED54: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825FED58: 83BF0110  lwz r29, 0x110(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 825FED5C: 4BF133BD  bl 0x82512118
	ctx.lr = 0x825FED60;
	sub_82512118(ctx, base);
	// 825FED60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825FED64: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FED68: 488140C9  bl 0x82e12e30
	ctx.lr = 0x825FED6C;
	sub_82E12E30(ctx, base);
	// 825FED6C: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825FED70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FED74: 419A0008  beq cr6, 0x825fed7c
	if ctx.cr[6].eq {
	pc = 0x825FED7C; continue 'dispatch;
	}
	// 825FED78: 4BCC1B19  bl 0x822c0890
	ctx.lr = 0x825FED7C;
	sub_822C0890(ctx, base);
	// 825FED7C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FED80: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FED84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FED88: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825FED8C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825FED90: 419A0024  beq cr6, 0x825fedb4
	if ctx.cr[6].eq {
	pc = 0x825FEDB4; continue 'dispatch;
	}
	// 825FED94: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825FED98: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FED9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FEDA0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FEDA4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FEDA8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FEDAC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FEDB0: 4082FFE8  bne 0x825fed98
	if !ctx.cr[0].eq {
	pc = 0x825FED98; continue 'dispatch;
	}
	// 825FEDB4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825FEDB8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FEDBC: 488162F5  bl 0x82e150b0
	ctx.lr = 0x825FEDC0;
	sub_82E150B0(ctx, base);
	// 825FEDC0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 825FEDC4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FEDC8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FEDCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FEDD0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 825FEDD4: 4BF11D85  bl 0x82510b58
	ctx.lr = 0x825FEDD8;
	sub_82510B58(ctx, base);
	// 825FEDD8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825FEDDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FEDE0: 419A0008  beq cr6, 0x825fede8
	if ctx.cr[6].eq {
	pc = 0x825FEDE8; continue 'dispatch;
	}
	// 825FEDE4: 4BCC1AAD  bl 0x822c0890
	ctx.lr = 0x825FEDE8;
	sub_822C0890(ctx, base);
	// 825FEDE8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825FEDEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FEDF0: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 825FEDF4: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 825FEDF8: 487F35F1  bl 0x82df23e8
	ctx.lr = 0x825FEDFC;
	sub_82DF23E8(ctx, base);
	// 825FEDFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FEE00: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825FEE04: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FEE08: 4182003C  beq 0x825fee44
	if ctx.cr[0].eq {
	pc = 0x825FEE44; continue 'dispatch;
	}
	// 825FEE0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 825FEE10: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825FEE14: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 825FEE18: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825FEE1C: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 825FEE20: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825FEE24: C00BD5B8  lfs f0, -0x2a48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FEE28: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825FEE2C: 4887D1AD  bl 0x82e7bfd8
	ctx.lr = 0x825FEE30;
	sub_82E7BFD8(ctx, base);
	// 825FEE30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FEE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEE38: 488142B9  bl 0x82e130f0
	ctx.lr = 0x825FEE3C;
	sub_82E130F0(ctx, base);
	// 825FEE3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FEE40: 48000008  b 0x825fee48
	pc = 0x825FEE48; continue 'dispatch;
	// 825FEE44: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825FEE48: 3BDF0118  addi r30, r31, 0x118
	ctx.r[30].s64 = ctx.r[31].s64 + 280;
	// 825FEE4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FEE50: 4BCE2F01  bl 0x822e1d50
	ctx.lr = 0x825FEE54;
	sub_822E1D50(ctx, base);
	// 825FEE54: 809F0118  lwz r4, 0x118(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 825FEE58: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FEE5C: 48813FD5  bl 0x82e12e30
	ctx.lr = 0x825FEE60;
	sub_82E12E30(ctx, base);
	// 825FEE60: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 825FEE64: 488CDB85  bl 0x82ecc9e8
	ctx.lr = 0x825FEE68;
	sub_82ECC9E8(ctx, base);
	// 825FEE68: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 825FEE6C: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FEE70: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 825FEE74: 996101C0  stb r11, 0x1c0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[11].u8 ) };
	// 825FEE78: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 825FEE7C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825FEE80: 92A10050  stw r21, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[21].u32 ) };
	// 825FEE84: 7C7BE02E  lwzx r3, r27, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 825FEE88: 488A18A9  bl 0x82ea0730
	ctx.lr = 0x825FEE8C;
	sub_82EA0730(ctx, base);
	// 825FEE8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FEE90: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 825FEE94: 396B1D20  addi r11, r11, 0x1d20
	ctx.r[11].s64 = ctx.r[11].s64 + 7456;
	// 825FEE98: 3AE00030  li r23, 0x30
	ctx.r[23].s64 = 48;
	// 825FEE9C: 3F408332  lis r26, -0x7cce
	ctx.r[26].s64 = -2093875200;
	// 825FEEA0: B2E30004  sth r23, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[23].u16 ) };
	// 825FEEA4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825FEEA8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FF158 size=424
    let mut pc: u32 = 0x825FF158;
    'dispatch: loop {
        match pc {
            0x825FF158 => {
    //   block [0x825FF158..0x825FF300)
	// 825FF158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF15C: 48BA9009  bl 0x831a8164
	ctx.lr = 0x825FF160;
	sub_831A8130(ctx, base);
	// 825FF160: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF164: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF168: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825FF16C: 3BCB1BE8  addi r30, r11, 0x1be8
	ctx.r[30].s64 = ctx.r[11].s64 + 7144;
	// 825FF170: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825FF174: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FF178: 38A0002F  li r5, 0x2f
	ctx.r[5].s64 = 47;
	// 825FF17C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825FF180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FF184: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 825FF188: 487F3261  bl 0x82df23e8
	ctx.lr = 0x825FF18C;
	sub_82DF23E8(ctx, base);
	// 825FF18C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FF190: 41820010  beq 0x825ff1a0
	if ctx.cr[0].eq {
	pc = 0x825FF1A0; continue 'dispatch;
	}
	// 825FF194: 4BFFEF35  bl 0x825fe0c8
	ctx.lr = 0x825FF198;
	sub_825FE0C8(ctx, base);
	// 825FF198: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FF19C: 48000008  b 0x825ff1a4
	pc = 0x825FF1A4; continue 'dispatch;
	// 825FF1A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FF1A4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825FF1A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF1AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FF1B0: 4BFFEB81  bl 0x825fdd30
	ctx.lr = 0x825FF1B4;
	sub_825FDD30(ctx, base);
	// 825FF1B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FF1B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF1BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825FF1C0: 4BCC0E41  bl 0x822c0000
	ctx.lr = 0x825FF1C4;
	sub_822C0000(ctx, base);
	// 825FF1C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825FF1C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825FF1CC: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 825FF1D0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825FF1D4: 4BCC1205  bl 0x822c03d8
	ctx.lr = 0x825FF1D8;
	sub_822C03D8(ctx, base);
	// 825FF1D8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825FF1DC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825FF1E0: 418200B4  beq 0x825ff294
	if ctx.cr[0].eq {
	pc = 0x825FF294; continue 'dispatch;
	}
	// 825FF1E4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825FF1E8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825FF1EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825FF1F0: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 825FF1F4: 409A0008  bne cr6, 0x825ff1fc
	if !ctx.cr[6].eq {
	pc = 0x825FF1FC; continue 'dispatch;
	}
	// 825FF1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF1FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825FF200: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FF204: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825FF208: 419A0024  beq cr6, 0x825ff22c
	if ctx.cr[6].eq {
	pc = 0x825FF22C; continue 'dispatch;
	}
	// 825FF20C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FF210: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825FF214: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FF218: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825FF21C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825FF220: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FF224: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FF228: 4082FFE8  bne 0x825ff210
	if !ctx.cr[0].eq {
	pc = 0x825FF210; continue 'dispatch;
	}
	// 825FF22C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825FF230: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FF234: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825FF238: 419A0024  beq cr6, 0x825ff25c
	if ctx.cr[6].eq {
	pc = 0x825FF25C; continue 'dispatch;
	}
	// 825FF23C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 825FF240: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825FF244: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FF248: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825FF24C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825FF250: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825FF254: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825FF258: 4082FFE8  bne 0x825ff240
	if !ctx.cr[0].eq {
	pc = 0x825FF240; continue 'dispatch;
	}
	// 825FF25C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FF260: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825FF264: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825FF268: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 825FF26C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825FF270: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825FF274: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FF278: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FF27C: 48199CB5  bl 0x82798f30
	ctx.lr = 0x825FF280;
	sub_82798F30(ctx, base);
	// 825FF280: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FF284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF288: 4819C3E1  bl 0x8279b668
	ctx.lr = 0x825FF28C;
	sub_8279B668(ctx, base);
	// 825FF28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FF290: 48000008  b 0x825ff298
	pc = 0x825FF298; continue 'dispatch;
	// 825FF294: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825FF298: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825FF29C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 825FF2A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF2A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF2A8: 4BF989A9  bl 0x82597c50
	ctx.lr = 0x825FF2AC;
	sub_82597C50(ctx, base);
	// 825FF2AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FF2B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF2B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF2B8: 4BCC0D49  bl 0x822c0000
	ctx.lr = 0x825FF2BC;
	sub_822C0000(ctx, base);
	// 825FF2BC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FF2C0: 41820024  beq 0x825ff2e4
	if ctx.cr[0].eq {
	pc = 0x825FF2E4; continue 'dispatch;
	}
	// 825FF2C4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825FF2C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FF2CC: 419A0008  beq cr6, 0x825ff2d4
	if ctx.cr[6].eq {
	pc = 0x825FF2D4; continue 'dispatch;
	}
	// 825FF2D0: 4BCC15C1  bl 0x822c0890
	ctx.lr = 0x825FF2D4;
	sub_822C0890(ctx, base);
	// 825FF2D4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825FF2D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FF2DC: 419A0008  beq cr6, 0x825ff2e4
	if ctx.cr[6].eq {
	pc = 0x825FF2E4; continue 'dispatch;
	}
	// 825FF2E0: 4BCC15B1  bl 0x822c0890
	ctx.lr = 0x825FF2E4;
	sub_822C0890(ctx, base);
	// 825FF2E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FF2E8: 419A000C  beq cr6, 0x825ff2f4
	if ctx.cr[6].eq {
	pc = 0x825FF2F4; continue 'dispatch;
	}
	// 825FF2EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825FF2F0: 4BCC15A1  bl 0x822c0890
	ctx.lr = 0x825FF2F4;
	sub_822C0890(ctx, base);
	// 825FF2F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825FF2F8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825FF2FC: 48BA8EB8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF300 size=140
    let mut pc: u32 = 0x825FF300;
    'dispatch: loop {
        match pc {
            0x825FF300 => {
    //   block [0x825FF300..0x825FF38C)
	// 825FF300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF30C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF314: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF318: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FF31C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FF320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF324: 388B1D60  addi r4, r11, 0x1d60
	ctx.r[4].s64 = ctx.r[11].s64 + 7520;
	// 825FF328: 487F46E1  bl 0x82df3a08
	ctx.lr = 0x825FF32C;
	sub_82DF3A08(ctx, base);
	// 825FF32C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FF330: 38BF0144  addi r5, r31, 0x144
	ctx.r[5].s64 = ctx.r[31].s64 + 324;
	// 825FF334: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF338: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FF33C: 4BFF8D4D  bl 0x825f8088
	ctx.lr = 0x825FF340;
	sub_825F8088(ctx, base);
	// 825FF340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF344: 487F40E5  bl 0x82df3428
	ctx.lr = 0x825FF348;
	sub_82DF3428(ctx, base);
	// 825FF348: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF34C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF350: 388B1D54  addi r4, r11, 0x1d54
	ctx.r[4].s64 = ctx.r[11].s64 + 7508;
	// 825FF354: 487F46B5  bl 0x82df3a08
	ctx.lr = 0x825FF358;
	sub_82DF3A08(ctx, base);
	// 825FF358: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825FF35C: 38BF0145  addi r5, r31, 0x145
	ctx.r[5].s64 = ctx.r[31].s64 + 325;
	// 825FF360: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF364: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FF368: 4BFF8D21  bl 0x825f8088
	ctx.lr = 0x825FF36C;
	sub_825F8088(ctx, base);
	// 825FF36C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF370: 487F40B9  bl 0x82df3428
	ctx.lr = 0x825FF374;
	sub_82DF3428(ctx, base);
	// 825FF374: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FF378: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF37C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF380: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF390 size=220
    let mut pc: u32 = 0x825FF390;
    'dispatch: loop {
        match pc {
            0x825FF390 => {
    //   block [0x825FF390..0x825FF46C)
	// 825FF390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF394: 48BA8DD5  bl 0x831a8168
	ctx.lr = 0x825FF398;
	sub_831A8130(ctx, base);
	// 825FF398: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF39C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825FF3A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FF3A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF3A8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825FF3AC: 41820038  beq 0x825ff3e4
	if ctx.cr[0].eq {
	pc = 0x825FF3E4; continue 'dispatch;
	}
	// 825FF3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF3B4: 48BAA5D5  bl 0x831a9988
	ctx.lr = 0x825FF3B8;
	sub_831A9988(ctx, base);
	// 825FF3B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 825FF3BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FF3C0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 825FF3C4: 48BA8D35  bl 0x831a80f8
	ctx.lr = 0x825FF3C8;
	sub_831A80F8(ctx, base);
	// 825FF3C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FF3CC: 41820018  beq 0x825ff3e4
	if ctx.cr[0].eq {
	pc = 0x825FF3E4; continue 'dispatch;
	}
	// 825FF3D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF3D4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825FF3D8: 4BFFF2D9  bl 0x825fe6b0
	ctx.lr = 0x825FF3DC;
	sub_825FE6B0(ctx, base);
	// 825FF3DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825FF3E0: 48000084  b 0x825ff464
	pc = 0x825FF464; continue 'dispatch;
	// 825FF3E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FF3E8: 419A006C  beq cr6, 0x825ff454
	if ctx.cr[6].eq {
	pc = 0x825FF454; continue 'dispatch;
	}
	// 825FF3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF3F0: 48BAA599  bl 0x831a9988
	ctx.lr = 0x825FF3F4;
	sub_831A9988(ctx, base);
	// 825FF3F4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FF3F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FF3FC: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 825FF400: 48BA8CF9  bl 0x831a80f8
	ctx.lr = 0x825FF404;
	sub_831A80F8(ctx, base);
	// 825FF404: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FF408: 41820014  beq 0x825ff41c
	if ctx.cr[0].eq {
	pc = 0x825FF41C; continue 'dispatch;
	}
	// 825FF40C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF410: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825FF414: 48004CCD  bl 0x826040e0
	ctx.lr = 0x825FF418;
	sub_826040E0(ctx, base);
	// 825FF418: 4BFFFFC4  b 0x825ff3dc
	pc = 0x825FF3DC; continue 'dispatch;
	// 825FF41C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825FF420: 419A0034  beq cr6, 0x825ff454
	if ctx.cr[6].eq {
	pc = 0x825FF454; continue 'dispatch;
	}
	// 825FF424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF428: 48BAA561  bl 0x831a9988
	ctx.lr = 0x825FF42C;
	sub_831A9988(ctx, base);
	// 825FF42C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 825FF430: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FF434: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 825FF438: 48BA8CC1  bl 0x831a80f8
	ctx.lr = 0x825FF43C;
	sub_831A80F8(ctx, base);
	// 825FF43C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825FF440: 41820014  beq 0x825ff454
	if ctx.cr[0].eq {
	pc = 0x825FF454; continue 'dispatch;
	}
	// 825FF444: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF448: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 825FF44C: 4BFFEA75  bl 0x825fdec0
	ctx.lr = 0x825FF450;
	sub_825FDEC0(ctx, base);
	// 825FF450: 4BFFFF8C  b 0x825ff3dc
	pc = 0x825FF3DC; continue 'dispatch;
	// 825FF454: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825FF458: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825FF45C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF460: 4BF131B9  bl 0x82512618
	ctx.lr = 0x825FF464;
	sub_82512618(ctx, base);
	// 825FF464: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FF468: 48BA8D50  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FF470 size=76
    let mut pc: u32 = 0x825FF470;
    'dispatch: loop {
        match pc {
            0x825FF470 => {
    //   block [0x825FF470..0x825FF4BC)
	// 825FF470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF47C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FF488: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825FF48C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825FF490: 4885D9E9  bl 0x82e5ce78
	ctx.lr = 0x825FF494;
	sub_82E5CE78(ctx, base);
	// 825FF494: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FF498: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FF49C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 825FF4A0: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825FF4A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FF4A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF4AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF4B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF4B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF4B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825FF4C0 size=44
    let mut pc: u32 = 0x825FF4C0;
    'dispatch: loop {
        match pc {
            0x825FF4C0 => {
    //   block [0x825FF4C0..0x825FF4EC)
	// 825FF4C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FF4C4: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FF4C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825FF4CC: C1AB0070  lfs f13, 0x70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FF4D0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825FF4D4: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825FF4D8: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FF4DC: C1AB0070  lfs f13, 0x70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FF4E0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 825FF4E4: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825FF4E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FF4F0 size=12
    let mut pc: u32 = 0x825FF4F0;
    'dispatch: loop {
        match pc {
            0x825FF4F0 => {
    //   block [0x825FF4F0..0x825FF4FC)
	// 825FF4F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF4F4: 9163018C  stw r11, 0x18c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 825FF4F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FF500 size=108
    let mut pc: u32 = 0x825FF500;
    'dispatch: loop {
        match pc {
            0x825FF500 => {
    //   block [0x825FF500..0x825FF56C)
	// 825FF500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF508: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF50C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF510: 80630180  lwz r3, 0x180(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(384 as u32) ) } as u64;
	// 825FF514: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF518: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF51C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825FF520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FF524: 4E800421  bctrl
	ctx.lr = 0x825FF528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FF528: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825FF52C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825FF530: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FF534: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FF538: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FF53C: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825FF540: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825FF544: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825FF548: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825FF54C: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825FF550: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FF570 size=188
    let mut pc: u32 = 0x825FF570;
    'dispatch: loop {
        match pc {
            0x825FF570 => {
    //   block [0x825FF570..0x825FF62C)
	// 825FF570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF574: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF578: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF57C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF580: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF584: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FF588: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825FF58C: 81640224  lwz r11, 0x224(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FF590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF594: 419A0080  beq cr6, 0x825ff614
	if ctx.cr[6].eq {
	pc = 0x825FF614; continue 'dispatch;
	}
	// 825FF598: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 825FF59C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FF5A0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 825FF5A4: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 825FF5A8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 825FF5AC: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 825FF5B0: 4BF0FF19  bl 0x8250f4c8
	ctx.lr = 0x825FF5B4;
	sub_8250F4C8(ctx, base);
	// 825FF5B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF5BC: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 825FF5C0: 409A0008  bne cr6, 0x825ff5c8
	if !ctx.cr[6].eq {
	pc = 0x825FF5C8; continue 'dispatch;
	}
	// 825FF5C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825FF5C8: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825FF5CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FF5D0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 825FF5D4: 83CB0224  lwz r30, 0x224(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FF5D8: 4BF093D9  bl 0x825089b0
	ctx.lr = 0x825FF5DC;
	sub_825089B0(ctx, base);
	// 825FF5DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FF5E0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 825FF5E4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825FF5E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FF5EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF5F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825FF5F4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FF5F8: C04A9534  lfs f2, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 825FF5FC: C06908A8  lfs f3, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 825FF600: 4BCD16B1  bl 0x822d0cb0
	ctx.lr = 0x825FF604;
	sub_822D0CB0(ctx, base);
	// 825FF604: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825FF608: 487F2689  bl 0x82df1c90
	ctx.lr = 0x825FF60C;
	sub_82DF1C90(ctx, base);
	// 825FF60C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FF610: 487F2681  bl 0x82df1c90
	ctx.lr = 0x825FF614;
	sub_82DF1C90(ctx, base);
	// 825FF614: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825FF618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF61C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF630 size=196
    let mut pc: u32 = 0x825FF630;
    'dispatch: loop {
        match pc {
            0x825FF630 => {
    //   block [0x825FF630..0x825FF6F4)
	// 825FF630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FF648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF64C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FF650: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF654: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF658: 4BCC12E1  bl 0x822c0938
	ctx.lr = 0x825FF65C;
	sub_822C0938(ctx, base);
	// 825FF65C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FF660: 41820028  beq 0x825ff688
	if ctx.cr[0].eq {
	pc = 0x825FF688; continue 'dispatch;
	}
	// 825FF664: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF668: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FF66C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FF670: 392B1DBC  addi r9, r11, 0x1dbc
	ctx.r[9].s64 = ctx.r[11].s64 + 7612;
	// 825FF674: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FF678: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FF67C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FF680: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FF684: 48000008  b 0x825ff68c
	pc = 0x825FF68C; continue 'dispatch;
	// 825FF688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF68C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF694: 409A0044  bne cr6, 0x825ff6d8
	if !ctx.cr[6].eq {
	pc = 0x825FF6D8; continue 'dispatch;
	}
	// 825FF698: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FF69C: 419A001C  beq cr6, 0x825ff6b8
	if ctx.cr[6].eq {
	pc = 0x825FF6B8; continue 'dispatch;
	}
	// 825FF6A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF6A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FF6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF6AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF6B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FF6B4: 4E800421  bctrl
	ctx.lr = 0x825FF6B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FF6B8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FF6BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FF6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF6C4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FF6C8: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FF6CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FF6D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FF6D4: 4BCC092D  bl 0x822c0000
	ctx.lr = 0x825FF6D8;
	sub_822C0000(ctx, base);
	// 825FF6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FF6E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF6E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF6E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF6EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF6F8 size=196
    let mut pc: u32 = 0x825FF6F8;
    'dispatch: loop {
        match pc {
            0x825FF6F8 => {
    //   block [0x825FF6F8..0x825FF7BC)
	// 825FF6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF70C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FF710: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF714: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FF718: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF71C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF720: 4BCC1219  bl 0x822c0938
	ctx.lr = 0x825FF724;
	sub_822C0938(ctx, base);
	// 825FF724: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FF728: 41820028  beq 0x825ff750
	if ctx.cr[0].eq {
	pc = 0x825FF750; continue 'dispatch;
	}
	// 825FF72C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF730: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FF734: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FF738: 392B1DD0  addi r9, r11, 0x1dd0
	ctx.r[9].s64 = ctx.r[11].s64 + 7632;
	// 825FF73C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FF740: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FF744: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FF748: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FF74C: 48000008  b 0x825ff754
	pc = 0x825FF754; continue 'dispatch;
	// 825FF750: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF754: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF75C: 409A0044  bne cr6, 0x825ff7a0
	if !ctx.cr[6].eq {
	pc = 0x825FF7A0; continue 'dispatch;
	}
	// 825FF760: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FF764: 419A001C  beq cr6, 0x825ff780
	if ctx.cr[6].eq {
	pc = 0x825FF780; continue 'dispatch;
	}
	// 825FF768: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF76C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FF770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF774: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FF778: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FF77C: 4E800421  bctrl
	ctx.lr = 0x825FF780;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FF780: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FF784: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FF788: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF78C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FF790: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FF794: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FF798: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FF79C: 4BCC0865  bl 0x822c0000
	ctx.lr = 0x825FF7A0;
	sub_822C0000(ctx, base);
	// 825FF7A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF7A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FF7A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF7AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF7B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF7B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF7B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF7C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF7C0 size=196
    let mut pc: u32 = 0x825FF7C0;
    'dispatch: loop {
        match pc {
            0x825FF7C0 => {
    //   block [0x825FF7C0..0x825FF884)
	// 825FF7C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF7C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF7C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF7CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF7D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF7D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FF7D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF7DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FF7E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF7E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF7E8: 4BCC1151  bl 0x822c0938
	ctx.lr = 0x825FF7EC;
	sub_822C0938(ctx, base);
	// 825FF7EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FF7F0: 41820028  beq 0x825ff818
	if ctx.cr[0].eq {
	pc = 0x825FF818; continue 'dispatch;
	}
	// 825FF7F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF7F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FF7FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FF800: 392B1DE4  addi r9, r11, 0x1de4
	ctx.r[9].s64 = ctx.r[11].s64 + 7652;
	// 825FF804: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FF808: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FF80C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FF810: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FF814: 48000008  b 0x825ff81c
	pc = 0x825FF81C; continue 'dispatch;
	// 825FF818: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF81C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF824: 409A0044  bne cr6, 0x825ff868
	if !ctx.cr[6].eq {
	pc = 0x825FF868; continue 'dispatch;
	}
	// 825FF828: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FF82C: 419A001C  beq cr6, 0x825ff848
	if ctx.cr[6].eq {
	pc = 0x825FF848; continue 'dispatch;
	}
	// 825FF830: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF834: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FF838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF83C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FF844: 4E800421  bctrl
	ctx.lr = 0x825FF848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FF848: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FF84C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FF850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF854: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FF858: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FF85C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FF860: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FF864: 4BCC079D  bl 0x822c0000
	ctx.lr = 0x825FF868;
	sub_822C0000(ctx, base);
	// 825FF868: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF86C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FF870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF878: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF87C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF888 size=196
    let mut pc: u32 = 0x825FF888;
    'dispatch: loop {
        match pc {
            0x825FF888 => {
    //   block [0x825FF888..0x825FF94C)
	// 825FF888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF89C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FF8A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF8A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FF8A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF8AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF8B0: 4BCC1089  bl 0x822c0938
	ctx.lr = 0x825FF8B4;
	sub_822C0938(ctx, base);
	// 825FF8B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FF8B8: 41820028  beq 0x825ff8e0
	if ctx.cr[0].eq {
	pc = 0x825FF8E0; continue 'dispatch;
	}
	// 825FF8BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF8C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FF8C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FF8C8: 392B1DF8  addi r9, r11, 0x1df8
	ctx.r[9].s64 = ctx.r[11].s64 + 7672;
	// 825FF8CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FF8D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FF8D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FF8D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FF8DC: 48000008  b 0x825ff8e4
	pc = 0x825FF8E4; continue 'dispatch;
	// 825FF8E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF8E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF8EC: 409A0044  bne cr6, 0x825ff930
	if !ctx.cr[6].eq {
	pc = 0x825FF930; continue 'dispatch;
	}
	// 825FF8F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FF8F4: 419A001C  beq cr6, 0x825ff910
	if ctx.cr[6].eq {
	pc = 0x825FF910; continue 'dispatch;
	}
	// 825FF8F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF8FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FF900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF904: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825FF908: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FF90C: 4E800421  bctrl
	ctx.lr = 0x825FF910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FF910: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FF914: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FF918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF91C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FF920: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FF924: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FF928: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FF92C: 4BCC06D5  bl 0x822c0000
	ctx.lr = 0x825FF930;
	sub_822C0000(ctx, base);
	// 825FF930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF934: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FF938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FF93C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FF940: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FF944: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FF948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FF950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FF950 size=196
    let mut pc: u32 = 0x825FF950;
    'dispatch: loop {
        match pc {
            0x825FF950 => {
    //   block [0x825FF950..0x825FFA14)
	// 825FF950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FF954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FF958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FF95C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FF960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FF964: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FF968: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF96C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FF970: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FF974: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF978: 4BCC0FC1  bl 0x822c0938
	ctx.lr = 0x825FF97C;
	sub_822C0938(ctx, base);
	// 825FF97C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FF980: 41820028  beq 0x825ff9a8
	if ctx.cr[0].eq {
	pc = 0x825FF9A8; continue 'dispatch;
	}
	// 825FF984: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FF988: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FF98C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FF990: 392B1E0C  addi r9, r11, 0x1e0c
	ctx.r[9].s64 = ctx.r[11].s64 + 7692;
	// 825FF994: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FF998: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FF99C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FF9A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FF9A4: 48000008  b 0x825ff9ac
	pc = 0x825FF9AC; continue 'dispatch;
	// 825FF9A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FF9AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FF9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FF9B4: 409A0044  bne cr6, 0x825ff9f8
	if !ctx.cr[6].eq {
	pc = 0x825FF9F8; continue 'dispatch;
	}
	// 825FF9B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FF9BC: 419A001C  beq cr6, 0x825ff9d8
	if ctx.cr[6].eq {
	pc = 0x825FF9D8; continue 'dispatch;
	}
	// 825FF9C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF9C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FF9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FF9CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FF9D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FF9D4: 4E800421  bctrl
	ctx.lr = 0x825FF9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FF9D8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FF9DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FF9E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FF9E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FF9E8: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FF9EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FF9F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FF9F4: 4BCC060D  bl 0x822c0000
	ctx.lr = 0x825FF9F8;
	sub_822C0000(ctx, base);
	// 825FF9F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FF9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FFA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FFA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FFA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FFA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FFA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FFA18 size=196
    let mut pc: u32 = 0x825FFA18;
    'dispatch: loop {
        match pc {
            0x825FFA18 => {
    //   block [0x825FFA18..0x825FFADC)
	// 825FFA18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FFA1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FFA20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FFA24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FFA28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FFA2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FFA30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FFA34: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FFA38: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FFA3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FFA40: 4BCC0EF9  bl 0x822c0938
	ctx.lr = 0x825FFA44;
	sub_822C0938(ctx, base);
	// 825FFA44: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FFA48: 41820028  beq 0x825ffa70
	if ctx.cr[0].eq {
	pc = 0x825FFA70; continue 'dispatch;
	}
	// 825FFA4C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FFA50: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FFA54: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FFA58: 392B1E20  addi r9, r11, 0x1e20
	ctx.r[9].s64 = ctx.r[11].s64 + 7712;
	// 825FFA5C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FFA60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FFA64: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FFA68: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FFA6C: 48000008  b 0x825ffa74
	pc = 0x825FFA74; continue 'dispatch;
	// 825FFA70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FFA74: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FFA78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FFA7C: 409A0044  bne cr6, 0x825ffac0
	if !ctx.cr[6].eq {
	pc = 0x825FFAC0; continue 'dispatch;
	}
	// 825FFA80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FFA84: 419A001C  beq cr6, 0x825ffaa0
	if ctx.cr[6].eq {
	pc = 0x825FFAA0; continue 'dispatch;
	}
	// 825FFA88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FFA8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FFA90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FFA94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FFA98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FFA9C: 4E800421  bctrl
	ctx.lr = 0x825FFAA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FFAA0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FFAA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FFAA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FFAAC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FFAB0: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FFAB4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FFAB8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FFABC: 4BCC0545  bl 0x822c0000
	ctx.lr = 0x825FFAC0;
	sub_822C0000(ctx, base);
	// 825FFAC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FFAC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FFAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FFACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FFAD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FFAD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FFAD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFAE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FFAE0 size=196
    let mut pc: u32 = 0x825FFAE0;
    'dispatch: loop {
        match pc {
            0x825FFAE0 => {
    //   block [0x825FFAE0..0x825FFBA4)
	// 825FFAE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FFAE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FFAE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825FFAEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FFAF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FFAF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825FFAF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FFAFC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 825FFB00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825FFB04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FFB08: 4BCC0E31  bl 0x822c0938
	ctx.lr = 0x825FFB0C;
	sub_822C0938(ctx, base);
	// 825FFB0C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FFB10: 41820028  beq 0x825ffb38
	if ctx.cr[0].eq {
	pc = 0x825FFB38; continue 'dispatch;
	}
	// 825FFB14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FFB18: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825FFB1C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FFB20: 392B1E34  addi r9, r11, 0x1e34
	ctx.r[9].s64 = ctx.r[11].s64 + 7732;
	// 825FFB24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825FFB28: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825FFB2C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825FFB30: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825FFB34: 48000008  b 0x825ffb3c
	pc = 0x825FFB3C; continue 'dispatch;
	// 825FFB38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FFB3C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825FFB40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FFB44: 409A0044  bne cr6, 0x825ffb88
	if !ctx.cr[6].eq {
	pc = 0x825FFB88; continue 'dispatch;
	}
	// 825FFB48: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FFB4C: 419A001C  beq cr6, 0x825ffb68
	if ctx.cr[6].eq {
	pc = 0x825FFB68; continue 'dispatch;
	}
	// 825FFB50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FFB54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825FFB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FFB5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825FFB60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825FFB64: 4E800421  bctrl
	ctx.lr = 0x825FFB68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825FFB68: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 825FFB6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FFB70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825FFB74: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 825FFB78: 816BFB48  lwz r11, -0x4b8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1208 as u32) ) } as u64;
	// 825FFB7C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825FFB80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825FFB84: 4BCC047D  bl 0x822c0000
	ctx.lr = 0x825FFB88;
	sub_822C0000(ctx, base);
	// 825FFB88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825FFB8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825FFB90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FFB94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FFB98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825FFB9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FFBA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FFBA8 size=220
    let mut pc: u32 = 0x825FFBA8;
    'dispatch: loop {
        match pc {
            0x825FFBA8 => {
    //   block [0x825FFBA8..0x825FFC84)
	// 825FFBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FFBAC: 48BA85C1  bl 0x831a816c
	ctx.lr = 0x825FFBB0;
	sub_831A8130(ctx, base);
	// 825FFBB0: 9421FE20  stwu r1, -0x1e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-480 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FFBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FFBB8: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FFBBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825FFBC0: 419A00BC  beq cr6, 0x825ffc7c
	if ctx.cr[6].eq {
	pc = 0x825FFC7C; continue 'dispatch;
	}
	// 825FFBC4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825FFBC8: 4BF121D1  bl 0x82511d98
	ctx.lr = 0x825FFBCC;
	sub_82511D98(ctx, base);
	// 825FFBCC: 3BDF01A0  addi r30, r31, 0x1a0
	ctx.r[30].s64 = ctx.r[31].s64 + 416;
	// 825FFBD0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825FFBD4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825FFBD8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825FFBDC: 4BCC4D25  bl 0x822c4900
	ctx.lr = 0x825FFBE0;
	sub_822C4900(ctx, base);
	// 825FFBE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825FFBE4: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FFBE8: 4BCD0D81  bl 0x822d0968
	ctx.lr = 0x825FFBEC;
	sub_822D0968(ctx, base);
	// 825FFBEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FFBF0: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 825FFBF4: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FFBF8: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 825FFBFC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825FFC00: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FFC04: 4BCD051D  bl 0x822d0120
	ctx.lr = 0x825FFC08;
	sub_822D0120(ctx, base);
	// 825FFC08: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 825FFC0C: C03F014C  lfs f1, 0x14c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825FFC10: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825FFC14: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FFC18: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825FFC1C: 4BCD0505  bl 0x822d0120
	ctx.lr = 0x825FFC20;
	sub_822D0120(ctx, base);
	// 825FFC20: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 825FFC24: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825FFC28: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 825FFC2C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825FFC30: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825FFC34: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825FFC38: 3BA100C0  addi r29, r1, 0xc0
	ctx.r[29].s64 = ctx.r[1].s64 + 192;
	// 825FFC3C: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFC88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FFC88 size=396
    let mut pc: u32 = 0x825FFC88;
    'dispatch: loop {
        match pc {
            0x825FFC88 => {
    //   block [0x825FFC88..0x825FFE14)
	// 825FFC88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FFC8C: 48BA84DD  bl 0x831a8168
	ctx.lr = 0x825FFC90;
	sub_831A8130(ctx, base);
	// 825FFC90: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825FFC94: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FFC98: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825FFC9C: 807C0224  lwz r3, 0x224(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(548 as u32) ) } as u64;
	// 825FFCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFCA4: 419A0164  beq cr6, 0x825ffe08
	if ctx.cr[6].eq {
	pc = 0x825FFE08; continue 'dispatch;
	}
	// 825FFCA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FFCAC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825FFCB0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825FFCB4: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 825FFCB8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825FFCBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825FFCC0: 4BCD0461  bl 0x822d0120
	ctx.lr = 0x825FFCC4;
	sub_822D0120(ctx, base);
	// 825FFCC4: 897C0221  lbz r11, 0x221(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(545 as u32) ) } as u64;
	// 825FFCC8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 825FFCCC: 41820028  beq 0x825ffcf4
	if ctx.cr[0].eq {
	pc = 0x825FFCF4; continue 'dispatch;
	}
	// 825FFCD0: D3E10064  stfs f31, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825FFCD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825FFCD8: 4887D7B9  bl 0x82e7d490
	ctx.lr = 0x825FFCDC;
	sub_82E7D490(ctx, base);
	// 825FFCDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825FFCE0: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825FFCE4: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825FFCE8: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FFCEC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825FFCF0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825FFCF4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825FFCF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825FFCFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FFD00: 4887D621  bl 0x82e7d320
	ctx.lr = 0x825FFD04;
	sub_82E7D320(ctx, base);
	// 825FFD04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825FFD08: 4887D789  bl 0x82e7d490
	ctx.lr = 0x825FFD0C;
	sub_82E7D490(ctx, base);
	// 825FFD0C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 825FFD10: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 825FFD14: C0010070  lfs f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FFD18: 396B6880  addi r11, r11, 0x6880
	ctx.r[11].s64 = ctx.r[11].s64 + 26752;
	// 825FFD1C: C1A10090  lfs f13, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FFD20: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 825FFD24: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825FFD28: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 825FFD2C: C1610098  lfs f11, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825FFD30: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 825FFD34: C141009C  lfs f10, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825FFD38: 390100C0  addi r8, r1, 0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + 192;
	// 825FFD3C: C1210054  lfs f9, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825FFD40: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 825FFD44: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 825FFD48: 3BE00030  li r31, 0x30
	ctx.r[31].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825FFE18 size=252
    let mut pc: u32 = 0x825FFE18;
    'dispatch: loop {
        match pc {
            0x825FFE18 => {
    //   block [0x825FFE18..0x825FFF14)
	// 825FFE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FFE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FFE20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FFE24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FFE28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FFE2C: 4BF12505  bl 0x82512330
	ctx.lr = 0x825FFE30;
	sub_82512330(ctx, base);
	// 825FFE30: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FFE34: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 825FFE38: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 825FFE3C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 825FFE40: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 825FFE44: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825FFE48: 394A1EAC  addi r10, r10, 0x1eac
	ctx.r[10].s64 = ctx.r[10].s64 + 7852;
	// 825FFE4C: 39291E98  addi r9, r9, 0x1e98
	ctx.r[9].s64 = ctx.r[9].s64 + 7832;
	// 825FFE50: 39681EEC  addi r11, r8, 0x1eec
	ctx.r[11].s64 = ctx.r[8].s64 + 7916;
	// 825FFE54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825FFE58: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 825FFE5C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825FFE60: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 825FFE64: 4885DA6D  bl 0x82e5d8d0
	ctx.lr = 0x825FFE68;
	sub_82E5D8D0(ctx, base);
	// 825FFE68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 825FFE6C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825FFE70: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 825FFE74: 390B1DA4  addi r8, r11, 0x1da4
	ctx.r[8].s64 = ctx.r[11].s64 + 7588;
	// 825FFE78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825FFE7C: 911F00E8  stw r8, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 825FFE80: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 825FFE84: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825FFE88: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 825FFE8C: C1A9A1C4  lfs f13, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825FFE90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825FFE94: D01F014C  stfs f0, 0x14c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), tmp.u32 ) };
	// 825FFE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FFE9C: D1BF0150  stfs f13, 0x150(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), tmp.u32 ) };
	// 825FFEA0: D01F0154  stfs f0, 0x154(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 825FFEA4: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 825FFEA8: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 825FFEAC: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 825FFEB0: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 825FFEB4: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 825FFEB8: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 825FFEBC: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 825FFEC0: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825FFEC4: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 825FFEC8: 917F017C  stw r11, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 825FFECC: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 825FFED0: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 825FFED4: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 825FFED8: 911F0188  stw r8, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[8].u32 ) };
	// 825FFEDC: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 825FFEE0: 995F0220  stb r10, 0x220(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), ctx.r[10].u8 ) };
	// 825FFEE4: 997F0221  stb r11, 0x221(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(545 as u32), ctx.r[11].u8 ) };
	// 825FFEE8: 917F0224  stw r11, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 825FFEEC: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 825FFEF0: 917F022C  stw r11, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[11].u32 ) };
	// 825FFEF4: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 825FFEF8: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 825FFEFC: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 825FFF00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FFF04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FFF08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FFF0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825FFF10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFF18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FFF18 size=8
    let mut pc: u32 = 0x825FFF18;
    'dispatch: loop {
        match pc {
            0x825FFF18 => {
    //   block [0x825FFF18..0x825FFF20)
	// 825FFF18: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 825FFF1C: 480005E4  b 0x82600500
	sub_82600500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825FFF20 size=8
    let mut pc: u32 = 0x825FFF20;
    'dispatch: loop {
        match pc {
            0x825FFF20 => {
    //   block [0x825FFF20..0x825FFF28)
	// 825FFF20: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 825FFF24: 480005DC  b 0x82600500
	sub_82600500(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825FFF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825FFF28 size=220
    let mut pc: u32 = 0x825FFF28;
    'dispatch: loop {
        match pc {
            0x825FFF28 => {
    //   block [0x825FFF28..0x82600004)
	// 825FFF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825FFF2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825FFF30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825FFF34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825FFF38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825FFF3C: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 825FFF40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFF44: 419A0008  beq cr6, 0x825fff4c
	if ctx.cr[6].eq {
	pc = 0x825FFF4C; continue 'dispatch;
	}
	// 825FFF48: 4BCC0949  bl 0x822c0890
	ctx.lr = 0x825FFF4C;
	sub_822C0890(ctx, base);
	// 825FFF4C: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 825FFF50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFF54: 419A0008  beq cr6, 0x825fff5c
	if ctx.cr[6].eq {
	pc = 0x825FFF5C; continue 'dispatch;
	}
	// 825FFF58: 4BCC0939  bl 0x822c0890
	ctx.lr = 0x825FFF5C;
	sub_822C0890(ctx, base);
	// 825FFF5C: 807F0228  lwz r3, 0x228(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 825FFF60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFF64: 419A0008  beq cr6, 0x825fff6c
	if ctx.cr[6].eq {
	pc = 0x825FFF6C; continue 'dispatch;
	}
	// 825FFF68: 4BCC0929  bl 0x822c0890
	ctx.lr = 0x825FFF6C;
	sub_822C0890(ctx, base);
	// 825FFF6C: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 825FFF70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFF74: 419A0008  beq cr6, 0x825fff7c
	if ctx.cr[6].eq {
	pc = 0x825FFF7C; continue 'dispatch;
	}
	// 825FFF78: 4BCC0919  bl 0x822c0890
	ctx.lr = 0x825FFF7C;
	sub_822C0890(ctx, base);
	// 825FFF7C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 825FFF80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFF84: 419A0008  beq cr6, 0x825fff8c
	if ctx.cr[6].eq {
	pc = 0x825FFF8C; continue 'dispatch;
	}
	// 825FFF88: 4BCC0909  bl 0x822c0890
	ctx.lr = 0x825FFF8C;
	sub_822C0890(ctx, base);
	// 825FFF8C: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 825FFF90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFF94: 419A0008  beq cr6, 0x825fff9c
	if ctx.cr[6].eq {
	pc = 0x825FFF9C; continue 'dispatch;
	}
	// 825FFF98: 4BCC08F9  bl 0x822c0890
	ctx.lr = 0x825FFF9C;
	sub_822C0890(ctx, base);
	// 825FFF9C: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 825FFFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFFA4: 419A0008  beq cr6, 0x825fffac
	if ctx.cr[6].eq {
	pc = 0x825FFFAC; continue 'dispatch;
	}
	// 825FFFA8: 4BCC08E9  bl 0x822c0890
	ctx.lr = 0x825FFFAC;
	sub_822C0890(ctx, base);
	// 825FFFAC: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 825FFFB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFFB4: 419A0008  beq cr6, 0x825fffbc
	if ctx.cr[6].eq {
	pc = 0x825FFFBC; continue 'dispatch;
	}
	// 825FFFB8: 4BCC08D9  bl 0x822c0890
	ctx.lr = 0x825FFFBC;
	sub_822C0890(ctx, base);
	// 825FFFBC: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 825FFFC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825FFFC4: 419A0008  beq cr6, 0x825fffcc
	if ctx.cr[6].eq {
	pc = 0x825FFFCC; continue 'dispatch;
	}
	// 825FFFC8: 4BCC08C9  bl 0x822c0890
	ctx.lr = 0x825FFFCC;
	sub_822C0890(ctx, base);
	// 825FFFCC: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 825FFFD0: 4885D879  bl 0x82e5d848
	ctx.lr = 0x825FFFD4;
	sub_82E5D848(ctx, base);
	// 825FFFD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825FFFD8: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 825FFFDC: 409A0008  bne cr6, 0x825fffe4
	if !ctx.cr[6].eq {
	pc = 0x825FFFE4; continue 'dispatch;
	}
	// 825FFFE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825FFFE4: 481A7675  bl 0x827a7658
	ctx.lr = 0x825FFFE8;
	sub_827A7658(ctx, base);
	// 825FFFE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825FFFEC: 4BD4F365  bl 0x8234f350
	ctx.lr = 0x825FFFF0;
	sub_8234F350(ctx, base);
	// 825FFFF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825FFFF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825FFFF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825FFFFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82600008 size=268
    let mut pc: u32 = 0x82600008;
    'dispatch: loop {
        match pc {
            0x82600008 => {
    //   block [0x82600008..0x82600114)
	// 82600008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260000C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82600010: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82600014: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82600018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260001C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600020: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82600024: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82600028: 388B1F38  addi r4, r11, 0x1f38
	ctx.r[4].s64 = ctx.r[11].s64 + 7992;
	// 8260002C: 38A000F1  li r5, 0xf1
	ctx.r[5].s64 = 241;
	// 82600030: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82600034: 487F23B5  bl 0x82df23e8
	ctx.lr = 0x82600038;
	sub_82DF23E8(ctx, base);
	// 82600038: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8260003C: 41820024  beq 0x82600060
	if ctx.cr[0].eq {
	pc = 0x82600060; continue 'dispatch;
	}
	// 82600040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82600044: 4885650D  bl 0x82e56550
	ctx.lr = 0x82600048;
	sub_82E56550(ctx, base);
	// 82600048: 397EFF1C  addi r11, r30, -0xe4
	ctx.r[11].s64 = ctx.r[30].s64 + -228;
	// 8260004C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82600050: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82600054: 396A1D90  addi r11, r10, 0x1d90
	ctx.r[11].s64 = ctx.r[10].s64 + 7568;
	// 82600058: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260005C: 48000008  b 0x82600064
	pc = 0x82600064; continue 'dispatch;
	// 82600060: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82600064: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82600068: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260006C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600070: 4BFFF751  bl 0x825ff7c0
	ctx.lr = 0x82600074;
	sub_825FF7C0(ctx, base);
	// 82600074: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82600078: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260007C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600080: 4BCBFF81  bl 0x822c0000
	ctx.lr = 0x82600084;
	sub_822C0000(ctx, base);
	// 82600084: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82600088: 3BFE007C  addi r31, r30, 0x7c
	ctx.r[31].s64 = ctx.r[30].s64 + 124;
	// 8260008C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82600090: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82600094: 917E007C  stw r11, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82600098: 4BCC43C9  bl 0x822c4460
	ctx.lr = 0x8260009C;
	sub_822C4460(ctx, base);
	// 8260009C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826000A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826000A4: 419A0008  beq cr6, 0x826000ac
	if ctx.cr[6].eq {
	pc = 0x826000AC; continue 'dispatch;
	}
	// 826000A8: 4BCC07E9  bl 0x822c0890
	ctx.lr = 0x826000AC;
	sub_822C0890(ctx, base);
	// 826000AC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826000B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826000B4: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 826000B8: 487F3951  bl 0x82df3a08
	ctx.lr = 0x826000BC;
	sub_82DF3A08(ctx, base);
	// 826000BC: 389EFF1C  addi r4, r30, -0xe4
	ctx.r[4].s64 = ctx.r[30].s64 + -228;
	// 826000C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826000C4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826000C8: 4BF0F401  bl 0x8250f4c8
	ctx.lr = 0x826000CC;
	sub_8250F4C8(ctx, base);
	// 826000CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826000D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826000D4: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826000D8: 409A0008  bne cr6, 0x826000e0
	if !ctx.cr[6].eq {
	pc = 0x826000E0; continue 'dispatch;
	}
	// 826000DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826000E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826000E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826000E8: 4BF08699  bl 0x82508780
	ctx.lr = 0x826000EC;
	sub_82508780(ctx, base);
	// 826000EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826000F0: 487F1BA1  bl 0x82df1c90
	ctx.lr = 0x826000F4;
	sub_82DF1C90(ctx, base);
	// 826000F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826000F8: 487F3331  bl 0x82df3428
	ctx.lr = 0x826000FC;
	sub_82DF3428(ctx, base);
	// 826000FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82600100: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82600104: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82600108: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260010C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600110: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82600118 size=200
    let mut pc: u32 = 0x82600118;
    'dispatch: loop {
        match pc {
            0x82600118 => {
    //   block [0x82600118..0x826001E0)
	// 82600118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260011C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82600120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82600124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82600128: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260012C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82600130: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82600134: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82600138: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8260013C: 4BF0F38D  bl 0x8250f4c8
	ctx.lr = 0x82600140;
	sub_8250F4C8(ctx, base);
	// 82600140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82600148: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8260014C: 409A0008  bne cr6, 0x82600154
	if !ctx.cr[6].eq {
	pc = 0x82600154; continue 'dispatch;
	}
	// 82600150: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82600154: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82600158: 4BF0A3C1  bl 0x8250a518
	ctx.lr = 0x8260015C;
	sub_8250A518(ctx, base);
	// 8260015C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82600160: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82600164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600168: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260016C: 4BCE54FD  bl 0x822e5668
	ctx.lr = 0x82600170;
	sub_822E5668(ctx, base);
	// 82600170: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82600174: 3BFE0224  addi r31, r30, 0x224
	ctx.r[31].s64 = ctx.r[30].s64 + 548;
	// 82600178: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8260017C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82600180: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600184: 917E0224  stw r11, 0x224(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(548 as u32), ctx.r[11].u32 ) };
	// 82600188: 4BCC42D9  bl 0x822c4460
	ctx.lr = 0x8260018C;
	sub_822C4460(ctx, base);
	// 8260018C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82600190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600194: 419A0008  beq cr6, 0x8260019c
	if ctx.cr[6].eq {
	pc = 0x8260019C; continue 'dispatch;
	}
	// 82600198: 4BCC06F9  bl 0x822c0890
	ctx.lr = 0x8260019C;
	sub_822C0890(ctx, base);
	// 8260019C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826001A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826001A4: 419A0008  beq cr6, 0x826001ac
	if ctx.cr[6].eq {
	pc = 0x826001AC; continue 'dispatch;
	}
	// 826001A8: 4BCC06E9  bl 0x822c0890
	ctx.lr = 0x826001AC;
	sub_822C0890(ctx, base);
	// 826001AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826001B0: 487F1AE1  bl 0x82df1c90
	ctx.lr = 0x826001B4;
	sub_82DF1C90(ctx, base);
	// 826001B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826001B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826001BC: 419A000C  beq cr6, 0x826001c8
	if ctx.cr[6].eq {
	pc = 0x826001C8; continue 'dispatch;
	}
	// 826001C0: C03E014C  lfs f1, 0x14c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(332 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826001C4: 4BCCFD6D  bl 0x822cff30
	ctx.lr = 0x826001C8;
	sub_822CFF30(ctx, base);
	// 826001C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826001CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826001D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826001D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826001D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826001DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826001E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826001E0 size=236
    let mut pc: u32 = 0x826001E0;
    'dispatch: loop {
        match pc {
            0x826001E0 => {
    //   block [0x826001E0..0x826002CC)
	// 826001E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826001E4: 48BA7F89  bl 0x831a816c
	ctx.lr = 0x826001E8;
	sub_831A8130(ctx, base);
	// 826001E8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826001EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826001F0: 3BBE0234  addi r29, r30, 0x234
	ctx.r[29].s64 = ctx.r[30].s64 + 564;
	// 826001F4: 817E0234  lwz r11, 0x234(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(564 as u32) ) } as u64;
	// 826001F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826001FC: 409A00C8  bne cr6, 0x826002c4
	if !ctx.cr[6].eq {
	pc = 0x826002C4; continue 'dispatch;
	}
	// 82600200: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600208: 388B1F80  addi r4, r11, 0x1f80
	ctx.r[4].s64 = ctx.r[11].s64 + 8064;
	// 8260020C: 487F37FD  bl 0x82df3a08
	ctx.lr = 0x82600210;
	sub_82DF3A08(ctx, base);
	// 82600210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82600214: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82600218: 4BF0F2B1  bl 0x8250f4c8
	ctx.lr = 0x8260021C;
	sub_8250F4C8(ctx, base);
	// 8260021C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82600224: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82600228: 409A0008  bne cr6, 0x82600230
	if !ctx.cr[6].eq {
	pc = 0x82600230; continue 'dispatch;
	}
	// 8260022C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82600230: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82600234: 4BF0A71D  bl 0x8250a950
	ctx.lr = 0x82600238;
	sub_8250A950(ctx, base);
	// 82600238: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260023C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82600240: 3BEBFF40  addi r31, r11, -0xc0
	ctx.r[31].s64 = ctx.r[11].s64 + -192;
	// 82600244: 409A0008  bne cr6, 0x8260024c
	if !ctx.cr[6].eq {
	pc = 0x8260024C; continue 'dispatch;
	}
	// 82600248: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8260024C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82600250: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82600254: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82600258: 4BF11EC1  bl 0x82512118
	ctx.lr = 0x8260025C;
	sub_82512118(ctx, base);
	// 8260025C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600260: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82600264: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82600268: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8260026C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82600270: 481D4A41  bl 0x827d4cb0
	ctx.lr = 0x82600274;
	sub_827D4CB0(ctx, base);
	// 82600274: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82600278: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 8260027C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82600280: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600284: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82600288: 4BCC41D9  bl 0x822c4460
	ctx.lr = 0x8260028C;
	sub_822C4460(ctx, base);
	// 8260028C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82600290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600294: 419A0008  beq cr6, 0x8260029c
	if ctx.cr[6].eq {
	pc = 0x8260029C; continue 'dispatch;
	}
	// 82600298: 4BCC05F9  bl 0x822c0890
	ctx.lr = 0x8260029C;
	sub_822C0890(ctx, base);
	// 8260029C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826002A0: 487F19F1  bl 0x82df1c90
	ctx.lr = 0x826002A4;
	sub_82DF1C90(ctx, base);
	// 826002A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826002A8: 487F19E9  bl 0x82df1c90
	ctx.lr = 0x826002AC;
	sub_82DF1C90(ctx, base);
	// 826002AC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826002B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826002B4: 419A0008  beq cr6, 0x826002bc
	if ctx.cr[6].eq {
	pc = 0x826002BC; continue 'dispatch;
	}
	// 826002B8: 4BCC05D9  bl 0x822c0890
	ctx.lr = 0x826002BC;
	sub_822C0890(ctx, base);
	// 826002BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826002C0: 487F3169  bl 0x82df3428
	ctx.lr = 0x826002C4;
	sub_82DF3428(ctx, base);
	// 826002C4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 826002C8: 48BA7EF4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826002D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826002D0 size=88
    let mut pc: u32 = 0x826002D0;
    'dispatch: loop {
        match pc {
            0x826002D0 => {
    //   block [0x826002D0..0x82600328)
	// 826002D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826002D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826002D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826002DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826002E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826002E4: 807F0234  lwz r3, 0x234(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 826002E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826002EC: 419A0028  beq cr6, 0x82600314
	if ctx.cr[6].eq {
	pc = 0x82600314; continue 'dispatch;
	}
	// 826002F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826002F4: 4888144D  bl 0x82e81740
	ctx.lr = 0x826002F8;
	sub_82E81740(ctx, base);
	// 826002F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826002FC: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82600300: 807F0238  lwz r3, 0x238(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 82600304: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600308: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 8260030C: 419A0008  beq cr6, 0x82600314
	if ctx.cr[6].eq {
	pc = 0x82600314; continue 'dispatch;
	}
	// 82600310: 4BCC0581  bl 0x822c0890
	ctx.lr = 0x82600314;
	sub_822C0890(ctx, base);
	// 82600314: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82600318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260031C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82600320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600324: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82600328 size=112
    let mut pc: u32 = 0x82600328;
    'dispatch: loop {
        match pc {
            0x82600328 => {
    //   block [0x82600328..0x82600398)
	// 82600328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260032C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82600330: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82600334: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82600338: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260033C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82600340: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82600344: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82600348: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8260034C: 4BFFF605  bl 0x825ff950
	ctx.lr = 0x82600350;
	sub_825FF950(ctx, base);
	// 82600350: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82600354: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82600358: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8260035C: 4BCBFCA5  bl 0x822c0000
	ctx.lr = 0x82600360;
	sub_822C0000(ctx, base);
	// 82600360: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82600364: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82600368: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260036C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82600370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600374: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82600378: 419A0008  beq cr6, 0x82600380
	if ctx.cr[6].eq {
	pc = 0x82600380; continue 'dispatch;
	}
	// 8260037C: 4BCC0515  bl 0x822c0890
	ctx.lr = 0x82600380;
	sub_822C0890(ctx, base);
	// 82600380: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82600384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82600388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260038C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82600390: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600394: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82600398 size=228
    let mut pc: u32 = 0x82600398;
    'dispatch: loop {
        match pc {
            0x82600398 => {
    //   block [0x82600398..0x8260047C)
	// 82600398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260039C: 48BA7DC9  bl 0x831a8164
	ctx.lr = 0x826003A0;
	sub_831A8130(ctx, base);
	// 826003A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826003A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826003A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826003AC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826003B0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826003B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826003B8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 826003BC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 826003C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826003C4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826003C8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 826003CC: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 826003D0: 487F2019  bl 0x82df23e8
	ctx.lr = 0x826003D4;
	sub_82DF23E8(ctx, base);
	// 826003D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826003D8: 41820058  beq 0x82600430
	if ctx.cr[0].eq {
	pc = 0x82600430; continue 'dispatch;
	}
	// 826003DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 826003E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826003E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826003E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826003EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826003F0: 419A0024  beq cr6, 0x82600414
	if ctx.cr[6].eq {
	pc = 0x82600414; continue 'dispatch;
	}
	// 826003F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826003F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826003FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82600400: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82600404: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82600408: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8260040C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82600410: 4082FFE8  bne 0x826003f8
	if !ctx.cr[0].eq {
	pc = 0x826003F8; continue 'dispatch;
	}
	// 82600414: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600418: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260041C: 88BD0000  lbz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600420: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82600424: 48557E05  bl 0x82b58228
	ctx.lr = 0x82600428;
	sub_82B58228(ctx, base);
	// 82600428: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260042C: 48000008  b 0x82600434
	pc = 0x82600434; continue 'dispatch;
	// 82600430: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82600434: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82600438: 3BBB0004  addi r29, r27, 4
	ctx.r[29].s64 = ctx.r[27].s64 + 4;
	// 8260043C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82600440: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82600444: 4BFFF5D5  bl 0x825ffa18
	ctx.lr = 0x82600448;
	sub_825FFA18(ctx, base);
	// 82600448: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260044C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82600450: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82600454: 4BCBFBAD  bl 0x822c0000
	ctx.lr = 0x82600458;
	sub_822C0000(ctx, base);
	// 82600458: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260045C: 41820014  beq 0x82600470
	if ctx.cr[0].eq {
	pc = 0x82600470; continue 'dispatch;
	}
	// 82600460: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82600464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600468: 419A0008  beq cr6, 0x82600470
	if ctx.cr[6].eq {
	pc = 0x82600470; continue 'dispatch;
	}
	// 8260046C: 4BCC0425  bl 0x822c0890
	ctx.lr = 0x82600470;
	sub_822C0890(ctx, base);
	// 82600470: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82600474: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82600478: 48BA7D3C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82600480 size=124
    let mut pc: u32 = 0x82600480;
    'dispatch: loop {
        match pc {
            0x82600480 => {
    //   block [0x82600480..0x826004FC)
	// 82600480: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82600484: 48BA7CE9  bl 0x831a816c
	ctx.lr = 0x82600488;
	sub_831A8130(ctx, base);
	// 82600488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260048C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82600490: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82600494: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82600498: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8260049C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 826004A0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 826004A4: 487F1F45  bl 0x82df23e8
	ctx.lr = 0x826004A8;
	sub_82DF23E8(ctx, base);
	// 826004A8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826004AC: 4182001C  beq 0x826004c8
	if ctx.cr[0].eq {
	pc = 0x826004C8; continue 'dispatch;
	}
	// 826004B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826004B4: 488591CD  bl 0x82e59680
	ctx.lr = 0x826004B8;
	sub_82E59680(ctx, base);
	// 826004B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826004BC: 396B1DB4  addi r11, r11, 0x1db4
	ctx.r[11].s64 = ctx.r[11].s64 + 7604;
	// 826004C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826004C4: 48000008  b 0x826004cc
	pc = 0x826004CC; continue 'dispatch;
	// 826004C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826004CC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 826004D0: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 826004D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826004D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826004DC: 4BFFF605  bl 0x825ffae0
	ctx.lr = 0x826004E0;
	sub_825FFAE0(ctx, base);
	// 826004E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826004E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826004E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826004EC: 4BCBFB15  bl 0x822c0000
	ctx.lr = 0x826004F0;
	sub_822C0000(ctx, base);
	// 826004F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826004F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826004F8: 48BA7CC4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82600500 size=76
    let mut pc: u32 = 0x82600500;
    'dispatch: loop {
        match pc {
            0x82600500 => {
    //   block [0x82600500..0x8260054C)
	// 82600500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82600504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82600508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260050C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82600510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82600514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82600518: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260051C: 4BFFFA0D  bl 0x825fff28
	ctx.lr = 0x82600520;
	sub_825FFF28(ctx, base);
	// 82600520: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82600524: 4182000C  beq 0x82600530
	if ctx.cr[0].eq {
	pc = 0x82600530; continue 'dispatch;
	}
	// 82600528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260052C: 487F1EAD  bl 0x82df23d8
	ctx.lr = 0x82600530;
	sub_82DF23D8(ctx, base);
	// 82600530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82600534: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82600538: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260053C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82600540: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82600544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82600550 size=1648
    let mut pc: u32 = 0x82600550;
    'dispatch: loop {
        match pc {
            0x82600550 => {
    //   block [0x82600550..0x82600BC0)
	// 82600550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82600554: 48BA7C09  bl 0x831a815c
	ctx.lr = 0x82600558;
	sub_831A8130(ctx, base);
	// 82600558: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8260055C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82600560: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82600564: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82600568: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8260056C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82600570: 4BF11469  bl 0x825119d8
	ctx.lr = 0x82600574;
	sub_825119D8(ctx, base);
	// 82600574: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82600578: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260057C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82600580: 487F3489  bl 0x82df3a08
	ctx.lr = 0x82600584;
	sub_82DF3A08(ctx, base);
	// 82600584: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82600588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260058C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82600590: 4BF081F1  bl 0x82508780
	ctx.lr = 0x82600594;
	sub_82508780(ctx, base);
	// 82600594: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600598: 487F2E91  bl 0x82df3428
	ctx.lr = 0x8260059C;
	sub_82DF3428(ctx, base);
	// 8260059C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826005A0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826005A4: 409A0008  bne cr6, 0x826005ac
	if !ctx.cr[6].eq {
	pc = 0x826005AC; continue 'dispatch;
	}
	// 826005A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826005AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826005B0: 4BF081F1  bl 0x825087a0
	ctx.lr = 0x826005B4;
	sub_825087A0(ctx, base);
	// 826005B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826005B8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 826005BC: 4882A52D  bl 0x82e2aae8
	ctx.lr = 0x826005C0;
	sub_82E2AAE8(ctx, base);
	// 826005C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826005C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826005C8: 388B1D6C  addi r4, r11, 0x1d6c
	ctx.r[4].s64 = ctx.r[11].s64 + 7532;
	// 826005CC: 487F343D  bl 0x82df3a08
	ctx.lr = 0x826005D0;
	sub_82DF3A08(ctx, base);
	// 826005D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826005D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826005D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826005DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 826005E0: 4882E891  bl 0x82e2ee70
	ctx.lr = 0x826005E4;
	sub_82E2EE70(ctx, base);
	// 826005E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826005E8: 487F2E41  bl 0x82df3428
	ctx.lr = 0x826005EC;
	sub_82DF3428(ctx, base);
	// 826005EC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 826005F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826005F4: 3F208335  lis r25, -0x7ccb
	ctx.r[25].s64 = -2093678592;
	// 826005F8: 3B6B1F38  addi r27, r11, 0x1f38
	ctx.r[27].s64 = ctx.r[11].s64 + 7992;
	// 826005FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600600: 419A00D8  beq cr6, 0x826006d8
	if ctx.cr[6].eq {
	pc = 0x826006D8; continue 'dispatch;
	}
	// 82600604: 487FE1DD  bl 0x82dfe7e0
	ctx.lr = 0x82600608;
	sub_82DFE7E0(ctx, base);
	// 82600608: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260060C: 40820060  bne 0x8260066c
	if !ctx.cr[0].eq {
	pc = 0x8260066C; continue 'dispatch;
	}
	// 82600610: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82600614: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82600618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260061C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82600620: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82600624: 419A0024  beq cr6, 0x82600648
	if ctx.cr[6].eq {
	pc = 0x82600648; continue 'dispatch;
	}
	// 82600628: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8260062C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82600630: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82600634: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82600638: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8260063C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82600640: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82600644: 4082FFE8  bne 0x8260062c
	if !ctx.cr[0].eq {
	pc = 0x8260062C; continue 'dispatch;
	}
	// 82600648: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8260064C: 4BEEA43D  bl 0x824eaa88
	ctx.lr = 0x82600650;
	sub_824EAA88(ctx, base);
	// 82600650: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82600654: 38C0007E  li r6, 0x7e
	ctx.r[6].s64 = 126;
	// 82600658: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260065C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600660: 485B9B21  bl 0x82bba180
	ctx.lr = 0x82600664;
	sub_82BBA180(ctx, base);
	// 82600664: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82600668: 487F1629  bl 0x82df1c90
	ctx.lr = 0x8260066C;
	sub_82DF1C90(ctx, base);
	// 8260066C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82600670: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82600674: 38A0007F  li r5, 0x7f
	ctx.r[5].s64 = 127;
	// 82600678: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8260067C: 487F1D6D  bl 0x82df23e8
	ctx.lr = 0x82600680;
	sub_82DF23E8(ctx, base);
	// 82600680: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82600684: 41820014  beq 0x82600698
	if ctx.cr[0].eq {
	pc = 0x82600698; continue 'dispatch;
	}
	// 82600688: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8260068C: 48816205  bl 0x82e16890
	ctx.lr = 0x82600690;
	sub_82E16890(ctx, base);
	// 82600690: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82600694: 48000008  b 0x8260069c
	pc = 0x8260069C; continue 'dispatch;
	// 82600698: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8260069C: 3BDF0170  addi r30, r31, 0x170
	ctx.r[30].s64 = ctx.r[31].s64 + 368;
	// 826006A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826006A4: 4BD5CCCD  bl 0x8235d370
	ctx.lr = 0x826006A8;
	sub_8235D370(ctx, base);
	// 826006A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826006AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826006B0: 83BF0170  lwz r29, 0x170(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 826006B4: 4BF11A65  bl 0x82512118
	ctx.lr = 0x826006B8;
	sub_82512118(ctx, base);
	// 826006B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826006BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826006C0: 48814A31  bl 0x82e150f0
	ctx.lr = 0x826006C4;
	sub_82E150F0(ctx, base);
	// 826006C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826006C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826006CC: 80997058  lwz r4, 0x7058(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826006D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826006D4: 4BF10485  bl 0x82510b58
	ctx.lr = 0x826006D8;
	sub_82510B58(ctx, base);
	// 826006D8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 826006DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826006E0: 419A0008  beq cr6, 0x826006e8
	if ctx.cr[6].eq {
	pc = 0x826006E8; continue 'dispatch;
	}
	// 826006E4: 4BCC01AD  bl 0x822c0890
	ctx.lr = 0x826006E8;
	sub_822C0890(ctx, base);
	// 826006E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826006EC: 4882A415  bl 0x82e2ab00
	ctx.lr = 0x826006F0;
	sub_82E2AB00(ctx, base);
	// 826006F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826006F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826006F8: 388B1FD8  addi r4, r11, 0x1fd8
	ctx.r[4].s64 = ctx.r[11].s64 + 8152;
	// 826006FC: 487F330D  bl 0x82df3a08
	ctx.lr = 0x82600700;
	sub_82DF3A08(ctx, base);
	// 82600700: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82600704: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82600708: 809F0170  lwz r4, 0x170(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(368 as u32) ) } as u64;
	// 8260070C: 48814925  bl 0x82e15030
	ctx.lr = 0x82600710;
	sub_82E15030(ctx, base);
	// 82600710: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82600714: 3B9F0178  addi r28, r31, 0x178
	ctx.r[28].s64 = ctx.r[31].s64 + 376;
	// 82600718: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8260071C: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82600720: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600724: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82600728: 4BCC3D39  bl 0x822c4460
	ctx.lr = 0x8260072C;
	sub_822C4460(ctx, base);
	// 8260072C: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82600730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600734: 419A0008  beq cr6, 0x8260073c
	if ctx.cr[6].eq {
	pc = 0x8260073C; continue 'dispatch;
	}
	// 82600738: 4BCC0159  bl 0x822c0890
	ctx.lr = 0x8260073C;
	sub_822C0890(ctx, base);
	// 8260073C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600740: 487F2CE9  bl 0x82df3428
	ctx.lr = 0x82600744;
	sub_82DF3428(ctx, base);
	// 82600744: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82600748: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8260074C: 4BF119CD  bl 0x82512118
	ctx.lr = 0x82600750;
	sub_82512118(ctx, base);
	// 82600750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82600754: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600758: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260075C: 48812875  bl 0x82e12fd0
	ctx.lr = 0x82600760;
	sub_82E12FD0(ctx, base);
	// 82600760: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82600764: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600768: 419A0008  beq cr6, 0x82600770
	if ctx.cr[6].eq {
	pc = 0x82600770; continue 'dispatch;
	}
	// 8260076C: 4BCC0125  bl 0x822c0890
	ctx.lr = 0x82600770;
	sub_822C0890(ctx, base);
	// 82600770: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600774: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82600778: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8260077C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82600780: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82600784: 4889FFAD  bl 0x82ea0730
	ctx.lr = 0x82600788;
	sub_82EA0730(ctx, base);
	// 82600788: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 8260078C: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82600790: B3A30004  sth r29, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u16 ) };
	// 82600794: C02B7BC8  lfs f1, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82600798: 48919A59  bl 0x82f1a1f0
	ctx.lr = 0x8260079C;
	sub_82F1A1F0(ctx, base);
	// 8260079C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 826007A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826007A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826007A8: 388B1FCC  addi r4, r11, 0x1fcc
	ctx.r[4].s64 = ctx.r[11].s64 + 8140;
	// 826007AC: 487F8D85  bl 0x82df9530
	ctx.lr = 0x826007B0;
	sub_82DF9530(ctx, base);
	// 826007B0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 826007B4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 826007B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826007BC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826007C0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826007C4: 419A0024  beq cr6, 0x826007e8
	if ctx.cr[6].eq {
	pc = 0x826007E8; continue 'dispatch;
	}
	// 826007C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826007CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826007D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826007D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826007D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826007DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826007E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826007E4: 4082FFE8  bne 0x826007cc
	if !ctx.cr[0].eq {
	pc = 0x826007CC; continue 'dispatch;
	}
	// 826007E8: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826007EC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 826007F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 826007F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826007F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826007FC: 80CB6894  lwz r6, 0x6894(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26772 as u32) ) } as u64;
	// 82600800: 4BF128F9  bl 0x825130f8
	ctx.lr = 0x82600804;
	sub_825130F8(ctx, base);
	// 82600804: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82600808: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 8260080C: 3BDF01E0  addi r30, r31, 0x1e0
	ctx.r[30].s64 = ctx.r[31].s64 + 480;
	// 82600810: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82600814: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82600818: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8260081C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82600820: 4887B7F9  bl 0x82e7c018
	ctx.lr = 0x82600824;
	sub_82E7C018(ctx, base);
	// 82600824: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82600828: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8260082C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 82600830: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82600834: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82600838: 13E04C07  vcmpneb. (lvlx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8260083C: 38A00095  li r5, 0x95
	ctx.r[5].s64 = 149;
	// 82600840: 13CA4C07  vcmpneb. (lvlx128) v30, v10, v9
	tmp.u32 = ctx.r[10].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82600844: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82600848: 13BD4C07  vcmpneb. (lvlx128) v29, v29, v9
	tmp.u32 = ctx.r[29].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8260084C: 138B4C07  vcmpneb. (lvlx128) v28, v11, v9
	tmp.u32 = ctx.r[11].u32 + ctx.r[9].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82600BC0 size=676
    let mut pc: u32 = 0x82600BC0;
    'dispatch: loop {
        match pc {
            0x82600BC0 => {
    //   block [0x82600BC0..0x82600E64)
	// 82600BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82600BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82600BC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82600BCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82600BD0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82600BD4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82600BD8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82600BDC: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82600BE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600BE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82600BE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82600BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600BF0: 388B2080  addi r4, r11, 0x2080
	ctx.r[4].s64 = ctx.r[11].s64 + 8320;
	// 82600BF4: 487F2E15  bl 0x82df3a08
	ctx.lr = 0x82600BF8;
	sub_82DF3A08(ctx, base);
	// 82600BF8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82600BFC: 38C000FF  li r6, 0xff
	ctx.r[6].s64 = 255;
	// 82600C00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82600C04: 389F0064  addi r4, r31, 0x64
	ctx.r[4].s64 = ctx.r[31].s64 + 100;
	// 82600C08: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82600C0C: 4BFA279D  bl 0x825a33a8
	ctx.lr = 0x82600C10;
	sub_825A33A8(ctx, base);
	// 82600C10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600C14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82600C18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600C1C: 4BFA12BD  bl 0x825a1ed8
	ctx.lr = 0x82600C20;
	sub_825A1ED8(ctx, base);
	// 82600C20: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 82600C24: 487F2805  bl 0x82df3428
	ctx.lr = 0x82600C28;
	sub_82DF3428(ctx, base);
	// 82600C28: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82600C2C: 4BCC808D  bl 0x822c8cb8
	ctx.lr = 0x82600C30;
	sub_822C8CB8(ctx, base);
	// 82600C30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600C34: 487F27F5  bl 0x82df3428
	ctx.lr = 0x82600C38;
	sub_82DF3428(ctx, base);
	// 82600C38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600C3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600C40: 388B2070  addi r4, r11, 0x2070
	ctx.r[4].s64 = ctx.r[11].s64 + 8304;
	// 82600C44: 487F2DC5  bl 0x82df3a08
	ctx.lr = 0x82600C48;
	sub_82DF3A08(ctx, base);
	// 82600C48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82600C4C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82600C50: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82600C54: 389F0068  addi r4, r31, 0x68
	ctx.r[4].s64 = ctx.r[31].s64 + 104;
	// 82600C58: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82600C5C: C3CB964C  lfs f30, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82600C60: C3AA9A8C  lfs f29, -0x6574(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82600C64: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82600C68: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82600C6C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82600C70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82600C74: 4BFA253D  bl 0x825a31b0
	ctx.lr = 0x82600C78;
	sub_825A31B0(ctx, base);
	// 82600C78: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600C7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82600C80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600C84: 4BFA0AED  bl 0x825a1770
	ctx.lr = 0x82600C88;
	sub_825A1770(ctx, base);
	// 82600C88: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82600C8C: 487F279D  bl 0x82df3428
	ctx.lr = 0x82600C90;
	sub_82DF3428(ctx, base);
	// 82600C90: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82600C94: 4BCC8025  bl 0x822c8cb8
	ctx.lr = 0x82600C98;
	sub_822C8CB8(ctx, base);
	// 82600C98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600C9C: 487F278D  bl 0x82df3428
	ctx.lr = 0x82600CA0;
	sub_82DF3428(ctx, base);
	// 82600CA0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600CA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600CA8: 388B2050  addi r4, r11, 0x2050
	ctx.r[4].s64 = ctx.r[11].s64 + 8272;
	// 82600CAC: 487F2D5D  bl 0x82df3a08
	ctx.lr = 0x82600CB0;
	sub_82DF3A08(ctx, base);
	// 82600CB0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600CB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600CB8: 388B2044  addi r4, r11, 0x2044
	ctx.r[4].s64 = ctx.r[11].s64 + 8260;
	// 82600CBC: 487F2D4D  bl 0x82df3a08
	ctx.lr = 0x82600CC0;
	sub_82DF3A08(ctx, base);
	// 82600CC0: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 82600CC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82600CC8: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82600CCC: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82600CD0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82600CD4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82600CD8: 4BFA25D1  bl 0x825a32a8
	ctx.lr = 0x82600CDC;
	sub_825A32A8(ctx, base);
	// 82600CDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600CE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82600CE8: 4BFA0A89  bl 0x825a1770
	ctx.lr = 0x82600CEC;
	sub_825A1770(ctx, base);
	// 82600CEC: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 82600CF0: 487F2739  bl 0x82df3428
	ctx.lr = 0x82600CF4;
	sub_82DF3428(ctx, base);
	// 82600CF4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82600CF8: 4BCC7FC1  bl 0x822c8cb8
	ctx.lr = 0x82600CFC;
	sub_822C8CB8(ctx, base);
	// 82600CFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600D00: 487F2729  bl 0x82df3428
	ctx.lr = 0x82600D04;
	sub_82DF3428(ctx, base);
	// 82600D04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600D08: 487F2721  bl 0x82df3428
	ctx.lr = 0x82600D0C;
	sub_82DF3428(ctx, base);
	// 82600D0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600D10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600D14: 388B2034  addi r4, r11, 0x2034
	ctx.r[4].s64 = ctx.r[11].s64 + 8244;
	// 82600D18: 487F2CF1  bl 0x82df3a08
	ctx.lr = 0x82600D1C;
	sub_82DF3A08(ctx, base);
	// 82600D1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600D20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600D24: 388B2024  addi r4, r11, 0x2024
	ctx.r[4].s64 = ctx.r[11].s64 + 8228;
	// 82600D28: 487F2CE1  bl 0x82df3a08
	ctx.lr = 0x82600D2C;
	sub_82DF3A08(ctx, base);
	// 82600D2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82600D30: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 82600D34: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82600D38: 38BF0070  addi r5, r31, 0x70
	ctx.r[5].s64 = ctx.r[31].s64 + 112;
	// 82600D3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600D40: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82600D44: C06B08A8  lfs f3, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82600D48: C04AC350  lfs f2, -0x3cb0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15536 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82600D4C: 4BFA255D  bl 0x825a32a8
	ctx.lr = 0x82600D50;
	sub_825A32A8(ctx, base);
	// 82600D50: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600D54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82600D58: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82600D5C: 4BFA0A15  bl 0x825a1770
	ctx.lr = 0x82600D60;
	sub_825A1770(ctx, base);
	// 82600D60: 386101B8  addi r3, r1, 0x1b8
	ctx.r[3].s64 = ctx.r[1].s64 + 440;
	// 82600D64: 487F26C5  bl 0x82df3428
	ctx.lr = 0x82600D68;
	sub_82DF3428(ctx, base);
	// 82600D68: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 82600D6C: 4BCC7F4D  bl 0x822c8cb8
	ctx.lr = 0x82600D70;
	sub_822C8CB8(ctx, base);
	// 82600D70: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600D74: 487F26B5  bl 0x82df3428
	ctx.lr = 0x82600D78;
	sub_82DF3428(ctx, base);
	// 82600D78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600D7C: 487F26AD  bl 0x82df3428
	ctx.lr = 0x82600D80;
	sub_82DF3428(ctx, base);
	// 82600D80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600D88: 388B2008  addi r4, r11, 0x2008
	ctx.r[4].s64 = ctx.r[11].s64 + 8200;
	// 82600D8C: 487F2C7D  bl 0x82df3a08
	ctx.lr = 0x82600D90;
	sub_82DF3A08(ctx, base);
	// 82600D90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600D94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600D98: 388B1FF8  addi r4, r11, 0x1ff8
	ctx.r[4].s64 = ctx.r[11].s64 + 8184;
	// 82600D9C: 487F2C6D  bl 0x82df3a08
	ctx.lr = 0x82600DA0;
	sub_82DF3A08(ctx, base);
	// 82600DA0: 38BF013C  addi r5, r31, 0x13c
	ctx.r[5].s64 = ctx.r[31].s64 + 316;
	// 82600DA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600DA8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82600DAC: 4BFA22A5  bl 0x825a3050
	ctx.lr = 0x82600DB0;
	sub_825A3050(ctx, base);
	// 82600DB0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600DB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82600DB8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82600DBC: 4BFA13CD  bl 0x825a2188
	ctx.lr = 0x82600DC0;
	sub_825A2188(ctx, base);
	// 82600DC0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82600DC4: 487F2665  bl 0x82df3428
	ctx.lr = 0x82600DC8;
	sub_82DF3428(ctx, base);
	// 82600DC8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82600DCC: 4BCC7EED  bl 0x822c8cb8
	ctx.lr = 0x82600DD0;
	sub_822C8CB8(ctx, base);
	// 82600DD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600DD4: 487F2655  bl 0x82df3428
	ctx.lr = 0x82600DD8;
	sub_82DF3428(ctx, base);
	// 82600DD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600DDC: 487F264D  bl 0x82df3428
	ctx.lr = 0x82600DE0;
	sub_82DF3428(ctx, base);
	// 82600DE0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600DE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600DE8: 388B1FE8  addi r4, r11, 0x1fe8
	ctx.r[4].s64 = ctx.r[11].s64 + 8168;
	// 82600DEC: 487F2C1D  bl 0x82df3a08
	ctx.lr = 0x82600DF0;
	sub_82DF3A08(ctx, base);
	// 82600DF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600DF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600DF8: 388B1FE0  addi r4, r11, 0x1fe0
	ctx.r[4].s64 = ctx.r[11].s64 + 8160;
	// 82600DFC: 487F2C0D  bl 0x82df3a08
	ctx.lr = 0x82600E00;
	sub_82DF3A08(ctx, base);
	// 82600E00: 38BF013D  addi r5, r31, 0x13d
	ctx.r[5].s64 = ctx.r[31].s64 + 317;
	// 82600E04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600E08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82600E0C: 4BFA2245  bl 0x825a3050
	ctx.lr = 0x82600E10;
	sub_825A3050(ctx, base);
	// 82600E10: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82600E14: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82600E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82600E1C: 4BFA136D  bl 0x825a2188
	ctx.lr = 0x82600E20;
	sub_825A2188(ctx, base);
	// 82600E20: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82600E24: 487F2605  bl 0x82df3428
	ctx.lr = 0x82600E28;
	sub_82DF3428(ctx, base);
	// 82600E28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82600E2C: 4BCC7E8D  bl 0x822c8cb8
	ctx.lr = 0x82600E30;
	sub_822C8CB8(ctx, base);
	// 82600E30: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82600E34: 487F25F5  bl 0x82df3428
	ctx.lr = 0x82600E38;
	sub_82DF3428(ctx, base);
	// 82600E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82600E3C: 487F25ED  bl 0x82df3428
	ctx.lr = 0x82600E40;
	sub_82DF3428(ctx, base);
	// 82600E40: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82600E44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82600E48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82600E4C: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82600E50: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82600E54: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82600E58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82600E5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600E60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82600E68 size=80
    let mut pc: u32 = 0x82600E68;
    'dispatch: loop {
        match pc {
            0x82600E68 => {
    //   block [0x82600E68..0x82600EB8)
	// 82600E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82600E6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82600E70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82600E74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82600E78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82600E7C: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 82600E80: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82600E84: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82600E88: 419A0014  beq cr6, 0x82600e9c
	if ctx.cr[6].eq {
	pc = 0x82600E9C; continue 'dispatch;
	}
	// 82600E8C: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 82600E90: 4BFFF289  bl 0x82600118
	ctx.lr = 0x82600E94;
	sub_82600118(ctx, base);
	// 82600E94: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82600E98: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82600E9C: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 82600EA0: 4BFFED09  bl 0x825ffba8
	ctx.lr = 0x82600EA4;
	sub_825FFBA8(ctx, base);
	// 82600EA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82600EA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82600EAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82600EB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82600EB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82600EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82600EB8 size=956
    let mut pc: u32 = 0x82600EB8;
    'dispatch: loop {
        match pc {
            0x82600EB8 => {
    //   block [0x82600EB8..0x82601274)
	// 82600EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82600EBC: 48BA72A1  bl 0x831a815c
	ctx.lr = 0x82600EC0;
	sub_831A8130(ctx, base);
	// 82600EC0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82600EC4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82600EC8: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82600ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82600ED0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82600ED4: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82600ED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82600EDC: 419A0388  beq cr6, 0x82601264
	if ctx.cr[6].eq {
	pc = 0x82601264; continue 'dispatch;
	}
	// 82600EE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82600EE4: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82600EE8: C3CB08A4  lfs f30, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82600EEC: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82600EF0: 41990374  bgt cr6, 0x82601264
	if ctx.cr[6].gt {
	pc = 0x82601264; continue 'dispatch;
	}
	// 82600EF4: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 82600EF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82600EFC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82600F00: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82600F04: 4BD9E385  bl 0x8239f288
	ctx.lr = 0x82600F08;
	sub_8239F288(ctx, base);
	// 82600F08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82600F0C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82600F10: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82600F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82600F18: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82600F1C: 419A0024  beq cr6, 0x82600f40
	if ctx.cr[6].eq {
	pc = 0x82600F40; continue 'dispatch;
	}
	// 82600F20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82600F24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82600F28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82600F2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82600F30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82600F34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82600F38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82600F3C: 4082FFE8  bne 0x82600f24
	if !ctx.cr[0].eq {
	pc = 0x82600F24; continue 'dispatch;
	}
	// 82600F40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82600F44: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 82600F48: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82600F4C: 48A071DD  bl 0x83008128
	ctx.lr = 0x82600F50;
	sub_83008128(ctx, base);
	// 82600F50: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82600F54: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82600F58: 3B6B1F38  addi r27, r11, 0x1f38
	ctx.r[27].s64 = ctx.r[11].s64 + 7992;
	// 82600F5C: 38A00114  li r5, 0x114
	ctx.r[5].s64 = 276;
	// 82600F60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82600F64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82600F68: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82600F6C: 4885607D  bl 0x82e56fe8
	ctx.lr = 0x82600F70;
	sub_82E56FE8(ctx, base);
	// 82600F70: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82600F74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600F78: 419A0008  beq cr6, 0x82600f80
	if ctx.cr[6].eq {
	pc = 0x82600F80; continue 'dispatch;
	}
	// 82600F7C: 4BCBF915  bl 0x822c0890
	ctx.lr = 0x82600F80;
	sub_822C0890(ctx, base);
	// 82600F80: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82600F84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82600F88: 419A0008  beq cr6, 0x82600f90
	if ctx.cr[6].eq {
	pc = 0x82600F90; continue 'dispatch;
	}
	// 82600F8C: 4BCBF905  bl 0x822c0890
	ctx.lr = 0x82600F90;
	sub_822C0890(ctx, base);
	// 82600F90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82600F94: D3C10080  stfs f30, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82600F98: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82600F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82600FA0: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82600FA4: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82600FA8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82600FAC: 4BF10BAD  bl 0x82511b58
	ctx.lr = 0x82600FB0;
	sub_82511B58(ctx, base);
	// 82600FB0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82600FB4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82600FB8: 4887AEE1  bl 0x82e7be98
	ctx.lr = 0x82600FBC;
	sub_82E7BE98(ctx, base);
	// 82600FBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82600FC0: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82600FC4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82600FC8: 4887AD01  bl 0x82e7bcc8
	ctx.lr = 0x82600FCC;
	sub_82E7BCC8(ctx, base);
	// 82600FCC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 82600FD0: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 82600FD4: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 82600FD8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82600FDC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82600FE0: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82601278 size=1300
    let mut pc: u32 = 0x82601278;
    'dispatch: loop {
        match pc {
            0x82601278 => {
    //   block [0x82601278..0x8260178C)
	// 82601278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260127C: 48BA6EE9  bl 0x831a8164
	ctx.lr = 0x82601280;
	sub_831A8130(ctx, base);
	// 82601280: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82601284: 48BA77F5  bl 0x831a8a78
	ctx.lr = 0x82601288;
	sub_831A8A40(ctx, base);
	// 82601288: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260128C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82601290: 48B53371  bl 0x83154600
	ctx.lr = 0x82601294;
	sub_83154600(ctx, base);
	// 82601294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82601298: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 8260129C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826012A0: 419A04DC  beq cr6, 0x8260177c
	if ctx.cr[6].eq {
	pc = 0x8260177C; continue 'dispatch;
	}
	// 826012A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826012A8: 488584D1  bl 0x82e59778
	ctx.lr = 0x826012AC;
	sub_82E59778(ctx, base);
	// 826012AC: C01B0060  lfs f0, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826012B0: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826012B4: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 826012B8: 4BCCEC49  bl 0x822cff00
	ctx.lr = 0x826012BC;
	sub_822CFF00(ctx, base);
	// 826012BC: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826012C0: 4BCCEC61  bl 0x822cff20
	ctx.lr = 0x826012C4;
	sub_822CFF20(ctx, base);
	// 826012C4: C39F014C  lfs f28, 0x14c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826012C8: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826012CC: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 826012D0: 4BCCEC41  bl 0x822cff10
	ctx.lr = 0x826012D4;
	sub_822CFF10(ctx, base);
	// 826012D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826012D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826012DC: C1BB0060  lfs f13, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826012E0: 3B8B1D84  addi r28, r11, 0x1d84
	ctx.r[28].s64 = ctx.r[11].s64 + 7556;
	// 826012E4: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826012E8: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826012EC: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 826012F0: EFA10028  fsubs f29, f1, f0
	ctx.f[29].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	// 826012F4: 409901C0  ble cr6, 0x826014b4
	if !ctx.cr[6].gt {
	pc = 0x826014B4; continue 'dispatch;
	}
	// 826012F8: 815F018C  lwz r10, 0x18c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826012FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601300: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82601304: 3BCB1F38  addi r30, r11, 0x1f38
	ctx.r[30].s64 = ctx.r[11].s64 + 7992;
	// 82601308: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260130C: 419A009C  beq cr6, 0x826013a8
	if ctx.cr[6].eq {
	pc = 0x826013A8; continue 'dispatch;
	}
	// 82601310: C01F0150  lfs f0, 0x150(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601314: EC1D0028  fsubs f0, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82601318: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 8260131C: 4198008C  blt cr6, 0x826013a8
	if ctx.cr[6].lt {
	pc = 0x826013A8; continue 'dispatch;
	}
	// 82601320: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82601324: 4BFFF15D  bl 0x82600480
	ctx.lr = 0x82601328;
	sub_82600480(ctx, base);
	// 82601328: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260132C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82601330: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82601334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601338: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8260133C: 419A0024  beq cr6, 0x82601360
	if ctx.cr[6].eq {
	pc = 0x82601360; continue 'dispatch;
	}
	// 82601340: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82601344: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82601348: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260134C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82601350: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82601354: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82601358: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260135C: 4082FFE8  bne 0x82601344
	if !ctx.cr[0].eq {
	pc = 0x82601344; continue 'dispatch;
	}
	// 82601360: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82601364: 80DF018C  lwz r6, 0x18c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82601368: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 8260136C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82601370: 38A001D4  li r5, 0x1d4
	ctx.r[5].s64 = 468;
	// 82601374: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82601378: 488576C9  bl 0x82e58a40
	ctx.lr = 0x8260137C;
	sub_82E58A40(ctx, base);
	// 8260137C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82601380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601384: 419A0008  beq cr6, 0x8260138c
	if ctx.cr[6].eq {
	pc = 0x8260138C; continue 'dispatch;
	}
	// 82601388: 4BCBF509  bl 0x822c0890
	ctx.lr = 0x8260138C;
	sub_822C0890(ctx, base);
	// 8260138C: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82601390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601394: 419A0008  beq cr6, 0x8260139c
	if ctx.cr[6].eq {
	pc = 0x8260139C; continue 'dispatch;
	}
	// 82601398: 4BCBF4F9  bl 0x822c0890
	ctx.lr = 0x8260139C;
	sub_822C0890(ctx, base);
	// 8260139C: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826013A0: 93BF018C  stw r29, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[29].u32 ) };
	// 826013A4: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 826013A8: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 826013AC: 419802B8  blt cr6, 0x82601664
	if ctx.cr[6].lt {
	pc = 0x82601664; continue 'dispatch;
	}
	// 826013B0: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 826013B4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826013B8: 4BCCEB79  bl 0x822cff30
	ctx.lr = 0x826013BC;
	sub_822CFF30(ctx, base);
	// 826013BC: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 826013C0: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826013C4: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 826013C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826013CC: 419A001C  beq cr6, 0x826013e8
	if ctx.cr[6].eq {
	pc = 0x826013E8; continue 'dispatch;
	}
	// 826013D0: 93BF022C  stw r29, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[29].u32 ) };
	// 826013D4: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 826013D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826013DC: 93BF0230  stw r29, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[29].u32 ) };
	// 826013E0: 419A0008  beq cr6, 0x826013e8
	if ctx.cr[6].eq {
	pc = 0x826013E8; continue 'dispatch;
	}
	// 826013E4: 4BCBF4AD  bl 0x822c0890
	ctx.lr = 0x826013E8;
	sub_822C0890(ctx, base);
	// 826013E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826013EC: 4BFFEEE5  bl 0x826002d0
	ctx.lr = 0x826013F0;
	sub_826002D0(ctx, base);
	// 826013F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826013F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826013F8: 38A001E0  li r5, 0x1e0
	ctx.r[5].s64 = 480;
	// 826013FC: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82601400: 487F0FE9  bl 0x82df23e8
	ctx.lr = 0x82601404;
	sub_82DF23E8(ctx, base);
	// 82601404: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82601408: 4182001C  beq 0x82601424
	if ctx.cr[0].eq {
	pc = 0x82601424; continue 'dispatch;
	}
	// 8260140C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601410: 4885B519  bl 0x82e5c928
	ctx.lr = 0x82601414;
	sub_82E5C928(ctx, base);
	// 82601414: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601418: 396B1E70  addi r11, r11, 0x1e70
	ctx.r[11].s64 = ctx.r[11].s64 + 7792;
	// 8260141C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82601420: 48000008  b 0x82601428
	pc = 0x82601428; continue 'dispatch;
	// 82601424: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82601428: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 8260142C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82601430: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82601434: 4BFFE2C5  bl 0x825ff6f8
	ctx.lr = 0x82601438;
	sub_825FF6F8(ctx, base);
	// 82601438: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8260143C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82601440: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82601444: 4BCBEBBD  bl 0x822c0000
	ctx.lr = 0x82601448;
	sub_822C0000(ctx, base);
	// 82601448: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260144C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82601450: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82601454: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82601458: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8260145C: 419A0024  beq cr6, 0x82601480
	if ctx.cr[6].eq {
	pc = 0x82601480; continue 'dispatch;
	}
	// 82601460: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82601464: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82601468: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260146C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82601470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82601474: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82601478: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260147C: 4082FFE8  bne 0x82601464
	if !ctx.cr[0].eq {
	pc = 0x82601464; continue 'dispatch;
	}
	// 82601480: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82601484: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82601488: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8260148C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82601490: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82601494: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82601498: 4885D429  bl 0x82e5e8c0
	ctx.lr = 0x8260149C;
	sub_82E5E8C0(ctx, base);
	// 8260149C: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 826014A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826014A4: 419A0008  beq cr6, 0x826014ac
	if ctx.cr[6].eq {
	pc = 0x826014AC; continue 'dispatch;
	}
	// 826014A8: 4BCBF3E9  bl 0x822c0890
	ctx.lr = 0x826014AC;
	sub_822C0890(ctx, base);
	// 826014AC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826014B0: 48000198  b 0x82601648
	pc = 0x82601648; continue 'dispatch;
	// 826014B4: FF1EE000  fcmpu cr6, f30, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 826014B8: 419901AC  bgt cr6, 0x82601664
	if ctx.cr[6].gt {
	pc = 0x82601664; continue 'dispatch;
	}
	// 826014BC: 815F018C  lwz r10, 0x18c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826014C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826014C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826014C8: 3BCB1F38  addi r30, r11, 0x1f38
	ctx.r[30].s64 = ctx.r[11].s64 + 7992;
	// 826014CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826014D0: 419A0084  beq cr6, 0x82601554
	if ctx.cr[6].eq {
	pc = 0x82601554; continue 'dispatch;
	}
	// 826014D4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 826014D8: 4BFFEFA9  bl 0x82600480
	ctx.lr = 0x826014DC;
	sub_82600480(ctx, base);
	// 826014DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826014E0: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 826014E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826014E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826014EC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 826014F0: 419A0024  beq cr6, 0x82601514
	if ctx.cr[6].eq {
	pc = 0x82601514; continue 'dispatch;
	}
	// 826014F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826014F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826014FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601500: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82601504: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82601508: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8260150C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601510: 4082FFE8  bne 0x826014f8
	if !ctx.cr[0].eq {
	pc = 0x826014F8; continue 'dispatch;
	}
	// 82601514: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82601518: 80DF018C  lwz r6, 0x18c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 8260151C: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 82601520: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82601524: 38A001E8  li r5, 0x1e8
	ctx.r[5].s64 = 488;
	// 82601528: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8260152C: 48857515  bl 0x82e58a40
	ctx.lr = 0x82601530;
	sub_82E58A40(ctx, base);
	// 82601530: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82601534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601538: 419A0008  beq cr6, 0x82601540
	if ctx.cr[6].eq {
	pc = 0x82601540; continue 'dispatch;
	}
	// 8260153C: 4BCBF355  bl 0x822c0890
	ctx.lr = 0x82601540;
	sub_822C0890(ctx, base);
	// 82601540: 806100D4  lwz r3, 0xd4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82601544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601548: 419A0008  beq cr6, 0x82601550
	if ctx.cr[6].eq {
	pc = 0x82601550; continue 'dispatch;
	}
	// 8260154C: 4BCBF345  bl 0x822c0890
	ctx.lr = 0x82601550;
	sub_822C0890(ctx, base);
	// 82601550: 93BF018C  stw r29, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[29].u32 ) };
	// 82601554: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 82601558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260155C: 419A001C  beq cr6, 0x82601578
	if ctx.cr[6].eq {
	pc = 0x82601578; continue 'dispatch;
	}
	// 82601560: 93BF022C  stw r29, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[29].u32 ) };
	// 82601564: 807F0230  lwz r3, 0x230(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(560 as u32) ) } as u64;
	// 82601568: 93BF0230  stw r29, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[29].u32 ) };
	// 8260156C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601570: 419A0008  beq cr6, 0x82601578
	if ctx.cr[6].eq {
	pc = 0x82601578; continue 'dispatch;
	}
	// 82601574: 4BCBF31D  bl 0x822c0890
	ctx.lr = 0x82601578;
	sub_822C0890(ctx, base);
	// 82601578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260157C: 4BFFED55  bl 0x826002d0
	ctx.lr = 0x82601580;
	sub_826002D0(ctx, base);
	// 82601580: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601584: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82601588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260158C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82601590: 38A001EF  li r5, 0x1ef
	ctx.r[5].s64 = 495;
	// 82601594: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 82601598: 487F0E51  bl 0x82df23e8
	ctx.lr = 0x8260159C;
	sub_82DF23E8(ctx, base);
	// 8260159C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 826015A0: 4182001C  beq 0x826015bc
	if ctx.cr[0].eq {
	pc = 0x826015BC; continue 'dispatch;
	}
	// 826015A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826015A8: 4885B381  bl 0x82e5c928
	ctx.lr = 0x826015AC;
	sub_82E5C928(ctx, base);
	// 826015AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826015B0: 396B1E70  addi r11, r11, 0x1e70
	ctx.r[11].s64 = ctx.r[11].s64 + 7792;
	// 826015B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826015B8: 48000008  b 0x826015c0
	pc = 0x826015C0; continue 'dispatch;
	// 826015BC: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 826015C0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 826015C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826015C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826015CC: 4BFFE12D  bl 0x825ff6f8
	ctx.lr = 0x826015D0;
	sub_825FF6F8(ctx, base);
	// 826015D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826015D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826015D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826015DC: 4BCBEA25  bl 0x822c0000
	ctx.lr = 0x826015E0;
	sub_822C0000(ctx, base);
	// 826015E0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826015E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 826015E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 826015EC: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 826015F0: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 826015F4: 419A0024  beq cr6, 0x82601618
	if ctx.cr[6].eq {
	pc = 0x82601618; continue 'dispatch;
	}
	// 826015F8: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 826015FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82601600: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601604: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82601608: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8260160C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82601610: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601614: 4082FFE8  bne 0x826015fc
	if !ctx.cr[0].eq {
	pc = 0x826015FC; continue 'dispatch;
	}
	// 82601618: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8260161C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82601620: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82601624: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82601628: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8260162C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82601630: 4885D291  bl 0x82e5e8c0
	ctx.lr = 0x82601634;
	sub_82E5E8C0(ctx, base);
	// 82601634: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82601638: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260163C: 419A0008  beq cr6, 0x82601644
	if ctx.cr[6].eq {
	pc = 0x82601644; continue 'dispatch;
	}
	// 82601640: 4BCBF251  bl 0x822c0890
	ctx.lr = 0x82601644;
	sub_822C0890(ctx, base);
	// 82601644: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82601648: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260164C: 419A0008  beq cr6, 0x82601654
	if ctx.cr[6].eq {
	pc = 0x82601654; continue 'dispatch;
	}
	// 82601650: 4BCBF241  bl 0x822c0890
	ctx.lr = 0x82601654;
	sub_822C0890(ctx, base);
	// 82601654: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82601658: 419A000C  beq cr6, 0x82601664
	if ctx.cr[6].eq {
	pc = 0x82601664; continue 'dispatch;
	}
	// 8260165C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601660: 4BCBF231  bl 0x822c0890
	ctx.lr = 0x82601664;
	sub_822C0890(ctx, base);
	// 82601664: 38C100F0  addi r6, r1, 0xf0
	ctx.r[6].s64 = ctx.r[1].s64 + 240;
	// 82601668: 807F0224  lwz r3, 0x224(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 8260166C: 38A10110  addi r5, r1, 0x110
	ctx.r[5].s64 = ctx.r[1].s64 + 272;
	// 82601670: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82601674: 4BCCE9E5  bl 0x822d0058
	ctx.lr = 0x82601678;
	sub_822D0058(ctx, base);
	// 82601678: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 8260167C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601680: 4BF10401  bl 0x82511a80
	ctx.lr = 0x82601684;
	sub_82511A80(ctx, base);
	// 82601684: 807F022C  lwz r3, 0x22c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 82601688: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260168C: 419A000C  beq cr6, 0x82601698
	if ctx.cr[6].eq {
	pc = 0x82601698; continue 'dispatch;
	}
	// 82601690: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82601694: 48545515  bl 0x82b46ba8
	ctx.lr = 0x82601698;
	sub_82B46BA8(ctx, base);
	// 82601698: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260169C: C1BB0060  lfs f13, 0x60(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826016A0: 3BCBFB44  addi r30, r11, -0x4bc
	ctx.r[30].s64 = ctx.r[11].s64 + -1212;
	// 826016A4: C01EFFFC  lfs f0, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826016A8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826016AC: 40990020  ble cr6, 0x826016cc
	if !ctx.cr[6].gt {
	pc = 0x826016CC; continue 'dispatch;
	}
	// 826016B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 826016B4: FFC06890  fmr f30, f13
	ctx.f[30].f64 = ctx.f[13].f64;
	// 826016B8: 488580C1  bl 0x82e59778
	ctx.lr = 0x826016BC;
	sub_82E59778(ctx, base);
	// 826016BC: EDA107B2  fmuls f13, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 826016C0: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826016C4: EC0DF03C  fnmsubs f0, f13, f0, f30
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 826016C8: D01B0060  stfs f0, 0x60(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 826016CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826016D0: C1A100F0  lfs f13, 0xf0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826016D4: C18100F8  lfs f12, 0xf8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826016D8: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 826016DC: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 826016E0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 826016E4: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 826016E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826016EC: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 826016F0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 826016F4: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826016F8: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 826016FC: D3E10090  stfs f31, 0x90(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82601700: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82601704: D3E10098  stfs f31, 0x98(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82601708: D3E1009C  stfs f31, 0x9c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8260170C: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82601710: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82601714: D18100B8  stfs f12, 0xb8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82601718: D3E100BC  stfs f31, 0xbc(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8260171C: 4887B945  bl 0x82e7d060
	ctx.lr = 0x82601720;
	sub_82E7D060(ctx, base);
	// 82601720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601724: 4BF10435  bl 0x82511b58
	ctx.lr = 0x82601728;
	sub_82511B58(ctx, base);
	// 82601728: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260172C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82601730: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601734: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82601738: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260173C: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82601740: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601744: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82601748: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260174C: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82601750: 48858029  bl 0x82e59778
	ctx.lr = 0x82601754;
	sub_82E59778(ctx, base);
	// 82601754: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601758: 38A10100  addi r5, r1, 0x100
	ctx.r[5].s64 = ctx.r[1].s64 + 256;
	// 8260175C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82601760: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601764: C00BD7BC  lfs f0, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601768: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8260176C: 4887BB5D  bl 0x82e7d2c8
	ctx.lr = 0x82601770;
	sub_82E7D2C8(ctx, base);
	// 82601770: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82601774: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601778: 4BF10379  bl 0x82511af0
	ctx.lr = 0x8260177C;
	sub_82511AF0(ctx, base);
	// 8260177C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82601780: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82601784: 48BA7341  bl 0x831a8ac4
	ctx.lr = 0x82601788;
	sub_831A8A8C(ctx, base);
	// 82601788: 48BA6A2C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82601790 size=332
    let mut pc: u32 = 0x82601790;
    'dispatch: loop {
        match pc {
            0x82601790 => {
    //   block [0x82601790..0x826018DC)
	// 82601790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601794: 48BA69D5  bl 0x831a8168
	ctx.lr = 0x82601798;
	sub_831A8130(ctx, base);
	// 82601798: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260179C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 826017A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826017A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826017A8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 826017AC: 41820038  beq 0x826017e4
	if ctx.cr[0].eq {
	pc = 0x826017E4; continue 'dispatch;
	}
	// 826017B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826017B4: 48BA81D5  bl 0x831a9988
	ctx.lr = 0x826017B8;
	sub_831A9988(ctx, base);
	// 826017B8: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826017BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826017C0: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 826017C4: 48BA6935  bl 0x831a80f8
	ctx.lr = 0x826017C8;
	sub_831A80F8(ctx, base);
	// 826017C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826017CC: 41820018  beq 0x826017e4
	if ctx.cr[0].eq {
	pc = 0x826017E4; continue 'dispatch;
	}
	// 826017D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826017D4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826017D8: 4BFFF6E1  bl 0x82600eb8
	ctx.lr = 0x826017DC;
	sub_82600EB8(ctx, base);
	// 826017DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 826017E0: 480000F4  b 0x826018d4
	pc = 0x826018D4; continue 'dispatch;
	// 826017E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826017E8: 419A00DC  beq cr6, 0x826018c4
	if ctx.cr[6].eq {
	pc = 0x826018C4; continue 'dispatch;
	}
	// 826017EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826017F0: 48BA8199  bl 0x831a9988
	ctx.lr = 0x826017F4;
	sub_831A9988(ctx, base);
	// 826017F4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 826017F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826017FC: 386B68A4  addi r3, r11, 0x68a4
	ctx.r[3].s64 = ctx.r[11].s64 + 26788;
	// 82601800: 48BA68F9  bl 0x831a80f8
	ctx.lr = 0x82601804;
	sub_831A80F8(ctx, base);
	// 82601804: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82601808: 41820014  beq 0x8260181c
	if ctx.cr[0].eq {
	pc = 0x8260181C; continue 'dispatch;
	}
	// 8260180C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601810: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82601814: 4BFFDCDD  bl 0x825ff4f0
	ctx.lr = 0x82601818;
	sub_825FF4F0(ctx, base);
	// 82601818: 4BFFFFC4  b 0x826017dc
	pc = 0x826017DC; continue 'dispatch;
	// 8260181C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82601820: 419A00A4  beq cr6, 0x826018c4
	if ctx.cr[6].eq {
	pc = 0x826018C4; continue 'dispatch;
	}
	// 82601824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601828: 48BA8161  bl 0x831a9988
	ctx.lr = 0x8260182C;
	sub_831A9988(ctx, base);
	// 8260182C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82601830: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82601834: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 82601838: 48BA68C1  bl 0x831a80f8
	ctx.lr = 0x8260183C;
	sub_831A80F8(ctx, base);
	// 8260183C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82601840: 41820014  beq 0x82601854
	if ctx.cr[0].eq {
	pc = 0x82601854; continue 'dispatch;
	}
	// 82601844: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601848: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8260184C: 480694A5  bl 0x8266acf0
	ctx.lr = 0x82601850;
	sub_8266ACF0(ctx, base);
	// 82601850: 4BFFFF8C  b 0x826017dc
	pc = 0x826017DC; continue 'dispatch;
	// 82601854: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82601858: 419A006C  beq cr6, 0x826018c4
	if ctx.cr[6].eq {
	pc = 0x826018C4; continue 'dispatch;
	}
	// 8260185C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601860: 48BA8129  bl 0x831a9988
	ctx.lr = 0x82601864;
	sub_831A9988(ctx, base);
	// 82601864: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82601868: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260186C: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 82601870: 48BA6889  bl 0x831a80f8
	ctx.lr = 0x82601874;
	sub_831A80F8(ctx, base);
	// 82601874: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82601878: 41820014  beq 0x8260188c
	if ctx.cr[0].eq {
	pc = 0x8260188C; continue 'dispatch;
	}
	// 8260187C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601880: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82601884: 480C0C65  bl 0x826c24e8
	ctx.lr = 0x82601888;
	sub_826C24E8(ctx, base);
	// 82601888: 4BFFFF54  b 0x826017dc
	pc = 0x826017DC; continue 'dispatch;
	// 8260188C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82601890: 419A0034  beq cr6, 0x826018c4
	if ctx.cr[6].eq {
	pc = 0x826018C4; continue 'dispatch;
	}
	// 82601894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601898: 48BA80F1  bl 0x831a9988
	ctx.lr = 0x8260189C;
	sub_831A9988(ctx, base);
	// 8260189C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826018A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826018A4: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 826018A8: 48BA6851  bl 0x831a80f8
	ctx.lr = 0x826018AC;
	sub_831A80F8(ctx, base);
	// 826018AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826018B0: 41820014  beq 0x826018c4
	if ctx.cr[0].eq {
	pc = 0x826018C4; continue 'dispatch;
	}
	// 826018B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826018B8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826018BC: 4BFFDC45  bl 0x825ff500
	ctx.lr = 0x826018C0;
	sub_825FF500(ctx, base);
	// 826018C0: 4BFFFF1C  b 0x826017dc
	pc = 0x826017DC; continue 'dispatch;
	// 826018C4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 826018C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826018CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826018D0: 4BF10D49  bl 0x82512618
	ctx.lr = 0x826018D4;
	sub_82512618(ctx, base);
	// 826018D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 826018D8: 48BA68E0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826018E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826018E0 size=408
    let mut pc: u32 = 0x826018E0;
    'dispatch: loop {
        match pc {
            0x826018E0 => {
    //   block [0x826018E0..0x82601A78)
	// 826018E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826018E4: 48BA6885  bl 0x831a8168
	ctx.lr = 0x826018E8;
	sub_831A8130(ctx, base);
	// 826018E8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826018EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826018F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826018F4: 3BCB1F38  addi r30, r11, 0x1f38
	ctx.r[30].s64 = ctx.r[11].s64 + 7992;
	// 826018F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826018FC: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 82601900: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82601904: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	// 82601908: 487F0AE1  bl 0x82df23e8
	ctx.lr = 0x8260190C;
	sub_82DF23E8(ctx, base);
	// 8260190C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82601910: 41820010  beq 0x82601920
	if ctx.cr[0].eq {
	pc = 0x82601920; continue 'dispatch;
	}
	// 82601914: 4BFFE505  bl 0x825ffe18
	ctx.lr = 0x82601918;
	sub_825FFE18(ctx, base);
	// 82601918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260191C: 48000008  b 0x82601924
	pc = 0x82601924; continue 'dispatch;
	// 82601920: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82601924: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82601928: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260192C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82601930: 4BFFDD01  bl 0x825ff630
	ctx.lr = 0x82601934;
	sub_825FF630(ctx, base);
	// 82601934: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82601938: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260193C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82601940: 4BCBE6C1  bl 0x822c0000
	ctx.lr = 0x82601944;
	sub_822C0000(ctx, base);
	// 82601944: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82601948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8260194C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82601950: 409A0008  bne cr6, 0x82601958
	if !ctx.cr[6].eq {
	pc = 0x82601958; continue 'dispatch;
	}
	// 82601954: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82601958: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260195C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82601960: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82601964: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82601968: 419A0024  beq cr6, 0x8260198c
	if ctx.cr[6].eq {
	pc = 0x8260198C; continue 'dispatch;
	}
	// 8260196C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82601970: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82601974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601978: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 8260197C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82601980: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82601984: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601988: 4082FFE8  bne 0x82601970
	if !ctx.cr[0].eq {
	pc = 0x82601970; continue 'dispatch;
	}
	// 8260198C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82601990: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82601994: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82601998: 419A0024  beq cr6, 0x826019bc
	if ctx.cr[6].eq {
	pc = 0x826019BC; continue 'dispatch;
	}
	// 8260199C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826019A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826019A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826019A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826019AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826019B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826019B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826019B8: 4082FFE8  bne 0x826019a0
	if !ctx.cr[0].eq {
	pc = 0x826019A0; continue 'dispatch;
	}
	// 826019BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826019C0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826019C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826019C8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826019CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826019D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826019D4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826019D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826019DC: 48197555  bl 0x82798f30
	ctx.lr = 0x826019E0;
	sub_82798F30(ctx, base);
	// 826019E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826019E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826019E8: 9961009C  stb r11, 0x9c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u8 ) };
	// 826019EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826019F0: 38A00042  li r5, 0x42
	ctx.r[5].s64 = 66;
	// 826019F4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826019F8: 4BCBE9E1  bl 0x822c03d8
	ctx.lr = 0x826019FC;
	sub_822C03D8(ctx, base);
	// 826019FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82601A00: 41820014  beq 0x82601a14
	if ctx.cr[0].eq {
	pc = 0x82601A14; continue 'dispatch;
	}
	// 82601A04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82601A08: 48199C61  bl 0x8279b668
	ctx.lr = 0x82601A0C;
	sub_8279B668(ctx, base);
	// 82601A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82601A10: 48000008  b 0x82601a18
	pc = 0x82601A18; continue 'dispatch;
	// 82601A14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82601A18: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82601A1C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82601A20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601A24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601A28: 4BF96229  bl 0x82597c50
	ctx.lr = 0x82601A2C;
	sub_82597C50(ctx, base);
	// 82601A2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82601A30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601A34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601A38: 4BCBE5C9  bl 0x822c0000
	ctx.lr = 0x82601A3C;
	sub_822C0000(ctx, base);
	// 82601A3C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82601A40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601A44: 419A0008  beq cr6, 0x82601a4c
	if ctx.cr[6].eq {
	pc = 0x82601A4C; continue 'dispatch;
	}
	// 82601A48: 4BCBEE49  bl 0x822c0890
	ctx.lr = 0x82601A4C;
	sub_822C0890(ctx, base);
	// 82601A4C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82601A50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601A54: 419A0008  beq cr6, 0x82601a5c
	if ctx.cr[6].eq {
	pc = 0x82601A5C; continue 'dispatch;
	}
	// 82601A58: 4BCBEE39  bl 0x822c0890
	ctx.lr = 0x82601A5C;
	sub_822C0890(ctx, base);
	// 82601A5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82601A60: 419A000C  beq cr6, 0x82601a6c
	if ctx.cr[6].eq {
	pc = 0x82601A6C; continue 'dispatch;
	}
	// 82601A64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82601A68: 4BCBEE29  bl 0x822c0890
	ctx.lr = 0x82601A6C;
	sub_822C0890(ctx, base);
	// 82601A6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82601A70: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82601A74: 48BA6744  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82601A78 size=164
    let mut pc: u32 = 0x82601A78;
    'dispatch: loop {
        match pc {
            0x82601A78 => {
    //   block [0x82601A78..0x82601B1C)
	// 82601A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82601A80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82601A84: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601A88: 3BE3FF1C  addi r31, r3, -0xe4
	ctx.r[31].s64 = ctx.r[3].s64 + -228;
	// 82601A8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82601A90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601A94: 4BF0DA35  bl 0x8250f4c8
	ctx.lr = 0x82601A98;
	sub_8250F4C8(ctx, base);
	// 82601A98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601AA0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82601AA4: 409A0008  bne cr6, 0x82601aac
	if !ctx.cr[6].eq {
	pc = 0x82601AAC; continue 'dispatch;
	}
	// 82601AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82601AAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601AB0: 4BF06CE1  bl 0x82508790
	ctx.lr = 0x82601AB4;
	sub_82508790(ctx, base);
	// 82601AB4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82601AB8: 487F01D9  bl 0x82df1c90
	ctx.lr = 0x82601ABC;
	sub_82DF1C90(ctx, base);
	// 82601ABC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82601AC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601AC4: 808BE268  lwz r4, -0x1d98(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7576 as u32) ) } as u64;
	// 82601AC8: 487F1F41  bl 0x82df3a08
	ctx.lr = 0x82601ACC;
	sub_82DF3A08(ctx, base);
	// 82601ACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601AD0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82601AD4: 4BF0D9F5  bl 0x8250f4c8
	ctx.lr = 0x82601AD8;
	sub_8250F4C8(ctx, base);
	// 82601AD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601ADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601AE0: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82601AE4: 409A0008  bne cr6, 0x82601aec
	if !ctx.cr[6].eq {
	pc = 0x82601AEC; continue 'dispatch;
	}
	// 82601AE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82601AEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82601AF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82601AF4: 4BF06C8D  bl 0x82508780
	ctx.lr = 0x82601AF8;
	sub_82508780(ctx, base);
	// 82601AF8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82601AFC: 487F0195  bl 0x82df1c90
	ctx.lr = 0x82601B00;
	sub_82DF1C90(ctx, base);
	// 82601B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601B04: 487F1925  bl 0x82df3428
	ctx.lr = 0x82601B08;
	sub_82DF3428(ctx, base);
	// 82601B08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82601B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82601B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82601B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82601B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82601B20 size=164
    let mut pc: u32 = 0x82601B20;
    'dispatch: loop {
        match pc {
            0x82601B20 => {
    //   block [0x82601B20..0x82601BC4)
	// 82601B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82601B28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82601B2C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601B30: 3BE3FF1C  addi r31, r3, -0xe4
	ctx.r[31].s64 = ctx.r[3].s64 + -228;
	// 82601B34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82601B38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601B3C: 4BF0D98D  bl 0x8250f4c8
	ctx.lr = 0x82601B40;
	sub_8250F4C8(ctx, base);
	// 82601B40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601B48: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82601B4C: 409A0008  bne cr6, 0x82601b54
	if !ctx.cr[6].eq {
	pc = 0x82601B54; continue 'dispatch;
	}
	// 82601B50: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82601B54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601B58: 4BF06C39  bl 0x82508790
	ctx.lr = 0x82601B5C;
	sub_82508790(ctx, base);
	// 82601B5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82601B60: 487F0131  bl 0x82df1c90
	ctx.lr = 0x82601B64;
	sub_82DF1C90(ctx, base);
	// 82601B64: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82601B68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601B6C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82601B70: 487F1E99  bl 0x82df3a08
	ctx.lr = 0x82601B74;
	sub_82DF3A08(ctx, base);
	// 82601B74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601B78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82601B7C: 4BF0D94D  bl 0x8250f4c8
	ctx.lr = 0x82601B80;
	sub_8250F4C8(ctx, base);
	// 82601B80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601B88: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82601B8C: 409A0008  bne cr6, 0x82601b94
	if !ctx.cr[6].eq {
	pc = 0x82601B94; continue 'dispatch;
	}
	// 82601B90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82601B94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82601B98: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82601B9C: 4BF06BE5  bl 0x82508780
	ctx.lr = 0x82601BA0;
	sub_82508780(ctx, base);
	// 82601BA0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82601BA4: 487F00ED  bl 0x82df1c90
	ctx.lr = 0x82601BA8;
	sub_82DF1C90(ctx, base);
	// 82601BA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601BAC: 487F187D  bl 0x82df3428
	ctx.lr = 0x82601BB0;
	sub_82DF3428(ctx, base);
	// 82601BB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82601BB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82601BB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82601BBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82601BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82601BC8 size=196
    let mut pc: u32 = 0x82601BC8;
    'dispatch: loop {
        match pc {
            0x82601BC8 => {
    //   block [0x82601BC8..0x82601C8C)
	// 82601BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601BCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82601BD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82601BD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82601BD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601BDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82601BE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82601BE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82601BE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82601BEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82601BF0: 4BCBED49  bl 0x822c0938
	ctx.lr = 0x82601BF4;
	sub_822C0938(ctx, base);
	// 82601BF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82601BF8: 41820028  beq 0x82601c20
	if ctx.cr[0].eq {
	pc = 0x82601C20; continue 'dispatch;
	}
	// 82601BFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601C00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82601C04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82601C08: 392B20A0  addi r9, r11, 0x20a0
	ctx.r[9].s64 = ctx.r[11].s64 + 8352;
	// 82601C0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82601C10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82601C14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82601C18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82601C1C: 48000008  b 0x82601c24
	pc = 0x82601C24; continue 'dispatch;
	// 82601C20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82601C24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82601C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601C2C: 409A0044  bne cr6, 0x82601c70
	if !ctx.cr[6].eq {
	pc = 0x82601C70; continue 'dispatch;
	}
	// 82601C30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82601C34: 419A001C  beq cr6, 0x82601c50
	if ctx.cr[6].eq {
	pc = 0x82601C50; continue 'dispatch;
	}
	// 82601C38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601C3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82601C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601C44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601C48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82601C4C: 4E800421  bctrl
	ctx.lr = 0x82601C50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82601C50: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82601C54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82601C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601C5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82601C60: 816BFEA0  lwz r11, -0x160(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-352 as u32) ) } as u64;
	// 82601C64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82601C68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82601C6C: 4BCBE395  bl 0x822c0000
	ctx.lr = 0x82601C70;
	sub_822C0000(ctx, base);
	// 82601C70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601C74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82601C78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82601C7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82601C80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82601C84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82601C88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82601C90 size=300
    let mut pc: u32 = 0x82601C90;
    'dispatch: loop {
        match pc {
            0x82601C90 => {
    //   block [0x82601C90..0x82601DBC)
	// 82601C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601C94: 48BA64D5  bl 0x831a8168
	ctx.lr = 0x82601C98;
	sub_831A8130(ctx, base);
	// 82601C98: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82601C9C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82601CA0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82601CA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82601CAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82601CB0: 4BF0D819  bl 0x8250f4c8
	ctx.lr = 0x82601CB4;
	sub_8250F4C8(ctx, base);
	// 82601CB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601CBC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82601CC0: 409A0008  bne cr6, 0x82601cc8
	if !ctx.cr[6].eq {
	pc = 0x82601CC8; continue 'dispatch;
	}
	// 82601CC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82601CC8: 4BF06851  bl 0x82508518
	ctx.lr = 0x82601CCC;
	sub_82508518(ctx, base);
	// 82601CCC: C01F0110  lfs f0, 0x110(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601CD0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82601CD4: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82601CD8: 487EFFB9  bl 0x82df1c90
	ctx.lr = 0x82601CDC;
	sub_82DF1C90(ctx, base);
	// 82601CDC: 3FA08212  lis r29, -0x7dee
	ctx.r[29].s64 = -2112749568;
	// 82601CE0: C1BF010C  lfs f13, 0x10c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82601CE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82601CE8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82601CEC: C01DDFAC  lfs f0, -0x2054(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601CF0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82601CF4: C3CB9524  lfs f30, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82601CF8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82601CFC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82601D00: 4887ACE9  bl 0x82e7c9e8
	ctx.lr = 0x82601D04;
	sub_82E7C9E8(ctx, base);
	// 82601D04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82601D08: C01F0108  lfs f0, 0x108(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601D0C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82601D10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82601D14: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82601D18: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82601D1C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82601D20: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82601D24: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82601D28: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82601D2C: 48879F9D  bl 0x82e7bcc8
	ctx.lr = 0x82601D30;
	sub_82E7BCC8(ctx, base);
	// 82601D30: 817F0100  lwz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82601D34: 83DF00FC  lwz r30, 0xfc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 82601D38: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82601D3C: 419A0070  beq cr6, 0x82601dac
	if ctx.cr[6].eq {
	pc = 0x82601DAC; continue 'dispatch;
	}
	// 82601D40: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82601D44: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82601D48: 4887ACA1  bl 0x82e7c9e8
	ctx.lr = 0x82601D4C;
	sub_82E7C9E8(ctx, base);
	// 82601D4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82601D50: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82601D54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82601D58: 48879F71  bl 0x82e7bcc8
	ctx.lr = 0x82601D5C;
	sub_82E7BCC8(ctx, base);
	// 82601D5C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82601D60: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82601D64: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601D68: 4887A271  bl 0x82e7bfd8
	ctx.lr = 0x82601D6C;
	sub_82E7BFD8(ctx, base);
	// 82601D6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82601D70: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82601D74: 488114ED  bl 0x82e13260
	ctx.lr = 0x82601D78;
	sub_82E13260(ctx, base);
	// 82601D78: 817F0114  lwz r11, 0x114(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) } as u64;
	// 82601D7C: C01DDFAC  lfs f0, -0x2054(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82601D80: 815F0100  lwz r10, 0x100(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 82601D84: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82601D88: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82601D8C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82601D90: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82601D94: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82601D98: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82601D9C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82601DA0: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82601DA4: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82601DA8: 409AFF98  bne cr6, 0x82601d40
	if !ctx.cr[6].eq {
	pc = 0x82601D40; continue 'dispatch;
	}
	// 82601DAC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82601DB0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82601DB4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82601DB8: 48BA6400  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82601DC0 size=128
    let mut pc: u32 = 0x82601DC0;
    'dispatch: loop {
        match pc {
            0x82601DC0 => {
    //   block [0x82601DC0..0x82601E40)
	// 82601DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601DC4: 48BA63A9  bl 0x831a816c
	ctx.lr = 0x82601DC8;
	sub_831A8130(ctx, base);
	// 82601DC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82601DD0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82601DD4: 4BF0E935  bl 0x82510708
	ctx.lr = 0x82601DD8;
	sub_82510708(ctx, base);
	// 82601DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601DDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82601DE0: 4BFFFEB1  bl 0x82601c90
	ctx.lr = 0x82601DE4;
	sub_82601C90(ctx, base);
	// 82601DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601DE8: 4BF0FD01  bl 0x82511ae8
	ctx.lr = 0x82601DEC;
	sub_82511AE8(ctx, base);
	// 82601DEC: 3BDF0120  addi r30, r31, 0x120
	ctx.r[30].s64 = ctx.r[31].s64 + 288;
	// 82601DF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82601DF4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82601DF8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82601DFC: C1BD0000  lfs f13, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82601E00: 39200130  li r9, 0x130
	ctx.r[9].s64 = 304;
	// 82601E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82601E08: 13C0F0C7  vcmpequd (lvx128) v30, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82601E40 size=196
    let mut pc: u32 = 0x82601E40;
    'dispatch: loop {
        match pc {
            0x82601E40 => {
    //   block [0x82601E40..0x82601F04)
	// 82601E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601E44: 48BA6329  bl 0x831a816c
	ctx.lr = 0x82601E48;
	sub_831A8130(ctx, base);
	// 82601E48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601E4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82601E50: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82601E54: 3BBF0130  addi r29, r31, 0x130
	ctx.r[29].s64 = ctx.r[31].s64 + 304;
	// 82601E58: 4BF0FC91  bl 0x82511ae8
	ctx.lr = 0x82601E5C;
	sub_82511AE8(ctx, base);
	// 82601E5C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82601E60: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82601E64: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 82601E68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82601E6C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82601E70: 4820A021  bl 0x8280be90
	ctx.lr = 0x82601E74;
	sub_8280BE90(ctx, base);
	// 82601E74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82601E78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82601E7C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82601E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82601E84: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82601E88: 419A0024  beq cr6, 0x82601eac
	if ctx.cr[6].eq {
	pc = 0x82601EAC; continue 'dispatch;
	}
	// 82601E8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82601E90: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82601E94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601E98: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82601E9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82601EA0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82601EA4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82601EA8: 4082FFE8  bne 0x82601e90
	if !ctx.cr[0].eq {
	pc = 0x82601E90; continue 'dispatch;
	}
	// 82601EAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601EB0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82601EB4: 48A06275  bl 0x83008128
	ctx.lr = 0x82601EB8;
	sub_83008128(ctx, base);
	// 82601EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82601EBC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82601EC0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82601EC4: 388A20B0  addi r4, r10, 0x20b0
	ctx.r[4].s64 = ctx.r[10].s64 + 8368;
	// 82601EC8: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 82601ECC: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82601ED0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82601ED4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82601ED8: 48856B69  bl 0x82e58a40
	ctx.lr = 0x82601EDC;
	sub_82E58A40(ctx, base);
	// 82601EDC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82601EE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601EE4: 419A0008  beq cr6, 0x82601eec
	if ctx.cr[6].eq {
	pc = 0x82601EEC; continue 'dispatch;
	}
	// 82601EE8: 4BCBE9A9  bl 0x822c0890
	ctx.lr = 0x82601EEC;
	sub_822C0890(ctx, base);
	// 82601EEC: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82601EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82601EF4: 419A0008  beq cr6, 0x82601efc
	if ctx.cr[6].eq {
	pc = 0x82601EFC; continue 'dispatch;
	}
	// 82601EF8: 4BCBE999  bl 0x822c0890
	ctx.lr = 0x82601EFC;
	sub_822C0890(ctx, base);
	// 82601EFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82601F00: 48BA62BC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82601F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82601F08 size=460
    let mut pc: u32 = 0x82601F08;
    'dispatch: loop {
        match pc {
            0x82601F08 => {
    //   block [0x82601F08..0x826020D4)
	// 82601F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82601F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82601F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82601F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82601F18: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82601F1C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82601F20: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82601F24: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82601F28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601F2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82601F30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82601F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601F38: 388B2114  addi r4, r11, 0x2114
	ctx.r[4].s64 = ctx.r[11].s64 + 8468;
	// 82601F3C: 487F1ACD  bl 0x82df3a08
	ctx.lr = 0x82601F40;
	sub_82DF3A08(ctx, base);
	// 82601F40: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82601F44: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82601F48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82601F4C: 389F0024  addi r4, r31, 0x24
	ctx.r[4].s64 = ctx.r[31].s64 + 36;
	// 82601F50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82601F54: C3EA6218  lfs f31, 0x6218(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82601F58: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82601F5C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82601F60: C06B964C  lfs f3, -0x69b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82601F64: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82601F68: 4BFA1249  bl 0x825a31b0
	ctx.lr = 0x82601F6C;
	sub_825A31B0(ctx, base);
	// 82601F6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82601F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601F74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82601F78: 4BF9F7F9  bl 0x825a1770
	ctx.lr = 0x82601F7C;
	sub_825A1770(ctx, base);
	// 82601F7C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82601F80: 487F14A9  bl 0x82df3428
	ctx.lr = 0x82601F84;
	sub_82DF3428(ctx, base);
	// 82601F84: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82601F88: 4BCC6D31  bl 0x822c8cb8
	ctx.lr = 0x82601F8C;
	sub_822C8CB8(ctx, base);
	// 82601F8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601F90: 487F1499  bl 0x82df3428
	ctx.lr = 0x82601F94;
	sub_82DF3428(ctx, base);
	// 82601F94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601F9C: 388B132C  addi r4, r11, 0x132c
	ctx.r[4].s64 = ctx.r[11].s64 + 4908;
	// 82601FA0: 487F1A69  bl 0x82df3a08
	ctx.lr = 0x82601FA4;
	sub_82DF3A08(ctx, base);
	// 82601FA4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82601FA8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82601FAC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82601FB0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82601FB4: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82601FB8: C3AB9528  lfs f29, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82601FBC: C04A89AC  lfs f2, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82601FC0: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82601FC4: C029D0B0  lfs f1, -0x2f50(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82601FC8: 4BFA11E9  bl 0x825a31b0
	ctx.lr = 0x82601FCC;
	sub_825A31B0(ctx, base);
	// 82601FCC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82601FD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82601FD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82601FD8: 4BF9F799  bl 0x825a1770
	ctx.lr = 0x82601FDC;
	sub_825A1770(ctx, base);
	// 82601FDC: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 82601FE0: 487F1449  bl 0x82df3428
	ctx.lr = 0x82601FE4;
	sub_82DF3428(ctx, base);
	// 82601FE4: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 82601FE8: 4BCC6CD1  bl 0x822c8cb8
	ctx.lr = 0x82601FEC;
	sub_822C8CB8(ctx, base);
	// 82601FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601FF0: 487F1439  bl 0x82df3428
	ctx.lr = 0x82601FF4;
	sub_82DF3428(ctx, base);
	// 82601FF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82601FF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82601FFC: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 82602000: 487F1A09  bl 0x82df3a08
	ctx.lr = 0x82602004;
	sub_82DF3A08(ctx, base);
	// 82602004: 389F002C  addi r4, r31, 0x2c
	ctx.r[4].s64 = ctx.r[31].s64 + 44;
	// 82602008: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8260200C: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82602010: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82602014: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82602018: 4BFA1199  bl 0x825a31b0
	ctx.lr = 0x8260201C;
	sub_825A31B0(ctx, base);
	// 8260201C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82602020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602024: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602028: 4BF9F749  bl 0x825a1770
	ctx.lr = 0x8260202C;
	sub_825A1770(ctx, base);
	// 8260202C: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82602030: 487F13F9  bl 0x82df3428
	ctx.lr = 0x82602034;
	sub_82DF3428(ctx, base);
	// 82602034: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82602038: 4BCC6C81  bl 0x822c8cb8
	ctx.lr = 0x8260203C;
	sub_822C8CB8(ctx, base);
	// 8260203C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602040: 487F13E9  bl 0x82df3428
	ctx.lr = 0x82602044;
	sub_82DF3428(ctx, base);
	// 82602044: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602048: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8260204C: 388B2108  addi r4, r11, 0x2108
	ctx.r[4].s64 = ctx.r[11].s64 + 8456;
	// 82602050: 487F19B9  bl 0x82df3a08
	ctx.lr = 0x82602054;
	sub_82DF3A08(ctx, base);
	// 82602054: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602058: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260205C: 388B2100  addi r4, r11, 0x2100
	ctx.r[4].s64 = ctx.r[11].s64 + 8448;
	// 82602060: 487F19A9  bl 0x82df3a08
	ctx.lr = 0x82602064;
	sub_82DF3A08(ctx, base);
	// 82602064: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82602068: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 8260206C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82602070: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 82602074: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82602078: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8260207C: 4BFABB15  bl 0x825adb90
	ctx.lr = 0x82602080;
	sub_825ADB90(ctx, base);
	// 82602080: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82602084: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260208C: 4BF9FD2D  bl 0x825a1db8
	ctx.lr = 0x82602090;
	sub_825A1DB8(ctx, base);
	// 82602090: 38610158  addi r3, r1, 0x158
	ctx.r[3].s64 = ctx.r[1].s64 + 344;
	// 82602094: 487F1395  bl 0x82df3428
	ctx.lr = 0x82602098;
	sub_82DF3428(ctx, base);
	// 82602098: 38610138  addi r3, r1, 0x138
	ctx.r[3].s64 = ctx.r[1].s64 + 312;
	// 8260209C: 4BCC6C1D  bl 0x822c8cb8
	ctx.lr = 0x826020A0;
	sub_822C8CB8(ctx, base);
	// 826020A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826020A4: 487F1385  bl 0x82df3428
	ctx.lr = 0x826020A8;
	sub_82DF3428(ctx, base);
	// 826020A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826020AC: 487F137D  bl 0x82df3428
	ctx.lr = 0x826020B0;
	sub_82DF3428(ctx, base);
	// 826020B0: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 826020B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826020B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826020BC: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826020C0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826020C4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 826020C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826020CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826020D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826020D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826020D8 size=108
    let mut pc: u32 = 0x826020D8;
    'dispatch: loop {
        match pc {
            0x826020D8 => {
    //   block [0x826020D8..0x82602144)
	// 826020D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826020DC: 48BA6091  bl 0x831a816c
	ctx.lr = 0x826020E0;
	sub_831A8130(ctx, base);
	// 826020E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826020E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826020E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826020EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826020F0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826020F4: 41820038  beq 0x8260212c
	if ctx.cr[0].eq {
	pc = 0x8260212C; continue 'dispatch;
	}
	// 826020F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826020FC: 48BA788D  bl 0x831a9988
	ctx.lr = 0x82602100;
	sub_831A9988(ctx, base);
	// 82602100: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82602104: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82602108: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 8260210C: 48BA5FED  bl 0x831a80f8
	ctx.lr = 0x82602110;
	sub_831A80F8(ctx, base);
	// 82602110: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82602114: 41820018  beq 0x8260212c
	if ctx.cr[0].eq {
	pc = 0x8260212C; continue 'dispatch;
	}
	// 82602118: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260211C: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82602120: 4BFFFD21  bl 0x82601e40
	ctx.lr = 0x82602124;
	sub_82601E40(ctx, base);
	// 82602124: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82602128: 48000014  b 0x8260213c
	pc = 0x8260213C; continue 'dispatch;
	// 8260212C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82602130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82602134: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82602138: 4BF104E1  bl 0x82512618
	ctx.lr = 0x8260213C;
	sub_82512618(ctx, base);
	// 8260213C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82602140: 48BA607C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82602148 size=192
    let mut pc: u32 = 0x82602148;
    'dispatch: loop {
        match pc {
            0x82602148 => {
    //   block [0x82602148..0x82602208)
	// 82602148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260214C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602150: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602154: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260215C: 4BF101D5  bl 0x82512330
	ctx.lr = 0x82602160;
	sub_82512330(ctx, base);
	// 82602160: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602164: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82602168: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 8260216C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82602170: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82602174: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82602178: 396A2184  addi r11, r10, 0x2184
	ctx.r[11].s64 = ctx.r[10].s64 + 8580;
	// 8260217C: 39492170  addi r10, r9, 0x2170
	ctx.r[10].s64 = ctx.r[9].s64 + 8560;
	// 82602180: 39282124  addi r9, r8, 0x2124
	ctx.r[9].s64 = ctx.r[8].s64 + 8484;
	// 82602184: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82602188: 3CE08338  lis r7, -0x7cc8
	ctx.r[7].s64 = -2093481984;
	// 8260218C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82602190: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82602194: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82602198: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 8260219C: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 826021A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826021A4: 39076910  addi r8, r7, 0x6910
	ctx.r[8].s64 = ctx.r[7].s64 + 26896;
	// 826021A8: 39200130  li r9, 0x130
	ctx.r[9].s64 = 304;
	// 826021AC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 826021B0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 826021B4: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 826021B8: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 826021BC: C0069524  lfs f0, -0x6adc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826021C0: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 826021C4: C1A508A8  lfs f13, 0x8a8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826021C8: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 826021CC: C18408A4  lfs f12, 0x8a4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(2212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826021D0: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 826021D4: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826021D8: D1BF010C  stfs f13, 0x10c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 826021DC: 915F0114  stw r10, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 826021E0: D19F0110  stfs f12, 0x110(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 826021E4: 915F0118  stw r10, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[10].u32 ) };
	// 826021E8: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826021EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82602208 size=8
    let mut pc: u32 = 0x82602208;
    'dispatch: loop {
        match pc {
            0x82602208 => {
    //   block [0x82602208..0x82602210)
	// 82602208: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8260220C: 48000064  b 0x82602270
	sub_82602270(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82602210 size=8
    let mut pc: u32 = 0x82602210;
    'dispatch: loop {
        match pc {
            0x82602210 => {
    //   block [0x82602210..0x82602218)
	// 82602210: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82602214: 4800005C  b 0x82602270
	sub_82602270(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82602218 size=84
    let mut pc: u32 = 0x82602218;
    'dispatch: loop {
        match pc {
            0x82602218 => {
    //   block [0x82602218..0x8260226C)
	// 82602218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260221C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602220: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602224: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260222C: 387F00F8  addi r3, r31, 0xf8
	ctx.r[3].s64 = ctx.r[31].s64 + 248;
	// 82602230: 4BEAF071  bl 0x824b12a0
	ctx.lr = 0x82602234;
	sub_824B12A0(ctx, base);
	// 82602234: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82602238: 4BEAF069  bl 0x824b12a0
	ctx.lr = 0x8260223C;
	sub_824B12A0(ctx, base);
	// 8260223C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82602240: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82602244: 409A0008  bne cr6, 0x8260224c
	if !ctx.cr[6].eq {
	pc = 0x8260224C; continue 'dispatch;
	}
	// 82602248: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8260224C: 481A540D  bl 0x827a7658
	ctx.lr = 0x82602250;
	sub_827A7658(ctx, base);
	// 82602250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602254: 4BD4D0FD  bl 0x8234f350
	ctx.lr = 0x82602258;
	sub_8234F350(ctx, base);
	// 82602258: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260225C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82602260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82602264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82602268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82602270 size=76
    let mut pc: u32 = 0x82602270;
    'dispatch: loop {
        match pc {
            0x82602270 => {
    //   block [0x82602270..0x826022BC)
	// 82602270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260227C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602284: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602288: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260228C: 4BFFFF8D  bl 0x82602218
	ctx.lr = 0x82602290;
	sub_82602218(ctx, base);
	// 82602290: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82602294: 4182000C  beq 0x826022a0
	if ctx.cr[0].eq {
	pc = 0x826022A0; continue 'dispatch;
	}
	// 82602298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260229C: 487F013D  bl 0x82df23d8
	ctx.lr = 0x826022A0;
	sub_82DF23D8(ctx, base);
	// 826022A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826022A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826022A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826022AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826022B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826022B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826022B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826022C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826022C0 size=424
    let mut pc: u32 = 0x826022C0;
    'dispatch: loop {
        match pc {
            0x826022C0 => {
    //   block [0x826022C0..0x82602468)
	// 826022C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826022C4: 48BA5EA1  bl 0x831a8164
	ctx.lr = 0x826022C8;
	sub_831A8130(ctx, base);
	// 826022C8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826022CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826022D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 826022D4: 3BCB20B0  addi r30, r11, 0x20b0
	ctx.r[30].s64 = ctx.r[11].s64 + 8368;
	// 826022D8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 826022DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826022E0: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 826022E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 826022E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826022EC: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 826022F0: 487F00F9  bl 0x82df23e8
	ctx.lr = 0x826022F4;
	sub_82DF23E8(ctx, base);
	// 826022F4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826022F8: 41820010  beq 0x82602308
	if ctx.cr[0].eq {
	pc = 0x82602308; continue 'dispatch;
	}
	// 826022FC: 4BFFFE4D  bl 0x82602148
	ctx.lr = 0x82602300;
	sub_82602148(ctx, base);
	// 82602300: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602304: 48000008  b 0x8260230c
	pc = 0x8260230C; continue 'dispatch;
	// 82602308: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8260230C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82602310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82602314: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602318: 4BFFF8B1  bl 0x82601bc8
	ctx.lr = 0x8260231C;
	sub_82601BC8(ctx, base);
	// 8260231C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82602324: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602328: 4BCBDCD9  bl 0x822c0000
	ctx.lr = 0x8260232C;
	sub_822C0000(ctx, base);
	// 8260232C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602330: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602334: 38A0001A  li r5, 0x1a
	ctx.r[5].s64 = 26;
	// 82602338: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8260233C: 4BCBE09D  bl 0x822c03d8
	ctx.lr = 0x82602340;
	sub_822C03D8(ctx, base);
	// 82602340: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82602344: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82602348: 418200B4  beq 0x826023fc
	if ctx.cr[0].eq {
	pc = 0x826023FC; continue 'dispatch;
	}
	// 8260234C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82602350: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82602354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82602358: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 8260235C: 409A0008  bne cr6, 0x82602364
	if !ctx.cr[6].eq {
	pc = 0x82602364; continue 'dispatch;
	}
	// 82602360: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82602364: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82602368: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8260236C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82602370: 419A0024  beq cr6, 0x82602394
	if ctx.cr[6].eq {
	pc = 0x82602394; continue 'dispatch;
	}
	// 82602374: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82602378: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8260237C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602380: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82602384: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82602388: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8260238C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602390: 4082FFE8  bne 0x82602378
	if !ctx.cr[0].eq {
	pc = 0x82602378; continue 'dispatch;
	}
	// 82602394: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82602398: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8260239C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 826023A0: 419A0024  beq cr6, 0x826023c4
	if ctx.cr[6].eq {
	pc = 0x826023C4; continue 'dispatch;
	}
	// 826023A4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 826023A8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826023AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826023B0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826023B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826023B8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826023BC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826023C0: 4082FFE8  bne 0x826023a8
	if !ctx.cr[0].eq {
	pc = 0x826023A8; continue 'dispatch;
	}
	// 826023C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826023C8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 826023CC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826023D0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 826023D4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 826023D8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826023DC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826023E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826023E4: 48196B4D  bl 0x82798f30
	ctx.lr = 0x826023E8;
	sub_82798F30(ctx, base);
	// 826023E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826023EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826023F0: 48199279  bl 0x8279b668
	ctx.lr = 0x826023F4;
	sub_8279B668(ctx, base);
	// 826023F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826023F8: 48000008  b 0x82602400
	pc = 0x82602400; continue 'dispatch;
	// 826023FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82602400: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82602404: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82602408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260240C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602410: 4BF95841  bl 0x82597c50
	ctx.lr = 0x82602414;
	sub_82597C50(ctx, base);
	// 82602414: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602418: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260241C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602420: 4BCBDBE1  bl 0x822c0000
	ctx.lr = 0x82602424;
	sub_822C0000(ctx, base);
	// 82602424: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82602428: 41820024  beq 0x8260244c
	if ctx.cr[0].eq {
	pc = 0x8260244C; continue 'dispatch;
	}
	// 8260242C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82602430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602434: 419A0008  beq cr6, 0x8260243c
	if ctx.cr[6].eq {
	pc = 0x8260243C; continue 'dispatch;
	}
	// 82602438: 4BCBE459  bl 0x822c0890
	ctx.lr = 0x8260243C;
	sub_822C0890(ctx, base);
	// 8260243C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82602440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602444: 419A0008  beq cr6, 0x8260244c
	if ctx.cr[6].eq {
	pc = 0x8260244C; continue 'dispatch;
	}
	// 82602448: 4BCBE449  bl 0x822c0890
	ctx.lr = 0x8260244C;
	sub_822C0890(ctx, base);
	// 8260244C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82602450: 419A000C  beq cr6, 0x8260245c
	if ctx.cr[6].eq {
	pc = 0x8260245C; continue 'dispatch;
	}
	// 82602454: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82602458: 4BCBE439  bl 0x822c0890
	ctx.lr = 0x8260245C;
	sub_822C0890(ctx, base);
	// 8260245C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82602460: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82602464: 48BA5D50  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82602468 size=944
    let mut pc: u32 = 0x82602468;
    'dispatch: loop {
        match pc {
            0x82602468 => {
    //   block [0x82602468..0x82602818)
	// 82602468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260246C: 48BA5CD5  bl 0x831a8140
	ctx.lr = 0x82602470;
	sub_831A8130(ctx, base);
	// 82602470: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82602474: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602478: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8260247C: 3E408335  lis r18, -0x7ccb
	ctx.r[18].s64 = -2093678592;
	// 82602480: 83FE00EC  lwz r31, 0xec(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 82602484: 4800001C  b 0x826024a0
	pc = 0x826024A0; continue 'dispatch;
	// 82602488: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8260248C: 80927058  lwz r4, 0x7058(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82602490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602498: 4BF0DD59  bl 0x825101f0
	ctx.lr = 0x8260249C;
	sub_825101F0(ctx, base);
	// 8260249C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 826024A0: 817E00F0  lwz r11, 0xf0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 826024A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826024A8: 409AFFE0  bne cr6, 0x82602488
	if !ctx.cr[6].eq {
	pc = 0x82602488; continue 'dispatch;
	}
	// 826024AC: 3A7E00E8  addi r19, r30, 0xe8
	ctx.r[19].s64 = ctx.r[30].s64 + 232;
	// 826024B0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 826024B4: 4BCC46F5  bl 0x822c6ba8
	ctx.lr = 0x826024B8;
	sub_822C6BA8(ctx, base);
	// 826024B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826024BC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826024C0: 4BF0D009  bl 0x8250f4c8
	ctx.lr = 0x826024C4;
	sub_8250F4C8(ctx, base);
	// 826024C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826024C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826024CC: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 826024D0: 409A0008  bne cr6, 0x826024d8
	if !ctx.cr[6].eq {
	pc = 0x826024D8; continue 'dispatch;
	}
	// 826024D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 826024D8: 4BF06051  bl 0x82508528
	ctx.lr = 0x826024DC;
	sub_82508528(ctx, base);
	// 826024DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826024E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826024E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826024E8: 48828601  bl 0x82e2aae8
	ctx.lr = 0x826024EC;
	sub_82E2AAE8(ctx, base);
	// 826024EC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826024F0: 487EF7A1  bl 0x82df1c90
	ctx.lr = 0x826024F4;
	sub_82DF1C90(ctx, base);
	// 826024F4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826024F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826024FC: 388BFCEC  addi r4, r11, -0x314
	ctx.r[4].s64 = ctx.r[11].s64 + -788;
	// 82602500: 487F1509  bl 0x82df3a08
	ctx.lr = 0x82602504;
	sub_82DF3A08(ctx, base);
	// 82602504: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602508: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8260250C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82602510: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82602514: 4882C95D  bl 0x82e2ee70
	ctx.lr = 0x82602518;
	sub_82E2EE70(ctx, base);
	// 82602518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260251C: 487F0F0D  bl 0x82df3428
	ctx.lr = 0x82602520;
	sub_82DF3428(ctx, base);
	// 82602520: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 82602524: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82602528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260252C: 409902C8  ble cr6, 0x826027f4
	if !ctx.cr[6].gt {
	pc = 0x826027F4; continue 'dispatch;
	}
	// 82602530: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82602534: 82CD0000  lwz r22, 0(r13)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602538: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260253C: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82602540: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82602544: 3AA00014  li r21, 0x14
	ctx.r[21].s64 = 20;
	// 82602548: C3E8A9F0  lfs f31, -0x5610(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8260254C: 3B5E00F8  addi r26, r30, 0xf8
	ctx.r[26].s64 = ctx.r[30].s64 + 248;
	// 82602550: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82602554: 3F008335  lis r24, -0x7ccb
	ctx.r[24].s64 = -2093678592;
	// 82602558: 3B6B21C0  addi r27, r11, 0x21c0
	ctx.r[27].s64 = ctx.r[11].s64 + 8640;
	// 8260255C: 3AEA6880  addi r23, r10, 0x6880
	ctx.r[23].s64 = ctx.r[10].s64 + 26752;
	// 82602560: 3B2920B0  addi r25, r9, 0x20b0
	ctx.r[25].s64 = ctx.r[9].s64 + 8368;
	// 82602564: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82602568: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8260256C: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82602570: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82602574: 487EFE75  bl 0x82df23e8
	ctx.lr = 0x82602578;
	sub_82DF23E8(ctx, base);
	// 82602578: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8260257C: 41820014  beq 0x82602590
	if ctx.cr[0].eq {
	pc = 0x82602590; continue 'dispatch;
	}
	// 82602580: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82602584: 4881430D  bl 0x82e16890
	ctx.lr = 0x82602588;
	sub_82E16890(ctx, base);
	// 82602588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260258C: 48000008  b 0x82602594
	pc = 0x82602594; continue 'dispatch;
	// 82602590: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82602594: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82602598: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260259C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826025A0: 4BD56B19  bl 0x823590b8
	ctx.lr = 0x826025A4;
	sub_823590B8(ctx, base);
	// 826025A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826025A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826025AC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826025B0: 4BCBDA51  bl 0x822c0000
	ctx.lr = 0x826025B4;
	sub_822C0000(ctx, base);
	// 826025B4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 826025B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826025BC: 419A0018  beq cr6, 0x826025d4
	if ctx.cr[6].eq {
	pc = 0x826025D4; continue 'dispatch;
	}
	// 826025C0: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 826025C4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 826025C8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 826025CC: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826025D0: 419800DC  blt cr6, 0x826026ac
	if ctx.cr[6].lt {
	pc = 0x826026AC; continue 'dispatch;
	}
	// 826025D4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 826025D8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826025DC: 38A0006A  li r5, 0x6a
	ctx.r[5].s64 = 106;
	// 826025E0: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 826025E4: 487EFE05  bl 0x82df23e8
	ctx.lr = 0x826025E8;
	sub_82DF23E8(ctx, base);
	// 826025E8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826025EC: 41820014  beq 0x82602600
	if ctx.cr[0].eq {
	pc = 0x82602600; continue 'dispatch;
	}
	// 826025F0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 826025F4: 48810AFD  bl 0x82e130f0
	ctx.lr = 0x826025F8;
	sub_82E130F0(ctx, base);
	// 826025F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826025FC: 48000008  b 0x82602604
	pc = 0x82602604; continue 'dispatch;
	// 82602600: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82602604: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82602608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260260C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82602610: 4BCDEA09  bl 0x822e1018
	ctx.lr = 0x82602614;
	sub_822E1018(ctx, base);
	// 82602614: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260261C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82602620: 4BCBD9E1  bl 0x822c0000
	ctx.lr = 0x82602624;
	sub_822C0000(ctx, base);
	// 82602624: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602628: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8260262C: 4BF0FAED  bl 0x82512118
	ctx.lr = 0x82602630;
	sub_82512118(ctx, base);
	// 82602630: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82602634: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602638: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8260263C: 488107F5  bl 0x82e12e30
	ctx.lr = 0x82602640;
	sub_82E12E30(ctx, base);
	// 82602640: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82602644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602648: 419A0008  beq cr6, 0x82602650
	if ctx.cr[6].eq {
	pc = 0x82602650; continue 'dispatch;
	}
	// 8260264C: 4BCBE245  bl 0x822c0890
	ctx.lr = 0x82602650;
	sub_822C0890(ctx, base);
	// 82602650: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82602654: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82602658: 485B0AB1  bl 0x82bb3108
	ctx.lr = 0x8260265C;
	sub_82BB3108(ctx, base);
	// 8260265C: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82602660: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82602664: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82602668: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 8260266C: 419A0024  beq cr6, 0x82602690
	if ctx.cr[6].eq {
	pc = 0x82602690; continue 'dispatch;
	}
	// 82602670: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82602674: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82602678: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260267C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82602680: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82602684: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82602688: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260268C: 4082FFE8  bne 0x82602674
	if !ctx.cr[0].eq {
	pc = 0x82602674; continue 'dispatch;
	}
	// 82602690: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82602694: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82602698: 48812A19  bl 0x82e150b0
	ctx.lr = 0x8260269C;
	sub_82E150B0(ctx, base);
	// 8260269C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826026A0: 419A000C  beq cr6, 0x826026ac
	if ctx.cr[6].eq {
	pc = 0x826026AC; continue 'dispatch;
	}
	// 826026A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826026A8: 4BCBE1E9  bl 0x822c0890
	ctx.lr = 0x826026AC;
	sub_822C0890(ctx, base);
	// 826026AC: 817E00FC  lwz r11, 0xfc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 826026B0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 826026B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826026B8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 826026BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826026C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826026C4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 826026C8: 419A0024  beq cr6, 0x826026ec
	if ctx.cr[6].eq {
	pc = 0x826026EC; continue 'dispatch;
	}
	// 826026CC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826026D0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826026D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826026D8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826026DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826026E0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826026E4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826026E8: 4082FFE8  bne 0x826026d0
	if !ctx.cr[0].eq {
	pc = 0x826026D0; continue 'dispatch;
	}
	// 826026EC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 826026F0: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826026F4: 488129BD  bl 0x82e150b0
	ctx.lr = 0x826026F8;
	sub_82E150B0(ctx, base);
	// 826026F8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826026FC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82602700: 80927058  lwz r4, 0x7058(r18)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82602704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602708: 4BF0E451  bl 0x82510b58
	ctx.lr = 0x8260270C;
	sub_82510B58(ctx, base);
	// 8260270C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82602710: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82602714: 485B09F5  bl 0x82bb3108
	ctx.lr = 0x82602718;
	sub_82BB3108(ctx, base);
	// 82602718: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 8260271C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82602720: 7C75B02E  lwzx r3, r21, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 82602724: 4889E00D  bl 0x82ea0730
	ctx.lr = 0x82602728;
	sub_82EA0730(ctx, base);
	// 82602728: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8260272C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82602730: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82602734: 48917ABD  bl 0x82f1a1f0
	ctx.lr = 0x82602738;
	sub_82F1A1F0(ctx, base);
	// 82602738: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8260273C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82602740: 4182000C  beq 0x8260274c
	if ctx.cr[0].eq {
	pc = 0x8260274C; continue 'dispatch;
	}
	// 82602744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602748: 4BCE5B01  bl 0x822e8248
	ctx.lr = 0x8260274C;
	sub_822E8248(ctx, base);
	// 8260274C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82602750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602754: 487F6DDD  bl 0x82df9530
	ctx.lr = 0x82602758;
	sub_82DF9530(ctx, base);
	// 82602758: 817E00FC  lwz r11, 0xfc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(252 as u32) ) } as u64;
	// 8260275C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82602760: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602764: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82602768: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260276C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82602770: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82602774: 419A0024  beq cr6, 0x82602798
	if ctx.cr[6].eq {
	pc = 0x82602798; continue 'dispatch;
	}
	// 82602778: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8260277C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82602780: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602784: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82602788: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8260278C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82602790: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602794: 4082FFE8  bne 0x8260277c
	if !ctx.cr[0].eq {
	pc = 0x8260277C; continue 'dispatch;
	}
	// 82602798: 38E10078  addi r7, r1, 0x78
	ctx.r[7].s64 = ctx.r[1].s64 + 120;
	// 8260279C: 80D86734  lwz r6, 0x6734(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(26420 as u32) ) } as u64;
	// 826027A0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 826027A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826027A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826027AC: 4BF1094D  bl 0x825130f8
	ctx.lr = 0x826027B0;
	sub_825130F8(ctx, base);
	// 826027B0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 826027B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826027B8: 419A0008  beq cr6, 0x826027c0
	if ctx.cr[6].eq {
	pc = 0x826027C0; continue 'dispatch;
	}
	// 826027BC: 4BCE5AAD  bl 0x822e8268
	ctx.lr = 0x826027C0;
	sub_822E8268(ctx, base);
	// 826027C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826027C4: 419A000C  beq cr6, 0x826027d0
	if ctx.cr[6].eq {
	pc = 0x826027D0; continue 'dispatch;
	}
	// 826027C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826027CC: 4BCE5A9D  bl 0x822e8268
	ctx.lr = 0x826027D0;
	sub_822E8268(ctx, base);
	// 826027D0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826027D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826027D8: 419A0008  beq cr6, 0x826027e0
	if ctx.cr[6].eq {
	pc = 0x826027E0; continue 'dispatch;
	}
	// 826027DC: 4BCBE0B5  bl 0x822c0890
	ctx.lr = 0x826027E0;
	sub_822C0890(ctx, base);
	// 826027E0: 817E0114  lwz r11, 0x114(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) } as u64;
	// 826027E4: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 826027E8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 826027EC: 7F145840  cmplw cr6, r20, r11
	ctx.cr[6].compare_u32(ctx.r[20].u32, ctx.r[11].u32, &mut ctx.xer);
	// 826027F0: 4198FD74  blt cr6, 0x82602564
	if ctx.cr[6].lt {
	pc = 0x82602564; continue 'dispatch;
	}
	// 826027F4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826027F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826027FC: 419A0008  beq cr6, 0x82602804
	if ctx.cr[6].eq {
	pc = 0x82602804; continue 'dispatch;
	}
	// 82602800: 4BCBE091  bl 0x822c0890
	ctx.lr = 0x82602804;
	sub_822C0890(ctx, base);
	// 82602804: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82602808: 488282F9  bl 0x82e2ab00
	ctx.lr = 0x8260280C;
	sub_82E2AB00(ctx, base);
	// 8260280C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82602810: CBE1FF80  lfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82602814: 48BA597C  b 0x831a8190
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82602818 size=72
    let mut pc: u32 = 0x82602818;
    'dispatch: loop {
        match pc {
            0x82602818 => {
    //   block [0x82602818..0x82602860)
	// 82602818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260281C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602824: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260282C: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82602830: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82602834: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82602838: 419A0014  beq cr6, 0x8260284c
	if ctx.cr[6].eq {
	pc = 0x8260284C; continue 'dispatch;
	}
	// 8260283C: 387FFF1C  addi r3, r31, -0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + -228;
	// 82602840: 4BFFFC29  bl 0x82602468
	ctx.lr = 0x82602844;
	sub_82602468(ctx, base);
	// 82602844: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82602848: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8260284C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82602850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82602854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82602858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260285C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82602860 size=148
    let mut pc: u32 = 0x82602860;
    'dispatch: loop {
        match pc {
            0x82602860 => {
    //   block [0x82602860..0x826028F4)
	// 82602860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602868: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260286C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602870: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602878: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8260287C: 4BF0F15D  bl 0x825119d8
	ctx.lr = 0x82602880;
	sub_825119D8(ctx, base);
	// 82602880: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82602884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602888: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 8260288C: 487F117D  bl 0x82df3a08
	ctx.lr = 0x82602890;
	sub_82DF3A08(ctx, base);
	// 82602890: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602894: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260289C: 4BF05EE5  bl 0x82508780
	ctx.lr = 0x826028A0;
	sub_82508780(ctx, base);
	// 826028A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826028A4: 487F0B85  bl 0x82df3428
	ctx.lr = 0x826028A8;
	sub_82DF3428(ctx, base);
	// 826028A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826028AC: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 826028B0: 409A0008  bne cr6, 0x826028b8
	if !ctx.cr[6].eq {
	pc = 0x826028B8; continue 'dispatch;
	}
	// 826028B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826028B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826028BC: 4BF05EE5  bl 0x825087a0
	ctx.lr = 0x826028C0;
	sub_825087A0(ctx, base);
	// 826028C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826028C4: 4BFFFBA5  bl 0x82602468
	ctx.lr = 0x826028C8;
	sub_82602468(ctx, base);
	// 826028C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826028CC: 4BF0F21D  bl 0x82511ae8
	ctx.lr = 0x826028D0;
	sub_82511AE8(ctx, base);
	// 826028D0: 39600120  li r11, 0x120
	ctx.r[11].s64 = 288;
	// 826028D4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826028F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826028F8 size=196
    let mut pc: u32 = 0x826028F8;
    'dispatch: loop {
        match pc {
            0x826028F8 => {
    //   block [0x826028F8..0x826029BC)
	// 826028F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826028FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602900: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82602904: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602908: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260290C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82602910: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82602914: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82602918: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8260291C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82602920: 4BCBE019  bl 0x822c0938
	ctx.lr = 0x82602924;
	sub_822C0938(ctx, base);
	// 82602924: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82602928: 41820028  beq 0x82602950
	if ctx.cr[0].eq {
	pc = 0x82602950; continue 'dispatch;
	}
	// 8260292C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602930: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82602934: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82602938: 392B21D0  addi r9, r11, 0x21d0
	ctx.r[9].s64 = ctx.r[11].s64 + 8656;
	// 8260293C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82602940: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82602944: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82602948: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8260294C: 48000008  b 0x82602954
	pc = 0x82602954; continue 'dispatch;
	// 82602950: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82602954: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82602958: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260295C: 409A0044  bne cr6, 0x826029a0
	if !ctx.cr[6].eq {
	pc = 0x826029A0; continue 'dispatch;
	}
	// 82602960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82602964: 419A001C  beq cr6, 0x82602980
	if ctx.cr[6].eq {
	pc = 0x82602980; continue 'dispatch;
	}
	// 82602968: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260296C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82602970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602974: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8260297C: 4E800421  bctrl
	ctx.lr = 0x82602980;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82602980: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82602984: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82602988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260298C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82602990: 816BFF14  lwz r11, -0xec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-236 as u32) ) } as u64;
	// 82602994: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82602998: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8260299C: 4BCBD665  bl 0x822c0000
	ctx.lr = 0x826029A0;
	sub_822C0000(ctx, base);
	// 826029A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826029A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826029A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826029AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826029B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826029B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826029B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826029C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826029C0 size=148
    let mut pc: u32 = 0x826029C0;
    'dispatch: loop {
        match pc {
            0x826029C0 => {
    //   block [0x826029C0..0x82602A54)
	// 826029C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826029C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826029C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826029CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826029D0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826029D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826029D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826029DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826029E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826029E4: 388B21F0  addi r4, r11, 0x21f0
	ctx.r[4].s64 = ctx.r[11].s64 + 8688;
	// 826029E8: 487F1021  bl 0x82df3a08
	ctx.lr = 0x826029EC;
	sub_82DF3A08(ctx, base);
	// 826029EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826029F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826029F4: 388B21E0  addi r4, r11, 0x21e0
	ctx.r[4].s64 = ctx.r[11].s64 + 8672;
	// 826029F8: 487F1011  bl 0x82df3a08
	ctx.lr = 0x826029FC;
	sub_82DF3A08(ctx, base);
	// 826029FC: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 82602A00: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82602A04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82602A08: 4BFA0649  bl 0x825a3050
	ctx.lr = 0x82602A0C;
	sub_825A3050(ctx, base);
	// 82602A0C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82602A10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602A18: 4BF9F771  bl 0x825a2188
	ctx.lr = 0x82602A1C;
	sub_825A2188(ctx, base);
	// 82602A1C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82602A20: 487F0A09  bl 0x82df3428
	ctx.lr = 0x82602A24;
	sub_82DF3428(ctx, base);
	// 82602A24: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82602A28: 4BCC6291  bl 0x822c8cb8
	ctx.lr = 0x82602A2C;
	sub_822C8CB8(ctx, base);
	// 82602A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602A30: 487F09F9  bl 0x82df3428
	ctx.lr = 0x82602A34;
	sub_82DF3428(ctx, base);
	// 82602A34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602A38: 487F09F1  bl 0x82df3428
	ctx.lr = 0x82602A3C;
	sub_82DF3428(ctx, base);
	// 82602A3C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82602A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82602A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82602A48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82602A4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82602A50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82602A58 size=800
    let mut pc: u32 = 0x82602A58;
    'dispatch: loop {
        match pc {
            0x82602A58 => {
    //   block [0x82602A58..0x82602D78)
	// 82602A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602A5C: 48BA570D  bl 0x831a8168
	ctx.lr = 0x82602A60;
	sub_831A8130(ctx, base);
	// 82602A60: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82602A64: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82602A68: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602A70: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82602A74: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82602A78: 4BF0EF61  bl 0x825119d8
	ctx.lr = 0x82602A7C;
	sub_825119D8(ctx, base);
	// 82602A7C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82602A80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602A84: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82602A88: 487F0F81  bl 0x82df3a08
	ctx.lr = 0x82602A8C;
	sub_82DF3A08(ctx, base);
	// 82602A8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602A90: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602A94: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602A98: 4BF05CE9  bl 0x82508780
	ctx.lr = 0x82602A9C;
	sub_82508780(ctx, base);
	// 82602A9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602AA0: 487F0989  bl 0x82df3428
	ctx.lr = 0x82602AA4;
	sub_82DF3428(ctx, base);
	// 82602AA4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82602AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602AAC: 808BE260  lwz r4, -0x1da0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7584 as u32) ) } as u64;
	// 82602AB0: 487F0F59  bl 0x82df3a08
	ctx.lr = 0x82602AB4;
	sub_82DF3A08(ctx, base);
	// 82602AB4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602AB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602ABC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602AC0: 4BF05CC1  bl 0x82508780
	ctx.lr = 0x82602AC4;
	sub_82508780(ctx, base);
	// 82602AC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602AC8: 487F0961  bl 0x82df3428
	ctx.lr = 0x82602ACC;
	sub_82DF3428(ctx, base);
	// 82602ACC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82602AD0: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82602AD4: 409A0008  bne cr6, 0x82602adc
	if !ctx.cr[6].eq {
	pc = 0x82602ADC; continue 'dispatch;
	}
	// 82602AD8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82602ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602AE0: 4BF05CC1  bl 0x825087a0
	ctx.lr = 0x82602AE4;
	sub_825087A0(ctx, base);
	// 82602AE4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82602AE8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602AEC: 48827FFD  bl 0x82e2aae8
	ctx.lr = 0x82602AF0;
	sub_82E2AAE8(ctx, base);
	// 82602AF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602AF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602AF8: 388B2248  addi r4, r11, 0x2248
	ctx.r[4].s64 = ctx.r[11].s64 + 8776;
	// 82602AFC: 487F0F0D  bl 0x82df3a08
	ctx.lr = 0x82602B00;
	sub_82DF3A08(ctx, base);
	// 82602B00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602B04: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82602B08: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82602B0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82602B10: 4882C361  bl 0x82e2ee70
	ctx.lr = 0x82602B14;
	sub_82E2EE70(ctx, base);
	// 82602B14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602B18: 487F0911  bl 0x82df3428
	ctx.lr = 0x82602B1C;
	sub_82DF3428(ctx, base);
	// 82602B1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82602B20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82602B24: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82602B28: C3CA08A8  lfs f30, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82602B2C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82602B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82602B34: 419A016C  beq cr6, 0x82602ca0
	if ctx.cr[6].eq {
	pc = 0x82602CA0; continue 'dispatch;
	}
	// 82602B38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602B3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602B40: 3BCB2200  addi r30, r11, 0x2200
	ctx.r[30].s64 = ctx.r[11].s64 + 8704;
	// 82602B44: 38A0005B  li r5, 0x5b
	ctx.r[5].s64 = 91;
	// 82602B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602B4C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82602B50: 487EF899  bl 0x82df23e8
	ctx.lr = 0x82602B54;
	sub_82DF23E8(ctx, base);
	// 82602B54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82602B58: 41820014  beq 0x82602b6c
	if ctx.cr[0].eq {
	pc = 0x82602B6C; continue 'dispatch;
	}
	// 82602B5C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82602B60: 48813D31  bl 0x82e16890
	ctx.lr = 0x82602B64;
	sub_82E16890(ctx, base);
	// 82602B64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82602B68: 48000008  b 0x82602b70
	pc = 0x82602B70; continue 'dispatch;
	// 82602B6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82602B70: 3BBF0100  addi r29, r31, 0x100
	ctx.r[29].s64 = ctx.r[31].s64 + 256;
	// 82602B74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82602B78: 4BD5A7F9  bl 0x8235d370
	ctx.lr = 0x82602B7C;
	sub_8235D370(ctx, base);
	// 82602B7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602B80: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602B84: 38A0005E  li r5, 0x5e
	ctx.r[5].s64 = 94;
	// 82602B88: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82602B8C: 487EF85D  bl 0x82df23e8
	ctx.lr = 0x82602B90;
	sub_82DF23E8(ctx, base);
	// 82602B90: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82602B94: 41820054  beq 0x82602be8
	if ctx.cr[0].eq {
	pc = 0x82602BE8; continue 'dispatch;
	}
	// 82602B98: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82602B9C: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82602BA0: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82602BA4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82602BA8: 488793C9  bl 0x82e7bf70
	ctx.lr = 0x82602BAC;
	sub_82E7BF70(ctx, base);
	// 82602BAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82602BB0: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82602BB4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82602BB8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82602BBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82602BC0: 48879459  bl 0x82e7c018
	ctx.lr = 0x82602BC4;
	sub_82E7C018(ctx, base);
	// 82602BC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82602BC8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82602BCC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82602BD0: 4BCC1D31  bl 0x822c4900
	ctx.lr = 0x82602BD4;
	sub_822C4900(ctx, base);
	// 82602BD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82602BD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602BDC: 48810515  bl 0x82e130f0
	ctx.lr = 0x82602BE0;
	sub_82E130F0(ctx, base);
	// 82602BE0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82602BE4: 48000008  b 0x82602bec
	pc = 0x82602BEC; continue 'dispatch;
	// 82602BE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82602BEC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82602BF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602BF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602BF8: 4BCDE421  bl 0x822e1018
	ctx.lr = 0x82602BFC;
	sub_822E1018(ctx, base);
	// 82602BFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82602C00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602C04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602C08: 4BCBD3F9  bl 0x822c0000
	ctx.lr = 0x82602C0C;
	sub_822C0000(ctx, base);
	// 82602C0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82602C10: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82602C14: 4BF0F505  bl 0x82512118
	ctx.lr = 0x82602C18;
	sub_82512118(ctx, base);
	// 82602C18: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82602C1C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602C20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82602C24: 4881020D  bl 0x82e12e30
	ctx.lr = 0x82602C28;
	sub_82E12E30(ctx, base);
	// 82602C28: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82602C2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602C30: 419A0008  beq cr6, 0x82602c38
	if ctx.cr[6].eq {
	pc = 0x82602C38; continue 'dispatch;
	}
	// 82602C34: 4BCBDC5D  bl 0x822c0890
	ctx.lr = 0x82602C38;
	sub_822C0890(ctx, base);
	// 82602C38: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82602C3C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82602C40: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82602C44: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82602C48: 419A0024  beq cr6, 0x82602c6c
	if ctx.cr[6].eq {
	pc = 0x82602C6C; continue 'dispatch;
	}
	// 82602C4C: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82602C50: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82602C54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602C58: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82602C5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82602C60: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82602C64: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602C68: 4082FFE8  bne 0x82602c50
	if !ctx.cr[0].eq {
	pc = 0x82602C50; continue 'dispatch;
	}
	// 82602C6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602C70: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602C74: 4881243D  bl 0x82e150b0
	ctx.lr = 0x82602C78;
	sub_82E150B0(ctx, base);
	// 82602C78: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82602C7C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82602C80: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82602C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602C88: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82602C8C: 4BF0DECD  bl 0x82510b58
	ctx.lr = 0x82602C90;
	sub_82510B58(ctx, base);
	// 82602C90: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82602C94: 419A000C  beq cr6, 0x82602ca0
	if ctx.cr[6].eq {
	pc = 0x82602CA0; continue 'dispatch;
	}
	// 82602C98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602C9C: 4BCBDBF5  bl 0x822c0890
	ctx.lr = 0x82602CA0;
	sub_822C0890(ctx, base);
	// 82602CA0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82602CA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602CA8: 419A0008  beq cr6, 0x82602cb0
	if ctx.cr[6].eq {
	pc = 0x82602CB0; continue 'dispatch;
	}
	// 82602CAC: 4BCBDBE5  bl 0x822c0890
	ctx.lr = 0x82602CB0;
	sub_822C0890(ctx, base);
	// 82602CB0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82602CB4: 48827E4D  bl 0x82e2ab00
	ctx.lr = 0x82602CB8;
	sub_82E2AB00(ctx, base);
	// 82602CB8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82602CBC: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82602CC0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82602CC4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82602CC8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82602CCC: 4889DA65  bl 0x82ea0730
	ctx.lr = 0x82602CD0;
	sub_82EA0730(ctx, base);
	// 82602CD0: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82602CD4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82602CD8: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82602CDC: 48917515  bl 0x82f1a1f0
	ctx.lr = 0x82602CE0;
	sub_82F1A1F0(ctx, base);
	// 82602CE0: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82602CE4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82602CE8: 4182000C  beq 0x82602cf4
	if ctx.cr[0].eq {
	pc = 0x82602CF4; continue 'dispatch;
	}
	// 82602CEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602CF0: 4BCE5559  bl 0x822e8248
	ctx.lr = 0x82602CF4;
	sub_822E8248(ctx, base);
	// 82602CF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82602CF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82602CFC: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 82602D00: 487F6831  bl 0x82df9530
	ctx.lr = 0x82602D04;
	sub_82DF9530(ctx, base);
	// 82602D04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82602D08: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82602D0C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82602D10: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82602D14: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82602D18: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82602D1C: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82602D20: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82602D24: 488792B5  bl 0x82e7bfd8
	ctx.lr = 0x82602D28;
	sub_82E7BFD8(ctx, base);
	// 82602D28: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82602D2C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82602D30: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82602D34: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82602D38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82602D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602D40: 80CB6894  lwz r6, 0x6894(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26772 as u32) ) } as u64;
	// 82602D44: 4BF103AD  bl 0x825130f0
	ctx.lr = 0x82602D48;
	sub_825130F0(ctx, base);
	// 82602D48: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82602D4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602D50: 419A0008  beq cr6, 0x82602d58
	if ctx.cr[6].eq {
	pc = 0x82602D58; continue 'dispatch;
	}
	// 82602D54: 4BCE5515  bl 0x822e8268
	ctx.lr = 0x82602D58;
	sub_822E8268(ctx, base);
	// 82602D58: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82602D5C: 419A000C  beq cr6, 0x82602d68
	if ctx.cr[6].eq {
	pc = 0x82602D68; continue 'dispatch;
	}
	// 82602D60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82602D64: 4BCE5505  bl 0x822e8268
	ctx.lr = 0x82602D68;
	sub_822E8268(ctx, base);
	// 82602D68: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 82602D6C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82602D70: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82602D74: 48BA5444  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82602D78 size=140
    let mut pc: u32 = 0x82602D78;
    'dispatch: loop {
        match pc {
            0x82602D78 => {
    //   block [0x82602D78..0x82602E04)
	// 82602D78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602D7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602D80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602D84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602D88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602D8C: 4BF0F5A5  bl 0x82512330
	ctx.lr = 0x82602D90;
	sub_82512330(ctx, base);
	// 82602D90: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602D94: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82602D98: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82602D9C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82602DA0: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82602DA4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82602DA8: 394A22CC  addi r10, r10, 0x22cc
	ctx.r[10].s64 = ctx.r[10].s64 + 8908;
	// 82602DAC: 392922B8  addi r9, r9, 0x22b8
	ctx.r[9].s64 = ctx.r[9].s64 + 8888;
	// 82602DB0: 3908226C  addi r8, r8, 0x226c
	ctx.r[8].s64 = ctx.r[8].s64 + 8812;
	// 82602DB4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82602DB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82602DBC: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82602DC0: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82602DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602DC8: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82602DCC: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82602DD0: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82602DD4: 917F00F8  stw r11, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82602DD8: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82602DDC: 917F0100  stw r11, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 82602DE0: 917F0104  stw r11, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[11].u32 ) };
	// 82602DE4: 997F0108  stb r11, 0x108(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[11].u8 ) };
	// 82602DE8: 917F0114  stw r11, 0x114(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82602DEC: 917F0118  stw r11, 0x118(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82602DF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82602DF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82602DF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82602DFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82602E00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82602E08 size=8
    let mut pc: u32 = 0x82602E08;
    'dispatch: loop {
        match pc {
            0x82602E08 => {
    //   block [0x82602E08..0x82602E10)
	// 82602E08: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82602E0C: 4800008C  b 0x82602e98
	sub_82602E98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82602E10 size=8
    let mut pc: u32 = 0x82602E10;
    'dispatch: loop {
        match pc {
            0x82602E10 => {
    //   block [0x82602E10..0x82602E18)
	// 82602E10: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82602E14: 48000084  b 0x82602e98
	sub_82602E98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82602E18 size=124
    let mut pc: u32 = 0x82602E18;
    'dispatch: loop {
        match pc {
            0x82602E18 => {
    //   block [0x82602E18..0x82602E94)
	// 82602E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602E20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602E24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602E28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602E2C: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82602E30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602E34: 419A0008  beq cr6, 0x82602e3c
	if ctx.cr[6].eq {
	pc = 0x82602E3C; continue 'dispatch;
	}
	// 82602E38: 4BCBDA59  bl 0x822c0890
	ctx.lr = 0x82602E3C;
	sub_822C0890(ctx, base);
	// 82602E3C: 807F0104  lwz r3, 0x104(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82602E40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602E44: 419A0008  beq cr6, 0x82602e4c
	if ctx.cr[6].eq {
	pc = 0x82602E4C; continue 'dispatch;
	}
	// 82602E48: 4BCBDA49  bl 0x822c0890
	ctx.lr = 0x82602E4C;
	sub_822C0890(ctx, base);
	// 82602E4C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 82602E50: 4BEAE451  bl 0x824b12a0
	ctx.lr = 0x82602E54;
	sub_824B12A0(ctx, base);
	// 82602E54: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82602E58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82602E5C: 419A0008  beq cr6, 0x82602e64
	if ctx.cr[6].eq {
	pc = 0x82602E64; continue 'dispatch;
	}
	// 82602E60: 4BCBDA31  bl 0x822c0890
	ctx.lr = 0x82602E64;
	sub_822C0890(ctx, base);
	// 82602E64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82602E68: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82602E6C: 409A0008  bne cr6, 0x82602e74
	if !ctx.cr[6].eq {
	pc = 0x82602E74; continue 'dispatch;
	}
	// 82602E70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82602E74: 481A47E5  bl 0x827a7658
	ctx.lr = 0x82602E78;
	sub_827A7658(ctx, base);
	// 82602E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602E7C: 4BD4C4D5  bl 0x8234f350
	ctx.lr = 0x82602E80;
	sub_8234F350(ctx, base);
	// 82602E80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82602E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82602E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82602E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82602E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82602E98 size=76
    let mut pc: u32 = 0x82602E98;
    'dispatch: loop {
        match pc {
            0x82602E98 => {
    //   block [0x82602E98..0x82602EE4)
	// 82602E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82602EA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82602EA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82602EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602EAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602EB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82602EB4: 4BFFFF65  bl 0x82602e18
	ctx.lr = 0x82602EB8;
	sub_82602E18(ctx, base);
	// 82602EB8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82602EBC: 4182000C  beq 0x82602ec8
	if ctx.cr[0].eq {
	pc = 0x82602EC8; continue 'dispatch;
	}
	// 82602EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602EC4: 487EF515  bl 0x82df23d8
	ctx.lr = 0x82602EC8;
	sub_82DF23D8(ctx, base);
	// 82602EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82602ECC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82602ED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82602ED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82602ED8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82602EDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82602EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82602EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82602EE8 size=400
    let mut pc: u32 = 0x82602EE8;
    'dispatch: loop {
        match pc {
            0x82602EE8 => {
    //   block [0x82602EE8..0x82603078)
	// 82602EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82602EEC: 48BA527D  bl 0x831a8168
	ctx.lr = 0x82602EF0;
	sub_831A8130(ctx, base);
	// 82602EF0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82602EF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82602EF8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82602EFC: 3BCB2200  addi r30, r11, 0x2200
	ctx.r[30].s64 = ctx.r[11].s64 + 8704;
	// 82602F00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602F04: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 82602F08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602F0C: 3860011C  li r3, 0x11c
	ctx.r[3].s64 = 284;
	// 82602F10: 487EF4D9  bl 0x82df23e8
	ctx.lr = 0x82602F14;
	sub_82DF23E8(ctx, base);
	// 82602F14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82602F18: 41820010  beq 0x82602f28
	if ctx.cr[0].eq {
	pc = 0x82602F28; continue 'dispatch;
	}
	// 82602F1C: 4BFFFE5D  bl 0x82602d78
	ctx.lr = 0x82602F20;
	sub_82602D78(ctx, base);
	// 82602F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82602F24: 48000008  b 0x82602f2c
	pc = 0x82602F2C; continue 'dispatch;
	// 82602F28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82602F2C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82602F30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82602F34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602F38: 4BFFF9C1  bl 0x826028f8
	ctx.lr = 0x82602F3C;
	sub_826028F8(ctx, base);
	// 82602F3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82602F40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82602F44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82602F48: 4BCBD0B9  bl 0x822c0000
	ctx.lr = 0x82602F4C;
	sub_822C0000(ctx, base);
	// 82602F4C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82602F50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82602F54: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82602F58: 409A0008  bne cr6, 0x82602f60
	if !ctx.cr[6].eq {
	pc = 0x82602F60; continue 'dispatch;
	}
	// 82602F5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82602F60: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82602F64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82602F68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82602F6C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82602F70: 419A0024  beq cr6, 0x82602f94
	if ctx.cr[6].eq {
	pc = 0x82602F94; continue 'dispatch;
	}
	// 82602F74: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82602F78: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82602F7C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602F80: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82602F84: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82602F88: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82602F8C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602F90: 4082FFE8  bne 0x82602f78
	if !ctx.cr[0].eq {
	pc = 0x82602F78; continue 'dispatch;
	}
	// 82602F94: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82602F98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82602F9C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82602FA0: 419A0024  beq cr6, 0x82602fc4
	if ctx.cr[6].eq {
	pc = 0x82602FC4; continue 'dispatch;
	}
	// 82602FA4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82602FA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82602FAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602FB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82602FB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82602FB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82602FBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82602FC0: 4082FFE8  bne 0x82602fa8
	if !ctx.cr[0].eq {
	pc = 0x82602FA8; continue 'dispatch;
	}
	// 82602FC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82602FC8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82602FCC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82602FD0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82602FD4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82602FD8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82602FDC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82602FE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82602FE4: 48195F4D  bl 0x82798f30
	ctx.lr = 0x82602FE8;
	sub_82798F30(ctx, base);
	// 82602FE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82602FEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82602FF0: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 82602FF4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82602FF8: 4BCBD3E1  bl 0x822c03d8
	ctx.lr = 0x82602FFC;
	sub_822C03D8(ctx, base);
	// 82602FFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82603000: 41820014  beq 0x82603014
	if ctx.cr[0].eq {
	pc = 0x82603014; continue 'dispatch;
	}
	// 82603004: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82603008: 48198661  bl 0x8279b668
	ctx.lr = 0x8260300C;
	sub_8279B668(ctx, base);
	// 8260300C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603010: 48000008  b 0x82603018
	pc = 0x82603018; continue 'dispatch;
	// 82603014: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82603018: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8260301C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82603020: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603028: 4BF94C29  bl 0x82597c50
	ctx.lr = 0x8260302C;
	sub_82597C50(ctx, base);
	// 8260302C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82603030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603038: 4BCBCFC9  bl 0x822c0000
	ctx.lr = 0x8260303C;
	sub_822C0000(ctx, base);
	// 8260303C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82603040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603044: 419A0008  beq cr6, 0x8260304c
	if ctx.cr[6].eq {
	pc = 0x8260304C; continue 'dispatch;
	}
	// 82603048: 4BCBD849  bl 0x822c0890
	ctx.lr = 0x8260304C;
	sub_822C0890(ctx, base);
	// 8260304C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82603050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603054: 419A0008  beq cr6, 0x8260305c
	if ctx.cr[6].eq {
	pc = 0x8260305C; continue 'dispatch;
	}
	// 82603058: 4BCBD839  bl 0x822c0890
	ctx.lr = 0x8260305C;
	sub_822C0890(ctx, base);
	// 8260305C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82603060: 419A000C  beq cr6, 0x8260306c
	if ctx.cr[6].eq {
	pc = 0x8260306C; continue 'dispatch;
	}
	// 82603064: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82603068: 4BCBD829  bl 0x822c0890
	ctx.lr = 0x8260306C;
	sub_822C0890(ctx, base);
	// 8260306C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82603070: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82603074: 48BA5144  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82603078 size=20
    let mut pc: u32 = 0x82603078;
    'dispatch: loop {
        match pc {
            0x82603078 => {
    //   block [0x82603078..0x8260308C)
	// 82603078: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 8260307C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82603080: 419A0018  beq cr6, 0x82603098
	if ctx.cr[6].eq {
		sub_82603098(ctx, base);
		return;
	}
	// 82603084: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 82603088: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8260308C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8260308C size=12
    let mut pc: u32 = 0x8260308C;
    'dispatch: loop {
        match pc {
            0x8260308C => {
    //   block [0x8260308C..0x82603098)
	// 8260308C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82603090: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82603094: 4800000C  b 0x826030a0
	sub_82603098(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82603098 size=20
    let mut pc: u32 = 0x82603098;
    'dispatch: loop {
        match pc {
            0x82603098 => {
    //   block [0x82603098..0x826030AC)
	// 82603098: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8260309C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826030A0: 99430101  stb r10, 0x101(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(257 as u32), ctx.r[10].u8 ) };
	// 826030A4: 99630100  stb r11, 0x100(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 826030A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826030B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826030B0 size=196
    let mut pc: u32 = 0x826030B0;
    'dispatch: loop {
        match pc {
            0x826030B0 => {
    //   block [0x826030B0..0x82603174)
	// 826030B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826030B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826030B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826030BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826030C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826030C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826030C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826030CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826030D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826030D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826030D8: 4BCBD861  bl 0x822c0938
	ctx.lr = 0x826030DC;
	sub_822C0938(ctx, base);
	// 826030DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826030E0: 41820028  beq 0x82603108
	if ctx.cr[0].eq {
	pc = 0x82603108; continue 'dispatch;
	}
	// 826030E4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826030E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826030EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826030F0: 392B2354  addi r9, r11, 0x2354
	ctx.r[9].s64 = ctx.r[11].s64 + 9044;
	// 826030F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826030F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826030FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82603100: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82603104: 48000008  b 0x8260310c
	pc = 0x8260310C; continue 'dispatch;
	// 82603108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260310C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82603110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82603114: 409A0044  bne cr6, 0x82603158
	if !ctx.cr[6].eq {
	pc = 0x82603158; continue 'dispatch;
	}
	// 82603118: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8260311C: 419A001C  beq cr6, 0x82603138
	if ctx.cr[6].eq {
	pc = 0x82603138; continue 'dispatch;
	}
	// 82603120: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603124: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82603128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260312C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82603134: 4E800421  bctrl
	ctx.lr = 0x82603138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82603138: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260313C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82603140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603144: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82603148: 816BFFB8  lwz r11, -0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-72 as u32) ) } as u64;
	// 8260314C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82603150: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82603154: 4BCBCEAD  bl 0x822c0000
	ctx.lr = 0x82603158;
	sub_822C0000(ctx, base);
	// 82603158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260315C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82603160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82603164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82603168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260316C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82603170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82603178 size=20
    let mut pc: u32 = 0x82603178;
    'dispatch: loop {
        match pc {
            0x82603178 => {
    //   block [0x82603178..0x8260318C)
	// 82603178: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 8260317C: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82603180: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82603184: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82603188: 4BF0EC10  b 0x82511d98
	sub_82511D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82603190 size=88
    let mut pc: u32 = 0x82603190;
    'dispatch: loop {
        match pc {
            0x82603190 => {
    //   block [0x82603190..0x826031E8)
	// 82603190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82603198: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260319C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826031A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826031A4: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 826031A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826031AC: 419A0028  beq cr6, 0x826031d4
	if ctx.cr[6].eq {
	pc = 0x826031D4; continue 'dispatch;
	}
	// 826031B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826031B4: 4887E58D  bl 0x82e81740
	ctx.lr = 0x826031B8;
	sub_82E81740(ctx, base);
	// 826031B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826031BC: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 826031C0: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 826031C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826031C8: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 826031CC: 419A0008  beq cr6, 0x826031d4
	if ctx.cr[6].eq {
	pc = 0x826031D4; continue 'dispatch;
	}
	// 826031D0: 4BCBD6C1  bl 0x822c0890
	ctx.lr = 0x826031D4;
	sub_822C0890(ctx, base);
	// 826031D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 826031D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826031DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826031E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826031E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826031E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826031E8 size=376
    let mut pc: u32 = 0x826031E8;
    'dispatch: loop {
        match pc {
            0x826031E8 => {
    //   block [0x826031E8..0x82603360)
	// 826031E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826031EC: 48BA4F81  bl 0x831a816c
	ctx.lr = 0x826031F0;
	sub_831A8130(ctx, base);
	// 826031F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826031F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826031F8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826031FC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82603200: 4BF0E7D9  bl 0x825119d8
	ctx.lr = 0x82603204;
	sub_825119D8(ctx, base);
	// 82603204: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82603208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260320C: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82603210: 487F07F9  bl 0x82df3a08
	ctx.lr = 0x82603214;
	sub_82DF3A08(ctx, base);
	// 82603214: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82603218: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260321C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603220: 4BF05561  bl 0x82508780
	ctx.lr = 0x82603224;
	sub_82508780(ctx, base);
	// 82603224: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603228: 487F0201  bl 0x82df3428
	ctx.lr = 0x8260322C;
	sub_82DF3428(ctx, base);
	// 8260322C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82603230: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82603234: 409A0008  bne cr6, 0x8260323c
	if !ctx.cr[6].eq {
	pc = 0x8260323C; continue 'dispatch;
	}
	// 82603238: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8260323C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603240: 4BF05561  bl 0x825087a0
	ctx.lr = 0x82603244;
	sub_825087A0(ctx, base);
	// 82603244: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82603248: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260324C: 4882789D  bl 0x82e2aae8
	ctx.lr = 0x82603250;
	sub_82E2AAE8(ctx, base);
	// 82603250: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603258: 388B23B8  addi r4, r11, 0x23b8
	ctx.r[4].s64 = ctx.r[11].s64 + 9144;
	// 8260325C: 487F07AD  bl 0x82df3a08
	ctx.lr = 0x82603260;
	sub_82DF3A08(ctx, base);
	// 82603260: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603264: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82603268: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8260326C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82603270: 4882BC01  bl 0x82e2ee70
	ctx.lr = 0x82603274;
	sub_82E2EE70(ctx, base);
	// 82603274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603278: 487F01B1  bl 0x82df3428
	ctx.lr = 0x8260327C;
	sub_82DF3428(ctx, base);
	// 8260327C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603280: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603284: 388B2370  addi r4, r11, 0x2370
	ctx.r[4].s64 = ctx.r[11].s64 + 9072;
	// 82603288: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 8260328C: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82603290: 487EF159  bl 0x82df23e8
	ctx.lr = 0x82603294;
	sub_82DF23E8(ctx, base);
	// 82603294: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82603298: 41820014  beq 0x826032ac
	if ctx.cr[0].eq {
	pc = 0x826032AC; continue 'dispatch;
	}
	// 8260329C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826032A0: 488135F1  bl 0x82e16890
	ctx.lr = 0x826032A4;
	sub_82E16890(ctx, base);
	// 826032A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826032A8: 48000008  b 0x826032b0
	pc = 0x826032B0; continue 'dispatch;
	// 826032AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826032B0: 3BDF013C  addi r30, r31, 0x13c
	ctx.r[30].s64 = ctx.r[31].s64 + 316;
	// 826032B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826032B8: 4BD5A0B9  bl 0x8235d370
	ctx.lr = 0x826032BC;
	sub_8235D370(ctx, base);
	// 826032BC: 817F013C  lwz r11, 0x13c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 826032C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826032C4: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 826032C8: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 826032CC: 4BF0EACD  bl 0x82511d98
	ctx.lr = 0x826032D0;
	sub_82511D98(ctx, base);
	// 826032D0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 826032D4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826032D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826032DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826032E0: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826032E4: 4BF0D875  bl 0x82510b58
	ctx.lr = 0x826032E8;
	sub_82510B58(ctx, base);
	// 826032E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826032EC: C01F00F4  lfs f0, 0xf4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826032F0: C1AB23B4  lfs f13, 0x23b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826032F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826032F8: 41980014  blt cr6, 0x8260330c
	if ctx.cr[6].lt {
	pc = 0x8260330C; continue 'dispatch;
	}
	// 826032FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82603300: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82603304: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603308: 48000030  b 0x82603338
	pc = 0x82603338; continue 'dispatch;
	// 8260330C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603310: C1ABD7BC  lfs f13, -0x2844(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82603314: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82603318: 41980014  blt cr6, 0x8260332c
	if ctx.cr[6].lt {
	pc = 0x8260332C; continue 'dispatch;
	}
	// 8260331C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82603320: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82603324: C00B0A98  lfs f0, 0xa98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603328: 48000010  b 0x82603338
	pc = 0x82603338; continue 'dispatch;
	// 8260332C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82603330: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82603334: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603338: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8260333C: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82603340: 915F0120  stw r10, 0x120(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), ctx.r[10].u32 ) };
	// 82603344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603348: 419A0008  beq cr6, 0x82603350
	if ctx.cr[6].eq {
	pc = 0x82603350; continue 'dispatch;
	}
	// 8260334C: 4BCBD545  bl 0x822c0890
	ctx.lr = 0x82603350;
	sub_822C0890(ctx, base);
	// 82603350: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82603354: 488277AD  bl 0x82e2ab00
	ctx.lr = 0x82603358;
	sub_82E2AB00(ctx, base);
	// 82603358: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8260335C: 48BA4E60  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82603360 size=104
    let mut pc: u32 = 0x82603360;
    'dispatch: loop {
        match pc {
            0x82603360 => {
    //   block [0x82603360..0x826033C8)
	// 82603360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82603368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260336C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82603370: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603378: 83DF0130  lwz r30, 0x130(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 8260337C: 48000014  b 0x82603390
	pc = 0x82603390; continue 'dispatch;
	// 82603380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603384: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603388: 4BF0F781  bl 0x82512b08
	ctx.lr = 0x8260338C;
	sub_82512B08(ctx, base);
	// 8260338C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82603390: 817F0134  lwz r11, 0x134(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82603394: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82603398: 409AFFE8  bne cr6, 0x82603380
	if !ctx.cr[6].eq {
	pc = 0x82603380; continue 'dispatch;
	}
	// 8260339C: 389F012C  addi r4, r31, 0x12c
	ctx.r[4].s64 = ctx.r[31].s64 + 300;
	// 826033A0: 80BF0130  lwz r5, 0x130(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 826033A4: 5566003E  slwi r6, r11, 0
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 826033A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826033AC: 4BD053BD  bl 0x82308768
	ctx.lr = 0x826033B0;
	sub_82308768(ctx, base);
	// 826033B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826033B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826033B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826033BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826033C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826033C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826033C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826033C8 size=196
    let mut pc: u32 = 0x826033C8;
    'dispatch: loop {
        match pc {
            0x826033C8 => {
    //   block [0x826033C8..0x8260348C)
	// 826033C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826033CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826033D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826033D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826033D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826033DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826033E0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826033E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826033E8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826033EC: C1AA234C  lfs f13, 0x234c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9036 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826033F0: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 826033F4: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 826033F8: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 826033FC: D1BF0124  stfs f13, 0x124(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82603400: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82603404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82603408: 419A0018  beq cr6, 0x82603420
	if ctx.cr[6].eq {
	pc = 0x82603420; continue 'dispatch;
	}
	// 8260340C: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82603410: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82603414: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82603418: 41820008  beq 0x82603420
	if ctx.cr[0].eq {
	pc = 0x82603420; continue 'dispatch;
	}
	// 8260341C: 4BFFFF45  bl 0x82603360
	ctx.lr = 0x82603420;
	sub_82603360(ctx, base);
	// 82603420: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82603424: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82603428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260342C: 419A001C  beq cr6, 0x82603448
	if ctx.cr[6].eq {
	pc = 0x82603448; continue 'dispatch;
	}
	// 82603430: 93DF0144  stw r30, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[30].u32 ) };
	// 82603434: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82603438: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260343C: 93DF0148  stw r30, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 82603440: 419A0008  beq cr6, 0x82603448
	if ctx.cr[6].eq {
	pc = 0x82603448; continue 'dispatch;
	}
	// 82603444: 4BCBD44D  bl 0x822c0890
	ctx.lr = 0x82603448;
	sub_822C0890(ctx, base);
	// 82603448: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 8260344C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603450: 419A0024  beq cr6, 0x82603474
	if ctx.cr[6].eq {
	pc = 0x82603474; continue 'dispatch;
	}
	// 82603454: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82603458: 4887E2E9  bl 0x82e81740
	ctx.lr = 0x8260345C;
	sub_82E81740(ctx, base);
	// 8260345C: 93DF014C  stw r30, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[30].u32 ) };
	// 82603460: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 82603464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603468: 93DF0150  stw r30, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[30].u32 ) };
	// 8260346C: 419A0008  beq cr6, 0x82603474
	if ctx.cr[6].eq {
	pc = 0x82603474; continue 'dispatch;
	}
	// 82603470: 4BCBD421  bl 0x822c0890
	ctx.lr = 0x82603474;
	sub_822C0890(ctx, base);
	// 82603474: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82603478: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260347C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82603480: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82603484: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82603488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82603490 size=200
    let mut pc: u32 = 0x82603490;
    'dispatch: loop {
        match pc {
            0x82603490 => {
    //   block [0x82603490..0x82603558)
	// 82603490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603494: 48BA4CD9  bl 0x831a816c
	ctx.lr = 0x82603498;
	sub_831A8130(ctx, base);
	// 82603498: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260349C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 826034A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826034A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 826034A8: 3BAB6910  addi r29, r11, 0x6910
	ctx.r[29].s64 = ctx.r[11].s64 + 26896;
	// 826034AC: 4BF0E63D  bl 0x82511ae8
	ctx.lr = 0x826034B0;
	sub_82511AE8(ctx, base);
	// 826034B0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 826034B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826034B8: 388B8614  addi r4, r11, -0x79ec
	ctx.r[4].s64 = ctx.r[11].s64 + -31212;
	// 826034BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826034C0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 826034C4: 482089CD  bl 0x8280be90
	ctx.lr = 0x826034C8;
	sub_8280BE90(ctx, base);
	// 826034C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826034CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826034D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826034D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826034D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826034DC: 419A0024  beq cr6, 0x82603500
	if ctx.cr[6].eq {
	pc = 0x82603500; continue 'dispatch;
	}
	// 826034E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826034E4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826034E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826034EC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826034F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826034F4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826034F8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826034FC: 4082FFE8  bne 0x826034e4
	if !ctx.cr[0].eq {
	pc = 0x826034E4; continue 'dispatch;
	}
	// 82603500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603504: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82603508: 48A04C21  bl 0x83008128
	ctx.lr = 0x8260350C;
	sub_83008128(ctx, base);
	// 8260350C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82603510: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82603514: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82603518: 388A2370  addi r4, r10, 0x2370
	ctx.r[4].s64 = ctx.r[10].s64 + 9072;
	// 8260351C: 38A001D3  li r5, 0x1d3
	ctx.r[5].s64 = 467;
	// 82603520: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82603524: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82603528: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8260352C: 48855515  bl 0x82e58a40
	ctx.lr = 0x82603530;
	sub_82E58A40(ctx, base);
	// 82603530: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82603534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603538: 419A0008  beq cr6, 0x82603540
	if ctx.cr[6].eq {
	pc = 0x82603540; continue 'dispatch;
	}
	// 8260353C: 4BCBD355  bl 0x822c0890
	ctx.lr = 0x82603540;
	sub_822C0890(ctx, base);
	// 82603540: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82603544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603548: 419A0008  beq cr6, 0x82603550
	if ctx.cr[6].eq {
	pc = 0x82603550; continue 'dispatch;
	}
	// 8260354C: 4BCBD345  bl 0x822c0890
	ctx.lr = 0x82603550;
	sub_822C0890(ctx, base);
	// 82603550: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82603554: 48BA4C68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82603558 size=856
    let mut pc: u32 = 0x82603558;
    'dispatch: loop {
        match pc {
            0x82603558 => {
    //   block [0x82603558..0x826038B0)
	// 82603558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260355C: 48BA4C0D  bl 0x831a8168
	ctx.lr = 0x82603560;
	sub_831A8130(ctx, base);
	// 82603560: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82603564: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82603568: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8260356C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603570: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82603574: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603578: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8260357C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603580: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82603584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603588: 388B1CE8  addi r4, r11, 0x1ce8
	ctx.r[4].s64 = ctx.r[11].s64 + 7400;
	// 8260358C: 487F047D  bl 0x82df3a08
	ctx.lr = 0x82603590;
	sub_82DF3A08(ctx, base);
	// 82603590: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82603594: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82603598: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 8260359C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 826035A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826035A4: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826035A8: C3CA6218  lfs f30, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826035AC: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826035B0: C3A9964C  lfs f29, -0x69b4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826035B4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 826035B8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826035BC: 4BF9FBF5  bl 0x825a31b0
	ctx.lr = 0x826035C0;
	sub_825A31B0(ctx, base);
	// 826035C0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826035C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826035C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826035CC: 4BF9E1A5  bl 0x825a1770
	ctx.lr = 0x826035D0;
	sub_825A1770(ctx, base);
	// 826035D0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 826035D4: 487EFE55  bl 0x82df3428
	ctx.lr = 0x826035D8;
	sub_82DF3428(ctx, base);
	// 826035D8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 826035DC: 4BCC56DD  bl 0x822c8cb8
	ctx.lr = 0x826035E0;
	sub_822C8CB8(ctx, base);
	// 826035E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826035E4: 487EFE45  bl 0x82df3428
	ctx.lr = 0x826035E8;
	sub_82DF3428(ctx, base);
	// 826035E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826035EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826035F0: 388B1CE0  addi r4, r11, 0x1ce0
	ctx.r[4].s64 = ctx.r[11].s64 + 7392;
	// 826035F4: 487F0415  bl 0x82df3a08
	ctx.lr = 0x826035F8;
	sub_82DF3A08(ctx, base);
	// 826035F8: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 826035FC: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82603600: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82603604: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82603608: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8260360C: 4BF9FBA5  bl 0x825a31b0
	ctx.lr = 0x82603610;
	sub_825A31B0(ctx, base);
	// 82603610: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82603614: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603618: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260361C: 4BF9E155  bl 0x825a1770
	ctx.lr = 0x82603620;
	sub_825A1770(ctx, base);
	// 82603620: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82603624: 487EFE05  bl 0x82df3428
	ctx.lr = 0x82603628;
	sub_82DF3428(ctx, base);
	// 82603628: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 8260362C: 4BCC568D  bl 0x822c8cb8
	ctx.lr = 0x82603630;
	sub_822C8CB8(ctx, base);
	// 82603630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603634: 487EFDF5  bl 0x82df3428
	ctx.lr = 0x82603638;
	sub_82DF3428(ctx, base);
	// 82603638: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260363C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603640: 388B2410  addi r4, r11, 0x2410
	ctx.r[4].s64 = ctx.r[11].s64 + 9232;
	// 82603644: 487F03C5  bl 0x82df3a08
	ctx.lr = 0x82603648;
	sub_82DF3A08(ctx, base);
	// 82603648: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8260364C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82603650: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82603654: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82603658: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8260365C: 4BF9FB55  bl 0x825a31b0
	ctx.lr = 0x82603660;
	sub_825A31B0(ctx, base);
	// 82603660: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82603664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603668: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260366C: 4BF9E105  bl 0x825a1770
	ctx.lr = 0x82603670;
	sub_825A1770(ctx, base);
	// 82603670: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82603674: 487EFDB5  bl 0x82df3428
	ctx.lr = 0x82603678;
	sub_82DF3428(ctx, base);
	// 82603678: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 8260367C: 4BCC563D  bl 0x822c8cb8
	ctx.lr = 0x82603680;
	sub_822C8CB8(ctx, base);
	// 82603680: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603684: 487EFDA5  bl 0x82df3428
	ctx.lr = 0x82603688;
	sub_82DF3428(ctx, base);
	// 82603688: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260368C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603690: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 82603694: 487F0375  bl 0x82df3a08
	ctx.lr = 0x82603698;
	sub_82DF3A08(ctx, base);
	// 82603698: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260369C: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 826036A0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 826036A4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 826036A8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 826036AC: C04BDD6C  lfs f2, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826036B0: 4BF9FB01  bl 0x825a31b0
	ctx.lr = 0x826036B4;
	sub_825A31B0(ctx, base);
	// 826036B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826036B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826036BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826036C0: 4BF9E0B1  bl 0x825a1770
	ctx.lr = 0x826036C4;
	sub_825A1770(ctx, base);
	// 826036C4: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826036C8: 487EFD61  bl 0x82df3428
	ctx.lr = 0x826036CC;
	sub_82DF3428(ctx, base);
	// 826036CC: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826036D0: 4BCC55E9  bl 0x822c8cb8
	ctx.lr = 0x826036D4;
	sub_822C8CB8(ctx, base);
	// 826036D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826036D8: 487EFD51  bl 0x82df3428
	ctx.lr = 0x826036DC;
	sub_82DF3428(ctx, base);
	// 826036DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826036E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826036E4: 388BFD08  addi r4, r11, -0x2f8
	ctx.r[4].s64 = ctx.r[11].s64 + -760;
	// 826036E8: 487F0321  bl 0x82df3a08
	ctx.lr = 0x826036EC;
	sub_82DF3A08(ctx, base);
	// 826036EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826036F0: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 826036F4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826036F8: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 826036FC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82603700: C02B08A4  lfs f1, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82603704: 4BF9FAAD  bl 0x825a31b0
	ctx.lr = 0x82603708;
	sub_825A31B0(ctx, base);
	// 82603708: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8260370C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82603710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603714: 4BF9E05D  bl 0x825a1770
	ctx.lr = 0x82603718;
	sub_825A1770(ctx, base);
	// 82603718: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 8260371C: 487EFD0D  bl 0x82df3428
	ctx.lr = 0x82603720;
	sub_82DF3428(ctx, base);
	// 82603720: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 82603724: 4BCC5595  bl 0x822c8cb8
	ctx.lr = 0x82603728;
	sub_822C8CB8(ctx, base);
	// 82603728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260372C: 487EFCFD  bl 0x82df3428
	ctx.lr = 0x82603730;
	sub_82DF3428(ctx, base);
	// 82603730: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603734: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603738: 388B2370  addi r4, r11, 0x2370
	ctx.r[4].s64 = ctx.r[11].s64 + 9072;
	// 8260373C: 38A00204  li r5, 0x204
	ctx.r[5].s64 = 516;
	// 82603740: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82603744: 4BCBCC95  bl 0x822c03d8
	ctx.lr = 0x82603748;
	sub_822C03D8(ctx, base);
	// 82603748: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8260374C: 41820034  beq 0x82603780
	if ctx.cr[0].eq {
	pc = 0x82603780; continue 'dispatch;
	}
	// 82603750: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603758: 388B2400  addi r4, r11, 0x2400
	ctx.r[4].s64 = ctx.r[11].s64 + 9216;
	// 8260375C: 487F02AD  bl 0x82df3a08
	ctx.lr = 0x82603760;
	sub_82DF3A08(ctx, base);
	// 82603760: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603764: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82603768: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260376C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82603770: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82603774: 4BFA8C9D  bl 0x825ac410
	ctx.lr = 0x82603778;
	sub_825AC410(ctx, base);
	// 82603778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260377C: 48000008  b 0x82603784
	pc = 0x82603784; continue 'dispatch;
	// 82603780: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82603784: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82603788: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260378C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82603790: 4BEEFC29  bl 0x824f33b8
	ctx.lr = 0x82603794;
	sub_824F33B8(ctx, base);
	// 82603794: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82603798: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260379C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 826037A0: 4BCBC861  bl 0x822c0000
	ctx.lr = 0x826037A4;
	sub_822C0000(ctx, base);
	// 826037A4: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826037A8: 4182000C  beq 0x826037b4
	if ctx.cr[0].eq {
	pc = 0x826037B4; continue 'dispatch;
	}
	// 826037AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826037B0: 487EFC79  bl 0x82df3428
	ctx.lr = 0x826037B4;
	sub_82DF3428(ctx, base);
	// 826037B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826037B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826037BC: 388B23F0  addi r4, r11, 0x23f0
	ctx.r[4].s64 = ctx.r[11].s64 + 9200;
	// 826037C0: 487F0249  bl 0x82df3a08
	ctx.lr = 0x826037C4;
	sub_82DF3A08(ctx, base);
	// 826037C4: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 826037C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826037CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826037D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826037D4: 4BFA85ED  bl 0x825abdc0
	ctx.lr = 0x826037D8;
	sub_825ABDC0(ctx, base);
	// 826037D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826037DC: 487EFC4D  bl 0x82df3428
	ctx.lr = 0x826037E0;
	sub_82DF3428(ctx, base);
	// 826037E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826037E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826037E8: 388B23E0  addi r4, r11, 0x23e0
	ctx.r[4].s64 = ctx.r[11].s64 + 9184;
	// 826037EC: 487F021D  bl 0x82df3a08
	ctx.lr = 0x826037F0;
	sub_82DF3A08(ctx, base);
	// 826037F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826037F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826037F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826037FC: 4BFA85C5  bl 0x825abdc0
	ctx.lr = 0x82603800;
	sub_825ABDC0(ctx, base);
	// 82603800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603804: 487EFC25  bl 0x82df3428
	ctx.lr = 0x82603808;
	sub_82DF3428(ctx, base);
	// 82603808: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260380C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603810: 388B23D4  addi r4, r11, 0x23d4
	ctx.r[4].s64 = ctx.r[11].s64 + 9172;
	// 82603814: 487F01F5  bl 0x82df3a08
	ctx.lr = 0x82603818;
	sub_82DF3A08(ctx, base);
	// 82603818: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8260381C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82603820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603824: 4BFA859D  bl 0x825abdc0
	ctx.lr = 0x82603828;
	sub_825ABDC0(ctx, base);
	// 82603828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260382C: 487EFBFD  bl 0x82df3428
	ctx.lr = 0x82603830;
	sub_82DF3428(ctx, base);
	// 82603830: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82603834: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603838: 388B44A0  addi r4, r11, 0x44a0
	ctx.r[4].s64 = ctx.r[11].s64 + 17568;
	// 8260383C: 487F01CD  bl 0x82df3a08
	ctx.lr = 0x82603840;
	sub_82DF3A08(ctx, base);
	// 82603840: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82603844: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82603848: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8260384C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82603850: 419A0024  beq cr6, 0x82603874
	if ctx.cr[6].eq {
	pc = 0x82603874; continue 'dispatch;
	}
	// 82603854: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82603858: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8260385C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603860: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82603864: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82603868: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8260386C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603870: 4082FFE8  bne 0x82603858
	if !ctx.cr[0].eq {
	pc = 0x82603858; continue 'dispatch;
	}
	// 82603874: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82603878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260387C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603880: 4BF9E891  bl 0x825a2110
	ctx.lr = 0x82603884;
	sub_825A2110(ctx, base);
	// 82603884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603888: 487EFBA1  bl 0x82df3428
	ctx.lr = 0x8260388C;
	sub_82DF3428(ctx, base);
	// 8260388C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82603890: 419A000C  beq cr6, 0x8260389c
	if ctx.cr[6].eq {
	pc = 0x8260389C; continue 'dispatch;
	}
	// 82603894: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82603898: 4BCBCFF9  bl 0x822c0890
	ctx.lr = 0x8260389C;
	sub_822C0890(ctx, base);
	// 8260389C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 826038A0: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826038A4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826038A8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826038AC: 48BA490C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826038B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826038B0 size=160
    let mut pc: u32 = 0x826038B0;
    'dispatch: loop {
        match pc {
            0x826038B0 => {
    //   block [0x826038B0..0x82603950)
	// 826038B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826038B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826038B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826038BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826038C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826038C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826038C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826038CC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826038D0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826038D4: 396B2484  addi r11, r11, 0x2484
	ctx.r[11].s64 = ctx.r[11].s64 + 9348;
	// 826038D8: 394A2470  addi r10, r10, 0x2470
	ctx.r[10].s64 = ctx.r[10].s64 + 9328;
	// 826038DC: 39292424  addi r9, r9, 0x2424
	ctx.r[9].s64 = ctx.r[9].s64 + 9252;
	// 826038E0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826038E4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 826038E8: 3BDF00E4  addi r30, r31, 0xe4
	ctx.r[30].s64 = ctx.r[31].s64 + 228;
	// 826038EC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826038F0: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 826038F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826038F8: 419A0008  beq cr6, 0x82603900
	if ctx.cr[6].eq {
	pc = 0x82603900; continue 'dispatch;
	}
	// 826038FC: 4BCBCF95  bl 0x822c0890
	ctx.lr = 0x82603900;
	sub_822C0890(ctx, base);
	// 82603900: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82603904: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603908: 419A0008  beq cr6, 0x82603910
	if ctx.cr[6].eq {
	pc = 0x82603910; continue 'dispatch;
	}
	// 8260390C: 4BCBCF85  bl 0x822c0890
	ctx.lr = 0x82603910;
	sub_822C0890(ctx, base);
	// 82603910: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82603914: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603918: 419A0008  beq cr6, 0x82603920
	if ctx.cr[6].eq {
	pc = 0x82603920; continue 'dispatch;
	}
	// 8260391C: 4BCBCF75  bl 0x822c0890
	ctx.lr = 0x82603920;
	sub_822C0890(ctx, base);
	// 82603920: 387F012C  addi r3, r31, 0x12c
	ctx.r[3].s64 = ctx.r[31].s64 + 300;
	// 82603924: 4BE666DD  bl 0x8246a000
	ctx.lr = 0x82603928;
	sub_8246A000(ctx, base);
	// 82603928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260392C: 481A3D2D  bl 0x827a7658
	ctx.lr = 0x82603930;
	sub_827A7658(ctx, base);
	// 82603930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603934: 4BD4BA1D  bl 0x8234f350
	ctx.lr = 0x82603938;
	sub_8234F350(ctx, base);
	// 82603938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260393C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82603940: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82603944: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82603948: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260394C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82603950 size=8
    let mut pc: u32 = 0x82603950;
    'dispatch: loop {
        match pc {
            0x82603950 => {
    //   block [0x82603950..0x82603958)
	// 82603950: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82603954: 4800000C  b 0x82603960
	sub_82603960(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82603958 size=8
    let mut pc: u32 = 0x82603958;
    'dispatch: loop {
        match pc {
            0x82603958 => {
    //   block [0x82603958..0x82603960)
	// 82603958: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8260395C: 48000004  b 0x82603960
	sub_82603960(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82603960 size=76
    let mut pc: u32 = 0x82603960;
    'dispatch: loop {
        match pc {
            0x82603960 => {
    //   block [0x82603960..0x826039AC)
	// 82603960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82603968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260396C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82603970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603974: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603978: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260397C: 4BFFFF35  bl 0x826038b0
	ctx.lr = 0x82603980;
	sub_826038B0(ctx, base);
	// 82603980: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82603984: 4182000C  beq 0x82603990
	if ctx.cr[0].eq {
	pc = 0x82603990; continue 'dispatch;
	}
	// 82603988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260398C: 487EEA4D  bl 0x82df23d8
	ctx.lr = 0x82603990;
	sub_82DF23D8(ctx, base);
	// 82603990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82603998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260399C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826039A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826039A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826039A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826039B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826039B0 size=232
    let mut pc: u32 = 0x826039B0;
    'dispatch: loop {
        match pc {
            0x826039B0 => {
    //   block [0x826039B0..0x82603A98)
	// 826039B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826039B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826039B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826039BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826039C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826039C4: 4BF0E96D  bl 0x82512330
	ctx.lr = 0x826039C8;
	sub_82512330(ctx, base);
	// 826039C8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826039CC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826039D0: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 826039D4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 826039D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826039DC: C1AA9524  lfs f13, -0x6adc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826039E0: 3CC08204  lis r6, -0x7dfc
	ctx.r[6].s64 = -2113667072;
	// 826039E4: C18908A8  lfs f12, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826039E8: 3CA08204  lis r5, -0x7dfc
	ctx.r[5].s64 = -2113667072;
	// 826039EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826039F0: C1686150  lfs f11, 0x6150(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24912 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 826039F4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826039F8: C00708A4  lfs f0, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826039FC: 390BA214  addi r8, r11, -0x5dec
	ctx.r[8].s64 = ctx.r[11].s64 + -24044;
	// 82603A00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82603A04: C146D7BC  lfs f10, -0x2844(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82603A08: 38E52484  addi r7, r5, 0x2484
	ctx.r[7].s64 = ctx.r[5].s64 + 9348;
	// 82603A0C: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82603A10: 394A2470  addi r10, r10, 0x2470
	ctx.r[10].s64 = ctx.r[10].s64 + 9328;
	// 82603A14: D1BF00E8  stfs f13, 0xe8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82603A18: 39292424  addi r9, r9, 0x2424
	ctx.r[9].s64 = ctx.r[9].s64 + 9252;
	// 82603A1C: D19F00EC  stfs f12, 0xec(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82603A20: D17F00F0  stfs f11, 0xf0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82603A24: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82603A28: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82603A2C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82603A30: D01F00F8  stfs f0, 0xf8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82603A34: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 82603A38: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82603A3C: 917F00FC  stw r11, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[11].u32 ) };
	// 82603A40: D01F010C  stfs f0, 0x10c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82603A44: 997F0100  stb r11, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 82603A48: D15F0114  stfs f10, 0x114(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82603A4C: 997F0101  stb r11, 0x101(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(257 as u32), ctx.r[11].u8 ) };
	// 82603A50: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 82603A54: 997F0110  stb r11, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[11].u8 ) };
	// 82603A58: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82603A5C: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82603A60: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 82603A64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603A68: 917F0138  stw r11, 0x138(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 82603A6C: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82603A70: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82603A74: 917F0144  stw r11, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82603A78: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82603A7C: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 82603A80: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82603A84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82603A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82603A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82603A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82603A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82603A98 size=400
    let mut pc: u32 = 0x82603A98;
    'dispatch: loop {
        match pc {
            0x82603A98 => {
    //   block [0x82603A98..0x82603C28)
	// 82603A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603A9C: 48BA46CD  bl 0x831a8168
	ctx.lr = 0x82603AA0;
	sub_831A8130(ctx, base);
	// 82603AA0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603AA4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603AA8: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82603AAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82603AB0: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 82603AB4: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82603AB8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82603ABC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82603AC0: 4889CC71  bl 0x82ea0730
	ctx.lr = 0x82603AC4;
	sub_82EA0730(ctx, base);
	// 82603AC4: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 82603AC8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82603ACC: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82603AD0: C02A234C  lfs f1, 0x234c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9036 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82603AD4: 4891671D  bl 0x82f1a1f0
	ctx.lr = 0x82603AD8;
	sub_82F1A1F0(ctx, base);
	// 82603AD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603ADC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82603AE0: 388B2370  addi r4, r11, 0x2370
	ctx.r[4].s64 = ctx.r[11].s64 + 9072;
	// 82603AE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603AE8: 38A001A0  li r5, 0x1a0
	ctx.r[5].s64 = 416;
	// 82603AEC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82603AF0: 487EE8F9  bl 0x82df23e8
	ctx.lr = 0x82603AF4;
	sub_82DF23E8(ctx, base);
	// 82603AF4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82603AF8: 41820024  beq 0x82603b1c
	if ctx.cr[0].eq {
	pc = 0x82603B1C; continue 'dispatch;
	}
	// 82603AFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82603B00: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82603B04: 488784D5  bl 0x82e7bfd8
	ctx.lr = 0x82603B08;
	sub_82E7BFD8(ctx, base);
	// 82603B08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82603B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603B10: 4880F5E1  bl 0x82e130f0
	ctx.lr = 0x82603B14;
	sub_82E130F0(ctx, base);
	// 82603B14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603B18: 48000008  b 0x82603b20
	pc = 0x82603B20; continue 'dispatch;
	// 82603B1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82603B20: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82603B24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603B28: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82603B2C: 4BCDD4ED  bl 0x822e1018
	ctx.lr = 0x82603B30;
	sub_822E1018(ctx, base);
	// 82603B30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82603B34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603B38: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82603B3C: 4BCBC4C5  bl 0x822c0000
	ctx.lr = 0x82603B40;
	sub_822C0000(ctx, base);
	// 82603B40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82603B44: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82603B48: 4BF0E5D1  bl 0x82512118
	ctx.lr = 0x82603B4C;
	sub_82512118(ctx, base);
	// 82603B4C: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82603B50: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603B54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603B58: 4880F2D9  bl 0x82e12e30
	ctx.lr = 0x82603B5C;
	sub_82E12E30(ctx, base);
	// 82603B5C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82603B60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603B64: 419A0008  beq cr6, 0x82603b6c
	if ctx.cr[6].eq {
	pc = 0x82603B6C; continue 'dispatch;
	}
	// 82603B68: 4BCBCD29  bl 0x822c0890
	ctx.lr = 0x82603B6C;
	sub_822C0890(ctx, base);
	// 82603B6C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82603B70: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82603B74: 419A000C  beq cr6, 0x82603b80
	if ctx.cr[6].eq {
	pc = 0x82603B80; continue 'dispatch;
	}
	// 82603B78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82603B7C: 4BCE46CD  bl 0x822e8248
	ctx.lr = 0x82603B80;
	sub_822E8248(ctx, base);
	// 82603B80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603B84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82603B88: 388B24C0  addi r4, r11, 0x24c0
	ctx.r[4].s64 = ctx.r[11].s64 + 9408;
	// 82603B8C: 487F59A5  bl 0x82df9530
	ctx.lr = 0x82603B90;
	sub_82DF9530(ctx, base);
	// 82603B90: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82603B94: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 82603B98: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82603B9C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82603BA0: 419A0024  beq cr6, 0x82603bc4
	if ctx.cr[6].eq {
	pc = 0x82603BC4; continue 'dispatch;
	}
	// 82603BA4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82603BA8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82603BAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603BB0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82603BB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82603BB8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82603BBC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603BC0: 4082FFE8  bne 0x82603ba8
	if !ctx.cr[0].eq {
	pc = 0x82603BA8; continue 'dispatch;
	}
	// 82603BC4: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82603BC8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82603BCC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82603BD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82603BD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82603BD8: 80CB6734  lwz r6, 0x6734(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26420 as u32) ) } as u64;
	// 82603BDC: 4BF0F51D  bl 0x825130f8
	ctx.lr = 0x82603BE0;
	sub_825130F8(ctx, base);
	// 82603BE0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82603BE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82603BE8: 387D012C  addi r3, r29, 0x12c
	ctx.r[3].s64 = ctx.r[29].s64 + 300;
	// 82603BEC: 4BEB5525  bl 0x824b9110
	ctx.lr = 0x82603BF0;
	sub_824B9110(ctx, base);
	// 82603BF0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82603BF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603BF8: 419A0008  beq cr6, 0x82603c00
	if ctx.cr[6].eq {
	pc = 0x82603C00; continue 'dispatch;
	}
	// 82603BFC: 4BCE466D  bl 0x822e8268
	ctx.lr = 0x82603C00;
	sub_822E8268(ctx, base);
	// 82603C00: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82603C04: 419A000C  beq cr6, 0x82603c10
	if ctx.cr[6].eq {
	pc = 0x82603C10; continue 'dispatch;
	}
	// 82603C08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82603C0C: 4BCE465D  bl 0x822e8268
	ctx.lr = 0x82603C10;
	sub_822E8268(ctx, base);
	// 82603C10: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82603C14: 419A000C  beq cr6, 0x82603c20
	if ctx.cr[6].eq {
	pc = 0x82603C20; continue 'dispatch;
	}
	// 82603C18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603C1C: 4BCBCC75  bl 0x822c0890
	ctx.lr = 0x82603C20;
	sub_822C0890(ctx, base);
	// 82603C20: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82603C24: 48BA4594  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82603C28 size=184
    let mut pc: u32 = 0x82603C28;
    'dispatch: loop {
        match pc {
            0x82603C28 => {
    //   block [0x82603C28..0x82603CE0)
	// 82603C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82603C30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82603C34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82603C38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603C3C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603C44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82603C48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603C4C: 388B1D60  addi r4, r11, 0x1d60
	ctx.r[4].s64 = ctx.r[11].s64 + 7520;
	// 82603C50: 487EFDB9  bl 0x82df3a08
	ctx.lr = 0x82603C54;
	sub_82DF3A08(ctx, base);
	// 82603C54: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82603C58: 38BF0100  addi r5, r31, 0x100
	ctx.r[5].s64 = ctx.r[31].s64 + 256;
	// 82603C5C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603C60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82603C64: 4BFF4425  bl 0x825f8088
	ctx.lr = 0x82603C68;
	sub_825F8088(ctx, base);
	// 82603C68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603C6C: 487EF7BD  bl 0x82df3428
	ctx.lr = 0x82603C70;
	sub_82DF3428(ctx, base);
	// 82603C70: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603C74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603C78: 388B1D54  addi r4, r11, 0x1d54
	ctx.r[4].s64 = ctx.r[11].s64 + 7508;
	// 82603C7C: 487EFD8D  bl 0x82df3a08
	ctx.lr = 0x82603C80;
	sub_82DF3A08(ctx, base);
	// 82603C80: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82603C84: 38BF0101  addi r5, r31, 0x101
	ctx.r[5].s64 = ctx.r[31].s64 + 257;
	// 82603C88: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603C8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82603C90: 4BFF43F9  bl 0x825f8088
	ctx.lr = 0x82603C94;
	sub_825F8088(ctx, base);
	// 82603C94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603C98: 487EF791  bl 0x82df3428
	ctx.lr = 0x82603C9C;
	sub_82DF3428(ctx, base);
	// 82603C9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603CA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603CA4: 388B24C8  addi r4, r11, 0x24c8
	ctx.r[4].s64 = ctx.r[11].s64 + 9416;
	// 82603CA8: 487EFD61  bl 0x82df3a08
	ctx.lr = 0x82603CAC;
	sub_82DF3A08(ctx, base);
	// 82603CAC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82603CB0: 38BF011C  addi r5, r31, 0x11c
	ctx.r[5].s64 = ctx.r[31].s64 + 284;
	// 82603CB4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603CB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82603CBC: 4BF091E5  bl 0x8250cea0
	ctx.lr = 0x82603CC0;
	sub_8250CEA0(ctx, base);
	// 82603CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82603CC4: 487EF765  bl 0x82df3428
	ctx.lr = 0x82603CC8;
	sub_82DF3428(ctx, base);
	// 82603CC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82603CCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82603CD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82603CD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82603CD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82603CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82603CE0 size=424
    let mut pc: u32 = 0x82603CE0;
    'dispatch: loop {
        match pc {
            0x82603CE0 => {
    //   block [0x82603CE0..0x82603E88)
	// 82603CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603CE4: 48BA4481  bl 0x831a8164
	ctx.lr = 0x82603CE8;
	sub_831A8130(ctx, base);
	// 82603CE8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603CEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82603CF0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82603CF4: 3BCB2370  addi r30, r11, 0x2370
	ctx.r[30].s64 = ctx.r[11].s64 + 9072;
	// 82603CF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82603CFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603D00: 38A000DC  li r5, 0xdc
	ctx.r[5].s64 = 220;
	// 82603D04: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82603D08: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82603D0C: 38600154  li r3, 0x154
	ctx.r[3].s64 = 340;
	// 82603D10: 487EE6D9  bl 0x82df23e8
	ctx.lr = 0x82603D14;
	sub_82DF23E8(ctx, base);
	// 82603D14: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82603D18: 41820010  beq 0x82603d28
	if ctx.cr[0].eq {
	pc = 0x82603D28; continue 'dispatch;
	}
	// 82603D1C: 4BFFFC95  bl 0x826039b0
	ctx.lr = 0x82603D20;
	sub_826039B0(ctx, base);
	// 82603D20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603D24: 48000008  b 0x82603d2c
	pc = 0x82603D2C; continue 'dispatch;
	// 82603D28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82603D2C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82603D30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603D34: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82603D38: 4BFFF379  bl 0x826030b0
	ctx.lr = 0x82603D3C;
	sub_826030B0(ctx, base);
	// 82603D3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82603D40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603D44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82603D48: 4BCBC2B9  bl 0x822c0000
	ctx.lr = 0x82603D4C;
	sub_822C0000(ctx, base);
	// 82603D4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82603D50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82603D54: 38A000DD  li r5, 0xdd
	ctx.r[5].s64 = 221;
	// 82603D58: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82603D5C: 4BCBC67D  bl 0x822c03d8
	ctx.lr = 0x82603D60;
	sub_822C03D8(ctx, base);
	// 82603D60: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82603D64: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82603D68: 418200B4  beq 0x82603e1c
	if ctx.cr[0].eq {
	pc = 0x82603E1C; continue 'dispatch;
	}
	// 82603D6C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82603D70: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82603D74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82603D78: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82603D7C: 409A0008  bne cr6, 0x82603d84
	if !ctx.cr[6].eq {
	pc = 0x82603D84; continue 'dispatch;
	}
	// 82603D80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82603D84: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82603D88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82603D8C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82603D90: 419A0024  beq cr6, 0x82603db4
	if ctx.cr[6].eq {
	pc = 0x82603DB4; continue 'dispatch;
	}
	// 82603D94: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82603D98: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82603D9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603DA0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82603DA4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82603DA8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82603DAC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603DB0: 4082FFE8  bne 0x82603d98
	if !ctx.cr[0].eq {
	pc = 0x82603D98; continue 'dispatch;
	}
	// 82603DB4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82603DB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82603DBC: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82603DC0: 419A0024  beq cr6, 0x82603de4
	if ctx.cr[6].eq {
	pc = 0x82603DE4; continue 'dispatch;
	}
	// 82603DC4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82603DC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82603DCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603DD0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82603DD4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82603DD8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82603DDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82603DE0: 4082FFE8  bne 0x82603dc8
	if !ctx.cr[0].eq {
	pc = 0x82603DC8; continue 'dispatch;
	}
	// 82603DE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82603DE8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82603DEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82603DF0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82603DF4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82603DF8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82603DFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82603E00: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82603E04: 4819512D  bl 0x82798f30
	ctx.lr = 0x82603E08;
	sub_82798F30(ctx, base);
	// 82603E08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82603E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603E10: 48197859  bl 0x8279b668
	ctx.lr = 0x82603E14;
	sub_8279B668(ctx, base);
	// 82603E14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603E18: 48000008  b 0x82603e20
	pc = 0x82603E20; continue 'dispatch;
	// 82603E1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82603E20: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82603E24: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82603E28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603E2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603E30: 4BF93E21  bl 0x82597c50
	ctx.lr = 0x82603E34;
	sub_82597C50(ctx, base);
	// 82603E34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82603E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603E3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82603E40: 4BCBC1C1  bl 0x822c0000
	ctx.lr = 0x82603E44;
	sub_822C0000(ctx, base);
	// 82603E44: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82603E48: 41820024  beq 0x82603e6c
	if ctx.cr[0].eq {
	pc = 0x82603E6C; continue 'dispatch;
	}
	// 82603E4C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82603E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603E54: 419A0008  beq cr6, 0x82603e5c
	if ctx.cr[6].eq {
	pc = 0x82603E5C; continue 'dispatch;
	}
	// 82603E58: 4BCBCA39  bl 0x822c0890
	ctx.lr = 0x82603E5C;
	sub_822C0890(ctx, base);
	// 82603E5C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82603E60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603E64: 419A0008  beq cr6, 0x82603e6c
	if ctx.cr[6].eq {
	pc = 0x82603E6C; continue 'dispatch;
	}
	// 82603E68: 4BCBCA29  bl 0x822c0890
	ctx.lr = 0x82603E6C;
	sub_822C0890(ctx, base);
	// 82603E6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82603E70: 419A000C  beq cr6, 0x82603e7c
	if ctx.cr[6].eq {
	pc = 0x82603E7C; continue 'dispatch;
	}
	// 82603E74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82603E78: 4BCBCA19  bl 0x822c0890
	ctx.lr = 0x82603E7C;
	sub_822C0890(ctx, base);
	// 82603E7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82603E80: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82603E84: 48BA4330  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82603E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82603E88 size=596
    let mut pc: u32 = 0x82603E88;
    'dispatch: loop {
        match pc {
            0x82603E88 => {
    //   block [0x82603E88..0x826040DC)
	// 82603E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82603E8C: 48BA42E1  bl 0x831a816c
	ctx.lr = 0x82603E90;
	sub_831A8130(ctx, base);
	// 82603E90: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82603E94: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82603E98: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82603E9C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82603EA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82603EA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82603EA8: C01F0124  lfs f0, 0x124(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603EAC: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82603EB0: C3AB08A4  lfs f29, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82603EB4: D01F0124  stfs f0, 0x124(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82603EB8: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82603EBC: 419900D4  bgt cr6, 0x82603f90
	if ctx.cr[6].gt {
	pc = 0x82603F90; continue 'dispatch;
	}
	// 82603EC0: 3FC08204  lis r30, -0x7dfc
	ctx.r[30].s64 = -2113667072;
	// 82603EC4: C1BF0128  lfs f13, 0x128(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82603EC8: C01F00F0  lfs f0, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603ECC: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82603ED0: C19E234C  lfs f12, 0x234c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9036 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82603ED4: EDAC0824  fdivs f13, f12, f1
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[1].f64) as f32) as f64;
	// 82603ED8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82603EDC: 40990008  ble cr6, 0x82603ee4
	if !ctx.cr[6].gt {
	pc = 0x82603EE4; continue 'dispatch;
	}
	// 82603EE0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82603EE4: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82603EE8: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82603EEC: C17F0118  lfs f11, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82603EF0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82603EF4: D1BF0114  stfs f13, 0x114(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82603EF8: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82603EFC: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82603F00: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82603F04: 4198008C  blt cr6, 0x82603f90
	if ctx.cr[6].lt {
	pc = 0x82603F90; continue 'dispatch;
	}
	// 82603F08: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82603F0C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82603F10: C3CB9F78  lfs f30, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82603F14: C3EA964C  lfs f31, -0x69b4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82603F18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603F1C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82603F20: 4BF0B411  bl 0x8250f330
	ctx.lr = 0x82603F24;
	sub_8250F330(ctx, base);
	// 82603F24: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603F28: 4BEE5929  bl 0x824e9850
	ctx.lr = 0x82603F2C;
	sub_824E9850(ctx, base);
	// 82603F2C: C01E234C  lfs f0, 0x234c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603F30: EC0107FA  fmadds f0, f1, f31, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82603F34: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82603F38: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82603F3C: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82603F40: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82603F44: D01F0114  stfs f0, 0x114(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82603F48: 487EDD49  bl 0x82df1c90
	ctx.lr = 0x82603F4C;
	sub_82DF1C90(ctx, base);
	// 82603F4C: C01E234C  lfs f0, 0x234c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603F50: C1BF0118  lfs f13, 0x118(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82603F54: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82603F58: C17F0128  lfs f11, 0x128(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82603F5C: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82603F60: 40980024  bge cr6, 0x82603f84
	if !ctx.cr[6].lt {
	pc = 0x82603F84; continue 'dispatch;
	}
	// 82603F64: D3A10090  stfs f29, 0x90(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82603F68: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82603F6C: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82603F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82603F74: D3A10098  stfs f29, 0x98(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82603F78: D3A1009C  stfs f29, 0x9c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82603F7C: 4BFFFB1D  bl 0x82603a98
	ctx.lr = 0x82603F80;
	sub_82603A98(ctx, base);
	// 82603F80: C01E234C  lfs f0, 0x234c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82603F84: C1BF0114  lfs f13, 0x114(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(276 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82603F88: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82603F8C: 4098FF8C  bge cr6, 0x82603f18
	if !ctx.cr[6].lt {
	pc = 0x82603F18; continue 'dispatch;
	}
	// 82603F90: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 82603F94: 3BDF0144  addi r30, r31, 0x144
	ctx.r[30].s64 = ctx.r[31].s64 + 324;
	// 82603F98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82603F9C: 409A004C  bne cr6, 0x82603fe8
	if !ctx.cr[6].eq {
	pc = 0x82603FE8; continue 'dispatch;
	}
	// 82603FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603FA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82603FA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82603FAC: 38AA24D4  addi r5, r10, 0x24d4
	ctx.r[5].s64 = ctx.r[10].s64 + 9428;
	// 82603FB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82603FB4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82603FB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82603FBC: 4E800421  bctrl
	ctx.lr = 0x82603FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82603FC0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82603FC4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82603FC8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82603FCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82603FD0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82603FD4: 4BCC048D  bl 0x822c4460
	ctx.lr = 0x82603FD8;
	sub_822C4460(ctx, base);
	// 82603FD8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82603FDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82603FE0: 419A0008  beq cr6, 0x82603fe8
	if ctx.cr[6].eq {
	pc = 0x82603FE8; continue 'dispatch;
	}
	// 82603FE4: 4BCBC8AD  bl 0x822c0890
	ctx.lr = 0x82603FE8;
	sub_822C0890(ctx, base);
	// 82603FE8: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82603FEC: 3BBF014C  addi r29, r31, 0x14c
	ctx.r[29].s64 = ctx.r[31].s64 + 332;
	// 82603FF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82603FF4: 409A00D4  bne cr6, 0x826040c8
	if !ctx.cr[6].eq {
	pc = 0x826040C8; continue 'dispatch;
	}
	// 82603FF8: 817F0120  lwz r11, 0x120(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(288 as u32) ) } as u64;
	// 82603FFC: 3D408329  lis r10, -0x7cd7
	ctx.r[10].s64 = -2094465024;
	// 82604000: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604004: 394AFFAC  addi r10, r10, -0x54
	ctx.r[10].s64 = ctx.r[10].s64 + -84;
	// 82604008: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8260400C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82604010: 487EF9F9  bl 0x82df3a08
	ctx.lr = 0x82604014;
	sub_82DF3A08(ctx, base);
	// 82604014: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604018: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8260401C: 4BF0B4AD  bl 0x8250f4c8
	ctx.lr = 0x82604020;
	sub_8250F4C8(ctx, base);
	// 82604020: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82604028: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 8260402C: 409A0008  bne cr6, 0x82604034
	if !ctx.cr[6].eq {
	pc = 0x82604034; continue 'dispatch;
	}
	// 82604030: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82604034: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82604038: 4BF06919  bl 0x8250a950
	ctx.lr = 0x8260403C;
	sub_8250A950(ctx, base);
	// 8260403C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604040: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82604044: 3BCBFF40  addi r30, r11, -0xc0
	ctx.r[30].s64 = ctx.r[11].s64 + -192;
	// 82604048: 409A0008  bne cr6, 0x82604050
	if !ctx.cr[6].eq {
	pc = 0x82604050; continue 'dispatch;
	}
	// 8260404C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82604050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604054: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82604058: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8260405C: 4BF0E0BD  bl 0x82512118
	ctx.lr = 0x82604060;
	sub_82512118(ctx, base);
	// 82604060: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82604064: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82604068: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8260406C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82604070: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82604074: 481D0C3D  bl 0x827d4cb0
	ctx.lr = 0x82604078;
	sub_827D4CB0(ctx, base);
	// 82604078: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260407C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 82604080: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82604084: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604088: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260408C: 4BCC03D5  bl 0x822c4460
	ctx.lr = 0x82604090;
	sub_822C4460(ctx, base);
	// 82604090: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82604094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82604098: 419A0008  beq cr6, 0x826040a0
	if ctx.cr[6].eq {
	pc = 0x826040A0; continue 'dispatch;
	}
	// 8260409C: 4BCBC7F5  bl 0x822c0890
	ctx.lr = 0x826040A0;
	sub_822C0890(ctx, base);
	// 826040A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826040A4: 487EDBED  bl 0x82df1c90
	ctx.lr = 0x826040A8;
	sub_82DF1C90(ctx, base);
	// 826040A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 826040AC: 487EDBE5  bl 0x82df1c90
	ctx.lr = 0x826040B0;
	sub_82DF1C90(ctx, base);
	// 826040B0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826040B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826040B8: 419A0008  beq cr6, 0x826040c0
	if ctx.cr[6].eq {
	pc = 0x826040C0; continue 'dispatch;
	}
	// 826040BC: 4BCBC7D5  bl 0x822c0890
	ctx.lr = 0x826040C0;
	sub_822C0890(ctx, base);
	// 826040C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826040C4: 487EF365  bl 0x82df3428
	ctx.lr = 0x826040C8;
	sub_82DF3428(ctx, base);
	// 826040C8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 826040CC: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826040D0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826040D4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826040D8: 48BA40E4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826040E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826040E0 size=100
    let mut pc: u32 = 0x826040E0;
    'dispatch: loop {
        match pc {
            0x826040E0 => {
    //   block [0x826040E0..0x82604144)
	// 826040E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826040E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826040E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826040EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826040F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826040F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826040F8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 826040FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82604100: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82604104: 4BEB10D5  bl 0x824b51d8
	ctx.lr = 0x82604108;
	sub_824B51D8(ctx, base);
	// 82604108: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 8260410C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82604110: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82604114: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82604118: 4BEB10C1  bl 0x824b51d8
	ctx.lr = 0x8260411C;
	sub_824B51D8(ctx, base);
	// 8260411C: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82604120: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82604124: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82604128: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8260412C: 4BEB10AD  bl 0x824b51d8
	ctx.lr = 0x82604130;
	sub_824B51D8(ctx, base);
	// 82604130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82604134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82604138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260413C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82604140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82604148 size=220
    let mut pc: u32 = 0x82604148;
    'dispatch: loop {
        match pc {
            0x82604148 => {
    //   block [0x82604148..0x82604224)
	// 82604148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260414C: 48BA401D  bl 0x831a8168
	ctx.lr = 0x82604150;
	sub_831A8130(ctx, base);
	// 82604150: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604154: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82604158: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8260415C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82604160: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82604164: 41820038  beq 0x8260419c
	if ctx.cr[0].eq {
	pc = 0x8260419C; continue 'dispatch;
	}
	// 82604168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260416C: 48BA581D  bl 0x831a9988
	ctx.lr = 0x82604170;
	sub_831A9988(ctx, base);
	// 82604170: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82604174: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82604178: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 8260417C: 48BA3F7D  bl 0x831a80f8
	ctx.lr = 0x82604180;
	sub_831A80F8(ctx, base);
	// 82604180: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82604184: 41820018  beq 0x8260419c
	if ctx.cr[0].eq {
	pc = 0x8260419C; continue 'dispatch;
	}
	// 82604188: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260418C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82604190: 4BFFF301  bl 0x82603490
	ctx.lr = 0x82604194;
	sub_82603490(ctx, base);
	// 82604194: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82604198: 48000084  b 0x8260421c
	pc = 0x8260421C; continue 'dispatch;
	// 8260419C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826041A0: 419A006C  beq cr6, 0x8260420c
	if ctx.cr[6].eq {
	pc = 0x8260420C; continue 'dispatch;
	}
	// 826041A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826041A8: 48BA57E1  bl 0x831a9988
	ctx.lr = 0x826041AC;
	sub_831A9988(ctx, base);
	// 826041AC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826041B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826041B4: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 826041B8: 48BA3F41  bl 0x831a80f8
	ctx.lr = 0x826041BC;
	sub_831A80F8(ctx, base);
	// 826041BC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826041C0: 41820014  beq 0x826041d4
	if ctx.cr[0].eq {
	pc = 0x826041D4; continue 'dispatch;
	}
	// 826041C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826041C8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 826041CC: 4BFFFF15  bl 0x826040e0
	ctx.lr = 0x826041D0;
	sub_826040E0(ctx, base);
	// 826041D0: 4BFFFFC4  b 0x82604194
	pc = 0x82604194; continue 'dispatch;
	// 826041D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 826041D8: 419A0034  beq cr6, 0x8260420c
	if ctx.cr[6].eq {
	pc = 0x8260420C; continue 'dispatch;
	}
	// 826041DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826041E0: 48BA57A9  bl 0x831a9988
	ctx.lr = 0x826041E4;
	sub_831A9988(ctx, base);
	// 826041E4: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826041E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826041EC: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826041F0: 48BA3F09  bl 0x831a80f8
	ctx.lr = 0x826041F4;
	sub_831A80F8(ctx, base);
	// 826041F4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826041F8: 41820014  beq 0x8260420c
	if ctx.cr[0].eq {
	pc = 0x8260420C; continue 'dispatch;
	}
	// 826041FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604200: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82604204: 4BFFEE75  bl 0x82603078
	ctx.lr = 0x82604208;
	sub_82603078(ctx, base);
	// 82604208: 4BFFFF8C  b 0x82604194
	pc = 0x82604194; continue 'dispatch;
	// 8260420C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82604210: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604218: 4BF0E401  bl 0x82512618
	ctx.lr = 0x8260421C;
	sub_82512618(ctx, base);
	// 8260421C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82604220: 48BA3F98  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82604228 size=464
    let mut pc: u32 = 0x82604228;
    'dispatch: loop {
        match pc {
            0x82604228 => {
    //   block [0x82604228..0x826043F8)
	// 82604228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260422C: 48BA3F41  bl 0x831a816c
	ctx.lr = 0x82604230;
	sub_831A8130(ctx, base);
	// 82604230: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82604234: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604238: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260423C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82604240: 4BF0C4C9  bl 0x82510708
	ctx.lr = 0x82604244;
	sub_82510708(ctx, base);
	// 82604244: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260424C: 4BF0B27D  bl 0x8250f4c8
	ctx.lr = 0x82604250;
	sub_8250F4C8(ctx, base);
	// 82604250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604254: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82604258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260425C: 386BFFFC  addi r3, r11, -4
	ctx.r[3].s64 = ctx.r[11].s64 + -4;
	// 82604260: 409A0008  bne cr6, 0x82604268
	if !ctx.cr[6].eq {
	pc = 0x82604268; continue 'dispatch;
	}
	// 82604264: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82604268: 4BF042B1  bl 0x82508518
	ctx.lr = 0x8260426C;
	sub_82508518(ctx, base);
	// 8260426C: C01F00F8  lfs f0, 0xf8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604270: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604274: EFE1002A  fadds f31, f1, f0
	ctx.f[31].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82604278: 487EDA19  bl 0x82df1c90
	ctx.lr = 0x8260427C;
	sub_82DF1C90(ctx, base);
	// 8260427C: C1BF00E8  lfs f13, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82604280: C01F00EC  lfs f0, 0xec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604284: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82604288: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 8260428C: 41980028  blt cr6, 0x826042b4
	if ctx.cr[6].lt {
	pc = 0x826042B4; continue 'dispatch;
	}
	// 82604290: ED9F0024  fdivs f12, f31, f0
	ctx.f[12].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82604294: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82604298: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 8260429C: E961005E  lwa r11, 0x5c(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as i32) as i64;
	// 826042A0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 826042A4: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 826042A8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 826042AC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 826042B0: EFECF83C  fnmsubs f31, f12, f0, f31
	ctx.f[31].f64 = -(((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 826042B4: 817F00FC  lwz r11, 0xfc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) } as u64;
	// 826042B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 826042BC: 41980060  blt cr6, 0x8260431c
	if ctx.cr[6].lt {
	pc = 0x8260431C; continue 'dispatch;
	}
	// 826042C0: 419A0044  beq cr6, 0x82604304
	if ctx.cr[6].eq {
	pc = 0x82604304; continue 'dispatch;
	}
	// 826042C4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 826042C8: 40980124  bge cr6, 0x826043ec
	if !ctx.cr[6].lt {
	pc = 0x826043EC; continue 'dispatch;
	}
	// 826042CC: 897F0100  lbz r11, 0x100(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) } as u64;
	// 826042D0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826042D4: 4182003C  beq 0x82604310
	if ctx.cr[0].eq {
	pc = 0x82604310; continue 'dispatch;
	}
	// 826042D8: C1BF00F8  lfs f13, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826042DC: C01F011C  lfs f0, 0x11c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(284 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826042E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 826042E4: 40980014  bge cr6, 0x826042f8
	if !ctx.cr[6].lt {
	pc = 0x826042F8; continue 'dispatch;
	}
	// 826042E8: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826042EC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 826042F0: D01F011C  stfs f0, 0x11c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(284 as u32), tmp.u32 ) };
	// 826042F4: 480000F8  b 0x826043ec
	pc = 0x826043EC; continue 'dispatch;
	// 826042F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826042FC: C04B08A8  lfs f2, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82604300: 480000E0  b 0x826043e0
	pc = 0x826043E0; continue 'dispatch;
	// 82604304: 897F0101  lbz r11, 0x101(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(257 as u32) ) } as u64;
	// 82604308: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8260430C: 4182FFCC  beq 0x826042d8
	if ctx.cr[0].eq {
	pc = 0x826042D8; continue 'dispatch;
	}
	// 82604310: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604314: 4BFFF0B5  bl 0x826033c8
	ctx.lr = 0x82604318;
	sub_826033C8(ctx, base);
	// 82604318: 480000D4  b 0x826043ec
	pc = 0x826043EC; continue 'dispatch;
	// 8260431C: FF1F6800  fcmpu cr6, f31, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 82604320: 4098009C  bge cr6, 0x826043bc
	if !ctx.cr[6].lt {
	pc = 0x826043BC; continue 'dispatch;
	}
	// 82604324: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82604328: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8260432C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604330: C1AA234C  lfs f13, 0x234c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9036 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82604334: D01F0118  stfs f0, 0x118(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82604338: D01F0104  stfs f0, 0x104(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 8260433C: D01F0108  stfs f0, 0x108(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82604340: D1BF0124  stfs f13, 0x124(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82604344: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 82604348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260434C: 419A001C  beq cr6, 0x82604368
	if ctx.cr[6].eq {
	pc = 0x82604368; continue 'dispatch;
	}
	// 82604350: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 82604354: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82604358: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260435C: 4182000C  beq 0x82604368
	if ctx.cr[0].eq {
	pc = 0x82604368; continue 'dispatch;
	}
	// 82604360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604364: 4BFFEFFD  bl 0x82603360
	ctx.lr = 0x82604368;
	sub_82603360(ctx, base);
	// 82604368: 817F0144  lwz r11, 0x144(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(324 as u32) ) } as u64;
	// 8260436C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82604370: 419A001C  beq cr6, 0x8260438c
	if ctx.cr[6].eq {
	pc = 0x8260438C; continue 'dispatch;
	}
	// 82604374: 93BF0144  stw r29, 0x144(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(324 as u32), ctx.r[29].u32 ) };
	// 82604378: 807F0148  lwz r3, 0x148(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 8260437C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82604380: 93BF0148  stw r29, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[29].u32 ) };
	// 82604384: 419A0008  beq cr6, 0x8260438c
	if ctx.cr[6].eq {
	pc = 0x8260438C; continue 'dispatch;
	}
	// 82604388: 4BCBC509  bl 0x822c0890
	ctx.lr = 0x8260438C;
	sub_822C0890(ctx, base);
	// 8260438C: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82604390: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82604394: 419A0058  beq cr6, 0x826043ec
	if ctx.cr[6].eq {
	pc = 0x826043EC; continue 'dispatch;
	}
	// 82604398: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8260439C: 4887D3A5  bl 0x82e81740
	ctx.lr = 0x826043A0;
	sub_82E81740(ctx, base);
	// 826043A0: 93BF014C  stw r29, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[29].u32 ) };
	// 826043A4: 807F0150  lwz r3, 0x150(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(336 as u32) ) } as u64;
	// 826043A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826043AC: 93BF0150  stw r29, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[29].u32 ) };
	// 826043B0: 419A003C  beq cr6, 0x826043ec
	if ctx.cr[6].eq {
	pc = 0x826043EC; continue 'dispatch;
	}
	// 826043B4: 4BCBC4DD  bl 0x822c0890
	ctx.lr = 0x826043B8;
	sub_822C0890(ctx, base);
	// 826043B8: 48000034  b 0x826043ec
	pc = 0x826043EC; continue 'dispatch;
	// 826043BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826043C0: C1AB9450  lfs f13, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826043C4: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 826043C8: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 826043CC: 4198FF2C  blt cr6, 0x826042f8
	if ctx.cr[6].lt {
	pc = 0x826042F8; continue 'dispatch;
	}
	// 826043D0: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 826043D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826043D8: C00B9524  lfs f0, -0x6adc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826043DC: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 826043E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826043E4: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826043E8: 4BFFFAA1  bl 0x82603e88
	ctx.lr = 0x826043EC;
	sub_82603E88(ctx, base);
	// 826043EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 826043F0: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 826043F4: 48BA3DC8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826043F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826043F8 size=152
    let mut pc: u32 = 0x826043F8;
    'dispatch: loop {
        match pc {
            0x826043F8 => {
    //   block [0x826043F8..0x82604490)
	// 826043F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826043FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82604400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82604404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82604408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260440C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82604410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82604414: 4BF0C2F5  bl 0x82510708
	ctx.lr = 0x82604418;
	sub_82510708(ctx, base);
	// 82604418: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260441C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82604420: 48858A59  bl 0x82e5ce78
	ctx.lr = 0x82604424;
	sub_82E5CE78(ctx, base);
	// 82604424: 897F0160  lbz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 82604428: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8260442C: 41820038  beq 0x82604464
	if ctx.cr[0].eq {
	pc = 0x82604464; continue 'dispatch;
	}
	// 82604430: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604434: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604438: C1BF0164  lfs f13, 0x164(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8260443C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82604440: D1BF0164  stfs f13, 0x164(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82604444: C00B2550  lfs f0, 0x2550(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604448: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8260444C: 41980018  blt cr6, 0x82604464
	if ctx.cr[6].lt {
	pc = 0x82604464; continue 'dispatch;
	}
	// 82604450: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82604454: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82604458: 995F0160  stb r10, 0x160(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[10].u8 ) };
	// 8260445C: C00B08A4  lfs f0, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604460: D01F0164  stfs f0, 0x164(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82604464: 807F01B4  lwz r3, 0x1b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82604468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260446C: 419A000C  beq cr6, 0x82604478
	if ctx.cr[6].eq {
	pc = 0x82604478; continue 'dispatch;
	}
	// 82604470: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82604474: 481C70A5  bl 0x827cb518
	ctx.lr = 0x82604478;
	sub_827CB518(ctx, base);
	// 82604478: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260447C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82604480: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82604484: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82604488: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260448C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82604490 size=196
    let mut pc: u32 = 0x82604490;
    'dispatch: loop {
        match pc {
            0x82604490 => {
    //   block [0x82604490..0x82604554)
	// 82604490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604494: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82604498: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260449C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826044A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826044A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826044A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826044AC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826044B0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826044B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826044B8: 4BCBC481  bl 0x822c0938
	ctx.lr = 0x826044BC;
	sub_822C0938(ctx, base);
	// 826044BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826044C0: 41820028  beq 0x826044e8
	if ctx.cr[0].eq {
	pc = 0x826044E8; continue 'dispatch;
	}
	// 826044C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826044C8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826044CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826044D0: 392B2570  addi r9, r11, 0x2570
	ctx.r[9].s64 = ctx.r[11].s64 + 9584;
	// 826044D4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826044D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826044DC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826044E0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826044E4: 48000008  b 0x826044ec
	pc = 0x826044EC; continue 'dispatch;
	// 826044E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826044EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826044F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826044F4: 409A0044  bne cr6, 0x82604538
	if !ctx.cr[6].eq {
	pc = 0x82604538; continue 'dispatch;
	}
	// 826044F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826044FC: 419A001C  beq cr6, 0x82604518
	if ctx.cr[6].eq {
	pc = 0x82604518; continue 'dispatch;
	}
	// 82604500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604504: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82604508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260450C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82604510: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82604514: 4E800421  bctrl
	ctx.lr = 0x82604518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82604518: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260451C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82604520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604524: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82604528: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8260452C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82604530: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82604534: 4BCBBACD  bl 0x822c0000
	ctx.lr = 0x82604538;
	sub_822C0000(ctx, base);
	// 82604538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260453C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82604540: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82604544: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82604548: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260454C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82604550: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82604558 size=196
    let mut pc: u32 = 0x82604558;
    'dispatch: loop {
        match pc {
            0x82604558 => {
    //   block [0x82604558..0x8260461C)
	// 82604558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260455C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82604560: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82604564: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82604568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260456C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82604570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82604574: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82604578: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8260457C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604580: 4BCBC3B9  bl 0x822c0938
	ctx.lr = 0x82604584;
	sub_822C0938(ctx, base);
	// 82604584: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82604588: 41820028  beq 0x826045b0
	if ctx.cr[0].eq {
	pc = 0x826045B0; continue 'dispatch;
	}
	// 8260458C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604590: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82604594: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82604598: 392B2584  addi r9, r11, 0x2584
	ctx.r[9].s64 = ctx.r[11].s64 + 9604;
	// 8260459C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826045A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826045A4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826045A8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826045AC: 48000008  b 0x826045b4
	pc = 0x826045B4; continue 'dispatch;
	// 826045B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826045B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826045B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826045BC: 409A0044  bne cr6, 0x82604600
	if !ctx.cr[6].eq {
	pc = 0x82604600; continue 'dispatch;
	}
	// 826045C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826045C4: 419A001C  beq cr6, 0x826045e0
	if ctx.cr[6].eq {
	pc = 0x826045E0; continue 'dispatch;
	}
	// 826045C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826045CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826045D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826045D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826045D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826045DC: 4E800421  bctrl
	ctx.lr = 0x826045E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826045E0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826045E4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826045E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826045EC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826045F0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 826045F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826045F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826045FC: 4BCBBA05  bl 0x822c0000
	ctx.lr = 0x82604600;
	sub_822C0000(ctx, base);
	// 82604600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604604: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82604608: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260460C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82604610: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82604614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82604618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82604620 size=196
    let mut pc: u32 = 0x82604620;
    'dispatch: loop {
        match pc {
            0x82604620 => {
    //   block [0x82604620..0x826046E4)
	// 82604620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604624: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82604628: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260462C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82604630: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82604638: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260463C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82604640: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82604644: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604648: 4BCBC2F1  bl 0x822c0938
	ctx.lr = 0x8260464C;
	sub_822C0938(ctx, base);
	// 8260464C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82604650: 41820028  beq 0x82604678
	if ctx.cr[0].eq {
	pc = 0x82604678; continue 'dispatch;
	}
	// 82604654: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604658: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8260465C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82604660: 392B2598  addi r9, r11, 0x2598
	ctx.r[9].s64 = ctx.r[11].s64 + 9624;
	// 82604664: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82604668: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260466C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82604670: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82604674: 48000008  b 0x8260467c
	pc = 0x8260467C; continue 'dispatch;
	// 82604678: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260467C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82604684: 409A0044  bne cr6, 0x826046c8
	if !ctx.cr[6].eq {
	pc = 0x826046C8; continue 'dispatch;
	}
	// 82604688: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8260468C: 419A001C  beq cr6, 0x826046a8
	if ctx.cr[6].eq {
	pc = 0x826046A8; continue 'dispatch;
	}
	// 82604690: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604694: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82604698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260469C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826046A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826046A4: 4E800421  bctrl
	ctx.lr = 0x826046A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826046A8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826046AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826046B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826046B4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826046B8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 826046BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826046C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826046C4: 4BCBB93D  bl 0x822c0000
	ctx.lr = 0x826046C8;
	sub_822C0000(ctx, base);
	// 826046C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826046CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826046D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826046D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826046D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826046DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826046E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826046E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826046E8 size=196
    let mut pc: u32 = 0x826046E8;
    'dispatch: loop {
        match pc {
            0x826046E8 => {
    //   block [0x826046E8..0x826047AC)
	// 826046E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826046EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826046F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826046F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826046F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826046FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82604700: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82604704: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82604708: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8260470C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604710: 4BCBC229  bl 0x822c0938
	ctx.lr = 0x82604714;
	sub_822C0938(ctx, base);
	// 82604714: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82604718: 41820028  beq 0x82604740
	if ctx.cr[0].eq {
	pc = 0x82604740; continue 'dispatch;
	}
	// 8260471C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604720: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82604724: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82604728: 392B25FC  addi r9, r11, 0x25fc
	ctx.r[9].s64 = ctx.r[11].s64 + 9724;
	// 8260472C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82604730: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82604734: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82604738: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8260473C: 48000008  b 0x82604744
	pc = 0x82604744; continue 'dispatch;
	// 82604740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82604744: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604748: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260474C: 409A0044  bne cr6, 0x82604790
	if !ctx.cr[6].eq {
	pc = 0x82604790; continue 'dispatch;
	}
	// 82604750: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82604754: 419A001C  beq cr6, 0x82604770
	if ctx.cr[6].eq {
	pc = 0x82604770; continue 'dispatch;
	}
	// 82604758: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260475C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82604760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604764: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604768: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8260476C: 4E800421  bctrl
	ctx.lr = 0x82604770;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82604770: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82604774: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82604778: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260477C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82604780: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82604784: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82604788: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8260478C: 4BCBB875  bl 0x822c0000
	ctx.lr = 0x82604790;
	sub_822C0000(ctx, base);
	// 82604790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604794: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82604798: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260479C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826047A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826047A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826047A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826047B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826047B0 size=8
    let mut pc: u32 = 0x826047B0;
    'dispatch: loop {
        match pc {
            0x826047B0 => {
    //   block [0x826047B0..0x826047B8)
	// 826047B0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 826047B4: 480005BC  b 0x82604d70
	sub_82604D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826047B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826047B8 size=8
    let mut pc: u32 = 0x826047B8;
    'dispatch: loop {
        match pc {
            0x826047B8 => {
    //   block [0x826047B8..0x826047C0)
	// 826047B8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 826047BC: 480005B4  b 0x82604d70
	sub_82604D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826047C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x826047C0 size=8
    let mut pc: u32 = 0x826047C0;
    'dispatch: loop {
        match pc {
            0x826047C0 => {
    //   block [0x826047C0..0x826047C8)
	// 826047C0: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 826047C4: 480005AC  b 0x82604d70
	sub_82604D70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826047C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826047C8 size=120
    let mut pc: u32 = 0x826047C8;
    'dispatch: loop {
        match pc {
            0x826047C8 => {
    //   block [0x826047C8..0x82604840)
	// 826047C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826047CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826047D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826047D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826047D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826047DC: 807F01B8  lwz r3, 0x1b8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(440 as u32) ) } as u64;
	// 826047E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826047E4: 419A0008  beq cr6, 0x826047ec
	if ctx.cr[6].eq {
	pc = 0x826047EC; continue 'dispatch;
	}
	// 826047E8: 4BCBC0A9  bl 0x822c0890
	ctx.lr = 0x826047EC;
	sub_822C0890(ctx, base);
	// 826047EC: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 826047F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826047F4: 419A0008  beq cr6, 0x826047fc
	if ctx.cr[6].eq {
	pc = 0x826047FC; continue 'dispatch;
	}
	// 826047F8: 4BCBC099  bl 0x822c0890
	ctx.lr = 0x826047FC;
	sub_822C0890(ctx, base);
	// 826047FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82604800: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82604804: 409A0008  bne cr6, 0x8260480c
	if !ctx.cr[6].eq {
	pc = 0x8260480C; continue 'dispatch;
	}
	// 82604808: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8260480C: 4885903D  bl 0x82e5d848
	ctx.lr = 0x82604810;
	sub_82E5D848(ctx, base);
	// 82604810: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82604814: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82604818: 409A0008  bne cr6, 0x82604820
	if !ctx.cr[6].eq {
	pc = 0x82604820; continue 'dispatch;
	}
	// 8260481C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82604820: 481A2E39  bl 0x827a7658
	ctx.lr = 0x82604824;
	sub_827A7658(ctx, base);
	// 82604824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604828: 4BD4AB29  bl 0x8234f350
	ctx.lr = 0x8260482C;
	sub_8234F350(ctx, base);
	// 8260482C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82604830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82604834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82604838: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260483C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82604840 size=252
    let mut pc: u32 = 0x82604840;
    'dispatch: loop {
        match pc {
            0x82604840 => {
    //   block [0x82604840..0x8260493C)
	// 82604840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82604848: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260484C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82604850: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82604854: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82604858: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8260485C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604860: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82604864: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82604868: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 8260486C: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82604870: 38ABBA80  addi r5, r11, -0x4580
	ctx.r[5].s64 = ctx.r[11].s64 + -17792;
	// 82604874: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82604878: 388A6910  addi r4, r10, 0x6910
	ctx.r[4].s64 = ctx.r[10].s64 + 26896;
	// 8260487C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82604880: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82604884: 4BF0D9DD  bl 0x82512260
	ctx.lr = 0x82604888;
	sub_82512260(ctx, base);
	// 82604888: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260488C: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82604890: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82604894: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82604898: 48859039  bl 0x82e5d8d0
	ctx.lr = 0x8260489C;
	sub_82E5D8D0(ctx, base);
	// 8260489C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826048A0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826048A4: 396B2558  addi r11, r11, 0x2558
	ctx.r[11].s64 = ctx.r[11].s64 + 9560;
	// 826048A8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 826048AC: 394A2684  addi r10, r10, 0x2684
	ctx.r[10].s64 = ctx.r[10].s64 + 9860;
	// 826048B0: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 826048B4: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 826048B8: 39692670  addi r11, r9, 0x2670
	ctx.r[11].s64 = ctx.r[9].s64 + 9840;
	// 826048BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826048C0: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 826048C4: 39472660  addi r10, r7, 0x2660
	ctx.r[10].s64 = ctx.r[7].s64 + 9824;
	// 826048C8: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 826048CC: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 826048D0: 39282614  addi r9, r8, 0x2614
	ctx.r[9].s64 = ctx.r[8].s64 + 9748;
	// 826048D4: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 826048D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826048DC: 913F00E4  stw r9, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[9].u32 ) };
	// 826048E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826048E4: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 826048E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826048EC: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 826048F0: C00608A4  lfs f0, 0x8a4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826048F4: D3FF0154  stfs f31, 0x154(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), tmp.u32 ) };
	// 826048F8: 997F0160  stb r11, 0x160(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u8 ) };
	// 826048FC: D3DF0158  stfs f30, 0x158(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), tmp.u32 ) };
	// 82604900: 9BDF0161  stb r30, 0x161(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(353 as u32), ctx.r[30].u8 ) };
	// 82604904: D3BF015C  stfs f29, 0x15c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), tmp.u32 ) };
	// 82604908: 995F01B0  stb r10, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[10].u8 ) };
	// 8260490C: D01F0164  stfs f0, 0x164(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82604910: 917F01B4  stw r11, 0x1b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 82604914: 917F01B8  stw r11, 0x1b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82604918: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8260491C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82604920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82604924: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82604928: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8260492C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82604930: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82604934: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82604938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82604940 size=572
    let mut pc: u32 = 0x82604940;
    'dispatch: loop {
        match pc {
            0x82604940 => {
    //   block [0x82604940..0x82604B7C)
	// 82604940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604944: 48BA3821  bl 0x831a8164
	ctx.lr = 0x82604948;
	sub_831A8130(ctx, base);
	// 82604948: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260494C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82604950: 48854E11  bl 0x82e59760
	ctx.lr = 0x82604954;
	sub_82E59760(ctx, base);
	// 82604954: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604958: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260495C: C00B2550  lfs f0, 0x2550(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82604960: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82604964: 409800DC  bge cr6, 0x82604a40
	if !ctx.cr[6].lt {
	pc = 0x82604A40; continue 'dispatch;
	}
	// 82604968: 48B4FC99  bl 0x83154600
	ctx.lr = 0x8260496C;
	sub_83154600(ctx, base);
	// 8260496C: 39630170  addi r11, r3, 0x170
	ctx.r[11].s64 = ctx.r[3].s64 + 368;
	// 82604970: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 82604974: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 82604978: 3BE00030  li r31, 0x30
	ctx.r[31].s64 = 48;
	// 8260497C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82604980: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82604984: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82604988: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8260498C: 13DD5C07  vcmpneb. (lvlx128) v30, v29, v11
	tmp.u32 = ctx.r[29].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82604990: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82604994: 13BE5C07  vcmpneb. (lvlx128) v29, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82604998: 139F5C07  vcmpneb. (lvlx128) v28, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8260499C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82604B80 size=368
    let mut pc: u32 = 0x82604B80;
    'dispatch: loop {
        match pc {
            0x82604B80 => {
    //   block [0x82604B80..0x82604CF0)
	// 82604B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604B84: 48BA35E5  bl 0x831a8168
	ctx.lr = 0x82604B88;
	sub_831A8130(ctx, base);
	// 82604B88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604B8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604B90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82604B94: 3B8B26C0  addi r28, r11, 0x26c0
	ctx.r[28].s64 = ctx.r[11].s64 + 9920;
	// 82604B98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82604B9C: 38A0013B  li r5, 0x13b
	ctx.r[5].s64 = 315;
	// 82604BA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82604BA4: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82604BA8: 487ED841  bl 0x82df23e8
	ctx.lr = 0x82604BAC;
	sub_82DF23E8(ctx, base);
	// 82604BAC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82604BB0: 4182001C  beq 0x82604bcc
	if ctx.cr[0].eq {
	pc = 0x82604BCC; continue 'dispatch;
	}
	// 82604BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604BB8: 48854AC9  bl 0x82e59680
	ctx.lr = 0x82604BBC;
	sub_82E59680(ctx, base);
	// 82604BBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604BC0: 396BF294  addi r11, r11, -0xd6c
	ctx.r[11].s64 = ctx.r[11].s64 + -3436;
	// 82604BC4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604BC8: 48000008  b 0x82604bd0
	pc = 0x82604BD0; continue 'dispatch;
	// 82604BCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82604BD0: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82604BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604BD8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82604BDC: 4BFDBD25  bl 0x825e0900
	ctx.lr = 0x82604BE0;
	sub_825E0900(ctx, base);
	// 82604BE0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82604BE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604BE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82604BEC: 4BCBB415  bl 0x822c0000
	ctx.lr = 0x82604BF0;
	sub_822C0000(ctx, base);
	// 82604BF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604BF4: 4BF0CEF5  bl 0x82511ae8
	ctx.lr = 0x82604BF8;
	sub_82511AE8(ctx, base);
	// 82604BF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82604BFC: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82604C00: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82604C04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604C08: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82604CF0 size=124
    let mut pc: u32 = 0x82604CF0;
    'dispatch: loop {
        match pc {
            0x82604CF0 => {
    //   block [0x82604CF0..0x82604D6C)
	// 82604CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604CF4: 48BA3479  bl 0x831a816c
	ctx.lr = 0x82604CF8;
	sub_831A8130(ctx, base);
	// 82604CF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604CFC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82604D00: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82604D04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82604D08: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82604D0C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 82604D10: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82604D14: 487ED6D5  bl 0x82df23e8
	ctx.lr = 0x82604D18;
	sub_82DF23E8(ctx, base);
	// 82604D18: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82604D1C: 4182001C  beq 0x82604d38
	if ctx.cr[0].eq {
	pc = 0x82604D38; continue 'dispatch;
	}
	// 82604D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604D24: 4885495D  bl 0x82e59680
	ctx.lr = 0x82604D28;
	sub_82E59680(ctx, base);
	// 82604D28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604D2C: 396B2568  addi r11, r11, 0x2568
	ctx.r[11].s64 = ctx.r[11].s64 + 9576;
	// 82604D30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82604D34: 48000008  b 0x82604d3c
	pc = 0x82604D3C; continue 'dispatch;
	// 82604D38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82604D3C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82604D40: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82604D44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604D48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604D4C: 4BFFF8D5  bl 0x82604620
	ctx.lr = 0x82604D50;
	sub_82604620(ctx, base);
	// 82604D50: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82604D54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82604D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604D5C: 4BCBB2A5  bl 0x822c0000
	ctx.lr = 0x82604D60;
	sub_822C0000(ctx, base);
	// 82604D60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82604D64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82604D68: 48BA3454  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82604D70 size=76
    let mut pc: u32 = 0x82604D70;
    'dispatch: loop {
        match pc {
            0x82604D70 => {
    //   block [0x82604D70..0x82604DBC)
	// 82604D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604D74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82604D78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82604D7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82604D80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82604D88: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82604D8C: 4BFFFA3D  bl 0x826047c8
	ctx.lr = 0x82604D90;
	sub_826047C8(ctx, base);
	// 82604D90: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82604D94: 4182000C  beq 0x82604da0
	if ctx.cr[0].eq {
	pc = 0x82604DA0; continue 'dispatch;
	}
	// 82604D98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604D9C: 487ED63D  bl 0x82df23d8
	ctx.lr = 0x82604DA0;
	sub_82DF23D8(ctx, base);
	// 82604DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604DA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82604DA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82604DAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82604DB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82604DB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82604DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82604DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82604DC0 size=824
    let mut pc: u32 = 0x82604DC0;
    'dispatch: loop {
        match pc {
            0x82604DC0 => {
    //   block [0x82604DC0..0x826050F8)
	// 82604DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82604DC4: 48BA339D  bl 0x831a8160
	ctx.lr = 0x82604DC8;
	sub_831A8130(ctx, base);
	// 82604DC8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82604DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82604DD0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82604DD4: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82604DD8: 4BF0CC01  bl 0x825119d8
	ctx.lr = 0x82604DDC;
	sub_825119D8(ctx, base);
	// 82604DDC: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82604DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604DE4: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82604DE8: 487EEC21  bl 0x82df3a08
	ctx.lr = 0x82604DEC;
	sub_82DF3A08(ctx, base);
	// 82604DEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82604DF0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82604DF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604DF8: 4BF03989  bl 0x82508780
	ctx.lr = 0x82604DFC;
	sub_82508780(ctx, base);
	// 82604DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604E00: 487EE629  bl 0x82df3428
	ctx.lr = 0x82604E04;
	sub_82DF3428(ctx, base);
	// 82604E04: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82604E08: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82604E0C: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82604E10: 409A0008  bne cr6, 0x82604e18
	if !ctx.cr[6].eq {
	pc = 0x82604E18; continue 'dispatch;
	}
	// 82604E14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82604E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604E1C: 4BF03985  bl 0x825087a0
	ctx.lr = 0x82604E20;
	sub_825087A0(ctx, base);
	// 82604E20: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82604E24: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82604E28: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82604E2C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604E30: 48825CB9  bl 0x82e2aae8
	ctx.lr = 0x82604E34;
	sub_82E2AAE8(ctx, base);
	// 82604E34: 897F0161  lbz r11, 0x161(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(353 as u32) ) } as u64;
	// 82604E38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604E3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82604E40: 40820044  bne 0x82604e84
	if !ctx.cr[0].eq {
	pc = 0x82604E84; continue 'dispatch;
	}
	// 82604E44: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82604E48: 808B001C  lwz r4, 0x1c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82604E4C: 487EEBBD  bl 0x82df3a08
	ctx.lr = 0x82604E50;
	sub_82DF3A08(ctx, base);
	// 82604E50: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82604E54: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82604E58: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82604E5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82604E60: 4882A011  bl 0x82e2ee70
	ctx.lr = 0x82604E64;
	sub_82E2EE70(ctx, base);
	// 82604E64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82604E68: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82604E6C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82604E70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604E74: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82604E78: 4BCBF5E9  bl 0x822c4460
	ctx.lr = 0x82604E7C;
	sub_822C4460(ctx, base);
	// 82604E7C: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82604E80: 48000040  b 0x82604ec0
	pc = 0x82604EC0; continue 'dispatch;
	// 82604E84: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82604E88: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82604E8C: 487EEB7D  bl 0x82df3a08
	ctx.lr = 0x82604E90;
	sub_82DF3A08(ctx, base);
	// 82604E90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82604E94: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82604E98: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82604E9C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82604EA0: 48829FD1  bl 0x82e2ee70
	ctx.lr = 0x82604EA4;
	sub_82E2EE70(ctx, base);
	// 82604EA4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82604EA8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82604EAC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82604EB0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604EB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82604EB8: 4BCBF5A9  bl 0x822c4460
	ctx.lr = 0x82604EBC;
	sub_822C4460(ctx, base);
	// 82604EBC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82604EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82604EC4: 419A0008  beq cr6, 0x82604ecc
	if ctx.cr[6].eq {
	pc = 0x82604ECC; continue 'dispatch;
	}
	// 82604EC8: 4BCBB9C9  bl 0x822c0890
	ctx.lr = 0x82604ECC;
	sub_822C0890(ctx, base);
	// 82604ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82604ED0: 487EE559  bl 0x82df3428
	ctx.lr = 0x82604ED4;
	sub_82DF3428(ctx, base);
	// 82604ED4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82604ED8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82604EDC: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 82604EE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82604EE4: 3B8B26C0  addi r28, r11, 0x26c0
	ctx.r[28].s64 = ctx.r[11].s64 + 9920;
	// 82604EE8: 419A00EC  beq cr6, 0x82604fd4
	if ctx.cr[6].eq {
	pc = 0x82604FD4; continue 'dispatch;
	}
	// 82604EEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82604EF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82604EF4: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 82604EF8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82604EFC: 487ED4ED  bl 0x82df23e8
	ctx.lr = 0x82604F00;
	sub_82DF23E8(ctx, base);
	// 82604F00: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82604F04: 41820014  beq 0x82604f18
	if ctx.cr[0].eq {
	pc = 0x82604F18; continue 'dispatch;
	}
	// 82604F08: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82604F0C: 48811985  bl 0x82e16890
	ctx.lr = 0x82604F10;
	sub_82E16890(ctx, base);
	// 82604F10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82604F14: 48000008  b 0x82604f1c
	pc = 0x82604F1C; continue 'dispatch;
	// 82604F18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82604F1C: 3BDF0148  addi r30, r31, 0x148
	ctx.r[30].s64 = ctx.r[31].s64 + 328;
	// 82604F20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82604F24: 4BD5844D  bl 0x8235d370
	ctx.lr = 0x82604F28;
	sub_8235D370(ctx, base);
	// 82604F28: 817F0148  lwz r11, 0x148(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82604F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604F30: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82604F34: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82604F38: 4BF0CE61  bl 0x82511d98
	ctx.lr = 0x82604F3C;
	sub_82511D98(ctx, base);
	// 82604F3C: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82604F40: 815F0148  lwz r10, 0x148(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82604F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82604F48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82604F4C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82604F50: 419A0024  beq cr6, 0x82604f74
	if ctx.cr[6].eq {
	pc = 0x82604F74; continue 'dispatch;
	}
	// 82604F54: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82604F58: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82604F5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82604F60: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82604F64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82604F68: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82604F6C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82604F70: 4082FFE8  bne 0x82604f58
	if !ctx.cr[0].eq {
	pc = 0x82604F58; continue 'dispatch;
	}
	// 82604F74: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82604F78: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82604F7C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82604F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82604F84: 808B7058  lwz r4, 0x7058(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28760 as u32) ) } as u64;
	// 82604F88: 4BF0BA71  bl 0x825109f8
	ctx.lr = 0x82604F8C;
	sub_825109F8(ctx, base);
	// 82604F8C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82604F90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82604F94: 419A0008  beq cr6, 0x82604f9c
	if ctx.cr[6].eq {
	pc = 0x82604F9C; continue 'dispatch;
	}
	// 82604F98: 4BCBB8F9  bl 0x822c0890
	ctx.lr = 0x82604F9C;
	sub_822C0890(ctx, base);
	// 82604F9C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82604FA0: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82604FA4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82604FA8: 397F0170  addi r11, r31, 0x170
	ctx.r[11].s64 = ctx.r[31].s64 + 368;
	// 82604FAC: 814A0084  lwz r10, 0x84(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(132 as u32) ) } as u64;
	// 82604FB0: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82604FB4: 13E85407  vcmpneb. (lvlx128) v31, v8, v10
	tmp.u32 = ctx.r[8].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82604FB8: 13DD5407  vcmpneb. (lvlx128) v30, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82604FBC: 13A95407  vcmpneb. (lvlx128) v29, v9, v10
	tmp.u32 = ctx.r[9].u32 + ctx.r[10].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82604FC0: 13805407  vcmpneb. (lvlx128) v28, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826050F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826050F8 size=284
    let mut pc: u32 = 0x826050F8;
    'dispatch: loop {
        match pc {
            0x826050F8 => {
    //   block [0x826050F8..0x82605214)
	// 826050F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826050FC: 48BA3065  bl 0x831a8160
	ctx.lr = 0x82605100;
	sub_831A8130(ctx, base);
	// 82605100: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605104: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605108: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8260510C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82605110: 388B26C0  addi r4, r11, 0x26c0
	ctx.r[4].s64 = ctx.r[11].s64 + 9920;
	// 82605114: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 82605118: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 8260511C: 487ED2CD  bl 0x82df23e8
	ctx.lr = 0x82605120;
	sub_82DF23E8(ctx, base);
	// 82605120: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82605124: 41820010  beq 0x82605134
	if ctx.cr[0].eq {
	pc = 0x82605134; continue 'dispatch;
	}
	// 82605128: 4814BCE9  bl 0x82750e10
	ctx.lr = 0x8260512C;
	sub_82750E10(ctx, base);
	// 8260512C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82605130: 48000008  b 0x82605138
	pc = 0x82605138; continue 'dispatch;
	// 82605134: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82605138: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8260513C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605140: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82605144: 4BFDB6F5  bl 0x825e0838
	ctx.lr = 0x82605148;
	sub_825E0838(ctx, base);
	// 82605148: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260514C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605150: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82605154: 4BCBAEAD  bl 0x822c0000
	ctx.lr = 0x82605158;
	sub_822C0000(ctx, base);
	// 82605158: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8260515C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82605160: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605164: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82605168: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8260516C: 419A0024  beq cr6, 0x82605190
	if ctx.cr[6].eq {
	pc = 0x82605190; continue 'dispatch;
	}
	// 82605170: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82605174: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82605178: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260517C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82605180: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82605184: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82605188: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8260518C: 4082FFE8  bne 0x82605174
	if !ctx.cr[0].eq {
	pc = 0x82605174; continue 'dispatch;
	}
	// 82605190: 3BFBFF1C  addi r31, r27, -0xe4
	ctx.r[31].s64 = ctx.r[27].s64 + -228;
	// 82605194: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82605198: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260519C: 4BF0A32D  bl 0x8250f4c8
	ctx.lr = 0x826051A0;
	sub_8250F4C8(ctx, base);
	// 826051A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826051A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826051A8: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	// 826051AC: 409A0008  bne cr6, 0x826051b4
	if !ctx.cr[6].eq {
	pc = 0x826051B4; continue 'dispatch;
	}
	// 826051B0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 826051B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826051B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826051BC: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 826051C0: 4BF0A359  bl 0x8250f518
	ctx.lr = 0x826051C4;
	sub_8250F518(ctx, base);
	// 826051C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826051C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826051CC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 826051D0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 826051D4: 4BF08335  bl 0x8250d508
	ctx.lr = 0x826051D8;
	sub_8250D508(ctx, base);
	// 826051D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826051DC: 487ECAB5  bl 0x82df1c90
	ctx.lr = 0x826051E0;
	sub_82DF1C90(ctx, base);
	// 826051E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826051E4: 487ECAAD  bl 0x82df1c90
	ctx.lr = 0x826051E8;
	sub_82DF1C90(ctx, base);
	// 826051E8: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 826051EC: 48A03DCD  bl 0x83008fb8
	ctx.lr = 0x826051F0;
	sub_83008FB8(ctx, base);
	// 826051F0: 907B006C  stw r3, 0x6c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 826051F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826051F8: 4BFFF989  bl 0x82604b80
	ctx.lr = 0x826051FC;
	sub_82604B80(ctx, base);
	// 826051FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605200: 419A000C  beq cr6, 0x8260520c
	if ctx.cr[6].eq {
	pc = 0x8260520C; continue 'dispatch;
	}
	// 82605204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82605208: 4BCBB689  bl 0x822c0890
	ctx.lr = 0x8260520C;
	sub_822C0890(ctx, base);
	// 8260520C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82605210: 48BA2FA0  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82605218 size=172
    let mut pc: u32 = 0x82605218;
    'dispatch: loop {
        match pc {
            0x82605218 => {
    //   block [0x82605218..0x826052C4)
	// 82605218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260521C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605220: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82605224: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605228: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260522C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82605230: 4BDCE6D9  bl 0x823d3908
	ctx.lr = 0x82605234;
	sub_823D3908(ctx, base);
	// 82605234: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605238: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8260523C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82605240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82605244: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82605248: 419A0024  beq cr6, 0x8260526c
	if ctx.cr[6].eq {
	pc = 0x8260526C; continue 'dispatch;
	}
	// 8260524C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82605250: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82605254: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605258: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8260525C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82605260: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82605264: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605268: 4082FFE8  bne 0x82605250
	if !ctx.cr[0].eq {
	pc = 0x82605250; continue 'dispatch;
	}
	// 8260526C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82605270: 80DF006C  lwz r6, 0x6c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82605274: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82605278: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8260527C: 388A26C0  addi r4, r10, 0x26c0
	ctx.r[4].s64 = ctx.r[10].s64 + 9920;
	// 82605280: 38A000D0  li r5, 0xd0
	ctx.r[5].s64 = 208;
	// 82605284: 387FFF44  addi r3, r31, -0xbc
	ctx.r[3].s64 = ctx.r[31].s64 + -188;
	// 82605288: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8260528C: 488537B5  bl 0x82e58a40
	ctx.lr = 0x82605290;
	sub_82E58A40(ctx, base);
	// 82605290: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82605294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82605298: 419A0008  beq cr6, 0x826052a0
	if ctx.cr[6].eq {
	pc = 0x826052A0; continue 'dispatch;
	}
	// 8260529C: 4BCBB5F5  bl 0x822c0890
	ctx.lr = 0x826052A0;
	sub_822C0890(ctx, base);
	// 826052A0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826052A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826052A8: 419A0008  beq cr6, 0x826052b0
	if ctx.cr[6].eq {
	pc = 0x826052B0; continue 'dispatch;
	}
	// 826052AC: 4BCBB5E5  bl 0x822c0890
	ctx.lr = 0x826052B0;
	sub_822C0890(ctx, base);
	// 826052B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826052B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826052B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826052BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826052C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826052C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826052C8 size=1132
    let mut pc: u32 = 0x826052C8;
    'dispatch: loop {
        match pc {
            0x826052C8 => {
    //   block [0x826052C8..0x82605734)
	// 826052C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826052CC: 48BA2E91  bl 0x831a815c
	ctx.lr = 0x826052D0;
	sub_831A8130(ctx, base);
	// 826052D0: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 826052D4: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 826052D8: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826052DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826052E0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826052E4: 897F0160  lbz r11, 0x160(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(352 as u32) ) } as u64;
	// 826052E8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826052EC: 40820438  bne 0x82605724
	if !ctx.cr[0].eq {
	pc = 0x82605724; continue 'dispatch;
	}
	// 826052F0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 826052F4: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 826052F8: 9BDF0160  stb r30, 0x160(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[30].u8 ) };
	// 826052FC: 4BF0CA9D  bl 0x82511d98
	ctx.lr = 0x82605300;
	sub_82511D98(ctx, base);
	// 82605300: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82605304: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82605308: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8260530C: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82605310: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82605314: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82605318: C00A9534  lfs f0, -0x6acc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260531C: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82605320: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82605324: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82605328: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8260532C: C3DF0154  lfs f30, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82605330: 48876A19  bl 0x82e7bd48
	ctx.lr = 0x82605334;
	sub_82E7BD48(ctx, base);
	// 82605334: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82605338: D3C10058  stfs f30, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8260533C: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 82605340: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82605344: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 82605348: C01F015C  lfs f0, 0x15c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260534C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605350: C1BF0154  lfs f13, 0x154(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82605354: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 82605358: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82605738 size=68
    let mut pc: u32 = 0x82605738;
    'dispatch: loop {
        match pc {
            0x82605738 => {
    //   block [0x82605738..0x8260577C)
	// 82605738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260573C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82605744: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605748: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 8260574C: 3BE3FF1C  addi r31, r3, -0xe4
	ctx.r[31].s64 = ctx.r[3].s64 + -228;
	// 82605750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605754: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82605758: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 8260575C: 4BF0C63D  bl 0x82511d98
	ctx.lr = 0x82605760;
	sub_82511D98(ctx, base);
	// 82605760: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605764: 4BFFF41D  bl 0x82604b80
	ctx.lr = 0x82605768;
	sub_82604B80(ctx, base);
	// 82605768: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260576C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82605770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82605774: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82605778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82605780 size=368
    let mut pc: u32 = 0x82605780;
    'dispatch: loop {
        match pc {
            0x82605780 => {
    //   block [0x82605780..0x826058F0)
	// 82605780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605784: 48BA29E5  bl 0x831a8168
	ctx.lr = 0x82605788;
	sub_831A8130(ctx, base);
	// 82605788: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8260578C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82605790: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82605794: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605798: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8260579C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826057A0: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 826057A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826057A8: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 826057AC: C00AE848  lfs f0, -0x17b8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6072 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826057B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 826057B4: C1A9D5B8  lfs f13, -0x2a48(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826057B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826057BC: C188D7BC  lfs f12, -0x2844(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826057C0: 3887F614  addi r4, r7, -0x9ec
	ctx.r[4].s64 = ctx.r[7].s64 + -2540;
	// 826057C4: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 826057C8: 3BEB0070  addi r31, r11, 0x70
	ctx.r[31].s64 = ctx.r[11].s64 + 112;
	// 826057CC: D1AB0074  stfs f13, 0x74(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 826057D0: 3BCB0074  addi r30, r11, 0x74
	ctx.r[30].s64 = ctx.r[11].s64 + 116;
	// 826057D4: D18B0078  stfs f12, 0x78(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 826057D8: 3BAB0078  addi r29, r11, 0x78
	ctx.r[29].s64 = ctx.r[11].s64 + 120;
	// 826057DC: 487EE22D  bl 0x82df3a08
	ctx.lr = 0x826057E0;
	sub_82DF3A08(ctx, base);
	// 826057E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826057E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826057E8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826057EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826057F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826057F4: C3AB964C  lfs f29, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826057F8: C3EA9F64  lfs f31, -0x609c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24732 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826057FC: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82605800: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82605804: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82605808: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8260580C: 4BF9D9A5  bl 0x825a31b0
	ctx.lr = 0x82605810;
	sub_825A31B0(ctx, base);
	// 82605810: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82605814: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82605818: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260581C: 4BF9BF55  bl 0x825a1770
	ctx.lr = 0x82605820;
	sub_825A1770(ctx, base);
	// 82605820: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82605824: 487EDC05  bl 0x82df3428
	ctx.lr = 0x82605828;
	sub_82DF3428(ctx, base);
	// 82605828: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8260582C: 4BCC348D  bl 0x822c8cb8
	ctx.lr = 0x82605830;
	sub_822C8CB8(ctx, base);
	// 82605830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605834: 487EDBF5  bl 0x82df3428
	ctx.lr = 0x82605838;
	sub_82DF3428(ctx, base);
	// 82605838: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8260583C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605840: 388B34B0  addi r4, r11, 0x34b0
	ctx.r[4].s64 = ctx.r[11].s64 + 13488;
	// 82605844: 487EE1C5  bl 0x82df3a08
	ctx.lr = 0x82605848;
	sub_82DF3A08(ctx, base);
	// 82605848: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8260584C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82605850: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82605854: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82605858: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8260585C: C06B9528  lfs f3, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82605860: 4BF9D951  bl 0x825a31b0
	ctx.lr = 0x82605864;
	sub_825A31B0(ctx, base);
	// 82605864: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82605868: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260586C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82605870: 4BF9BF01  bl 0x825a1770
	ctx.lr = 0x82605874;
	sub_825A1770(ctx, base);
	// 82605874: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82605878: 487EDBB1  bl 0x82df3428
	ctx.lr = 0x8260587C;
	sub_82DF3428(ctx, base);
	// 8260587C: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 82605880: 4BCC3439  bl 0x822c8cb8
	ctx.lr = 0x82605884;
	sub_822C8CB8(ctx, base);
	// 82605884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605888: 487EDBA1  bl 0x82df3428
	ctx.lr = 0x8260588C;
	sub_82DF3428(ctx, base);
	// 8260588C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605894: 388BF5E4  addi r4, r11, -0xa1c
	ctx.r[4].s64 = ctx.r[11].s64 + -2588;
	// 82605898: 487EE171  bl 0x82df3a08
	ctx.lr = 0x8260589C;
	sub_82DF3A08(ctx, base);
	// 8260589C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826058A0: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 826058A4: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 826058A8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 826058AC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826058B0: 4BF9D901  bl 0x825a31b0
	ctx.lr = 0x826058B4;
	sub_825A31B0(ctx, base);
	// 826058B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826058B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826058BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826058C0: 4BF9BEB1  bl 0x825a1770
	ctx.lr = 0x826058C4;
	sub_825A1770(ctx, base);
	// 826058C4: 38610118  addi r3, r1, 0x118
	ctx.r[3].s64 = ctx.r[1].s64 + 280;
	// 826058C8: 487EDB61  bl 0x82df3428
	ctx.lr = 0x826058CC;
	sub_82DF3428(ctx, base);
	// 826058CC: 386100F8  addi r3, r1, 0xf8
	ctx.r[3].s64 = ctx.r[1].s64 + 248;
	// 826058D0: 4BCC33E9  bl 0x822c8cb8
	ctx.lr = 0x826058D4;
	sub_822C8CB8(ctx, base);
	// 826058D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826058D8: 487EDB51  bl 0x82df3428
	ctx.lr = 0x826058DC;
	sub_82DF3428(ctx, base);
	// 826058DC: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 826058E0: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826058E4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826058E8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826058EC: 48BA28CC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826058F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826058F0 size=108
    let mut pc: u32 = 0x826058F0;
    'dispatch: loop {
        match pc {
            0x826058F0 => {
    //   block [0x826058F0..0x8260595C)
	// 826058F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826058F4: 48BA2879  bl 0x831a816c
	ctx.lr = 0x826058F8;
	sub_831A8130(ctx, base);
	// 826058F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826058FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82605900: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82605904: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82605908: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260590C: 41820038  beq 0x82605944
	if ctx.cr[0].eq {
	pc = 0x82605944; continue 'dispatch;
	}
	// 82605910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605914: 48BA4075  bl 0x831a9988
	ctx.lr = 0x82605918;
	sub_831A9988(ctx, base);
	// 82605918: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 8260591C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82605920: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82605924: 48BA27D5  bl 0x831a80f8
	ctx.lr = 0x82605928;
	sub_831A80F8(ctx, base);
	// 82605928: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260592C: 41820018  beq 0x82605944
	if ctx.cr[0].eq {
	pc = 0x82605944; continue 'dispatch;
	}
	// 82605930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605934: 387DFFD8  addi r3, r29, -0x28
	ctx.r[3].s64 = ctx.r[29].s64 + -40;
	// 82605938: 4BFFF991  bl 0x826052c8
	ctx.lr = 0x8260593C;
	sub_826052C8(ctx, base);
	// 8260593C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82605940: 48000014  b 0x82605954
	pc = 0x82605954; continue 'dispatch;
	// 82605944: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82605948: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260594C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82605950: 4BF0CCC9  bl 0x82512618
	ctx.lr = 0x82605954;
	sub_82512618(ctx, base);
	// 82605954: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82605958: 48BA2864  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82605960 size=504
    let mut pc: u32 = 0x82605960;
    'dispatch: loop {
        match pc {
            0x82605960 => {
    //   block [0x82605960..0x82605B58)
	// 82605960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605964: 48BA2801  bl 0x831a8164
	ctx.lr = 0x82605968;
	sub_831A8130(ctx, base);
	// 82605968: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8260596C: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605970: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605974: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82605978: 3BCB26C0  addi r30, r11, 0x26c0
	ctx.r[30].s64 = ctx.r[11].s64 + 9920;
	// 8260597C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82605980: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82605984: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 82605988: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8260598C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82605990: 386001C0  li r3, 0x1c0
	ctx.r[3].s64 = 448;
	// 82605994: 487ECA55  bl 0x82df23e8
	ctx.lr = 0x82605998;
	sub_82DF23E8(ctx, base);
	// 82605998: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8260599C: 4182002C  beq 0x826059c8
	if ctx.cr[0].eq {
	pc = 0x826059C8; continue 'dispatch;
	}
	// 826059A0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826059A4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826059A8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 826059AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 826059B0: C06BD7BC  lfs f3, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 826059B4: C04AD5B8  lfs f2, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 826059B8: C029E848  lfs f1, -0x17b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6072 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826059BC: 4BFFEE85  bl 0x82604840
	ctx.lr = 0x826059C0;
	sub_82604840(ctx, base);
	// 826059C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826059C4: 48000008  b 0x826059cc
	pc = 0x826059CC; continue 'dispatch;
	// 826059C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 826059CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 826059D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826059D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826059D8: 4BFFED11  bl 0x826046e8
	ctx.lr = 0x826059DC;
	sub_826046E8(ctx, base);
	// 826059DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 826059E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826059E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826059E8: 4BCBA619  bl 0x822c0000
	ctx.lr = 0x826059EC;
	sub_822C0000(ctx, base);
	// 826059EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826059F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826059F4: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 826059F8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 826059FC: 4BCBA9DD  bl 0x822c03d8
	ctx.lr = 0x82605A00;
	sub_822C03D8(ctx, base);
	// 82605A00: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82605A04: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82605A08: 418200E0  beq 0x82605ae8
	if ctx.cr[0].eq {
	pc = 0x82605AE8; continue 'dispatch;
	}
	// 82605A0C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82605A10: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82605A14: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82605A18: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82605A1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82605A20: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82605A24: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82605A28: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82605A2C: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82605A30: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82605A34: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82605A38: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82605A3C: 409A0008  bne cr6, 0x82605a44
	if !ctx.cr[6].eq {
	pc = 0x82605A44; continue 'dispatch;
	}
	// 82605A40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82605A44: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82605A48: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605A4C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82605A50: 419A0024  beq cr6, 0x82605a74
	if ctx.cr[6].eq {
	pc = 0x82605A74; continue 'dispatch;
	}
	// 82605A54: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82605A58: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82605A5C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605A60: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82605A64: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82605A68: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82605A6C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605A70: 4082FFE8  bne 0x82605a58
	if !ctx.cr[0].eq {
	pc = 0x82605A58; continue 'dispatch;
	}
	// 82605A74: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82605A78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605A7C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82605A80: 419A0024  beq cr6, 0x82605aa4
	if ctx.cr[6].eq {
	pc = 0x82605AA4; continue 'dispatch;
	}
	// 82605A84: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82605A88: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82605A8C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605A90: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82605A94: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82605A98: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82605A9C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605AA0: 4082FFE8  bne 0x82605a88
	if !ctx.cr[0].eq {
	pc = 0x82605A88; continue 'dispatch;
	}
	// 82605AA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82605AA8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82605AAC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82605AB0: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82605AB4: 4887718D  bl 0x82e7cc40
	ctx.lr = 0x82605AB8;
	sub_82E7CC40(ctx, base);
	// 82605AB8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82605ABC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82605AC0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82605AC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82605AC8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82605ACC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82605AD0: 48193461  bl 0x82798f30
	ctx.lr = 0x82605AD4;
	sub_82798F30(ctx, base);
	// 82605AD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82605AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605ADC: 48195B8D  bl 0x8279b668
	ctx.lr = 0x82605AE0;
	sub_8279B668(ctx, base);
	// 82605AE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82605AE4: 48000008  b 0x82605aec
	pc = 0x82605AEC; continue 'dispatch;
	// 82605AE8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82605AEC: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82605AF0: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82605AF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82605AFC: 4BF92155  bl 0x82597c50
	ctx.lr = 0x82605B00;
	sub_82597C50(ctx, base);
	// 82605B00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82605B04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82605B0C: 4BCBA4F5  bl 0x822c0000
	ctx.lr = 0x82605B10;
	sub_822C0000(ctx, base);
	// 82605B10: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82605B14: 41820024  beq 0x82605b38
	if ctx.cr[0].eq {
	pc = 0x82605B38; continue 'dispatch;
	}
	// 82605B18: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82605B1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82605B20: 419A0008  beq cr6, 0x82605b28
	if ctx.cr[6].eq {
	pc = 0x82605B28; continue 'dispatch;
	}
	// 82605B24: 4BCBAD6D  bl 0x822c0890
	ctx.lr = 0x82605B28;
	sub_822C0890(ctx, base);
	// 82605B28: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82605B2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82605B30: 419A0008  beq cr6, 0x82605b38
	if ctx.cr[6].eq {
	pc = 0x82605B38; continue 'dispatch;
	}
	// 82605B34: 4BCBAD5D  bl 0x822c0890
	ctx.lr = 0x82605B38;
	sub_822C0890(ctx, base);
	// 82605B38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605B3C: 419A000C  beq cr6, 0x82605b48
	if ctx.cr[6].eq {
	pc = 0x82605B48; continue 'dispatch;
	}
	// 82605B40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82605B44: 4BCBAD4D  bl 0x822c0890
	ctx.lr = 0x82605B48;
	sub_822C0890(ctx, base);
	// 82605B48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82605B4C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82605B50: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82605B54: 48BA2660  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82605B58 size=504
    let mut pc: u32 = 0x82605B58;
    'dispatch: loop {
        match pc {
            0x82605B58 => {
    //   block [0x82605B58..0x82605D50)
	// 82605B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605B5C: 48BA2609  bl 0x831a8164
	ctx.lr = 0x82605B60;
	sub_831A8130(ctx, base);
	// 82605B60: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82605B64: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605B68: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605B6C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82605B70: 3BCB26C0  addi r30, r11, 0x26c0
	ctx.r[30].s64 = ctx.r[11].s64 + 9920;
	// 82605B74: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82605B78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82605B7C: 38A00043  li r5, 0x43
	ctx.r[5].s64 = 67;
	// 82605B80: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82605B84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82605B88: 386001C0  li r3, 0x1c0
	ctx.r[3].s64 = 448;
	// 82605B8C: 487EC85D  bl 0x82df23e8
	ctx.lr = 0x82605B90;
	sub_82DF23E8(ctx, base);
	// 82605B90: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82605B94: 4182002C  beq 0x82605bc0
	if ctx.cr[0].eq {
	pc = 0x82605BC0; continue 'dispatch;
	}
	// 82605B98: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605B9C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82605BA0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82605BA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82605BA8: C06BD7BC  lfs f3, -0x2844(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82605BAC: C04AD5B8  lfs f2, -0x2a48(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10824 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82605BB0: C029E848  lfs f1, -0x17b8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-6072 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82605BB4: 4BFFEC8D  bl 0x82604840
	ctx.lr = 0x82605BB8;
	sub_82604840(ctx, base);
	// 82605BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82605BBC: 48000008  b 0x82605bc4
	pc = 0x82605BC4; continue 'dispatch;
	// 82605BC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82605BC4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82605BC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605BCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82605BD0: 4BFFEB19  bl 0x826046e8
	ctx.lr = 0x82605BD4;
	sub_826046E8(ctx, base);
	// 82605BD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82605BD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605BDC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82605BE0: 4BCBA421  bl 0x822c0000
	ctx.lr = 0x82605BE4;
	sub_822C0000(ctx, base);
	// 82605BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82605BE8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82605BEC: 38A00044  li r5, 0x44
	ctx.r[5].s64 = 68;
	// 82605BF0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82605BF4: 4BCBA7E5  bl 0x822c03d8
	ctx.lr = 0x82605BF8;
	sub_822C03D8(ctx, base);
	// 82605BF8: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82605BFC: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82605C00: 418200E0  beq 0x82605ce0
	if ctx.cr[0].eq {
	pc = 0x82605CE0; continue 'dispatch;
	}
	// 82605C04: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82605C08: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82605C0C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82605C10: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82605C14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82605C18: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82605C1C: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82605C20: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82605C24: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82605C28: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82605C2C: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82605C30: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82605C34: 409A0008  bne cr6, 0x82605c3c
	if !ctx.cr[6].eq {
	pc = 0x82605C3C; continue 'dispatch;
	}
	// 82605C38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82605C3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82605C40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605C44: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82605C48: 419A0024  beq cr6, 0x82605c6c
	if ctx.cr[6].eq {
	pc = 0x82605C6C; continue 'dispatch;
	}
	// 82605C4C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82605C50: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82605C54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605C58: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82605C5C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82605C60: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82605C64: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605C68: 4082FFE8  bne 0x82605c50
	if !ctx.cr[0].eq {
	pc = 0x82605C50; continue 'dispatch;
	}
	// 82605C6C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82605C70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605C74: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82605C78: 419A0024  beq cr6, 0x82605c9c
	if ctx.cr[6].eq {
	pc = 0x82605C9C; continue 'dispatch;
	}
	// 82605C7C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82605C80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82605C84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605C88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82605C8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82605C90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82605C94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82605C98: 4082FFE8  bne 0x82605c80
	if !ctx.cr[0].eq {
	pc = 0x82605C80; continue 'dispatch;
	}
	// 82605C9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82605CA0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82605CA4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82605CA8: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82605CAC: 48876F95  bl 0x82e7cc40
	ctx.lr = 0x82605CB0;
	sub_82E7CC40(ctx, base);
	// 82605CB0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82605CB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82605CB8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82605CBC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82605CC0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82605CC4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82605CC8: 48193269  bl 0x82798f30
	ctx.lr = 0x82605CCC;
	sub_82798F30(ctx, base);
	// 82605CCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82605CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605CD4: 48195995  bl 0x8279b668
	ctx.lr = 0x82605CD8;
	sub_8279B668(ctx, base);
	// 82605CD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82605CDC: 48000008  b 0x82605ce4
	pc = 0x82605CE4; continue 'dispatch;
	// 82605CE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82605CE4: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82605CE8: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82605CEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605CF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82605CF4: 4BF91F5D  bl 0x82597c50
	ctx.lr = 0x82605CF8;
	sub_82597C50(ctx, base);
	// 82605CF8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82605CFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82605D00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82605D04: 4BCBA2FD  bl 0x822c0000
	ctx.lr = 0x82605D08;
	sub_822C0000(ctx, base);
	// 82605D08: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82605D0C: 41820024  beq 0x82605d30
	if ctx.cr[0].eq {
	pc = 0x82605D30; continue 'dispatch;
	}
	// 82605D10: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82605D14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82605D18: 419A0008  beq cr6, 0x82605d20
	if ctx.cr[6].eq {
	pc = 0x82605D20; continue 'dispatch;
	}
	// 82605D1C: 4BCBAB75  bl 0x822c0890
	ctx.lr = 0x82605D20;
	sub_822C0890(ctx, base);
	// 82605D20: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82605D24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82605D28: 419A0008  beq cr6, 0x82605d30
	if ctx.cr[6].eq {
	pc = 0x82605D30; continue 'dispatch;
	}
	// 82605D2C: 4BCBAB65  bl 0x822c0890
	ctx.lr = 0x82605D30;
	sub_822C0890(ctx, base);
	// 82605D30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82605D34: 419A000C  beq cr6, 0x82605d40
	if ctx.cr[6].eq {
	pc = 0x82605D40; continue 'dispatch;
	}
	// 82605D38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82605D3C: 4BCBAB55  bl 0x822c0890
	ctx.lr = 0x82605D40;
	sub_822C0890(ctx, base);
	// 82605D40: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82605D44: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82605D48: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82605D4C: 48BA2468  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605D50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82605D50 size=96
    let mut pc: u32 = 0x82605D50;
    'dispatch: loop {
        match pc {
            0x82605D50 => {
    //   block [0x82605D50..0x82605DB0)
	// 82605D50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605D54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605D58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82605D5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82605D60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605D64: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605D68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82605D6C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82605D70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605D74: 388B279C  addi r4, r11, 0x279c
	ctx.r[4].s64 = ctx.r[11].s64 + 10140;
	// 82605D78: 487EDC91  bl 0x82df3a08
	ctx.lr = 0x82605D7C;
	sub_82DF3A08(ctx, base);
	// 82605D7C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82605D80: 38BF01B0  addi r5, r31, 0x1b0
	ctx.r[5].s64 = ctx.r[31].s64 + 432;
	// 82605D84: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605D88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82605D8C: 4BFF22FD  bl 0x825f8088
	ctx.lr = 0x82605D90;
	sub_825F8088(ctx, base);
	// 82605D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605D94: 487ED695  bl 0x82df3428
	ctx.lr = 0x82605D98;
	sub_82DF3428(ctx, base);
	// 82605D98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82605D9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82605DA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82605DA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82605DA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82605DAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82605DB0 size=32
    let mut pc: u32 = 0x82605DB0;
    'dispatch: loop {
        match pc {
            0x82605DB0 => {
    //   block [0x82605DB0..0x82605DD0)
	// 82605DB0: 896301C6  lbz r11, 0x1c6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(454 as u32) ) } as u64;
	// 82605DB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82605DB8: 41820018  beq 0x82605dd0
	if ctx.cr[0].eq {
		sub_82605DD0(ctx, base);
		return;
	}
	// 82605DBC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82605DC0: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 82605DC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82605DC8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82605DCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605DD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82605DD0 size=8
    let mut pc: u32 = 0x82605DD0;
    'dispatch: loop {
        match pc {
            0x82605DD0 => {
    //   block [0x82605DD0..0x82605DD8)
	// 82605DD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82605DD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82605DD8 size=136
    let mut pc: u32 = 0x82605DD8;
    'dispatch: loop {
        match pc {
            0x82605DD8 => {
    //   block [0x82605DD8..0x82605E60)
	// 82605DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605DE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82605DE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605DE8: 896301C6  lbz r11, 0x1c6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(454 as u32) ) } as u64;
	// 82605DEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82605DF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82605DF4: 41820054  beq 0x82605e48
	if ctx.cr[0].eq {
	pc = 0x82605E48; continue 'dispatch;
	}
	// 82605DF8: 80630190  lwz r3, 0x190(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(400 as u32) ) } as u64;
	// 82605DFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605E00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82605E04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82605E08: 4E800421  bctrl
	ctx.lr = 0x82605E0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82605E0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82605E10: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82605E14: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82605E18: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82605E1C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82605E20: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82605E24: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82605E28: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82605E2C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82605E30: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82605E34: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82605E38: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82605E3C: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82605E60 size=196
    let mut pc: u32 = 0x82605E60;
    'dispatch: loop {
        match pc {
            0x82605E60 => {
    //   block [0x82605E60..0x82605F24)
	// 82605E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605E68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82605E6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82605E70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605E74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82605E78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82605E7C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82605E80: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82605E84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82605E88: 4BCBAAB1  bl 0x822c0938
	ctx.lr = 0x82605E8C;
	sub_822C0938(ctx, base);
	// 82605E8C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82605E90: 41820028  beq 0x82605eb8
	if ctx.cr[0].eq {
	pc = 0x82605EB8; continue 'dispatch;
	}
	// 82605E94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605E98: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82605E9C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82605EA0: 392B27F8  addi r9, r11, 0x27f8
	ctx.r[9].s64 = ctx.r[11].s64 + 10232;
	// 82605EA4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82605EA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82605EAC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82605EB0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82605EB4: 48000008  b 0x82605ebc
	pc = 0x82605EBC; continue 'dispatch;
	// 82605EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82605EBC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82605EC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82605EC4: 409A0044  bne cr6, 0x82605f08
	if !ctx.cr[6].eq {
	pc = 0x82605F08; continue 'dispatch;
	}
	// 82605EC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82605ECC: 419A001C  beq cr6, 0x82605ee8
	if ctx.cr[6].eq {
	pc = 0x82605EE8; continue 'dispatch;
	}
	// 82605ED0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605ED4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82605ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605EDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605EE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82605EE4: 4E800421  bctrl
	ctx.lr = 0x82605EE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82605EE8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82605EEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82605EF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605EF4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82605EF8: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 82605EFC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82605F00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82605F04: 4BCBA0FD  bl 0x822c0000
	ctx.lr = 0x82605F08;
	sub_822C0000(ctx, base);
	// 82605F08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82605F0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82605F10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82605F14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82605F18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82605F1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82605F20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82605F28 size=196
    let mut pc: u32 = 0x82605F28;
    'dispatch: loop {
        match pc {
            0x82605F28 => {
    //   block [0x82605F28..0x82605FEC)
	// 82605F28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605F2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605F30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82605F34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82605F38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82605F3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82605F40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82605F44: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82605F48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82605F4C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82605F50: 4BCBA9E9  bl 0x822c0938
	ctx.lr = 0x82605F54;
	sub_822C0938(ctx, base);
	// 82605F54: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82605F58: 41820028  beq 0x82605f80
	if ctx.cr[0].eq {
	pc = 0x82605F80; continue 'dispatch;
	}
	// 82605F5C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82605F60: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82605F64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82605F68: 392B280C  addi r9, r11, 0x280c
	ctx.r[9].s64 = ctx.r[11].s64 + 10252;
	// 82605F6C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82605F70: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82605F74: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82605F78: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82605F7C: 48000008  b 0x82605f84
	pc = 0x82605F84; continue 'dispatch;
	// 82605F80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82605F84: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82605F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82605F8C: 409A0044  bne cr6, 0x82605fd0
	if !ctx.cr[6].eq {
	pc = 0x82605FD0; continue 'dispatch;
	}
	// 82605F90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82605F94: 419A001C  beq cr6, 0x82605fb0
	if ctx.cr[6].eq {
	pc = 0x82605FB0; continue 'dispatch;
	}
	// 82605F98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605F9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82605FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82605FA4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82605FA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82605FAC: 4E800421  bctrl
	ctx.lr = 0x82605FB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82605FB0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82605FB4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82605FB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82605FBC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82605FC0: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 82605FC4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82605FC8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82605FCC: 4BCBA035  bl 0x822c0000
	ctx.lr = 0x82605FD0;
	sub_822C0000(ctx, base);
	// 82605FD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82605FD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82605FD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82605FDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82605FE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82605FE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82605FE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82605FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82605FF0 size=196
    let mut pc: u32 = 0x82605FF0;
    'dispatch: loop {
        match pc {
            0x82605FF0 => {
    //   block [0x82605FF0..0x826060B4)
	// 82605FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82605FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82605FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82605FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82606008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260600C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82606010: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82606014: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606018: 4BCBA921  bl 0x822c0938
	ctx.lr = 0x8260601C;
	sub_822C0938(ctx, base);
	// 8260601C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82606020: 41820028  beq 0x82606048
	if ctx.cr[0].eq {
	pc = 0x82606048; continue 'dispatch;
	}
	// 82606024: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606028: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8260602C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82606030: 392B2820  addi r9, r11, 0x2820
	ctx.r[9].s64 = ctx.r[11].s64 + 10272;
	// 82606034: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82606038: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260603C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82606040: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82606044: 48000008  b 0x8260604c
	pc = 0x8260604C; continue 'dispatch;
	// 82606048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260604C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82606054: 409A0044  bne cr6, 0x82606098
	if !ctx.cr[6].eq {
	pc = 0x82606098; continue 'dispatch;
	}
	// 82606058: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8260605C: 419A001C  beq cr6, 0x82606078
	if ctx.cr[6].eq {
	pc = 0x82606078; continue 'dispatch;
	}
	// 82606060: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606064: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82606068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260606C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606070: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82606074: 4E800421  bctrl
	ctx.lr = 0x82606078;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82606078: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260607C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82606080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606084: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82606088: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 8260608C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82606090: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82606094: 4BCB9F6D  bl 0x822c0000
	ctx.lr = 0x82606098;
	sub_822C0000(ctx, base);
	// 82606098: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260609C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826060A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826060A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826060A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826060AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826060B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826060B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826060B8 size=196
    let mut pc: u32 = 0x826060B8;
    'dispatch: loop {
        match pc {
            0x826060B8 => {
    //   block [0x826060B8..0x8260617C)
	// 826060B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826060BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826060C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826060C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826060C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826060CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826060D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826060D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826060D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826060DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826060E0: 4BCBA859  bl 0x822c0938
	ctx.lr = 0x826060E4;
	sub_822C0938(ctx, base);
	// 826060E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826060E8: 41820028  beq 0x82606110
	if ctx.cr[0].eq {
	pc = 0x82606110; continue 'dispatch;
	}
	// 826060EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826060F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826060F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826060F8: 392B2834  addi r9, r11, 0x2834
	ctx.r[9].s64 = ctx.r[11].s64 + 10292;
	// 826060FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82606100: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82606104: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82606108: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8260610C: 48000008  b 0x82606114
	pc = 0x82606114; continue 'dispatch;
	// 82606110: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82606114: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606118: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260611C: 409A0044  bne cr6, 0x82606160
	if !ctx.cr[6].eq {
	pc = 0x82606160; continue 'dispatch;
	}
	// 82606120: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82606124: 419A001C  beq cr6, 0x82606140
	if ctx.cr[6].eq {
	pc = 0x82606140; continue 'dispatch;
	}
	// 82606128: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260612C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82606130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606134: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82606138: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8260613C: 4E800421  bctrl
	ctx.lr = 0x82606140;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82606140: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82606144: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82606148: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260614C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82606150: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 82606154: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82606158: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8260615C: 4BCB9EA5  bl 0x822c0000
	ctx.lr = 0x82606160;
	sub_822C0000(ctx, base);
	// 82606160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82606164: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82606168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260616C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606170: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82606174: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606178: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82606180 size=196
    let mut pc: u32 = 0x82606180;
    'dispatch: loop {
        match pc {
            0x82606180 => {
    //   block [0x82606180..0x82606244)
	// 82606180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606184: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82606188: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260618C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606190: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82606198: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260619C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826061A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826061A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826061A8: 4BCBA791  bl 0x822c0938
	ctx.lr = 0x826061AC;
	sub_822C0938(ctx, base);
	// 826061AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826061B0: 41820028  beq 0x826061d8
	if ctx.cr[0].eq {
	pc = 0x826061D8; continue 'dispatch;
	}
	// 826061B4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826061B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 826061BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 826061C0: 392B2848  addi r9, r11, 0x2848
	ctx.r[9].s64 = ctx.r[11].s64 + 10312;
	// 826061C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 826061C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826061CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 826061D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 826061D4: 48000008  b 0x826061dc
	pc = 0x826061DC; continue 'dispatch;
	// 826061D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826061DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826061E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826061E4: 409A0044  bne cr6, 0x82606228
	if !ctx.cr[6].eq {
	pc = 0x82606228; continue 'dispatch;
	}
	// 826061E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826061EC: 419A001C  beq cr6, 0x82606208
	if ctx.cr[6].eq {
	pc = 0x82606208; continue 'dispatch;
	}
	// 826061F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826061F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826061F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826061FC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82606200: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82606204: 4E800421  bctrl
	ctx.lr = 0x82606208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82606208: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260620C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82606210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606214: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82606218: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 8260621C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82606220: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82606224: 4BCB9DDD  bl 0x822c0000
	ctx.lr = 0x82606228;
	sub_822C0000(ctx, base);
	// 82606228: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260622C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82606230: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82606234: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606238: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260623C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82606248 size=196
    let mut pc: u32 = 0x82606248;
    'dispatch: loop {
        match pc {
            0x82606248 => {
    //   block [0x82606248..0x8260630C)
	// 82606248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260624C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82606250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82606254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260625C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82606260: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82606264: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82606268: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8260626C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606270: 4BCBA6C9  bl 0x822c0938
	ctx.lr = 0x82606274;
	sub_822C0938(ctx, base);
	// 82606274: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82606278: 41820028  beq 0x826062a0
	if ctx.cr[0].eq {
	pc = 0x826062A0; continue 'dispatch;
	}
	// 8260627C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606280: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82606284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82606288: 392B285C  addi r9, r11, 0x285c
	ctx.r[9].s64 = ctx.r[11].s64 + 10332;
	// 8260628C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82606290: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82606294: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82606298: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8260629C: 48000008  b 0x826062a4
	pc = 0x826062A4; continue 'dispatch;
	// 826062A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826062A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826062A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826062AC: 409A0044  bne cr6, 0x826062f0
	if !ctx.cr[6].eq {
	pc = 0x826062F0; continue 'dispatch;
	}
	// 826062B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 826062B4: 419A001C  beq cr6, 0x826062d0
	if ctx.cr[6].eq {
	pc = 0x826062D0; continue 'dispatch;
	}
	// 826062B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826062BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 826062C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826062C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 826062C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826062CC: 4E800421  bctrl
	ctx.lr = 0x826062D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826062D0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826062D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826062D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826062DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826062E0: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 826062E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826062E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826062EC: 4BCB9D15  bl 0x822c0000
	ctx.lr = 0x826062F0;
	sub_822C0000(ctx, base);
	// 826062F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826062F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826062F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826062FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82606304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82606310 size=196
    let mut pc: u32 = 0x82606310;
    'dispatch: loop {
        match pc {
            0x82606310 => {
    //   block [0x82606310..0x826063D4)
	// 82606310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82606318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260631C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606324: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82606328: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260632C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82606330: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82606334: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606338: 4BCBA601  bl 0x822c0938
	ctx.lr = 0x8260633C;
	sub_822C0938(ctx, base);
	// 8260633C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82606340: 41820028  beq 0x82606368
	if ctx.cr[0].eq {
	pc = 0x82606368; continue 'dispatch;
	}
	// 82606344: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606348: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8260634C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82606350: 392B2870  addi r9, r11, 0x2870
	ctx.r[9].s64 = ctx.r[11].s64 + 10352;
	// 82606354: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82606358: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260635C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82606360: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82606364: 48000008  b 0x8260636c
	pc = 0x8260636C; continue 'dispatch;
	// 82606368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8260636C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82606374: 409A0044  bne cr6, 0x826063b8
	if !ctx.cr[6].eq {
	pc = 0x826063B8; continue 'dispatch;
	}
	// 82606378: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8260637C: 419A001C  beq cr6, 0x82606398
	if ctx.cr[6].eq {
	pc = 0x82606398; continue 'dispatch;
	}
	// 82606380: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606384: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82606388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260638C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82606390: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82606394: 4E800421  bctrl
	ctx.lr = 0x82606398;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82606398: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260639C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 826063A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826063A4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 826063A8: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 826063AC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 826063B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826063B4: 4BCB9C4D  bl 0x822c0000
	ctx.lr = 0x826063B8;
	sub_822C0000(ctx, base);
	// 826063B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826063BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826063C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826063C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826063C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826063CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826063D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826063D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826063D8 size=196
    let mut pc: u32 = 0x826063D8;
    'dispatch: loop {
        match pc {
            0x826063D8 => {
    //   block [0x826063D8..0x8260649C)
	// 826063D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826063DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826063E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826063E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826063E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826063EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826063F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826063F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 826063F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826063FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606400: 4BCBA539  bl 0x822c0938
	ctx.lr = 0x82606404;
	sub_822C0938(ctx, base);
	// 82606404: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82606408: 41820028  beq 0x82606430
	if ctx.cr[0].eq {
	pc = 0x82606430; continue 'dispatch;
	}
	// 8260640C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606410: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82606414: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82606418: 392B2884  addi r9, r11, 0x2884
	ctx.r[9].s64 = ctx.r[11].s64 + 10372;
	// 8260641C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82606420: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82606424: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82606428: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8260642C: 48000008  b 0x82606434
	pc = 0x82606434; continue 'dispatch;
	// 82606430: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82606434: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82606438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260643C: 409A0044  bne cr6, 0x82606480
	if !ctx.cr[6].eq {
	pc = 0x82606480; continue 'dispatch;
	}
	// 82606440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82606444: 419A001C  beq cr6, 0x82606460
	if ctx.cr[6].eq {
	pc = 0x82606460; continue 'dispatch;
	}
	// 82606448: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260644C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82606450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606454: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82606458: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8260645C: 4E800421  bctrl
	ctx.lr = 0x82606460;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82606460: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82606464: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82606468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260646C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82606470: 816B02B4  lwz r11, 0x2b4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(692 as u32) ) } as u64;
	// 82606474: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82606478: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8260647C: 4BCB9B85  bl 0x822c0000
	ctx.lr = 0x82606480;
	sub_822C0000(ctx, base);
	// 82606480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82606484: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82606488: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260648C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606490: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82606494: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606498: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826064A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826064A0 size=124
    let mut pc: u32 = 0x826064A0;
    'dispatch: loop {
        match pc {
            0x826064A0 => {
    //   block [0x826064A0..0x8260651C)
	// 826064A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826064A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826064A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826064AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826064B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826064B4: 48B4E14D  bl 0x83154600
	ctx.lr = 0x826064B8;
	sub_83154600(ctx, base);
	// 826064B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826064BC: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 826064C0: 91630198  stw r11, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 826064C4: 4BF0958D  bl 0x8250fa50
	ctx.lr = 0x826064C8;
	sub_8250FA50(ctx, base);
	// 826064C8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826064CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826064D0: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 826064D4: 487ED535  bl 0x82df3a08
	ctx.lr = 0x826064D8;
	sub_82DF3A08(ctx, base);
	// 826064D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826064DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826064E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826064E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826064E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826064EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826064F0: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826064F4: 4885859D  bl 0x82e5ea90
	ctx.lr = 0x826064F8;
	sub_82E5EA90(ctx, base);
	// 826064F8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 826064FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606500: 419A0008  beq cr6, 0x82606508
	if ctx.cr[6].eq {
	pc = 0x82606508; continue 'dispatch;
	}
	// 82606504: 4BCBA38D  bl 0x822c0890
	ctx.lr = 0x82606508;
	sub_822C0890(ctx, base);
	// 82606508: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260650C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82606510: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606514: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606518: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82606520 size=124
    let mut pc: u32 = 0x82606520;
    'dispatch: loop {
        match pc {
            0x82606520 => {
    //   block [0x82606520..0x8260659C)
	// 82606520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82606528: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8260652C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606530: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82606534: 4885322D  bl 0x82e59760
	ctx.lr = 0x82606538;
	sub_82E59760(ctx, base);
	// 82606538: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8260653C: C00B9450  lfs f0, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82606540: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82606544: 40990044  ble cr6, 0x82606588
	if !ctx.cr[6].gt {
	pc = 0x82606588; continue 'dispatch;
	}
	// 82606548: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8260654C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606550: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 82606554: 487ED4B5  bl 0x82df3a08
	ctx.lr = 0x82606558;
	sub_82DF3A08(ctx, base);
	// 82606558: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8260655C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82606560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82606564: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82606568: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8260656C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82606570: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82606574: 4885851D  bl 0x82e5ea90
	ctx.lr = 0x82606578;
	sub_82E5EA90(ctx, base);
	// 82606578: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8260657C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606580: 419A0008  beq cr6, 0x82606588
	if ctx.cr[6].eq {
	pc = 0x82606588; continue 'dispatch;
	}
	// 82606584: 4BCBA30D  bl 0x822c0890
	ctx.lr = 0x82606588;
	sub_822C0890(ctx, base);
	// 82606588: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260658C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82606590: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606594: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826065A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826065A0 size=336
    let mut pc: u32 = 0x826065A0;
    'dispatch: loop {
        match pc {
            0x826065A0 => {
    //   block [0x826065A0..0x826066F0)
	// 826065A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826065A4: 48BA1BC5  bl 0x831a8168
	ctx.lr = 0x826065A8;
	sub_831A8130(ctx, base);
	// 826065A8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 826065AC: 48BA24C1  bl 0x831a8a6c
	ctx.lr = 0x826065B0;
	sub_831A8A40(ctx, base);
	// 826065B0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826065B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 826065B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826065BC: 4880B91D  bl 0x82e11ed8
	ctx.lr = 0x826065C0;
	sub_82E11ED8(ctx, base);
	// 826065C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826065C4: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 826065C8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 826065CC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 826065D0: 394A2960  addi r10, r10, 0x2960
	ctx.r[10].s64 = ctx.r[10].s64 + 10592;
	// 826065D4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 826065D8: C3CB08A8  lfs f30, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 826065DC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 826065E0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826065E4: D3DE0210  stfs f30, 0x210(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 826065E8: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826065EC: C3E908A4  lfs f31, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826065F0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 826065F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 826065F8: C388CFC8  lfs f28, -0x3038(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12344 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 826065FC: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 82606600: C34B9534  lfs f26, -0x6acc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27340 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82606604: 93BE0214  stw r29, 0x214(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(532 as u32), ctx.r[29].u32 ) };
	// 82606608: C36A2960  lfs f27, 0x2960(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8260660C: 93BE0218  stw r29, 0x218(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(536 as u32), ctx.r[29].u32 ) };
	// 82606610: C3A7952C  lfs f29, -0x6ad4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27348 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82606614: 3F808212  lis r28, -0x7dee
	ctx.r[28].s64 = -2112749568;
	// 82606618: 57ABF87E  srwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8260661C: D3810060  stfs f28, 0x60(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82606620: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82606624: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82606628: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8260662C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82606630: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82606634: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82606638: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8260663C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82606640: C01CDFAC  lfs f0, -0x2054(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82606644: EF2D0772  fmuls f25, f13, f29
	ctx.f[25].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82606648: EC000672  fmuls f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 8260664C: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82606650: 48876399  bl 0x82e7c9e8
	ctx.lr = 0x82606654;
	sub_82E7C9E8(ctx, base);
	// 82606654: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82606658: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8260665C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82606660: 48875669  bl 0x82e7bcc8
	ctx.lr = 0x82606664;
	sub_82E7BCC8(ctx, base);
	// 82606664: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82606668: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8260666C: ED60F028  fsubs f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82606670: C1810078  lfs f12, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82606674: ED5EC828  fsubs f10, f30, f25
	ctx.f[10].f64 = (((ctx.f[30].f64 - ctx.f[25].f64) as f32) as f64);
	// 82606678: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8260667C: 3BBD0002  addi r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 2;
	// 82606680: D1BFFFFC  stfs f13, -4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82606684: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82606688: 2B1D000E  cmplwi cr6, r29, 0xe
	ctx.cr[6].compare_u32(ctx.r[29].u32, 14 as u32, &mut ctx.xer);
	// 8260668C: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82606690: D1BF001C  stfs f13, 0x1c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82606694: D17F0020  stfs f11, 0x20(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82606698: D15F0008  stfs f10, 8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8260669C: D15F0028  stfs f10, 0x28(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 826066A0: C01FFFFC  lfs f0, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826066A4: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 826066A8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826066AC: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 826066B0: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826066B4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 826066B8: C01F001C  lfs f0, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826066BC: C1BF0024  lfs f13, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826066C0: C19F0020  lfs f12, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 826066C4: ED8CD028  fsubs f12, f12, f26
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[26].f64) as f32) as f64);
	// 826066C8: D19F0034  stfs f12, 0x34(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 826066CC: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 826066D0: D1BF0038  stfs f13, 0x38(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 826066D4: 3BFF0040  addi r31, r31, 0x40
	ctx.r[31].s64 = ctx.r[31].s64 + 64;
	// 826066D8: 4198FF40  blt cr6, 0x82606618
	if ctx.cr[6].lt {
	pc = 0x82606618; continue 'dispatch;
	}
	// 826066DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826066E0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 826066E4: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 826066E8: 48BA23D1  bl 0x831a8ab8
	ctx.lr = 0x826066EC;
	sub_831A8A8C(ctx, base);
	// 826066EC: 48BA1ACC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826066F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826066F0 size=88
    let mut pc: u32 = 0x826066F0;
    'dispatch: loop {
        match pc {
            0x826066F0 => {
    //   block [0x826066F0..0x82606748)
	// 826066F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826066F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826066F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 826066FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82606708: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8260670C: 387F0214  addi r3, r31, 0x214
	ctx.r[3].s64 = ctx.r[31].s64 + 532;
	// 82606710: 4880CB89  bl 0x82e13298
	ctx.lr = 0x82606714;
	sub_82E13298(ctx, base);
	// 82606714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606718: 4880B7D9  bl 0x82e11ef0
	ctx.lr = 0x8260671C;
	sub_82E11EF0(ctx, base);
	// 8260671C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82606720: 4182000C  beq 0x8260672c
	if ctx.cr[0].eq {
	pc = 0x8260672C; continue 'dispatch;
	}
	// 82606724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606728: 487EBCB1  bl 0x82df23d8
	ctx.lr = 0x8260672C;
	sub_82DF23D8(ctx, base);
	// 8260672C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606730: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82606734: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82606738: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260673C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82606740: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82606748 size=792
    let mut pc: u32 = 0x82606748;
    'dispatch: loop {
        match pc {
            0x82606748 => {
    //   block [0x82606748..0x82606A60)
	// 82606748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260674C: 48BA1A11  bl 0x831a815c
	ctx.lr = 0x82606750;
	sub_831A8130(ctx, base);
	// 82606750: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606754: 3FC08335  lis r30, -0x7ccb
	ctx.r[30].s64 = -2093678592;
	// 82606758: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8260675C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82606760: 3BEB7F0C  addi r31, r11, 0x7f0c
	ctx.r[31].s64 = ctx.r[11].s64 + 32524;
	// 82606764: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82606768: 817E7F10  lwz r11, 0x7f10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32528 as u32) ) } as u64;
	// 8260676C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82606770: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82606774: 4082001C  bne 0x82606790
	if !ctx.cr[0].eq {
	pc = 0x82606790; continue 'dispatch;
	}
	// 82606778: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8260677C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82606780: 917E7F10  stw r11, 0x7f10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32528 as u32), ctx.r[11].u32 ) };
	// 82606784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606788: 388A9428  addi r4, r10, -0x6bd8
	ctx.r[4].s64 = ctx.r[10].s64 + -27608;
	// 8260678C: 487F2DA5  bl 0x82df9530
	ctx.lr = 0x82606790;
	sub_82DF9530(ctx, base);
	// 82606790: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606794: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82606798: 409A02C0  bne cr6, 0x82606a58
	if !ctx.cr[6].eq {
	pc = 0x82606A58; continue 'dispatch;
	}
	// 8260679C: 817B0214  lwz r11, 0x214(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(532 as u32) ) } as u64;
	// 826067A0: 3BFB0214  addi r31, r27, 0x214
	ctx.r[31].s64 = ctx.r[27].s64 + 532;
	// 826067A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826067A8: 409A009C  bne cr6, 0x82606844
	if !ctx.cr[6].eq {
	pc = 0x82606844; continue 'dispatch;
	}
	// 826067AC: 3D40002A  lis r10, 0x2a
	ctx.r[10].s64 = 2752512;
	// 826067B0: B1610050  sth r11, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u16 ) };
	// 826067B4: 3D20002C  lis r9, 0x2c
	ctx.r[9].s64 = 2883584;
	// 826067B8: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 826067BC: 614A23B9  ori r10, r10, 0x23b9
	ctx.r[10].u64 = ctx.r[10].u64 | 9145;
	// 826067C0: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 826067C4: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 826067C8: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 826067CC: 612923A5  ori r9, r9, 0x23a5
	ctx.r[9].u64 = ctx.r[9].u64 | 9125;
	// 826067D0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 826067D4: 38E00005  li r7, 5
	ctx.r[7].s64 = 5;
	// 826067D8: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 826067DC: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 826067E0: B161005C  sth r11, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 826067E4: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	// 826067E8: B101005E  sth r8, 0x5e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[8].u16 ) };
	// 826067EC: 3B4000FF  li r26, 0xff
	ctx.r[26].s64 = 255;
	// 826067F0: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 826067F4: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 826067F8: 99610064  stb r11, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u8 ) };
	// 826067FC: 98E10065  stb r7, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[7].u8 ) };
	// 82606800: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82606804: 99610066  stb r11, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[11].u8 ) };
	// 82606808: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260680C: B1610068  sth r11, 0x68(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u16 ) };
	// 82606810: B0C1006A  sth r6, 0x6a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[6].u16 ) };
	// 82606814: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82606818: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 8260681C: 9B810071  stb r28, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[28].u8 ) };
	// 82606820: 99610072  stb r11, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[11].u8 ) };
	// 82606824: B3410074  sth r26, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u16 ) };
	// 82606828: B1610076  sth r11, 0x76(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[11].u16 ) };
	// 8260682C: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 82606830: 9961007C  stb r11, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82606834: 9961007D  stb r11, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[11].u8 ) };
	// 82606838: 9961007E  stb r11, 0x7e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(126 as u32), ctx.r[11].u8 ) };
	// 8260683C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606840: 48808929  bl 0x82e0f168
	ctx.lr = 0x82606844;
	sub_82E0F168(ctx, base);
	// 82606844: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606848: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260684C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82606850: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82606854: 419A0010  beq cr6, 0x82606864
	if ctx.cr[6].eq {
	pc = 0x82606864; continue 'dispatch;
	}
	// 82606858: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 8260685C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606860: 485D2071  bl 0x82bd88d0
	ctx.lr = 0x82606864;
	sub_82BD88D0(ctx, base);
	// 82606864: 389B01D0  addi r4, r27, 0x1d0
	ctx.r[4].s64 = ctx.r[27].s64 + 464;
	// 82606868: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8260686C: 48808C8D  bl 0x82e0f4f8
	ctx.lr = 0x82606870;
	sub_82E0F4F8(ctx, base);
	// 82606870: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82606874: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82606878: 4BCBDB91  bl 0x822c4408
	ctx.lr = 0x8260687C;
	sub_822C4408(ctx, base);
	// 8260687C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82606880: 388B0160  addi r4, r11, 0x160
	ctx.r[4].s64 = ctx.r[11].s64 + 352;
	// 82606884: 3BEB0168  addi r31, r11, 0x168
	ctx.r[31].s64 = ctx.r[11].s64 + 360;
	// 82606888: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260688C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82606890: 48808299  bl 0x82e0eb28
	ctx.lr = 0x82606894;
	sub_82E0EB28(ctx, base);
	// 82606894: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82606898: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8260689C: 48808385  bl 0x82e0ec20
	ctx.lr = 0x826068A0;
	sub_82E0EC20(ctx, base);
	// 826068A0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 826068A4: 814B0168  lwz r10, 0x168(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) } as u64;
	// 826068A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 826068AC: 419A00A8  beq cr6, 0x82606954
	if ctx.cr[6].eq {
	pc = 0x82606954; continue 'dispatch;
	}
	// 826068B0: 816B0150  lwz r11, 0x150(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 826068B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826068B8: 419A0048  beq cr6, 0x82606900
	if ctx.cr[6].eq {
	pc = 0x82606900; continue 'dispatch;
	}
	// 826068BC: 817E7F10  lwz r11, 0x7f10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32528 as u32) ) } as u64;
	// 826068C0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826068C4: 556907BD  rlwinm. r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 826068C8: 3BEA7F08  addi r31, r10, 0x7f08
	ctx.r[31].s64 = ctx.r[10].s64 + 32520;
	// 826068CC: 4082001C  bne 0x826068e8
	if !ctx.cr[0].eq {
	pc = 0x826068E8; continue 'dispatch;
	}
	// 826068D0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 826068D4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 826068D8: 917E7F10  stw r11, 0x7f10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32528 as u32), ctx.r[11].u32 ) };
	// 826068DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826068E0: 388AAC50  addi r4, r10, -0x53b0
	ctx.r[4].s64 = ctx.r[10].s64 + -21424;
	// 826068E4: 487F2C4D  bl 0x82df9530
	ctx.lr = 0x826068E8;
	sub_82DF9530(ctx, base);
	// 826068E8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 826068EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826068F0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826068F4: 808B0150  lwz r4, 0x150(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(336 as u32) ) } as u64;
	// 826068F8: 806B0168  lwz r3, 0x168(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) } as u64;
	// 826068FC: 4880AA6D  bl 0x82e11368
	ctx.lr = 0x82606900;
	sub_82E11368(ctx, base);
	// 82606900: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82606904: 816B0158  lwz r11, 0x158(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 82606908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260690C: 419A0048  beq cr6, 0x82606954
	if ctx.cr[6].eq {
	pc = 0x82606954; continue 'dispatch;
	}
	// 82606910: 817E7F10  lwz r11, 0x7f10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32528 as u32) ) } as u64;
	// 82606914: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82606918: 5569077B  rlwinm. r9, r11, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8260691C: 3BEA7F04  addi r31, r10, 0x7f04
	ctx.r[31].s64 = ctx.r[10].s64 + 32516;
	// 82606920: 4082001C  bne 0x8260693c
	if !ctx.cr[0].eq {
	pc = 0x8260693C; continue 'dispatch;
	}
	// 82606924: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82606928: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 8260692C: 917E7F10  stw r11, 0x7f10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32528 as u32), ctx.r[11].u32 ) };
	// 82606930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606934: 388A296C  addi r4, r10, 0x296c
	ctx.r[4].s64 = ctx.r[10].s64 + 10604;
	// 82606938: 487F2BF9  bl 0x82df9530
	ctx.lr = 0x8260693C;
	sub_82DF9530(ctx, base);
	// 8260693C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82606940: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82606944: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606948: 808B0158  lwz r4, 0x158(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(344 as u32) ) } as u64;
	// 8260694C: 806B0168  lwz r3, 0x168(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) } as u64;
	// 82606950: 4880AA19  bl 0x82e11368
	ctx.lr = 0x82606954;
	sub_82E11368(ctx, base);
	// 82606954: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606958: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 8260695C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606960: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 82606964: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82606968: 4082000C  bne 0x82606974
	if !ctx.cr[0].eq {
	pc = 0x82606974; continue 'dispatch;
	}
	// 8260696C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82606970: 48000028  b 0x82606998
	pc = 0x82606998; continue 'dispatch;
	// 82606974: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82606978: 4BCDE971  bl 0x822e52e8
	ctx.lr = 0x8260697C;
	sub_822E52E8(ctx, base);
	// 8260697C: 388000D0  li r4, 0xd0
	ctx.r[4].s64 = 208;
	// 82606980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606984: 80BF0030  lwz r5, 0x30(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82606988: 4BCDE961  bl 0x822e52e8
	ctx.lr = 0x8260698C;
	sub_822E52E8(ctx, base);
	// 8260698C: 80BF0034  lwz r5, 0x34(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82606990: 388000CC  li r4, 0xcc
	ctx.r[4].s64 = 204;
	// 82606994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606998: 4BCDE951  bl 0x822e52e8
	ctx.lr = 0x8260699C;
	sub_822E52E8(ctx, base);
	// 8260699C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826069A0: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 826069A4: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826069A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826069AC: 48807E0D  bl 0x82e0e7b8
	ctx.lr = 0x826069B0;
	sub_82E0E7B8(ctx, base);
	// 826069B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 826069B4: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 826069B8: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826069BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826069C0: 48807DF9  bl 0x82e0e7b8
	ctx.lr = 0x826069C4;
	sub_82E0E7B8(ctx, base);
	// 826069C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826069C8: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 826069CC: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826069D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 826069D4: 48807DE5  bl 0x82e0e7b8
	ctx.lr = 0x826069D8;
	sub_82E0E7B8(ctx, base);
	// 826069D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826069DC: 3880004C  li r4, 0x4c
	ctx.r[4].s64 = 76;
	// 826069E0: 835D0000  lwz r26, 0(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826069E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 826069E8: 48807DD1  bl 0x82e0e7b8
	ctx.lr = 0x826069EC;
	sub_82E0E7B8(ctx, base);
	// 826069EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 826069F0: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 826069F4: 833D0000  lwz r25, 0(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826069F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826069FC: 48807DBD  bl 0x82e0e7b8
	ctx.lr = 0x82606A00;
	sub_82E0E7B8(ctx, base);
	// 82606A00: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606A04: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 82606A08: 38DB000C  addi r6, r27, 0xc
	ctx.r[6].s64 = ctx.r[27].s64 + 12;
	// 82606A0C: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 82606A10: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82606A14: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82606A18: 485D6ED1  bl 0x82bdd8e8
	ctx.lr = 0x82606A1C;
	sub_82BDD8E8(ctx, base);
	// 82606A1C: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 82606A20: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82606A24: 48807E6D  bl 0x82e0e890
	ctx.lr = 0x82606A28;
	sub_82E0E890(ctx, base);
	// 82606A28: 3880004C  li r4, 0x4c
	ctx.r[4].s64 = 76;
	// 82606A2C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82606A30: 48807E61  bl 0x82e0e890
	ctx.lr = 0x82606A34;
	sub_82E0E890(ctx, base);
	// 82606A34: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 82606A38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82606A3C: 48807E55  bl 0x82e0e890
	ctx.lr = 0x82606A40;
	sub_82E0E890(ctx, base);
	// 82606A40: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 82606A44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82606A48: 48807E49  bl 0x82e0e890
	ctx.lr = 0x82606A4C;
	sub_82E0E890(ctx, base);
	// 82606A4C: 3880003C  li r4, 0x3c
	ctx.r[4].s64 = 60;
	// 82606A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606A54: 48807E3D  bl 0x82e0e890
	ctx.lr = 0x82606A58;
	sub_82E0E890(ctx, base);
	// 82606A58: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82606A5C: 48BA1750  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82606A60 size=236
    let mut pc: u32 = 0x82606A60;
    'dispatch: loop {
        match pc {
            0x82606A60 => {
    //   block [0x82606A60..0x82606B4C)
	// 82606A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606A64: 48BA1701  bl 0x831a8164
	ctx.lr = 0x82606A68;
	sub_831A8130(ctx, base);
	// 82606A68: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82606A6C: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606A70: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82606A74: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82606A78: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82606A7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82606A80: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82606A84: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82606A88: 3BFE01D0  addi r31, r30, 0x1d0
	ctx.r[31].s64 = ctx.r[30].s64 + 464;
	// 82606A8C: C06B08A8  lfs f3, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82606A90: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82606A94: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82606A98: 488754D9  bl 0x82e7bf70
	ctx.lr = 0x82606A9C;
	sub_82E7BF70(ctx, base);
	// 82606A9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82606AA0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82606AA4: 4BF0B0B5  bl 0x82511b58
	ctx.lr = 0x82606AA8;
	sub_82511B58(ctx, base);
	// 82606AA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82606AAC: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82606AB0: 488753E9  bl 0x82e7be98
	ctx.lr = 0x82606AB4;
	sub_82E7BE98(ctx, base);
	// 82606AB4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82606AB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82606ABC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606AC0: 48875519  bl 0x82e7bfd8
	ctx.lr = 0x82606AC4;
	sub_82E7BFD8(ctx, base);
	// 82606AC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82606AC8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82606ACC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82606AD0: 4BCBDE31  bl 0x822c4900
	ctx.lr = 0x82606AD4;
	sub_822C4900(ctx, base);
	// 82606AD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82606AD8: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82606ADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82606AE0: 4BCBDE21  bl 0x822c4900
	ctx.lr = 0x82606AE4;
	sub_822C4900(ctx, base);
	// 82606AE4: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82606AE8: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82606AEC: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82606AF0: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82606AF4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606AF8: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82606AFC: 138A1C07  vcmpneb. (lvlx128) v28, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82606B00: 13C81C07  vcmpneb. (lvlx128) v30, v8, v3
	tmp.u32 = ctx.r[8].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82606B04: 13A91C07  vcmpneb. (lvlx128) v29, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82606B50 size=108
    let mut pc: u32 = 0x82606B50;
    'dispatch: loop {
        match pc {
            0x82606B50 => {
    //   block [0x82606B50..0x82606BBC)
	// 82606B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606B54: 48BA1619  bl 0x831a816c
	ctx.lr = 0x82606B58;
	sub_831A8130(ctx, base);
	// 82606B58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606B5C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82606B60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82606B64: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82606B68: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82606B6C: 41820038  beq 0x82606ba4
	if ctx.cr[0].eq {
	pc = 0x82606BA4; continue 'dispatch;
	}
	// 82606B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606B74: 48BA2E15  bl 0x831a9988
	ctx.lr = 0x82606B78;
	sub_831A9988(ctx, base);
	// 82606B78: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82606B7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82606B80: 386B68A4  addi r3, r11, 0x68a4
	ctx.r[3].s64 = ctx.r[11].s64 + 26788;
	// 82606B84: 48BA1575  bl 0x831a80f8
	ctx.lr = 0x82606B88;
	sub_831A80F8(ctx, base);
	// 82606B88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82606B8C: 41820018  beq 0x82606ba4
	if ctx.cr[0].eq {
	pc = 0x82606BA4; continue 'dispatch;
	}
	// 82606B90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82606B94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82606B98: 4BFFF909  bl 0x826064a0
	ctx.lr = 0x82606B9C;
	sub_826064A0(ctx, base);
	// 82606B9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82606BA0: 48000014  b 0x82606bb4
	pc = 0x82606BB4; continue 'dispatch;
	// 82606BA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82606BA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82606BAC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82606BB0: 48B778D9  bl 0x8317e488
	ctx.lr = 0x82606BB4;
	sub_8317E488(ctx, base);
	// 82606BB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82606BB8: 48BA1604  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82606BC0 size=304
    let mut pc: u32 = 0x82606BC0;
    'dispatch: loop {
        match pc {
            0x82606BC0 => {
    //   block [0x82606BC0..0x82606CF0)
	// 82606BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606BC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82606BC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606BCC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606BD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82606BD4: 4BF0B75D  bl 0x82512330
	ctx.lr = 0x82606BD8;
	sub_82512330(ctx, base);
	// 82606BD8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606BDC: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82606BE0: 396BA214  addi r11, r11, -0x5dec
	ctx.r[11].s64 = ctx.r[11].s64 + -24044;
	// 82606BE4: 917F00E4  stw r11, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82606BE8: 48856CE9  bl 0x82e5d8d0
	ctx.lr = 0x82606BEC;
	sub_82E5D8D0(ctx, base);
	// 82606BEC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606BF0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82606BF4: 396B27E8  addi r11, r11, 0x27e8
	ctx.r[11].s64 = ctx.r[11].s64 + 10216;
	// 82606BF8: 394A29F4  addi r10, r10, 0x29f4
	ctx.r[10].s64 = ctx.r[10].s64 + 10740;
	// 82606BFC: 917F00E8  stw r11, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82606C00: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82606C04: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82606C08: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82606C0C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82606C10: 394729E4  addi r10, r7, 0x29e4
	ctx.r[10].s64 = ctx.r[7].s64 + 10724;
	// 82606C14: 392929D0  addi r9, r9, 0x29d0
	ctx.r[9].s64 = ctx.r[9].s64 + 10704;
	// 82606C18: 39082984  addi r8, r8, 0x2984
	ctx.r[8].s64 = ctx.r[8].s64 + 10628;
	// 82606C1C: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 82606C20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82606C24: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82606C28: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82606C2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82606C30: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82606C34: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82606C38: 917F014C  stw r11, 0x14c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 82606C3C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82606C40: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82606C44: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82606C48: 917F0154  stw r11, 0x154(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82606C4C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82606C50: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82606C54: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82606C58: 917F015C  stw r11, 0x15c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82606C5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606C60: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82606C64: C1A82978  lfs f13, 0x2978(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(10616 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82606C68: 917F0164  stw r11, 0x164(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 82606C6C: C18708AC  lfs f12, 0x8ac(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2220 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82606C70: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 82606C74: 917F016C  stw r11, 0x16c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82606C78: 917F0170  stw r11, 0x170(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82606C7C: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 82606C80: 917F0178  stw r11, 0x178(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82606C84: 917F017C  stw r11, 0x17c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 82606C88: 917F0180  stw r11, 0x180(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82606C8C: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82606C90: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82606C94: 917F018C  stw r11, 0x18c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82606C98: 917F0190  stw r11, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82606C9C: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82606CA0: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82606CA4: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82606CA8: 917F0198  stw r11, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82606CAC: 917F01A4  stw r11, 0x1a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82606CB0: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82606CB4: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82606CB8: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82606CBC: D01F01C0  stfs f0, 0x1c0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), tmp.u32 ) };
	// 82606CC0: C009A1C4  lfs f0, -0x5e3c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-24124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82606CC4: 997F01C4  stb r11, 0x1c4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[11].u8 ) };
	// 82606CC8: D01F01B4  stfs f0, 0x1b4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82606CCC: 997F01C5  stb r11, 0x1c5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(453 as u32), ctx.r[11].u8 ) };
	// 82606CD0: D1BF01B8  stfs f13, 0x1b8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(440 as u32), tmp.u32 ) };
	// 82606CD4: 98DF01C6  stb r6, 0x1c6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(454 as u32), ctx.r[6].u8 ) };
	// 82606CD8: D19F01BC  stfs f12, 0x1bc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(444 as u32), tmp.u32 ) };
	// 82606CDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82606CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82606CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82606CF0 size=8
    let mut pc: u32 = 0x82606CF0;
    'dispatch: loop {
        match pc {
            0x82606CF0 => {
    //   block [0x82606CF0..0x82606CF8)
	// 82606CF0: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82606CF4: 48000B34  b 0x82607828
	sub_82607828(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82606CF8 size=8
    let mut pc: u32 = 0x82606CF8;
    'dispatch: loop {
        match pc {
            0x82606CF8 => {
    //   block [0x82606CF8..0x82606D00)
	// 82606CF8: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 82606CFC: 48000B2C  b 0x82607828
	sub_82607828(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82606D00 size=8
    let mut pc: u32 = 0x82606D00;
    'dispatch: loop {
        match pc {
            0x82606D00 => {
    //   block [0x82606D00..0x82606D08)
	// 82606D00: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 82606D04: 48000B24  b 0x82607828
	sub_82607828(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82606D08 size=280
    let mut pc: u32 = 0x82606D08;
    'dispatch: loop {
        match pc {
            0x82606D08 => {
    //   block [0x82606D08..0x82606E20)
	// 82606D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82606D10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82606D14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606D18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82606D1C: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82606D20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D24: 419A0008  beq cr6, 0x82606d2c
	if ctx.cr[6].eq {
	pc = 0x82606D2C; continue 'dispatch;
	}
	// 82606D28: 4BCB9B69  bl 0x822c0890
	ctx.lr = 0x82606D2C;
	sub_822C0890(ctx, base);
	// 82606D2C: 807F01A8  lwz r3, 0x1a8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82606D30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D34: 419A0008  beq cr6, 0x82606d3c
	if ctx.cr[6].eq {
	pc = 0x82606D3C; continue 'dispatch;
	}
	// 82606D38: 4BCB9B59  bl 0x822c0890
	ctx.lr = 0x82606D3C;
	sub_822C0890(ctx, base);
	// 82606D3C: 807F0194  lwz r3, 0x194(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82606D40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D44: 419A0008  beq cr6, 0x82606d4c
	if ctx.cr[6].eq {
	pc = 0x82606D4C; continue 'dispatch;
	}
	// 82606D48: 4BCB9B49  bl 0x822c0890
	ctx.lr = 0x82606D4C;
	sub_822C0890(ctx, base);
	// 82606D4C: 807F018C  lwz r3, 0x18c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 82606D50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D54: 419A0008  beq cr6, 0x82606d5c
	if ctx.cr[6].eq {
	pc = 0x82606D5C; continue 'dispatch;
	}
	// 82606D58: 4BCB9B39  bl 0x822c0890
	ctx.lr = 0x82606D5C;
	sub_822C0890(ctx, base);
	// 82606D5C: 807F0184  lwz r3, 0x184(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) } as u64;
	// 82606D60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D64: 419A0008  beq cr6, 0x82606d6c
	if ctx.cr[6].eq {
	pc = 0x82606D6C; continue 'dispatch;
	}
	// 82606D68: 4BCB9B29  bl 0x822c0890
	ctx.lr = 0x82606D6C;
	sub_822C0890(ctx, base);
	// 82606D6C: 807F017C  lwz r3, 0x17c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 82606D70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D74: 419A0008  beq cr6, 0x82606d7c
	if ctx.cr[6].eq {
	pc = 0x82606D7C; continue 'dispatch;
	}
	// 82606D78: 4BCB9B19  bl 0x822c0890
	ctx.lr = 0x82606D7C;
	sub_822C0890(ctx, base);
	// 82606D7C: 807F0174  lwz r3, 0x174(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 82606D80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D84: 419A0008  beq cr6, 0x82606d8c
	if ctx.cr[6].eq {
	pc = 0x82606D8C; continue 'dispatch;
	}
	// 82606D88: 4BCB9B09  bl 0x822c0890
	ctx.lr = 0x82606D8C;
	sub_822C0890(ctx, base);
	// 82606D8C: 807F016C  lwz r3, 0x16c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 82606D90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606D94: 419A0008  beq cr6, 0x82606d9c
	if ctx.cr[6].eq {
	pc = 0x82606D9C; continue 'dispatch;
	}
	// 82606D98: 4BCB9AF9  bl 0x822c0890
	ctx.lr = 0x82606D9C;
	sub_822C0890(ctx, base);
	// 82606D9C: 807F0164  lwz r3, 0x164(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(356 as u32) ) } as u64;
	// 82606DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606DA4: 419A0008  beq cr6, 0x82606dac
	if ctx.cr[6].eq {
	pc = 0x82606DAC; continue 'dispatch;
	}
	// 82606DA8: 4BCB9AE9  bl 0x822c0890
	ctx.lr = 0x82606DAC;
	sub_822C0890(ctx, base);
	// 82606DAC: 807F015C  lwz r3, 0x15c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(348 as u32) ) } as u64;
	// 82606DB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606DB4: 419A0008  beq cr6, 0x82606dbc
	if ctx.cr[6].eq {
	pc = 0x82606DBC; continue 'dispatch;
	}
	// 82606DB8: 4BCB9AD9  bl 0x822c0890
	ctx.lr = 0x82606DBC;
	sub_822C0890(ctx, base);
	// 82606DBC: 807F0154  lwz r3, 0x154(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(340 as u32) ) } as u64;
	// 82606DC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606DC4: 419A0008  beq cr6, 0x82606dcc
	if ctx.cr[6].eq {
	pc = 0x82606DCC; continue 'dispatch;
	}
	// 82606DC8: 4BCB9AC9  bl 0x822c0890
	ctx.lr = 0x82606DCC;
	sub_822C0890(ctx, base);
	// 82606DCC: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82606DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82606DD4: 419A0008  beq cr6, 0x82606ddc
	if ctx.cr[6].eq {
	pc = 0x82606DDC; continue 'dispatch;
	}
	// 82606DD8: 4BCB9AB9  bl 0x822c0890
	ctx.lr = 0x82606DDC;
	sub_822C0890(ctx, base);
	// 82606DDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82606DE0: 387F00E8  addi r3, r31, 0xe8
	ctx.r[3].s64 = ctx.r[31].s64 + 232;
	// 82606DE4: 409A0008  bne cr6, 0x82606dec
	if !ctx.cr[6].eq {
	pc = 0x82606DEC; continue 'dispatch;
	}
	// 82606DE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82606DEC: 48856A5D  bl 0x82e5d848
	ctx.lr = 0x82606DF0;
	sub_82E5D848(ctx, base);
	// 82606DF0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82606DF4: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82606DF8: 409A0008  bne cr6, 0x82606e00
	if !ctx.cr[6].eq {
	pc = 0x82606E00; continue 'dispatch;
	}
	// 82606DFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82606E00: 481A0859  bl 0x827a7658
	ctx.lr = 0x82606E04;
	sub_827A7658(ctx, base);
	// 82606E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606E08: 4BD48549  bl 0x8234f350
	ctx.lr = 0x82606E0C;
	sub_8234F350(ctx, base);
	// 82606E0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82606E10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82606E14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82606E18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82606E1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82606E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82606E20 size=732
    let mut pc: u32 = 0x82606E20;
    'dispatch: loop {
        match pc {
            0x82606E20 => {
    //   block [0x82606E20..0x826070FC)
	// 82606E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82606E24: 48BA1345  bl 0x831a8168
	ctx.lr = 0x82606E28;
	sub_831A8130(ctx, base);
	// 82606E28: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 82606E2C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82606E30: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82606E34: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82606E38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606E3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82606E40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82606E44: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82606E48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606E4C: 388B2408  addi r4, r11, 0x2408
	ctx.r[4].s64 = ctx.r[11].s64 + 9224;
	// 82606E50: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82606E54: 487ECBB5  bl 0x82df3a08
	ctx.lr = 0x82606E58;
	sub_82DF3A08(ctx, base);
	// 82606E58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82606E5C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82606E60: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82606E64: 389E00D0  addi r4, r30, 0xd0
	ctx.r[4].s64 = ctx.r[30].s64 + 208;
	// 82606E68: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82606E6C: C3EB9528  lfs f31, -0x6ad8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82606E70: C3C908A4  lfs f30, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82606E74: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82606E78: C04ADD6C  lfs f2, -0x2294(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82606E7C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82606E80: 4BF9C331  bl 0x825a31b0
	ctx.lr = 0x82606E84;
	sub_825A31B0(ctx, base);
	// 82606E84: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82606E88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82606E8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82606E90: 4BF9A8E1  bl 0x825a1770
	ctx.lr = 0x82606E94;
	sub_825A1770(ctx, base);
	// 82606E94: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 82606E98: 487EC591  bl 0x82df3428
	ctx.lr = 0x82606E9C;
	sub_82DF3428(ctx, base);
	// 82606E9C: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 82606EA0: 4BCC1E19  bl 0x822c8cb8
	ctx.lr = 0x82606EA4;
	sub_822C8CB8(ctx, base);
	// 82606EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606EA8: 487EC581  bl 0x82df3428
	ctx.lr = 0x82606EAC;
	sub_82DF3428(ctx, base);
	// 82606EAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606EB0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82606EB4: 388B2AB0  addi r4, r11, 0x2ab0
	ctx.r[4].s64 = ctx.r[11].s64 + 10928;
	// 82606EB8: 38A000C3  li r5, 0xc3
	ctx.r[5].s64 = 195;
	// 82606EBC: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82606EC0: 4BCB9519  bl 0x822c03d8
	ctx.lr = 0x82606EC4;
	sub_822C03D8(ctx, base);
	// 82606EC4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82606EC8: 41820030  beq 0x82606ef8
	if ctx.cr[0].eq {
	pc = 0x82606EF8; continue 'dispatch;
	}
	// 82606ECC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606ED0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82606ED4: 388B2A94  addi r4, r11, 0x2a94
	ctx.r[4].s64 = ctx.r[11].s64 + 10900;
	// 82606ED8: 487ECB31  bl 0x82df3a08
	ctx.lr = 0x82606EDC;
	sub_82DF3A08(ctx, base);
	// 82606EDC: 38BE00E0  addi r5, r30, 0xe0
	ctx.r[5].s64 = ctx.r[30].s64 + 224;
	// 82606EE0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82606EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606EE8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82606EEC: 4BF9FA1D  bl 0x825a6908
	ctx.lr = 0x82606EF0;
	sub_825A6908(ctx, base);
	// 82606EF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82606EF4: 48000008  b 0x82606efc
	pc = 0x82606EFC; continue 'dispatch;
	// 82606EF8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82606EFC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606F00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606F04: 388B2A88  addi r4, r11, 0x2a88
	ctx.r[4].s64 = ctx.r[11].s64 + 10888;
	// 82606F08: 487ECB01  bl 0x82df3a08
	ctx.lr = 0x82606F0C;
	sub_82DF3A08(ctx, base);
	// 82606F0C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82606F10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82606F14: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82606F18: 4BF99F51  bl 0x825a0e68
	ctx.lr = 0x82606F1C;
	sub_825A0E68(ctx, base);
	// 82606F1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82606F20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82606F24: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82606F28: 4BCB90D9  bl 0x822c0000
	ctx.lr = 0x82606F2C;
	sub_822C0000(ctx, base);
	// 82606F2C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82606F30: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82606F34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82606F38: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82606F3C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82606F40: 419A0024  beq cr6, 0x82606f64
	if ctx.cr[6].eq {
	pc = 0x82606F64; continue 'dispatch;
	}
	// 82606F44: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82606F48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82606F4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82606F50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82606F54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82606F58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82606F5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82606F60: 4082FFE8  bne 0x82606f48
	if !ctx.cr[0].eq {
	pc = 0x82606F48; continue 'dispatch;
	}
	// 82606F64: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82606F68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82606F6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82606F70: 4BF9B1A1  bl 0x825a2110
	ctx.lr = 0x82606F74;
	sub_825A2110(ctx, base);
	// 82606F74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82606F78: 419A000C  beq cr6, 0x82606f84
	if ctx.cr[6].eq {
	pc = 0x82606F84; continue 'dispatch;
	}
	// 82606F7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82606F80: 4BCB9911  bl 0x822c0890
	ctx.lr = 0x82606F84;
	sub_822C0890(ctx, base);
	// 82606F84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606F88: 487EC4A1  bl 0x82df3428
	ctx.lr = 0x82606F8C;
	sub_82DF3428(ctx, base);
	// 82606F8C: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82606F90: 4182000C  beq 0x82606f9c
	if ctx.cr[0].eq {
	pc = 0x82606F9C; continue 'dispatch;
	}
	// 82606F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82606F98: 487EC491  bl 0x82df3428
	ctx.lr = 0x82606F9C;
	sub_82DF3428(ctx, base);
	// 82606F9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82606FA4: 388B2A7C  addi r4, r11, 0x2a7c
	ctx.r[4].s64 = ctx.r[11].s64 + 10876;
	// 82606FA8: 487ECA61  bl 0x82df3a08
	ctx.lr = 0x82606FAC;
	sub_82DF3A08(ctx, base);
	// 82606FAC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82606FB0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82606FB4: 388B2A6C  addi r4, r11, 0x2a6c
	ctx.r[4].s64 = ctx.r[11].s64 + 10860;
	// 82606FB8: 487ECA51  bl 0x82df3a08
	ctx.lr = 0x82606FBC;
	sub_82DF3A08(ctx, base);
	// 82606FBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82606FC0: 38BE00D4  addi r5, r30, 0xd4
	ctx.r[5].s64 = ctx.r[30].s64 + 212;
	// 82606FC4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82606FC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82606FCC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82606FD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82606FD4: C3AB9A8C  lfs f29, -0x6574(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25972 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82606FD8: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82606FDC: 4BF9C2CD  bl 0x825a32a8
	ctx.lr = 0x82606FE0;
	sub_825A32A8(ctx, base);
	// 82606FE0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82606FE4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82606FE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82606FEC: 4BF9A785  bl 0x825a1770
	ctx.lr = 0x82606FF0;
	sub_825A1770(ctx, base);
	// 82606FF0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82606FF4: 487EC435  bl 0x82df3428
	ctx.lr = 0x82606FF8;
	sub_82DF3428(ctx, base);
	// 82606FF8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82606FFC: 4BCC1CBD  bl 0x822c8cb8
	ctx.lr = 0x82607000;
	sub_822C8CB8(ctx, base);
	// 82607000: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607004: 487EC425  bl 0x82df3428
	ctx.lr = 0x82607008;
	sub_82DF3428(ctx, base);
	// 82607008: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260700C: 487EC41D  bl 0x82df3428
	ctx.lr = 0x82607010;
	sub_82DF3428(ctx, base);
	// 82607010: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607018: 388B2A54  addi r4, r11, 0x2a54
	ctx.r[4].s64 = ctx.r[11].s64 + 10836;
	// 8260701C: 487EC9ED  bl 0x82df3a08
	ctx.lr = 0x82607020;
	sub_82DF3A08(ctx, base);
	// 82607020: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82607024: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607028: 388B34B0  addi r4, r11, 0x34b0
	ctx.r[4].s64 = ctx.r[11].s64 + 13488;
	// 8260702C: 487EC9DD  bl 0x82df3a08
	ctx.lr = 0x82607030;
	sub_82DF3A08(ctx, base);
	// 82607030: 38BE00DC  addi r5, r30, 0xdc
	ctx.r[5].s64 = ctx.r[30].s64 + 220;
	// 82607034: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82607038: FC40E890  fmr f2, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8260703C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82607040: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82607044: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82607048: 4BF9C261  bl 0x825a32a8
	ctx.lr = 0x8260704C;
	sub_825A32A8(ctx, base);
	// 8260704C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82607050: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82607054: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607058: 4BF9A719  bl 0x825a1770
	ctx.lr = 0x8260705C;
	sub_825A1770(ctx, base);
	// 8260705C: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 82607060: 487EC3C9  bl 0x82df3428
	ctx.lr = 0x82607064;
	sub_82DF3428(ctx, base);
	// 82607064: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82607068: 4BCC1C51  bl 0x822c8cb8
	ctx.lr = 0x8260706C;
	sub_822C8CB8(ctx, base);
	// 8260706C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607070: 487EC3B9  bl 0x82df3428
	ctx.lr = 0x82607074;
	sub_82DF3428(ctx, base);
	// 82607074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607078: 487EC3B1  bl 0x82df3428
	ctx.lr = 0x8260707C;
	sub_82DF3428(ctx, base);
	// 8260707C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607080: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607084: 388B2A3C  addi r4, r11, 0x2a3c
	ctx.r[4].s64 = ctx.r[11].s64 + 10812;
	// 82607088: 487EC981  bl 0x82df3a08
	ctx.lr = 0x8260708C;
	sub_82DF3A08(ctx, base);
	// 8260708C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607090: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607094: 388B2A30  addi r4, r11, 0x2a30
	ctx.r[4].s64 = ctx.r[11].s64 + 10800;
	// 82607098: 487EC971  bl 0x82df3a08
	ctx.lr = 0x8260709C;
	sub_82DF3A08(ctx, base);
	// 8260709C: 38BE00D8  addi r5, r30, 0xd8
	ctx.r[5].s64 = ctx.r[30].s64 + 216;
	// 826070A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826070A4: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 826070A8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 826070AC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826070B0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 826070B4: 4BF9C1F5  bl 0x825a32a8
	ctx.lr = 0x826070B8;
	sub_825A32A8(ctx, base);
	// 826070B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826070BC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 826070C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826070C4: 4BF9A6AD  bl 0x825a1770
	ctx.lr = 0x826070C8;
	sub_825A1770(ctx, base);
	// 826070C8: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 826070CC: 487EC35D  bl 0x82df3428
	ctx.lr = 0x826070D0;
	sub_82DF3428(ctx, base);
	// 826070D0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826070D4: 4BCC1BE5  bl 0x822c8cb8
	ctx.lr = 0x826070D8;
	sub_822C8CB8(ctx, base);
	// 826070D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 826070DC: 487EC34D  bl 0x82df3428
	ctx.lr = 0x826070E0;
	sub_82DF3428(ctx, base);
	// 826070E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826070E4: 487EC345  bl 0x82df3428
	ctx.lr = 0x826070E8;
	sub_82DF3428(ctx, base);
	// 826070E8: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 826070EC: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 826070F0: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 826070F4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 826070F8: 48BA10C0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607100 size=216
    let mut pc: u32 = 0x82607100;
    'dispatch: loop {
        match pc {
            0x82607100 => {
    //   block [0x82607100..0x826071D8)
	// 82607100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607104: 48BA1069  bl 0x831a816c
	ctx.lr = 0x82607108;
	sub_831A8130(ctx, base);
	// 82607108: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8260710C: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607110: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607114: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82607118: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260711C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82607120: C01F019C  lfs f0, 0x19c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82607124: 83DF0188  lwz r30, 0x188(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82607128: C1BF01B4  lfs f13, 0x1b4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8260712C: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82607130: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82607134: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82607138: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8260713C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82607140: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82607144: 48874E95  bl 0x82e7bfd8
	ctx.lr = 0x82607148;
	sub_82E7BFD8(ctx, base);
	// 82607148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260714C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607150: 4880C111  bl 0x82e13260
	ctx.lr = 0x82607154;
	sub_82E13260(ctx, base);
	// 82607154: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82607158: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8260715C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607160: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82607164: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82607168: C00B9450  lfs f0, -0x6bb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8260716C: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82607170: 4BF0A9E9  bl 0x82511b58
	ctx.lr = 0x82607174;
	sub_82511B58(ctx, base);
	// 82607174: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607178: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8260717C: 48874D1D  bl 0x82e7be98
	ctx.lr = 0x82607180;
	sub_82E7BE98(ctx, base);
	// 82607180: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607184: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82607188: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8260718C: 48874B3D  bl 0x82e7bcc8
	ctx.lr = 0x82607190;
	sub_82E7BCC8(ctx, base);
	// 82607190: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82607194: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82607198: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 8260719C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826071A0: 3BC10080  addi r30, r1, 0x80
	ctx.r[30].s64 = ctx.r[1].s64 + 128;
	// 826071A4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 826071A8: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826071D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826071D8 size=124
    let mut pc: u32 = 0x826071D8;
    'dispatch: loop {
        match pc {
            0x826071D8 => {
    //   block [0x826071D8..0x82607254)
	// 826071D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826071DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826071E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826071E4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826071E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826071EC: 3BE401AC  addi r31, r4, 0x1ac
	ctx.r[31].s64 = ctx.r[4].s64 + 428;
	// 826071F0: 816401AC  lwz r11, 0x1ac(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(428 as u32) ) } as u64;
	// 826071F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826071F8: 409A0048  bne cr6, 0x82607240
	if !ctx.cr[6].eq {
	pc = 0x82607240; continue 'dispatch;
	}
	// 826071FC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82607200: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82607204: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607208: 38AA2AF8  addi r5, r10, 0x2af8
	ctx.r[5].s64 = ctx.r[10].s64 + 11000;
	// 8260720C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82607210: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82607214: 4E800421  bctrl
	ctx.lr = 0x82607218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82607218: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260721C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82607220: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82607224: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82607228: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260722C: 4BCBD235  bl 0x822c4460
	ctx.lr = 0x82607230;
	sub_822C4460(ctx, base);
	// 82607230: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82607234: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607238: 419A0008  beq cr6, 0x82607240
	if ctx.cr[6].eq {
	pc = 0x82607240; continue 'dispatch;
	}
	// 8260723C: 4BCB9655  bl 0x822c0890
	ctx.lr = 0x82607240;
	sub_822C0890(ctx, base);
	// 82607240: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607244: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82607248: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260724C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82607250: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607258 size=84
    let mut pc: u32 = 0x82607258;
    'dispatch: loop {
        match pc {
            0x82607258 => {
    //   block [0x82607258..0x826072AC)
	// 82607258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260725C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82607260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82607264: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260726C: 807F01AC  lwz r3, 0x1ac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 82607270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607274: 419A0024  beq cr6, 0x82607298
	if ctx.cr[6].eq {
	pc = 0x82607298; continue 'dispatch;
	}
	// 82607278: 4853F451  bl 0x82b466c8
	ctx.lr = 0x8260727C;
	sub_82B466C8(ctx, base);
	// 8260727C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607280: 917F01AC  stw r11, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82607284: 807F01B0  lwz r3, 0x1b0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 82607288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260728C: 917F01B0  stw r11, 0x1b0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 82607290: 419A0008  beq cr6, 0x82607298
	if ctx.cr[6].eq {
	pc = 0x82607298; continue 'dispatch;
	}
	// 82607294: 4BCB95FD  bl 0x822c0890
	ctx.lr = 0x82607298;
	sub_822C0890(ctx, base);
	// 82607298: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260729C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826072A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826072A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826072A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826072B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826072B0 size=148
    let mut pc: u32 = 0x826072B0;
    'dispatch: loop {
        match pc {
            0x826072B0 => {
    //   block [0x826072B0..0x82607344)
	// 826072B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826072B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 826072B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 826072BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826072C0: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 826072C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826072C8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 826072CC: 409A0064  bne cr6, 0x82607330
	if !ctx.cr[6].eq {
	pc = 0x82607330; continue 'dispatch;
	}
	// 826072D0: 48B4D331  bl 0x83154600
	ctx.lr = 0x826072D4;
	sub_83154600(ctx, base);
	// 826072D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 826072D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826072DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826072E0: 996A01C6  stb r11, 0x1c6(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(454 as u32), ctx.r[11].u8 ) };
	// 826072E4: 996A01C5  stb r11, 0x1c5(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(453 as u32), ctx.r[11].u8 ) };
	// 826072E8: 48B4D319  bl 0x83154600
	ctx.lr = 0x826072EC;
	sub_83154600(ctx, base);
	// 826072EC: 4BFFFEED  bl 0x826071d8
	ctx.lr = 0x826072F0;
	sub_826071D8(ctx, base);
	// 826072F0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826072F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826072F8: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 826072FC: 487EC70D  bl 0x82df3a08
	ctx.lr = 0x82607300;
	sub_82DF3A08(ctx, base);
	// 82607300: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82607304: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82607308: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260730C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82607310: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607314: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82607318: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8260731C: 48857775  bl 0x82e5ea90
	ctx.lr = 0x82607320;
	sub_82E5EA90(ctx, base);
	// 82607320: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82607324: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607328: 419A0008  beq cr6, 0x82607330
	if ctx.cr[6].eq {
	pc = 0x82607330; continue 'dispatch;
	}
	// 8260732C: 4BCB9565  bl 0x822c0890
	ctx.lr = 0x82607330;
	sub_822C0890(ctx, base);
	// 82607330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82607338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8260733C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82607340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607348 size=48
    let mut pc: u32 = 0x82607348;
    'dispatch: loop {
        match pc {
            0x82607348 => {
    //   block [0x82607348..0x82607378)
	// 82607348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260734C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82607350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607354: 48B4D2AD  bl 0x83154600
	ctx.lr = 0x82607358;
	sub_83154600(ctx, base);
	// 82607358: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 8260735C: C00B7F00  lfs f0, 0x7f00(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82607360: D00301A0  stfs f0, 0x1a0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82607364: 4BFFFE75  bl 0x826071d8
	ctx.lr = 0x82607368;
	sub_826071D8(ctx, base);
	// 82607368: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8260736C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82607370: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82607374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607378 size=200
    let mut pc: u32 = 0x82607378;
    'dispatch: loop {
        match pc {
            0x82607378 => {
    //   block [0x82607378..0x82607440)
	// 82607378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260737C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82607380: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82607384: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82607388: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8260738C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607390: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82607394: 48B4D26D  bl 0x83154600
	ctx.lr = 0x82607398;
	sub_83154600(ctx, base);
	// 82607398: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 8260739C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 826073A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826073A4: C00B02AC  lfs f0, 0x2ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826073A8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 826073AC: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 826073B0: 488523C9  bl 0x82e59778
	ctx.lr = 0x826073B4;
	sub_82E59778(ctx, base);
	// 826073B4: C01F019C  lfs f0, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826073B8: C1BF01A0  lfs f13, 0x1a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826073BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826073C0: EC01037A  fmadds f0, f1, f13, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 826073C4: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 826073C8: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 826073CC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 826073D0: 4199004C  bgt cr6, 0x8260741c
	if ctx.cr[6].gt {
	pc = 0x8260741C; continue 'dispatch;
	}
	// 826073D4: D3FF019C  stfs f31, 0x19c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 826073D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826073DC: 4BFFFE7D  bl 0x82607258
	ctx.lr = 0x826073E0;
	sub_82607258(ctx, base);
	// 826073E0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826073E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826073E8: 388BCFB0  addi r4, r11, -0x3050
	ctx.r[4].s64 = ctx.r[11].s64 + -12368;
	// 826073EC: 487EC61D  bl 0x82df3a08
	ctx.lr = 0x826073F0;
	sub_82DF3A08(ctx, base);
	// 826073F0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826073F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826073F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826073FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82607400: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607404: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82607408: 48857689  bl 0x82e5ea90
	ctx.lr = 0x8260740C;
	sub_82E5EA90(ctx, base);
	// 8260740C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82607410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607414: 419A0008  beq cr6, 0x8260741c
	if ctx.cr[6].eq {
	pc = 0x8260741C; continue 'dispatch;
	}
	// 82607418: 4BCB9479  bl 0x822c0890
	ctx.lr = 0x8260741C;
	sub_822C0890(ctx, base);
	// 8260741C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607420: 4BFFFCE1  bl 0x82607100
	ctx.lr = 0x82607424;
	sub_82607100(ctx, base);
	// 82607424: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82607428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8260742C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82607430: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82607434: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82607438: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8260743C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607440 size=112
    let mut pc: u32 = 0x82607440;
    'dispatch: loop {
        match pc {
            0x82607440 => {
    //   block [0x82607440..0x826074B0)
	// 82607440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607444: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82607448: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8260744C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82607450: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607454: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260745C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82607460: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607464: 4BFFEAC5  bl 0x82605f28
	ctx.lr = 0x82607468;
	sub_82605F28(ctx, base);
	// 82607468: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8260746C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607470: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607474: 4BCB8B8D  bl 0x822c0000
	ctx.lr = 0x82607478;
	sub_822C0000(ctx, base);
	// 82607478: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8260747C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82607480: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82607484: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82607488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260748C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82607490: 419A0008  beq cr6, 0x82607498
	if ctx.cr[6].eq {
	pc = 0x82607498; continue 'dispatch;
	}
	// 82607494: 4BCB93FD  bl 0x822c0890
	ctx.lr = 0x82607498;
	sub_822C0890(ctx, base);
	// 82607498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8260749C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 826074A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 826074A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 826074A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 826074AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826074B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x826074B0 size=136
    let mut pc: u32 = 0x826074B0;
    'dispatch: loop {
        match pc {
            0x826074B0 => {
    //   block [0x826074B0..0x82607538)
	// 826074B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826074B4: 48BA0CB5  bl 0x831a8168
	ctx.lr = 0x826074B8;
	sub_831A8130(ctx, base);
	// 826074B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826074BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826074C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 826074C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826074C8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826074CC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 826074D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826074D4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 826074D8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 826074DC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 826074E0: 487EAF09  bl 0x82df23e8
	ctx.lr = 0x826074E4;
	sub_82DF23E8(ctx, base);
	// 826074E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826074E8: 4182001C  beq 0x82607504
	if ctx.cr[0].eq {
	pc = 0x82607504; continue 'dispatch;
	}
	// 826074EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 826074F0: C03D0000  lfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826074F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826074F8: 48550771  bl 0x82b57c68
	ctx.lr = 0x826074FC;
	sub_82B57C68(ctx, base);
	// 826074FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607500: 48000008  b 0x82607508
	pc = 0x82607508; continue 'dispatch;
	// 82607504: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607508: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8260750C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82607510: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607514: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607518: 4BFFEAD9  bl 0x82605ff0
	ctx.lr = 0x8260751C;
	sub_82605FF0(ctx, base);
	// 8260751C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82607520: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607528: 4BCB8AD9  bl 0x822c0000
	ctx.lr = 0x8260752C;
	sub_822C0000(ctx, base);
	// 8260752C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82607530: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82607534: 48BA0C84  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607538 size=124
    let mut pc: u32 = 0x82607538;
    'dispatch: loop {
        match pc {
            0x82607538 => {
    //   block [0x82607538..0x826075B4)
	// 82607538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260753C: 48BA0C31  bl 0x831a816c
	ctx.lr = 0x82607540;
	sub_831A8130(ctx, base);
	// 82607540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82607548: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8260754C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607550: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82607554: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82607558: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8260755C: 487EAE8D  bl 0x82df23e8
	ctx.lr = 0x82607560;
	sub_82DF23E8(ctx, base);
	// 82607560: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82607564: 4182001C  beq 0x82607580
	if ctx.cr[0].eq {
	pc = 0x82607580; continue 'dispatch;
	}
	// 82607568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260756C: 488553BD  bl 0x82e5c928
	ctx.lr = 0x82607570;
	sub_82E5C928(ctx, base);
	// 82607570: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607574: 396B2898  addi r11, r11, 0x2898
	ctx.r[11].s64 = ctx.r[11].s64 + 10392;
	// 82607578: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260757C: 48000008  b 0x82607584
	pc = 0x82607584; continue 'dispatch;
	// 82607580: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607584: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82607588: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8260758C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607594: 4BFFEB25  bl 0x826060b8
	ctx.lr = 0x82607598;
	sub_826060B8(ctx, base);
	// 82607598: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260759C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826075A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826075A4: 4BCB8A5D  bl 0x822c0000
	ctx.lr = 0x826075A8;
	sub_822C0000(ctx, base);
	// 826075A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826075AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826075B0: 48BA0C0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826075B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826075B8 size=124
    let mut pc: u32 = 0x826075B8;
    'dispatch: loop {
        match pc {
            0x826075B8 => {
    //   block [0x826075B8..0x82607634)
	// 826075B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826075BC: 48BA0BB1  bl 0x831a816c
	ctx.lr = 0x826075C0;
	sub_831A8130(ctx, base);
	// 826075C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826075C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826075C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826075CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826075D0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 826075D4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 826075D8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826075DC: 487EAE0D  bl 0x82df23e8
	ctx.lr = 0x826075E0;
	sub_82DF23E8(ctx, base);
	// 826075E0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826075E4: 4182001C  beq 0x82607600
	if ctx.cr[0].eq {
	pc = 0x82607600; continue 'dispatch;
	}
	// 826075E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826075EC: 4885533D  bl 0x82e5c928
	ctx.lr = 0x826075F0;
	sub_82E5C928(ctx, base);
	// 826075F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826075F4: 396B28C0  addi r11, r11, 0x28c0
	ctx.r[11].s64 = ctx.r[11].s64 + 10432;
	// 826075F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826075FC: 48000008  b 0x82607604
	pc = 0x82607604; continue 'dispatch;
	// 82607600: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607604: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82607608: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8260760C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607610: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607614: 4BFFEB6D  bl 0x82606180
	ctx.lr = 0x82607618;
	sub_82606180(ctx, base);
	// 82607618: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260761C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607624: 4BCB89DD  bl 0x822c0000
	ctx.lr = 0x82607628;
	sub_822C0000(ctx, base);
	// 82607628: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260762C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607630: 48BA0B8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607638 size=124
    let mut pc: u32 = 0x82607638;
    'dispatch: loop {
        match pc {
            0x82607638 => {
    //   block [0x82607638..0x826076B4)
	// 82607638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260763C: 48BA0B31  bl 0x831a816c
	ctx.lr = 0x82607640;
	sub_831A8130(ctx, base);
	// 82607640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607644: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82607648: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8260764C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607650: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82607654: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82607658: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8260765C: 487EAD8D  bl 0x82df23e8
	ctx.lr = 0x82607660;
	sub_82DF23E8(ctx, base);
	// 82607660: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82607664: 4182001C  beq 0x82607680
	if ctx.cr[0].eq {
	pc = 0x82607680; continue 'dispatch;
	}
	// 82607668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260766C: 488552BD  bl 0x82e5c928
	ctx.lr = 0x82607670;
	sub_82E5C928(ctx, base);
	// 82607670: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607674: 396B28E8  addi r11, r11, 0x28e8
	ctx.r[11].s64 = ctx.r[11].s64 + 10472;
	// 82607678: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260767C: 48000008  b 0x82607684
	pc = 0x82607684; continue 'dispatch;
	// 82607680: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607684: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82607688: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8260768C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607694: 4BFFEBB5  bl 0x82606248
	ctx.lr = 0x82607698;
	sub_82606248(ctx, base);
	// 82607698: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260769C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826076A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826076A4: 4BCB895D  bl 0x822c0000
	ctx.lr = 0x826076A8;
	sub_822C0000(ctx, base);
	// 826076A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826076AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826076B0: 48BA0B0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826076B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826076B8 size=124
    let mut pc: u32 = 0x826076B8;
    'dispatch: loop {
        match pc {
            0x826076B8 => {
    //   block [0x826076B8..0x82607734)
	// 826076B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826076BC: 48BA0AB1  bl 0x831a816c
	ctx.lr = 0x826076C0;
	sub_831A8130(ctx, base);
	// 826076C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826076C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 826076C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826076CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826076D0: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 826076D4: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 826076D8: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 826076DC: 487EAD0D  bl 0x82df23e8
	ctx.lr = 0x826076E0;
	sub_82DF23E8(ctx, base);
	// 826076E0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 826076E4: 4182001C  beq 0x82607700
	if ctx.cr[0].eq {
	pc = 0x82607700; continue 'dispatch;
	}
	// 826076E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826076EC: 4885523D  bl 0x82e5c928
	ctx.lr = 0x826076F0;
	sub_82E5C928(ctx, base);
	// 826076F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826076F4: 396B2910  addi r11, r11, 0x2910
	ctx.r[11].s64 = ctx.r[11].s64 + 10512;
	// 826076F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 826076FC: 48000008  b 0x82607704
	pc = 0x82607704; continue 'dispatch;
	// 82607700: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607704: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82607708: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8260770C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607714: 4BFFEBFD  bl 0x82606310
	ctx.lr = 0x82607718;
	sub_82606310(ctx, base);
	// 82607718: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260771C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607724: 4BCB88DD  bl 0x822c0000
	ctx.lr = 0x82607728;
	sub_822C0000(ctx, base);
	// 82607728: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260772C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607730: 48BA0A8C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607738 size=124
    let mut pc: u32 = 0x82607738;
    'dispatch: loop {
        match pc {
            0x82607738 => {
    //   block [0x82607738..0x826077B4)
	// 82607738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260773C: 48BA0A31  bl 0x831a816c
	ctx.lr = 0x82607740;
	sub_831A8130(ctx, base);
	// 82607740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607744: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82607748: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8260774C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607750: 388B5444  addi r4, r11, 0x5444
	ctx.r[4].s64 = ctx.r[11].s64 + 21572;
	// 82607754: 38A00067  li r5, 0x67
	ctx.r[5].s64 = 103;
	// 82607758: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 8260775C: 487EAC8D  bl 0x82df23e8
	ctx.lr = 0x82607760;
	sub_82DF23E8(ctx, base);
	// 82607760: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82607764: 4182001C  beq 0x82607780
	if ctx.cr[0].eq {
	pc = 0x82607780; continue 'dispatch;
	}
	// 82607768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260776C: 488551BD  bl 0x82e5c928
	ctx.lr = 0x82607770;
	sub_82E5C928(ctx, base);
	// 82607770: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607774: 396B2938  addi r11, r11, 0x2938
	ctx.r[11].s64 = ctx.r[11].s64 + 10552;
	// 82607778: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8260777C: 48000008  b 0x82607784
	pc = 0x82607784; continue 'dispatch;
	// 82607780: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607784: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82607788: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8260778C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607794: 4BFFEC45  bl 0x826063d8
	ctx.lr = 0x82607798;
	sub_826063D8(ctx, base);
	// 82607798: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260779C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826077A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826077A4: 4BCB885D  bl 0x822c0000
	ctx.lr = 0x826077A8;
	sub_822C0000(ctx, base);
	// 826077A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826077AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 826077B0: 48BA0A0C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_826077B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x826077B8 size=108
    let mut pc: u32 = 0x826077B8;
    'dispatch: loop {
        match pc {
            0x826077B8 => {
    //   block [0x826077B8..0x82607824)
	// 826077B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 826077BC: 48BA09B1  bl 0x831a816c
	ctx.lr = 0x826077C0;
	sub_831A8130(ctx, base);
	// 826077C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 826077C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 826077C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 826077CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 826077D0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826077D4: 41820038  beq 0x8260780c
	if ctx.cr[0].eq {
	pc = 0x8260780C; continue 'dispatch;
	}
	// 826077D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826077DC: 48BA21AD  bl 0x831a9988
	ctx.lr = 0x826077E0;
	sub_831A9988(ctx, base);
	// 826077E0: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 826077E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826077E8: 386B6BDC  addi r3, r11, 0x6bdc
	ctx.r[3].s64 = ctx.r[11].s64 + 27612;
	// 826077EC: 48BA090D  bl 0x831a80f8
	ctx.lr = 0x826077F0;
	sub_831A80F8(ctx, base);
	// 826077F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 826077F4: 41820018  beq 0x8260780c
	if ctx.cr[0].eq {
	pc = 0x8260780C; continue 'dispatch;
	}
	// 826077F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826077FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607800: 4BFFFAB1  bl 0x826072b0
	ctx.lr = 0x82607804;
	sub_826072B0(ctx, base);
	// 82607804: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82607808: 48000014  b 0x8260781c
	pc = 0x8260781C; continue 'dispatch;
	// 8260780C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82607810: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607814: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607818: 48B76C71  bl 0x8317e488
	ctx.lr = 0x8260781C;
	sub_8317E488(ctx, base);
	// 8260781C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607820: 48BA099C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607828 size=76
    let mut pc: u32 = 0x82607828;
    'dispatch: loop {
        match pc {
            0x82607828 => {
    //   block [0x82607828..0x82607874)
	// 82607828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260782C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82607830: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82607834: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82607838: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260783C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607840: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607844: 4BFFF4C5  bl 0x82606d08
	ctx.lr = 0x82607848;
	sub_82606D08(ctx, base);
	// 82607848: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8260784C: 4182000C  beq 0x82607858
	if ctx.cr[0].eq {
	pc = 0x82607858; continue 'dispatch;
	}
	// 82607850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607854: 487EAB85  bl 0x82df23d8
	ctx.lr = 0x82607858;
	sub_82DF23D8(ctx, base);
	// 82607858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8260785C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82607864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82607868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8260786C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82607870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82607878 size=8
    let mut pc: u32 = 0x82607878;
    'dispatch: loop {
        match pc {
            0x82607878 => {
    //   block [0x82607878..0x82607880)
	// 82607878: 3863FF1C  addi r3, r3, -0xe4
	ctx.r[3].s64 = ctx.r[3].s64 + -228;
	// 8260787C: 4BFFF884  b 0x82607100
	sub_82607100(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607880 size=248
    let mut pc: u32 = 0x82607880;
    'dispatch: loop {
        match pc {
            0x82607880 => {
    //   block [0x82607880..0x82607978)
	// 82607880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607884: 48BA08E9  bl 0x831a816c
	ctx.lr = 0x82607888;
	sub_831A8130(ctx, base);
	// 82607888: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8260788C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607890: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607894: 817F0198  lwz r11, 0x198(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) } as u64;
	// 82607898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260789C: 409A00D0  bne cr6, 0x8260796c
	if !ctx.cr[6].eq {
	pc = 0x8260796C; continue 'dispatch;
	}
	// 826078A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 826078A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 826078A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 826078AC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 826078B0: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 826078B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826078B8: 389F0190  addi r4, r31, 0x190
	ctx.r[4].s64 = ctx.r[31].s64 + 400;
	// 826078BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826078C0: 4BFF8AD9  bl 0x82600398
	ctx.lr = 0x826078C4;
	sub_82600398(ctx, base);
	// 826078C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 826078C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 826078CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 826078D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826078D4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826078D8: 419A0024  beq cr6, 0x826078fc
	if ctx.cr[6].eq {
	pc = 0x826078FC; continue 'dispatch;
	}
	// 826078DC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826078E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826078E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826078E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826078EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826078F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826078F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826078F8: 4082FFE8  bne 0x826078e0
	if !ctx.cr[0].eq {
	pc = 0x826078E0; continue 'dispatch;
	}
	// 826078FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607900: 3BA10058  addi r29, r1, 0x58
	ctx.r[29].s64 = ctx.r[1].s64 + 88;
	// 82607904: 48A00825  bl 0x83008128
	ctx.lr = 0x82607908;
	sub_83008128(ctx, base);
	// 82607908: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8260790C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82607910: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82607914: 388A2AB0  addi r4, r10, 0x2ab0
	ctx.r[4].s64 = ctx.r[10].s64 + 10928;
	// 82607918: 38A000FA  li r5, 0xfa
	ctx.r[5].s64 = 250;
	// 8260791C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82607920: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82607924: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82607928: 48851119  bl 0x82e58a40
	ctx.lr = 0x8260792C;
	sub_82E58A40(ctx, base);
	// 8260792C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82607930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607934: 419A0008  beq cr6, 0x8260793c
	if ctx.cr[6].eq {
	pc = 0x8260793C; continue 'dispatch;
	}
	// 82607938: 4BCB8F59  bl 0x822c0890
	ctx.lr = 0x8260793C;
	sub_822C0890(ctx, base);
	// 8260793C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82607940: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607944: 419A0008  beq cr6, 0x8260794c
	if ctx.cr[6].eq {
	pc = 0x8260794C; continue 'dispatch;
	}
	// 82607948: 4BCB8F49  bl 0x822c0890
	ctx.lr = 0x8260794C;
	sub_822C0890(ctx, base);
	// 8260794C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82607950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607954: 4BF080FD  bl 0x8250fa50
	ctx.lr = 0x82607958;
	sub_8250FA50(ctx, base);
	// 82607958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260795C: 48A007CD  bl 0x83008128
	ctx.lr = 0x82607960;
	sub_83008128(ctx, base);
	// 82607960: 907F0198  stw r3, 0x198(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), ctx.r[3].u32 ) };
	// 82607964: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82607968: 48000008  b 0x82607970
	pc = 0x82607970; continue 'dispatch;
	// 8260796C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82607970: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82607974: 48BA0848  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607978 size=548
    let mut pc: u32 = 0x82607978;
    'dispatch: loop {
        match pc {
            0x82607978 => {
    //   block [0x82607978..0x82607B9C)
	// 82607978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8260797C: 48BA07ED  bl 0x831a8168
	ctx.lr = 0x82607980;
	sub_831A8130(ctx, base);
	// 82607980: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82607984: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607988: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8260798C: 48B4CC75  bl 0x83154600
	ctx.lr = 0x82607990;
	sub_83154600(ctx, base);
	// 82607990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607998: C3FF01BC  lfs f31, 0x1bc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(444 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8260799C: 48851DDD  bl 0x82e59778
	ctx.lr = 0x826079A0;
	sub_82E59778(ctx, base);
	// 826079A0: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 826079A4: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826079A8: 3BCB02A4  addi r30, r11, 0x2a4
	ctx.r[30].s64 = ctx.r[11].s64 + 676;
	// 826079AC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826079B0: EC1F0024  fdivs f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 826079B4: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 826079B8: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 826079BC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 826079C0: 41980008  blt cr6, 0x826079c8
	if ctx.cr[6].lt {
	pc = 0x826079C8; continue 'dispatch;
	}
	// 826079C4: D3FF01A0  stfs f31, 0x1a0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 826079C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 826079CC: 48851DAD  bl 0x82e59778
	ctx.lr = 0x826079D0;
	sub_82E59778(ctx, base);
	// 826079D0: C01F019C  lfs f0, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826079D4: C1BF01A0  lfs f13, 0x1a0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826079D8: EDA1037A  fmadds f13, f1, f13, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 826079DC: C01F01B4  lfs f0, 0x1b4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826079E0: D1BF019C  stfs f13, 0x19c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 826079E4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 826079E8: 409901A0  ble cr6, 0x82607b88
	if !ctx.cr[6].gt {
	pc = 0x82607B88; continue 'dispatch;
	}
	// 826079EC: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 826079F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826079F4: 4BFFF865  bl 0x82607258
	ctx.lr = 0x826079F8;
	sub_82607258(ctx, base);
	// 826079F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 826079FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82607A00: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82607A04: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82607A08: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82607A0C: C00A08A8  lfs f0, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82607A10: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82607A14: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82607A18: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82607A1C: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82607A20: C1A9CEE4  lfs f13, -0x311c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82607A24: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82607A28: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82607A2C: FC200050  fneg f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82607A30: 48874F59  bl 0x82e7c988
	ctx.lr = 0x82607A34;
	sub_82E7C988(ctx, base);
	// 82607A34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82607A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607A3C: 4BF0A11D  bl 0x82511b58
	ctx.lr = 0x82607A40;
	sub_82511B58(ctx, base);
	// 82607A40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607A44: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82607A48: 48874451  bl 0x82e7be98
	ctx.lr = 0x82607A4C;
	sub_82E7BE98(ctx, base);
	// 82607A4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607A50: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82607A54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82607A58: 4BCBCEA9  bl 0x822c4900
	ctx.lr = 0x82607A5C;
	sub_822C4900(ctx, base);
	// 82607A5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607A60: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82607A64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82607A68: 48874261  bl 0x82e7bcc8
	ctx.lr = 0x82607A6C;
	sub_82E7BCC8(ctx, base);
	// 82607A6C: 396001B8  li r11, 0x1b8
	ctx.r[11].s64 = 440;
	// 82607A70: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82607A74: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82607A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607A7C: 3BDF01C0  addi r30, r31, 0x1c0
	ctx.r[30].s64 = ctx.r[31].s64 + 448;
	// 82607A80: 13FF5C07  vcmpneb. (lvlx128) v31, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82607A84: 3B8100A0  addi r28, r1, 0xa0
	ctx.r[28].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607BA0 size=136
    let mut pc: u32 = 0x82607BA0;
    'dispatch: loop {
        match pc {
            0x82607BA0 => {
    //   block [0x82607BA0..0x82607C28)
	// 82607BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82607BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82607BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82607BB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607BB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607BBC: 48B4CA45  bl 0x83154600
	ctx.lr = 0x82607BC0;
	sub_83154600(ctx, base);
	// 82607BC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607BC4: 4BFFFCBD  bl 0x82607880
	ctx.lr = 0x82607BC8;
	sub_82607880(ctx, base);
	// 82607BC8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82607BCC: 41820044  beq 0x82607c10
	if ctx.cr[0].eq {
	pc = 0x82607C10; continue 'dispatch;
	}
	// 82607BD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607BD8: 388B2B08  addi r4, r11, 0x2b08
	ctx.r[4].s64 = ctx.r[11].s64 + 11016;
	// 82607BDC: 487EBE2D  bl 0x82df3a08
	ctx.lr = 0x82607BE0;
	sub_82DF3A08(ctx, base);
	// 82607BE0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82607BE4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82607BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607BEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82607BF0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607BF4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82607BF8: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82607BFC: 48856E95  bl 0x82e5ea90
	ctx.lr = 0x82607C00;
	sub_82E5EA90(ctx, base);
	// 82607C00: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82607C04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607C08: 419A0008  beq cr6, 0x82607c10
	if ctx.cr[6].eq {
	pc = 0x82607C10; continue 'dispatch;
	}
	// 82607C0C: 4BCB8C85  bl 0x822c0890
	ctx.lr = 0x82607C10;
	sub_822C0890(ctx, base);
	// 82607C10: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82607C14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82607C18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82607C1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82607C20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82607C24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607C28 size=108
    let mut pc: u32 = 0x82607C28;
    'dispatch: loop {
        match pc {
            0x82607C28 => {
    //   block [0x82607C28..0x82607C94)
	// 82607C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607C2C: 48BA0541  bl 0x831a816c
	ctx.lr = 0x82607C30;
	sub_831A8130(ctx, base);
	// 82607C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607C34: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82607C38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82607C3C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82607C40: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82607C44: 41820038  beq 0x82607c7c
	if ctx.cr[0].eq {
	pc = 0x82607C7C; continue 'dispatch;
	}
	// 82607C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607C4C: 48BA1D3D  bl 0x831a9988
	ctx.lr = 0x82607C50;
	sub_831A9988(ctx, base);
	// 82607C50: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82607C54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607C58: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 82607C5C: 48BA049D  bl 0x831a80f8
	ctx.lr = 0x82607C60;
	sub_831A80F8(ctx, base);
	// 82607C60: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82607C64: 41820018  beq 0x82607c7c
	if ctx.cr[0].eq {
	pc = 0x82607C7C; continue 'dispatch;
	}
	// 82607C68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607C6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607C70: 4BFFFF31  bl 0x82607ba0
	ctx.lr = 0x82607C74;
	sub_82607BA0(ctx, base);
	// 82607C74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82607C78: 48000014  b 0x82607c8c
	pc = 0x82607C8C; continue 'dispatch;
	// 82607C7C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82607C80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607C84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607C88: 48B76801  bl 0x8317e488
	ctx.lr = 0x82607C8C;
	sub_8317E488(ctx, base);
	// 82607C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82607C90: 48BA052C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82607C98 size=424
    let mut pc: u32 = 0x82607C98;
    'dispatch: loop {
        match pc {
            0x82607C98 => {
    //   block [0x82607C98..0x82607E40)
	// 82607C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607C9C: 48BA04C9  bl 0x831a8164
	ctx.lr = 0x82607CA0;
	sub_831A8130(ctx, base);
	// 82607CA0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607CA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82607CA8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82607CAC: 3BCB2AB0  addi r30, r11, 0x2ab0
	ctx.r[30].s64 = ctx.r[11].s64 + 10928;
	// 82607CB0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82607CB4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607CB8: 38A00033  li r5, 0x33
	ctx.r[5].s64 = 51;
	// 82607CBC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82607CC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607CC4: 386001C8  li r3, 0x1c8
	ctx.r[3].s64 = 456;
	// 82607CC8: 487EA721  bl 0x82df23e8
	ctx.lr = 0x82607CCC;
	sub_82DF23E8(ctx, base);
	// 82607CCC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82607CD0: 41820010  beq 0x82607ce0
	if ctx.cr[0].eq {
	pc = 0x82607CE0; continue 'dispatch;
	}
	// 82607CD4: 4BFFEEED  bl 0x82606bc0
	ctx.lr = 0x82607CD8;
	sub_82606BC0(ctx, base);
	// 82607CD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607CDC: 48000008  b 0x82607ce4
	pc = 0x82607CE4; continue 'dispatch;
	// 82607CE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607CE4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82607CE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607CEC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607CF0: 4BFFE171  bl 0x82605e60
	ctx.lr = 0x82607CF4;
	sub_82605E60(ctx, base);
	// 82607CF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82607CF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607CFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82607D00: 4BCB8301  bl 0x822c0000
	ctx.lr = 0x82607D04;
	sub_822C0000(ctx, base);
	// 82607D04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607D08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82607D0C: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 82607D10: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82607D14: 4BCB86C5  bl 0x822c03d8
	ctx.lr = 0x82607D18;
	sub_822C03D8(ctx, base);
	// 82607D18: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82607D1C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82607D20: 418200B4  beq 0x82607dd4
	if ctx.cr[0].eq {
	pc = 0x82607DD4; continue 'dispatch;
	}
	// 82607D24: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82607D28: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82607D2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82607D30: 396A00E4  addi r11, r10, 0xe4
	ctx.r[11].s64 = ctx.r[10].s64 + 228;
	// 82607D34: 409A0008  bne cr6, 0x82607d3c
	if !ctx.cr[6].eq {
	pc = 0x82607D3C; continue 'dispatch;
	}
	// 82607D38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607D3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82607D40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82607D44: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82607D48: 419A0024  beq cr6, 0x82607d6c
	if ctx.cr[6].eq {
	pc = 0x82607D6C; continue 'dispatch;
	}
	// 82607D4C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82607D50: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82607D54: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82607D58: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82607D5C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82607D60: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82607D64: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82607D68: 4082FFE8  bne 0x82607d50
	if !ctx.cr[0].eq {
	pc = 0x82607D50; continue 'dispatch;
	}
	// 82607D6C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82607D70: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82607D74: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82607D78: 419A0024  beq cr6, 0x82607d9c
	if ctx.cr[6].eq {
	pc = 0x82607D9C; continue 'dispatch;
	}
	// 82607D7C: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82607D80: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82607D84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82607D88: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82607D8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82607D90: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82607D94: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82607D98: 4082FFE8  bne 0x82607d80
	if !ctx.cr[0].eq {
	pc = 0x82607D80; continue 'dispatch;
	}
	// 82607D9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82607DA0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82607DA4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82607DA8: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82607DAC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82607DB0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82607DB4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82607DB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82607DBC: 48191175  bl 0x82798f30
	ctx.lr = 0x82607DC0;
	sub_82798F30(ctx, base);
	// 82607DC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607DC8: 481938A1  bl 0x8279b668
	ctx.lr = 0x82607DCC;
	sub_8279B668(ctx, base);
	// 82607DCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607DD0: 48000008  b 0x82607dd8
	pc = 0x82607DD8; continue 'dispatch;
	// 82607DD4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82607DD8: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82607DDC: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82607DE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607DE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607DE8: 4BF8FE69  bl 0x82597c50
	ctx.lr = 0x82607DEC;
	sub_82597C50(ctx, base);
	// 82607DEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82607DF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82607DF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607DF8: 4BCB8209  bl 0x822c0000
	ctx.lr = 0x82607DFC;
	sub_822C0000(ctx, base);
	// 82607DFC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82607E00: 41820024  beq 0x82607e24
	if ctx.cr[0].eq {
	pc = 0x82607E24; continue 'dispatch;
	}
	// 82607E04: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82607E08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607E0C: 419A0008  beq cr6, 0x82607e14
	if ctx.cr[6].eq {
	pc = 0x82607E14; continue 'dispatch;
	}
	// 82607E10: 4BCB8A81  bl 0x822c0890
	ctx.lr = 0x82607E14;
	sub_822C0890(ctx, base);
	// 82607E14: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82607E18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82607E1C: 419A0008  beq cr6, 0x82607e24
	if ctx.cr[6].eq {
	pc = 0x82607E24; continue 'dispatch;
	}
	// 82607E20: 4BCB8A71  bl 0x822c0890
	ctx.lr = 0x82607E24;
	sub_822C0890(ctx, base);
	// 82607E24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82607E28: 419A000C  beq cr6, 0x82607e34
	if ctx.cr[6].eq {
	pc = 0x82607E34; continue 'dispatch;
	}
	// 82607E2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82607E30: 4BCB8A61  bl 0x822c0890
	ctx.lr = 0x82607E34;
	sub_822C0890(ctx, base);
	// 82607E34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82607E38: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82607E3C: 48BA0378  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607E40 size=92
    let mut pc: u32 = 0x82607E40;
    'dispatch: loop {
        match pc {
            0x82607E40 => {
    //   block [0x82607E40..0x82607E9C)
	// 82607E40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607E44: 48BA0329  bl 0x831a816c
	ctx.lr = 0x82607E48;
	sub_831A8130(ctx, base);
	// 82607E48: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607E4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607E50: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 82607E54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82607E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607E5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607E60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82607E64: 388A7538  addi r4, r10, 0x7538
	ctx.r[4].s64 = ctx.r[10].s64 + 30008;
	// 82607E68: 4BD57C09  bl 0x8235fa70
	ctx.lr = 0x82607E6C;
	sub_8235FA70(ctx, base);
	// 82607E6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607E70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607E74: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82607E78: 487EBD89  bl 0x82df3c00
	ctx.lr = 0x82607E7C;
	sub_82DF3C00(ctx, base);
	// 82607E7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607E84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82607E88: 488542D1  bl 0x82e5c158
	ctx.lr = 0x82607E8C;
	sub_82E5C158(ctx, base);
	// 82607E8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607E90: 487EB599  bl 0x82df3428
	ctx.lr = 0x82607E94;
	sub_82DF3428(ctx, base);
	// 82607E94: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82607E98: 48BA0324  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607EA0 size=92
    let mut pc: u32 = 0x82607EA0;
    'dispatch: loop {
        match pc {
            0x82607EA0 => {
    //   block [0x82607EA0..0x82607EFC)
	// 82607EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607EA4: 48BA02C9  bl 0x831a816c
	ctx.lr = 0x82607EA8;
	sub_831A8130(ctx, base);
	// 82607EA8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607EAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607EB0: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 82607EB4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82607EB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607EBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607EC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82607EC4: 388A75B8  addi r4, r10, 0x75b8
	ctx.r[4].s64 = ctx.r[10].s64 + 30136;
	// 82607EC8: 4BD57BA9  bl 0x8235fa70
	ctx.lr = 0x82607ECC;
	sub_8235FA70(ctx, base);
	// 82607ECC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607ED4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82607ED8: 487EBD29  bl 0x82df3c00
	ctx.lr = 0x82607EDC;
	sub_82DF3C00(ctx, base);
	// 82607EDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607EE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82607EE8: 48854271  bl 0x82e5c158
	ctx.lr = 0x82607EEC;
	sub_82E5C158(ctx, base);
	// 82607EEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607EF0: 487EB539  bl 0x82df3428
	ctx.lr = 0x82607EF4;
	sub_82DF3428(ctx, base);
	// 82607EF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82607EF8: 48BA02C4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607F00 size=92
    let mut pc: u32 = 0x82607F00;
    'dispatch: loop {
        match pc {
            0x82607F00 => {
    //   block [0x82607F00..0x82607F5C)
	// 82607F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607F04: 48BA0269  bl 0x831a816c
	ctx.lr = 0x82607F08;
	sub_831A8130(ctx, base);
	// 82607F08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607F0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607F10: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 82607F14: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82607F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607F1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607F20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82607F24: 388A7638  addi r4, r10, 0x7638
	ctx.r[4].s64 = ctx.r[10].s64 + 30264;
	// 82607F28: 4BD57B49  bl 0x8235fa70
	ctx.lr = 0x82607F2C;
	sub_8235FA70(ctx, base);
	// 82607F2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607F30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607F34: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82607F38: 487EBCC9  bl 0x82df3c00
	ctx.lr = 0x82607F3C;
	sub_82DF3C00(ctx, base);
	// 82607F3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607F40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607F44: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82607F48: 48854211  bl 0x82e5c158
	ctx.lr = 0x82607F4C;
	sub_82E5C158(ctx, base);
	// 82607F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607F50: 487EB4D9  bl 0x82df3428
	ctx.lr = 0x82607F54;
	sub_82DF3428(ctx, base);
	// 82607F54: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82607F58: 48BA0264  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607F60 size=92
    let mut pc: u32 = 0x82607F60;
    'dispatch: loop {
        match pc {
            0x82607F60 => {
    //   block [0x82607F60..0x82607FBC)
	// 82607F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607F64: 48BA0209  bl 0x831a816c
	ctx.lr = 0x82607F68;
	sub_831A8130(ctx, base);
	// 82607F68: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607F6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607F70: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 82607F74: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82607F78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607F7C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607F80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82607F84: 388A76B8  addi r4, r10, 0x76b8
	ctx.r[4].s64 = ctx.r[10].s64 + 30392;
	// 82607F88: 4BD57AE9  bl 0x8235fa70
	ctx.lr = 0x82607F8C;
	sub_8235FA70(ctx, base);
	// 82607F8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607F94: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82607F98: 487EBC69  bl 0x82df3c00
	ctx.lr = 0x82607F9C;
	sub_82DF3C00(ctx, base);
	// 82607F9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82607FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82607FA4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82607FA8: 488541B1  bl 0x82e5c158
	ctx.lr = 0x82607FAC;
	sub_82E5C158(ctx, base);
	// 82607FAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82607FB0: 487EB479  bl 0x82df3428
	ctx.lr = 0x82607FB4;
	sub_82DF3428(ctx, base);
	// 82607FB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82607FB8: 48BA0204  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82607FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82607FC0 size=92
    let mut pc: u32 = 0x82607FC0;
    'dispatch: loop {
        match pc {
            0x82607FC0 => {
    //   block [0x82607FC0..0x8260801C)
	// 82607FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82607FC4: 48BA01A9  bl 0x831a816c
	ctx.lr = 0x82607FC8;
	sub_831A8130(ctx, base);
	// 82607FC8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82607FCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82607FD0: 3D408260  lis r10, -0x7da0
	ctx.r[10].s64 = -2107637760;
	// 82607FD4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82607FD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82607FDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82607FE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82607FE4: 388A7738  addi r4, r10, 0x7738
	ctx.r[4].s64 = ctx.r[10].s64 + 30520;
	// 82607FE8: 4BD57A89  bl 0x8235fa70
	ctx.lr = 0x82607FEC;
	sub_8235FA70(ctx, base);
	// 82607FEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82607FF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82607FF4: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82607FF8: 487EBC09  bl 0x82df3c00
	ctx.lr = 0x82607FFC;
	sub_82DF3C00(ctx, base);
	// 82607FFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608004: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82608008: 48854151  bl 0x82e5c158
	ctx.lr = 0x8260800C;
	sub_82E5C158(ctx, base);
	// 8260800C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608010: 487EB419  bl 0x82df3428
	ctx.lr = 0x82608014;
	sub_82DF3428(ctx, base);
	// 82608014: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82608018: 48BA01A4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82608020 size=2528
    let mut pc: u32 = 0x82608020;
    'dispatch: loop {
        match pc {
            0x82608020 => {
    //   block [0x82608020..0x82608A00)
	// 82608020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82608024: 48BA0131  bl 0x831a8154
	ctx.lr = 0x82608028;
	sub_831A8130(ctx, base);
	// 82608028: DBA1FF98  stfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[29].u64 ) };
	// 8260802C: DBC1FFA0  stfd f30, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 82608030: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82608034: 9421FD00  stwu r1, -0x300(r1)
	ea = ctx.r[1].u32.wrapping_add(-768 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82608038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8260803C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82608040: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82608044: 4BF09995  bl 0x825119d8
	ctx.lr = 0x82608048;
	sub_825119D8(ctx, base);
	// 82608048: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 8260804C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608050: 808BE250  lwz r4, -0x1db0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82608054: 487EB9B5  bl 0x82df3a08
	ctx.lr = 0x82608058;
	sub_82DF3A08(ctx, base);
	// 82608058: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8260805C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82608060: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82608064: 4BF0071D  bl 0x82508780
	ctx.lr = 0x82608068;
	sub_82508780(ctx, base);
	// 82608068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260806C: 487EB3BD  bl 0x82df3428
	ctx.lr = 0x82608070;
	sub_82DF3428(ctx, base);
	// 82608070: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82608074: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82608078: 409A0008  bne cr6, 0x82608080
	if !ctx.cr[6].eq {
	pc = 0x82608080; continue 'dispatch;
	}
	// 8260807C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82608080: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82608084: 4BF0071D  bl 0x825087a0
	ctx.lr = 0x82608088;
	sub_825087A0(ctx, base);
	// 82608088: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8260808C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608090: 48822A59  bl 0x82e2aae8
	ctx.lr = 0x82608094;
	sub_82E2AAE8(ctx, base);
	// 82608094: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260809C: 3B6B27A8  addi r27, r11, 0x27a8
	ctx.r[27].s64 = ctx.r[11].s64 + 10152;
	// 826080A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 826080A4: 487EB965  bl 0x82df3a08
	ctx.lr = 0x826080A8;
	sub_82DF3A08(ctx, base);
	// 826080A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826080AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826080B0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826080B4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 826080B8: 48826DB9  bl 0x82e2ee70
	ctx.lr = 0x826080BC;
	sub_82E2EE70(ctx, base);
	// 826080BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826080C0: 487EB369  bl 0x82df3428
	ctx.lr = 0x826080C4;
	sub_82DF3428(ctx, base);
	// 826080C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826080C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826080CC: 3B4B2AB0  addi r26, r11, 0x2ab0
	ctx.r[26].s64 = ctx.r[11].s64 + 10928;
	// 826080D0: 38A00051  li r5, 0x51
	ctx.r[5].s64 = 81;
	// 826080D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826080D8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 826080DC: 487EA30D  bl 0x82df23e8
	ctx.lr = 0x826080E0;
	sub_82DF23E8(ctx, base);
	// 826080E0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 826080E4: 41820014  beq 0x826080f8
	if ctx.cr[0].eq {
	pc = 0x826080F8; continue 'dispatch;
	}
	// 826080E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 826080EC: 4880E7A5  bl 0x82e16890
	ctx.lr = 0x826080F0;
	sub_82E16890(ctx, base);
	// 826080F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826080F4: 48000008  b 0x826080fc
	pc = 0x826080FC; continue 'dispatch;
	// 826080F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 826080FC: 3BBF0178  addi r29, r31, 0x178
	ctx.r[29].s64 = ctx.r[31].s64 + 376;
	// 82608100: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82608104: 4BD5526D  bl 0x8235d370
	ctx.lr = 0x82608108;
	sub_8235D370(ctx, base);
	// 82608108: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8260810C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608110: 38A00052  li r5, 0x52
	ctx.r[5].s64 = 82;
	// 82608114: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82608118: 487EA2D1  bl 0x82df23e8
	ctx.lr = 0x8260811C;
	sub_82DF23E8(ctx, base);
	// 8260811C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82608120: 3F208212  lis r25, -0x7dee
	ctx.r[25].s64 = -2112749568;
	// 82608124: 41820024  beq 0x82608148
	if ctx.cr[0].eq {
	pc = 0x82608148; continue 'dispatch;
	}
	// 82608128: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 8260812C: C039DFAC  lfs f1, -0x2054(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82608130: 488748B9  bl 0x82e7c9e8
	ctx.lr = 0x82608134;
	sub_82E7C9E8(ctx, base);
	// 82608134: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260813C: 4880AFB5  bl 0x82e130f0
	ctx.lr = 0x82608140;
	sub_82E130F0(ctx, base);
	// 82608140: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608144: 48000008  b 0x8260814c
	pc = 0x8260814C; continue 'dispatch;
	// 82608148: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8260814C: 3B9F0180  addi r28, r31, 0x180
	ctx.r[28].s64 = ctx.r[31].s64 + 384;
	// 82608150: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82608154: 4BCD9BFD  bl 0x822e1d50
	ctx.lr = 0x82608158;
	sub_822E1D50(ctx, base);
	// 82608158: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8260815C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82608160: 83DF0180  lwz r30, 0x180(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) } as u64;
	// 82608164: 4BF09FB5  bl 0x82512118
	ctx.lr = 0x82608168;
	sub_82512118(ctx, base);
	// 82608168: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260816C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608170: 4880ACC1  bl 0x82e12e30
	ctx.lr = 0x82608174;
	sub_82E12E30(ctx, base);
	// 82608174: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82608178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260817C: 419A0008  beq cr6, 0x82608184
	if ctx.cr[6].eq {
	pc = 0x82608184; continue 'dispatch;
	}
	// 82608180: 4BCB8711  bl 0x822c0890
	ctx.lr = 0x82608184;
	sub_822C0890(ctx, base);
	// 82608184: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82608188: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260818C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82608190: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82608194: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82608198: 419A0024  beq cr6, 0x826081bc
	if ctx.cr[6].eq {
	pc = 0x826081BC; continue 'dispatch;
	}
	// 8260819C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826081A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826081A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826081A8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826081AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826081B0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826081B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826081B8: 4082FFE8  bne 0x826081a0
	if !ctx.cr[0].eq {
	pc = 0x826081A0; continue 'dispatch;
	}
	// 826081BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826081C0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826081C4: 4880CEED  bl 0x82e150b0
	ctx.lr = 0x826081C8;
	sub_82E150B0(ctx, base);
	// 826081C8: 3F008335  lis r24, -0x7ccb
	ctx.r[24].s64 = -2093678592;
	// 826081CC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826081D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826081D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826081D8: 80987058  lwz r4, 0x7058(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826081DC: 4BF0897D  bl 0x82510b58
	ctx.lr = 0x826081E0;
	sub_82510B58(ctx, base);
	// 826081E0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 826081E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826081E8: 419A0008  beq cr6, 0x826081f0
	if ctx.cr[6].eq {
	pc = 0x826081F0; continue 'dispatch;
	}
	// 826081EC: 4BCB86A5  bl 0x822c0890
	ctx.lr = 0x826081F0;
	sub_822C0890(ctx, base);
	// 826081F0: 389B0018  addi r4, r27, 0x18
	ctx.r[4].s64 = ctx.r[27].s64 + 24;
	// 826081F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826081F8: 487EB811  bl 0x82df3a08
	ctx.lr = 0x826081FC;
	sub_82DF3A08(ctx, base);
	// 826081FC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608200: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82608204: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82608208: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 8260820C: 48826C65  bl 0x82e2ee70
	ctx.lr = 0x82608210;
	sub_82E2EE70(ctx, base);
	// 82608210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608214: 487EB215  bl 0x82df3428
	ctx.lr = 0x82608218;
	sub_82DF3428(ctx, base);
	// 82608218: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8260821C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608220: 38A00069  li r5, 0x69
	ctx.r[5].s64 = 105;
	// 82608224: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82608228: 487EA1C1  bl 0x82df23e8
	ctx.lr = 0x8260822C;
	sub_82DF23E8(ctx, base);
	// 8260822C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82608230: 41820014  beq 0x82608244
	if ctx.cr[0].eq {
	pc = 0x82608244; continue 'dispatch;
	}
	// 82608234: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82608238: 4880E659  bl 0x82e16890
	ctx.lr = 0x8260823C;
	sub_82E16890(ctx, base);
	// 8260823C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608240: 48000008  b 0x82608248
	pc = 0x82608248; continue 'dispatch;
	// 82608244: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82608248: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260824C: 4BD55125  bl 0x8235d370
	ctx.lr = 0x82608250;
	sub_8235D370(ctx, base);
	// 82608250: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82608254: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608258: 38A0006A  li r5, 0x6a
	ctx.r[5].s64 = 106;
	// 8260825C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82608260: 487EA189  bl 0x82df23e8
	ctx.lr = 0x82608264;
	sub_82DF23E8(ctx, base);
	// 82608264: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82608268: 41820018  beq 0x82608280
	if ctx.cr[0].eq {
	pc = 0x82608280; continue 'dispatch;
	}
	// 8260826C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82608270: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 82608274: 4880AE7D  bl 0x82e130f0
	ctx.lr = 0x82608278;
	sub_82E130F0(ctx, base);
	// 82608278: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260827C: 48000008  b 0x82608284
	pc = 0x82608284; continue 'dispatch;
	// 82608280: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82608284: 3BDF0188  addi r30, r31, 0x188
	ctx.r[30].s64 = ctx.r[31].s64 + 392;
	// 82608288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8260828C: 4BCD9AC5  bl 0x822e1d50
	ctx.lr = 0x82608290;
	sub_822E1D50(ctx, base);
	// 82608290: 809F0188  lwz r4, 0x188(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 82608294: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608298: 4880AB99  bl 0x82e12e30
	ctx.lr = 0x8260829C;
	sub_82E12E30(ctx, base);
	// 8260829C: 817F018C  lwz r11, 0x18c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) } as u64;
	// 826082A0: 815F0188  lwz r10, 0x188(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) } as u64;
	// 826082A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826082A8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826082AC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826082B0: 419A0024  beq cr6, 0x826082d4
	if ctx.cr[6].eq {
	pc = 0x826082D4; continue 'dispatch;
	}
	// 826082B4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 826082B8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826082BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826082C0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826082C4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826082C8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826082CC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826082D0: 4082FFE8  bne 0x826082b8
	if !ctx.cr[0].eq {
	pc = 0x826082B8; continue 'dispatch;
	}
	// 826082D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 826082D8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826082DC: 4880CDD5  bl 0x82e150b0
	ctx.lr = 0x826082E0;
	sub_82E150B0(ctx, base);
	// 826082E0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826082E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 826082E8: 80987058  lwz r4, 0x7058(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826082EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826082F0: 4BF08869  bl 0x82510b58
	ctx.lr = 0x826082F4;
	sub_82510B58(ctx, base);
	// 826082F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 826082F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826082FC: 38A00078  li r5, 0x78
	ctx.r[5].s64 = 120;
	// 82608300: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 82608304: 487EA0E5  bl 0x82df23e8
	ctx.lr = 0x82608308;
	sub_82DF23E8(ctx, base);
	// 82608308: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8260830C: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82608310: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82608314: 4182004C  beq 0x82608360
	if ctx.cr[0].eq {
	pc = 0x82608360; continue 'dispatch;
	}
	// 82608318: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 8260831C: C039DFAC  lfs f1, -0x2054(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-8276 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82608320: 488746C9  bl 0x82e7c9e8
	ctx.lr = 0x82608324;
	sub_82E7C9E8(ctx, base);
	// 82608324: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82608328: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 8260832C: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82608330: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82608334: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82608338: 48873CE1  bl 0x82e7c018
	ctx.lr = 0x8260833C;
	sub_82E7C018(ctx, base);
	// 8260833C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608340: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 82608344: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82608348: 4BCBC5B9  bl 0x822c4900
	ctx.lr = 0x8260834C;
	sub_822C4900(ctx, base);
	// 8260834C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82608354: 4880AD9D  bl 0x82e130f0
	ctx.lr = 0x82608358;
	sub_82E130F0(ctx, base);
	// 82608358: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260835C: 48000008  b 0x82608364
	pc = 0x82608364; continue 'dispatch;
	// 82608360: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82608364: 3BBF0190  addi r29, r31, 0x190
	ctx.r[29].s64 = ctx.r[31].s64 + 400;
	// 82608368: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8260836C: 4BCD99E5  bl 0x822e1d50
	ctx.lr = 0x82608370;
	sub_822E1D50(ctx, base);
	// 82608370: 809F0190  lwz r4, 0x190(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82608374: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608378: 4880AAB9  bl 0x82e12e30
	ctx.lr = 0x8260837C;
	sub_82E12E30(ctx, base);
	// 8260837C: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82608380: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608384: 419A0008  beq cr6, 0x8260838c
	if ctx.cr[6].eq {
	pc = 0x8260838C; continue 'dispatch;
	}
	// 82608388: 4BCB8509  bl 0x822c0890
	ctx.lr = 0x8260838C;
	sub_822C0890(ctx, base);
	// 8260838C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608390: 4BF0A709  bl 0x82512a98
	ctx.lr = 0x82608394;
	sub_82512A98(ctx, base);
	// 82608394: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608398: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 8260839C: 38A00027  li r5, 0x27
	ctx.r[5].s64 = 39;
	// 826083A0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 826083A4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 826083A8: 48898389  bl 0x82ea0730
	ctx.lr = 0x826083AC;
	sub_82EA0730(ctx, base);
	// 826083AC: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 826083B0: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 826083B4: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 826083B8: C02A7BC8  lfs f1, 0x7bc8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31688 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 826083BC: 48911E35  bl 0x82f1a1f0
	ctx.lr = 0x826083C0;
	sub_82F1A1F0(ctx, base);
	// 826083C0: 7C791B79  or. r25, r3, r3
	ctx.r[25].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 826083C4: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 826083C8: 4182000C  beq 0x826083d4
	if ctx.cr[0].eq {
	pc = 0x826083D4; continue 'dispatch;
	}
	// 826083CC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826083D0: 4BCDFE79  bl 0x822e8248
	ctx.lr = 0x826083D4;
	sub_822E8248(ctx, base);
	// 826083D4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826083D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826083DC: 388B2B58  addi r4, r11, 0x2b58
	ctx.r[4].s64 = ctx.r[11].s64 + 11096;
	// 826083E0: 487F1151  bl 0x82df9530
	ctx.lr = 0x826083E4;
	sub_82DF9530(ctx, base);
	// 826083E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 826083E8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 826083EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 826083F0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 826083F4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 826083F8: 419A0024  beq cr6, 0x8260841c
	if ctx.cr[6].eq {
	pc = 0x8260841C; continue 'dispatch;
	}
	// 826083FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82608400: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82608404: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82608408: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8260840C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82608410: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82608414: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82608418: 4082FFE8  bne 0x82608400
	if !ctx.cr[0].eq {
	pc = 0x82608400; continue 'dispatch;
	}
	// 8260841C: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82608420: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82608424: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82608428: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260842C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608430: 80CB6894  lwz r6, 0x6894(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26772 as u32) ) } as u64;
	// 82608434: 4BF0ACC5  bl 0x825130f8
	ctx.lr = 0x82608438;
	sub_825130F8(ctx, base);
	// 82608438: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8260843C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608440: 419A0008  beq cr6, 0x82608448
	if ctx.cr[6].eq {
	pc = 0x82608448; continue 'dispatch;
	}
	// 82608444: 4BCDFE25  bl 0x822e8268
	ctx.lr = 0x82608448;
	sub_822E8268(ctx, base);
	// 82608448: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8260844C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608450: 38A00083  li r5, 0x83
	ctx.r[5].s64 = 131;
	// 82608454: 38600220  li r3, 0x220
	ctx.r[3].s64 = 544;
	// 82608458: 487E9F91  bl 0x82df23e8
	ctx.lr = 0x8260845C;
	sub_82DF23E8(ctx, base);
	// 8260845C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82608460: 41820014  beq 0x82608474
	if ctx.cr[0].eq {
	pc = 0x82608474; continue 'dispatch;
	}
	// 82608464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82608468: 4BFFE139  bl 0x826065a0
	ctx.lr = 0x8260846C;
	sub_826065A0(ctx, base);
	// 8260846C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608470: 48000008  b 0x82608478
	pc = 0x82608478; continue 'dispatch;
	// 82608474: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82608478: 387F0148  addi r3, r31, 0x148
	ctx.r[3].s64 = ctx.r[31].s64 + 328;
	// 8260847C: 4BFFEFC5  bl 0x82607440
	ctx.lr = 0x82608480;
	sub_82607440(ctx, base);
	// 82608480: 817F014C  lwz r11, 0x14c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82608484: 815F0148  lwz r10, 0x148(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(328 as u32) ) } as u64;
	// 82608488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8260848C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82608490: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82608494: 419A0024  beq cr6, 0x826084b8
	if ctx.cr[6].eq {
	pc = 0x826084B8; continue 'dispatch;
	}
	// 82608498: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8260849C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 826084A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826084A4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 826084A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 826084AC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 826084B0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 826084B4: 4082FFE8  bne 0x8260849c
	if !ctx.cr[0].eq {
	pc = 0x8260849C; continue 'dispatch;
	}
	// 826084B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 826084BC: 80987058  lwz r4, 0x7058(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28760 as u32) ) } as u64;
	// 826084C0: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 826084C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826084C8: 4BF08531  bl 0x825109f8
	ctx.lr = 0x826084CC;
	sub_825109F8(ctx, base);
	// 826084CC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 826084D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826084D4: 419A0008  beq cr6, 0x826084dc
	if ctx.cr[6].eq {
	pc = 0x826084DC; continue 'dispatch;
	}
	// 826084D8: 4BCB83B9  bl 0x822c0890
	ctx.lr = 0x826084DC;
	sub_822C0890(ctx, base);
	// 826084DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826084E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826084E4: 388B1F90  addi r4, r11, 0x1f90
	ctx.r[4].s64 = ctx.r[11].s64 + 8080;
	// 826084E8: 487EB521  bl 0x82df3a08
	ctx.lr = 0x826084EC;
	sub_82DF3A08(ctx, base);
	// 826084EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826084F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826084F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826084F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 826084FC: 48823755  bl 0x82e2bc50
	ctx.lr = 0x82608500;
	sub_82E2BC50(ctx, base);
	// 82608500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608504: 487EAF25  bl 0x82df3428
	ctx.lr = 0x82608508;
	sub_82DF3428(ctx, base);
	// 82608508: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 8260850C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82608510: 419A00CC  beq cr6, 0x826085dc
	if ctx.cr[6].eq {
	pc = 0x826085DC; continue 'dispatch;
	}
	// 82608514: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82608518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260851C: 388ACE10  addi r4, r10, -0x31f0
	ctx.r[4].s64 = ctx.r[10].s64 + -12784;
	// 82608520: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82608524: 487F100D  bl 0x82df9530
	ctx.lr = 0x82608528;
	sub_82DF9530(ctx, base);
	// 82608528: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8260852C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82608530: 3BCBD28C  addi r30, r11, -0x2d74
	ctx.r[30].s64 = ctx.r[11].s64 + -11636;
	// 82608534: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82608538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260853C: 487F0FF5  bl 0x82df9530
	ctx.lr = 0x82608540;
	sub_82DF9530(ctx, base);
	// 82608540: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82608544: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82608548: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260854C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82608550: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 82608554: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608558: 4880FB71  bl 0x82e180c8
	ctx.lr = 0x8260855C;
	sub_82E180C8(ctx, base);
	// 8260855C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82608560: 395F0160  addi r10, r31, 0x160
	ctx.r[10].s64 = ctx.r[31].s64 + 352;
	// 82608564: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82608568: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 8260856C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608570: 917F0160  stw r11, 0x160(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 82608574: 4BCBBEED  bl 0x822c4460
	ctx.lr = 0x82608578;
	sub_822C4460(ctx, base);
	// 82608578: 806100CC  lwz r3, 0xcc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 8260857C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608580: 419A0008  beq cr6, 0x82608588
	if ctx.cr[6].eq {
	pc = 0x82608588; continue 'dispatch;
	}
	// 82608584: 4BCB830D  bl 0x822c0890
	ctx.lr = 0x82608588;
	sub_822C0890(ctx, base);
	// 82608588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8260858C: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82608590: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82608594: 487F0F9D  bl 0x82df9530
	ctx.lr = 0x82608598;
	sub_82DF9530(ctx, base);
	// 82608598: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260859C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826085A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826085A4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 826085A8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826085AC: 4880FA1D  bl 0x82e17fc8
	ctx.lr = 0x826085B0;
	sub_82E17FC8(ctx, base);
	// 826085B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 826085B4: 395F0168  addi r10, r31, 0x168
	ctx.r[10].s64 = ctx.r[31].s64 + 360;
	// 826085B8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 826085BC: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 826085C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 826085C4: 917F0168  stw r11, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 826085C8: 4BCBBE99  bl 0x822c4460
	ctx.lr = 0x826085CC;
	sub_822C4460(ctx, base);
	// 826085CC: 806100C4  lwz r3, 0xc4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 826085D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826085D4: 419A0008  beq cr6, 0x826085dc
	if ctx.cr[6].eq {
	pc = 0x826085DC; continue 'dispatch;
	}
	// 826085D8: 4BCB82B9  bl 0x822c0890
	ctx.lr = 0x826085DC;
	sub_822C0890(ctx, base);
	// 826085DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826085E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826085E4: 388B1F9C  addi r4, r11, 0x1f9c
	ctx.r[4].s64 = ctx.r[11].s64 + 8092;
	// 826085E8: 487EB421  bl 0x82df3a08
	ctx.lr = 0x826085EC;
	sub_82DF3A08(ctx, base);
	// 826085EC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826085F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 826085F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 826085F8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 826085FC: 488235E5  bl 0x82e2bbe0
	ctx.lr = 0x82608600;
	sub_82E2BBE0(ctx, base);
	// 82608600: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82608604: 395F0150  addi r10, r31, 0x150
	ctx.r[10].s64 = ctx.r[31].s64 + 336;
	// 82608608: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8260860C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82608610: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608614: 917F0150  stw r11, 0x150(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82608618: 4BCBBE49  bl 0x822c4460
	ctx.lr = 0x8260861C;
	sub_822C4460(ctx, base);
	// 8260861C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82608620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608624: 419A0008  beq cr6, 0x8260862c
	if ctx.cr[6].eq {
	pc = 0x8260862C; continue 'dispatch;
	}
	// 82608628: 4BCB8269  bl 0x822c0890
	ctx.lr = 0x8260862C;
	sub_822C0890(ctx, base);
	// 8260862C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608630: 487EADF9  bl 0x82df3428
	ctx.lr = 0x82608634;
	sub_82DF3428(ctx, base);
	// 82608634: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260863C: 388B1FB4  addi r4, r11, 0x1fb4
	ctx.r[4].s64 = ctx.r[11].s64 + 8116;
	// 82608640: 487EB3C9  bl 0x82df3a08
	ctx.lr = 0x82608644;
	sub_82DF3A08(ctx, base);
	// 82608644: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608648: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8260864C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82608650: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82608654: 4882358D  bl 0x82e2bbe0
	ctx.lr = 0x82608658;
	sub_82E2BBE0(ctx, base);
	// 82608658: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8260865C: 395F0158  addi r10, r31, 0x158
	ctx.r[10].s64 = ctx.r[31].s64 + 344;
	// 82608660: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82608664: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 82608668: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8260866C: 917F0158  stw r11, 0x158(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82608670: 4BCBBDF1  bl 0x822c4460
	ctx.lr = 0x82608674;
	sub_822C4460(ctx, base);
	// 82608674: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82608678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8260867C: 419A0008  beq cr6, 0x82608684
	if ctx.cr[6].eq {
	pc = 0x82608684; continue 'dispatch;
	}
	// 82608680: 4BCB8211  bl 0x822c0890
	ctx.lr = 0x82608684;
	sub_822C0890(ctx, base);
	// 82608684: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608688: 487EADA1  bl 0x82df3428
	ctx.lr = 0x8260868C;
	sub_82DF3428(ctx, base);
	// 8260868C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608690: 4BFFEA71  bl 0x82607100
	ctx.lr = 0x82608694;
	sub_82607100(ctx, base);
	// 82608694: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82608698: 3BDF00E8  addi r30, r31, 0xe8
	ctx.r[30].s64 = ctx.r[31].s64 + 232;
	// 8260869C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 826086A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826086A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 826086A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 826086AC: 4E800421  bctrl
	ctx.lr = 0x826086B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 826086B0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826086B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826086B8: 3BAB2B50  addi r29, r11, 0x2b50
	ctx.r[29].s64 = ctx.r[11].s64 + 11088;
	// 826086BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 826086C0: 487EB349  bl 0x82df3a08
	ctx.lr = 0x826086C4;
	sub_82DF3A08(ctx, base);
	// 826086C4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826086C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826086CC: 4BFFF775  bl 0x82607e40
	ctx.lr = 0x826086D0;
	sub_82607E40(ctx, base);
	// 826086D0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 826086D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826086D8: 3B8BCFB0  addi r28, r11, -0x3050
	ctx.r[28].s64 = ctx.r[11].s64 + -12368;
	// 826086DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826086E0: 487EB329  bl 0x82df3a08
	ctx.lr = 0x826086E4;
	sub_82DF3A08(ctx, base);
	// 826086E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 826086E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826086EC: 4BFFF7B5  bl 0x82607ea0
	ctx.lr = 0x826086F0;
	sub_82607EA0(ctx, base);
	// 826086F0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826086F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826086F8: 388B2B08  addi r4, r11, 0x2b08
	ctx.r[4].s64 = ctx.r[11].s64 + 11016;
	// 826086FC: 487EB30D  bl 0x82df3a08
	ctx.lr = 0x82608700;
	sub_82DF3A08(ctx, base);
	// 82608700: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608708: 4BFFF7F9  bl 0x82607f00
	ctx.lr = 0x8260870C;
	sub_82607F00(ctx, base);
	// 8260870C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82608710: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82608714: 388B4418  addi r4, r11, 0x4418
	ctx.r[4].s64 = ctx.r[11].s64 + 17432;
	// 82608718: 487EB2F1  bl 0x82df3a08
	ctx.lr = 0x8260871C;
	sub_82DF3A08(ctx, base);
	// 8260871C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608724: 4BFFF83D  bl 0x82607f60
	ctx.lr = 0x82608728;
	sub_82607F60(ctx, base);
	// 82608728: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8260872C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82608730: 388B2B0C  addi r4, r11, 0x2b0c
	ctx.r[4].s64 = ctx.r[11].s64 + 11020;
	// 82608734: 487EB2D5  bl 0x82df3a08
	ctx.lr = 0x82608738;
	sub_82DF3A08(ctx, base);
	// 82608738: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8260873C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608740: 4BFFF881  bl 0x82607fc0
	ctx.lr = 0x82608744;
	sub_82607FC0(ctx, base);
	// 82608744: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82608748: 3B6B02A4  addi r27, r11, 0x2a4
	ctx.r[27].s64 = ctx.r[11].s64 + 676;
	// 8260874C: 897F01C4  lbz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82608750: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82608754: 4182006C  beq 0x826087c0
	if ctx.cr[0].eq {
	pc = 0x826087C0; continue 'dispatch;
	}
	// 82608758: 897F01C5  lbz r11, 0x1c5(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(453 as u32) ) } as u64;
	// 8260875C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82608760: 40820060  bne 0x826087c0
	if !ctx.cr[0].eq {
	pc = 0x826087C0; continue 'dispatch;
	}
	// 82608764: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82608768: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8260876C: 487EB29D  bl 0x82df3a08
	ctx.lr = 0x82608770;
	sub_82DF3A08(ctx, base);
	// 82608770: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82608774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82608778: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8260877C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 82608780: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82608784: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82608788: 488561D9  bl 0x82e5e960
	ctx.lr = 0x8260878C;
	sub_82E5E960(ctx, base);
	// 8260878C: 806100AC  lwz r3, 0xac(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82608790: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608794: 419A0008  beq cr6, 0x8260879c
	if ctx.cr[6].eq {
	pc = 0x8260879C; continue 'dispatch;
	}
	// 82608798: 4BCB80F9  bl 0x822c0890
	ctx.lr = 0x8260879C;
	sub_822C0890(ctx, base);
	// 8260879C: C1BF01B4  lfs f13, 0x1b4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 826087A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826087A4: C01B000C  lfs f0, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 826087A8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 826087AC: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 826087B0: 4BFFE951  bl 0x82607100
	ctx.lr = 0x826087B4;
	sub_82607100(ctx, base);
	// 826087B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 826087B8: 997F01C6  stb r11, 0x1c6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(454 as u32), ctx.r[11].u8 ) };
	// 826087BC: 4800003C  b 0x826087f8
	pc = 0x826087F8; continue 'dispatch;
	// 826087C0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 826087C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 826087C8: 487EB241  bl 0x82df3a08
	ctx.lr = 0x826087CC;
	sub_82DF3A08(ctx, base);
	// 826087CC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826087D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 826087D4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826087D8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 826087DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 826087E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 826087E4: 4885617D  bl 0x82e5e960
	ctx.lr = 0x826087E8;
	sub_82E5E960(ctx, base);
	// 826087E8: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 826087EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826087F0: 419A0008  beq cr6, 0x826087f8
	if ctx.cr[6].eq {
	pc = 0x826087F8; continue 'dispatch;
	}
	// 826087F4: 4BCB809D  bl 0x822c0890
	ctx.lr = 0x826087F8;
	sub_822C0890(ctx, base);
	// 826087F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826087FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608800: 388B2B44  addi r4, r11, 0x2b44
	ctx.r[4].s64 = ctx.r[11].s64 + 11076;
	// 82608804: 487EB205  bl 0x82df3a08
	ctx.lr = 0x82608808;
	sub_82DF3A08(ctx, base);
	// 82608808: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8260880C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82608810: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82608814: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82608818: 4BF01CC9  bl 0x8250a4e0
	ctx.lr = 0x8260881C;
	sub_8250A4E0(ctx, base);
	// 8260881C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82608820: 3BFF01A4  addi r31, r31, 0x1a4
	ctx.r[31].s64 = ctx.r[31].s64 + 420;
	// 82608824: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82608828: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8260882C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608830: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82608834: 4BCBBC2D  bl 0x822c4460
	ctx.lr = 0x82608838;
	sub_822C4460(ctx, base);
	// 82608838: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 8260883C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608840: 419A0008  beq cr6, 0x82608848
	if ctx.cr[6].eq {
	pc = 0x82608848; continue 'dispatch;
	}
	// 82608844: 4BCB804D  bl 0x822c0890
	ctx.lr = 0x82608848;
	sub_822C0890(ctx, base);
	// 82608848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260884C: 487EABDD  bl 0x82df3428
	ctx.lr = 0x82608850;
	sub_82DF3428(ctx, base);
	// 82608850: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82608858: 419A016C  beq cr6, 0x826089c4
	if ctx.cr[6].eq {
	pc = 0x826089C4; continue 'dispatch;
	}
	// 8260885C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608864: 388B2B34  addi r4, r11, 0x2b34
	ctx.r[4].s64 = ctx.r[11].s64 + 11060;
	// 82608868: 487EB1A1  bl 0x82df3a08
	ctx.lr = 0x8260886C;
	sub_82DF3A08(ctx, base);
	// 8260886C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82608870: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82608874: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82608878: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8260887C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82608880: C3CB9528  lfs f30, -0x6ad8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27352 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82608884: C04AD0F8  lfs f2, -0x2f08(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12040 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82608888: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8260888C: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608890: 4BF9A921  bl 0x825a31b0
	ctx.lr = 0x82608894;
	sub_825A31B0(ctx, base);
	// 82608894: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82608898: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8260889C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 826088A0: 4BF9A3D9  bl 0x825a2c78
	ctx.lr = 0x826088A4;
	sub_825A2C78(ctx, base);
	// 826088A4: 38610108  addi r3, r1, 0x108
	ctx.r[3].s64 = ctx.r[1].s64 + 264;
	// 826088A8: 487EAB81  bl 0x82df3428
	ctx.lr = 0x826088AC;
	sub_82DF3428(ctx, base);
	// 826088AC: 386100E8  addi r3, r1, 0xe8
	ctx.r[3].s64 = ctx.r[1].s64 + 232;
	// 826088B0: 4BCC0409  bl 0x822c8cb8
	ctx.lr = 0x826088B4;
	sub_822C8CB8(ctx, base);
	// 826088B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826088B8: 487EAB71  bl 0x82df3428
	ctx.lr = 0x826088BC;
	sub_82DF3428(ctx, base);
	// 826088BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826088C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826088C4: 388BF614  addi r4, r11, -0x9ec
	ctx.r[4].s64 = ctx.r[11].s64 + -2540;
	// 826088C8: 487EB141  bl 0x82df3a08
	ctx.lr = 0x826088CC;
	sub_82DF3A08(ctx, base);
	// 826088CC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 826088D0: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 826088D4: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 826088D8: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 826088DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 826088E0: 388A7F00  addi r4, r10, 0x7f00
	ctx.r[4].s64 = ctx.r[10].s64 + 32512;
	// 826088E4: C3ABDD6C  lfs f29, -0x2294(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8852 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 826088E8: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 826088EC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 826088F0: 4BF9A8C1  bl 0x825a31b0
	ctx.lr = 0x826088F4;
	sub_825A31B0(ctx, base);
	// 826088F4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826088F8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826088FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608900: 4BF9A379  bl 0x825a2c78
	ctx.lr = 0x82608904;
	sub_825A2C78(ctx, base);
	// 82608904: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 82608908: 487EAB21  bl 0x82df3428
	ctx.lr = 0x8260890C;
	sub_82DF3428(ctx, base);
	// 8260890C: 386101A8  addi r3, r1, 0x1a8
	ctx.r[3].s64 = ctx.r[1].s64 + 424;
	// 82608910: 4BCC03A9  bl 0x822c8cb8
	ctx.lr = 0x82608914;
	sub_822C8CB8(ctx, base);
	// 82608914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608918: 487EAB11  bl 0x82df3428
	ctx.lr = 0x8260891C;
	sub_82DF3428(ctx, base);
	// 8260891C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608924: 388B2B24  addi r4, r11, 0x2b24
	ctx.r[4].s64 = ctx.r[11].s64 + 11044;
	// 82608928: 487EB0E1  bl 0x82df3a08
	ctx.lr = 0x8260892C;
	sub_82DF3A08(ctx, base);
	// 8260892C: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82608930: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82608934: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82608938: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8260893C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82608940: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608944: 4BF9A86D  bl 0x825a31b0
	ctx.lr = 0x82608948;
	sub_825A31B0(ctx, base);
	// 82608948: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8260894C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82608950: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608954: 4BF9A325  bl 0x825a2c78
	ctx.lr = 0x82608958;
	sub_825A2C78(ctx, base);
	// 82608958: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 8260895C: 487EAACD  bl 0x82df3428
	ctx.lr = 0x82608960;
	sub_82DF3428(ctx, base);
	// 82608960: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 82608964: 4BCC0355  bl 0x822c8cb8
	ctx.lr = 0x82608968;
	sub_822C8CB8(ctx, base);
	// 82608968: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8260896C: 487EAABD  bl 0x82df3428
	ctx.lr = 0x82608970;
	sub_82DF3428(ctx, base);
	// 82608970: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608978: 388B2B18  addi r4, r11, 0x2b18
	ctx.r[4].s64 = ctx.r[11].s64 + 11032;
	// 8260897C: 487EB08D  bl 0x82df3a08
	ctx.lr = 0x82608980;
	sub_82DF3A08(ctx, base);
	// 82608980: 389B0008  addi r4, r27, 8
	ctx.r[4].s64 = ctx.r[27].s64 + 8;
	// 82608984: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82608988: FC60F090  fmr f3, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8260898C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82608990: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82608994: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608998: 4BF9A819  bl 0x825a31b0
	ctx.lr = 0x8260899C;
	sub_825A31B0(ctx, base);
	// 8260899C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 826089A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 826089A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 826089A8: 4BF9A2D1  bl 0x825a2c78
	ctx.lr = 0x826089AC;
	sub_825A2C78(ctx, base);
	// 826089AC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 826089B0: 487EAA79  bl 0x82df3428
	ctx.lr = 0x826089B4;
	sub_82DF3428(ctx, base);
	// 826089B4: 38610128  addi r3, r1, 0x128
	ctx.r[3].s64 = ctx.r[1].s64 + 296;
	// 826089B8: 4BCC0301  bl 0x822c8cb8
	ctx.lr = 0x826089BC;
	sub_822C8CB8(ctx, base);
	// 826089BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 826089C0: 487EAA69  bl 0x82df3428
	ctx.lr = 0x826089C4;
	sub_82DF3428(ctx, base);
	// 826089C4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 826089C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 826089CC: 419A0008  beq cr6, 0x826089d4
	if ctx.cr[6].eq {
	pc = 0x826089D4; continue 'dispatch;
	}
	// 826089D0: 4BCB7EC1  bl 0x822c0890
	ctx.lr = 0x826089D4;
	sub_822C0890(ctx, base);
	// 826089D4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 826089D8: 419A000C  beq cr6, 0x826089e4
	if ctx.cr[6].eq {
	pc = 0x826089E4; continue 'dispatch;
	}
	// 826089DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 826089E0: 4BCDF889  bl 0x822e8268
	ctx.lr = 0x826089E4;
	sub_822E8268(ctx, base);
	// 826089E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 826089E8: 48822119  bl 0x82e2ab00
	ctx.lr = 0x826089EC;
	sub_82E2AB00(ctx, base);
	// 826089EC: 38210300  addi r1, r1, 0x300
	ctx.r[1].s64 = ctx.r[1].s64 + 768;
	// 826089F0: CBA1FF98  lfd f29, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 826089F4: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 826089F8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 826089FC: 48B9F7A8  b 0x831a81a4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82608A00 size=96
    let mut pc: u32 = 0x82608A00;
    'dispatch: loop {
        match pc {
            0x82608A00 => {
    //   block [0x82608A00..0x82608A60)
	// 82608A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82608A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82608A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82608A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82608A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82608A14: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82608A1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82608A20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608A24: 388B2B60  addi r4, r11, 0x2b60
	ctx.r[4].s64 = ctx.r[11].s64 + 11104;
	// 82608A28: 487EAFE1  bl 0x82df3a08
	ctx.lr = 0x82608A2C;
	sub_82DF3A08(ctx, base);
	// 82608A2C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82608A30: 38BF01C5  addi r5, r31, 0x1c5
	ctx.r[5].s64 = ctx.r[31].s64 + 453;
	// 82608A34: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82608A38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82608A3C: 4BFEF64D  bl 0x825f8088
	ctx.lr = 0x82608A40;
	sub_825F8088(ctx, base);
	// 82608A40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82608A44: 487EA9E5  bl 0x82df3428
	ctx.lr = 0x82608A48;
	sub_82DF3428(ctx, base);
	// 82608A48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82608A4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82608A50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82608A54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82608A58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82608A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82608A60 size=80
    let mut pc: u32 = 0x82608A60;
    'dispatch: loop {
        match pc {
            0x82608A60 => {
    //   block [0x82608A60..0x82608AB0)
	// 82608A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82608A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82608A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82608A6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82608A70: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82608A74: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82608A78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82608A7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82608A80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608A84: 4BEAC755  bl 0x824b51d8
	ctx.lr = 0x82608A88;
	sub_824B51D8(ctx, base);
	// 82608A88: 39600006  li r11, 6
	ctx.r[11].s64 = 6;
	// 82608A8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82608A90: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82608A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608A98: 4BEAC741  bl 0x824b51d8
	ctx.lr = 0x82608A9C;
	sub_824B51D8(ctx, base);
	// 82608A9C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82608AA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82608AA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82608AA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82608AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82608AB0 size=220
    let mut pc: u32 = 0x82608AB0;
    'dispatch: loop {
        match pc {
            0x82608AB0 => {
    //   block [0x82608AB0..0x82608B8C)
	// 82608AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82608AB4: 48B9F6B5  bl 0x831a8168
	ctx.lr = 0x82608AB8;
	sub_831A8130(ctx, base);
	// 82608AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82608ABC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82608AC0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82608AC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82608AC8: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82608ACC: 41820034  beq 0x82608b00
	if ctx.cr[0].eq {
	pc = 0x82608B00; continue 'dispatch;
	}
	// 82608AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608AD4: 48BA0EB5  bl 0x831a9988
	ctx.lr = 0x82608AD8;
	sub_831A9988(ctx, base);
	// 82608AD8: 3D608329  lis r11, -0x7cd7
	ctx.r[11].s64 = -2094465024;
	// 82608ADC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608AE0: 386BD9D8  addi r3, r11, -0x2628
	ctx.r[3].s64 = ctx.r[11].s64 + -9768;
	// 82608AE4: 48B9F615  bl 0x831a80f8
	ctx.lr = 0x82608AE8;
	sub_831A80F8(ctx, base);
	// 82608AE8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82608AEC: 41820014  beq 0x82608b00
	if ctx.cr[0].eq {
	pc = 0x82608B00; continue 'dispatch;
	}
	// 82608AF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82608AF4: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82608AF8: 4BFFD2B9  bl 0x82605db0
	ctx.lr = 0x82608AFC;
	sub_82605DB0(ctx, base);
	// 82608AFC: 48000088  b 0x82608b84
	pc = 0x82608B84; continue 'dispatch;
	// 82608B00: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82608B04: 419A0070  beq cr6, 0x82608b74
	if ctx.cr[6].eq {
	pc = 0x82608B74; continue 'dispatch;
	}
	// 82608B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608B0C: 48BA0E7D  bl 0x831a9988
	ctx.lr = 0x82608B10;
	sub_831A9988(ctx, base);
	// 82608B10: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82608B14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608B18: 386BCAE8  addi r3, r11, -0x3518
	ctx.r[3].s64 = ctx.r[11].s64 + -13592;
	// 82608B1C: 48B9F5DD  bl 0x831a80f8
	ctx.lr = 0x82608B20;
	sub_831A80F8(ctx, base);
	// 82608B20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82608B24: 41820014  beq 0x82608b38
	if ctx.cr[0].eq {
	pc = 0x82608B38; continue 'dispatch;
	}
	// 82608B28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82608B2C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82608B30: 4BFFD2A9  bl 0x82605dd8
	ctx.lr = 0x82608B34;
	sub_82605DD8(ctx, base);
	// 82608B34: 48000050  b 0x82608b84
	pc = 0x82608B84; continue 'dispatch;
	// 82608B38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82608B3C: 419A0038  beq cr6, 0x82608b74
	if ctx.cr[6].eq {
	pc = 0x82608B74; continue 'dispatch;
	}
	// 82608B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608B44: 48BA0E45  bl 0x831a9988
	ctx.lr = 0x82608B48;
	sub_831A9988(ctx, base);
	// 82608B48: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82608B4C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82608B50: 386B6C0C  addi r3, r11, 0x6c0c
	ctx.r[3].s64 = ctx.r[11].s64 + 27660;
	// 82608B54: 48B9F5A5  bl 0x831a80f8
	ctx.lr = 0x82608B58;
	sub_831A80F8(ctx, base);
	// 82608B58: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82608B5C: 41820018  beq 0x82608b74
	if ctx.cr[0].eq {
	pc = 0x82608B74; continue 'dispatch;
	}
	// 82608B60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82608B64: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82608B68: 480D2AC9  bl 0x826db630
	ctx.lr = 0x82608B6C;
	sub_826DB630(ctx, base);
	// 82608B6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82608B70: 48000014  b 0x82608b84
	pc = 0x82608B84; continue 'dispatch;
	// 82608B74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82608B78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82608B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82608B80: 4BF09A99  bl 0x82512618
	ctx.lr = 0x82608B84;
	sub_82512618(ctx, base);
	// 82608B84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82608B88: 48B9F630  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608B90 size=44
    let mut pc: u32 = 0x82608B90;
    'dispatch: loop {
        match pc {
            0x82608B90 => {
    //   block [0x82608B90..0x82608BBC)
	// 82608B90: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82608B94: 41980050  blt cr6, 0x82608be4
	if ctx.cr[6].lt {
		sub_82608BE4(ctx, base);
		return;
	}
	// 82608B98: 419A0044  beq cr6, 0x82608bdc
	if ctx.cr[6].eq {
		sub_82608BDC(ctx, base);
		return;
	}
	// 82608B9C: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 82608BA0: 41980034  blt cr6, 0x82608bd4
	if ctx.cr[6].lt {
		sub_82608BD4(ctx, base);
		return;
	}
	// 82608BA4: 419A0028  beq cr6, 0x82608bcc
	if ctx.cr[6].eq {
		sub_82608BCC(ctx, base);
		return;
	}
	// 82608BA8: 2B030005  cmplwi cr6, r3, 5
	ctx.cr[6].compare_u32(ctx.r[3].u32, 5 as u32, &mut ctx.xer);
	// 82608BAC: 41980018  blt cr6, 0x82608bc4
	if ctx.cr[6].lt {
		sub_82608BC4(ctx, base);
		return;
	}
	// 82608BB0: 419A000C  beq cr6, 0x82608bbc
	if ctx.cr[6].eq {
		sub_82608BBC(ctx, base);
		return;
	}
	// 82608BB4: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 82608BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BBC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608BBC size=8
    let mut pc: u32 = 0x82608BBC;
    'dispatch: loop {
        match pc {
            0x82608BBC => {
    //   block [0x82608BBC..0x82608BC4)
	// 82608BBC: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 82608BC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BC4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608BC4 size=8
    let mut pc: u32 = 0x82608BC4;
    'dispatch: loop {
        match pc {
            0x82608BC4 => {
    //   block [0x82608BC4..0x82608BCC)
	// 82608BC4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82608BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BCC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608BCC size=8
    let mut pc: u32 = 0x82608BCC;
    'dispatch: loop {
        match pc {
            0x82608BCC => {
    //   block [0x82608BCC..0x82608BD4)
	// 82608BCC: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82608BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608BD4 size=8
    let mut pc: u32 = 0x82608BD4;
    'dispatch: loop {
        match pc {
            0x82608BD4 => {
    //   block [0x82608BD4..0x82608BDC)
	// 82608BD4: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82608BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BDC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608BDC size=8
    let mut pc: u32 = 0x82608BDC;
    'dispatch: loop {
        match pc {
            0x82608BDC => {
    //   block [0x82608BDC..0x82608BE4)
	// 82608BDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82608BE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BE4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82608BE4 size=8
    let mut pc: u32 = 0x82608BE4;
    'dispatch: loop {
        match pc {
            0x82608BE4 => {
    //   block [0x82608BE4..0x82608BEC)
	// 82608BE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82608BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82608BF0 size=20
    let mut pc: u32 = 0x82608BF0;
    'dispatch: loop {
        match pc {
            0x82608BF0 => {
    //   block [0x82608BF0..0x82608C04)
	// 82608BF0: 81630130  lwz r11, 0x130(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) } as u64;
	// 82608BF4: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82608BF8: C0030134  lfs f0, 0x134(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82608BFC: D004001C  stfs f0, 0x1c(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82608C00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82608C08 size=88
    let mut pc: u32 = 0x82608C08;
    'dispatch: loop {
        match pc {
            0x82608C08 => {
    //   block [0x82608C08..0x82608C60)
	// 82608C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82608C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82608C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82608C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82608C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82608C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82608C20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82608C24: 4BF084CD  bl 0x825110f0
	ctx.lr = 0x82608C28;
	sub_825110F0(ctx, base);
	// 82608C28: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82608C2C: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82608C30: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82608C34: 396B2C60  addi r11, r11, 0x2c60
	ctx.r[11].s64 = ctx.r[11].s64 + 11360;
	// 82608C38: 394A2C4C  addi r10, r10, 0x2c4c
	ctx.r[10].s64 = ctx.r[10].s64 + 11340;
	// 82608C3C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82608C40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82608C44: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82608C48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82608C4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82608C50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82608C54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82608C58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82608C5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82608C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82608C60 size=120
    let mut pc: u32 = 0x82608C60;
    'dispatch: loop {
        match pc {
            0x82608C60 => {
    //   block [0x82608C60..0x82608CD8)
	// 82608C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82608C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82608C68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82608C6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82608C70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82608C74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82608C78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82608C7C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82608C80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82608C84: 419A001C  beq cr6, 0x82608ca0
	if ctx.cr[6].eq {
	pc = 0x82608CA0; continue 'dispatch;
	}
	// 82608C88: 485ABB91  bl 0x82bb4818
	ctx.lr = 0x82608C8C;
	sub_82BB4818(ctx, base);
	// 82608C8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82608C90: 41820010  beq 0x82608ca0
	if ctx.cr[0].eq {
	pc = 0x82608CA0; continue 'dispatch;
	}
	// 82608C94: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82608C98: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82608C9C: 485AC855  bl 0x82bb54f0
	ctx.lr = 0x82608CA0;
	sub_82BB54F0(ctx, base);
	// 82608CA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82608CA4: C01F0128  lfs f0, 0x128(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82608CA8: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82608CAC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82608CB0: 40990010  ble cr6, 0x82608cc0
	if !ctx.cr[6].gt {
	pc = 0x82608CC0; continue 'dispatch;
	}
	// 82608CB4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82608CB8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82608CBC: D01F0128  stfs f0, 0x128(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82608CC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82608CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82608CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82608CCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82608CD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82608CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


