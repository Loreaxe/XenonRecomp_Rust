pub fn sub_82838BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838BC0 size=428
    let mut pc: u32 = 0x82838BC0;
    'dispatch: loop {
        match pc {
            0x82838BC0 => {
    //   block [0x82838BC0..0x82838D6C)
	// 82838BC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82838BC4: 4896F5A5  bl 0x831a8168
	ctx.lr = 0x82838BC8;
	sub_831A8130(ctx, base);
	// 82838BC8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838BCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838BD0: 3D408284  lis r10, -0x7d7c
	ctx.r[10].s64 = -2105278464;
	// 82838BD4: 3D208283  lis r9, -0x7d7d
	ctx.r[9].s64 = -2105344000;
	// 82838BD8: 394A8A78  addi r10, r10, -0x7588
	ctx.r[10].s64 = ctx.r[10].s64 + -30088;
	// 82838BDC: 3D00822C  lis r8, -0x7dd4
	ctx.r[8].s64 = -2111045632;
	// 82838BE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838BE4: 3CE08283  lis r7, -0x7d7d
	ctx.r[7].s64 = -2105344000;
	// 82838BE8: 39297B48  addi r9, r9, 0x7b48
	ctx.r[9].s64 = ctx.r[9].s64 + 31560;
	// 82838BEC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82838BF0: 3CA08284  lis r5, -0x7d7c
	ctx.r[5].s64 = -2105278464;
	// 82838BF4: 39080000  addi r8, r8, 0
	ctx.r[8].s64 = ctx.r[8].s64 + 0;
	// 82838BF8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82838BFC: 3CC0822C  lis r6, -0x7dd4
	ctx.r[6].s64 = -2111045632;
	// 82838C00: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82838C04: 808B0070  lwz r4, 0x70(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82838C08: 39474680  addi r10, r7, 0x4680
	ctx.r[10].s64 = ctx.r[7].s64 + 18048;
	// 82838C0C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82838C10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82838C14: 38E58B68  addi r7, r5, -0x7498
	ctx.r[7].s64 = ctx.r[5].s64 + -29848;
	// 82838C18: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82838C1C: 39260000  addi r9, r6, 0
	ctx.r[9].s64 = ctx.r[6].s64 + 0;
	// 82838C20: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82838C24: 3D008283  lis r8, -0x7d7d
	ctx.r[8].s64 = -2105344000;
	// 82838C28: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 82838C2C: EBC10090  ld r30, 0x90(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82838C30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82838C34: 39485968  addi r10, r8, 0x5968
	ctx.r[10].s64 = ctx.r[8].s64 + 22888;
	// 82838C38: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82838C3C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82838C40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82838C44: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82838C48: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82838C4C: E8E10060  ld r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82838C50: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82838C54: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82838C58: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82838C5C: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82838C60: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82838C64: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82838C68: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 82838C6C: F96100A8  std r11, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u64 ) };
	// 82838C70: FBC100A0  std r30, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u64 ) };
	// 82838C74: F92100B0  std r9, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[9].u64 ) };
	// 82838C78: F90100B8  std r8, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[8].u64 ) };
	// 82838C7C: F8E100C0  std r7, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[7].u64 ) };
	// 82838C80: F8C100C8  std r6, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[6].u64 ) };
	// 82838C84: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 82838C88: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 82838C8C: 4E800421  bctrl
	ctx.lr = 0x82838C90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82838C90: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82838C94: 418200C4  beq 0x82838d58
	if ctx.cr[0].eq {
	pc = 0x82838D58; continue 'dispatch;
	}
	// 82838C98: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82838C9C: 394100A4  addi r10, r1, 0xa4
	ctx.r[10].s64 = ctx.r[1].s64 + 164;
	// 82838CA0: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82838CA4: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82838CA8: 55681838  slwi r8, r11, 3
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82838CAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82838CB0: 7D68502E  lwzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82838CB4: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82838CB8: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82838CBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82838CC0: 4E800421  bctrl
	ctx.lr = 0x82838CC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82838CC4: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82838CC8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82838CCC: 409A008C  bne cr6, 0x82838d58
	if !ctx.cr[6].eq {
	pc = 0x82838D58; continue 'dispatch;
	}
	// 82838CD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82838CD4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82838CD8: 4BFB38F1  bl 0x827ec5c8
	ctx.lr = 0x82838CDC;
	sub_827EC5C8(ctx, base);
	// 82838CDC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838CE0: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82838CE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82838CE8: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82838CEC: 3BAB0010  addi r29, r11, 0x10
	ctx.r[29].s64 = ctx.r[11].s64 + 16;
	// 82838CF0: 419A000C  beq cr6, 0x82838cfc
	if ctx.cr[6].eq {
	pc = 0x82838CFC; continue 'dispatch;
	}
	// 82838CF4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82838CF8: 4BA87B99  bl 0x822c0890
	ctx.lr = 0x82838CFC;
	sub_822C0890(ctx, base);
	// 82838CFC: C01D003C  lfs f0, 0x3c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838D00: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82838D04: C1BD0038  lfs f13, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838D08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838D0C: C19D0034  lfs f12, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82838D10: C17D0030  lfs f11, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82838D14: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82838D18: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82838D1C: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82838D20: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82838D24: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838D28: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82838D2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82838D30: 4E800421  bctrl
	ctx.lr = 0x82838D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82838D34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82838D38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82838D3C: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838D40: 486440C9  bl 0x82e7ce08
	ctx.lr = 0x82838D44;
	sub_82E7CE08(ctx, base);
	// 82838D44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838D48: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82838D4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838D50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82838D54: 4E800421  bctrl
	ctx.lr = 0x82838D58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82838D58: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82838D5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838D60: 4BFDE929  bl 0x82817688
	ctx.lr = 0x82838D64;
	sub_82817688(ctx, base);
	// 82838D64: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82838D68: 4896F450  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838D70 size=300
    let mut pc: u32 = 0x82838D70;
    'dispatch: loop {
        match pc {
            0x82838D70 => {
    //   block [0x82838D70..0x82838E9C)
	// 82838D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82838D74: 4896F3F5  bl 0x831a8168
	ctx.lr = 0x82838D78;
	sub_831A8130(ctx, base);
	// 82838D78: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82838D7C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838D80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838D84: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82838D88: 817F026C  lwz r11, 0x26c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(620 as u32) ) } as u64;
	// 82838D8C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82838D90: 409A0014  bne cr6, 0x82838da4
	if !ctx.cr[6].eq {
	pc = 0x82838DA4; continue 'dispatch;
	}
	// 82838D94: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838D98: C1BF0288  lfs f13, 0x288(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838D9C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82838DA0: 48000008  b 0x82838da8
	pc = 0x82838DA8; continue 'dispatch;
	// 82838DA4: C01F0284  lfs f0, 0x284(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838DA8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838DAC: D01F0288  stfs f0, 0x288(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 82838DB0: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82838DB4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82838DB8: 409800CC  bge cr6, 0x82838e84
	if !ctx.cr[6].lt {
	pc = 0x82838E84; continue 'dispatch;
	}
	// 82838DBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838DC0: 481DA8C1  bl 0x82a13680
	ctx.lr = 0x82838DC4;
	sub_82A13680(ctx, base);
	// 82838DC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838DC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82838DCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838DD0: C02B08A8  lfs f1, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82838DD4: 4BFE025D  bl 0x82819030
	ctx.lr = 0x82838DD8;
	sub_82819030(ctx, base);
	// 82838DD8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82838DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838DE0: 808B8618  lwz r4, -0x79e8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31208 as u32) ) } as u64;
	// 82838DE4: 4BFFE3B5  bl 0x82837198
	ctx.lr = 0x82838DE8;
	sub_82837198(ctx, base);
	// 82838DE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82838DEC: 4BD9F265  bl 0x825d8050
	ctx.lr = 0x82838DF0;
	sub_825D8050(ctx, base);
	// 82838DF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82838DF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82838DF8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82838DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82838E00: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82838E04: 419A0024  beq cr6, 0x82838e28
	if ctx.cr[6].eq {
	pc = 0x82838E28; continue 'dispatch;
	}
	// 82838E08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82838E0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82838E10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838E14: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82838E18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82838E1C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82838E20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82838E24: 4082FFE8  bne 0x82838e0c
	if !ctx.cr[0].eq {
	pc = 0x82838E0C; continue 'dispatch;
	}
	// 82838E28: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 82838E2C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82838E30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838E34: 487D0185  bl 0x83008fb8
	ctx.lr = 0x82838E38;
	sub_83008FB8(ctx, base);
	// 82838E38: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82838E3C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82838E40: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82838E44: 388BC548  addi r4, r11, -0x3ab8
	ctx.r[4].s64 = ctx.r[11].s64 + -15032;
	// 82838E48: 38A003D4  li r5, 0x3d4
	ctx.r[5].s64 = 980;
	// 82838E4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838E50: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82838E54: 4861FBED  bl 0x82e58a40
	ctx.lr = 0x82838E58;
	sub_82E58A40(ctx, base);
	// 82838E58: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82838E5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838E60: 419A0008  beq cr6, 0x82838e68
	if ctx.cr[6].eq {
	pc = 0x82838E68; continue 'dispatch;
	}
	// 82838E64: 4BA87A2D  bl 0x822c0890
	ctx.lr = 0x82838E68;
	sub_822C0890(ctx, base);
	// 82838E68: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82838E6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82838E70: 419A0008  beq cr6, 0x82838e78
	if ctx.cr[6].eq {
	pc = 0x82838E78; continue 'dispatch;
	}
	// 82838E74: 4BA87A1D  bl 0x822c0890
	ctx.lr = 0x82838E78;
	sub_822C0890(ctx, base);
	// 82838E78: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82838E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838E80: 4BCD6BD1  bl 0x8250fa50
	ctx.lr = 0x82838E84;
	sub_8250FA50(ctx, base);
	// 82838E84: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82838E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838E8C: 4BFFFD35  bl 0x82838bc0
	ctx.lr = 0x82838E90;
	sub_82838BC0(ctx, base);
	// 82838E90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82838E94: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82838E98: 4896F320  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82838EA0 size=148
    let mut pc: u32 = 0x82838EA0;
    'dispatch: loop {
        match pc {
            0x82838EA0 => {
    //   block [0x82838EA0..0x82838F34)
	// 82838EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82838EA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82838EA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82838EAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82838EB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82838EB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82838EB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82838EBC: 4BCD8235  bl 0x825110f0
	ctx.lr = 0x82838EC0;
	sub_825110F0(ctx, base);
	// 82838EC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82838EC4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82838EC8: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82838ECC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82838ED0: 3929C828  addi r9, r9, -0x37d8
	ctx.r[9].s64 = ctx.r[9].s64 + -14296;
	// 82838ED4: 3908C814  addi r8, r8, -0x37ec
	ctx.r[8].s64 = ctx.r[8].s64 + -14316;
	// 82838ED8: C00A08A4  lfs f0, 0x8a4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838EDC: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82838EE0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82838EE4: 911F0028  stw r8, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[8].u32 ) };
	// 82838EE8: 3D408328  lis r10, -0x7cd8
	ctx.r[10].s64 = -2094530560;
	// 82838EEC: 917F00C4  stw r11, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82838EF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82838EF4: 997F00C8  stb r11, 0xc8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82838EF8: 808AE250  lwz r4, -0x1db0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-7600 as u32) ) } as u64;
	// 82838EFC: 485BAB0D  bl 0x82df3a08
	ctx.lr = 0x82838F00;
	sub_82DF3A08(ctx, base);
	// 82838F00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82838F04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82838F08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82838F0C: 4BCCF875  bl 0x82508780
	ctx.lr = 0x82838F10;
	sub_82508780(ctx, base);
	// 82838F10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82838F14: 485BA515  bl 0x82df3428
	ctx.lr = 0x82838F18;
	sub_82DF3428(ctx, base);
	// 82838F18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82838F1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82838F20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82838F24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82838F28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82838F2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82838F30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82838F38 size=72
    let mut pc: u32 = 0x82838F38;
    'dispatch: loop {
        match pc {
            0x82838F38 => {
    //   block [0x82838F38..0x82838F80)
	// 82838F38: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82838F3C: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838F40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82838F44: 396BC80C  addi r11, r11, -0x37f4
	ctx.r[11].s64 = ctx.r[11].s64 + -14324;
	// 82838F48: C1AA08A4  lfs f13, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838F4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82838F50: 40990024  ble cr6, 0x82838f74
	if !ctx.cr[6].gt {
	pc = 0x82838F74; continue 'dispatch;
	}
	// 82838F54: 814300C4  lwz r10, 0xc4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82838F58: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838F5C: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82838F60: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82838F64: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82838F68: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82838F6C: EC0C037C  fnmsubs f0, f12, f13, f0
	ctx.f[0].f64 = -(((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82838F70: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82838F74: 894300C8  lbz r10, 0xc8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(200 as u32) ) } as u64;
	// 82838F78: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82838F7C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82838F80 size=28
    let mut pc: u32 = 0x82838F80;
    'dispatch: loop {
        match pc {
            0x82838F80 => {
    //   block [0x82838F80..0x82838F9C)
	// 82838F80: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838F84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82838F88: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838F8C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82838F90: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82838F94: 994300C8  stb r10, 0xc8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[10].u8 ) };
	// 82838F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82838FA0 size=40
    let mut pc: u32 = 0x82838FA0;
    'dispatch: loop {
        match pc {
            0x82838FA0 => {
    //   block [0x82838FA0..0x82838FC8)
	// 82838FA0: 816300C4  lwz r11, 0xc4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(196 as u32) ) } as u64;
	// 82838FA4: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82838FA8: 4098000C  bge cr6, 0x82838fb4
	if !ctx.cr[6].lt {
	pc = 0x82838FB4; continue 'dispatch;
	}
	// 82838FAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82838FB0: 916300C4  stw r11, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82838FB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838FB8: C00300C0  lfs f0, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82838FBC: C1AB08A4  lfs f13, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838FC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82838FC4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82838FC8 size=20
    let mut pc: u32 = 0x82838FC8;
    'dispatch: loop {
        match pc {
            0x82838FC8 => {
    //   block [0x82838FC8..0x82838FDC)
	// 82838FC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82838FCC: C1AB9450  lfs f13, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838FD0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82838FD4: D00300C0  stfs f0, 0xc0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82838FD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82838FE0 size=12
    let mut pc: u32 = 0x82838FE0;
    'dispatch: loop {
        match pc {
            0x82838FE0 => {
    //   block [0x82838FE0..0x82838FEC)
	// 82838FE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82838FE4: 996300C8  stb r11, 0xc8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u8 ) };
	// 82838FE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82838FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82838FF0 size=24
    let mut pc: u32 = 0x82838FF0;
    'dispatch: loop {
        match pc {
            0x82838FF0 => {
    //   block [0x82838FF0..0x82839008)
	// 82838FF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82838FF4: C1A300C0  lfs f13, 0xc0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82838FF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82838FFC: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82839000: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82839004: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839008 size=8
    let mut pc: u32 = 0x82839008;
    'dispatch: loop {
        match pc {
            0x82839008 => {
    //   block [0x82839008..0x82839010)
	// 82839008: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8283900C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839010 size=8
    let mut pc: u32 = 0x82839010;
    'dispatch: loop {
        match pc {
            0x82839010 => {
    //   block [0x82839010..0x82839018)
	// 82839010: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82839014: 48000004  b 0x82839018
	sub_82839018(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839018 size=100
    let mut pc: u32 = 0x82839018;
    'dispatch: loop {
        match pc {
            0x82839018 => {
    //   block [0x82839018..0x8283907C)
	// 82839018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283901C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283902C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839030: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839034: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82839038: 396BC828  addi r11, r11, -0x37d8
	ctx.r[11].s64 = ctx.r[11].s64 + -14296;
	// 8283903C: 394AC814  addi r10, r10, -0x37ec
	ctx.r[10].s64 = ctx.r[10].s64 + -14316;
	// 82839040: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82839044: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82839048: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 8283904C: 4BCD814D  bl 0x82511198
	ctx.lr = 0x82839050;
	sub_82511198(ctx, base);
	// 82839050: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82839054: 4182000C  beq 0x82839060
	if ctx.cr[0].eq {
	pc = 0x82839060; continue 'dispatch;
	}
	// 82839058: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283905C: 485B937D  bl 0x82df23d8
	ctx.lr = 0x82839060;
	sub_82DF23D8(ctx, base);
	// 82839060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839064: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283906C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839070: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839074: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839078: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839080 size=196
    let mut pc: u32 = 0x82839080;
    'dispatch: loop {
        match pc {
            0x82839080 => {
    //   block [0x82839080..0x82839144)
	// 82839080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283908C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82839098: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283909C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828390A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828390A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828390A8: 4BA87891  bl 0x822c0938
	ctx.lr = 0x828390AC;
	sub_822C0938(ctx, base);
	// 828390AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828390B0: 41820028  beq 0x828390d8
	if ctx.cr[0].eq {
	pc = 0x828390D8; continue 'dispatch;
	}
	// 828390B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828390B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828390BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828390C0: 392BC854  addi r9, r11, -0x37ac
	ctx.r[9].s64 = ctx.r[11].s64 + -14252;
	// 828390C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828390C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828390CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828390D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828390D4: 48000008  b 0x828390dc
	pc = 0x828390DC; continue 'dispatch;
	// 828390D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828390DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828390E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828390E4: 409A0044  bne cr6, 0x82839128
	if !ctx.cr[6].eq {
	pc = 0x82839128; continue 'dispatch;
	}
	// 828390E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828390EC: 419A001C  beq cr6, 0x82839108
	if ctx.cr[6].eq {
	pc = 0x82839108; continue 'dispatch;
	}
	// 828390F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828390F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828390F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828390FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839100: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839104: 4E800421  bctrl
	ctx.lr = 0x82839108;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839108: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283910C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82839110: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839114: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82839118: 816B16D8  lwz r11, 0x16d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5848 as u32) ) } as u64;
	// 8283911C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82839120: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82839124: 4BA86EDD  bl 0x822c0000
	ctx.lr = 0x82839128;
	sub_822C0000(ctx, base);
	// 82839128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283912C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839138: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283913C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839148 size=268
    let mut pc: u32 = 0x82839148;
    'dispatch: loop {
        match pc {
            0x82839148 => {
    //   block [0x82839148..0x82839254)
	// 82839148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283914C: 4896F01D  bl 0x831a8168
	ctx.lr = 0x82839150;
	sub_831A8130(ctx, base);
	// 82839150: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839154: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82839158: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283915C: 3B8BB4EC  addi r28, r11, -0x4b14
	ctx.r[28].s64 = ctx.r[11].s64 + -19220;
	// 82839160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839164: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82839168: 4818F5F1  bl 0x829c8758
	ctx.lr = 0x8283916C;
	sub_829C8758(ctx, base);
	// 8283916C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82839174: 409A00D4  bne cr6, 0x82839248
	if !ctx.cr[6].eq {
	pc = 0x82839248; continue 'dispatch;
	}
	// 82839178: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8283917C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82839180: 4818F5D9  bl 0x829c8758
	ctx.lr = 0x82839184;
	sub_829C8758(ctx, base);
	// 82839184: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82839188: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 8283918C: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82839190: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82839194: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839198: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283919C: 4BA8B2C5  bl 0x822c4460
	ctx.lr = 0x828391A0;
	sub_822C4460(ctx, base);
	// 828391A0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828391A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828391A8: 419A0008  beq cr6, 0x828391b0
	if ctx.cr[6].eq {
	pc = 0x828391B0; continue 'dispatch;
	}
	// 828391AC: 4BA876E5  bl 0x822c0890
	ctx.lr = 0x828391B0;
	sub_822C0890(ctx, base);
	// 828391B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828391B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828391B8: 409A0090  bne cr6, 0x82839248
	if !ctx.cr[6].eq {
	pc = 0x82839248; continue 'dispatch;
	}
	// 828391BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828391C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828391C4: 388BC868  addi r4, r11, -0x3798
	ctx.r[4].s64 = ctx.r[11].s64 + -14232;
	// 828391C8: 38A00041  li r5, 0x41
	ctx.r[5].s64 = 65;
	// 828391CC: 386000CC  li r3, 0xcc
	ctx.r[3].s64 = 204;
	// 828391D0: 485B9219  bl 0x82df23e8
	ctx.lr = 0x828391D4;
	sub_82DF23E8(ctx, base);
	// 828391D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828391D8: 41820014  beq 0x828391ec
	if ctx.cr[0].eq {
	pc = 0x828391EC; continue 'dispatch;
	}
	// 828391DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828391E0: 4BFFFCC1  bl 0x82838ea0
	ctx.lr = 0x828391E4;
	sub_82838EA0(ctx, base);
	// 828391E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828391E8: 48000008  b 0x828391f0
	pc = 0x828391F0; continue 'dispatch;
	// 828391EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828391F0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 828391F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828391F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828391FC: 4BFFFE85  bl 0x82839080
	ctx.lr = 0x82839200;
	sub_82839080(ctx, base);
	// 82839200: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82839204: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839208: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283920C: 4BA86DF5  bl 0x822c0000
	ctx.lr = 0x82839210;
	sub_822C0000(ctx, base);
	// 82839210: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82839214: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82839218: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283921C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82839220: 4BA8B241  bl 0x822c4460
	ctx.lr = 0x82839224;
	sub_822C4460(ctx, base);
	// 82839224: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82839228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283922C: 419A0008  beq cr6, 0x82839234
	if ctx.cr[6].eq {
	pc = 0x82839234; continue 'dispatch;
	}
	// 82839230: 4BA87661  bl 0x822c0890
	ctx.lr = 0x82839234;
	sub_822C0890(ctx, base);
	// 82839234: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839238: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283923C: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82839240: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82839244: 4BCBD06D  bl 0x824f62b0
	ctx.lr = 0x82839248;
	sub_824F62B0(ctx, base);
	// 82839248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283924C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82839250: 4896EF68  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82839258 size=96
    let mut pc: u32 = 0x82839258;
    'dispatch: loop {
        match pc {
            0x82839258 => {
    //   block [0x82839258..0x828392B8)
	// 82839258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283925C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839260: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839264: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839268: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283926C: 4BFDED7D  bl 0x82817fe8
	ctx.lr = 0x82839270;
	sub_82817FE8(ctx, base);
	// 82839270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82839274: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82839278: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283927C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82839280: 394AC934  addi r10, r10, -0x36cc
	ctx.r[10].s64 = ctx.r[10].s64 + -14028;
	// 82839284: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82839288: 3929C920  addi r9, r9, -0x36e0
	ctx.r[9].s64 = ctx.r[9].s64 + -14048;
	// 8283928C: 3968C8D4  addi r11, r8, -0x372c
	ctx.r[11].s64 = ctx.r[8].s64 + -14124;
	// 82839290: D01F0254  stfs f0, 0x254(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), tmp.u32 ) };
	// 82839294: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82839298: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283929C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 828392A0: 917F0208  stw r11, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 828392A4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828392A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828392AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828392B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828392B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828392B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828392B8 size=12
    let mut pc: u32 = 0x828392B8;
    'dispatch: loop {
        match pc {
            0x828392B8 => {
    //   block [0x828392B8..0x828392C4)
	// 828392B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828392BC: 386BB510  addi r3, r11, -0x4af0
	ctx.r[3].s64 = ctx.r[11].s64 + -19184;
	// 828392C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828392C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828392C8 size=12
    let mut pc: u32 = 0x828392C8;
    'dispatch: loop {
        match pc {
            0x828392C8 => {
    //   block [0x828392C8..0x828392D4)
	// 828392C8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828392CC: 386BB4F4  addi r3, r11, -0x4b0c
	ctx.r[3].s64 = ctx.r[11].s64 + -19212;
	// 828392D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828392D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828392D8 size=12
    let mut pc: u32 = 0x828392D8;
    'dispatch: loop {
        match pc {
            0x828392D8 => {
    //   block [0x828392D8..0x828392E4)
	// 828392D8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828392DC: 386BB520  addi r3, r11, -0x4ae0
	ctx.r[3].s64 = ctx.r[11].s64 + -19168;
	// 828392E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828392E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828392E8 size=12
    let mut pc: u32 = 0x828392E8;
    'dispatch: loop {
        match pc {
            0x828392E8 => {
    //   block [0x828392E8..0x828392F4)
	// 828392E8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828392EC: 386B13BC  addi r3, r11, 0x13bc
	ctx.r[3].s64 = ctx.r[11].s64 + 5052;
	// 828392F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828392F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828392F8 size=8
    let mut pc: u32 = 0x828392F8;
    'dispatch: loop {
        match pc {
            0x828392F8 => {
    //   block [0x828392F8..0x82839300)
	// 828392F8: C0230254  lfs f1, 0x254(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(596 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828392FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839300 size=212
    let mut pc: u32 = 0x82839300;
    'dispatch: loop {
        match pc {
            0x82839300 => {
    //   block [0x82839300..0x828393D4)
	// 82839300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283930C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839314: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839318: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283931C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839320: 388BC9D8  addi r4, r11, -0x3628
	ctx.r[4].s64 = ctx.r[11].s64 + -13864;
	// 82839324: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82839328: 485BA6E1  bl 0x82df3a08
	ctx.lr = 0x8283932C;
	sub_82DF3A08(ctx, base);
	// 8283932C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839334: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839338: 4BFB27F9  bl 0x827ebb30
	ctx.lr = 0x8283933C;
	sub_827EBB30(ctx, base);
	// 8283933C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839340: 485BA0E9  bl 0x82df3428
	ctx.lr = 0x82839344;
	sub_82DF3428(ctx, base);
	// 82839344: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283934C: 388BC9CC  addi r4, r11, -0x3634
	ctx.r[4].s64 = ctx.r[11].s64 + -13876;
	// 82839350: 485BA6B9  bl 0x82df3a08
	ctx.lr = 0x82839354;
	sub_82DF3A08(ctx, base);
	// 82839354: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283935C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839360: 4BFB27D1  bl 0x827ebb30
	ctx.lr = 0x82839364;
	sub_827EBB30(ctx, base);
	// 82839364: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839368: 485BA0C1  bl 0x82df3428
	ctx.lr = 0x8283936C;
	sub_82DF3428(ctx, base);
	// 8283936C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839370: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839374: 388BC9C0  addi r4, r11, -0x3640
	ctx.r[4].s64 = ctx.r[11].s64 + -13888;
	// 82839378: 485BA691  bl 0x82df3a08
	ctx.lr = 0x8283937C;
	sub_82DF3A08(ctx, base);
	// 8283937C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839384: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839388: 4BFB27A9  bl 0x827ebb30
	ctx.lr = 0x8283938C;
	sub_827EBB30(ctx, base);
	// 8283938C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839390: 485BA099  bl 0x82df3428
	ctx.lr = 0x82839394;
	sub_82DF3428(ctx, base);
	// 82839394: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283939C: 388BC9B4  addi r4, r11, -0x364c
	ctx.r[4].s64 = ctx.r[11].s64 + -13900;
	// 828393A0: 485BA669  bl 0x82df3a08
	ctx.lr = 0x828393A4;
	sub_82DF3A08(ctx, base);
	// 828393A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828393A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828393AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828393B0: 4BFB2781  bl 0x827ebb30
	ctx.lr = 0x828393B4;
	sub_827EBB30(ctx, base);
	// 828393B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828393B8: 485BA071  bl 0x82df3428
	ctx.lr = 0x828393BC;
	sub_82DF3428(ctx, base);
	// 828393BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828393C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828393C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828393C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828393CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828393D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828393D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828393D8 size=4
    let mut pc: u32 = 0x828393D8;
    'dispatch: loop {
        match pc {
            0x828393D8 => {
    //   block [0x828393D8..0x828393DC)
	// 828393D8: 4BFE0E60  b 0x8281a238
	sub_8281A238(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828393E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828393E0 size=4
    let mut pc: u32 = 0x828393E0;
    'dispatch: loop {
        match pc {
            0x828393E0 => {
    //   block [0x828393E0..0x828393E4)
	// 828393E0: 4BFDE2A8  b 0x82817688
	sub_82817688(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828393E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828393E8 size=8
    let mut pc: u32 = 0x828393E8;
    'dispatch: loop {
        match pc {
            0x828393E8 => {
    //   block [0x828393E8..0x828393F0)
	// 828393E8: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 828393EC: 4800000C  b 0x828393f8
	sub_828393F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828393F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828393F0 size=8
    let mut pc: u32 = 0x828393F0;
    'dispatch: loop {
        match pc {
            0x828393F0 => {
    //   block [0x828393F0..0x828393F8)
	// 828393F0: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 828393F4: 48000004  b 0x828393f8
	sub_828393F8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828393F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828393F8 size=112
    let mut pc: u32 = 0x828393F8;
    'dispatch: loop {
        match pc {
            0x828393F8 => {
    //   block [0x828393F8..0x82839468)
	// 828393F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828393FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283940C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839410: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839414: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82839418: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283941C: 396BC934  addi r11, r11, -0x36cc
	ctx.r[11].s64 = ctx.r[11].s64 + -14028;
	// 82839420: 394AC920  addi r10, r10, -0x36e0
	ctx.r[10].s64 = ctx.r[10].s64 + -14048;
	// 82839424: 3929C8D4  addi r9, r9, -0x372c
	ctx.r[9].s64 = ctx.r[9].s64 + -14124;
	// 82839428: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283942C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82839430: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82839434: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 82839438: 4BFDEA41  bl 0x82817e78
	ctx.lr = 0x8283943C;
	sub_82817E78(ctx, base);
	// 8283943C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82839440: 4182000C  beq 0x8283944c
	if ctx.cr[0].eq {
	pc = 0x8283944C; continue 'dispatch;
	}
	// 82839444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839448: 485B8F91  bl 0x82df23d8
	ctx.lr = 0x8283944C;
	sub_82DF23D8(ctx, base);
	// 8283944C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283945C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839468 size=196
    let mut pc: u32 = 0x82839468;
    'dispatch: loop {
        match pc {
            0x82839468 => {
    //   block [0x82839468..0x8283952C)
	// 82839468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283946C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839470: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839474: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839478: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283947C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82839480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82839484: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82839488: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283948C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82839490: 4BA874A9  bl 0x822c0938
	ctx.lr = 0x82839494;
	sub_822C0938(ctx, base);
	// 82839494: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82839498: 41820028  beq 0x828394c0
	if ctx.cr[0].eq {
	pc = 0x828394C0; continue 'dispatch;
	}
	// 8283949C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828394A0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828394A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828394A8: 392BC9E8  addi r9, r11, -0x3618
	ctx.r[9].s64 = ctx.r[11].s64 + -13848;
	// 828394AC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828394B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828394B4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828394B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828394BC: 48000008  b 0x828394c4
	pc = 0x828394C4; continue 'dispatch;
	// 828394C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828394C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828394C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828394CC: 409A0044  bne cr6, 0x82839510
	if !ctx.cr[6].eq {
	pc = 0x82839510; continue 'dispatch;
	}
	// 828394D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828394D4: 419A001C  beq cr6, 0x828394f0
	if ctx.cr[6].eq {
	pc = 0x828394F0; continue 'dispatch;
	}
	// 828394D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828394DC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828394E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828394E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828394E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828394EC: 4E800421  bctrl
	ctx.lr = 0x828394F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828394F0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828394F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828394F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828394FC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82839500: 816B1754  lwz r11, 0x1754(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5972 as u32) ) } as u64;
	// 82839504: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82839508: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283950C: 4BA86AF5  bl 0x822c0000
	ctx.lr = 0x82839510;
	sub_822C0000(ctx, base);
	// 82839510: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82839514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283951C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839520: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82839530 size=140
    let mut pc: u32 = 0x82839530;
    'dispatch: loop {
        match pc {
            0x82839530 => {
    //   block [0x82839530..0x828395BC)
	// 82839530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839534: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839538: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283953C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839540: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839544: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82839548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283954C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82839550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839554: 388B7C44  addi r4, r11, 0x7c44
	ctx.r[4].s64 = ctx.r[11].s64 + 31812;
	// 82839558: 485BA4B1  bl 0x82df3a08
	ctx.lr = 0x8283955C;
	sub_82DF3A08(ctx, base);
	// 8283955C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82839560: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82839564: 389F004C  addi r4, r31, 0x4c
	ctx.r[4].s64 = ctx.r[31].s64 + 76;
	// 82839568: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283956C: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82839570: C04A89AC  lfs f2, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82839574: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82839578: 4BD69C39  bl 0x825a31b0
	ctx.lr = 0x8283957C;
	sub_825A31B0(ctx, base);
	// 8283957C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82839580: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82839584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82839588: 4BD681E9  bl 0x825a1770
	ctx.lr = 0x8283958C;
	sub_825A1770(ctx, base);
	// 8283958C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82839590: 485B9E99  bl 0x82df3428
	ctx.lr = 0x82839594;
	sub_82DF3428(ctx, base);
	// 82839594: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82839598: 4BA8F721  bl 0x822c8cb8
	ctx.lr = 0x8283959C;
	sub_822C8CB8(ctx, base);
	// 8283959C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828395A0: 485B9E89  bl 0x82df3428
	ctx.lr = 0x828395A4;
	sub_82DF3428(ctx, base);
	// 828395A4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 828395A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828395AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828395B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828395B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828395B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828395C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828395C0 size=476
    let mut pc: u32 = 0x828395C0;
    'dispatch: loop {
        match pc {
            0x828395C0 => {
    //   block [0x828395C0..0x8283979C)
	// 828395C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828395C4: 4896EBA1  bl 0x831a8164
	ctx.lr = 0x828395C8;
	sub_831A8130(ctx, base);
	// 828395C8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 828395CC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828395D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828395D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828395D8: 3BCBC9F8  addi r30, r11, -0x3608
	ctx.r[30].s64 = ctx.r[11].s64 + -13832;
	// 828395DC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828395E0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828395E4: 38A00035  li r5, 0x35
	ctx.r[5].s64 = 53;
	// 828395E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828395EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828395F0: 38600258  li r3, 0x258
	ctx.r[3].s64 = 600;
	// 828395F4: 485B8DF5  bl 0x82df23e8
	ctx.lr = 0x828395F8;
	sub_82DF23E8(ctx, base);
	// 828395F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828395FC: 41820010  beq 0x8283960c
	if ctx.cr[0].eq {
	pc = 0x8283960C; continue 'dispatch;
	}
	// 82839600: 4BFFFC59  bl 0x82839258
	ctx.lr = 0x82839604;
	sub_82839258(ctx, base);
	// 82839604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839608: 48000008  b 0x82839610
	pc = 0x82839610; continue 'dispatch;
	// 8283960C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82839610: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82839614: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82839618: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283961C: 4BFFFE4D  bl 0x82839468
	ctx.lr = 0x82839620;
	sub_82839468(ctx, base);
	// 82839620: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82839624: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82839628: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283962C: 4BA869D5  bl 0x822c0000
	ctx.lr = 0x82839630;
	sub_822C0000(ctx, base);
	// 82839630: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82839638: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 8283963C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82839640: 4BA86D99  bl 0x822c03d8
	ctx.lr = 0x82839644;
	sub_822C03D8(ctx, base);
	// 82839644: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82839648: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8283964C: 418200E0  beq 0x8283972c
	if ctx.cr[0].eq {
	pc = 0x8283972C; continue 'dispatch;
	}
	// 82839650: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82839654: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82839658: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8283965C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82839660: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82839664: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82839668: 396A0208  addi r11, r10, 0x208
	ctx.r[11].s64 = ctx.r[10].s64 + 520;
	// 8283966C: C00908A8  lfs f0, 0x8a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82839670: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82839674: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82839678: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8283967C: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82839680: 409A0008  bne cr6, 0x82839688
	if !ctx.cr[6].eq {
	pc = 0x82839688; continue 'dispatch;
	}
	// 82839684: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82839688: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283968C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82839690: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82839694: 419A0024  beq cr6, 0x828396b8
	if ctx.cr[6].eq {
	pc = 0x828396B8; continue 'dispatch;
	}
	// 82839698: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8283969C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828396A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828396A4: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828396A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828396AC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828396B0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828396B4: 4082FFE8  bne 0x8283969c
	if !ctx.cr[0].eq {
	pc = 0x8283969C; continue 'dispatch;
	}
	// 828396B8: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 828396BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828396C0: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 828396C4: 419A0024  beq cr6, 0x828396e8
	if ctx.cr[6].eq {
	pc = 0x828396E8; continue 'dispatch;
	}
	// 828396C8: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828396CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828396D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828396D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828396D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828396DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828396E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828396E4: 4082FFE8  bne 0x828396cc
	if !ctx.cr[0].eq {
	pc = 0x828396CC; continue 'dispatch;
	}
	// 828396E8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 828396EC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828396F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828396F4: C02B7590  lfs f1, 0x7590(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828396F8: 48643549  bl 0x82e7cc40
	ctx.lr = 0x828396FC;
	sub_82E7CC40(ctx, base);
	// 828396FC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82839700: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839704: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82839708: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283970C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82839710: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82839714: 4BF5F81D  bl 0x82798f30
	ctx.lr = 0x82839718;
	sub_82798F30(ctx, base);
	// 82839718: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283971C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839720: 4BF61F49  bl 0x8279b668
	ctx.lr = 0x82839724;
	sub_8279B668(ctx, base);
	// 82839724: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839728: 48000008  b 0x82839730
	pc = 0x82839730; continue 'dispatch;
	// 8283972C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82839730: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82839734: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 82839738: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283973C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82839740: 4BD5E511  bl 0x82597c50
	ctx.lr = 0x82839744;
	sub_82597C50(ctx, base);
	// 82839744: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82839748: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283974C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82839750: 4BA868B1  bl 0x822c0000
	ctx.lr = 0x82839754;
	sub_822C0000(ctx, base);
	// 82839754: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82839758: 41820024  beq 0x8283977c
	if ctx.cr[0].eq {
	pc = 0x8283977C; continue 'dispatch;
	}
	// 8283975C: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82839760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82839764: 419A0008  beq cr6, 0x8283976c
	if ctx.cr[6].eq {
	pc = 0x8283976C; continue 'dispatch;
	}
	// 82839768: 4BA87129  bl 0x822c0890
	ctx.lr = 0x8283976C;
	sub_822C0890(ctx, base);
	// 8283976C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82839770: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82839774: 419A0008  beq cr6, 0x8283977c
	if ctx.cr[6].eq {
	pc = 0x8283977C; continue 'dispatch;
	}
	// 82839778: 4BA87119  bl 0x822c0890
	ctx.lr = 0x8283977C;
	sub_822C0890(ctx, base);
	// 8283977C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82839780: 419A000C  beq cr6, 0x8283978c
	if ctx.cr[6].eq {
	pc = 0x8283978C; continue 'dispatch;
	}
	// 82839784: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82839788: 4BA87109  bl 0x822c0890
	ctx.lr = 0x8283978C;
	sub_822C0890(ctx, base);
	// 8283978C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82839790: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82839794: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82839798: 4896EA1C  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828397A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828397A0 size=16
    let mut pc: u32 = 0x828397A0;
    'dispatch: loop {
        match pc {
            0x828397A0 => {
    //   block [0x828397A0..0x828397B0)
	// 828397A0: C0030064  lfs f0, 0x64(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828397A4: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 828397A8: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 828397AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828397B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828397B0 size=96
    let mut pc: u32 = 0x828397B0;
    'dispatch: loop {
        match pc {
            0x828397B0 => {
    //   block [0x828397B0..0x82839810)
	// 828397B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828397B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828397B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828397BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828397C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828397C4: 4BFDCDB5  bl 0x82816578
	ctx.lr = 0x828397C8;
	sub_82816578(ctx, base);
	// 828397C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828397CC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828397D0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828397D4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 828397D8: 394ACAC8  addi r10, r10, -0x3538
	ctx.r[10].s64 = ctx.r[10].s64 + -13624;
	// 828397DC: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828397E0: 3929CA9C  addi r9, r9, -0x3564
	ctx.r[9].s64 = ctx.r[9].s64 + -13668;
	// 828397E4: 3968CA88  addi r11, r8, -0x3578
	ctx.r[11].s64 = ctx.r[8].s64 + -13688;
	// 828397E8: D01F0210  stfs f0, 0x210(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 828397EC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828397F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828397F4: 913F0058  stw r9, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828397F8: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 828397FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82839800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839808: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283980C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82839810 size=24
    let mut pc: u32 = 0x82839810;
    'dispatch: loop {
        match pc {
            0x82839810 => {
    //   block [0x82839810..0x82839828)
	// 82839810: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839814: C1A30080  lfs f13, 0x80(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82839818: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8283981C: C00BE830  lfs f0, -0x17d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-6096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82839820: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82839824: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839828 size=8
    let mut pc: u32 = 0x82839828;
    'dispatch: loop {
        match pc {
            0x82839828 => {
    //   block [0x82839828..0x82839830)
	// 82839828: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8283982C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839830 size=84
    let mut pc: u32 = 0x82839830;
    'dispatch: loop {
        match pc {
            0x82839830 => {
    //   block [0x82839830..0x82839884)
	// 82839830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839838: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283983C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839840: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82839844: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839848: 388BB5D8  addi r4, r11, -0x4a28
	ctx.r[4].s64 = ctx.r[11].s64 + -18984;
	// 8283984C: 4BFB6FDD  bl 0x827f0828
	ctx.lr = 0x82839850;
	sub_827F0828(ctx, base);
	// 82839850: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82839854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839858: 388BB5F4  addi r4, r11, -0x4a0c
	ctx.r[4].s64 = ctx.r[11].s64 + -18956;
	// 8283985C: 4BFBC895  bl 0x827f60f0
	ctx.lr = 0x82839860;
	sub_827F60F0(ctx, base);
	// 82839860: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82839864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839868: 388BB604  addi r4, r11, -0x49fc
	ctx.r[4].s64 = ctx.r[11].s64 + -18940;
	// 8283986C: 4BFB725D  bl 0x827f0ac8
	ctx.lr = 0x82839870;
	sub_827F0AC8(ctx, base);
	// 82839870: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82839874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283987C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839888 size=12
    let mut pc: u32 = 0x82839888;
    'dispatch: loop {
        match pc {
            0x82839888 => {
    //   block [0x82839888..0x82839894)
	// 82839888: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283988C: 386BB5F4  addi r3, r11, -0x4a0c
	ctx.r[3].s64 = ctx.r[11].s64 + -18956;
	// 82839890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839898 size=12
    let mut pc: u32 = 0x82839898;
    'dispatch: loop {
        match pc {
            0x82839898 => {
    //   block [0x82839898..0x828398A4)
	// 82839898: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8283989C: 386BB5D8  addi r3, r11, -0x4a28
	ctx.r[3].s64 = ctx.r[11].s64 + -18984;
	// 828398A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828398A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828398A8 size=12
    let mut pc: u32 = 0x828398A8;
    'dispatch: loop {
        match pc {
            0x828398A8 => {
    //   block [0x828398A8..0x828398B4)
	// 828398A8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828398AC: 386BB604  addi r3, r11, -0x49fc
	ctx.r[3].s64 = ctx.r[11].s64 + -18940;
	// 828398B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828398B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828398B8 size=12
    let mut pc: u32 = 0x828398B8;
    'dispatch: loop {
        match pc {
            0x828398B8 => {
    //   block [0x828398B8..0x828398C4)
	// 828398B8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828398BC: 386BAE64  addi r3, r11, -0x519c
	ctx.r[3].s64 = ctx.r[11].s64 + -20892;
	// 828398C0: 4BFE2670  b 0x8281bf30
	sub_8281BF30(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828398C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828398C8 size=12
    let mut pc: u32 = 0x828398C8;
    'dispatch: loop {
        match pc {
            0x828398C8 => {
    //   block [0x828398C8..0x828398D4)
	// 828398C8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 828398CC: 386BAE64  addi r3, r11, -0x519c
	ctx.r[3].s64 = ctx.r[11].s64 + -20892;
	// 828398D0: 4BFE2668  b 0x8281bf38
	sub_8281BF38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828398D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828398D8 size=8
    let mut pc: u32 = 0x828398D8;
    'dispatch: loop {
        match pc {
            0x828398D8 => {
    //   block [0x828398D8..0x828398E0)
	// 828398D8: C0230310  lfs f1, 0x310(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(784 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828398DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828398E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828398E0 size=804
    let mut pc: u32 = 0x828398E0;
    'dispatch: loop {
        match pc {
            0x828398E0 => {
    //   block [0x828398E0..0x82839C04)
	// 828398E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828398E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828398E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828398EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828398F0: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 828398F4: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 828398F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828398FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82839900: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82839904: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839908: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8283990C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82839910: 485BA0F9  bl 0x82df3a08
	ctx.lr = 0x82839914;
	sub_82DF3A08(ctx, base);
	// 82839914: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82839918: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283991C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839920: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839924: C3EB7BC8  lfs f31, 0x7bc8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31688 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82839928: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283992C: 4BFB2455  bl 0x827ebd80
	ctx.lr = 0x82839930;
	sub_827EBD80(ctx, base);
	// 82839930: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839934: 485B9AF5  bl 0x82df3428
	ctx.lr = 0x82839938;
	sub_82DF3428(ctx, base);
	// 82839938: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283993C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839940: 388BCB9C  addi r4, r11, -0x3464
	ctx.r[4].s64 = ctx.r[11].s64 + -13412;
	// 82839944: 485BA0C5  bl 0x82df3a08
	ctx.lr = 0x82839948;
	sub_82DF3A08(ctx, base);
	// 82839948: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283994C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839950: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839954: 4BFB21DD  bl 0x827ebb30
	ctx.lr = 0x82839958;
	sub_827EBB30(ctx, base);
	// 82839958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283995C: 485B9ACD  bl 0x82df3428
	ctx.lr = 0x82839960;
	sub_82DF3428(ctx, base);
	// 82839960: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 82839964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839968: 388B2D6C  addi r4, r11, 0x2d6c
	ctx.r[4].s64 = ctx.r[11].s64 + 11628;
	// 8283996C: 485BA09D  bl 0x82df3a08
	ctx.lr = 0x82839970;
	sub_82DF3A08(ctx, base);
	// 82839970: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82839974: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283997C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839980: C3CBA9F0  lfs f30, -0x5610(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22032 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82839984: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82839988: 4BFB2331  bl 0x827ebcb8
	ctx.lr = 0x8283998C;
	sub_827EBCB8(ctx, base);
	// 8283998C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839990: 485B9A99  bl 0x82df3428
	ctx.lr = 0x82839994;
	sub_82DF3428(ctx, base);
	// 82839994: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839998: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283999C: 388BCB8C  addi r4, r11, -0x3474
	ctx.r[4].s64 = ctx.r[11].s64 + -13428;
	// 828399A0: 485BA069  bl 0x82df3a08
	ctx.lr = 0x828399A4;
	sub_82DF3A08(ctx, base);
	// 828399A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828399A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828399AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828399B0: 4BFB2181  bl 0x827ebb30
	ctx.lr = 0x828399B4;
	sub_827EBB30(ctx, base);
	// 828399B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828399B8: 485B9A71  bl 0x82df3428
	ctx.lr = 0x828399BC;
	sub_82DF3428(ctx, base);
	// 828399BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828399C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828399C4: 388BCB7C  addi r4, r11, -0x3484
	ctx.r[4].s64 = ctx.r[11].s64 + -13444;
	// 828399C8: 485BA041  bl 0x82df3a08
	ctx.lr = 0x828399CC;
	sub_82DF3A08(ctx, base);
	// 828399CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828399D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828399D4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828399D8: 4BFB2221  bl 0x827ebbf8
	ctx.lr = 0x828399DC;
	sub_827EBBF8(ctx, base);
	// 828399DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828399E0: 485B9A49  bl 0x82df3428
	ctx.lr = 0x828399E4;
	sub_82DF3428(ctx, base);
	// 828399E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828399E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828399EC: 388BCB70  addi r4, r11, -0x3490
	ctx.r[4].s64 = ctx.r[11].s64 + -13456;
	// 828399F0: 485BA019  bl 0x82df3a08
	ctx.lr = 0x828399F4;
	sub_82DF3A08(ctx, base);
	// 828399F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828399F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828399FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839A00: 4BFB2131  bl 0x827ebb30
	ctx.lr = 0x82839A04;
	sub_827EBB30(ctx, base);
	// 82839A04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A08: 485B9A21  bl 0x82df3428
	ctx.lr = 0x82839A0C;
	sub_82DF3428(ctx, base);
	// 82839A0C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839A10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A14: 388BCB60  addi r4, r11, -0x34a0
	ctx.r[4].s64 = ctx.r[11].s64 + -13472;
	// 82839A18: 485B9FF1  bl 0x82df3a08
	ctx.lr = 0x82839A1C;
	sub_82DF3A08(ctx, base);
	// 82839A1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839A24: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839A28: 4BFB2109  bl 0x827ebb30
	ctx.lr = 0x82839A2C;
	sub_827EBB30(ctx, base);
	// 82839A2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A30: 485B99F9  bl 0x82df3428
	ctx.lr = 0x82839A34;
	sub_82DF3428(ctx, base);
	// 82839A34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A3C: 388BCB50  addi r4, r11, -0x34b0
	ctx.r[4].s64 = ctx.r[11].s64 + -13488;
	// 82839A40: 485B9FC9  bl 0x82df3a08
	ctx.lr = 0x82839A44;
	sub_82DF3A08(ctx, base);
	// 82839A44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839A48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839A50: 4BFB21A9  bl 0x827ebbf8
	ctx.lr = 0x82839A54;
	sub_827EBBF8(ctx, base);
	// 82839A54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A58: 485B99D1  bl 0x82df3428
	ctx.lr = 0x82839A5C;
	sub_82DF3428(ctx, base);
	// 82839A5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A64: 388BCB44  addi r4, r11, -0x34bc
	ctx.r[4].s64 = ctx.r[11].s64 + -13500;
	// 82839A68: 485B9FA1  bl 0x82df3a08
	ctx.lr = 0x82839A6C;
	sub_82DF3A08(ctx, base);
	// 82839A6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839A70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839A74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839A78: 4BFB20B9  bl 0x827ebb30
	ctx.lr = 0x82839A7C;
	sub_827EBB30(ctx, base);
	// 82839A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A80: 485B99A9  bl 0x82df3428
	ctx.lr = 0x82839A84;
	sub_82DF3428(ctx, base);
	// 82839A84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839A88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839A8C: 388BCB38  addi r4, r11, -0x34c8
	ctx.r[4].s64 = ctx.r[11].s64 + -13512;
	// 82839A90: 485B9F79  bl 0x82df3a08
	ctx.lr = 0x82839A94;
	sub_82DF3A08(ctx, base);
	// 82839A94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82839A98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839A9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839AA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839AA4: C02B9450  lfs f1, -0x6bb0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27568 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82839AA8: 4BFB2211  bl 0x827ebcb8
	ctx.lr = 0x82839AAC;
	sub_827EBCB8(ctx, base);
	// 82839AAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839AB0: 485B9979  bl 0x82df3428
	ctx.lr = 0x82839AB4;
	sub_82DF3428(ctx, base);
	// 82839AB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839AB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839ABC: 388BCB28  addi r4, r11, -0x34d8
	ctx.r[4].s64 = ctx.r[11].s64 + -13528;
	// 82839AC0: 485B9F49  bl 0x82df3a08
	ctx.lr = 0x82839AC4;
	sub_82DF3A08(ctx, base);
	// 82839AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839ACC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839AD0: 4BFB2129  bl 0x827ebbf8
	ctx.lr = 0x82839AD4;
	sub_827EBBF8(ctx, base);
	// 82839AD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839AD8: 485B9951  bl 0x82df3428
	ctx.lr = 0x82839ADC;
	sub_82DF3428(ctx, base);
	// 82839ADC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839AE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839AE4: 388BCB1C  addi r4, r11, -0x34e4
	ctx.r[4].s64 = ctx.r[11].s64 + -13540;
	// 82839AE8: 485B9F21  bl 0x82df3a08
	ctx.lr = 0x82839AEC;
	sub_82DF3A08(ctx, base);
	// 82839AEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839AF4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839AF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839AFC: 4BFB21BD  bl 0x827ebcb8
	ctx.lr = 0x82839B00;
	sub_827EBCB8(ctx, base);
	// 82839B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B04: 485B9925  bl 0x82df3428
	ctx.lr = 0x82839B08;
	sub_82DF3428(ctx, base);
	// 82839B08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839B0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B10: 388BCB10  addi r4, r11, -0x34f0
	ctx.r[4].s64 = ctx.r[11].s64 + -13552;
	// 82839B14: 485B9EF5  bl 0x82df3a08
	ctx.lr = 0x82839B18;
	sub_82DF3A08(ctx, base);
	// 82839B18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82839B1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839B24: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839B28: C02B9524  lfs f1, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82839B2C: 4BFB218D  bl 0x827ebcb8
	ctx.lr = 0x82839B30;
	sub_827EBCB8(ctx, base);
	// 82839B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B34: 485B98F5  bl 0x82df3428
	ctx.lr = 0x82839B38;
	sub_82DF3428(ctx, base);
	// 82839B38: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839B3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B40: 388BCB04  addi r4, r11, -0x34fc
	ctx.r[4].s64 = ctx.r[11].s64 + -13564;
	// 82839B44: 485B9EC5  bl 0x82df3a08
	ctx.lr = 0x82839B48;
	sub_82DF3A08(ctx, base);
	// 82839B48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839B50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839B54: 4BFB20A5  bl 0x827ebbf8
	ctx.lr = 0x82839B58;
	sub_827EBBF8(ctx, base);
	// 82839B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B5C: 485B98CD  bl 0x82df3428
	ctx.lr = 0x82839B60;
	sub_82DF3428(ctx, base);
	// 82839B60: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839B64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B68: 388BCAF4  addi r4, r11, -0x350c
	ctx.r[4].s64 = ctx.r[11].s64 + -13580;
	// 82839B6C: 485B9E9D  bl 0x82df3a08
	ctx.lr = 0x82839B70;
	sub_82DF3A08(ctx, base);
	// 82839B70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839B74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839B78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839B80: 4BFB2139  bl 0x827ebcb8
	ctx.lr = 0x82839B84;
	sub_827EBCB8(ctx, base);
	// 82839B84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B88: 485B98A1  bl 0x82df3428
	ctx.lr = 0x82839B8C;
	sub_82DF3428(ctx, base);
	// 82839B8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839B90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839B94: 388BCAE4  addi r4, r11, -0x351c
	ctx.r[4].s64 = ctx.r[11].s64 + -13596;
	// 82839B98: 485B9E71  bl 0x82df3a08
	ctx.lr = 0x82839B9C;
	sub_82DF3A08(ctx, base);
	// 82839B9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839BA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839BA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839BA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839BAC: 4BFB210D  bl 0x827ebcb8
	ctx.lr = 0x82839BB0;
	sub_827EBCB8(ctx, base);
	// 82839BB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839BB4: 485B9875  bl 0x82df3428
	ctx.lr = 0x82839BB8;
	sub_82DF3428(ctx, base);
	// 82839BB8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839BBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839BC0: 388BB1A8  addi r4, r11, -0x4e58
	ctx.r[4].s64 = ctx.r[11].s64 + -20056;
	// 82839BC4: 485B9E45  bl 0x82df3a08
	ctx.lr = 0x82839BC8;
	sub_82DF3A08(ctx, base);
	// 82839BC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839BCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839BD0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82839BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839BD8: 4BFB20E1  bl 0x827ebcb8
	ctx.lr = 0x82839BDC;
	sub_827EBCB8(ctx, base);
	// 82839BDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839BE0: 485B9849  bl 0x82df3428
	ctx.lr = 0x82839BE4;
	sub_82DF3428(ctx, base);
	// 82839BE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82839BE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839BEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839BF0: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82839BF4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82839BF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839BFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839C00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82839C08 size=136
    let mut pc: u32 = 0x82839C08;
    'dispatch: loop {
        match pc {
            0x82839C08 => {
    //   block [0x82839C08..0x82839C90)
	// 82839C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839C10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839C14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839C18: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82839C1C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839C20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839C24: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82839C28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82839C2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839C30: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82839C34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839C38: 4E800421  bctrl
	ctx.lr = 0x82839C3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839C3C: EDA1F82A  fadds f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82839C40: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82839C44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839C48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82839C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839C50: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82839C54: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82839C58: EFED002A  fadds f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82839C5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839C60: 4E800421  bctrl
	ctx.lr = 0x82839C64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839C64: FF1F0800  fcmpu cr6, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[1].f64);
	// 82839C68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82839C6C: 41990008  bgt cr6, 0x82839c74
	if ctx.cr[6].gt {
	pc = 0x82839C74; continue 'dispatch;
	}
	// 82839C70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82839C74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839C78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839C7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839C80: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82839C84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839C88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82839C90 size=196
    let mut pc: u32 = 0x82839C90;
    'dispatch: loop {
        match pc {
            0x82839C90 => {
    //   block [0x82839C90..0x82839D54)
	// 82839C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839C98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839C9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839CA0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82839CA4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82839CA8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82839CAC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839CB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82839CB4: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82839CB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839CBC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82839CC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82839CC4: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82839CC8: 419A0064  beq cr6, 0x82839d2c
	if ctx.cr[6].eq {
	pc = 0x82839D2C; continue 'dispatch;
	}
	// 82839CCC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839CD0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82839CD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839CD8: 4E800421  bctrl
	ctx.lr = 0x82839CDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839CDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839CE0: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82839CE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82839CE8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82839CEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839CF0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82839CF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839CF8: 4E800421  bctrl
	ctx.lr = 0x82839CFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839CFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839D04: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82839D08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839D0C: 4E800421  bctrl
	ctx.lr = 0x82839D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839D10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839D14: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82839D18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839D1C: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82839D20: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82839D24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839D28: 4E800421  bctrl
	ctx.lr = 0x82839D2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839D2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839D30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82839D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839D3C: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82839D40: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82839D44: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82839D48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839D4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839D50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82839D58 size=148
    let mut pc: u32 = 0x82839D58;
    'dispatch: loop {
        match pc {
            0x82839D58 => {
    //   block [0x82839D58..0x82839DEC)
	// 82839D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839D60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839D64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839D68: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82839D6C: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82839D70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839D78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82839D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82839D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839D84: 4BFB4C65  bl 0x827ee9e8
	ctx.lr = 0x82839D88;
	sub_827EE9E8(ctx, base);
	// 82839D88: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82839D8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82839D90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82839D94: C3EB6218  lfs f31, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82839D98: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839D9C: 4BFFFEF5  bl 0x82839c90
	ctx.lr = 0x82839DA0;
	sub_82839C90(ctx, base);
	// 82839DA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839DA4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82839DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839DAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82839DB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82839DB4: 4E800421  bctrl
	ctx.lr = 0x82839DB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82839DB8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82839DBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82839DC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82839DC4: 4BFFFECD  bl 0x82839c90
	ctx.lr = 0x82839DC8;
	sub_82839C90(ctx, base);
	// 82839DC8: EC21F028  fsubs f1, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 82839DCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82839DD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839DD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839DD8: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82839DDC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82839DE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839DF0 size=12
    let mut pc: u32 = 0x82839DF0;
    'dispatch: loop {
        match pc {
            0x82839DF0 => {
    //   block [0x82839DF0..0x82839DFC)
	// 82839DF0: 816302A0  lwz r11, 0x2a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(672 as u32) ) } as u64;
	// 82839DF4: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82839DF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839E00 size=12
    let mut pc: u32 = 0x82839E00;
    'dispatch: loop {
        match pc {
            0x82839E00 => {
    //   block [0x82839E00..0x82839E0C)
	// 82839E00: 816302A8  lwz r11, 0x2a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(680 as u32) ) } as u64;
	// 82839E04: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82839E08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839E10 size=12
    let mut pc: u32 = 0x82839E10;
    'dispatch: loop {
        match pc {
            0x82839E10 => {
    //   block [0x82839E10..0x82839E1C)
	// 82839E10: 816302A4  lwz r11, 0x2a4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(676 as u32) ) } as u64;
	// 82839E14: 91640018  stw r11, 0x18(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82839E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839E20 size=32
    let mut pc: u32 = 0x82839E20;
    'dispatch: loop {
        match pc {
            0x82839E20 => {
    //   block [0x82839E20..0x82839E40)
	// 82839E20: 8143028C  lwz r10, 0x28c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(652 as u32) ) } as u64;
	// 82839E24: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82839E28: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82839E2C: 81430290  lwz r10, 0x290(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(656 as u32) ) } as u64;
	// 82839E30: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82839E34: 81430294  lwz r10, 0x294(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(660 as u32) ) } as u64;
	// 82839E38: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82839E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839E40 size=28
    let mut pc: u32 = 0x82839E40;
    'dispatch: loop {
        match pc {
            0x82839E40 => {
    //   block [0x82839E40..0x82839E5C)
	// 82839E40: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82839E44: 9163028C  stw r11, 0x28c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(652 as u32), ctx.r[11].u32 ) };
	// 82839E48: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82839E4C: 91630290  stw r11, 0x290(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 82839E50: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82839E54: 91630294  stw r11, 0x294(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 82839E58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839E60 size=136
    let mut pc: u32 = 0x82839E60;
    'dispatch: loop {
        match pc {
            0x82839E60 => {
    //   block [0x82839E60..0x82839EE8)
	// 82839E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839E64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839E68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839E6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839E70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839E74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82839E78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82839E7C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82839E80: 409A0020  bne cr6, 0x82839ea0
	if !ctx.cr[6].eq {
	pc = 0x82839EA0; continue 'dispatch;
	}
	// 82839E84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82839E88: 419A0048  beq cr6, 0x82839ed0
	if ctx.cr[6].eq {
	pc = 0x82839ED0; continue 'dispatch;
	}
	// 82839E8C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82839E90: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82839E94: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82839E98: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82839E9C: 48000034  b 0x82839ed0
	pc = 0x82839ED0; continue 'dispatch;
	// 82839EA0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82839EA4: 419A002C  beq cr6, 0x82839ed0
	if ctx.cr[6].eq {
	pc = 0x82839ED0; continue 'dispatch;
	}
	// 82839EA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82839EAC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839EB0: 388B2040  addi r4, r11, 0x2040
	ctx.r[4].s64 = ctx.r[11].s64 + 8256;
	// 82839EB4: 4896E245  bl 0x831a80f8
	ctx.lr = 0x82839EB8;
	sub_831A80F8(ctx, base);
	// 82839EB8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82839EBC: 4182000C  beq 0x82839ec8
	if ctx.cr[0].eq {
	pc = 0x82839EC8; continue 'dispatch;
	}
	// 82839EC0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82839EC4: 4800000C  b 0x82839ed0
	pc = 0x82839ED0; continue 'dispatch;
	// 82839EC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82839ECC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82839ED0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839ED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839ED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839EDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839EE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839EE8 size=136
    let mut pc: u32 = 0x82839EE8;
    'dispatch: loop {
        match pc {
            0x82839EE8 => {
    //   block [0x82839EE8..0x82839F70)
	// 82839EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82839EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839EFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82839F00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82839F04: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82839F08: 409A0020  bne cr6, 0x82839f28
	if !ctx.cr[6].eq {
	pc = 0x82839F28; continue 'dispatch;
	}
	// 82839F0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82839F10: 419A0048  beq cr6, 0x82839f58
	if ctx.cr[6].eq {
	pc = 0x82839F58; continue 'dispatch;
	}
	// 82839F14: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82839F18: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82839F1C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82839F20: F97F0008  std r11, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82839F24: 48000034  b 0x82839f58
	pc = 0x82839F58; continue 'dispatch;
	// 82839F28: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 82839F2C: 419A002C  beq cr6, 0x82839f58
	if ctx.cr[6].eq {
	pc = 0x82839F58; continue 'dispatch;
	}
	// 82839F30: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82839F34: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82839F38: 388B2100  addi r4, r11, 0x2100
	ctx.r[4].s64 = ctx.r[11].s64 + 8448;
	// 82839F3C: 4896E1BD  bl 0x831a80f8
	ctx.lr = 0x82839F40;
	sub_831A80F8(ctx, base);
	// 82839F40: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82839F44: 4182000C  beq 0x82839f50
	if ctx.cr[0].eq {
	pc = 0x82839F50; continue 'dispatch;
	}
	// 82839F48: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82839F4C: 4800000C  b 0x82839f58
	pc = 0x82839F58; continue 'dispatch;
	// 82839F50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82839F54: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82839F58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82839F5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82839F60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82839F64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82839F68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82839F6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839F70 size=8
    let mut pc: u32 = 0x82839F70;
    'dispatch: loop {
        match pc {
            0x82839F70 => {
    //   block [0x82839F70..0x82839F78)
	// 82839F70: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82839F74: 480001FC  b 0x8283a170
	sub_8283A170(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82839F78 size=8
    let mut pc: u32 = 0x82839F78;
    'dispatch: loop {
        match pc {
            0x82839F78 => {
    //   block [0x82839F78..0x82839F80)
	// 82839F78: 3863FFA8  addi r3, r3, -0x58
	ctx.r[3].s64 = ctx.r[3].s64 + -88;
	// 82839F7C: 480001F4  b 0x8283a170
	sub_8283A170(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82839F80 size=108
    let mut pc: u32 = 0x82839F80;
    'dispatch: loop {
        match pc {
            0x82839F80 => {
    //   block [0x82839F80..0x82839FEC)
	// 82839F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839F84: 4896E1E9  bl 0x831a816c
	ctx.lr = 0x82839F88;
	sub_831A8130(ctx, base);
	// 82839F88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82839F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82839F90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82839F94: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82839F98: 48028B81  bl 0x82862b18
	ctx.lr = 0x82839F9C;
	sub_82862B18(ctx, base);
	// 82839F9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82839FA0: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82839FA4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82839FA8: 93BF0068  stw r29, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82839FAC: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 82839FB0: 394ACD7C  addi r10, r10, -0x3284
	ctx.r[10].s64 = ctx.r[10].s64 + -12932;
	// 82839FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839FB8: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82839FBC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82839FC0: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82839FC4: 808917D0  lwz r4, 0x17d0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(6096 as u32) ) } as u64;
	// 82839FC8: 485B9A41  bl 0x82df3a08
	ctx.lr = 0x82839FCC;
	sub_82DF3A08(ctx, base);
	// 82839FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839FD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82839FD4: 4861F715  bl 0x82e596e8
	ctx.lr = 0x82839FD8;
	sub_82E596E8(ctx, base);
	// 82839FD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82839FDC: 485B944D  bl 0x82df3428
	ctx.lr = 0x82839FE0;
	sub_82DF3428(ctx, base);
	// 82839FE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82839FE4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82839FE8: 4896E1D4  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82839FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82839FF0 size=88
    let mut pc: u32 = 0x82839FF0;
    'dispatch: loop {
        match pc {
            0x82839FF0 => {
    //   block [0x82839FF0..0x8283A048)
	// 82839FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82839FF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82839FF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82839FFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A000: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A004: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A008: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A00C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A010: 396BCD7C  addi r11, r11, -0x3284
	ctx.r[11].s64 = ctx.r[11].s64 + -12932;
	// 8283A014: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A018: 48622571  bl 0x82e5c588
	ctx.lr = 0x8283A01C;
	sub_82E5C588(ctx, base);
	// 8283A01C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283A020: 4182000C  beq 0x8283a02c
	if ctx.cr[0].eq {
	pc = 0x8283A02C; continue 'dispatch;
	}
	// 8283A024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A028: 485B83B1  bl 0x82df23d8
	ctx.lr = 0x8283A02C;
	sub_82DF23D8(ctx, base);
	// 8283A02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A030: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A034: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A038: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A03C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A048 size=96
    let mut pc: u32 = 0x8283A048;
    'dispatch: loop {
        match pc {
            0x8283A048 => {
    //   block [0x8283A048..0x8283A0A8)
	// 8283A048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A04C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A050: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A054: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A058: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A05C: 48028ABD  bl 0x82862b18
	ctx.lr = 0x8283A060;
	sub_82862B18(ctx, base);
	// 8283A060: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A064: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283A068: 396BCDCC  addi r11, r11, -0x3234
	ctx.r[11].s64 = ctx.r[11].s64 + -12852;
	// 8283A06C: 388ACDB8  addi r4, r10, -0x3248
	ctx.r[4].s64 = ctx.r[10].s64 + -12872;
	// 8283A070: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A074: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283A078: 485B9991  bl 0x82df3a08
	ctx.lr = 0x8283A07C;
	sub_82DF3A08(ctx, base);
	// 8283A07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A080: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283A084: 4861F665  bl 0x82e596e8
	ctx.lr = 0x8283A088;
	sub_82E596E8(ctx, base);
	// 8283A088: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283A08C: 485B939D  bl 0x82df3428
	ctx.lr = 0x8283A090;
	sub_82DF3428(ctx, base);
	// 8283A090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A094: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A0A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A0A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A0A8 size=112
    let mut pc: u32 = 0x8283A0A8;
    'dispatch: loop {
        match pc {
            0x8283A0A8 => {
    //   block [0x8283A0A8..0x8283A118)
	// 8283A0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A0B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A0B4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8283A0B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A0BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A0C0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8283A0C4: 48028A55  bl 0x82862b18
	ctx.lr = 0x8283A0C8;
	sub_82862B18(ctx, base);
	// 8283A0C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A0CC: D3FF0064  stfs f31, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8283A0D0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283A0D4: 396BCE24  addi r11, r11, -0x31dc
	ctx.r[11].s64 = ctx.r[11].s64 + -12764;
	// 8283A0D8: 388ACE08  addi r4, r10, -0x31f8
	ctx.r[4].s64 = ctx.r[10].s64 + -12792;
	// 8283A0DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A0E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283A0E4: 485B9925  bl 0x82df3a08
	ctx.lr = 0x8283A0E8;
	sub_82DF3A08(ctx, base);
	// 8283A0E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A0EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283A0F0: 4861F5F9  bl 0x82e596e8
	ctx.lr = 0x8283A0F4;
	sub_82E596E8(ctx, base);
	// 8283A0F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283A0F8: 485B9331  bl 0x82df3428
	ctx.lr = 0x8283A0FC;
	sub_82DF3428(ctx, base);
	// 8283A0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A100: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A10C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A118 size=88
    let mut pc: u32 = 0x8283A118;
    'dispatch: loop {
        match pc {
            0x8283A118 => {
    //   block [0x8283A118..0x8283A170)
	// 8283A118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A11C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A128: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A12C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A130: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A134: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A138: 396BCE24  addi r11, r11, -0x31dc
	ctx.r[11].s64 = ctx.r[11].s64 + -12764;
	// 8283A13C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A140: 48622449  bl 0x82e5c588
	ctx.lr = 0x8283A144;
	sub_82E5C588(ctx, base);
	// 8283A144: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283A148: 4182000C  beq 0x8283a154
	if ctx.cr[0].eq {
	pc = 0x8283A154; continue 'dispatch;
	}
	// 8283A14C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A150: 485B8289  bl 0x82df23d8
	ctx.lr = 0x8283A154;
	sub_82DF23D8(ctx, base);
	// 8283A154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A158: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A164: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A168: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A16C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A170 size=76
    let mut pc: u32 = 0x8283A170;
    'dispatch: loop {
        match pc {
            0x8283A170 => {
    //   block [0x8283A170..0x8283A1BC)
	// 8283A170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A17C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A188: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A18C: 4BFDBF3D  bl 0x828160c8
	ctx.lr = 0x8283A190;
	sub_828160C8(ctx, base);
	// 8283A190: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283A194: 4182000C  beq 0x8283a1a0
	if ctx.cr[0].eq {
	pc = 0x8283A1A0; continue 'dispatch;
	}
	// 8283A198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A19C: 485B823D  bl 0x82df23d8
	ctx.lr = 0x8283A1A0;
	sub_82DF23D8(ctx, base);
	// 8283A1A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A1A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A1A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A1AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A1B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A1B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A1B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A1C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8283A1C0 size=124
    let mut pc: u32 = 0x8283A1C0;
    'dispatch: loop {
        match pc {
            0x8283A1C0 => {
    //   block [0x8283A1C0..0x8283A23C)
	// 8283A1C0: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A23C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8283A23C size=8
    let mut pc: u32 = 0x8283A23C;
    'dispatch: loop {
        match pc {
            0x8283A23C => {
    //   block [0x8283A23C..0x8283A244)
	// 8283A23C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8283A240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A248 size=144
    let mut pc: u32 = 0x8283A248;
    'dispatch: loop {
        match pc {
            0x8283A248 => {
    //   block [0x8283A248..0x8283A2D8)
	// 8283A248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A24C: 4896DF19  bl 0x831a8164
	ctx.lr = 0x8283A250;
	sub_831A8130(ctx, base);
	// 8283A250: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A258: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A25C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8283A260: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8283A264: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8283A268: 480288B1  bl 0x82862b18
	ctx.lr = 0x8283A26C;
	sub_82862B18(ctx, base);
	// 8283A26C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283A270: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8283A274: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8283A278: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 8283A27C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283A280: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8283A284: 3D00832B  lis r8, -0x7cd5
	ctx.r[8].s64 = -2094333952;
	// 8283A288: 937F0070  stw r27, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 8283A28C: 3929CE64  addi r9, r9, -0x319c
	ctx.r[9].s64 = ctx.r[9].s64 + -12700;
	// 8283A290: C00B08A4  lfs f0, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A294: 396836FC  addi r11, r8, 0x36fc
	ctx.r[11].s64 = ctx.r[8].s64 + 14076;
	// 8283A298: C1AA959C  lfs f13, -0x6a64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A29C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283A2A0: D01F0074  stfs f0, 0x74(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8283A2A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8283A2A8: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8283A2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A2B0: 812836FC  lwz r9, 0x36fc(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(14076 as u32) ) } as u64;
	// 8283A2B4: 913F007C  stw r9, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 8283A2B8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283A2BC: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8283A2C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283A2C4: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8283A2C8: 995F008C  stb r10, 0x8c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 8283A2CC: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8283A2D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283A2D4: 4896DEE0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A2D8 size=120
    let mut pc: u32 = 0x8283A2D8;
    'dispatch: loop {
        match pc {
            0x8283A2D8 => {
    //   block [0x8283A2D8..0x8283A350)
	// 8283A2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A2DC: 4896DE89  bl 0x831a8164
	ctx.lr = 0x8283A2E0;
	sub_831A8130(ctx, base);
	// 8283A2E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A2E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A2E8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A2EC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8283A2F0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8283A2F4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8283A2F8: 48028821  bl 0x82862b18
	ctx.lr = 0x8283A2FC;
	sub_82862B18(ctx, base);
	// 8283A2FC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283A300: 937F0064  stw r27, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 8283A304: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283A308: 939F0068  stw r28, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 8283A30C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283A310: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 8283A314: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 8283A318: 93BF0070  stw r29, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 8283A31C: 3D008206  lis r8, -0x7dfa
	ctx.r[8].s64 = -2113536000;
	// 8283A320: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 8283A324: 394ACEA4  addi r10, r10, -0x315c
	ctx.r[10].s64 = ctx.r[10].s64 + -12636;
	// 8283A328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A32C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8283A330: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283A334: C008CFA8  lfs f0, -0x3058(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12376 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A338: C1A708A4  lfs f13, 0x8a4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A350 size=76
    let mut pc: u32 = 0x8283A350;
    'dispatch: loop {
        match pc {
            0x8283A350 => {
    //   block [0x8283A350..0x8283A39C)
	// 8283A350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A35C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A368: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A36C: 480287AD  bl 0x82862b18
	ctx.lr = 0x8283A370;
	sub_82862B18(ctx, base);
	// 8283A370: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A374: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8283A378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A37C: 396BCEE4  addi r11, r11, -0x311c
	ctx.r[11].s64 = ctx.r[11].s64 + -12572;
	// 8283A380: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A384: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A388: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A38C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A390: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A394: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A398: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A3A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A3A0 size=148
    let mut pc: u32 = 0x8283A3A0;
    'dispatch: loop {
        match pc {
            0x8283A3A0 => {
    //   block [0x8283A3A0..0x8283A434)
	// 8283A3A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A3A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A3A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A3AC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A3B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A3B4: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283A3B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283A3BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283A3C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283A3C4: 4E800421  bctrl
	ctx.lr = 0x8283A3C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283A3C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283A3CC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 8283A3D0: 3D208338  lis r9, -0x7cc8
	ctx.r[9].s64 = -2093481984;
	// 8283A3D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283A3D8: 38A96910  addi r5, r9, 0x6910
	ctx.r[5].s64 = ctx.r[9].s64 + 26896;
	// 8283A3DC: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A3E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283A3E4: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A3E8: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283A3EC: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283A3F0: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283A3F4: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8283A3F8: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283A3FC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283A400: C02A9F78  lfs f1, -0x6088(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283A404: 4864323D  bl 0x82e7d640
	ctx.lr = 0x8283A408;
	sub_82E7D640(ctx, base);
	// 8283A408: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283A40C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283A410: 48641BC9  bl 0x82e7bfd8
	ctx.lr = 0x8283A414;
	sub_82E7BFD8(ctx, base);
	// 8283A414: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283A418: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283A41C: 485D8E45  bl 0x82e13260
	ctx.lr = 0x8283A420;
	sub_82E13260(ctx, base);
	// 8283A420: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8283A424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A42C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A438 size=108
    let mut pc: u32 = 0x8283A438;
    'dispatch: loop {
        match pc {
            0x8283A438 => {
    //   block [0x8283A438..0x8283A4A4)
	// 8283A438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A43C: 4896DD29  bl 0x831a8164
	ctx.lr = 0x8283A440;
	sub_831A8130(ctx, base);
	// 8283A440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A448: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A44C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8283A450: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8283A454: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 8283A458: 480286C1  bl 0x82862b18
	ctx.lr = 0x8283A45C;
	sub_82862B18(ctx, base);
	// 8283A45C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283A460: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 8283A464: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283A468: 937F0068  stw r27, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 8283A46C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283A470: 93BF006C  stw r29, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 8283A474: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 8283A478: 939F0070  stw r28, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 8283A47C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 8283A480: 394ACF24  addi r10, r10, -0x30dc
	ctx.r[10].s64 = ctx.r[10].s64 + -12508;
	// 8283A484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A488: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8283A48C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A4A8 size=156
    let mut pc: u32 = 0x8283A4A8;
    'dispatch: loop {
        match pc {
            0x8283A4A8 => {
    //   block [0x8283A4A8..0x8283A544)
	// 8283A4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A4B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A4BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A4C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A4C4: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283A4C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283A4CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283A4D0: 419A005C  beq cr6, 0x8283a52c
	if ctx.cr[6].eq {
	pc = 0x8283A52C; continue 'dispatch;
	}
	// 8283A4D4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283A4D8: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283A4DC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8283A4E0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283A4E4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8283A4E8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8283A548 size=92
    let mut pc: u32 = 0x8283A548;
    'dispatch: loop {
        match pc {
            0x8283A548 => {
    //   block [0x8283A548..0x8283A5A4)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A5A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8283A5A4 size=8
    let mut pc: u32 = 0x8283A5A4;
    'dispatch: loop {
        match pc {
            0x8283A5A4 => {
    //   block [0x8283A5A4..0x8283A5AC)
	// 8283A5A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8283A5A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A5B0 size=96
    let mut pc: u32 = 0x8283A5B0;
    'dispatch: loop {
        match pc {
            0x8283A5B0 => {
    //   block [0x8283A5B0..0x8283A610)
	// 8283A5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A5B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A5B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A5BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A5C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A5C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A5C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283A5CC: 4802854D  bl 0x82862b18
	ctx.lr = 0x8283A5D0;
	sub_82862B18(ctx, base);
	// 8283A5D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A5D4: 39400070  li r10, 0x70
	ctx.r[10].s64 = 112;
	// 8283A5D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8283A5DC: 396BCF64  addi r11, r11, -0x309c
	ctx.r[11].s64 = ctx.r[11].s64 + -12444;
	// 8283A5E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A5E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A5E8: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A610 size=164
    let mut pc: u32 = 0x8283A610;
    'dispatch: loop {
        match pc {
            0x8283A610 => {
    //   block [0x8283A610..0x8283A6B4)
	// 8283A610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A618: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A61C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A620: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283A624: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283A628: C01F031C  lfs f0, 0x31c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A62C: C1BF02C0  lfs f13, 0x2c0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(704 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A630: EC0D007A  fmadds f0, f13, f1, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 8283A634: C1ABD200  lfs f13, -0x2e00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11776 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A638: D01F031C  stfs f0, 0x31c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(796 as u32), tmp.u32 ) };
	// 8283A63C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8283A640: 4099000C  ble cr6, 0x8283a64c
	if !ctx.cr[6].gt {
	pc = 0x8283A64C; continue 'dispatch;
	}
	// 8283A644: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8283A648: D01F031C  stfs f0, 0x31c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(796 as u32), tmp.u32 ) };
	// 8283A64C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283A650: C1BF031C  lfs f13, 0x31c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(796 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A654: C00BCEE4  lfs f0, -0x311c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12572 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A658: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8283A65C: 4896E76D  bl 0x831a8dc8
	ctx.lr = 0x8283A660;
	sub_831A8DC8(ctx, base);
	// 8283A660: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8283A664: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 8283A668: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283A66C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283A670: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283A674: C1ABACFC  lfs f13, -0x5304(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21252 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A678: C00A08A4  lfs f0, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A67C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283A680: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283A684: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283A688: EC0C0372  fmuls f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8283A68C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8283A690: 48641949  bl 0x82e7bfd8
	ctx.lr = 0x8283A694;
	sub_82E7BFD8(ctx, base);
	// 8283A694: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283A698: 807F0314  lwz r3, 0x314(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(788 as u32) ) } as u64;
	// 8283A69C: 485D8BC5  bl 0x82e13260
	ctx.lr = 0x8283A6A0;
	sub_82E13260(ctx, base);
	// 8283A6A0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8283A6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A6AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A6B8 size=180
    let mut pc: u32 = 0x8283A6B8;
    'dispatch: loop {
        match pc {
            0x8283A6B8 => {
    //   block [0x8283A6B8..0x8283A76C)
	// 8283A6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A6BC: 4896DAB1  bl 0x831a816c
	ctx.lr = 0x8283A6C0;
	sub_831A8130(ctx, base);
	// 8283A6C0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8283A6C4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8283A6C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A6CC: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283A6D0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8283A6D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283A6D8: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283A6DC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283A6E0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8283A6E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283A6E8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8283A770 size=20
    let mut pc: u32 = 0x8283A770;
    'dispatch: loop {
        match pc {
            0x8283A770 => {
    //   block [0x8283A770..0x8283A784)
	// 8283A770: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 8283A774: 39400330  li r10, 0x330
	ctx.r[10].s64 = 816;
	// 8283A778: 13E458C7  vcmpequd (lvx128) v31, v4, v11
	tmp.u32 = ctx.r[4].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283A788 size=140
    let mut pc: u32 = 0x8283A788;
    'dispatch: loop {
        match pc {
            0x8283A788 => {
    //   block [0x8283A788..0x8283A814)
	// 8283A788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A794: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A798: 8163025C  lwz r11, 0x25c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(604 as u32) ) } as u64;
	// 8283A79C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283A7A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283A7A4: 419A004C  beq cr6, 0x8283a7f0
	if ctx.cr[6].eq {
	pc = 0x8283A7F0; continue 'dispatch;
	}
	// 8283A7A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283A7AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8283A7B0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8283A7B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283A7B8: 4E800421  bctrl
	ctx.lr = 0x8283A7BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283A7BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8283A7C0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8283A7C4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283A7C8: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283A7CC: C1830038  lfs f12, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283A7D0: C163003C  lfs f11, 0x3c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283A7D4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283A7D8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8283A7DC: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283A7E0: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283A7E4: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A818 size=196
    let mut pc: u32 = 0x8283A818;
    'dispatch: loop {
        match pc {
            0x8283A818 => {
    //   block [0x8283A818..0x8283A8DC)
	// 8283A818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A82C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283A830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283A834: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283A838: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283A83C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A840: 4BA860F9  bl 0x822c0938
	ctx.lr = 0x8283A844;
	sub_822C0938(ctx, base);
	// 8283A844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283A848: 41820028  beq 0x8283a870
	if ctx.cr[0].eq {
	pc = 0x8283A870; continue 'dispatch;
	}
	// 8283A84C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A850: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283A854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283A858: 392BCBB0  addi r9, r11, -0x3450
	ctx.r[9].s64 = ctx.r[11].s64 + -13392;
	// 8283A85C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283A860: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283A864: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283A868: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283A86C: 48000008  b 0x8283a874
	pc = 0x8283A874; continue 'dispatch;
	// 8283A870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283A874: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283A87C: 409A0044  bne cr6, 0x8283a8c0
	if !ctx.cr[6].eq {
	pc = 0x8283A8C0; continue 'dispatch;
	}
	// 8283A880: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283A884: 419A001C  beq cr6, 0x8283a8a0
	if ctx.cr[6].eq {
	pc = 0x8283A8A0; continue 'dispatch;
	}
	// 8283A888: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283A88C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283A890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283A898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283A89C: 4E800421  bctrl
	ctx.lr = 0x8283A8A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283A8A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283A8A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283A8A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283A8AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283A8B0: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283A8B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283A8B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283A8BC: 4BA85745  bl 0x822c0000
	ctx.lr = 0x8283A8C0;
	sub_822C0000(ctx, base);
	// 8283A8C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283A8C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A8C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A8CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A8D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A8D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A8D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A8E0 size=196
    let mut pc: u32 = 0x8283A8E0;
    'dispatch: loop {
        match pc {
            0x8283A8E0 => {
    //   block [0x8283A8E0..0x8283A9A4)
	// 8283A8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A8E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A8EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A8F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A8F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283A8F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283A8FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283A900: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283A904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A908: 4BA86031  bl 0x822c0938
	ctx.lr = 0x8283A90C;
	sub_822C0938(ctx, base);
	// 8283A90C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283A910: 41820028  beq 0x8283a938
	if ctx.cr[0].eq {
	pc = 0x8283A938; continue 'dispatch;
	}
	// 8283A914: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A918: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283A91C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283A920: 392BCBC4  addi r9, r11, -0x343c
	ctx.r[9].s64 = ctx.r[11].s64 + -13372;
	// 8283A924: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283A928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283A92C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283A930: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283A934: 48000008  b 0x8283a93c
	pc = 0x8283A93C; continue 'dispatch;
	// 8283A938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283A93C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283A944: 409A0044  bne cr6, 0x8283a988
	if !ctx.cr[6].eq {
	pc = 0x8283A988; continue 'dispatch;
	}
	// 8283A948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283A94C: 419A001C  beq cr6, 0x8283a968
	if ctx.cr[6].eq {
	pc = 0x8283A968; continue 'dispatch;
	}
	// 8283A950: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283A954: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283A958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283A95C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283A960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283A964: 4E800421  bctrl
	ctx.lr = 0x8283A968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283A968: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283A96C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283A970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283A974: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283A978: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283A97C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283A980: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283A984: 4BA8567D  bl 0x822c0000
	ctx.lr = 0x8283A988;
	sub_822C0000(ctx, base);
	// 8283A988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283A98C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283A990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283A994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283A998: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283A99C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283A9A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283A9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283A9A8 size=196
    let mut pc: u32 = 0x8283A9A8;
    'dispatch: loop {
        match pc {
            0x8283A9A8 => {
    //   block [0x8283A9A8..0x8283AA6C)
	// 8283A9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283A9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283A9B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283A9B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283A9B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283A9BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283A9C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283A9C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283A9C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283A9CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283A9D0: 4BA85F69  bl 0x822c0938
	ctx.lr = 0x8283A9D4;
	sub_822C0938(ctx, base);
	// 8283A9D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283A9D8: 41820028  beq 0x8283aa00
	if ctx.cr[0].eq {
	pc = 0x8283AA00; continue 'dispatch;
	}
	// 8283A9DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283A9E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283A9E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283A9E8: 392BCBD8  addi r9, r11, -0x3428
	ctx.r[9].s64 = ctx.r[11].s64 + -13352;
	// 8283A9EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283A9F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283A9F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283A9F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283A9FC: 48000008  b 0x8283aa04
	pc = 0x8283AA04; continue 'dispatch;
	// 8283AA00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AA04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AA0C: 409A0044  bne cr6, 0x8283aa50
	if !ctx.cr[6].eq {
	pc = 0x8283AA50; continue 'dispatch;
	}
	// 8283AA10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283AA14: 419A001C  beq cr6, 0x8283aa30
	if ctx.cr[6].eq {
	pc = 0x8283AA30; continue 'dispatch;
	}
	// 8283AA18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AA1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AA24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283AA28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AA2C: 4E800421  bctrl
	ctx.lr = 0x8283AA30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AA30: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AA34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AA38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AA3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AA40: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AA44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283AA48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283AA4C: 4BA855B5  bl 0x822c0000
	ctx.lr = 0x8283AA50;
	sub_822C0000(ctx, base);
	// 8283AA50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283AA54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283AA58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283AA5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283AA60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283AA64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283AA68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AA70 size=196
    let mut pc: u32 = 0x8283AA70;
    'dispatch: loop {
        match pc {
            0x8283AA70 => {
    //   block [0x8283AA70..0x8283AB34)
	// 8283AA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AA74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AA78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AA7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283AA80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283AA84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283AA88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AA8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283AA90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283AA94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AA98: 4BA85EA1  bl 0x822c0938
	ctx.lr = 0x8283AA9C;
	sub_822C0938(ctx, base);
	// 8283AA9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283AAA0: 41820028  beq 0x8283aac8
	if ctx.cr[0].eq {
	pc = 0x8283AAC8; continue 'dispatch;
	}
	// 8283AAA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283AAA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283AAAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283AAB0: 392BCBEC  addi r9, r11, -0x3414
	ctx.r[9].s64 = ctx.r[11].s64 + -13332;
	// 8283AAB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283AAB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283AABC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283AAC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283AAC4: 48000008  b 0x8283aacc
	pc = 0x8283AACC; continue 'dispatch;
	// 8283AAC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AACC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AAD4: 409A0044  bne cr6, 0x8283ab18
	if !ctx.cr[6].eq {
	pc = 0x8283AB18; continue 'dispatch;
	}
	// 8283AAD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283AADC: 419A001C  beq cr6, 0x8283aaf8
	if ctx.cr[6].eq {
	pc = 0x8283AAF8; continue 'dispatch;
	}
	// 8283AAE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AAE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AAE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AAEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283AAF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AAF4: 4E800421  bctrl
	ctx.lr = 0x8283AAF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AAF8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AAFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AB04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AB08: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AB0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283AB10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283AB14: 4BA854ED  bl 0x822c0000
	ctx.lr = 0x8283AB18;
	sub_822C0000(ctx, base);
	// 8283AB18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283AB1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283AB20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283AB24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283AB28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283AB2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283AB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AB38 size=196
    let mut pc: u32 = 0x8283AB38;
    'dispatch: loop {
        match pc {
            0x8283AB38 => {
    //   block [0x8283AB38..0x8283ABFC)
	// 8283AB38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AB3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AB40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AB44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283AB48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283AB4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283AB50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AB54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283AB58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283AB5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AB60: 4BA85DD9  bl 0x822c0938
	ctx.lr = 0x8283AB64;
	sub_822C0938(ctx, base);
	// 8283AB64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283AB68: 41820028  beq 0x8283ab90
	if ctx.cr[0].eq {
	pc = 0x8283AB90; continue 'dispatch;
	}
	// 8283AB6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283AB70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283AB74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283AB78: 392BCC00  addi r9, r11, -0x3400
	ctx.r[9].s64 = ctx.r[11].s64 + -13312;
	// 8283AB7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283AB80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283AB84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283AB88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283AB8C: 48000008  b 0x8283ab94
	pc = 0x8283AB94; continue 'dispatch;
	// 8283AB90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AB94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AB9C: 409A0044  bne cr6, 0x8283abe0
	if !ctx.cr[6].eq {
	pc = 0x8283ABE0; continue 'dispatch;
	}
	// 8283ABA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283ABA4: 419A001C  beq cr6, 0x8283abc0
	if ctx.cr[6].eq {
	pc = 0x8283ABC0; continue 'dispatch;
	}
	// 8283ABA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283ABAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283ABB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283ABB4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283ABB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283ABBC: 4E800421  bctrl
	ctx.lr = 0x8283ABC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283ABC0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283ABC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283ABC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283ABCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283ABD0: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283ABD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283ABD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283ABDC: 4BA85425  bl 0x822c0000
	ctx.lr = 0x8283ABE0;
	sub_822C0000(ctx, base);
	// 8283ABE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283ABE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283ABE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283ABEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283ABF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283ABF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283ABF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AC00 size=196
    let mut pc: u32 = 0x8283AC00;
    'dispatch: loop {
        match pc {
            0x8283AC00 => {
    //   block [0x8283AC00..0x8283ACC4)
	// 8283AC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AC04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AC08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AC0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283AC10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283AC14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283AC18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AC1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283AC20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283AC24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AC28: 4BA85D11  bl 0x822c0938
	ctx.lr = 0x8283AC2C;
	sub_822C0938(ctx, base);
	// 8283AC2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283AC30: 41820028  beq 0x8283ac58
	if ctx.cr[0].eq {
	pc = 0x8283AC58; continue 'dispatch;
	}
	// 8283AC34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283AC38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283AC3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283AC40: 392BCC14  addi r9, r11, -0x33ec
	ctx.r[9].s64 = ctx.r[11].s64 + -13292;
	// 8283AC44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283AC48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283AC4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283AC50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283AC54: 48000008  b 0x8283ac5c
	pc = 0x8283AC5C; continue 'dispatch;
	// 8283AC58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AC5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AC64: 409A0044  bne cr6, 0x8283aca8
	if !ctx.cr[6].eq {
	pc = 0x8283ACA8; continue 'dispatch;
	}
	// 8283AC68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283AC6C: 419A001C  beq cr6, 0x8283ac88
	if ctx.cr[6].eq {
	pc = 0x8283AC88; continue 'dispatch;
	}
	// 8283AC70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AC74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AC78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AC7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283AC80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AC84: 4E800421  bctrl
	ctx.lr = 0x8283AC88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AC88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AC8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AC90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AC94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AC98: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AC9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283ACA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283ACA4: 4BA8535D  bl 0x822c0000
	ctx.lr = 0x8283ACA8;
	sub_822C0000(ctx, base);
	// 8283ACA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283ACAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283ACB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283ACB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283ACB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283ACBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283ACC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283ACC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283ACC8 size=196
    let mut pc: u32 = 0x8283ACC8;
    'dispatch: loop {
        match pc {
            0x8283ACC8 => {
    //   block [0x8283ACC8..0x8283AD8C)
	// 8283ACC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283ACCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283ACD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283ACD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283ACD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283ACDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283ACE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283ACE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283ACE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283ACEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283ACF0: 4BA85C49  bl 0x822c0938
	ctx.lr = 0x8283ACF4;
	sub_822C0938(ctx, base);
	// 8283ACF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283ACF8: 41820028  beq 0x8283ad20
	if ctx.cr[0].eq {
	pc = 0x8283AD20; continue 'dispatch;
	}
	// 8283ACFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283AD00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283AD04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283AD08: 392BCC28  addi r9, r11, -0x33d8
	ctx.r[9].s64 = ctx.r[11].s64 + -13272;
	// 8283AD0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283AD10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283AD14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283AD18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283AD1C: 48000008  b 0x8283ad24
	pc = 0x8283AD24; continue 'dispatch;
	// 8283AD20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AD24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AD28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AD2C: 409A0044  bne cr6, 0x8283ad70
	if !ctx.cr[6].eq {
	pc = 0x8283AD70; continue 'dispatch;
	}
	// 8283AD30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283AD34: 419A001C  beq cr6, 0x8283ad50
	if ctx.cr[6].eq {
	pc = 0x8283AD50; continue 'dispatch;
	}
	// 8283AD38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AD3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AD40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AD44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AD48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AD4C: 4E800421  bctrl
	ctx.lr = 0x8283AD50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AD50: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AD54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AD58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AD5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AD60: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AD64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283AD68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283AD6C: 4BA85295  bl 0x822c0000
	ctx.lr = 0x8283AD70;
	sub_822C0000(ctx, base);
	// 8283AD70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283AD74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283AD78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283AD7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283AD80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283AD84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283AD88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AD90 size=196
    let mut pc: u32 = 0x8283AD90;
    'dispatch: loop {
        match pc {
            0x8283AD90 => {
    //   block [0x8283AD90..0x8283AE54)
	// 8283AD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AD98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AD9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283ADA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283ADA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283ADA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283ADAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283ADB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283ADB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283ADB8: 4BA85B81  bl 0x822c0938
	ctx.lr = 0x8283ADBC;
	sub_822C0938(ctx, base);
	// 8283ADBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283ADC0: 41820028  beq 0x8283ade8
	if ctx.cr[0].eq {
	pc = 0x8283ADE8; continue 'dispatch;
	}
	// 8283ADC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283ADC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283ADCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283ADD0: 392BCC3C  addi r9, r11, -0x33c4
	ctx.r[9].s64 = ctx.r[11].s64 + -13252;
	// 8283ADD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283ADD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283ADDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283ADE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283ADE4: 48000008  b 0x8283adec
	pc = 0x8283ADEC; continue 'dispatch;
	// 8283ADE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283ADEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283ADF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283ADF4: 409A0044  bne cr6, 0x8283ae38
	if !ctx.cr[6].eq {
	pc = 0x8283AE38; continue 'dispatch;
	}
	// 8283ADF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283ADFC: 419A001C  beq cr6, 0x8283ae18
	if ctx.cr[6].eq {
	pc = 0x8283AE18; continue 'dispatch;
	}
	// 8283AE00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AE04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AE08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AE0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AE10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AE14: 4E800421  bctrl
	ctx.lr = 0x8283AE18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AE18: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AE1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AE20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AE24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AE28: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AE2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283AE30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283AE34: 4BA851CD  bl 0x822c0000
	ctx.lr = 0x8283AE38;
	sub_822C0000(ctx, base);
	// 8283AE38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283AE3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283AE40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283AE44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283AE48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283AE4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283AE50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AE58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AE58 size=196
    let mut pc: u32 = 0x8283AE58;
    'dispatch: loop {
        match pc {
            0x8283AE58 => {
    //   block [0x8283AE58..0x8283AF1C)
	// 8283AE58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AE5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AE60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AE64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283AE68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283AE6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283AE70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AE74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283AE78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283AE7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AE80: 4BA85AB9  bl 0x822c0938
	ctx.lr = 0x8283AE84;
	sub_822C0938(ctx, base);
	// 8283AE84: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283AE88: 41820028  beq 0x8283aeb0
	if ctx.cr[0].eq {
	pc = 0x8283AEB0; continue 'dispatch;
	}
	// 8283AE8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283AE90: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283AE94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283AE98: 392BCC50  addi r9, r11, -0x33b0
	ctx.r[9].s64 = ctx.r[11].s64 + -13232;
	// 8283AE9C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283AEA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283AEA4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283AEA8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283AEAC: 48000008  b 0x8283aeb4
	pc = 0x8283AEB4; continue 'dispatch;
	// 8283AEB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AEB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AEBC: 409A0044  bne cr6, 0x8283af00
	if !ctx.cr[6].eq {
	pc = 0x8283AF00; continue 'dispatch;
	}
	// 8283AEC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283AEC4: 419A001C  beq cr6, 0x8283aee0
	if ctx.cr[6].eq {
	pc = 0x8283AEE0; continue 'dispatch;
	}
	// 8283AEC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AECC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AED4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AED8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AEDC: 4E800421  bctrl
	ctx.lr = 0x8283AEE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AEE0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AEE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AEE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AEEC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AEF0: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AEF4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283AEF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283AEFC: 4BA85105  bl 0x822c0000
	ctx.lr = 0x8283AF00;
	sub_822C0000(ctx, base);
	// 8283AF00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283AF04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283AF08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283AF0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283AF10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283AF14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283AF18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AF20 size=196
    let mut pc: u32 = 0x8283AF20;
    'dispatch: loop {
        match pc {
            0x8283AF20 => {
    //   block [0x8283AF20..0x8283AFE4)
	// 8283AF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AF24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AF28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AF2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283AF30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283AF34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283AF38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AF3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283AF40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283AF44: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AF48: 4BA859F1  bl 0x822c0938
	ctx.lr = 0x8283AF4C;
	sub_822C0938(ctx, base);
	// 8283AF4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283AF50: 41820028  beq 0x8283af78
	if ctx.cr[0].eq {
	pc = 0x8283AF78; continue 'dispatch;
	}
	// 8283AF54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283AF58: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283AF5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283AF60: 392BCC64  addi r9, r11, -0x339c
	ctx.r[9].s64 = ctx.r[11].s64 + -13212;
	// 8283AF64: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283AF68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283AF6C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283AF70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283AF74: 48000008  b 0x8283af7c
	pc = 0x8283AF7C; continue 'dispatch;
	// 8283AF78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283AF7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283AF80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283AF84: 409A0044  bne cr6, 0x8283afc8
	if !ctx.cr[6].eq {
	pc = 0x8283AFC8; continue 'dispatch;
	}
	// 8283AF88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283AF8C: 419A001C  beq cr6, 0x8283afa8
	if ctx.cr[6].eq {
	pc = 0x8283AFA8; continue 'dispatch;
	}
	// 8283AF90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AF94: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283AF98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283AF9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283AFA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283AFA4: 4E800421  bctrl
	ctx.lr = 0x8283AFA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283AFA8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283AFAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283AFB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283AFB4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283AFB8: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283AFBC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283AFC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283AFC4: 4BA8503D  bl 0x822c0000
	ctx.lr = 0x8283AFC8;
	sub_822C0000(ctx, base);
	// 8283AFC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283AFCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283AFD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283AFD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283AFD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283AFDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283AFE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283AFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283AFE8 size=196
    let mut pc: u32 = 0x8283AFE8;
    'dispatch: loop {
        match pc {
            0x8283AFE8 => {
    //   block [0x8283AFE8..0x8283B0AC)
	// 8283AFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283AFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283AFF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283AFF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283AFF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283AFFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B000: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B004: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B008: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B00C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B010: 4BA85929  bl 0x822c0938
	ctx.lr = 0x8283B014;
	sub_822C0938(ctx, base);
	// 8283B014: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B018: 41820028  beq 0x8283b040
	if ctx.cr[0].eq {
	pc = 0x8283B040; continue 'dispatch;
	}
	// 8283B01C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B020: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B024: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B028: 392BCC78  addi r9, r11, -0x3388
	ctx.r[9].s64 = ctx.r[11].s64 + -13192;
	// 8283B02C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B030: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B034: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B038: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B03C: 48000008  b 0x8283b044
	pc = 0x8283B044; continue 'dispatch;
	// 8283B040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B044: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B048: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B04C: 409A0044  bne cr6, 0x8283b090
	if !ctx.cr[6].eq {
	pc = 0x8283B090; continue 'dispatch;
	}
	// 8283B050: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B054: 419A001C  beq cr6, 0x8283b070
	if ctx.cr[6].eq {
	pc = 0x8283B070; continue 'dispatch;
	}
	// 8283B058: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B05C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283B068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B06C: 4E800421  bctrl
	ctx.lr = 0x8283B070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B070: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B074: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B078: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B07C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B080: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B084: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B088: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B08C: 4BA84F75  bl 0x822c0000
	ctx.lr = 0x8283B090;
	sub_822C0000(ctx, base);
	// 8283B090: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B094: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B098: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B09C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B0A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B0A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B0A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B0B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B0B0 size=196
    let mut pc: u32 = 0x8283B0B0;
    'dispatch: loop {
        match pc {
            0x8283B0B0 => {
    //   block [0x8283B0B0..0x8283B174)
	// 8283B0B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B0B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B0B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B0BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B0C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B0C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B0C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B0CC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B0D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B0D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B0D8: 4BA85861  bl 0x822c0938
	ctx.lr = 0x8283B0DC;
	sub_822C0938(ctx, base);
	// 8283B0DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B0E0: 41820028  beq 0x8283b108
	if ctx.cr[0].eq {
	pc = 0x8283B108; continue 'dispatch;
	}
	// 8283B0E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B0E8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B0EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B0F0: 392BCC8C  addi r9, r11, -0x3374
	ctx.r[9].s64 = ctx.r[11].s64 + -13172;
	// 8283B0F4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B0F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B0FC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B100: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B104: 48000008  b 0x8283b10c
	pc = 0x8283B10C; continue 'dispatch;
	// 8283B108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B10C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B114: 409A0044  bne cr6, 0x8283b158
	if !ctx.cr[6].eq {
	pc = 0x8283B158; continue 'dispatch;
	}
	// 8283B118: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B11C: 419A001C  beq cr6, 0x8283b138
	if ctx.cr[6].eq {
	pc = 0x8283B138; continue 'dispatch;
	}
	// 8283B120: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B124: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B12C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283B130: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B134: 4E800421  bctrl
	ctx.lr = 0x8283B138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B138: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B13C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B140: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B144: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B148: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B14C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B150: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B154: 4BA84EAD  bl 0x822c0000
	ctx.lr = 0x8283B158;
	sub_822C0000(ctx, base);
	// 8283B158: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B15C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B16C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B178 size=196
    let mut pc: u32 = 0x8283B178;
    'dispatch: loop {
        match pc {
            0x8283B178 => {
    //   block [0x8283B178..0x8283B23C)
	// 8283B178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B17C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B180: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B184: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B188: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B18C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B194: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B198: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B19C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B1A0: 4BA85799  bl 0x822c0938
	ctx.lr = 0x8283B1A4;
	sub_822C0938(ctx, base);
	// 8283B1A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B1A8: 41820028  beq 0x8283b1d0
	if ctx.cr[0].eq {
	pc = 0x8283B1D0; continue 'dispatch;
	}
	// 8283B1AC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B1B0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B1B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B1B8: 392BCCA0  addi r9, r11, -0x3360
	ctx.r[9].s64 = ctx.r[11].s64 + -13152;
	// 8283B1BC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B1C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B1C4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B1C8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B1CC: 48000008  b 0x8283b1d4
	pc = 0x8283B1D4; continue 'dispatch;
	// 8283B1D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B1D4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B1D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B1DC: 409A0044  bne cr6, 0x8283b220
	if !ctx.cr[6].eq {
	pc = 0x8283B220; continue 'dispatch;
	}
	// 8283B1E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B1E4: 419A001C  beq cr6, 0x8283b200
	if ctx.cr[6].eq {
	pc = 0x8283B200; continue 'dispatch;
	}
	// 8283B1E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B1EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B1F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283B1F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B1FC: 4E800421  bctrl
	ctx.lr = 0x8283B200;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B200: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B204: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B208: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B20C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B210: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B214: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B218: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B21C: 4BA84DE5  bl 0x822c0000
	ctx.lr = 0x8283B220;
	sub_822C0000(ctx, base);
	// 8283B220: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B224: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B228: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B22C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B230: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B240 size=196
    let mut pc: u32 = 0x8283B240;
    'dispatch: loop {
        match pc {
            0x8283B240 => {
    //   block [0x8283B240..0x8283B304)
	// 8283B240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B24C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B254: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B258: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B25C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B260: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B264: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B268: 4BA856D1  bl 0x822c0938
	ctx.lr = 0x8283B26C;
	sub_822C0938(ctx, base);
	// 8283B26C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B270: 41820028  beq 0x8283b298
	if ctx.cr[0].eq {
	pc = 0x8283B298; continue 'dispatch;
	}
	// 8283B274: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B278: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B27C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B280: 392BCCB4  addi r9, r11, -0x334c
	ctx.r[9].s64 = ctx.r[11].s64 + -13132;
	// 8283B284: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B288: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B28C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B290: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B294: 48000008  b 0x8283b29c
	pc = 0x8283B29C; continue 'dispatch;
	// 8283B298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B29C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B2A4: 409A0044  bne cr6, 0x8283b2e8
	if !ctx.cr[6].eq {
	pc = 0x8283B2E8; continue 'dispatch;
	}
	// 8283B2A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B2AC: 419A001C  beq cr6, 0x8283b2c8
	if ctx.cr[6].eq {
	pc = 0x8283B2C8; continue 'dispatch;
	}
	// 8283B2B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B2B4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B2BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283B2C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B2C4: 4E800421  bctrl
	ctx.lr = 0x8283B2C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B2C8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B2CC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B2D4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B2D8: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B2DC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B2E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B2E4: 4BA84D1D  bl 0x822c0000
	ctx.lr = 0x8283B2E8;
	sub_822C0000(ctx, base);
	// 8283B2E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B2EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B2F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B2F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B2F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B2FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B308 size=196
    let mut pc: u32 = 0x8283B308;
    'dispatch: loop {
        match pc {
            0x8283B308 => {
    //   block [0x8283B308..0x8283B3CC)
	// 8283B308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B310: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B314: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B31C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B320: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B324: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B328: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B32C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B330: 4BA85609  bl 0x822c0938
	ctx.lr = 0x8283B334;
	sub_822C0938(ctx, base);
	// 8283B334: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B338: 41820028  beq 0x8283b360
	if ctx.cr[0].eq {
	pc = 0x8283B360; continue 'dispatch;
	}
	// 8283B33C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B340: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B344: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B348: 392BCCC8  addi r9, r11, -0x3338
	ctx.r[9].s64 = ctx.r[11].s64 + -13112;
	// 8283B34C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B350: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B354: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B358: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B35C: 48000008  b 0x8283b364
	pc = 0x8283B364; continue 'dispatch;
	// 8283B360: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B364: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B36C: 409A0044  bne cr6, 0x8283b3b0
	if !ctx.cr[6].eq {
	pc = 0x8283B3B0; continue 'dispatch;
	}
	// 8283B370: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B374: 419A001C  beq cr6, 0x8283b390
	if ctx.cr[6].eq {
	pc = 0x8283B390; continue 'dispatch;
	}
	// 8283B378: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B37C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B384: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B388: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B38C: 4E800421  bctrl
	ctx.lr = 0x8283B390;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B390: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B394: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B398: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B39C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B3A0: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B3A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B3A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B3AC: 4BA84C55  bl 0x822c0000
	ctx.lr = 0x8283B3B0;
	sub_822C0000(ctx, base);
	// 8283B3B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B3B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B3C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B3C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B3D0 size=196
    let mut pc: u32 = 0x8283B3D0;
    'dispatch: loop {
        match pc {
            0x8283B3D0 => {
    //   block [0x8283B3D0..0x8283B494)
	// 8283B3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B3D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B3DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B3E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B3E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B3E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B3EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B3F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B3F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B3F8: 4BA85541  bl 0x822c0938
	ctx.lr = 0x8283B3FC;
	sub_822C0938(ctx, base);
	// 8283B3FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B400: 41820028  beq 0x8283b428
	if ctx.cr[0].eq {
	pc = 0x8283B428; continue 'dispatch;
	}
	// 8283B404: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B408: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B40C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B410: 392BCCDC  addi r9, r11, -0x3324
	ctx.r[9].s64 = ctx.r[11].s64 + -13092;
	// 8283B414: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B418: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B41C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B420: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B424: 48000008  b 0x8283b42c
	pc = 0x8283B42C; continue 'dispatch;
	// 8283B428: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B42C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B434: 409A0044  bne cr6, 0x8283b478
	if !ctx.cr[6].eq {
	pc = 0x8283B478; continue 'dispatch;
	}
	// 8283B438: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B43C: 419A001C  beq cr6, 0x8283b458
	if ctx.cr[6].eq {
	pc = 0x8283B458; continue 'dispatch;
	}
	// 8283B440: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B444: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B448: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B44C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B450: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B454: 4E800421  bctrl
	ctx.lr = 0x8283B458;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B458: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B45C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B460: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B464: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B468: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B46C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B470: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B474: 4BA84B8D  bl 0x822c0000
	ctx.lr = 0x8283B478;
	sub_822C0000(ctx, base);
	// 8283B478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B47C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B488: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B498 size=196
    let mut pc: u32 = 0x8283B498;
    'dispatch: loop {
        match pc {
            0x8283B498 => {
    //   block [0x8283B498..0x8283B55C)
	// 8283B498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B49C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B4A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B4A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B4A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B4AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B4B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B4B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B4B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B4BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B4C0: 4BA85479  bl 0x822c0938
	ctx.lr = 0x8283B4C4;
	sub_822C0938(ctx, base);
	// 8283B4C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B4C8: 41820028  beq 0x8283b4f0
	if ctx.cr[0].eq {
	pc = 0x8283B4F0; continue 'dispatch;
	}
	// 8283B4CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B4D0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B4D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B4D8: 392BCCF0  addi r9, r11, -0x3310
	ctx.r[9].s64 = ctx.r[11].s64 + -13072;
	// 8283B4DC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B4E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B4E4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B4E8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B4EC: 48000008  b 0x8283b4f4
	pc = 0x8283B4F4; continue 'dispatch;
	// 8283B4F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B4F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B4F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B4FC: 409A0044  bne cr6, 0x8283b540
	if !ctx.cr[6].eq {
	pc = 0x8283B540; continue 'dispatch;
	}
	// 8283B500: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B504: 419A001C  beq cr6, 0x8283b520
	if ctx.cr[6].eq {
	pc = 0x8283B520; continue 'dispatch;
	}
	// 8283B508: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B50C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B514: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B518: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B51C: 4E800421  bctrl
	ctx.lr = 0x8283B520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B520: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B524: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B52C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B530: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B534: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B538: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B53C: 4BA84AC5  bl 0x822c0000
	ctx.lr = 0x8283B540;
	sub_822C0000(ctx, base);
	// 8283B540: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B544: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B548: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B54C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B550: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B554: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B558: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B560 size=196
    let mut pc: u32 = 0x8283B560;
    'dispatch: loop {
        match pc {
            0x8283B560 => {
    //   block [0x8283B560..0x8283B624)
	// 8283B560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B574: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B57C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B580: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B584: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B588: 4BA853B1  bl 0x822c0938
	ctx.lr = 0x8283B58C;
	sub_822C0938(ctx, base);
	// 8283B58C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B590: 41820028  beq 0x8283b5b8
	if ctx.cr[0].eq {
	pc = 0x8283B5B8; continue 'dispatch;
	}
	// 8283B594: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B598: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B59C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B5A0: 392BCD04  addi r9, r11, -0x32fc
	ctx.r[9].s64 = ctx.r[11].s64 + -13052;
	// 8283B5A4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B5A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B5AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B5B0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B5B4: 48000008  b 0x8283b5bc
	pc = 0x8283B5BC; continue 'dispatch;
	// 8283B5B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B5BC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B5C4: 409A0044  bne cr6, 0x8283b608
	if !ctx.cr[6].eq {
	pc = 0x8283B608; continue 'dispatch;
	}
	// 8283B5C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B5CC: 419A001C  beq cr6, 0x8283b5e8
	if ctx.cr[6].eq {
	pc = 0x8283B5E8; continue 'dispatch;
	}
	// 8283B5D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B5D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B5DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B5E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B5E4: 4E800421  bctrl
	ctx.lr = 0x8283B5E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B5E8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B5EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B5F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B5F4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B5F8: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B5FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B600: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B604: 4BA849FD  bl 0x822c0000
	ctx.lr = 0x8283B608;
	sub_822C0000(ctx, base);
	// 8283B608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B60C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B610: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B614: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B618: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B61C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B628 size=196
    let mut pc: u32 = 0x8283B628;
    'dispatch: loop {
        match pc {
            0x8283B628 => {
    //   block [0x8283B628..0x8283B6EC)
	// 8283B628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B62C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B630: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B634: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B638: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B63C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B640: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B644: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B648: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B64C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B650: 4BA852E9  bl 0x822c0938
	ctx.lr = 0x8283B654;
	sub_822C0938(ctx, base);
	// 8283B654: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B658: 41820028  beq 0x8283b680
	if ctx.cr[0].eq {
	pc = 0x8283B680; continue 'dispatch;
	}
	// 8283B65C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B660: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B664: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B668: 392BCD18  addi r9, r11, -0x32e8
	ctx.r[9].s64 = ctx.r[11].s64 + -13032;
	// 8283B66C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B670: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B674: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B678: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B67C: 48000008  b 0x8283b684
	pc = 0x8283B684; continue 'dispatch;
	// 8283B680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B684: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B688: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B68C: 409A0044  bne cr6, 0x8283b6d0
	if !ctx.cr[6].eq {
	pc = 0x8283B6D0; continue 'dispatch;
	}
	// 8283B690: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B694: 419A001C  beq cr6, 0x8283b6b0
	if ctx.cr[6].eq {
	pc = 0x8283B6B0; continue 'dispatch;
	}
	// 8283B698: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B69C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B6A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B6A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B6AC: 4E800421  bctrl
	ctx.lr = 0x8283B6B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B6B0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B6B4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B6BC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B6C0: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B6C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B6C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B6CC: 4BA84935  bl 0x822c0000
	ctx.lr = 0x8283B6D0;
	sub_822C0000(ctx, base);
	// 8283B6D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B6D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B6D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B6DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B6E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B6E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B6E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B6F0 size=196
    let mut pc: u32 = 0x8283B6F0;
    'dispatch: loop {
        match pc {
            0x8283B6F0 => {
    //   block [0x8283B6F0..0x8283B7B4)
	// 8283B6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B6F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B6F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B6FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B704: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B70C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B710: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B714: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B718: 4BA85221  bl 0x822c0938
	ctx.lr = 0x8283B71C;
	sub_822C0938(ctx, base);
	// 8283B71C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B720: 41820028  beq 0x8283b748
	if ctx.cr[0].eq {
	pc = 0x8283B748; continue 'dispatch;
	}
	// 8283B724: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B728: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B72C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B730: 392BCD2C  addi r9, r11, -0x32d4
	ctx.r[9].s64 = ctx.r[11].s64 + -13012;
	// 8283B734: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B738: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B73C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B740: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B744: 48000008  b 0x8283b74c
	pc = 0x8283B74C; continue 'dispatch;
	// 8283B748: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B74C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B754: 409A0044  bne cr6, 0x8283b798
	if !ctx.cr[6].eq {
	pc = 0x8283B798; continue 'dispatch;
	}
	// 8283B758: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B75C: 419A001C  beq cr6, 0x8283b778
	if ctx.cr[6].eq {
	pc = 0x8283B778; continue 'dispatch;
	}
	// 8283B760: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B764: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B76C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B770: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B774: 4E800421  bctrl
	ctx.lr = 0x8283B778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B778: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B77C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B784: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B788: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B78C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B790: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B794: 4BA8486D  bl 0x822c0000
	ctx.lr = 0x8283B798;
	sub_822C0000(ctx, base);
	// 8283B798: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B79C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B7A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B7AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B7B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B7B8 size=196
    let mut pc: u32 = 0x8283B7B8;
    'dispatch: loop {
        match pc {
            0x8283B7B8 => {
    //   block [0x8283B7B8..0x8283B87C)
	// 8283B7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B7C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B7C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B7C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B7CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B7D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B7D4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B7D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B7DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B7E0: 4BA85159  bl 0x822c0938
	ctx.lr = 0x8283B7E4;
	sub_822C0938(ctx, base);
	// 8283B7E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B7E8: 41820028  beq 0x8283b810
	if ctx.cr[0].eq {
	pc = 0x8283B810; continue 'dispatch;
	}
	// 8283B7EC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B7F0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B7F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B7F8: 392BCD40  addi r9, r11, -0x32c0
	ctx.r[9].s64 = ctx.r[11].s64 + -12992;
	// 8283B7FC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B800: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B804: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B808: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B80C: 48000008  b 0x8283b814
	pc = 0x8283B814; continue 'dispatch;
	// 8283B810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B814: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B81C: 409A0044  bne cr6, 0x8283b860
	if !ctx.cr[6].eq {
	pc = 0x8283B860; continue 'dispatch;
	}
	// 8283B820: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B824: 419A001C  beq cr6, 0x8283b840
	if ctx.cr[6].eq {
	pc = 0x8283B840; continue 'dispatch;
	}
	// 8283B828: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B82C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B834: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B838: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B83C: 4E800421  bctrl
	ctx.lr = 0x8283B840;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B840: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B844: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B84C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B850: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B854: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B858: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B85C: 4BA847A5  bl 0x822c0000
	ctx.lr = 0x8283B860;
	sub_822C0000(ctx, base);
	// 8283B860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B864: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B868: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B86C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B870: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B874: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B880 size=196
    let mut pc: u32 = 0x8283B880;
    'dispatch: loop {
        match pc {
            0x8283B880 => {
    //   block [0x8283B880..0x8283B944)
	// 8283B880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B88C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B894: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B89C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B8A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B8A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B8A8: 4BA85091  bl 0x822c0938
	ctx.lr = 0x8283B8AC;
	sub_822C0938(ctx, base);
	// 8283B8AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B8B0: 41820028  beq 0x8283b8d8
	if ctx.cr[0].eq {
	pc = 0x8283B8D8; continue 'dispatch;
	}
	// 8283B8B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B8B8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B8BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B8C0: 392BCD54  addi r9, r11, -0x32ac
	ctx.r[9].s64 = ctx.r[11].s64 + -12972;
	// 8283B8C4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B8C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B8CC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B8D0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B8D4: 48000008  b 0x8283b8dc
	pc = 0x8283B8DC; continue 'dispatch;
	// 8283B8D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B8DC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B8E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B8E4: 409A0044  bne cr6, 0x8283b928
	if !ctx.cr[6].eq {
	pc = 0x8283B928; continue 'dispatch;
	}
	// 8283B8E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B8EC: 419A001C  beq cr6, 0x8283b908
	if ctx.cr[6].eq {
	pc = 0x8283B908; continue 'dispatch;
	}
	// 8283B8F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B8F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B8FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B904: 4E800421  bctrl
	ctx.lr = 0x8283B908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B908: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B90C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B914: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B918: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B91C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B920: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B924: 4BA846DD  bl 0x822c0000
	ctx.lr = 0x8283B928;
	sub_822C0000(ctx, base);
	// 8283B928: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B92C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B930: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B934: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283B938: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283B93C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283B940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283B948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283B948 size=196
    let mut pc: u32 = 0x8283B948;
    'dispatch: loop {
        match pc {
            0x8283B948 => {
    //   block [0x8283B948..0x8283BA0C)
	// 8283B948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283B94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283B950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283B954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283B958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283B95C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283B960: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B964: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8283B968: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283B96C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B970: 4BA84FC9  bl 0x822c0938
	ctx.lr = 0x8283B974;
	sub_822C0938(ctx, base);
	// 8283B974: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283B978: 41820028  beq 0x8283b9a0
	if ctx.cr[0].eq {
	pc = 0x8283B9A0; continue 'dispatch;
	}
	// 8283B97C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283B980: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8283B984: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283B988: 392BCD68  addi r9, r11, -0x3298
	ctx.r[9].s64 = ctx.r[11].s64 + -12952;
	// 8283B98C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8283B990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283B994: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8283B998: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8283B99C: 48000008  b 0x8283b9a4
	pc = 0x8283B9A4; continue 'dispatch;
	// 8283B9A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283B9A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283B9A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283B9AC: 409A0044  bne cr6, 0x8283b9f0
	if !ctx.cr[6].eq {
	pc = 0x8283B9F0; continue 'dispatch;
	}
	// 8283B9B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283B9B4: 419A001C  beq cr6, 0x8283b9d0
	if ctx.cr[6].eq {
	pc = 0x8283B9D0; continue 'dispatch;
	}
	// 8283B9B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B9BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8283B9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283B9C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283B9C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283B9CC: 4E800421  bctrl
	ctx.lr = 0x8283B9D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283B9D0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283B9D4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283B9D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283B9DC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 8283B9E0: 816B17D8  lwz r11, 0x17d8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6104 as u32) ) } as u64;
	// 8283B9E4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 8283B9E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283B9EC: 4BA84615  bl 0x822c0000
	ctx.lr = 0x8283B9F0;
	sub_822C0000(ctx, base);
	// 8283B9F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283B9F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283B9F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283B9FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283BA00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283BA04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283BA08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283BA10 size=100
    let mut pc: u32 = 0x8283BA10;
    'dispatch: loop {
        match pc {
            0x8283BA10 => {
    //   block [0x8283BA10..0x8283BA74)
	// 8283BA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283BA14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283BA18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283BA1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283BA20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283BA24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283BA28: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283BA2C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 8283BA30: 396BCFA4  addi r11, r11, -0x305c
	ctx.r[11].s64 = ctx.r[11].s64 + -12380;
	// 8283BA34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283BA38: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283BA3C: 485B79ED  bl 0x82df3428
	ctx.lr = 0x8283BA40;
	sub_82DF3428(ctx, base);
	// 8283BA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283BA44: 48620B45  bl 0x82e5c588
	ctx.lr = 0x8283BA48;
	sub_82E5C588(ctx, base);
	// 8283BA48: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283BA4C: 4182000C  beq 0x8283ba58
	if ctx.cr[0].eq {
	pc = 0x8283BA58; continue 'dispatch;
	}
	// 8283BA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283BA54: 485B6985  bl 0x82df23d8
	ctx.lr = 0x8283BA58;
	sub_82DF23D8(ctx, base);
	// 8283BA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283BA5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283BA60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283BA64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283BA68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283BA6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283BA70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8283BA78 size=360
    let mut pc: u32 = 0x8283BA78;
    'dispatch: loop {
        match pc {
            0x8283BA78 => {
    //   block [0x8283BA78..0x8283BBE0)
	// 8283BA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283BA7C: 4896C6ED  bl 0x831a8168
	ctx.lr = 0x8283BA80;
	sub_831A8130(ctx, base);
	// 8283BA80: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BA84: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 8283BA88: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8283BA8C: 39440020  addi r10, r4, 0x20
	ctx.r[10].s64 = ctx.r[4].s64 + 32;
	// 8283BA90: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BA94: 3BC00020  li r30, 0x20
	ctx.r[30].s64 = 32;
	// 8283BA98: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8283BA9C: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 8283BAA0: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BAA4: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 8283BAA8: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8283BAAC: 39030020  addi r8, r3, 0x20
	ctx.r[8].s64 = ctx.r[3].s64 + 32;
	// 8283BAB0: C004000C  lfs f0, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BAB4: 90C1FFC8  stw r6, -0x38(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.r[6].u32 ) };
	// 8283BAB8: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8283BABC: 38C30070  addi r6, r3, 0x70
	ctx.r[6].s64 = ctx.r[3].s64 + 112;
	// 8283BAC0: 13E458C7  vcmpequd (lvx128) v31, v4, v11
	tmp.u32 = ctx.r[4].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283BAC4: 9101FFC4  stw r8, -0x3c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), ctx.r[8].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283BBE0 size=240
    let mut pc: u32 = 0x8283BBE0;
    'dispatch: loop {
        match pc {
            0x8283BBE0 => {
    //   block [0x8283BBE0..0x8283BCD0)
	// 8283BBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283BBE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283BBE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283BBEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283BBF0: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 8283BBF4: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8283BBF8: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8283BBFC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283BC00: 81640064  lwz r11, 0x64(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283BC04: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283BC08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283BC0C: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8283BC10: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 8283BC14: C3CA08A4  lfs f30, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8283BC18: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8283BC1C: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 8283BC20: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283BC24: 48000010  b 0x8283bc34
	pc = 0x8283BC34; continue 'dispatch;
	// 8283BC28: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BC2C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8283BC30: EFE0F82A  fadds f31, f0, f31
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8283BC34: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8283BC38: 409AFFF0  bne cr6, 0x8283bc28
	if !ctx.cr[6].eq {
	pc = 0x8283BC28; continue 'dispatch;
	}
	// 8283BC3C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283BC40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283BC44: 388B9BC9  addi r4, r11, -0x6437
	ctx.r[4].s64 = ctx.r[11].s64 + -25655;
	// 8283BC48: 485B7DC1  bl 0x82df3a08
	ctx.lr = 0x8283BC4C;
	sub_82DF3A08(ctx, base);
	// 8283BC4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283BC50: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283BC54: FC00F090  fmr f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8283BC58: EDBF0772  fmuls f13, f31, f29
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 8283BC5C: 48000038  b 0x8283bc94
	pc = 0x8283BC94; continue 'dispatch;
	// 8283BC60: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8283BC64: 41990018  bgt cr6, 0x8283bc7c
	if ctx.cr[6].gt {
	pc = 0x8283BC7C; continue 'dispatch;
	}
	// 8283BC68: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283BC6C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283BC70: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8283BC74: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8283BC78: 40990008  ble cr6, 0x8283bc80
	if !ctx.cr[6].gt {
	pc = 0x8283BC80; continue 'dispatch;
	}
	// 8283BC7C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8283BC80: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8283BC84: 4082001C  bne 0x8283bca0
	if !ctx.cr[0].eq {
	pc = 0x8283BCA0; continue 'dispatch;
	}
	// 8283BC88: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283BC8C: 38840008  addi r4, r4, 8
	ctx.r[4].s64 = ctx.r[4].s64 + 8;
	// 8283BC90: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8283BC94: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8283BC98: 409AFFC8  bne cr6, 0x8283bc60
	if !ctx.cr[6].eq {
	pc = 0x8283BC60; continue 'dispatch;
	}
	// 8283BC9C: 4800000C  b 0x8283bca8
	pc = 0x8283BCA8; continue 'dispatch;
	// 8283BCA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283BCA4: 485B7F2D  bl 0x82df3bd0
	ctx.lr = 0x8283BCA8;
	sub_82DF3BD0(ctx, base);
	// 8283BCA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283BCAC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283BCB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283BCB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283BCB8: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8283BCBC: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8283BCC0: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8283BCC4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283BCC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283BCCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8283BCD0 size=72
    let mut pc: u32 = 0x8283BCD0;
    'dispatch: loop {
        match pc {
            0x8283BCD0 => {
    //   block [0x8283BCD0..0x8283BD18)
	// 8283BCD0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8283BCD4: 81430064  lwz r10, 0x64(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283BCD8: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 8283BCDC: C00908A4  lfs f0, 0x8a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BCE0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283BCE4: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283BCE8: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8283BCEC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8283BCF0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8283BCF4: 419A0018  beq cr6, 0x8283bd0c
	if ctx.cr[6].eq {
	pc = 0x8283BD0C; continue 'dispatch;
	}
	// 8283BCF8: C16A0004  lfs f11, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283BCFC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8283BD00: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 8283BD04: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8283BD08: 409AFFF0  bne cr6, 0x8283bcf8
	if !ctx.cr[6].eq {
	pc = 0x8283BCF8; continue 'dispatch;
	}
	// 8283BD0C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8283BD10: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 8283BD14: 48000038  b 0x8283bd4c
	sub_8283BD18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8283BD18 size=64
    let mut pc: u32 = 0x8283BD18;
    'dispatch: loop {
        match pc {
            0x8283BD18 => {
    //   block [0x8283BD18..0x8283BD58)
	// 8283BD18: FF006800  fcmpu cr6, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8283BD1C: 41990018  bgt cr6, 0x8283bd34
	if ctx.cr[6].gt {
	pc = 0x8283BD34; continue 'dispatch;
	}
	// 8283BD20: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283BD24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8283BD28: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8283BD2C: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8283BD30: 40990008  ble cr6, 0x8283bd38
	if !ctx.cr[6].gt {
	pc = 0x8283BD38; continue 'dispatch;
	}
	// 8283BD34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8283BD38: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8283BD3C: 4082001C  bne 0x8283bd58
	if !ctx.cr[0].eq {
		sub_8283BD58(ctx, base);
		return;
	}
	// 8283BD40: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283BD44: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8283BD48: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8283BD4C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8283BD50: 409AFFC8  bne cr6, 0x8283bd18
	if !ctx.cr[6].eq {
	pc = 0x8283BD18; continue 'dispatch;
	}
	// 8283BD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8283BD58 size=8
    let mut pc: u32 = 0x8283BD58;
    'dispatch: loop {
        match pc {
            0x8283BD58 => {
    //   block [0x8283BD58..0x8283BD60)
	// 8283BD58: C02B0000  lfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283BD5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283BD60 size=116
    let mut pc: u32 = 0x8283BD60;
    'dispatch: loop {
        match pc {
            0x8283BD60 => {
    //   block [0x8283BD60..0x8283BDD4)
	// 8283BD60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283BD64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283BD68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283BD6C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8283BD70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283BD74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283BD78: C1A40210  lfs f13, 0x210(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283BD7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283BD80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283BD84: C00B89AC  lfs f0, -0x7654(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283BD88: EFED002A  fadds f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8283BD8C: 4BFD98A5  bl 0x82815630
	ctx.lr = 0x8283BD90;
	sub_82815630(ctx, base);
	// 8283BD90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283BD94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283BD98: 486416B9  bl 0x82e7d450
	ctx.lr = 0x8283BD9C;
	sub_82E7D450(ctx, base);
	// 8283BD9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8283BDA0: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283BDA4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283BDA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283BDAC: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BDD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283BDD8 size=392
    let mut pc: u32 = 0x8283BDD8;
    'dispatch: loop {
        match pc {
            0x8283BDD8 => {
    //   block [0x8283BDD8..0x8283BF60)
	// 8283BDD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283BDDC: 4896C38D  bl 0x831a8168
	ctx.lr = 0x8283BDE0;
	sub_831A8130(ctx, base);
	// 8283BDE0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283BDE4: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283BDE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283BDEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283BDF0: 83DF0064  lwz r30, 0x64(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283BDF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283BDF8: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283BDFC: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 8283BE00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283BE04: 4E800421  bctrl
	ctx.lr = 0x8283BE08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283BE08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283BE0C: 817C0038  lwz r11, 0x38(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 8283BE10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283BE14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283BE18: 4E800421  bctrl
	ctx.lr = 0x8283BE1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283BE1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283BE20: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283BE24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283BE28: C3EB08A4  lfs f31, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8283BE2C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283BE30: 817F00B0  lwz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 8283BE34: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283BE38: 4BFFE881  bl 0x8283a6b8
	ctx.lr = 0x8283BE3C;
	sub_8283A6B8(ctx, base);
	// 8283BE3C: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283BE40: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283BE44: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 8283BE48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283BE4C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8283BE50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283BE54: 4E800421  bctrl
	ctx.lr = 0x8283BE58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283BE58: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8283BE5C: 809F0064  lwz r4, 0x64(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283BE60: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283BE64: 80DF00B4  lwz r6, 0xb4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 8283BE68: 4BFFE851  bl 0x8283a6b8
	ctx.lr = 0x8283BE6C;
	sub_8283A6B8(ctx, base);
	// 8283BE6C: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283BF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8283BF60 size=648
    let mut pc: u32 = 0x8283BF60;
    'dispatch: loop {
        match pc {
            0x8283BF60 => {
    //   block [0x8283BF60..0x8283C1E8)
	// 8283BF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283BF64: 4896C209  bl 0x831a816c
	ctx.lr = 0x8283BF68;
	sub_831A8130(ctx, base);
	// 8283BF68: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283C1E8 size=88
    let mut pc: u32 = 0x8283C1E8;
    'dispatch: loop {
        match pc {
            0x8283C1E8 => {
    //   block [0x8283C1E8..0x8283C240)
	// 8283C1E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C1EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283C1F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283C1F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283C1F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C1FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C200: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283C204: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C208: 396BCE64  addi r11, r11, -0x319c
	ctx.r[11].s64 = ctx.r[11].s64 + -12700;
	// 8283C20C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283C210: 48620379  bl 0x82e5c588
	ctx.lr = 0x8283C214;
	sub_82E5C588(ctx, base);
	// 8283C214: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283C218: 4182000C  beq 0x8283c224
	if ctx.cr[0].eq {
	pc = 0x8283C224; continue 'dispatch;
	}
	// 8283C21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C220: 485B61B9  bl 0x82df23d8
	ctx.lr = 0x8283C224;
	sub_82DF23D8(ctx, base);
	// 8283C224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C228: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283C22C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283C230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283C234: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283C238: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283C23C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283C240 size=88
    let mut pc: u32 = 0x8283C240;
    'dispatch: loop {
        match pc {
            0x8283C240 => {
    //   block [0x8283C240..0x8283C298)
	// 8283C240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283C248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283C24C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283C250: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C254: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C258: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283C25C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C260: 396BCEA4  addi r11, r11, -0x315c
	ctx.r[11].s64 = ctx.r[11].s64 + -12636;
	// 8283C264: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283C268: 48620321  bl 0x82e5c588
	ctx.lr = 0x8283C26C;
	sub_82E5C588(ctx, base);
	// 8283C26C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283C270: 4182000C  beq 0x8283c27c
	if ctx.cr[0].eq {
	pc = 0x8283C27C; continue 'dispatch;
	}
	// 8283C274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C278: 485B6161  bl 0x82df23d8
	ctx.lr = 0x8283C27C;
	sub_82DF23D8(ctx, base);
	// 8283C27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C280: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283C284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283C288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283C28C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283C290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283C294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283C298 size=276
    let mut pc: u32 = 0x8283C298;
    'dispatch: loop {
        match pc {
            0x8283C298 => {
    //   block [0x8283C298..0x8283C3AC)
	// 8283C298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C29C: 4896BECD  bl 0x831a8168
	ctx.lr = 0x8283C2A0;
	sub_831A8130(ctx, base);
	// 8283C2A0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C2A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C2A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283C2AC: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283C2B0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C2B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8283C2B8: 419A00EC  beq cr6, 0x8283c3a4
	if ctx.cr[6].eq {
	pc = 0x8283C3A4; continue 'dispatch;
	}
	// 8283C2BC: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283C2C0: 485D6451  bl 0x82e12710
	ctx.lr = 0x8283C2C4;
	sub_82E12710(ctx, base);
	// 8283C2C4: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283C2C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C2CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8283C2D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C2D4: 4E800421  bctrl
	ctx.lr = 0x8283C2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C2D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8283C2DC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8283C2E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8283C2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C2E8: C01C003C  lfs f0, 0x3c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C2EC: C1BC0038  lfs f13, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283C2F0: C19C0034  lfs f12, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283C2F4: C17C0030  lfs f11, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283C2F8: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283C2FC: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8283C300: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283C304: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283C308: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C30C: C02B6218  lfs f1, 0x6218(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283C310: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8283C314: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C318: 4E800421  bctrl
	ctx.lr = 0x8283C31C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C31C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283C320: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8283C324: 809F0070  lwz r4, 0x70(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8283C328: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283C32C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8283C330: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C334: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283C3B0 size=88
    let mut pc: u32 = 0x8283C3B0;
    'dispatch: loop {
        match pc {
            0x8283C3B0 => {
    //   block [0x8283C3B0..0x8283C408)
	// 8283C3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283C3B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283C3BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283C3C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C3C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283C3CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C3D0: 396BCEE4  addi r11, r11, -0x311c
	ctx.r[11].s64 = ctx.r[11].s64 + -12572;
	// 8283C3D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283C3D8: 486201B1  bl 0x82e5c588
	ctx.lr = 0x8283C3DC;
	sub_82E5C588(ctx, base);
	// 8283C3DC: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283C3E0: 4182000C  beq 0x8283c3ec
	if ctx.cr[0].eq {
	pc = 0x8283C3EC; continue 'dispatch;
	}
	// 8283C3E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C3E8: 485B5FF1  bl 0x82df23d8
	ctx.lr = 0x8283C3EC;
	sub_82DF23D8(ctx, base);
	// 8283C3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C3F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283C3F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283C3F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283C3FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283C400: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283C404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283C408 size=88
    let mut pc: u32 = 0x8283C408;
    'dispatch: loop {
        match pc {
            0x8283C408 => {
    //   block [0x8283C408..0x8283C460)
	// 8283C408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C40C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283C410: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283C414: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283C418: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C41C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C420: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283C424: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C428: 396BCF24  addi r11, r11, -0x30dc
	ctx.r[11].s64 = ctx.r[11].s64 + -12508;
	// 8283C42C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283C430: 48620159  bl 0x82e5c588
	ctx.lr = 0x8283C434;
	sub_82E5C588(ctx, base);
	// 8283C434: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283C438: 4182000C  beq 0x8283c444
	if ctx.cr[0].eq {
	pc = 0x8283C444; continue 'dispatch;
	}
	// 8283C43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C440: 485B5F99  bl 0x82df23d8
	ctx.lr = 0x8283C444;
	sub_82DF23D8(ctx, base);
	// 8283C444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283C44C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283C450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283C454: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283C458: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283C45C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283C460 size=280
    let mut pc: u32 = 0x8283C460;
    'dispatch: loop {
        match pc {
            0x8283C460 => {
    //   block [0x8283C460..0x8283C578)
	// 8283C460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C464: 4896BD01  bl 0x831a8164
	ctx.lr = 0x8283C468;
	sub_831A8130(ctx, base);
	// 8283C468: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C46C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C470: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8283C474: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283C478: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C47C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8283C480: 419A00F0  beq cr6, 0x8283c570
	if ctx.cr[6].eq {
	pc = 0x8283C570; continue 'dispatch;
	}
	// 8283C484: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C488: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8283C48C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283C490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C494: 4E800421  bctrl
	ctx.lr = 0x8283C498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C498: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C49C: 815F0070  lwz r10, 0x70(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8283C4A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8283C4A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C4A8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8283C4AC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8283C4B0: C02A0000  lfs f1, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283C4B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C4B8: 4E800421  bctrl
	ctx.lr = 0x8283C4BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C4BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C4C0: 815F006C  lwz r10, 0x6c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283C4C4: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 8283C4C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C4CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8283C4D0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8283C4D4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C4D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C4DC: 4E800421  bctrl
	ctx.lr = 0x8283C4E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C4E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8283C4E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283C4E8: 48641041  bl 0x82e7d528
	ctx.lr = 0x8283C4EC;
	sub_82E7D528(ctx, base);
	// 8283C4EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8283C4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283C4F4: 4BFB335D  bl 0x827ef850
	ctx.lr = 0x8283C4F8;
	sub_827EF850(ctx, base);
	// 8283C4F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283C4FC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8283C500: 13E0E8C7  vcmpequd (lvx128) v31, v0, v29
	tmp.u32 = ctx.r[29].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283C504: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283C508: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283C50C: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C510: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283C514: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8283C518: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283C51C: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8283C520: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283C524: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283C578 size=464
    let mut pc: u32 = 0x8283C578;
    'dispatch: loop {
        match pc {
            0x8283C578 => {
    //   block [0x8283C578..0x8283C748)
	// 8283C578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C57C: 4896BBED  bl 0x831a8168
	ctx.lr = 0x8283C580;
	sub_831A8130(ctx, base);
	// 8283C580: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8283C584: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283C588: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C58C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C590: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8283C594: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C598: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283C59C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C5A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283C5A4: 419A0194  beq cr6, 0x8283c738
	if ctx.cr[6].eq {
	pc = 0x8283C738; continue 'dispatch;
	}
	// 8283C5A8: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 8283C5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C5B0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C5B4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C5B8: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8283C5BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283C5C0: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283C5C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C5C8: 4E800421  bctrl
	ctx.lr = 0x8283C5CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C5CC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283C5D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8283C5D4: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8283C5D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283C5DC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8283C5E0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8283C5E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283C5E8: 4E800421  bctrl
	ctx.lr = 0x8283C5EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283C5EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283C5F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283C5F4: 4BFB325D  bl 0x827ef850
	ctx.lr = 0x8283C5F8;
	sub_827EF850(ctx, base);
	// 8283C5F8: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283C748 size=88
    let mut pc: u32 = 0x8283C748;
    'dispatch: loop {
        match pc {
            0x8283C748 => {
    //   block [0x8283C748..0x8283C7A0)
	// 8283C748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C74C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283C750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283C754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283C758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C75C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283C760: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283C764: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C768: 396BCF64  addi r11, r11, -0x309c
	ctx.r[11].s64 = ctx.r[11].s64 + -12444;
	// 8283C76C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283C770: 4861FE19  bl 0x82e5c588
	ctx.lr = 0x8283C774;
	sub_82E5C588(ctx, base);
	// 8283C774: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283C778: 4182000C  beq 0x8283c784
	if ctx.cr[0].eq {
	pc = 0x8283C784; continue 'dispatch;
	}
	// 8283C77C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C780: 485B5C59  bl 0x82df23d8
	ctx.lr = 0x8283C784;
	sub_82DF23D8(ctx, base);
	// 8283C784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283C788: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283C78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283C790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283C794: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283C798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283C79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283C7A0 size=332
    let mut pc: u32 = 0x8283C7A0;
    'dispatch: loop {
        match pc {
            0x8283C7A0 => {
    //   block [0x8283C7A0..0x8283C8EC)
	// 8283C7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C7A4: 4896B9C5  bl 0x831a8168
	ctx.lr = 0x8283C7A8;
	sub_831A8130(ctx, base);
	// 8283C7A8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283C7AC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C7B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283C8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283C8F0 size=744
    let mut pc: u32 = 0x8283C8F0;
    'dispatch: loop {
        match pc {
            0x8283C8F0 => {
    //   block [0x8283C8F0..0x8283CBD8)
	// 8283C8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283C8F4: 4896B875  bl 0x831a8168
	ctx.lr = 0x8283C8F8;
	sub_831A8130(ctx, base);
	// 8283C8F8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8283C8FC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8283C900: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283C904: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283C908: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283C90C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283C910: 83FD0280  lwz r31, 0x280(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(640 as u32) ) } as u64;
	// 8283C914: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283C918: 419A02AC  beq cr6, 0x8283cbc4
	if ctx.cr[6].eq {
	pc = 0x8283CBC4; continue 'dispatch;
	}
	// 8283C91C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283C920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283C924: 388BB334  addi r4, r11, -0x4ccc
	ctx.r[4].s64 = ctx.r[11].s64 + -19660;
	// 8283C928: 485B70E1  bl 0x82df3a08
	ctx.lr = 0x8283C92C;
	sub_82DF3A08(ctx, base);
	// 8283C92C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283C930: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C934: 48377F55  bl 0x82bb4888
	ctx.lr = 0x8283C938;
	sub_82BB4888(ctx, base);
	// 8283C938: 7C7C0734  extsh r28, r3
	ctx.r[28].s64 = ctx.r[3].s16 as i64;
	// 8283C93C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283C940: 485B6AE9  bl 0x82df3428
	ctx.lr = 0x8283C944;
	sub_82DF3428(ctx, base);
	// 8283C944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283C948: 482A6F49  bl 0x82ae3890
	ctx.lr = 0x8283C94C;
	sub_82AE3890(ctx, base);
	// 8283C94C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8283C950: 48772899  bl 0x82faf1e8
	ctx.lr = 0x8283C954;
	sub_82FAF1E8(ctx, base);
	// 8283C954: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C958: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8283C95C: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 8283C960: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C964: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283C968: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8283C96C: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 8283C970: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C974: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283C978: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8283C97C: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8283C980: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283C984: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8283C988: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8283C98C: 809D02A0  lwz r4, 0x2a0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(672 as u32) ) } as u64;
	// 8283C990: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283C994: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283CBD8 size=296
    let mut pc: u32 = 0x8283CBD8;
    'dispatch: loop {
        match pc {
            0x8283CBD8 => {
    //   block [0x8283CBD8..0x8283CD00)
	// 8283CBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CBDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283CBE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283CBE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283CBE8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CBEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283CBF0: D02100F4  stfs f1, 0xf4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8283CBF4: 807E0320  lwz r3, 0x320(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(800 as u32) ) } as u64;
	// 8283CBF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283CBFC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283CC00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283CC04: 4E800421  bctrl
	ctx.lr = 0x8283CC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283CC08: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 8283CC0C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 8283CC10: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283CC14: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8283CC18: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 8283CC1C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 8283CC20: 13CB1C07  vcmpneb. (lvlx128) v30, v11, v3
	tmp.u32 = ctx.r[11].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283CC24: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8283CC28: 13AA1C07  vcmpneb. (lvlx128) v29, v10, v3
	tmp.u32 = ctx.r[10].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283CC2C: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8283CC30: 13891C07  vcmpneb. (lvlx128) v28, v9, v3
	tmp.u32 = ctx.r[9].u32 + ctx.r[3].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283CC34: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283CD00 size=176
    let mut pc: u32 = 0x8283CD00;
    'dispatch: loop {
        match pc {
            0x8283CD00 => {
    //   block [0x8283CD00..0x8283CDB0)
	// 8283CD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283CD08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283CD0C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CD10: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283CD14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283CD18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283CD1C: 388BB1A8  addi r4, r11, -0x4e58
	ctx.r[4].s64 = ctx.r[11].s64 + -20056;
	// 8283CD20: 485B6CE9  bl 0x82df3a08
	ctx.lr = 0x8283CD24;
	sub_82DF3A08(ctx, base);
	// 8283CD24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283CD28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283CD2C: 48026995  bl 0x828636c0
	ctx.lr = 0x8283CD30;
	sub_828636C0(ctx, base);
	// 8283CD30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283CD34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283CD38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283CD3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283CD40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8283CD44: 419A0024  beq cr6, 0x8283cd68
	if ctx.cr[6].eq {
	pc = 0x8283CD68; continue 'dispatch;
	}
	// 8283CD48: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283CD4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283CD50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283CD54: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283CD58: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283CD5C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283CD60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283CD64: 4082FFE8  bne 0x8283cd4c
	if !ctx.cr[0].eq {
	pc = 0x8283CD4C; continue 'dispatch;
	}
	// 8283CD68: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8283CD6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283CD70: 4BFB2931  bl 0x827ef6a0
	ctx.lr = 0x8283CD74;
	sub_827EF6A0(ctx, base);
	// 8283CD74: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283CD78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283CD7C: 419A0008  beq cr6, 0x8283cd84
	if ctx.cr[6].eq {
	pc = 0x8283CD84; continue 'dispatch;
	}
	// 8283CD80: 4BA83B11  bl 0x822c0890
	ctx.lr = 0x8283CD84;
	sub_822C0890(ctx, base);
	// 8283CD84: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283CD88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283CD8C: 419A0008  beq cr6, 0x8283cd94
	if ctx.cr[6].eq {
	pc = 0x8283CD94; continue 'dispatch;
	}
	// 8283CD90: 4BA83B01  bl 0x822c0890
	ctx.lr = 0x8283CD94;
	sub_822C0890(ctx, base);
	// 8283CD94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283CD98: 485B6691  bl 0x82df3428
	ctx.lr = 0x8283CD9C;
	sub_82DF3428(ctx, base);
	// 8283CD9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283CDA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283CDA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283CDA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283CDAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283CDB0 size=288
    let mut pc: u32 = 0x8283CDB0;
    'dispatch: loop {
        match pc {
            0x8283CDB0 => {
    //   block [0x8283CDB0..0x8283CED0)
	// 8283CDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CDB4: 4896B3B5  bl 0x831a8168
	ctx.lr = 0x8283CDB8;
	sub_831A8130(ctx, base);
	// 8283CDB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CDBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283CDC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283CDC4: 4812379D  bl 0x82960560
	ctx.lr = 0x8283CDC8;
	sub_82960560(ctx, base);
	// 8283CDC8: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8283CDCC: 418200FC  beq 0x8283cec8
	if ctx.cr[0].eq {
	pc = 0x8283CEC8; continue 'dispatch;
	}
	// 8283CDD0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283CDD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283CDD8: 808B17D4  lwz r4, 0x17d4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6100 as u32) ) } as u64;
	// 8283CDDC: 485B6C2D  bl 0x82df3a08
	ctx.lr = 0x8283CDE0;
	sub_82DF3A08(ctx, base);
	// 8283CDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283CDE4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 8283CDE8: 4BFB0019  bl 0x827ece00
	ctx.lr = 0x8283CDEC;
	sub_827ECE00(ctx, base);
	// 8283CDEC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8283CDF0: 485B64B1  bl 0x82df32a0
	ctx.lr = 0x8283CDF4;
	sub_82DF32A0(ctx, base);
	// 8283CDF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8283CDF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283CDFC: 485B662D  bl 0x82df3428
	ctx.lr = 0x8283CE00;
	sub_82DF3428(ctx, base);
	// 8283CE00: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283CE04: 4182000C  beq 0x8283ce10
	if ctx.cr[0].eq {
	pc = 0x8283CE10; continue 'dispatch;
	}
	// 8283CE08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CE0C: 4BFB1DD5  bl 0x827eebe0
	ctx.lr = 0x8283CE10;
	sub_827EEBE0(ctx, base);
	// 8283CE10: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 8283CE14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283CE18: 388B2D6C  addi r4, r11, 0x2d6c
	ctx.r[4].s64 = ctx.r[11].s64 + 11628;
	// 8283CE1C: 485B6BED  bl 0x82df3a08
	ctx.lr = 0x8283CE20;
	sub_82DF3A08(ctx, base);
	// 8283CE20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283CE24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283CE28: 48026899  bl 0x828636c0
	ctx.lr = 0x8283CE2C;
	sub_828636C0(ctx, base);
	// 8283CE2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283CE30: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283CE34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283CE38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283CE3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8283CE40: 419A0024  beq cr6, 0x8283ce64
	if ctx.cr[6].eq {
	pc = 0x8283CE64; continue 'dispatch;
	}
	// 8283CE44: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283CE48: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283CE4C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283CE50: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283CE54: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283CE58: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283CE5C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283CE60: 4082FFE8  bne 0x8283ce48
	if !ctx.cr[0].eq {
	pc = 0x8283CE48; continue 'dispatch;
	}
	// 8283CE64: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8283CE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283CE6C: 4BFB002D  bl 0x827ece98
	ctx.lr = 0x8283CE70;
	sub_827ECE98(ctx, base);
	// 8283CE70: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283CE74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283CE78: 419A0008  beq cr6, 0x8283ce80
	if ctx.cr[6].eq {
	pc = 0x8283CE80; continue 'dispatch;
	}
	// 8283CE7C: 4BA83A15  bl 0x822c0890
	ctx.lr = 0x8283CE80;
	sub_822C0890(ctx, base);
	// 8283CE80: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283CE84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283CE88: 419A0008  beq cr6, 0x8283ce90
	if ctx.cr[6].eq {
	pc = 0x8283CE90; continue 'dispatch;
	}
	// 8283CE8C: 4BA83A05  bl 0x822c0890
	ctx.lr = 0x8283CE90;
	sub_822C0890(ctx, base);
	// 8283CE90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283CE94: 485B6595  bl 0x82df3428
	ctx.lr = 0x8283CE98;
	sub_82DF3428(ctx, base);
	// 8283CE98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283CE9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CEA0: 38ABCFE0  addi r5, r11, -0x3020
	ctx.r[5].s64 = ctx.r[11].s64 + -12320;
	// 8283CEA4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283CEA8: 4BFB0309  bl 0x827ed1b0
	ctx.lr = 0x8283CEAC;
	sub_827ED1B0(ctx, base);
	// 8283CEAC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283CEB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283CEB4: 419A0008  beq cr6, 0x8283cebc
	if ctx.cr[6].eq {
	pc = 0x8283CEBC; continue 'dispatch;
	}
	// 8283CEB8: 4BA839D9  bl 0x822c0890
	ctx.lr = 0x8283CEBC;
	sub_822C0890(ctx, base);
	// 8283CEBC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283CEC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283CEC4: 4BFDC74D  bl 0x82819610
	ctx.lr = 0x8283CEC8;
	sub_82819610(ctx, base);
	// 8283CEC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8283CECC: 4896B2EC  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283CED0 size=84
    let mut pc: u32 = 0x8283CED0;
    'dispatch: loop {
        match pc {
            0x8283CED0 => {
    //   block [0x8283CED0..0x8283CF24)
	// 8283CED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CED4: 4896B299  bl 0x831a816c
	ctx.lr = 0x8283CED8;
	sub_831A8130(ctx, base);
	// 8283CED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CEDC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283CEE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283CEE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283CEE8: 397F0058  addi r11, r31, 0x58
	ctx.r[11].s64 = ctx.r[31].s64 + 88;
	// 8283CEEC: 409A0008  bne cr6, 0x8283cef4
	if !ctx.cr[6].eq {
	pc = 0x8283CEF4; continue 'dispatch;
	}
	// 8283CEF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283CEF4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283CEF8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283CEFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CF00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CF04: 4BFFDDC5  bl 0x8283acc8
	ctx.lr = 0x8283CF08;
	sub_8283ACC8(ctx, base);
	// 8283CF08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283CF0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CF10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CF14: 4BA830ED  bl 0x822c0000
	ctx.lr = 0x8283CF18;
	sub_822C0000(ctx, base);
	// 8283CF18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283CF1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283CF20: 4896B29C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283CF28 size=84
    let mut pc: u32 = 0x8283CF28;
    'dispatch: loop {
        match pc {
            0x8283CF28 => {
    //   block [0x8283CF28..0x8283CF7C)
	// 8283CF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CF2C: 4896B241  bl 0x831a816c
	ctx.lr = 0x8283CF30;
	sub_831A8130(ctx, base);
	// 8283CF30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CF34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283CF38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283CF3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283CF40: 397F0058  addi r11, r31, 0x58
	ctx.r[11].s64 = ctx.r[31].s64 + 88;
	// 8283CF44: 409A0008  bne cr6, 0x8283cf4c
	if !ctx.cr[6].eq {
	pc = 0x8283CF4C; continue 'dispatch;
	}
	// 8283CF48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283CF4C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283CF50: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283CF54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CF58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CF5C: 4BFFDEFD  bl 0x8283ae58
	ctx.lr = 0x8283CF60;
	sub_8283AE58(ctx, base);
	// 8283CF60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283CF64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CF68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CF6C: 4BA83095  bl 0x822c0000
	ctx.lr = 0x8283CF70;
	sub_822C0000(ctx, base);
	// 8283CF70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283CF74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283CF78: 4896B244  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283CF80 size=84
    let mut pc: u32 = 0x8283CF80;
    'dispatch: loop {
        match pc {
            0x8283CF80 => {
    //   block [0x8283CF80..0x8283CFD4)
	// 8283CF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CF84: 4896B1E9  bl 0x831a816c
	ctx.lr = 0x8283CF88;
	sub_831A8130(ctx, base);
	// 8283CF88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CF8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283CF90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283CF94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283CF98: 397F0058  addi r11, r31, 0x58
	ctx.r[11].s64 = ctx.r[31].s64 + 88;
	// 8283CF9C: 409A0008  bne cr6, 0x8283cfa4
	if !ctx.cr[6].eq {
	pc = 0x8283CFA4; continue 'dispatch;
	}
	// 8283CFA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283CFA4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283CFA8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283CFAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CFB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CFB4: 4BFFDF6D  bl 0x8283af20
	ctx.lr = 0x8283CFB8;
	sub_8283AF20(ctx, base);
	// 8283CFB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283CFBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283CFC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283CFC4: 4BA8303D  bl 0x822c0000
	ctx.lr = 0x8283CFC8;
	sub_822C0000(ctx, base);
	// 8283CFC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283CFCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283CFD0: 4896B1EC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283CFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283CFD8 size=72
    let mut pc: u32 = 0x8283CFD8;
    'dispatch: loop {
        match pc {
            0x8283CFD8 => {
    //   block [0x8283CFD8..0x8283D020)
	// 8283CFD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283CFDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283CFE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283CFE4: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8283CFE8: 419A001C  beq cr6, 0x8283d004
	if ctx.cr[6].eq {
	pc = 0x8283D004; continue 'dispatch;
	}
	// 8283CFEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8283CFF0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8283CFF4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8283CFF8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283CFFC: 4BFFCE65  bl 0x82839e60
	ctx.lr = 0x8283D000;
	sub_82839E60(ctx, base);
	// 8283D000: 48000010  b 0x8283d010
	pc = 0x8283D010; continue 'dispatch;
	// 8283D004: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283D008: 396B2040  addi r11, r11, 0x2040
	ctx.r[11].s64 = ctx.r[11].s64 + 8256;
	// 8283D00C: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283D010: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283D014: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283D018: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283D01C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D020 size=72
    let mut pc: u32 = 0x8283D020;
    'dispatch: loop {
        match pc {
            0x8283D020 => {
    //   block [0x8283D020..0x8283D068)
	// 8283D020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283D028: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D02C: 2F050003  cmpwi cr6, r5, 3
	ctx.cr[6].compare_i32(ctx.r[5].s32, 3, &mut ctx.xer);
	// 8283D030: 419A001C  beq cr6, 0x8283d04c
	if ctx.cr[6].eq {
	pc = 0x8283D04C; continue 'dispatch;
	}
	// 8283D034: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8283D038: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8283D03C: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 8283D040: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283D044: 4BFFCEA5  bl 0x82839ee8
	ctx.lr = 0x8283D048;
	sub_82839EE8(ctx, base);
	// 8283D048: 48000010  b 0x8283d058
	pc = 0x8283D058; continue 'dispatch;
	// 8283D04C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283D050: 396B2100  addi r11, r11, 0x2100
	ctx.r[11].s64 = ctx.r[11].s64 + 8448;
	// 8283D054: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283D058: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283D05C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283D060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283D064: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D068 size=128
    let mut pc: u32 = 0x8283D068;
    'dispatch: loop {
        match pc {
            0x8283D068 => {
    //   block [0x8283D068..0x8283D0E8)
	// 8283D068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D06C: 4896B101  bl 0x831a816c
	ctx.lr = 0x8283D070;
	sub_831A8130(ctx, base);
	// 8283D070: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D074: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D078: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283D07C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283D080: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283D084: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283D088: 388BCFF8  addi r4, r11, -0x3008
	ctx.r[4].s64 = ctx.r[11].s64 + -12296;
	// 8283D08C: 38A000C1  li r5, 0xc1
	ctx.r[5].s64 = 193;
	// 8283D090: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 8283D094: 485B5355  bl 0x82df23e8
	ctx.lr = 0x8283D098;
	sub_82DF23E8(ctx, base);
	// 8283D098: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283D09C: 41820018  beq 0x8283d0b4
	if ctx.cr[0].eq {
	pc = 0x8283D0B4; continue 'dispatch;
	}
	// 8283D0A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8283D0A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D0A8: 4BFFCED9  bl 0x82839f80
	ctx.lr = 0x8283D0AC;
	sub_82839F80(ctx, base);
	// 8283D0AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D0B0: 48000008  b 0x8283d0b8
	pc = 0x8283D0B8; continue 'dispatch;
	// 8283D0B4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283D0B8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283D0BC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283D0C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D0C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D0C8: 4BFFD751  bl 0x8283a818
	ctx.lr = 0x8283D0CC;
	sub_8283A818(ctx, base);
	// 8283D0CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283D0D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D0D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D0D8: 4BA82F29  bl 0x822c0000
	ctx.lr = 0x8283D0DC;
	sub_822C0000(ctx, base);
	// 8283D0DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283D0E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283D0E4: 4896B0D8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283D0E8 size=264
    let mut pc: u32 = 0x8283D0E8;
    'dispatch: loop {
        match pc {
            0x8283D0E8 => {
    //   block [0x8283D0E8..0x8283D1F0)
	// 8283D0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D0EC: 4896B079  bl 0x831a8164
	ctx.lr = 0x8283D0F0;
	sub_831A8130(ctx, base);
	// 8283D0F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D0F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D0F8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8283D0FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283D100: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8283D104: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8283D108: 48025A11  bl 0x82862b18
	ctx.lr = 0x8283D10C;
	sub_82862B18(ctx, base);
	// 8283D10C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283D110: 397F0064  addi r11, r31, 0x64
	ctx.r[11].s64 = ctx.r[31].s64 + 100;
	// 8283D114: 396AD064  addi r11, r10, -0x2f9c
	ctx.r[11].s64 = ctx.r[10].s64 + -12188;
	// 8283D118: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283D11C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283D120: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8283D124: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283D128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283D12C: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8283D130: 419A0024  beq cr6, 0x8283d154
	if ctx.cr[6].eq {
	pc = 0x8283D154; continue 'dispatch;
	}
	// 8283D134: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283D138: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283D13C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283D140: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283D144: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283D148: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283D14C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283D150: 4082FFE8  bne 0x8283d138
	if !ctx.cr[0].eq {
	pc = 0x8283D138; continue 'dispatch;
	}
	// 8283D154: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283D158: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8283D15C: 38EB6880  addi r7, r11, 0x6880
	ctx.r[7].s64 = ctx.r[11].s64 + 26752;
	// 8283D160: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 8283D164: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 8283D168: 3CC08338  lis r6, -0x7cc8
	ctx.r[6].s64 = -2093481984;
	// 8283D16C: 397F0070  addi r11, r31, 0x70
	ctx.r[11].s64 = ctx.r[31].s64 + 112;
	// 8283D170: 38C66910  addi r6, r6, 0x6910
	ctx.r[6].s64 = ctx.r[6].s64 + 26896;
	// 8283D174: 13E83C07  vcmpneb. (lvlx128) v31, v8, v7
	tmp.u32 = ctx.r[8].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283D178: 38A000C0  li r5, 0xc0
	ctx.r[5].s64 = 192;
	// 8283D17C: 13C93C07  vcmpneb. (lvlx128) v30, v9, v7
	tmp.u32 = ctx.r[9].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283D180: 3F608200  lis r27, -0x7e00
	ctx.r[27].s64 = -2113929216;
	// 8283D184: 13AA3C07  vcmpneb. (lvlx128) v29, v10, v7
	tmp.u32 = ctx.r[10].u32 + ctx.r[7].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283D188: 13803C07  vcmpneb. (lvlx128) v28, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283D18C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D1F0 size=84
    let mut pc: u32 = 0x8283D1F0;
    'dispatch: loop {
        match pc {
            0x8283D1F0 => {
    //   block [0x8283D1F0..0x8283D244)
	// 8283D1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283D1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283D1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D200: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D204: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D208: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 8283D20C: 396BD064  addi r11, r11, -0x2f9c
	ctx.r[11].s64 = ctx.r[11].s64 + -12188;
	// 8283D210: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283D214: 485B6215  bl 0x82df3428
	ctx.lr = 0x8283D218;
	sub_82DF3428(ctx, base);
	// 8283D218: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283D21C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283D220: 419A0008  beq cr6, 0x8283d228
	if ctx.cr[6].eq {
	pc = 0x8283D228; continue 'dispatch;
	}
	// 8283D224: 4BA8366D  bl 0x822c0890
	ctx.lr = 0x8283D228;
	sub_822C0890(ctx, base);
	// 8283D228: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283D22C: 4861F35D  bl 0x82e5c588
	ctx.lr = 0x8283D230;
	sub_82E5C588(ctx, base);
	// 8283D230: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8283D234: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283D238: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283D23C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283D240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D248 size=76
    let mut pc: u32 = 0x8283D248;
    'dispatch: loop {
        match pc {
            0x8283D248 => {
    //   block [0x8283D248..0x8283D294)
	// 8283D248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283D250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283D254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283D258: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D25C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D260: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283D264: 4BFFFF8D  bl 0x8283d1f0
	ctx.lr = 0x8283D268;
	sub_8283D1F0(ctx, base);
	// 8283D268: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283D26C: 4182000C  beq 0x8283d278
	if ctx.cr[0].eq {
	pc = 0x8283D278; continue 'dispatch;
	}
	// 8283D270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283D274: 485B5165  bl 0x82df23d8
	ctx.lr = 0x8283D278;
	sub_82DF23D8(ctx, base);
	// 8283D278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283D27C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283D280: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283D284: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283D288: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283D28C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283D290: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D298 size=164
    let mut pc: u32 = 0x8283D298;
    'dispatch: loop {
        match pc {
            0x8283D298 => {
    //   block [0x8283D298..0x8283D33C)
	// 8283D298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D29C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283D2A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283D2A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283D2A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D2AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283D2B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283D2B4: 4861C71D  bl 0x82e599d0
	ctx.lr = 0x8283D2B8;
	sub_82E599D0(ctx, base);
	// 8283D2B8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283D2BC: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283D2C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283D2C4: 419A000C  beq cr6, 0x8283d2d0
	if ctx.cr[6].eq {
	pc = 0x8283D2D0; continue 'dispatch;
	}
	// 8283D2C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8283D2CC: 4BA835C5  bl 0x822c0890
	ctx.lr = 0x8283D2D0;
	sub_822C0890(ctx, base);
	// 8283D2D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283D2D4: 419A004C  beq cr6, 0x8283d320
	if ctx.cr[6].eq {
	pc = 0x8283D320; continue 'dispatch;
	}
	// 8283D2D8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283D2DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283D2E0: 808B17D4  lwz r4, 0x17d4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6100 as u32) ) } as u64;
	// 8283D2E4: 485B6725  bl 0x82df3a08
	ctx.lr = 0x8283D2E8;
	sub_82DF3A08(ctx, base);
	// 8283D2E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283D2EC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8283D2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283D2F4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8283D2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283D2FC: 4E800421  bctrl
	ctx.lr = 0x8283D300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283D300: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283D304: 485B5F9D  bl 0x82df32a0
	ctx.lr = 0x8283D308;
	sub_82DF32A0(ctx, base);
	// 8283D308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D30C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283D310: 485B6119  bl 0x82df3428
	ctx.lr = 0x8283D314;
	sub_82DF3428(ctx, base);
	// 8283D314: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283D318: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8283D31C: 40820008  bne 0x8283d324
	if !ctx.cr[0].eq {
	pc = 0x8283D324; continue 'dispatch;
	}
	// 8283D320: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8283D324: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283D328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283D32C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283D330: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283D334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283D338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D340 size=144
    let mut pc: u32 = 0x8283D340;
    'dispatch: loop {
        match pc {
            0x8283D340 => {
    //   block [0x8283D340..0x8283D3D0)
	// 8283D340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D344: 4896AE21  bl 0x831a8164
	ctx.lr = 0x8283D348;
	sub_831A8130(ctx, base);
	// 8283D348: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D34C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D350: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8283D354: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283D358: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283D35C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8283D360: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283D364: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283D368: 38A000C2  li r5, 0xc2
	ctx.r[5].s64 = 194;
	// 8283D36C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8283D370: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8283D374: 485B5075  bl 0x82df23e8
	ctx.lr = 0x8283D378;
	sub_82DF23E8(ctx, base);
	// 8283D378: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283D37C: 41820020  beq 0x8283d39c
	if ctx.cr[0].eq {
	pc = 0x8283D39C; continue 'dispatch;
	}
	// 8283D380: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8283D384: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8283D388: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8283D38C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D390: 4BFFCEB9  bl 0x8283a248
	ctx.lr = 0x8283D394;
	sub_8283A248(ctx, base);
	// 8283D394: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D398: 48000008  b 0x8283d3a0
	pc = 0x8283D3A0; continue 'dispatch;
	// 8283D39C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283D3A0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283D3A4: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8283D3A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D3AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D3B0: 4BFFD531  bl 0x8283a8e0
	ctx.lr = 0x8283D3B4;
	sub_8283A8E0(ctx, base);
	// 8283D3B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283D3B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D3BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D3C0: 4BA82C41  bl 0x822c0000
	ctx.lr = 0x8283D3C4;
	sub_822C0000(ctx, base);
	// 8283D3C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283D3C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283D3CC: 4896ADE8  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D3D0 size=144
    let mut pc: u32 = 0x8283D3D0;
    'dispatch: loop {
        match pc {
            0x8283D3D0 => {
    //   block [0x8283D3D0..0x8283D460)
	// 8283D3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D3D4: 4896AD91  bl 0x831a8164
	ctx.lr = 0x8283D3D8;
	sub_831A8130(ctx, base);
	// 8283D3D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D3DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D3E0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8283D3E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283D3E8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283D3EC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8283D3F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283D3F4: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283D3F8: 38A001A1  li r5, 0x1a1
	ctx.r[5].s64 = 417;
	// 8283D3FC: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 8283D400: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8283D404: 485B4FE5  bl 0x82df23e8
	ctx.lr = 0x8283D408;
	sub_82DF23E8(ctx, base);
	// 8283D408: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283D40C: 41820020  beq 0x8283d42c
	if ctx.cr[0].eq {
	pc = 0x8283D42C; continue 'dispatch;
	}
	// 8283D410: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8283D414: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8283D418: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8283D41C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D420: 4BFFCEB9  bl 0x8283a2d8
	ctx.lr = 0x8283D424;
	sub_8283A2D8(ctx, base);
	// 8283D424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D428: 48000008  b 0x8283d430
	pc = 0x8283D430; continue 'dispatch;
	// 8283D42C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283D430: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283D434: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8283D438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D43C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D440: 4BFFD569  bl 0x8283a9a8
	ctx.lr = 0x8283D444;
	sub_8283A9A8(ctx, base);
	// 8283D444: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283D448: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D450: 4BA82BB1  bl 0x822c0000
	ctx.lr = 0x8283D454;
	sub_822C0000(ctx, base);
	// 8283D454: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283D458: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283D45C: 4896AD58  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D460 size=120
    let mut pc: u32 = 0x8283D460;
    'dispatch: loop {
        match pc {
            0x8283D460 => {
    //   block [0x8283D460..0x8283D4D8)
	// 8283D460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D464: 4896AD09  bl 0x831a816c
	ctx.lr = 0x8283D468;
	sub_831A8130(ctx, base);
	// 8283D468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D46C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D470: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283D474: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283D478: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283D47C: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283D480: 38A00233  li r5, 0x233
	ctx.r[5].s64 = 563;
	// 8283D484: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 8283D488: 485B4F61  bl 0x82df23e8
	ctx.lr = 0x8283D48C;
	sub_82DF23E8(ctx, base);
	// 8283D48C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283D490: 41820014  beq 0x8283d4a4
	if ctx.cr[0].eq {
	pc = 0x8283D4A4; continue 'dispatch;
	}
	// 8283D494: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D498: 4BFFCEB9  bl 0x8283a350
	ctx.lr = 0x8283D49C;
	sub_8283A350(ctx, base);
	// 8283D49C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D4A0: 48000008  b 0x8283d4a8
	pc = 0x8283D4A8; continue 'dispatch;
	// 8283D4A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283D4A8: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283D4AC: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283D4B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D4B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D4B8: 4BFFD5B9  bl 0x8283aa70
	ctx.lr = 0x8283D4BC;
	sub_8283AA70(ctx, base);
	// 8283D4BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283D4C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D4C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D4C8: 4BA82B39  bl 0x822c0000
	ctx.lr = 0x8283D4CC;
	sub_822C0000(ctx, base);
	// 8283D4CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283D4D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283D4D4: 4896ACE8  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D4D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D4D8 size=144
    let mut pc: u32 = 0x8283D4D8;
    'dispatch: loop {
        match pc {
            0x8283D4D8 => {
    //   block [0x8283D4D8..0x8283D568)
	// 8283D4D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D4DC: 4896AC89  bl 0x831a8164
	ctx.lr = 0x8283D4E0;
	sub_831A8130(ctx, base);
	// 8283D4E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D4E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D4E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8283D4EC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283D4F0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283D4F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8283D4F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283D4FC: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283D500: 38A0026D  li r5, 0x26d
	ctx.r[5].s64 = 621;
	// 8283D504: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 8283D508: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8283D50C: 485B4EDD  bl 0x82df23e8
	ctx.lr = 0x8283D510;
	sub_82DF23E8(ctx, base);
	// 8283D510: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283D514: 41820020  beq 0x8283d534
	if ctx.cr[0].eq {
	pc = 0x8283D534; continue 'dispatch;
	}
	// 8283D518: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8283D51C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8283D520: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8283D524: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D528: 4BFFCF11  bl 0x8283a438
	ctx.lr = 0x8283D52C;
	sub_8283A438(ctx, base);
	// 8283D52C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D530: 48000008  b 0x8283d538
	pc = 0x8283D538; continue 'dispatch;
	// 8283D534: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283D538: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283D53C: 3BDB0004  addi r30, r27, 4
	ctx.r[30].s64 = ctx.r[27].s64 + 4;
	// 8283D540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D544: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D548: 4BFFD5F1  bl 0x8283ab38
	ctx.lr = 0x8283D54C;
	sub_8283AB38(ctx, base);
	// 8283D54C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283D550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D558: 4BA82AA9  bl 0x822c0000
	ctx.lr = 0x8283D55C;
	sub_822C0000(ctx, base);
	// 8283D55C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283D560: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283D564: 4896AC50  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283D568 size=120
    let mut pc: u32 = 0x8283D568;
    'dispatch: loop {
        match pc {
            0x8283D568 => {
    //   block [0x8283D568..0x8283D5E0)
	// 8283D568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D56C: 4896AC01  bl 0x831a816c
	ctx.lr = 0x8283D570;
	sub_831A8130(ctx, base);
	// 8283D570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D574: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283D578: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283D57C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283D580: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283D584: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283D588: 38A002CA  li r5, 0x2ca
	ctx.r[5].s64 = 714;
	// 8283D58C: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8283D590: 485B4E59  bl 0x82df23e8
	ctx.lr = 0x8283D594;
	sub_82DF23E8(ctx, base);
	// 8283D594: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283D598: 41820014  beq 0x8283d5ac
	if ctx.cr[0].eq {
	pc = 0x8283D5AC; continue 'dispatch;
	}
	// 8283D59C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D5A0: 4BFFD011  bl 0x8283a5b0
	ctx.lr = 0x8283D5A4;
	sub_8283A5B0(ctx, base);
	// 8283D5A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D5A8: 48000008  b 0x8283d5b0
	pc = 0x8283D5B0; continue 'dispatch;
	// 8283D5AC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283D5B0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283D5B4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283D5B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D5BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D5C0: 4BFFD641  bl 0x8283ac00
	ctx.lr = 0x8283D5C4;
	sub_8283AC00(ctx, base);
	// 8283D5C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283D5C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283D5D0: 4BA82A31  bl 0x822c0000
	ctx.lr = 0x8283D5D4;
	sub_822C0000(ctx, base);
	// 8283D5D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283D5D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283D5DC: 4896ABE0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283D5E0 size=568
    let mut pc: u32 = 0x8283D5E0;
    'dispatch: loop {
        match pc {
            0x8283D5E0 => {
    //   block [0x8283D5E0..0x8283D818)
	// 8283D5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D5E4: 4896AB89  bl 0x831a816c
	ctx.lr = 0x8283D5E8;
	sub_831A8130(ctx, base);
	// 8283D5E8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8283D5EC: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D5F4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 8283D5F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D5FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283D600: 4BFB0B19  bl 0x827ee118
	ctx.lr = 0x8283D604;
	sub_827EE118(ctx, base);
	// 8283D604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283D608: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283D60C: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 8283D610: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283D614: 3D20832B  lis r9, -0x7cd5
	ctx.r[9].s64 = -2094333952;
	// 8283D618: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8283D61C: 3BCACA80  addi r30, r10, -0x3580
	ctx.r[30].s64 = ctx.r[10].s64 + -13696;
	// 8283D620: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8283D624: 3BA9CA90  addi r29, r9, -0x3570
	ctx.r[29].s64 = ctx.r[9].s64 + -13680;
	// 8283D628: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8283D62C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8283D630: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8283D634: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283D638: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283D63C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 8283D640: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 8283D644: 4863FA1D  bl 0x82e7d060
	ctx.lr = 0x8283D648;
	sub_82E7D060(ctx, base);
	// 8283D648: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283D64C: C1A10068  lfs f13, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283D650: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283D654: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8283D658: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8283D65C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8283D660: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8283D664: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8283D668: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 8283D66C: C00B08A8  lfs f0, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283D670: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283D674: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283D678: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8283D67C: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8283D680: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283D684: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8283D688: 4863F9D9  bl 0x82e7d060
	ctx.lr = 0x8283D68C;
	sub_82E7D060(ctx, base);
	// 8283D68C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D690: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 8283D694: 4BFB21BD  bl 0x827ef850
	ctx.lr = 0x8283D698;
	sub_827EF850(ctx, base);
	// 8283D698: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283D69C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8283D6A0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8283D6A4: 4863FC7D  bl 0x82e7d320
	ctx.lr = 0x8283D6A8;
	sub_82E7D320(ctx, base);
	// 8283D6A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283D6AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283D6B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283D6B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283D6B8: 4E800421  bctrl
	ctx.lr = 0x8283D6BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283D6BC: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 8283D6C0: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8283D6C4: 392100D0  addi r9, r1, 0xd0
	ctx.r[9].s64 = ctx.r[1].s64 + 208;
	// 8283D6C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D6CC: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 8283D6D0: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283D6D4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 8283D6D8: 13C050C7  vcmpequd (lvx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283D818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283D818 size=536
    let mut pc: u32 = 0x8283D818;
    'dispatch: loop {
        match pc {
            0x8283D818 => {
    //   block [0x8283D818..0x8283DA30)
	// 8283D818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283D81C: 4896A939  bl 0x831a8154
	ctx.lr = 0x8283D820;
	sub_831A8130(ctx, base);
	// 8283D820: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283D824: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283D828: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283D82C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8283D830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283D834: 485B61D5  bl 0x82df3a08
	ctx.lr = 0x8283D838;
	sub_82DF3A08(ctx, base);
	// 8283D838: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283D83C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8283D840: 4BFAED89  bl 0x827ec5c8
	ctx.lr = 0x8283D844;
	sub_827EC5C8(ctx, base);
	// 8283D844: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283D848: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8283D84C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283D850: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283D854: 485D77DD  bl 0x82e15030
	ctx.lr = 0x8283D858;
	sub_82E15030(ctx, base);
	// 8283D858: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 8283D85C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283D860: 419A0008  beq cr6, 0x8283d868
	if ctx.cr[6].eq {
	pc = 0x8283D868; continue 'dispatch;
	}
	// 8283D864: 4BA8302D  bl 0x822c0890
	ctx.lr = 0x8283D868;
	sub_822C0890(ctx, base);
	// 8283D868: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283D86C: 485B5BBD  bl 0x82df3428
	ctx.lr = 0x8283D870;
	sub_82DF3428(ctx, base);
	// 8283D870: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8283D874: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283D878: 419A01A0  beq cr6, 0x8283da18
	if ctx.cr[6].eq {
	pc = 0x8283DA18; continue 'dispatch;
	}
	// 8283D87C: 485D4E95  bl 0x82e12710
	ctx.lr = 0x8283D880;
	sub_82E12710(ctx, base);
	// 8283D880: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8283D884: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283D888: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8283D88C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283D890: 4E800421  bctrl
	ctx.lr = 0x8283D894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283D894: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283D898: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 8283D89C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 8283D8A0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 8283D8A4: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283D8A8: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283D8AC: C18B0038  lfs f12, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283D8B0: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283D8B4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8283D8B8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8283D8BC: D1810078  stfs f12, 0x78(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8283D8C0: D161007C  stfs f11, 0x7c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283D8C4: 4863F545  bl 0x82e7ce08
	ctx.lr = 0x8283D8C8;
	sub_82E7CE08(ctx, base);
	// 8283D8C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283D8CC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8283D8D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8283D8D4: 4BAC9EA5  bl 0x82307778
	ctx.lr = 0x8283D8D8;
	sub_82307778(ctx, base);
	// 8283D8D8: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 8283D8DC: 39410120  addi r10, r1, 0x120
	ctx.r[10].s64 = ctx.r[1].s64 + 288;
	// 8283D8E0: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283D8E4: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 8283D8E8: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 8283D8EC: 38E10130  addi r7, r1, 0x130
	ctx.r[7].s64 = ctx.r[1].s64 + 304;
	// 8283D8F0: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 8283D8F4: 13E05C07  vcmpneb. (lvlx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283D8F8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 8283D8FC: 3BA10140  addi r29, r1, 0x140
	ctx.r[29].s64 = ctx.r[1].s64 + 320;
	// 8283D900: 3B810150  addi r28, r1, 0x150
	ctx.r[28].s64 = ctx.r[1].s64 + 336;
	// 8283D904: 3B610160  addi r27, r1, 0x160
	ctx.r[27].s64 = ctx.r[1].s64 + 352;
	// 8283D908: 3B410110  addi r26, r1, 0x110
	ctx.r[26].s64 = ctx.r[1].s64 + 272;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283DA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283DA30 size=392
    let mut pc: u32 = 0x8283DA30;
    'dispatch: loop {
        match pc {
            0x8283DA30 => {
    //   block [0x8283DA30..0x8283DBB8)
	// 8283DA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283DA34: 4896A735  bl 0x831a8168
	ctx.lr = 0x8283DA38;
	sub_831A8130(ctx, base);
	// 8283DA38: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283DA3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8283DA40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283DA44: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 8283DA48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283DA4C: 485B5FBD  bl 0x82df3a08
	ctx.lr = 0x8283DA50;
	sub_82DF3A08(ctx, base);
	// 8283DA50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283DA54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283DA58: 485B61A9  bl 0x82df3c00
	ctx.lr = 0x8283DA5C;
	sub_82DF3C00(ctx, base);
	// 8283DA5C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 8283DA60: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283DA64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283DBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283DBB8 size=828
    let mut pc: u32 = 0x8283DBB8;
    'dispatch: loop {
        match pc {
            0x8283DBB8 => {
    //   block [0x8283DBB8..0x8283DEF4)
	// 8283DBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283DBBC: 4896A5A9  bl 0x831a8164
	ctx.lr = 0x8283DBC0;
	sub_831A8130(ctx, base);
	// 8283DBC0: 9421FC80  stwu r1, -0x380(r1)
	ea = ctx.r[1].u32.wrapping_add(-896 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283DBC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283DBC8: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283DBCC: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8283DBD0: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283DBD4: 392100B0  addi r9, r1, 0xb0
	ctx.r[9].s64 = ctx.r[1].s64 + 176;
	// 8283DBD8: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 8283DBDC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8283DBE0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8283DBE4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 8283DBE8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283DEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283DEF8 size=172
    let mut pc: u32 = 0x8283DEF8;
    'dispatch: loop {
        match pc {
            0x8283DEF8 => {
    //   block [0x8283DEF8..0x8283DFA4)
	// 8283DEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283DEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283DF00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283DF04: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8283DF08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283DF0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283DF10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283DF14: C01F0298  lfs f0, 0x298(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283DF18: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8283DF1C: 4BFB1935  bl 0x827ef850
	ctx.lr = 0x8283DF20;
	sub_827EF850(ctx, base);
	// 8283DF20: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8283DF24: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283DF28: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283DF2C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8283DF30: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283DF34: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 8283DF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283DF3C: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283DFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283DFA8 size=328
    let mut pc: u32 = 0x8283DFA8;
    'dispatch: loop {
        match pc {
            0x8283DFA8 => {
    //   block [0x8283DFA8..0x8283E0F0)
	// 8283DFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283DFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283DFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283DFB4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283DFB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283DFBC: 4BFAD67D  bl 0x827eb638
	ctx.lr = 0x8283DFC0;
	sub_827EB638(ctx, base);
	// 8283DFC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283DFC4: 4BFAE155  bl 0x827ec118
	ctx.lr = 0x8283DFC8;
	sub_827EC118(ctx, base);
	// 8283DFC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283DFCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283DFD0: 388BCB04  addi r4, r11, -0x34fc
	ctx.r[4].s64 = ctx.r[11].s64 + -13564;
	// 8283DFD4: 485B5A35  bl 0x82df3a08
	ctx.lr = 0x8283DFD8;
	sub_82DF3A08(ctx, base);
	// 8283DFD8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283DFDC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283DFE0: 480256E1  bl 0x828636c0
	ctx.lr = 0x8283DFE4;
	sub_828636C0(ctx, base);
	// 8283DFE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283DFE8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283DFEC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283DFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283DFF4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8283DFF8: 419A0024  beq cr6, 0x8283e01c
	if ctx.cr[6].eq {
	pc = 0x8283E01C; continue 'dispatch;
	}
	// 8283DFFC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E000: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E004: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E008: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E00C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E010: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E014: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E018: 4082FFE8  bne 0x8283e000
	if !ctx.cr[0].eq {
	pc = 0x8283E000; continue 'dispatch;
	}
	// 8283E01C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8283E020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E024: 4BFAED35  bl 0x827ecd58
	ctx.lr = 0x8283E028;
	sub_827ECD58(ctx, base);
	// 8283E028: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283E02C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E030: 419A0008  beq cr6, 0x8283e038
	if ctx.cr[6].eq {
	pc = 0x8283E038; continue 'dispatch;
	}
	// 8283E034: 4BA8285D  bl 0x822c0890
	ctx.lr = 0x8283E038;
	sub_822C0890(ctx, base);
	// 8283E038: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283E03C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E040: 419A0008  beq cr6, 0x8283e048
	if ctx.cr[6].eq {
	pc = 0x8283E048; continue 'dispatch;
	}
	// 8283E044: 4BA8284D  bl 0x822c0890
	ctx.lr = 0x8283E048;
	sub_822C0890(ctx, base);
	// 8283E048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283E04C: 485B53DD  bl 0x82df3428
	ctx.lr = 0x8283E050;
	sub_82DF3428(ctx, base);
	// 8283E050: 38FF02EC  addi r7, r31, 0x2ec
	ctx.r[7].s64 = ctx.r[31].s64 + 748;
	// 8283E054: 389F0280  addi r4, r31, 0x280
	ctx.r[4].s64 = ctx.r[31].s64 + 640;
	// 8283E058: 80BF02A0  lwz r5, 0x2a0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 8283E05C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283E060: 80DF0254  lwz r6, 0x254(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 8283E064: 4BFFF36D  bl 0x8283d3d0
	ctx.lr = 0x8283E068;
	sub_8283D3D0(ctx, base);
	// 8283E068: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E06C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8283E070: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283E074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E078: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8283E07C: 419A0024  beq cr6, 0x8283e0a0
	if ctx.cr[6].eq {
	pc = 0x8283E0A0; continue 'dispatch;
	}
	// 8283E080: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E084: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E088: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E08C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E090: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E094: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E098: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E09C: 4082FFE8  bne 0x8283e084
	if !ctx.cr[0].eq {
	pc = 0x8283E084; continue 'dispatch;
	}
	// 8283E0A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283E0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E0A8: 4BFAEE89  bl 0x827ecf30
	ctx.lr = 0x8283E0AC;
	sub_827ECF30(ctx, base);
	// 8283E0AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283E0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E0B4: 419A0008  beq cr6, 0x8283e0bc
	if ctx.cr[6].eq {
	pc = 0x8283E0BC; continue 'dispatch;
	}
	// 8283E0B8: 4BA827D9  bl 0x822c0890
	ctx.lr = 0x8283E0BC;
	sub_822C0890(ctx, base);
	// 8283E0BC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8283E0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E0C4: 419A0008  beq cr6, 0x8283e0cc
	if ctx.cr[6].eq {
	pc = 0x8283E0CC; continue 'dispatch;
	}
	// 8283E0C8: 4BA827C9  bl 0x822c0890
	ctx.lr = 0x8283E0CC;
	sub_822C0890(ctx, base);
	// 8283E0CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283E0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E0D4: 388BD1A0  addi r4, r11, -0x2e60
	ctx.r[4].s64 = ctx.r[11].s64 + -11872;
	// 8283E0D8: 4BFDA331  bl 0x82818408
	ctx.lr = 0x8283E0DC;
	sub_82818408(ctx, base);
	// 8283E0DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8283E0E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283E0E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283E0E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283E0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E0F0 size=456
    let mut pc: u32 = 0x8283E0F0;
    'dispatch: loop {
        match pc {
            0x8283E0F0 => {
    //   block [0x8283E0F0..0x8283E2B8)
	// 8283E0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E0F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283E0F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283E0FC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E104: 4BFAE015  bl 0x827ec118
	ctx.lr = 0x8283E108;
	sub_827EC118(ctx, base);
	// 8283E108: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283E10C: 809F0254  lwz r4, 0x254(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(596 as u32) ) } as u64;
	// 8283E110: 4BFFF351  bl 0x8283d460
	ctx.lr = 0x8283E114;
	sub_8283D460(ctx, base);
	// 8283E114: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E118: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283E11C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283E120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E124: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8283E128: 419A0024  beq cr6, 0x8283e14c
	if ctx.cr[6].eq {
	pc = 0x8283E14C; continue 'dispatch;
	}
	// 8283E12C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E130: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E134: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E138: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E13C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E140: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E144: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E148: 4082FFE8  bne 0x8283e130
	if !ctx.cr[0].eq {
	pc = 0x8283E130; continue 'dispatch;
	}
	// 8283E14C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8283E150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E154: 4BFAEDDD  bl 0x827ecf30
	ctx.lr = 0x8283E158;
	sub_827ECF30(ctx, base);
	// 8283E158: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283E15C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E160: 419A0008  beq cr6, 0x8283e168
	if ctx.cr[6].eq {
	pc = 0x8283E168; continue 'dispatch;
	}
	// 8283E164: 4BA8272D  bl 0x822c0890
	ctx.lr = 0x8283E168;
	sub_822C0890(ctx, base);
	// 8283E168: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8283E16C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E170: 419A0008  beq cr6, 0x8283e178
	if ctx.cr[6].eq {
	pc = 0x8283E178; continue 'dispatch;
	}
	// 8283E174: 4BA8271D  bl 0x822c0890
	ctx.lr = 0x8283E178;
	sub_822C0890(ctx, base);
	// 8283E178: 38FF029C  addi r7, r31, 0x29c
	ctx.r[7].s64 = ctx.r[31].s64 + 668;
	// 8283E17C: 38DF0298  addi r6, r31, 0x298
	ctx.r[6].s64 = ctx.r[31].s64 + 664;
	// 8283E180: 38BF02A0  addi r5, r31, 0x2a0
	ctx.r[5].s64 = ctx.r[31].s64 + 672;
	// 8283E184: 389F0280  addi r4, r31, 0x280
	ctx.r[4].s64 = ctx.r[31].s64 + 640;
	// 8283E188: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8283E18C: 4BFFF1B5  bl 0x8283d340
	ctx.lr = 0x8283E190;
	sub_8283D340(ctx, base);
	// 8283E190: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E194: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8283E198: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283E19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E1A0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8283E1A4: 419A0024  beq cr6, 0x8283e1c8
	if ctx.cr[6].eq {
	pc = 0x8283E1C8; continue 'dispatch;
	}
	// 8283E1A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E1AC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E1B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E1B4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E1B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E1BC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E1C0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E1C4: 4082FFE8  bne 0x8283e1ac
	if !ctx.cr[0].eq {
	pc = 0x8283E1AC; continue 'dispatch;
	}
	// 8283E1C8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283E1CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E1D0: 4BFAEE09  bl 0x827ecfd8
	ctx.lr = 0x8283E1D4;
	sub_827ECFD8(ctx, base);
	// 8283E1D4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283E1D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E1DC: 419A0008  beq cr6, 0x8283e1e4
	if ctx.cr[6].eq {
	pc = 0x8283E1E4; continue 'dispatch;
	}
	// 8283E1E0: 4BA826B1  bl 0x822c0890
	ctx.lr = 0x8283E1E4;
	sub_822C0890(ctx, base);
	// 8283E1E4: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 8283E1E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E1EC: 419A0008  beq cr6, 0x8283e1f4
	if ctx.cr[6].eq {
	pc = 0x8283E1F4; continue 'dispatch;
	}
	// 8283E1F0: 4BA826A1  bl 0x822c0890
	ctx.lr = 0x8283E1F4;
	sub_822C0890(ctx, base);
	// 8283E1F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283E1F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283E1FC: 388BCAE4  addi r4, r11, -0x351c
	ctx.r[4].s64 = ctx.r[11].s64 + -13596;
	// 8283E200: 485B5809  bl 0x82df3a08
	ctx.lr = 0x8283E204;
	sub_82DF3A08(ctx, base);
	// 8283E204: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283E208: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8283E20C: 480254B5  bl 0x828636c0
	ctx.lr = 0x8283E210;
	sub_828636C0(ctx, base);
	// 8283E210: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E214: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8283E218: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283E21C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E220: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8283E224: 419A0024  beq cr6, 0x8283e248
	if ctx.cr[6].eq {
	pc = 0x8283E248; continue 'dispatch;
	}
	// 8283E228: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E22C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E230: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E234: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E238: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E23C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E240: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E244: 4082FFE8  bne 0x8283e22c
	if !ctx.cr[0].eq {
	pc = 0x8283E22C; continue 'dispatch;
	}
	// 8283E248: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8283E24C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E250: 4BFAEB09  bl 0x827ecd58
	ctx.lr = 0x8283E254;
	sub_827ECD58(ctx, base);
	// 8283E254: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283E258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E25C: 419A0008  beq cr6, 0x8283e264
	if ctx.cr[6].eq {
	pc = 0x8283E264; continue 'dispatch;
	}
	// 8283E260: 4BA82631  bl 0x822c0890
	ctx.lr = 0x8283E264;
	sub_822C0890(ctx, base);
	// 8283E264: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8283E268: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E26C: 419A0008  beq cr6, 0x8283e274
	if ctx.cr[6].eq {
	pc = 0x8283E274; continue 'dispatch;
	}
	// 8283E270: 4BA82621  bl 0x822c0890
	ctx.lr = 0x8283E274;
	sub_822C0890(ctx, base);
	// 8283E274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283E278: 485B51B1  bl 0x82df3428
	ctx.lr = 0x8283E27C;
	sub_82DF3428(ctx, base);
	// 8283E27C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283E280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E284: 388BD1C8  addi r4, r11, -0x2e38
	ctx.r[4].s64 = ctx.r[11].s64 + -11832;
	// 8283E288: 4BFDAA21  bl 0x82818ca8
	ctx.lr = 0x8283E28C;
	sub_82818CA8(ctx, base);
	// 8283E28C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283E290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E294: 388BD1B4  addi r4, r11, -0x2e4c
	ctx.r[4].s64 = ctx.r[11].s64 + -11852;
	// 8283E298: 4BFDA171  bl 0x82818408
	ctx.lr = 0x8283E29C;
	sub_82818408(ctx, base);
	// 8283E29C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8283E2A0: 917F02A4  stw r11, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 8283E2A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8283E2A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283E2AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283E2B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283E2B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283E2B8 size=464
    let mut pc: u32 = 0x8283E2B8;
    'dispatch: loop {
        match pc {
            0x8283E2B8 => {
    //   block [0x8283E2B8..0x8283E488)
	// 8283E2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E2BC: 48969EB1  bl 0x831a816c
	ctx.lr = 0x8283E2C0;
	sub_831A8130(ctx, base);
	// 8283E2C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E2C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283E2C8: 48122299  bl 0x82960560
	ctx.lr = 0x8283E2CC;
	sub_82960560(ctx, base);
	// 8283E2CC: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 8283E2D0: 41820198  beq 0x8283e468
	if ctx.cr[0].eq {
	pc = 0x8283E468; continue 'dispatch;
	}
	// 8283E2D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E2D8: 4BFB08B1  bl 0x827eeb88
	ctx.lr = 0x8283E2DC;
	sub_827EEB88(ctx, base);
	// 8283E2DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E2E0: 4BFADE39  bl 0x827ec118
	ctx.lr = 0x8283E2E4;
	sub_827EC118(ctx, base);
	// 8283E2E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283E2E8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E2EC: 388BD108  addi r4, r11, -0x2ef8
	ctx.r[4].s64 = ctx.r[11].s64 + -12024;
	// 8283E2F0: 38A003BB  li r5, 0x3bb
	ctx.r[5].s64 = 955;
	// 8283E2F4: 38600064  li r3, 0x64
	ctx.r[3].s64 = 100;
	// 8283E2F8: 485B40F1  bl 0x82df23e8
	ctx.lr = 0x8283E2FC;
	sub_82DF23E8(ctx, base);
	// 8283E2FC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E300: 41820010  beq 0x8283e310
	if ctx.cr[0].eq {
	pc = 0x8283E310; continue 'dispatch;
	}
	// 8283E304: 4BFFBD45  bl 0x8283a048
	ctx.lr = 0x8283E308;
	sub_8283A048(ctx, base);
	// 8283E308: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E30C: 48000008  b 0x8283e314
	pc = 0x8283E314; continue 'dispatch;
	// 8283E310: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E314: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8283E318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E31C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283E320: 4BFFCF21  bl 0x8283b240
	ctx.lr = 0x8283E324;
	sub_8283B240(ctx, base);
	// 8283E324: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E328: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E32C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283E330: 4BA81CD1  bl 0x822c0000
	ctx.lr = 0x8283E334;
	sub_822C0000(ctx, base);
	// 8283E334: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283E338: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283E33C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283E340: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8283E344: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8283E348: 419A0024  beq cr6, 0x8283e36c
	if ctx.cr[6].eq {
	pc = 0x8283E36C; continue 'dispatch;
	}
	// 8283E34C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8283E350: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E354: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E358: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E35C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E360: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E364: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E368: 4082FFE8  bne 0x8283e350
	if !ctx.cr[0].eq {
	pc = 0x8283E350; continue 'dispatch;
	}
	// 8283E36C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283E370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E374: 4BFAE9E5  bl 0x827ecd58
	ctx.lr = 0x8283E378;
	sub_827ECD58(ctx, base);
	// 8283E378: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283E37C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E380: 419A0008  beq cr6, 0x8283e388
	if ctx.cr[6].eq {
	pc = 0x8283E388; continue 'dispatch;
	}
	// 8283E384: 4BA8250D  bl 0x822c0890
	ctx.lr = 0x8283E388;
	sub_822C0890(ctx, base);
	// 8283E388: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283E38C: 419A000C  beq cr6, 0x8283e398
	if ctx.cr[6].eq {
	pc = 0x8283E398; continue 'dispatch;
	}
	// 8283E390: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E394: 4BA824FD  bl 0x822c0890
	ctx.lr = 0x8283E398;
	sub_822C0890(ctx, base);
	// 8283E398: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283E39C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8283E3A0: 4BFB14B1  bl 0x827ef850
	ctx.lr = 0x8283E3A4;
	sub_827EF850(ctx, base);
	// 8283E3A4: 39600298  li r11, 0x298
	ctx.r[11].s64 = 664;
	// 8283E3A8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8283E3AC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8283E3B0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8283E3B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283E3B8: 13FE5C07  vcmpneb. (lvlx128) v31, v30, v11
	tmp.u32 = ctx.r[30].u32 + ctx.r[11].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283E3BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283E3C0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E488 size=176
    let mut pc: u32 = 0x8283E488;
    'dispatch: loop {
        match pc {
            0x8283E488 => {
    //   block [0x8283E488..0x8283E538)
	// 8283E488: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E48C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283E490: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283E494: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E498: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E49C: 817F02A4  lwz r11, 0x2a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(676 as u32) ) } as u64;
	// 8283E4A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E4A4: 419A0080  beq cr6, 0x8283e524
	if ctx.cr[6].eq {
	pc = 0x8283E524; continue 'dispatch;
	}
	// 8283E4A8: 389F02C8  addi r4, r31, 0x2c8
	ctx.r[4].s64 = ctx.r[31].s64 + 712;
	// 8283E4AC: 80BF02A8  lwz r5, 0x2a8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 8283E4B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283E4B4: 4BFFEBB5  bl 0x8283d068
	ctx.lr = 0x8283E4B8;
	sub_8283D068(ctx, base);
	// 8283E4B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E4BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283E4C0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283E4C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E4C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283E4CC: 419A0024  beq cr6, 0x8283e4f0
	if ctx.cr[6].eq {
	pc = 0x8283E4F0; continue 'dispatch;
	}
	// 8283E4D0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E4D4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E4D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E4DC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283E4E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283E4E4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283E4E8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283E4EC: 4082FFE8  bne 0x8283e4d4
	if !ctx.cr[0].eq {
	pc = 0x8283E4D4; continue 'dispatch;
	}
	// 8283E4F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283E4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E4F8: 4BFAE861  bl 0x827ecd58
	ctx.lr = 0x8283E4FC;
	sub_827ECD58(ctx, base);
	// 8283E4FC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283E500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E504: 419A0008  beq cr6, 0x8283e50c
	if ctx.cr[6].eq {
	pc = 0x8283E50C; continue 'dispatch;
	}
	// 8283E508: 4BA82389  bl 0x822c0890
	ctx.lr = 0x8283E50C;
	sub_822C0890(ctx, base);
	// 8283E50C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283E510: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283E514: 419A0008  beq cr6, 0x8283e51c
	if ctx.cr[6].eq {
	pc = 0x8283E51C; continue 'dispatch;
	}
	// 8283E518: 4BA82379  bl 0x822c0890
	ctx.lr = 0x8283E51C;
	sub_822C0890(ctx, base);
	// 8283E51C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8283E520: 917F02A4  stw r11, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 8283E524: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283E52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283E530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283E534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E538 size=112
    let mut pc: u32 = 0x8283E538;
    'dispatch: loop {
        match pc {
            0x8283E538 => {
    //   block [0x8283E538..0x8283E5A8)
	// 8283E538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E53C: 48969C31  bl 0x831a816c
	ctx.lr = 0x8283E540;
	sub_831A8130(ctx, base);
	// 8283E540: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E548: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E54C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E550: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E554: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8283E558: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8283E55C: 485B3E8D  bl 0x82df23e8
	ctx.lr = 0x8283E560;
	sub_82DF23E8(ctx, base);
	// 8283E560: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E564: 41820010  beq 0x8283e574
	if ctx.cr[0].eq {
	pc = 0x8283E574; continue 'dispatch;
	}
	// 8283E568: 4800DBB1  bl 0x8284c118
	ctx.lr = 0x8283E56C;
	sub_8284C118(ctx, base);
	// 8283E56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E570: 48000008  b 0x8283e578
	pc = 0x8283E578; continue 'dispatch;
	// 8283E574: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E578: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E57C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E580: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E588: 4BFFCD81  bl 0x8283b308
	ctx.lr = 0x8283E58C;
	sub_8283B308(ctx, base);
	// 8283E58C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E590: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E594: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E598: 4BA81A69  bl 0x822c0000
	ctx.lr = 0x8283E59C;
	sub_822C0000(ctx, base);
	// 8283E59C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E5A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E5A4: 48969C18  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E5A8 size=120
    let mut pc: u32 = 0x8283E5A8;
    'dispatch: loop {
        match pc {
            0x8283E5A8 => {
    //   block [0x8283E5A8..0x8283E620)
	// 8283E5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E5AC: 48969BC1  bl 0x831a816c
	ctx.lr = 0x8283E5B0;
	sub_831A8130(ctx, base);
	// 8283E5B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E5B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E5B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E5BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283E5C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E5C4: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E5C8: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8283E5CC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8283E5D0: 485B3E19  bl 0x82df23e8
	ctx.lr = 0x8283E5D4;
	sub_82DF23E8(ctx, base);
	// 8283E5D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E5D8: 41820014  beq 0x8283e5ec
	if ctx.cr[0].eq {
	pc = 0x8283E5EC; continue 'dispatch;
	}
	// 8283E5DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E5E0: 4800DA51  bl 0x8284c030
	ctx.lr = 0x8283E5E4;
	sub_8284C030(ctx, base);
	// 8283E5E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E5E8: 48000008  b 0x8283e5f0
	pc = 0x8283E5F0; continue 'dispatch;
	// 8283E5EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E5F0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E5F4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E5F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E5FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E600: 4BFFCDD1  bl 0x8283b3d0
	ctx.lr = 0x8283E604;
	sub_8283B3D0(ctx, base);
	// 8283E604: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E608: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E60C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E610: 4BA819F1  bl 0x822c0000
	ctx.lr = 0x8283E614;
	sub_822C0000(ctx, base);
	// 8283E614: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E618: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E61C: 48969BA0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E620 size=112
    let mut pc: u32 = 0x8283E620;
    'dispatch: loop {
        match pc {
            0x8283E620 => {
    //   block [0x8283E620..0x8283E690)
	// 8283E620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E624: 48969B49  bl 0x831a816c
	ctx.lr = 0x8283E628;
	sub_831A8130(ctx, base);
	// 8283E628: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E62C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E630: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E634: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E638: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E63C: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8283E640: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8283E644: 485B3DA5  bl 0x82df23e8
	ctx.lr = 0x8283E648;
	sub_82DF23E8(ctx, base);
	// 8283E648: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E64C: 41820010  beq 0x8283e65c
	if ctx.cr[0].eq {
	pc = 0x8283E65C; continue 'dispatch;
	}
	// 8283E650: 4800DC81  bl 0x8284c2d0
	ctx.lr = 0x8283E654;
	sub_8284C2D0(ctx, base);
	// 8283E654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E658: 48000008  b 0x8283e660
	pc = 0x8283E660; continue 'dispatch;
	// 8283E65C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E660: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E664: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E66C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E670: 4BFFCE29  bl 0x8283b498
	ctx.lr = 0x8283E674;
	sub_8283B498(ctx, base);
	// 8283E674: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E678: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E67C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E680: 4BA81981  bl 0x822c0000
	ctx.lr = 0x8283E684;
	sub_822C0000(ctx, base);
	// 8283E684: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E688: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E68C: 48969B30  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E690 size=112
    let mut pc: u32 = 0x8283E690;
    'dispatch: loop {
        match pc {
            0x8283E690 => {
    //   block [0x8283E690..0x8283E700)
	// 8283E690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E694: 48969AD9  bl 0x831a816c
	ctx.lr = 0x8283E698;
	sub_831A8130(ctx, base);
	// 8283E698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E69C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E6A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E6A4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E6A8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E6AC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8283E6B0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8283E6B4: 485B3D35  bl 0x82df23e8
	ctx.lr = 0x8283E6B8;
	sub_82DF23E8(ctx, base);
	// 8283E6B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E6BC: 41820010  beq 0x8283e6cc
	if ctx.cr[0].eq {
	pc = 0x8283E6CC; continue 'dispatch;
	}
	// 8283E6C0: 4800DA11  bl 0x8284c0d0
	ctx.lr = 0x8283E6C4;
	sub_8284C0D0(ctx, base);
	// 8283E6C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E6C8: 48000008  b 0x8283e6d0
	pc = 0x8283E6D0; continue 'dispatch;
	// 8283E6CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E6D0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E6D4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E6D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E6DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E6E0: 4BFFCE81  bl 0x8283b560
	ctx.lr = 0x8283E6E4;
	sub_8283B560(ctx, base);
	// 8283E6E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E6E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E6EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E6F0: 4BA81911  bl 0x822c0000
	ctx.lr = 0x8283E6F4;
	sub_822C0000(ctx, base);
	// 8283E6F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E6F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E6FC: 48969AC0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E700 size=120
    let mut pc: u32 = 0x8283E700;
    'dispatch: loop {
        match pc {
            0x8283E700 => {
    //   block [0x8283E700..0x8283E778)
	// 8283E700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E704: 48969A69  bl 0x831a816c
	ctx.lr = 0x8283E708;
	sub_831A8130(ctx, base);
	// 8283E708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E70C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E710: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E714: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283E718: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E71C: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E720: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8283E724: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8283E728: 485B3CC1  bl 0x82df23e8
	ctx.lr = 0x8283E72C;
	sub_82DF23E8(ctx, base);
	// 8283E72C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E730: 41820014  beq 0x8283e744
	if ctx.cr[0].eq {
	pc = 0x8283E744; continue 'dispatch;
	}
	// 8283E734: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E738: 4800DA89  bl 0x8284c1c0
	ctx.lr = 0x8283E73C;
	sub_8284C1C0(ctx, base);
	// 8283E73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E740: 48000008  b 0x8283e748
	pc = 0x8283E748; continue 'dispatch;
	// 8283E744: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E748: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E74C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E750: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E758: 4BFFCED1  bl 0x8283b628
	ctx.lr = 0x8283E75C;
	sub_8283B628(ctx, base);
	// 8283E75C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E760: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E764: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E768: 4BA81899  bl 0x822c0000
	ctx.lr = 0x8283E76C;
	sub_822C0000(ctx, base);
	// 8283E76C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E774: 48969A48  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E778 size=124
    let mut pc: u32 = 0x8283E778;
    'dispatch: loop {
        match pc {
            0x8283E778 => {
    //   block [0x8283E778..0x8283E7F4)
	// 8283E778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E77C: 489699F1  bl 0x831a816c
	ctx.lr = 0x8283E780;
	sub_831A8130(ctx, base);
	// 8283E780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E784: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E788: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E78C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E790: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E794: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8283E798: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 8283E79C: 485B3C4D  bl 0x82df23e8
	ctx.lr = 0x8283E7A0;
	sub_82DF23E8(ctx, base);
	// 8283E7A0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8283E7A4: 4182001C  beq 0x8283e7c0
	if ctx.cr[0].eq {
	pc = 0x8283E7C0; continue 'dispatch;
	}
	// 8283E7A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E7AC: 4861AED5  bl 0x82e59680
	ctx.lr = 0x8283E7B0;
	sub_82E59680(ctx, base);
	// 8283E7B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283E7B4: 396BCBA8  addi r11, r11, -0x3458
	ctx.r[11].s64 = ctx.r[11].s64 + -13400;
	// 8283E7B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8283E7BC: 48000008  b 0x8283e7c4
	pc = 0x8283E7C4; continue 'dispatch;
	// 8283E7C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E7C4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E7C8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E7CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E7D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E7D4: 4BFFCF1D  bl 0x8283b6f0
	ctx.lr = 0x8283E7D8;
	sub_8283B6F0(ctx, base);
	// 8283E7D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E7DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E7E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E7E4: 4BA8181D  bl 0x822c0000
	ctx.lr = 0x8283E7E8;
	sub_822C0000(ctx, base);
	// 8283E7E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E7EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E7F0: 489699CC  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E7F8 size=120
    let mut pc: u32 = 0x8283E7F8;
    'dispatch: loop {
        match pc {
            0x8283E7F8 => {
    //   block [0x8283E7F8..0x8283E870)
	// 8283E7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E7FC: 48969971  bl 0x831a816c
	ctx.lr = 0x8283E800;
	sub_831A8130(ctx, base);
	// 8283E800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E804: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E808: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E80C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283E810: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E814: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E818: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8283E81C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8283E820: 485B3BC9  bl 0x82df23e8
	ctx.lr = 0x8283E824;
	sub_82DF23E8(ctx, base);
	// 8283E824: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E828: 41820014  beq 0x8283e83c
	if ctx.cr[0].eq {
	pc = 0x8283E83C; continue 'dispatch;
	}
	// 8283E82C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E830: 4800DBB1  bl 0x8284c3e0
	ctx.lr = 0x8283E834;
	sub_8284C3E0(ctx, base);
	// 8283E834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E838: 48000008  b 0x8283e840
	pc = 0x8283E840; continue 'dispatch;
	// 8283E83C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E840: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E844: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E848: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E84C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E850: 4BFFCF69  bl 0x8283b7b8
	ctx.lr = 0x8283E854;
	sub_8283B7B8(ctx, base);
	// 8283E854: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E858: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E85C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E860: 4BA817A1  bl 0x822c0000
	ctx.lr = 0x8283E864;
	sub_822C0000(ctx, base);
	// 8283E864: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E868: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E86C: 48969950  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283E870 size=136
    let mut pc: u32 = 0x8283E870;
    'dispatch: loop {
        match pc {
            0x8283E870 => {
    //   block [0x8283E870..0x8283E8F8)
	// 8283E870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E874: 489698F5  bl 0x831a8168
	ctx.lr = 0x8283E878;
	sub_831A8130(ctx, base);
	// 8283E878: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E87C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E880: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8283E884: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283E888: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283E88C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 8283E890: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E894: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E898: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8283E89C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 8283E8A0: 485B3B49  bl 0x82df23e8
	ctx.lr = 0x8283E8A4;
	sub_82DF23E8(ctx, base);
	// 8283E8A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E8A8: 4182001C  beq 0x8283e8c4
	if ctx.cr[0].eq {
	pc = 0x8283E8C4; continue 'dispatch;
	}
	// 8283E8AC: C07D0000  lfs f3, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8283E8B0: C05E0000  lfs f2, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8283E8B4: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283E8B8: 4800DAB1  bl 0x8284c368
	ctx.lr = 0x8283E8BC;
	sub_8284C368(ctx, base);
	// 8283E8BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E8C0: 48000008  b 0x8283e8c8
	pc = 0x8283E8C8; continue 'dispatch;
	// 8283E8C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E8C8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E8CC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 8283E8D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E8D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E8D8: 4BFFCFA9  bl 0x8283b880
	ctx.lr = 0x8283E8DC;
	sub_8283B880(ctx, base);
	// 8283E8DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E8E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E8E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E8E8: 4BA81719  bl 0x822c0000
	ctx.lr = 0x8283E8EC;
	sub_822C0000(ctx, base);
	// 8283E8EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8283E8F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283E8F4: 489698C4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283E8F8 size=112
    let mut pc: u32 = 0x8283E8F8;
    'dispatch: loop {
        match pc {
            0x8283E8F8 => {
    //   block [0x8283E8F8..0x8283E968)
	// 8283E8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E8FC: 48969871  bl 0x831a816c
	ctx.lr = 0x8283E900;
	sub_831A8130(ctx, base);
	// 8283E900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E904: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283E908: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8283E90C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283E910: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 8283E914: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 8283E918: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 8283E91C: 485B3ACD  bl 0x82df23e8
	ctx.lr = 0x8283E920;
	sub_82DF23E8(ctx, base);
	// 8283E920: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283E924: 41820010  beq 0x8283e934
	if ctx.cr[0].eq {
	pc = 0x8283E934; continue 'dispatch;
	}
	// 8283E928: 4800D629  bl 0x8284bf50
	ctx.lr = 0x8283E92C;
	sub_8284BF50(ctx, base);
	// 8283E92C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283E930: 48000008  b 0x8283e938
	pc = 0x8283E938; continue 'dispatch;
	// 8283E934: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283E938: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8283E93C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 8283E940: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E948: 4BFFD001  bl 0x8283b948
	ctx.lr = 0x8283E94C;
	sub_8283B948(ctx, base);
	// 8283E94C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283E950: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283E954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E958: 4BA816A9  bl 0x822c0000
	ctx.lr = 0x8283E95C;
	sub_822C0000(ctx, base);
	// 8283E95C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283E960: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8283E964: 48969858  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283E968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283E968 size=288
    let mut pc: u32 = 0x8283E968;
    'dispatch: loop {
        match pc {
            0x8283E968 => {
    //   block [0x8283E968..0x8283EA88)
	// 8283E968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283E96C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283E970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283E974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283E978: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8283E97C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283E980: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283E984: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283E988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E98C: 4BFAEE8D  bl 0x827ed818
	ctx.lr = 0x8283E990;
	sub_827ED818(ctx, base);
	// 8283E990: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283E994: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283E998: 4BCD0999  bl 0x8250f330
	ctx.lr = 0x8283E99C;
	sub_8250F330(ctx, base);
	// 8283E99C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E9A0: 4BCAAEB1  bl 0x824e9850
	ctx.lr = 0x8283E9A4;
	sub_824E9850(ctx, base);
	// 8283E9A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283E9A8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8283E9AC: 485B32E5  bl 0x82df1c90
	ctx.lr = 0x8283E9B0;
	sub_82DF1C90(ctx, base);
	// 8283E9B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283E9B4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283E9B8: 4BFFD319  bl 0x8283bcd0
	ctx.lr = 0x8283E9BC;
	sub_8283BCD0(ctx, base);
	// 8283E9BC: D03E006C  stfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8283E9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283E9C4: 4BFAEE5D  bl 0x827ed820
	ctx.lr = 0x8283E9C8;
	sub_827ED820(ctx, base);
	// 8283E9C8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8283E9CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283E9D0: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8283E9D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283E9D8: 4BFF7BC1  bl 0x82836598
	ctx.lr = 0x8283E9DC;
	sub_82836598(ctx, base);
	// 8283E9DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283E9E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283E9E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283E9E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283E9EC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283E9F0: 419A0024  beq cr6, 0x8283ea14
	if ctx.cr[6].eq {
	pc = 0x8283EA14; continue 'dispatch;
	}
	// 8283E9F4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283E9F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283E9FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EA00: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283EA04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283EA08: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283EA0C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EA10: 4082FFE8  bne 0x8283e9f8
	if !ctx.cr[0].eq {
	pc = 0x8283E9F8; continue 'dispatch;
	}
	// 8283EA14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283EA18: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283EA1C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283EA20: 388ACFF8  addi r4, r10, -0x3008
	ctx.r[4].s64 = ctx.r[10].s64 + -12296;
	// 8283EA24: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8283EA28: 38A000D4  li r5, 0xd4
	ctx.r[5].s64 = 212;
	// 8283EA2C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283EA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EA34: 4BFB1125  bl 0x827efb58
	ctx.lr = 0x8283EA38;
	sub_827EFB58(ctx, base);
	// 8283EA38: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283EA3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283EA40: 419A0008  beq cr6, 0x8283ea48
	if ctx.cr[6].eq {
	pc = 0x8283EA48; continue 'dispatch;
	}
	// 8283EA44: 4BA81E4D  bl 0x822c0890
	ctx.lr = 0x8283EA48;
	sub_822C0890(ctx, base);
	// 8283EA48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283EA4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283EA50: 38ABD1F8  addi r5, r11, -0x2e08
	ctx.r[5].s64 = ctx.r[11].s64 + -11784;
	// 8283EA54: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283EA58: 4BFB1271  bl 0x827efcc8
	ctx.lr = 0x8283EA5C;
	sub_827EFCC8(ctx, base);
	// 8283EA5C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283EA60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283EA64: 419A0008  beq cr6, 0x8283ea6c
	if ctx.cr[6].eq {
	pc = 0x8283EA6C; continue 'dispatch;
	}
	// 8283EA68: 4BA81E29  bl 0x822c0890
	ctx.lr = 0x8283EA6C;
	sub_822C0890(ctx, base);
	// 8283EA6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8283EA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283EA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283EA78: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8283EA7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283EA80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283EA84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283EA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283EA88 size=492
    let mut pc: u32 = 0x8283EA88;
    'dispatch: loop {
        match pc {
            0x8283EA88 => {
    //   block [0x8283EA88..0x8283EC74)
	// 8283EA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283EA8C: 489696D9  bl 0x831a8164
	ctx.lr = 0x8283EA90;
	sub_831A8130(ctx, base);
	// 8283EA90: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8283EA94: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8283EA98: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283EA9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283EAA0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8283EAA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283EAA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283EAAC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283EAB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283EAB4: 4BFFFA85  bl 0x8283e538
	ctx.lr = 0x8283EAB8;
	sub_8283E538(ctx, base);
	// 8283EAB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283EABC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283EAC0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8283EAC4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283EAC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283EACC: 4BA85995  bl 0x822c4460
	ctx.lr = 0x8283EAD0;
	sub_822C4460(ctx, base);
	// 8283EAD0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283EAD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283EAD8: 419A0008  beq cr6, 0x8283eae0
	if ctx.cr[6].eq {
	pc = 0x8283EAE0; continue 'dispatch;
	}
	// 8283EADC: 4BA81DB5  bl 0x822c0890
	ctx.lr = 0x8283EAE0;
	sub_822C0890(ctx, base);
	// 8283EAE0: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283EAE4: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283EAE8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8283EAEC: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 8283EAF0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8283EAF4: 419A0024  beq cr6, 0x8283eb18
	if ctx.cr[6].eq {
	pc = 0x8283EB18; continue 'dispatch;
	}
	// 8283EAF8: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 8283EAFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283EB00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EB04: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283EB08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283EB0C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283EB10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EB14: 4082FFE8  bne 0x8283eafc
	if !ctx.cr[0].eq {
	pc = 0x8283EAFC; continue 'dispatch;
	}
	// 8283EB18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283EB1C: 80DE0068  lwz r6, 0x68(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 8283EB20: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283EB24: 3BABCFF8  addi r29, r11, -0x3008
	ctx.r[29].s64 = ctx.r[11].s64 + -12296;
	// 8283EB28: 38A000E1  li r5, 0xe1
	ctx.r[5].s64 = 225;
	// 8283EB2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283EB30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EB34: 4BFB10F5  bl 0x827efc28
	ctx.lr = 0x8283EB38;
	sub_827EFC28(ctx, base);
	// 8283EB38: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8283EB3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 8283EB40: 41820114  beq 0x8283ec54
	if ctx.cr[0].eq {
	pc = 0x8283EC54; continue 'dispatch;
	}
	// 8283EB44: C01E006C  lfs f0, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283EB48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283EB4C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8283EB50: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8283EB54: C3EB08A4  lfs f31, 0x8a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8283EB58: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8283EB5C: 409800F8  bge cr6, 0x8283ec54
	if !ctx.cr[6].lt {
	pc = 0x8283EC54; continue 'dispatch;
	}
	// 8283EB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EB64: 4BFAECB5  bl 0x827ed818
	ctx.lr = 0x8283EB68;
	sub_827ED818(ctx, base);
	// 8283EB68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283EB6C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283EB70: 4BCD07C1  bl 0x8250f330
	ctx.lr = 0x8283EB74;
	sub_8250F330(ctx, base);
	// 8283EB74: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283EB78: 4BCAACD9  bl 0x824e9850
	ctx.lr = 0x8283EB7C;
	sub_824E9850(ctx, base);
	// 8283EB7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8283EB80: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8283EB84: 485B310D  bl 0x82df1c90
	ctx.lr = 0x8283EB88;
	sub_82DF1C90(ctx, base);
	// 8283EB88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283EB8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283EB90: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8283EB94: 4BFFD04D  bl 0x8283bbe0
	ctx.lr = 0x8283EB98;
	sub_8283BBE0(ctx, base);
	// 8283EB98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EB9C: 4BFAEC85  bl 0x827ed820
	ctx.lr = 0x8283EBA0;
	sub_827ED820(ctx, base);
	// 8283EBA0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8283EBA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283EBA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283EBAC: 4BFFF9FD  bl 0x8283e5a8
	ctx.lr = 0x8283EBB0;
	sub_8283E5A8(ctx, base);
	// 8283EBB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283EBB4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283EBB8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283EBBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283EBC0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8283EBC4: 419A0024  beq cr6, 0x8283ebe8
	if ctx.cr[6].eq {
	pc = 0x8283EBE8; continue 'dispatch;
	}
	// 8283EBC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283EBCC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283EBD0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EBD4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283EBD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283EBDC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283EBE0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EBE4: 4082FFE8  bne 0x8283ebcc
	if !ctx.cr[0].eq {
	pc = 0x8283EBCC; continue 'dispatch;
	}
	// 8283EBE8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283EBEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283EBF0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8283EBF4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8283EBF8: 38A000EB  li r5, 0xeb
	ctx.r[5].s64 = 235;
	// 8283EBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EC00: 4BFB0F59  bl 0x827efb58
	ctx.lr = 0x8283EC04;
	sub_827EFB58(ctx, base);
	// 8283EC04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8283EC08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283EC0C: 419A0008  beq cr6, 0x8283ec14
	if ctx.cr[6].eq {
	pc = 0x8283EC14; continue 'dispatch;
	}
	// 8283EC10: 4BA81C81  bl 0x822c0890
	ctx.lr = 0x8283EC14;
	sub_822C0890(ctx, base);
	// 8283EC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283EC18: 485B4811  bl 0x82df3428
	ctx.lr = 0x8283EC1C;
	sub_82DF3428(ctx, base);
	// 8283EC1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EC20: 4BFAEBF9  bl 0x827ed818
	ctx.lr = 0x8283EC24;
	sub_827ED818(ctx, base);
	// 8283EC24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8283EC28: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8283EC2C: 4BCD0705  bl 0x8250f330
	ctx.lr = 0x8283EC30;
	sub_8250F330(ctx, base);
	// 8283EC30: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283EC34: 4BCAAC1D  bl 0x824e9850
	ctx.lr = 0x8283EC38;
	sub_824E9850(ctx, base);
	// 8283EC38: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8283EC3C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8283EC40: 485B3051  bl 0x82df1c90
	ctx.lr = 0x8283EC44;
	sub_82DF1C90(ctx, base);
	// 8283EC44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283EC48: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283EC4C: 4BFFD085  bl 0x8283bcd0
	ctx.lr = 0x8283EC50;
	sub_8283BCD0(ctx, base);
	// 8283EC50: D03E006C  stfs f1, 0x6c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8283EC54: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8283EC58: 419A000C  beq cr6, 0x8283ec64
	if ctx.cr[6].eq {
	pc = 0x8283EC64; continue 'dispatch;
	}
	// 8283EC5C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8283EC60: 4BA81C31  bl 0x822c0890
	ctx.lr = 0x8283EC64;
	sub_822C0890(ctx, base);
	// 8283EC64: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8283EC68: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8283EC6C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8283EC70: 48969544  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283EC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283EC78 size=184
    let mut pc: u32 = 0x8283EC78;
    'dispatch: loop {
        match pc {
            0x8283EC78 => {
    //   block [0x8283EC78..0x8283ED30)
	// 8283EC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283EC7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283EC80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283EC84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283EC88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283EC8C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8283EC90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283EC94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283EC98: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8283EC9C: 4BFF78FD  bl 0x82836598
	ctx.lr = 0x8283ECA0;
	sub_82836598(ctx, base);
	// 8283ECA0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283ECA4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283ECA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283ECAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283ECB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283ECB4: 419A0024  beq cr6, 0x8283ecd8
	if ctx.cr[6].eq {
	pc = 0x8283ECD8; continue 'dispatch;
	}
	// 8283ECB8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283ECBC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283ECC0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283ECC4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283ECC8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283ECCC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283ECD0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283ECD4: 4082FFE8  bne 0x8283ecbc
	if !ctx.cr[0].eq {
	pc = 0x8283ECBC; continue 'dispatch;
	}
	// 8283ECD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283ECDC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8283ECE0: 4BFAEB41  bl 0x827ed820
	ctx.lr = 0x8283ECE4;
	sub_827ED820(ctx, base);
	// 8283ECE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283ECE8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283ECEC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283ECF0: 388ACFF8  addi r4, r10, -0x3008
	ctx.r[4].s64 = ctx.r[10].s64 + -12296;
	// 8283ECF4: 38A00157  li r5, 0x157
	ctx.r[5].s64 = 343;
	// 8283ECF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283ECFC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283ED00: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8283ED04: 4BFB0E55  bl 0x827efb58
	ctx.lr = 0x8283ED08;
	sub_827EFB58(ctx, base);
	// 8283ED08: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283ED0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283ED10: 419A0008  beq cr6, 0x8283ed18
	if ctx.cr[6].eq {
	pc = 0x8283ED18; continue 'dispatch;
	}
	// 8283ED14: 4BA81B7D  bl 0x822c0890
	ctx.lr = 0x8283ED18;
	sub_822C0890(ctx, base);
	// 8283ED18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283ED1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283ED20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283ED24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283ED28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283ED2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283ED30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283ED30 size=184
    let mut pc: u32 = 0x8283ED30;
    'dispatch: loop {
        match pc {
            0x8283ED30 => {
    //   block [0x8283ED30..0x8283EDE8)
	// 8283ED30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283ED34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283ED38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283ED3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283ED40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283ED44: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8283ED48: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283ED4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283ED50: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8283ED54: 4BFF7845  bl 0x82836598
	ctx.lr = 0x8283ED58;
	sub_82836598(ctx, base);
	// 8283ED58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283ED5C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283ED60: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283ED64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283ED68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283ED6C: 419A0024  beq cr6, 0x8283ed90
	if ctx.cr[6].eq {
	pc = 0x8283ED90; continue 'dispatch;
	}
	// 8283ED70: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283ED74: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283ED78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283ED7C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283ED80: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283ED84: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283ED88: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283ED8C: 4082FFE8  bne 0x8283ed74
	if !ctx.cr[0].eq {
	pc = 0x8283ED74; continue 'dispatch;
	}
	// 8283ED90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283ED94: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8283ED98: 4BFAEA89  bl 0x827ed820
	ctx.lr = 0x8283ED9C;
	sub_827ED820(ctx, base);
	// 8283ED9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283EDA0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283EDA4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283EDA8: 388ACFF8  addi r4, r10, -0x3008
	ctx.r[4].s64 = ctx.r[10].s64 + -12296;
	// 8283EDAC: 38A00177  li r5, 0x177
	ctx.r[5].s64 = 375;
	// 8283EDB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283EDB4: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283EDB8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8283EDBC: 4BFB0D9D  bl 0x827efb58
	ctx.lr = 0x8283EDC0;
	sub_827EFB58(ctx, base);
	// 8283EDC0: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283EDC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283EDC8: 419A0008  beq cr6, 0x8283edd0
	if ctx.cr[6].eq {
	pc = 0x8283EDD0; continue 'dispatch;
	}
	// 8283EDCC: 4BA81AC5  bl 0x822c0890
	ctx.lr = 0x8283EDD0;
	sub_822C0890(ctx, base);
	// 8283EDD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283EDD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283EDD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283EDDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283EDE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283EDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283EDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283EDE8 size=192
    let mut pc: u32 = 0x8283EDE8;
    'dispatch: loop {
        match pc {
            0x8283EDE8 => {
    //   block [0x8283EDE8..0x8283EEA8)
	// 8283EDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283EDEC: 4896937D  bl 0x831a8168
	ctx.lr = 0x8283EDF0;
	sub_831A8130(ctx, base);
	// 8283EDF0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283EDF4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283EDF8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8283EDFC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8283EE00: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283EE04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283EE08: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8283EE0C: 419A0090  beq cr6, 0x8283ee9c
	if ctx.cr[6].eq {
	pc = 0x8283EE9C; continue 'dispatch;
	}
	// 8283EE10: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283EE14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283EE18: 3BABCFF8  addi r29, r11, -0x3008
	ctx.r[29].s64 = ctx.r[11].s64 + -12296;
	// 8283EE1C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8283EE20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283EE24: 4BD9922D  bl 0x825d8050
	ctx.lr = 0x8283EE28;
	sub_825D8050(ctx, base);
	// 8283EE28: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283EE2C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283EE30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283EE34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283EE38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283EE3C: 419A0024  beq cr6, 0x8283ee60
	if ctx.cr[6].eq {
	pc = 0x8283EE60; continue 'dispatch;
	}
	// 8283EE40: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283EE44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283EE48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EE4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283EE50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283EE54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283EE58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283EE5C: 4082FFE8  bne 0x8283ee44
	if !ctx.cr[0].eq {
	pc = 0x8283EE44; continue 'dispatch;
	}
	// 8283EE60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283EE64: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283EE68: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283EE6C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283EE70: 38A001AD  li r5, 0x1ad
	ctx.r[5].s64 = 429;
	// 8283EE74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8283EE78: 4BFB0CE1  bl 0x827efb58
	ctx.lr = 0x8283EE7C;
	sub_827EFB58(ctx, base);
	// 8283EE7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283EE80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283EE84: 419A0008  beq cr6, 0x8283ee8c
	if ctx.cr[6].eq {
	pc = 0x8283EE8C; continue 'dispatch;
	}
	// 8283EE88: 4BA81A09  bl 0x822c0890
	ctx.lr = 0x8283EE8C;
	sub_822C0890(ctx, base);
	// 8283EE8C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8283EE90: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8283EE94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8283EE98: 409AFF88  bne cr6, 0x8283ee20
	if !ctx.cr[6].eq {
	pc = 0x8283EE20; continue 'dispatch;
	}
	// 8283EE9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8283EEA0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8283EEA4: 48969314  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283EEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283EEA8 size=252
    let mut pc: u32 = 0x8283EEA8;
    'dispatch: loop {
        match pc {
            0x8283EEA8 => {
    //   block [0x8283EEA8..0x8283EFA4)
	// 8283EEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283EEAC: 489692C1  bl 0x831a816c
	ctx.lr = 0x8283EEB0;
	sub_831A8130(ctx, base);
	// 8283EEB0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283EEB4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283EEB8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8283EEBC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283EEC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283EEC4: 3BBFFFA8  addi r29, r31, -0x58
	ctx.r[29].s64 = ctx.r[31].s64 + -88;
	// 8283EEC8: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283EECC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283EFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283EFA8 size=220
    let mut pc: u32 = 0x8283EFA8;
    'dispatch: loop {
        match pc {
            0x8283EFA8 => {
    //   block [0x8283EFA8..0x8283F084)
	// 8283EFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283EFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283EFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283EFB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283EFB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F088 size=436
    let mut pc: u32 = 0x8283F088;
    'dispatch: loop {
        match pc {
            0x8283F088 => {
    //   block [0x8283F088..0x8283F23C)
	// 8283F088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F08C: 489690D1  bl 0x831a815c
	ctx.lr = 0x8283F090;
	sub_831A8130(ctx, base);
	// 8283F090: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F094: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8283F098: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283F09C: 81790064  lwz r11, 0x64(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283F0A0: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F0A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283F0A8: 419A0038  beq cr6, 0x8283f0e0
	if ctx.cr[6].eq {
	pc = 0x8283F0E0; continue 'dispatch;
	}
	// 8283F0AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283F0B4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F0B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283F0BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283F0C0: 4E800421  bctrl
	ctx.lr = 0x8283F0C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283F0C4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8283F0C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8283F0CC: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 8283F0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F0D4: C02B6218  lfs f1, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283F0D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8283F0DC: 4E800421  bctrl
	ctx.lr = 0x8283F0E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283F0E0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8283F0E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283F0E8: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 8283F0EC: 4BFFF535  bl 0x8283e620
	ctx.lr = 0x8283F0F0;
	sub_8283E620(ctx, base);
	// 8283F0F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283F0F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283F0F8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8283F0FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F100: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283F104: 4BA8535D  bl 0x822c4460
	ctx.lr = 0x8283F108;
	sub_822C4460(ctx, base);
	// 8283F108: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283F10C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283F110: 419A0008  beq cr6, 0x8283f118
	if ctx.cr[6].eq {
	pc = 0x8283F118; continue 'dispatch;
	}
	// 8283F114: 4BA8177D  bl 0x822c0890
	ctx.lr = 0x8283F118;
	sub_822C0890(ctx, base);
	// 8283F118: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283F11C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283F120: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283F124: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8283F128: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8283F12C: 419A0024  beq cr6, 0x8283f150
	if ctx.cr[6].eq {
	pc = 0x8283F150; continue 'dispatch;
	}
	// 8283F130: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8283F134: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283F138: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F13C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283F140: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283F144: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283F148: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F14C: 4082FFE8  bne 0x8283f134
	if !ctx.cr[0].eq {
	pc = 0x8283F134; continue 'dispatch;
	}
	// 8283F150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283F154: 3B610050  addi r27, r1, 0x50
	ctx.r[27].s64 = ctx.r[1].s64 + 80;
	// 8283F158: 4BFAE6C9  bl 0x827ed820
	ctx.lr = 0x8283F15C;
	sub_827ED820(ctx, base);
	// 8283F15C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283F160: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283F164: 3BABD0A0  addi r29, r11, -0x2f60
	ctx.r[29].s64 = ctx.r[11].s64 + -12128;
	// 8283F168: 38A000DE  li r5, 0xde
	ctx.r[5].s64 = 222;
	// 8283F16C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283F170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283F174: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8283F178: 4BFB0AB1  bl 0x827efc28
	ctx.lr = 0x8283F17C;
	sub_827EFC28(ctx, base);
	// 8283F17C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283F180: 837C0018  lwz r27, 0x18(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8283F184: 419A000C  beq cr6, 0x8283f190
	if ctx.cr[6].eq {
	pc = 0x8283F190; continue 'dispatch;
	}
	// 8283F188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F18C: 4BA81705  bl 0x822c0890
	ctx.lr = 0x8283F190;
	sub_822C0890(ctx, base);
	// 8283F190: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8283F194: 419A00A0  beq cr6, 0x8283f234
	if ctx.cr[6].eq {
	pc = 0x8283F234; continue 'dispatch;
	}
	// 8283F198: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283F19C: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 8283F1A0: 4BFFF4F1  bl 0x8283e690
	ctx.lr = 0x8283F1A4;
	sub_8283E690(ctx, base);
	// 8283F1A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283F1A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283F1AC: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8283F1B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F1B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283F1B8: 4BA852A9  bl 0x822c4460
	ctx.lr = 0x8283F1BC;
	sub_822C4460(ctx, base);
	// 8283F1BC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283F1C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283F1C4: 419A0008  beq cr6, 0x8283f1cc
	if ctx.cr[6].eq {
	pc = 0x8283F1CC; continue 'dispatch;
	}
	// 8283F1C8: 4BA816C9  bl 0x822c0890
	ctx.lr = 0x8283F1CC;
	sub_822C0890(ctx, base);
	// 8283F1CC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283F1D0: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283F1D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283F1D8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8283F1DC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8283F1E0: 419A0024  beq cr6, 0x8283f204
	if ctx.cr[6].eq {
	pc = 0x8283F204; continue 'dispatch;
	}
	// 8283F1E4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8283F1E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283F1EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F1F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283F1F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283F1F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283F1FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F200: 4082FFE8  bne 0x8283f1e8
	if !ctx.cr[0].eq {
	pc = 0x8283F1E8; continue 'dispatch;
	}
	// 8283F204: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283F208: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283F20C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8283F210: 38A000E6  li r5, 0xe6
	ctx.r[5].s64 = 230;
	// 8283F214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283F218: 4BFB0A11  bl 0x827efc28
	ctx.lr = 0x8283F21C;
	sub_827EFC28(ctx, base);
	// 8283F21C: 897C0018  lbz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8283F220: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283F224: 9979008C  stb r11, 0x8c(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(140 as u32), ctx.r[11].u8 ) };
	// 8283F228: 419A000C  beq cr6, 0x8283f234
	if ctx.cr[6].eq {
	pc = 0x8283F234; continue 'dispatch;
	}
	// 8283F22C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F230: 4BA81661  bl 0x822c0890
	ctx.lr = 0x8283F234;
	sub_822C0890(ctx, base);
	// 8283F234: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8283F238: 48968F74  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F240 size=516
    let mut pc: u32 = 0x8283F240;
    'dispatch: loop {
        match pc {
            0x8283F240 => {
    //   block [0x8283F240..0x8283F444)
	// 8283F240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F244: 48968F15  bl 0x831a8158
	ctx.lr = 0x8283F248;
	sub_831A8130(ctx, base);
	// 8283F248: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F24C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283F250: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 8283F254: 3B8B6910  addi r28, r11, 0x6910
	ctx.r[28].s64 = ctx.r[11].s64 + 26896;
	// 8283F258: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283F25C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283F260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283F264: 13E0E0C7  vcmpequd (lvx128) v31, v0, v28
	tmp.u32 = ctx.r[28].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F448 size=220
    let mut pc: u32 = 0x8283F448;
    'dispatch: loop {
        match pc {
            0x8283F448 => {
    //   block [0x8283F448..0x8283F524)
	// 8283F448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F44C: 48968D1D  bl 0x831a8168
	ctx.lr = 0x8283F450;
	sub_831A8130(ctx, base);
	// 8283F450: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283F458: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283F45C: 3BBE0080  addi r29, r30, 0x80
	ctx.r[29].s64 = ctx.r[30].s64 + 128;
	// 8283F460: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283F464: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 8283F468: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283F46C: 4BADDD65  bl 0x8231d1d0
	ctx.lr = 0x8283F470;
	sub_8231D1D0(ctx, base);
	// 8283F470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F474: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8283F478: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283F47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283F480: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8283F484: 419A0024  beq cr6, 0x8283f4a8
	if ctx.cr[6].eq {
	pc = 0x8283F4A8; continue 'dispatch;
	}
	// 8283F488: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283F48C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283F490: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F494: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283F498: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283F49C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283F4A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F4A4: 4082FFE8  bne 0x8283f48c
	if !ctx.cr[0].eq {
	pc = 0x8283F48C; continue 'dispatch;
	}
	// 8283F4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F4AC: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 8283F4B0: 4BFAE381  bl 0x827ed830
	ctx.lr = 0x8283F4B4;
	sub_827ED830(ctx, base);
	// 8283F4B4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283F4B8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283F4BC: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283F4C0: 38A001B9  li r5, 0x1b9
	ctx.r[5].s64 = 441;
	// 8283F4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F4C8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8283F4CC: 4BFB075D  bl 0x827efc28
	ctx.lr = 0x8283F4D0;
	sub_827EFC28(ctx, base);
	// 8283F4D0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283F4D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283F4D8: 419A0008  beq cr6, 0x8283f4e0
	if ctx.cr[6].eq {
	pc = 0x8283F4E0; continue 'dispatch;
	}
	// 8283F4DC: 4BA813B5  bl 0x822c0890
	ctx.lr = 0x8283F4E0;
	sub_822C0890(ctx, base);
	// 8283F4E0: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283F4E4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F4E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283F4EC: 419A0030  beq cr6, 0x8283f51c
	if ctx.cr[6].eq {
	pc = 0x8283F51C; continue 'dispatch;
	}
	// 8283F4F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8283F4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F4F8: 4BAA3B01  bl 0x822e2ff8
	ctx.lr = 0x8283F4FC;
	sub_822E2FF8(ctx, base);
	// 8283F4FC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8283F500: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8283F504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F508: C02B6218  lfs f1, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283F50C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F510: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8283F514: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283F518: 4E800421  bctrl
	ctx.lr = 0x8283F51C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283F51C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8283F520: 48968C98  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F528 size=800
    let mut pc: u32 = 0x8283F528;
    'dispatch: loop {
        match pc {
            0x8283F528 => {
    //   block [0x8283F528..0x8283F848)
	// 8283F528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F52C: 48968C3D  bl 0x831a8168
	ctx.lr = 0x8283F530;
	sub_831A8130(ctx, base);
	// 8283F530: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8283F534: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8283F538: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8283F53C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F540: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283F544: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 8283F548: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283F54C: 3B9E0080  addi r28, r30, 0x80
	ctx.r[28].s64 = ctx.r[30].s64 + 128;
	// 8283F550: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283F554: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 8283F558: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8283F55C: 4BADDC75  bl 0x8231d1d0
	ctx.lr = 0x8283F560;
	sub_8231D1D0(ctx, base);
	// 8283F560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F564: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283F568: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283F56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283F570: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283F574: 419A0024  beq cr6, 0x8283f598
	if ctx.cr[6].eq {
	pc = 0x8283F598; continue 'dispatch;
	}
	// 8283F578: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283F57C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283F580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F584: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283F588: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283F58C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283F590: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F594: 4082FFE8  bne 0x8283f57c
	if !ctx.cr[0].eq {
	pc = 0x8283F57C; continue 'dispatch;
	}
	// 8283F598: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283F59C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8283F5A0: 4BFAE291  bl 0x827ed830
	ctx.lr = 0x8283F5A4;
	sub_827ED830(ctx, base);
	// 8283F5A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283F5A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283F5AC: 388BD0A0  addi r4, r11, -0x2f60
	ctx.r[4].s64 = ctx.r[11].s64 + -12128;
	// 8283F5B0: 38A001C6  li r5, 0x1c6
	ctx.r[5].s64 = 454;
	// 8283F5B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283F5B8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8283F5BC: 4BFB066D  bl 0x827efc28
	ctx.lr = 0x8283F5C0;
	sub_827EFC28(ctx, base);
	// 8283F5C0: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 8283F5C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283F5C8: 419A0008  beq cr6, 0x8283f5d0
	if ctx.cr[6].eq {
	pc = 0x8283F5D0; continue 'dispatch;
	}
	// 8283F5CC: 4BA812C5  bl 0x822c0890
	ctx.lr = 0x8283F5D0;
	sub_822C0890(ctx, base);
	// 8283F5D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 8283F5D4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F5D8: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8283F5DC: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 8283F5E0: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8283F5E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283F5E8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283F5EC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F848 size=184
    let mut pc: u32 = 0x8283F848;
    'dispatch: loop {
        match pc {
            0x8283F848 => {
    //   block [0x8283F848..0x8283F900)
	// 8283F848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283F850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283F854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283F858: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F85C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8283F860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F864: 4BFADFB5  bl 0x827ed818
	ctx.lr = 0x8283F868;
	sub_827ED818(ctx, base);
	// 8283F868: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 8283F86C: 487C974D  bl 0x83008fb8
	ctx.lr = 0x8283F870;
	sub_83008FB8(ctx, base);
	// 8283F870: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283F874: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283F878: 4BD987D9  bl 0x825d8050
	ctx.lr = 0x8283F87C;
	sub_825D8050(ctx, base);
	// 8283F87C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F880: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283F884: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283F888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283F88C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283F890: 419A0024  beq cr6, 0x8283f8b4
	if ctx.cr[6].eq {
	pc = 0x8283F8B4; continue 'dispatch;
	}
	// 8283F894: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283F898: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283F89C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F8A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283F8A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283F8A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283F8AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F8B0: 4082FFE8  bne 0x8283f898
	if !ctx.cr[0].eq {
	pc = 0x8283F898; continue 'dispatch;
	}
	// 8283F8B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283F8B8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283F8BC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283F8C0: 388AD0A0  addi r4, r10, -0x2f60
	ctx.r[4].s64 = ctx.r[10].s64 + -12128;
	// 8283F8C4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8283F8C8: 38A002FB  li r5, 0x2fb
	ctx.r[5].s64 = 763;
	// 8283F8CC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283F8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283F8D4: 4BFB0285  bl 0x827efb58
	ctx.lr = 0x8283F8D8;
	sub_827EFB58(ctx, base);
	// 8283F8D8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283F8DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283F8E0: 419A0008  beq cr6, 0x8283f8e8
	if ctx.cr[6].eq {
	pc = 0x8283F8E8; continue 'dispatch;
	}
	// 8283F8E4: 4BA80FAD  bl 0x822c0890
	ctx.lr = 0x8283F8E8;
	sub_822C0890(ctx, base);
	// 8283F8E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283F8EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283F8F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283F8F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283F8F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283F8FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F900 size=140
    let mut pc: u32 = 0x8283F900;
    'dispatch: loop {
        match pc {
            0x8283F900 => {
    //   block [0x8283F900..0x8283F98C)
	// 8283F900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F904: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283F908: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283F90C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283F910: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F914: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 8283F918: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283F91C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283F920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283F924: 388B7C44  addi r4, r11, 0x7c44
	ctx.r[4].s64 = ctx.r[11].s64 + 31812;
	// 8283F928: 485B40E1  bl 0x82df3a08
	ctx.lr = 0x8283F92C;
	sub_82DF3A08(ctx, base);
	// 8283F92C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283F930: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283F934: 389F0108  addi r4, r31, 0x108
	ctx.r[4].s64 = ctx.r[31].s64 + 264;
	// 8283F938: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283F93C: C06B964C  lfs f3, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8283F940: C04A89AC  lfs f2, -0x7654(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8283F944: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 8283F948: 4BD63869  bl 0x825a31b0
	ctx.lr = 0x8283F94C;
	sub_825A31B0(ctx, base);
	// 8283F94C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8283F950: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8283F954: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283F958: 4BD61E19  bl 0x825a1770
	ctx.lr = 0x8283F95C;
	sub_825A1770(ctx, base);
	// 8283F95C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 8283F960: 485B3AC9  bl 0x82df3428
	ctx.lr = 0x8283F964;
	sub_82DF3428(ctx, base);
	// 8283F964: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8283F968: 4BA89351  bl 0x822c8cb8
	ctx.lr = 0x8283F96C;
	sub_822C8CB8(ctx, base);
	// 8283F96C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283F970: 485B3AB9  bl 0x82df3428
	ctx.lr = 0x8283F974;
	sub_82DF3428(ctx, base);
	// 8283F974: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8283F978: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283F97C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283F980: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283F984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283F988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283F990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283F990 size=208
    let mut pc: u32 = 0x8283F990;
    'dispatch: loop {
        match pc {
            0x8283F990 => {
    //   block [0x8283F990..0x8283FA60)
	// 8283F990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283F994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283F998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283F99C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283F9A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283F9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283F9A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8283F9AC: 817F02A8  lwz r11, 0x2a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 8283F9B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283F9B4: 419A0088  beq cr6, 0x8283fa3c
	if ctx.cr[6].eq {
	pc = 0x8283FA3C; continue 'dispatch;
	}
	// 8283F9B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283F9BC: 4BFFEDBD  bl 0x8283e778
	ctx.lr = 0x8283F9C0;
	sub_8283E778(ctx, base);
	// 8283F9C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283F9C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283F9C8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283F9CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283F9D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283F9D4: 419A0024  beq cr6, 0x8283f9f8
	if ctx.cr[6].eq {
	pc = 0x8283F9F8; continue 'dispatch;
	}
	// 8283F9D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283F9DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283F9E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F9E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283F9E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283F9EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283F9F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283F9F4: 4082FFE8  bne 0x8283f9dc
	if !ctx.cr[0].eq {
	pc = 0x8283F9DC; continue 'dispatch;
	}
	// 8283F9F8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283F9FC: 80DF02A8  lwz r6, 0x2a8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 8283FA00: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283FA04: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283FA08: 388AD108  addi r4, r10, -0x2ef8
	ctx.r[4].s64 = ctx.r[10].s64 + -12024;
	// 8283FA0C: 38A0014B  li r5, 0x14b
	ctx.r[5].s64 = 331;
	// 8283FA10: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8283FA14: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283FA18: 48619029  bl 0x82e58a40
	ctx.lr = 0x8283FA1C;
	sub_82E58A40(ctx, base);
	// 8283FA1C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283FA20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FA24: 419A0008  beq cr6, 0x8283fa2c
	if ctx.cr[6].eq {
	pc = 0x8283FA2C; continue 'dispatch;
	}
	// 8283FA28: 4BA80E69  bl 0x822c0890
	ctx.lr = 0x8283FA2C;
	sub_822C0890(ctx, base);
	// 8283FA2C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283FA30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FA34: 419A0008  beq cr6, 0x8283fa3c
	if ctx.cr[6].eq {
	pc = 0x8283FA3C; continue 'dispatch;
	}
	// 8283FA38: 4BA80E59  bl 0x822c0890
	ctx.lr = 0x8283FA3C;
	sub_822C0890(ctx, base);
	// 8283FA3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8283FA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FA44: 4BFDA01D  bl 0x82819a60
	ctx.lr = 0x8283FA48;
	sub_82819A60(ctx, base);
	// 8283FA48: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8283FA4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283FA50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283FA54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283FA58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283FA5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283FA60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283FA60 size=148
    let mut pc: u32 = 0x8283FA60;
    'dispatch: loop {
        match pc {
            0x8283FA60 => {
    //   block [0x8283FA60..0x8283FAF4)
	// 8283FA60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283FA64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283FA68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283FA6C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8283FA70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283FA74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283FA78: 48120AE9  bl 0x82960560
	ctx.lr = 0x8283FA7C;
	sub_82960560(ctx, base);
	// 8283FA7C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8283FA80: 4182005C  beq 0x8283fadc
	if ctx.cr[0].eq {
	pc = 0x8283FADC; continue 'dispatch;
	}
	// 8283FA84: C01F0298  lfs f0, 0x298(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283FA88: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283FA8C: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8283FA90: 4BFAFDC1  bl 0x827ef850
	ctx.lr = 0x8283FA94;
	sub_827EF850(ctx, base);
	// 8283FA94: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8283FA98: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283FA9C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8283FAA0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 8283FAA4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 8283FAA8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283FAAC: 38A9A07C  addi r5, r9, -0x5f84
	ctx.r[5].s64 = ctx.r[9].s64 + -24452;
	// 8283FAB0: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283FAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283FAF8 size=560
    let mut pc: u32 = 0x8283FAF8;
    'dispatch: loop {
        match pc {
            0x8283FAF8 => {
    //   block [0x8283FAF8..0x8283FD28)
	// 8283FAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283FAFC: 48968665  bl 0x831a8160
	ctx.lr = 0x8283FB00;
	sub_831A8130(ctx, base);
	// 8283FB00: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8283FB04: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283FB08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283FB0C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8283FB10: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283FB14: 817E02A4  lwz r11, 0x2a4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(676 as u32) ) } as u64;
	// 8283FB18: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8283FB1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283FB20: 419A01FC  beq cr6, 0x8283fd1c
	if ctx.cr[6].eq {
	pc = 0x8283FD1C; continue 'dispatch;
	}
	// 8283FB24: 48120A3D  bl 0x82960560
	ctx.lr = 0x8283FB28;
	sub_82960560(ctx, base);
	// 8283FB28: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8283FB2C: 418201F0  beq 0x8283fd1c
	if ctx.cr[0].eq {
	pc = 0x8283FD1C; continue 'dispatch;
	}
	// 8283FB30: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8283FB34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283FB38: 808B17D0  lwz r4, 0x17d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6096 as u32) ) } as u64;
	// 8283FB3C: 485B3ECD  bl 0x82df3a08
	ctx.lr = 0x8283FB40;
	sub_82DF3A08(ctx, base);
	// 8283FB40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8283FB44: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 8283FB48: 4BFAD2B9  bl 0x827ece00
	ctx.lr = 0x8283FB4C;
	sub_827ECE00(ctx, base);
	// 8283FB4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283FB50: 485B37B9  bl 0x82df3308
	ctx.lr = 0x8283FB54;
	sub_82DF3308(ctx, base);
	// 8283FB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283FB58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283FB5C: 485B38CD  bl 0x82df3428
	ctx.lr = 0x8283FB60;
	sub_82DF3428(ctx, base);
	// 8283FB60: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283FB64: 4182000C  beq 0x8283fb70
	if ctx.cr[0].eq {
	pc = 0x8283FB70; continue 'dispatch;
	}
	// 8283FB68: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8283FB6C: 4BFAF075  bl 0x827eebe0
	ctx.lr = 0x8283FB70;
	sub_827EEBE0(ctx, base);
	// 8283FB70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283FB74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283FB78: 3B6BD108  addi r27, r11, -0x2ef8
	ctx.r[27].s64 = ctx.r[11].s64 + -12024;
	// 8283FB7C: 38A00356  li r5, 0x356
	ctx.r[5].s64 = 854;
	// 8283FB80: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8283FB84: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8283FB88: 485B2861  bl 0x82df23e8
	ctx.lr = 0x8283FB8C;
	sub_82DF23E8(ctx, base);
	// 8283FB8C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8283FB90: 41820038  beq 0x8283fbc8
	if ctx.cr[0].eq {
	pc = 0x8283FBC8; continue 'dispatch;
	}
	// 8283FB94: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 8283FB98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283FB9C: 388B0380  addi r4, r11, 0x380
	ctx.r[4].s64 = ctx.r[11].s64 + 896;
	// 8283FBA0: 485B3E69  bl 0x82df3a08
	ctx.lr = 0x8283FBA4;
	sub_82DF3A08(ctx, base);
	// 8283FBA4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8283FBA8: 38BE02A0  addi r5, r30, 0x2a0
	ctx.r[5].s64 = ctx.r[30].s64 + 672;
	// 8283FBAC: 80DD0018  lwz r6, 0x18(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 8283FBB0: 389E0280  addi r4, r30, 0x280
	ctx.r[4].s64 = ctx.r[30].s64 + 640;
	// 8283FBB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FBB8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8283FBBC: 4BFFD52D  bl 0x8283d0e8
	ctx.lr = 0x8283FBC0;
	sub_8283D0E8(ctx, base);
	// 8283FBC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283FBC4: 48000008  b 0x8283fbcc
	pc = 0x8283FBCC; continue 'dispatch;
	// 8283FBC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8283FBCC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8283FBD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283FBD4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8283FBD8: 4BFFB5A1  bl 0x8283b178
	ctx.lr = 0x8283FBDC;
	sub_8283B178(ctx, base);
	// 8283FBDC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8283FBE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283FBE4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8283FBE8: 4BA80419  bl 0x822c0000
	ctx.lr = 0x8283FBEC;
	sub_822C0000(ctx, base);
	// 8283FBEC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283FBF0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8283FBF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283FBF8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 8283FBFC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8283FC00: 419A0024  beq cr6, 0x8283fc24
	if ctx.cr[6].eq {
	pc = 0x8283FC24; continue 'dispatch;
	}
	// 8283FC04: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8283FC08: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283FC0C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FC10: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283FC14: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283FC18: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283FC1C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FC20: 4082FFE8  bne 0x8283fc08
	if !ctx.cr[0].eq {
	pc = 0x8283FC08; continue 'dispatch;
	}
	// 8283FC24: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8283FC28: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8283FC2C: 4BFAFA75  bl 0x827ef6a0
	ctx.lr = 0x8283FC30;
	sub_827EF6A0(ctx, base);
	// 8283FC30: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283FC34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FC38: 419A0008  beq cr6, 0x8283fc40
	if ctx.cr[6].eq {
	pc = 0x8283FC40; continue 'dispatch;
	}
	// 8283FC3C: 4BA80C55  bl 0x822c0890
	ctx.lr = 0x8283FC40;
	sub_822C0890(ctx, base);
	// 8283FC40: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283FC44: 419A000C  beq cr6, 0x8283fc50
	if ctx.cr[6].eq {
	pc = 0x8283FC50; continue 'dispatch;
	}
	// 8283FC48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FC4C: 4BA80C45  bl 0x822c0890
	ctx.lr = 0x8283FC50;
	sub_822C0890(ctx, base);
	// 8283FC50: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283FC54: 4182000C  beq 0x8283fc60
	if ctx.cr[0].eq {
	pc = 0x8283FC60; continue 'dispatch;
	}
	// 8283FC58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8283FC5C: 485B37CD  bl 0x82df3428
	ctx.lr = 0x8283FC60;
	sub_82DF3428(ctx, base);
	// 8283FC60: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 8283FC64: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283FC68: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8283FC6C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 8283FC70: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8283FC74: C00B964C  lfs f0, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283FC78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283FC7C: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8283FC80: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8283FC84: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8283FC88: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8283FC8C: 4BFFEBE5  bl 0x8283e870
	ctx.lr = 0x8283FC90;
	sub_8283E870(ctx, base);
	// 8283FC90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283FC94: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8283FC98: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283FC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283FCA0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8283FCA4: 419A0024  beq cr6, 0x8283fcc8
	if ctx.cr[6].eq {
	pc = 0x8283FCC8; continue 'dispatch;
	}
	// 8283FCA8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283FCAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283FCB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FCB4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283FCB8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283FCBC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283FCC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FCC4: 4082FFE8  bne 0x8283fcac
	if !ctx.cr[0].eq {
	pc = 0x8283FCAC; continue 'dispatch;
	}
	// 8283FCC8: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 8283FCCC: 3BA10068  addi r29, r1, 0x68
	ctx.r[29].s64 = ctx.r[1].s64 + 104;
	// 8283FCD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FCD4: 487C92E5  bl 0x83008fb8
	ctx.lr = 0x8283FCD8;
	sub_83008FB8(ctx, base);
	// 8283FCD8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283FCDC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8283FCE0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8283FCE4: 38A00357  li r5, 0x357
	ctx.r[5].s64 = 855;
	// 8283FCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FCEC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8283FCF0: 48618D51  bl 0x82e58a40
	ctx.lr = 0x8283FCF4;
	sub_82E58A40(ctx, base);
	// 8283FCF4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8283FCF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FCFC: 419A0008  beq cr6, 0x8283fd04
	if ctx.cr[6].eq {
	pc = 0x8283FD04; continue 'dispatch;
	}
	// 8283FD00: 4BA80B91  bl 0x822c0890
	ctx.lr = 0x8283FD04;
	sub_822C0890(ctx, base);
	// 8283FD04: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 8283FD08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FD0C: 419A0008  beq cr6, 0x8283fd14
	if ctx.cr[6].eq {
	pc = 0x8283FD14; continue 'dispatch;
	}
	// 8283FD10: 4BA80B81  bl 0x822c0890
	ctx.lr = 0x8283FD14;
	sub_822C0890(ctx, base);
	// 8283FD14: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8283FD18: 917E02A4  stw r11, 0x2a4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 8283FD1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8283FD20: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8283FD24: 4896848C  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283FD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8283FD28 size=252
    let mut pc: u32 = 0x8283FD28;
    'dispatch: loop {
        match pc {
            0x8283FD28 => {
    //   block [0x8283FD28..0x8283FE24)
	// 8283FD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283FD2C: 4896843D  bl 0x831a8168
	ctx.lr = 0x8283FD30;
	sub_831A8130(ctx, base);
	// 8283FD30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283FD34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283FD38: 48120829  bl 0x82960560
	ctx.lr = 0x8283FD3C;
	sub_82960560(ctx, base);
	// 8283FD3C: 4BFAEEA5  bl 0x827eebe0
	ctx.lr = 0x8283FD40;
	sub_827EEBE0(ctx, base);
	// 8283FD40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8283FD44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283FD48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283FD4C: 4BFFEBAD  bl 0x8283e8f8
	ctx.lr = 0x8283FD50;
	sub_8283E8F8(ctx, base);
	// 8283FD50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283FD54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8283FD58: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 8283FD5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283FD60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283FD64: 4BA846FD  bl 0x822c4460
	ctx.lr = 0x8283FD68;
	sub_822C4460(ctx, base);
	// 8283FD68: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283FD6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FD70: 419A0008  beq cr6, 0x8283fd78
	if ctx.cr[6].eq {
	pc = 0x8283FD78; continue 'dispatch;
	}
	// 8283FD74: 4BA80B1D  bl 0x822c0890
	ctx.lr = 0x8283FD78;
	sub_822C0890(ctx, base);
	// 8283FD78: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283FD7C: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8283FD80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283FD84: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 8283FD88: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 8283FD8C: 419A0024  beq cr6, 0x8283fdb0
	if ctx.cr[6].eq {
	pc = 0x8283FDB0; continue 'dispatch;
	}
	// 8283FD90: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 8283FD94: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283FD98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FD9C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283FDA0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283FDA4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283FDA8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FDAC: 4082FFE8  bne 0x8283fd94
	if !ctx.cr[0].eq {
	pc = 0x8283FD94; continue 'dispatch;
	}
	// 8283FDB0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283FDB4: 80DF02A8  lwz r6, 0x2a8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(680 as u32) ) } as u64;
	// 8283FDB8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8283FDBC: 388BD108  addi r4, r11, -0x2ef8
	ctx.r[4].s64 = ctx.r[11].s64 + -12024;
	// 8283FDC0: 38A00383  li r5, 0x383
	ctx.r[5].s64 = 899;
	// 8283FDC4: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8283FDC8: 48617221  bl 0x82e56fe8
	ctx.lr = 0x8283FDCC;
	sub_82E56FE8(ctx, base);
	// 8283FDCC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283FDD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8283FDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283FDD8: 419A000C  beq cr6, 0x8283fde4
	if ctx.cr[6].eq {
	pc = 0x8283FDE4; continue 'dispatch;
	}
	// 8283FDDC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8283FDE0: 4BA80AB1  bl 0x822c0890
	ctx.lr = 0x8283FDE4;
	sub_822C0890(ctx, base);
	// 8283FDE4: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8283FDE8: 41820024  beq 0x8283fe0c
	if ctx.cr[0].eq {
	pc = 0x8283FE0C; continue 'dispatch;
	}
	// 8283FDEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283FDF0: 809C0018  lwz r4, 0x18(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 8283FDF4: 4800C525  bl 0x8284c318
	ctx.lr = 0x8283FDF8;
	sub_8284C318(ctx, base);
	// 8283FDF8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8283FDFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FE00: 4BFFFCF9  bl 0x8283faf8
	ctx.lr = 0x8283FE04;
	sub_8283FAF8(ctx, base);
	// 8283FE04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8283FE08: 486197D1  bl 0x82e595d8
	ctx.lr = 0x8283FE0C;
	sub_82E595D8(ctx, base);
	// 8283FE0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8283FE10: 419A000C  beq cr6, 0x8283fe1c
	if ctx.cr[6].eq {
	pc = 0x8283FE1C; continue 'dispatch;
	}
	// 8283FE14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8283FE18: 4BA80A79  bl 0x822c0890
	ctx.lr = 0x8283FE1C;
	sub_822C0890(ctx, base);
	// 8283FE1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8283FE20: 48968398  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283FE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283FE28 size=416
    let mut pc: u32 = 0x8283FE28;
    'dispatch: loop {
        match pc {
            0x8283FE28 => {
    //   block [0x8283FE28..0x8283FFC8)
	// 8283FE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283FE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8283FE30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8283FE34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8283FE38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283FE3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8283FE40: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 8283FE44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FE48: 419A004C  beq cr6, 0x8283fe94
	if ctx.cr[6].eq {
	pc = 0x8283FE94; continue 'dispatch;
	}
	// 8283FE4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283FE50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8283FE54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283FE58: 4E800421  bctrl
	ctx.lr = 0x8283FE5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283FE5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283FE60: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8283FE64: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8283FE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FE6C: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283FE70: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283FE74: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283FE78: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283FE7C: D1610070  stfs f11, 0x70(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8283FE80: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8283FE84: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8283FE88: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8283FE8C: C02A08A8  lfs f1, 0x8a8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2216 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283FE90: 4BFD91A1  bl 0x82819030
	ctx.lr = 0x8283FE94;
	sub_82819030(ctx, base);
	// 8283FE94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8283FE98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8283FE9C: 38ABD210  addi r5, r11, -0x2df0
	ctx.r[5].s64 = ctx.r[11].s64 + -11760;
	// 8283FEA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8283FEA4: 4BFAD30D  bl 0x827ed1b0
	ctx.lr = 0x8283FEA8;
	sub_827ED1B0(ctx, base);
	// 8283FEA8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8283FEAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FEB0: 419A0008  beq cr6, 0x8283feb8
	if ctx.cr[6].eq {
	pc = 0x8283FEB8; continue 'dispatch;
	}
	// 8283FEB4: 4BA809DD  bl 0x822c0890
	ctx.lr = 0x8283FEB8;
	sub_822C0890(ctx, base);
	// 8283FEB8: 807F025C  lwz r3, 0x25c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(604 as u32) ) } as u64;
	// 8283FEBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FEC0: 419A0050  beq cr6, 0x8283ff10
	if ctx.cr[6].eq {
	pc = 0x8283FF10; continue 'dispatch;
	}
	// 8283FEC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283FEC8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8283FECC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8283FED0: 4E800421  bctrl
	ctx.lr = 0x8283FED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8283FED4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8283FED8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 8283FEDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8283FEE0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8283FEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FEE8: C00B003C  lfs f0, 0x3c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8283FEEC: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8283FEF0: C18B0034  lfs f12, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8283FEF4: C16B0030  lfs f11, 0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8283FEF8: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8283FEFC: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8283FF00: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8283FF04: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8283FF08: C02A6218  lfs f1, 0x6218(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283FF0C: 4BFD8E5D  bl 0x82818d68
	ctx.lr = 0x8283FF10;
	sub_82818D68(ctx, base);
	// 8283FF10: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8283FF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FF18: 4BCCFB39  bl 0x8250fa50
	ctx.lr = 0x8283FF1C;
	sub_8250FA50(ctx, base);
	// 8283FF1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8283FF20: 4BD98131  bl 0x825d8050
	ctx.lr = 0x8283FF24;
	sub_825D8050(ctx, base);
	// 8283FF24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8283FF28: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8283FF2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8283FF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8283FF34: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8283FF38: 419A0024  beq cr6, 0x8283ff5c
	if ctx.cr[6].eq {
	pc = 0x8283FF5C; continue 'dispatch;
	}
	// 8283FF3C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8283FF40: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8283FF44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FF48: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8283FF4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8283FF50: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8283FF54: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8283FF58: 4082FFE8  bne 0x8283ff40
	if !ctx.cr[0].eq {
	pc = 0x8283FF40; continue 'dispatch;
	}
	// 8283FF5C: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 8283FF60: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 8283FF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FF68: 487C9051  bl 0x83008fb8
	ctx.lr = 0x8283FF6C;
	sub_83008FB8(ctx, base);
	// 8283FF6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8283FF70: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8283FF74: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 8283FF78: 388AD108  addi r4, r10, -0x2ef8
	ctx.r[4].s64 = ctx.r[10].s64 + -12024;
	// 8283FF7C: 38A003DE  li r5, 0x3de
	ctx.r[5].s64 = 990;
	// 8283FF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FF84: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8283FF88: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 8283FF8C: 48618AB5  bl 0x82e58a40
	ctx.lr = 0x8283FF90;
	sub_82E58A40(ctx, base);
	// 8283FF90: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8283FF94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FF98: 419A0008  beq cr6, 0x8283ffa0
	if ctx.cr[6].eq {
	pc = 0x8283FFA0; continue 'dispatch;
	}
	// 8283FF9C: 4BA808F5  bl 0x822c0890
	ctx.lr = 0x8283FFA0;
	sub_822C0890(ctx, base);
	// 8283FFA0: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8283FFA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8283FFA8: 419A0008  beq cr6, 0x8283ffb0
	if ctx.cr[6].eq {
	pc = 0x8283FFB0; continue 'dispatch;
	}
	// 8283FFAC: 4BA808E5  bl 0x822c0890
	ctx.lr = 0x8283FFB0;
	sub_822C0890(ctx, base);
	// 8283FFB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8283FFB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8283FFB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8283FFBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8283FFC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8283FFC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8283FFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8283FFC8 size=92
    let mut pc: u32 = 0x8283FFC8;
    'dispatch: loop {
        match pc {
            0x8283FFC8 => {
    //   block [0x8283FFC8..0x82840024)
	// 8283FFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8283FFCC: 489681A1  bl 0x831a816c
	ctx.lr = 0x8283FFD0;
	sub_831A8130(ctx, base);
	// 8283FFD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8283FFD4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8283FFD8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8283FFDC: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8283FFE0: 419A0038  beq cr6, 0x82840018
	if ctx.cr[6].eq {
	pc = 0x82840018; continue 'dispatch;
	}
	// 8283FFE4: 7FDF1850  subf r30, r31, r3
	ctx.r[30].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	// 8283FFE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8283FFEC: 419A001C  beq cr6, 0x82840008
	if ctx.cr[6].eq {
	pc = 0x82840008; continue 'dispatch;
	}
	// 8283FFF0: 7C9EFA14  add r4, r30, r31
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 8283FFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8283FFF8: 485B3C09  bl 0x82df3c00
	ctx.lr = 0x8283FFFC;
	sub_82DF3C00(ctx, base);
	// 8283FFFC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82840000: 7C1E5C2E  lfsx f0, r30, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82840004: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82840008: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 8284000C: 7D7EFA14  add r11, r30, r31
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82840010: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82840014: 409AFFD4  bne cr6, 0x8283ffe8
	if !ctx.cr[6].eq {
	pc = 0x8283FFE8; continue 'dispatch;
	}
	// 82840018: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284001C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82840020: 4896819C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840028 size=72
    let mut pc: u32 = 0x82840028;
    'dispatch: loop {
        match pc {
            0x82840028 => {
    //   block [0x82840028..0x82840070)
	// 82840028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284002C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82840030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82840034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82840038: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284003C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82840040: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82840044: 38BF006C  addi r5, r31, 0x6c
	ctx.r[5].s64 = ctx.r[31].s64 + 108;
	// 82840048: 4BFFEDA1  bl 0x8283ede8
	ctx.lr = 0x8284004C;
	sub_8283EDE8(ctx, base);
	// 8284004C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82840050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82840054: 4BA7FFAD  bl 0x822c0000
	ctx.lr = 0x82840058;
	sub_822C0000(ctx, base);
	// 82840058: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284005C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82840060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82840064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82840068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8284006C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840070 size=128
    let mut pc: u32 = 0x82840070;
    'dispatch: loop {
        match pc {
            0x82840070 => {
    //   block [0x82840070..0x828400F0)
	// 82840070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82840074: 489680F9  bl 0x831a816c
	ctx.lr = 0x82840078;
	sub_831A8130(ctx, base);
	// 82840078: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284007C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82840080: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82840084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82840088: 3BEBB540  addi r31, r11, -0x4ac0
	ctx.r[31].s64 = ctx.r[11].s64 + -19136;
	// 8284008C: 816AB548  lwz r11, -0x4ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19128 as u32) ) } as u64;
	// 82840090: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82840094: 40820024  bne 0x828400b8
	if !ctx.cr[0].eq {
	pc = 0x828400B8; continue 'dispatch;
	}
	// 82840098: 3D208290  lis r9, -0x7d70
	ctx.r[9].s64 = -2104492032;
	// 8284009C: 3D008284  lis r8, -0x7d7c
	ctx.r[8].s64 = -2105278464;
	// 828400A0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828400A4: 3929DD90  addi r9, r9, -0x2270
	ctx.r[9].s64 = ctx.r[9].s64 + -8816;
	// 828400A8: 3908CFD8  addi r8, r8, -0x3028
	ctx.r[8].s64 = ctx.r[8].s64 + -12328;
	// 828400AC: 916AB548  stw r11, -0x4ab8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19128 as u32), ctx.r[11].u32 ) };
	// 828400B0: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828400B4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828400B8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 828400BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828400C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828400C4: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 828400C8: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 828400CC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828400D0: 4BE144F1  bl 0x826545c0
	ctx.lr = 0x828400D4;
	sub_826545C0(ctx, base);
	// 828400D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828400D8: 4182000C  beq 0x828400e4
	if ctx.cr[0].eq {
	pc = 0x828400E4; continue 'dispatch;
	}
	// 828400DC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828400E0: 48000008  b 0x828400e8
	pc = 0x828400E8; continue 'dispatch;
	// 828400E4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828400E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828400EC: 489680D0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828400F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828400F0 size=128
    let mut pc: u32 = 0x828400F0;
    'dispatch: loop {
        match pc {
            0x828400F0 => {
    //   block [0x828400F0..0x82840170)
	// 828400F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828400F4: 48968079  bl 0x831a816c
	ctx.lr = 0x828400F8;
	sub_831A8130(ctx, base);
	// 828400F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828400FC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82840100: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82840104: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82840108: 3BEBB54C  addi r31, r11, -0x4ab4
	ctx.r[31].s64 = ctx.r[11].s64 + -19124;
	// 8284010C: 816AB554  lwz r11, -0x4aac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-19116 as u32) ) } as u64;
	// 82840110: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82840114: 40820024  bne 0x82840138
	if !ctx.cr[0].eq {
	pc = 0x82840138; continue 'dispatch;
	}
	// 82840118: 3D208271  lis r9, -0x7d8f
	ctx.r[9].s64 = -2106523648;
	// 8284011C: 3D008284  lis r8, -0x7d7c
	ctx.r[8].s64 = -2105278464;
	// 82840120: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82840124: 39298E48  addi r9, r9, -0x71b8
	ctx.r[9].s64 = ctx.r[9].s64 + -29112;
	// 82840128: 3908D020  addi r8, r8, -0x2fe0
	ctx.r[8].s64 = ctx.r[8].s64 + -12256;
	// 8284012C: 916AB554  stw r11, -0x4aac(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19116 as u32), ctx.r[11].u32 ) };
	// 82840130: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82840134: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82840138: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8284013C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82840140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82840144: 38DE0008  addi r6, r30, 8
	ctx.r[6].s64 = ctx.r[30].s64 + 8;
	// 82840148: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 8284014C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82840150: 4BE14471  bl 0x826545c0
	ctx.lr = 0x82840154;
	sub_826545C0(ctx, base);
	// 82840154: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82840158: 4182000C  beq 0x82840164
	if ctx.cr[0].eq {
	pc = 0x82840164; continue 'dispatch;
	}
	// 8284015C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82840160: 48000008  b 0x82840168
	pc = 0x82840168; continue 'dispatch;
	// 82840164: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82840168: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8284016C: 48968050  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840170 size=164
    let mut pc: u32 = 0x82840170;
    'dispatch: loop {
        match pc {
            0x82840170 => {
    //   block [0x82840170..0x82840214)
	// 82840170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82840174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82840178: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8284017C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82840180: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82840184: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82840188: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284018C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82840190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82840194: 409A000C  bne cr6, 0x828401a0
	if !ctx.cr[6].eq {
	pc = 0x828401A0; continue 'dispatch;
	}
	// 82840198: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8284019C: 48000010  b 0x828401ac
	pc = 0x828401AC; continue 'dispatch;
	// 828401A0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828401A4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828401A8: 7D641E70  srawi r4, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 828401AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828401B0: 4BA85E91  bl 0x822c6040
	ctx.lr = 0x828401B4;
	sub_822C6040(ctx, base);
	// 828401B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828401B8: 41820040  beq 0x828401f8
	if ctx.cr[0].eq {
	pc = 0x828401F8; continue 'dispatch;
	}
	// 828401BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828401C0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828401C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828401C8: 48000024  b 0x828401ec
	pc = 0x828401EC; continue 'dispatch;
	// 828401CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828401D0: 419A0014  beq cr6, 0x828401e4
	if ctx.cr[6].eq {
	pc = 0x828401E4; continue 'dispatch;
	}
	// 828401D4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828401D8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828401DC: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828401E0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 828401E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 828401E8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 828401EC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828401F0: 409AFFDC  bne cr6, 0x828401cc
	if !ctx.cr[6].eq {
	pc = 0x828401CC; continue 'dispatch;
	}
	// 828401F4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 828401F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828401FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82840200: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82840204: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82840208: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284020C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82840210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840218 size=128
    let mut pc: u32 = 0x82840218;
    'dispatch: loop {
        match pc {
            0x82840218 => {
    //   block [0x82840218..0x82840298)
	// 82840218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284021C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82840220: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82840224: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82840228: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284022C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82840230: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82840234: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82840238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284023C: 409A000C  bne cr6, 0x82840248
	if !ctx.cr[6].eq {
	pc = 0x82840248; continue 'dispatch;
	}
	// 82840240: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82840244: 48000010  b 0x82840254
	pc = 0x82840254; continue 'dispatch;
	// 82840248: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8284024C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82840250: 7D641E70  srawi r4, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82840254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82840258: 4BA85DE9  bl 0x822c6040
	ctx.lr = 0x8284025C;
	sub_822C6040(ctx, base);
	// 8284025C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82840260: 4182001C  beq 0x8284027c
	if ctx.cr[0].eq {
	pc = 0x8284027C; continue 'dispatch;
	}
	// 82840264: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82840268: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284026C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82840270: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82840274: 4BFFFD55  bl 0x8283ffc8
	ctx.lr = 0x82840278;
	sub_8283FFC8(ctx, base);
	// 82840278: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 8284027C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82840280: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82840284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82840288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8284028C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82840290: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82840294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840298 size=224
    let mut pc: u32 = 0x82840298;
    'dispatch: loop {
        match pc {
            0x82840298 => {
    //   block [0x82840298..0x82840378)
	// 82840298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284029C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828402A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828402A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828402A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828402AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828402B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828402B4: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828402B8: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828402BC: 396BD28C  addi r11, r11, -0x2d74
	ctx.r[11].s64 = ctx.r[11].s64 + -11636;
	// 828402C0: 394AD278  addi r10, r10, -0x2d88
	ctx.r[10].s64 = ctx.r[10].s64 + -11656;
	// 828402C4: 3929D22C  addi r9, r9, -0x2dd4
	ctx.r[9].s64 = ctx.r[9].s64 + -11732;
	// 828402C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828402CC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 828402D0: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 828402D4: 807F0324  lwz r3, 0x324(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(804 as u32) ) } as u64;
	// 828402D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828402DC: 419A0008  beq cr6, 0x828402e4
	if ctx.cr[6].eq {
	pc = 0x828402E4; continue 'dispatch;
	}
	// 828402E0: 4BA805B1  bl 0x822c0890
	ctx.lr = 0x828402E4;
	sub_822C0890(ctx, base);
	// 828402E4: 807F0318  lwz r3, 0x318(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(792 as u32) ) } as u64;
	// 828402E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828402EC: 419A0008  beq cr6, 0x828402f4
	if ctx.cr[6].eq {
	pc = 0x828402F4; continue 'dispatch;
	}
	// 828402F0: 4BA805A1  bl 0x822c0890
	ctx.lr = 0x828402F4;
	sub_822C0890(ctx, base);
	// 828402F4: 3BDF02C8  addi r30, r31, 0x2c8
	ctx.r[30].s64 = ctx.r[31].s64 + 712;
	// 828402F8: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 828402FC: 485B312D  bl 0x82df3428
	ctx.lr = 0x82840300;
	sub_82DF3428(ctx, base);
	// 82840300: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 82840304: 482F8A9D  bl 0x82b38da0
	ctx.lr = 0x82840308;
	sub_82B38DA0(ctx, base);
	// 82840308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284030C: 4BC29CF5  bl 0x8246a000
	ctx.lr = 0x82840310;
	sub_8246A000(ctx, base);
	// 82840310: 807F0284  lwz r3, 0x284(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 82840314: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82840318: 419A0008  beq cr6, 0x82840320
	if ctx.cr[6].eq {
	pc = 0x82840320; continue 'dispatch;
	}
	// 8284031C: 4BA80575  bl 0x822c0890
	ctx.lr = 0x82840320;
	sub_822C0890(ctx, base);
	// 82840320: 387F026C  addi r3, r31, 0x26c
	ctx.r[3].s64 = ctx.r[31].s64 + 620;
	// 82840324: 4BD7FD7D  bl 0x825c00a0
	ctx.lr = 0x82840328;
	sub_825C00A0(ctx, base);
	// 82840328: 807F0268  lwz r3, 0x268(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(616 as u32) ) } as u64;
	// 8284032C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82840330: 419A0008  beq cr6, 0x82840338
	if ctx.cr[6].eq {
	pc = 0x82840338; continue 'dispatch;
	}
	// 82840334: 4BA8055D  bl 0x822c0890
	ctx.lr = 0x82840338;
	sub_822C0890(ctx, base);
	// 82840338: 807F0260  lwz r3, 0x260(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(608 as u32) ) } as u64;
	// 8284033C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82840340: 419A0008  beq cr6, 0x82840348
	if ctx.cr[6].eq {
	pc = 0x82840348; continue 'dispatch;
	}
	// 82840344: 4BA8054D  bl 0x822c0890
	ctx.lr = 0x82840348;
	sub_822C0890(ctx, base);
	// 82840348: 807F0258  lwz r3, 0x258(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(600 as u32) ) } as u64;
	// 8284034C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82840350: 419A0008  beq cr6, 0x82840358
	if ctx.cr[6].eq {
	pc = 0x82840358; continue 'dispatch;
	}
	// 82840354: 4BA8053D  bl 0x822c0890
	ctx.lr = 0x82840358;
	sub_822C0890(ctx, base);
	// 82840358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284035C: 4BFD7B1D  bl 0x82817e78
	ctx.lr = 0x82840360;
	sub_82817E78(ctx, base);
	// 82840360: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82840364: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82840368: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8284036C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82840370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82840374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82840378 size=8
    let mut pc: u32 = 0x82840378;
    'dispatch: loop {
        match pc {
            0x82840378 => {
    //   block [0x82840378..0x82840380)
	// 82840378: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 8284037C: 480003F4  b 0x82840770
	sub_82840770(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82840380 size=8
    let mut pc: u32 = 0x82840380;
    'dispatch: loop {
        match pc {
            0x82840380 => {
    //   block [0x82840380..0x82840388)
	// 82840380: 3863FDF8  addi r3, r3, -0x208
	ctx.r[3].s64 = ctx.r[3].s64 + -520;
	// 82840384: 480003EC  b 0x82840770
	sub_82840770(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840388 size=100
    let mut pc: u32 = 0x82840388;
    'dispatch: loop {
        match pc {
            0x82840388 => {
    //   block [0x82840388..0x828403EC)
	// 82840388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284038C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82840390: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82840394: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82840398: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284039C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828403A0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 828403A4: 48022E65  bl 0x82863208
	ctx.lr = 0x828403A8;
	sub_82863208(ctx, base);
	// 828403A8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828403AC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 828403B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828403B4: 394AD314  addi r10, r10, -0x2cec
	ctx.r[10].s64 = ctx.r[10].s64 + -11500;
	// 828403B8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828403BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828403C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828403C4: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828403C8: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 828403CC: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 828403D0: 993F007C  stb r9, 0x7c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u8 ) };
	// 828403D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828403D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828403DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828403E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828403E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828403E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828403F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828403F0 size=88
    let mut pc: u32 = 0x828403F0;
    'dispatch: loop {
        match pc {
            0x828403F0 => {
    //   block [0x828403F0..0x82840448)
	// 828403F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828403F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828403F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828403FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82840400: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82840404: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82840408: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 8284040C: 396BD314  addi r11, r11, -0x2cec
	ctx.r[11].s64 = ctx.r[11].s64 + -11500;
	// 82840410: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82840414: 4BC29BED  bl 0x8246a000
	ctx.lr = 0x82840418;
	sub_8246A000(ctx, base);
	// 82840418: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8284041C: 387F0064  addi r3, r31, 0x64
	ctx.r[3].s64 = ctx.r[31].s64 + 100;
	// 82840420: 396BCFA4  addi r11, r11, -0x305c
	ctx.r[11].s64 = ctx.r[11].s64 + -12380;
	// 82840424: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82840428: 485B3001  bl 0x82df3428
	ctx.lr = 0x8284042C;
	sub_82DF3428(ctx, base);
	// 8284042C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82840430: 4861C159  bl 0x82e5c588
	ctx.lr = 0x82840434;
	sub_82E5C588(ctx, base);
	// 82840434: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82840438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8284043C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82840440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82840444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840448 size=76
    let mut pc: u32 = 0x82840448;
    'dispatch: loop {
        match pc {
            0x82840448 => {
    //   block [0x82840448..0x82840494)
	// 82840448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284044C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82840450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82840454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82840458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284045C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82840460: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82840464: 4BFFFF8D  bl 0x828403f0
	ctx.lr = 0x82840468;
	sub_828403F0(ctx, base);
	// 82840468: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284046C: 4182000C  beq 0x82840478
	if ctx.cr[0].eq {
	pc = 0x82840478; continue 'dispatch;
	}
	// 82840470: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82840474: 485B1F65  bl 0x82df23d8
	ctx.lr = 0x82840478;
	sub_82DF23D8(ctx, base);
	// 82840478: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284047C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82840480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82840484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82840488: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284048C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82840490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82840498 size=264
    let mut pc: u32 = 0x82840498;
    'dispatch: loop {
        match pc {
            0x82840498 => {
    //   block [0x82840498..0x828405A0)
	// 82840498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284049C: 48967CCD  bl 0x831a8168
	ctx.lr = 0x828404A0;
	sub_831A8130(ctx, base);
	// 828404A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828404A4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 828404A8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828404AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828404B0: 4BFAF2D1  bl 0x827ef780
	ctx.lr = 0x828404B4;
	sub_827EF780(ctx, base);
	// 828404B4: 4BFA9DF5  bl 0x827ea2a8
	ctx.lr = 0x828404B8;
	sub_827EA2A8(ctx, base);
	// 828404B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828404BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828404C0: 4BFAE3F1  bl 0x827ee8b0
	ctx.lr = 0x828404C4;
	sub_827EE8B0(ctx, base);
	// 828404C4: 48376575  bl 0x82bb6a38
	ctx.lr = 0x828404C8;
	sub_82BB6A38(ctx, base);
	// 828404C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828404CC: C00B08A8  lfs f0, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828404D0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 828404D4: 40990070  ble cr6, 0x82840544
	if !ctx.cr[6].gt {
	pc = 0x82840544; continue 'dispatch;
	}
	// 828404D8: 897E007C  lbz r11, 0x7c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) } as u64;
	// 828404DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828404E0: 41820064  beq 0x82840544
	if ctx.cr[0].eq {
	pc = 0x82840544; continue 'dispatch;
	}
	// 828404E4: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828404E8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828404EC: 3B8B6910  addi r28, r11, 0x6910
	ctx.r[28].s64 = ctx.r[11].s64 + 26896;
	// 828404F0: 38AAD360  addi r5, r10, -0x2ca0
	ctx.r[5].s64 = ctx.r[10].s64 + -11424;
	// 828404F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828404F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828404FC: 4BFFD535  bl 0x8283da30
	ctx.lr = 0x82840500;
	sub_8283DA30(ctx, base);
	// 82840500: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82840504: 3BFE006C  addi r31, r30, 0x6c
	ctx.r[31].s64 = ctx.r[30].s64 + 108;
	// 82840508: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8284050C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82840510: 4BC78C01  bl 0x824b9110
	ctx.lr = 0x82840514;
	sub_824B9110(ctx, base);
	// 82840514: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82840518: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8284051C: 38ABD350  addi r5, r11, -0x2cb0
	ctx.r[5].s64 = ctx.r[11].s64 + -11440;
	// 82840520: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82840524: 4BFFD50D  bl 0x8283da30
	ctx.lr = 0x82840528;
	sub_8283DA30(ctx, base);
	// 82840528: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 8284052C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82840530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82840534: 4BC78BDD  bl 0x824b9110
	ctx.lr = 0x82840538;
	sub_824B9110(ctx, base);
	// 82840538: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8284053C: 997E007C  stb r11, 0x7c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 82840540: 48000058  b 0x82840598
	pc = 0x82840598; continue 'dispatch;
	// 82840544: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82840548: C00BE47C  lfs f0, -0x1b84(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8284054C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82840550: 40990048  ble cr6, 0x82840598
	if !ctx.cr[6].gt {
	pc = 0x82840598; continue 'dispatch;
	}
	// 82840554: 817E0070  lwz r11, 0x70(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) } as u64;
	// 82840558: 3BFE006C  addi r31, r30, 0x6c
	ctx.r[31].s64 = ctx.r[30].s64 + 108;
	// 8284055C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82840560: 419A0038  beq cr6, 0x82840598
	if ctx.cr[6].eq {
	pc = 0x82840598; continue 'dispatch;
	}
	// 82840564: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82840568: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8284056C: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82840570: 41820028  beq 0x82840598
	if ctx.cr[0].eq {
	pc = 0x82840598; continue 'dispatch;
	}
	// 82840574: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82840578: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8284057C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82840580: 4BFFE869  bl 0x8283ede8
	ctx.lr = 0x82840584;
	sub_8283EDE8(ctx, base);
	// 82840584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82840588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284058C: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82840590: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82840594: 4BAC81D5  bl 0x82308768
	ctx.lr = 0x82840598;
	sub_82308768(ctx, base);
	// 82840598: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8284059C: 48967C1C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828405A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828405A0 size=460
    let mut pc: u32 = 0x828405A0;
    'dispatch: loop {
        match pc {
            0x828405A0 => {
    //   block [0x828405A0..0x8284076C)
	// 828405A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828405A4: 48967BBD  bl 0x831a8160
	ctx.lr = 0x828405A8;
	sub_831A8130(ctx, base);
	// 828405A8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828405AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828405B0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828405B4: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 828405B8: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 828405BC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 828405C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828405C4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828405C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828405CC: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840770 size=76
    let mut pc: u32 = 0x82840770;
    'dispatch: loop {
        match pc {
            0x82840770 => {
    //   block [0x82840770..0x828407BC)
	// 82840770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82840774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82840778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8284077C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82840780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82840784: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82840788: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8284078C: 4BFFFB0D  bl 0x82840298
	ctx.lr = 0x82840790;
	sub_82840298(ctx, base);
	// 82840790: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82840794: 4182000C  beq 0x828407a0
	if ctx.cr[0].eq {
	pc = 0x828407A0; continue 'dispatch;
	}
	// 82840798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284079C: 485B1C3D  bl 0x82df23d8
	ctx.lr = 0x828407A0;
	sub_82DF23D8(ctx, base);
	// 828407A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828407A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828407A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828407AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828407B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828407B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828407B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828407C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828407C0 size=84
    let mut pc: u32 = 0x828407C0;
    'dispatch: loop {
        match pc {
            0x828407C0 => {
    //   block [0x828407C0..0x82840814)
	// 828407C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828407C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828407C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828407CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828407D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828407D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828407D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828407DC: 4BFFF995  bl 0x82840170
	ctx.lr = 0x828407E0;
	sub_82840170(ctx, base);
	// 828407E0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 828407E4: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 828407E8: 4BFFFA31  bl 0x82840218
	ctx.lr = 0x828407EC;
	sub_82840218(ctx, base);
	// 828407EC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 828407F0: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 828407F4: 485B340D  bl 0x82df3c00
	ctx.lr = 0x828407F8;
	sub_82DF3C00(ctx, base);
	// 828407F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828407FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82840800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82840804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82840808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284080C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82840810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82840818 size=1952
    let mut pc: u32 = 0x82840818;
    'dispatch: loop {
        match pc {
            0x82840818 => {
    //   block [0x82840818..0x82840FB8)
	// 82840818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284081C: 48967945  bl 0x831a8160
	ctx.lr = 0x82840820;
	sub_831A8130(ctx, base);
	// 82840820: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 82840824: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82840828: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8284082C: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82840830: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82840834: 4BFD9A05  bl 0x8281a238
	ctx.lr = 0x82840838;
	sub_8281A238(ctx, base);
	// 82840838: 38BE0280  addi r5, r30, 0x280
	ctx.r[5].s64 = ctx.r[30].s64 + 640;
	// 8284083C: 809E0288  lwz r4, 0x288(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(648 as u32) ) } as u64;
	// 82840840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82840844: 4BFDA2BD  bl 0x8281ab00
	ctx.lr = 0x82840848;
	sub_8281AB00(ctx, base);
	// 82840848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284084C: 83FE0280  lwz r31, 0x280(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(640 as u32) ) } as u64;
	// 82840850: 481D2E31  bl 0x82a13680
	ctx.lr = 0x82840854;
	sub_82A13680(ctx, base);
	// 82840854: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82840858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284085C: 4BFDA12D  bl 0x8281a988
	ctx.lr = 0x82840860;
	sub_8281A988(ctx, base);
	// 82840860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82840864: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82840868: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 8284086C: C3AB08A8  lfs f29, 0x8a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82840870: C3EA08A4  lfs f31, 0x8a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82840874: C3C96218  lfs f30, 0x6218(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(25112 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82840878: 83FE0280  lwz r31, 0x280(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(640 as u32) ) } as u64;
	// 8284087C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82840880: 419A00D0  beq cr6, 0x82840950
	if ctx.cr[6].eq {
	pc = 0x82840950; continue 'dispatch;
	}
	// 82840884: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82840888: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 8284088C: 396B6910  addi r11, r11, 0x6910
	ctx.r[11].s64 = ctx.r[11].s64 + 26896;
	// 82840890: 392100E0  addi r9, r1, 0xe0
	ctx.r[9].s64 = ctx.r[1].s64 + 224;
	// 82840894: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82840898: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284089C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82840FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82840FB8 size=292
    let mut pc: u32 = 0x82840FB8;
    'dispatch: loop {
        match pc {
            0x82840FB8 => {
    //   block [0x82840FB8..0x828410DC)
	// 82840FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82840FBC: 489671A9  bl 0x831a8164
	ctx.lr = 0x82840FC0;
	sub_831A8130(ctx, base);
	// 82840FC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82840FC4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82840FC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82840FCC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82840FD0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82840FD4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82840FD8: 4BFAB141  bl 0x827ec118
	ctx.lr = 0x82840FDC;
	sub_827EC118(ctx, base);
	// 82840FDC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82840FE0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82840FE4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82840FE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82840FEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82840FF0: 4BFFC4E9  bl 0x8283d4d8
	ctx.lr = 0x82840FF4;
	sub_8283D4D8(ctx, base);
	// 82840FF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82840FF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82840FFC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82841000: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82841004: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82841008: 419A0024  beq cr6, 0x8284102c
	if ctx.cr[6].eq {
	pc = 0x8284102C; continue 'dispatch;
	}
	// 8284100C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82841010: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82841014: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841018: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8284101C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82841020: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82841024: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841028: 4082FFE8  bne 0x82841010
	if !ctx.cr[0].eq {
	pc = 0x82841010; continue 'dispatch;
	}
	// 8284102C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82841030: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82841034: 4BFABEFD  bl 0x827ecf30
	ctx.lr = 0x82841038;
	sub_827ECF30(ctx, base);
	// 82841038: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284103C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841040: 419A0008  beq cr6, 0x82841048
	if ctx.cr[6].eq {
	pc = 0x82841048; continue 'dispatch;
	}
	// 82841044: 4BA7F84D  bl 0x822c0890
	ctx.lr = 0x82841048;
	sub_822C0890(ctx, base);
	// 82841048: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8284104C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841050: 419A0008  beq cr6, 0x82841058
	if ctx.cr[6].eq {
	pc = 0x82841058; continue 'dispatch;
	}
	// 82841054: 4BA7F83D  bl 0x822c0890
	ctx.lr = 0x82841058;
	sub_822C0890(ctx, base);
	// 82841058: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 8284105C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82841060: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82841064: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841068: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8284106C: 4BFFC2D5  bl 0x8283d340
	ctx.lr = 0x82841070;
	sub_8283D340(ctx, base);
	// 82841070: 83E30004  lwz r31, 4(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82841074: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841078: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8284107C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82841080: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82841084: 419A0024  beq cr6, 0x828410a8
	if ctx.cr[6].eq {
	pc = 0x828410A8; continue 'dispatch;
	}
	// 82841088: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8284108C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82841090: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841094: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82841098: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8284109C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828410A0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828410A4: 4082FFE8  bne 0x8284108c
	if !ctx.cr[0].eq {
	pc = 0x8284108C; continue 'dispatch;
	}
	// 828410A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828410AC: 387B026C  addi r3, r27, 0x26c
	ctx.r[3].s64 = ctx.r[27].s64 + 620;
	// 828410B0: 4BFAE299  bl 0x827ef348
	ctx.lr = 0x828410B4;
	sub_827EF348(ctx, base);
	// 828410B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828410B8: 419A000C  beq cr6, 0x828410c4
	if ctx.cr[6].eq {
	pc = 0x828410C4; continue 'dispatch;
	}
	// 828410BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828410C0: 4BA7F7D1  bl 0x822c0890
	ctx.lr = 0x828410C4;
	sub_822C0890(ctx, base);
	// 828410C4: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828410C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828410CC: 419A0008  beq cr6, 0x828410d4
	if ctx.cr[6].eq {
	pc = 0x828410D4; continue 'dispatch;
	}
	// 828410D0: 4BA7F7C1  bl 0x822c0890
	ctx.lr = 0x828410D4;
	sub_822C0890(ctx, base);
	// 828410D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828410D8: 489670DC  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828410E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828410E0 size=688
    let mut pc: u32 = 0x828410E0;
    'dispatch: loop {
        match pc {
            0x828410E0 => {
    //   block [0x828410E0..0x82841390)
	// 828410E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828410E4: 48967085  bl 0x831a8168
	ctx.lr = 0x828410E8;
	sub_831A8130(ctx, base);
	// 828410E8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828410EC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828410F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828410F4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 828410F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828410FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82841100: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841104: C3FE02C4  lfs f31, 0x2c4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(708 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82841108: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 8284110C: 388BCB38  addi r4, r11, -0x34c8
	ctx.r[4].s64 = ctx.r[11].s64 + -13512;
	// 82841110: 485B28F9  bl 0x82df3a08
	ctx.lr = 0x82841114;
	sub_82DF3A08(ctx, base);
	// 82841114: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82841118: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8284111C: 480225A5  bl 0x828636c0
	ctx.lr = 0x82841120;
	sub_828636C0(ctx, base);
	// 82841120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841124: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82841128: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284112C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82841130: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82841134: 419A0024  beq cr6, 0x82841158
	if ctx.cr[6].eq {
	pc = 0x82841158; continue 'dispatch;
	}
	// 82841138: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8284113C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82841140: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841144: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82841148: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8284114C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82841150: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841154: 4082FFE8  bne 0x8284113c
	if !ctx.cr[0].eq {
	pc = 0x8284113C; continue 'dispatch;
	}
	// 82841158: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8284115C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82841160: 4BFAE541  bl 0x827ef6a0
	ctx.lr = 0x82841164;
	sub_827EF6A0(ctx, base);
	// 82841164: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82841168: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284116C: 419A0008  beq cr6, 0x82841174
	if ctx.cr[6].eq {
	pc = 0x82841174; continue 'dispatch;
	}
	// 82841170: 4BA7F721  bl 0x822c0890
	ctx.lr = 0x82841174;
	sub_822C0890(ctx, base);
	// 82841174: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82841178: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8284117C: 419A0008  beq cr6, 0x82841184
	if ctx.cr[6].eq {
	pc = 0x82841184; continue 'dispatch;
	}
	// 82841180: 4BA7F711  bl 0x822c0890
	ctx.lr = 0x82841184;
	sub_822C0890(ctx, base);
	// 82841184: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841188: 485B22A1  bl 0x82df3428
	ctx.lr = 0x8284118C;
	sub_82DF3428(ctx, base);
	// 8284118C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82841190: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841194: 388BCB28  addi r4, r11, -0x34d8
	ctx.r[4].s64 = ctx.r[11].s64 + -13528;
	// 82841198: 485B2871  bl 0x82df3a08
	ctx.lr = 0x8284119C;
	sub_82DF3A08(ctx, base);
	// 8284119C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828411A0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 828411A4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828411A8: 48022591  bl 0x82863738
	ctx.lr = 0x828411AC;
	sub_82863738(ctx, base);
	// 828411AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828411B0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 828411B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828411B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828411BC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 828411C0: 419A0024  beq cr6, 0x828411e4
	if ctx.cr[6].eq {
	pc = 0x828411E4; continue 'dispatch;
	}
	// 828411C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828411C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828411CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828411D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828411D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828411D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828411DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828411E0: 4082FFE8  bne 0x828411c8
	if !ctx.cr[0].eq {
	pc = 0x828411C8; continue 'dispatch;
	}
	// 828411E4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 828411E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828411EC: 4BFAE4B5  bl 0x827ef6a0
	ctx.lr = 0x828411F0;
	sub_827EF6A0(ctx, base);
	// 828411F0: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828411F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828411F8: 419A0008  beq cr6, 0x82841200
	if ctx.cr[6].eq {
	pc = 0x82841200; continue 'dispatch;
	}
	// 828411FC: 4BA7F695  bl 0x822c0890
	ctx.lr = 0x82841200;
	sub_822C0890(ctx, base);
	// 82841200: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82841204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841208: 419A0008  beq cr6, 0x82841210
	if ctx.cr[6].eq {
	pc = 0x82841210; continue 'dispatch;
	}
	// 8284120C: 4BA7F685  bl 0x822c0890
	ctx.lr = 0x82841210;
	sub_822C0890(ctx, base);
	// 82841210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841214: 485B2215  bl 0x82df3428
	ctx.lr = 0x82841218;
	sub_82DF3428(ctx, base);
	// 82841218: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8284121C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82841220: 388BD108  addi r4, r11, -0x2ef8
	ctx.r[4].s64 = ctx.r[11].s64 + -12024;
	// 82841224: 38A002D3  li r5, 0x2d3
	ctx.r[5].s64 = 723;
	// 82841228: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 8284122C: 485B11BD  bl 0x82df23e8
	ctx.lr = 0x82841230;
	sub_82DF23E8(ctx, base);
	// 82841230: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82841234: 41820030  beq 0x82841264
	if ctx.cr[0].eq {
	pc = 0x82841264; continue 'dispatch;
	}
	// 82841238: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8284123C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841240: 388BCB1C  addi r4, r11, -0x34e4
	ctx.r[4].s64 = ctx.r[11].s64 + -13540;
	// 82841244: 485B27C5  bl 0x82df3a08
	ctx.lr = 0x82841248;
	sub_82DF3A08(ctx, base);
	// 82841248: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8284124C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82841250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841254: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82841258: 4BFFF131  bl 0x82840388
	ctx.lr = 0x8284125C;
	sub_82840388(ctx, base);
	// 8284125C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82841260: 48000008  b 0x82841268
	pc = 0x82841268; continue 'dispatch;
	// 82841264: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82841268: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8284126C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841270: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82841274: 4BFF9D75  bl 0x8283afe8
	ctx.lr = 0x82841278;
	sub_8283AFE8(ctx, base);
	// 82841278: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8284127C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841280: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82841284: 4BA7ED7D  bl 0x822c0000
	ctx.lr = 0x82841288;
	sub_822C0000(ctx, base);
	// 82841288: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8284128C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82841290: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82841294: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82841298: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 8284129C: 419A0024  beq cr6, 0x828412c0
	if ctx.cr[6].eq {
	pc = 0x828412C0; continue 'dispatch;
	}
	// 828412A0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828412A4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828412A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828412AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828412B0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828412B4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828412B8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828412BC: 4082FFE8  bne 0x828412a4
	if !ctx.cr[0].eq {
	pc = 0x828412A4; continue 'dispatch;
	}
	// 828412C0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 828412C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828412C8: 4BFAE3D9  bl 0x827ef6a0
	ctx.lr = 0x828412CC;
	sub_827EF6A0(ctx, base);
	// 828412CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 828412D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828412D4: 419A0008  beq cr6, 0x828412dc
	if ctx.cr[6].eq {
	pc = 0x828412DC; continue 'dispatch;
	}
	// 828412D8: 4BA7F5B9  bl 0x822c0890
	ctx.lr = 0x828412DC;
	sub_822C0890(ctx, base);
	// 828412DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828412E0: 419A000C  beq cr6, 0x828412ec
	if ctx.cr[6].eq {
	pc = 0x828412EC; continue 'dispatch;
	}
	// 828412E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828412E8: 4BA7F5A9  bl 0x822c0890
	ctx.lr = 0x828412EC;
	sub_822C0890(ctx, base);
	// 828412EC: 578B07FF  clrlwi. r11, r28, 0x1f
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828412F0: 4182000C  beq 0x828412fc
	if ctx.cr[0].eq {
	pc = 0x828412FC; continue 'dispatch;
	}
	// 828412F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828412F8: 485B2131  bl 0x82df3428
	ctx.lr = 0x828412FC;
	sub_82DF3428(ctx, base);
	// 828412FC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82841300: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841304: 388BCB10  addi r4, r11, -0x34f0
	ctx.r[4].s64 = ctx.r[11].s64 + -13552;
	// 82841308: 485B2701  bl 0x82df3a08
	ctx.lr = 0x8284130C;
	sub_82DF3A08(ctx, base);
	// 8284130C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82841310: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82841314: 480223AD  bl 0x828636c0
	ctx.lr = 0x82841318;
	sub_828636C0(ctx, base);
	// 82841318: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284131C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82841320: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82841324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82841328: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 8284132C: 419A0024  beq cr6, 0x82841350
	if ctx.cr[6].eq {
	pc = 0x82841350; continue 'dispatch;
	}
	// 82841330: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82841334: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82841338: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284133C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82841340: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82841344: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82841348: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284134C: 4082FFE8  bne 0x82841334
	if !ctx.cr[0].eq {
	pc = 0x82841334; continue 'dispatch;
	}
	// 82841350: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82841354: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82841358: 4BFAE349  bl 0x827ef6a0
	ctx.lr = 0x8284135C;
	sub_827EF6A0(ctx, base);
	// 8284135C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82841360: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841364: 419A0008  beq cr6, 0x8284136c
	if ctx.cr[6].eq {
	pc = 0x8284136C; continue 'dispatch;
	}
	// 82841368: 4BA7F529  bl 0x822c0890
	ctx.lr = 0x8284136C;
	sub_822C0890(ctx, base);
	// 8284136C: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82841370: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841374: 419A0008  beq cr6, 0x8284137c
	if ctx.cr[6].eq {
	pc = 0x8284137C; continue 'dispatch;
	}
	// 82841378: 4BA7F519  bl 0x822c0890
	ctx.lr = 0x8284137C;
	sub_822C0890(ctx, base);
	// 8284137C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841380: 485B20A9  bl 0x82df3428
	ctx.lr = 0x82841384;
	sub_82DF3428(ctx, base);
	// 82841384: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82841388: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8284138C: 48966E2C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82841390 size=136
    let mut pc: u32 = 0x82841390;
    'dispatch: loop {
        match pc {
            0x82841390 => {
    //   block [0x82841390..0x82841418)
	// 82841390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82841394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82841398: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284139C: 3D208284  lis r9, -0x7d7c
	ctx.r[9].s64 = -2105278464;
	// 828413A0: 3D408284  lis r10, -0x7d7c
	ctx.r[10].s64 = -2105278464;
	// 828413A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828413A8: 3929CD00  addi r9, r9, -0x3300
	ctx.r[9].s64 = ctx.r[9].s64 + -13056;
	// 828413AC: 394A10E0  addi r10, r10, 0x10e0
	ctx.r[10].s64 = ctx.r[10].s64 + 4320;
	// 828413B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828413B4: 3D008284  lis r8, -0x7d7c
	ctx.r[8].s64 = -2105278464;
	// 828413B8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828413BC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828413C0: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 828413C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828413C8: 3928DEF8  addi r9, r8, -0x2108
	ctx.r[9].s64 = ctx.r[8].s64 + -8456;
	// 828413CC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828413D0: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828413D4: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828413D8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828413DC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 828413E0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828413E4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 828413E8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 828413EC: F8C10060  std r6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[6].u64 ) };
	// 828413F0: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 828413F4: 7D6A382E  lwzx r11, r10, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 828413F8: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 828413FC: 7D6A282E  lwzx r11, r10, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82841400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82841404: 4E800421  bctrl
	ctx.lr = 0x82841408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82841408: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8284140C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82841410: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82841414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82841418 size=328
    let mut pc: u32 = 0x82841418;
    'dispatch: loop {
        match pc {
            0x82841418 => {
    //   block [0x82841418..0x82841560)
	// 82841418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284141C: 48966D4D  bl 0x831a8168
	ctx.lr = 0x82841420;
	sub_831A8130(ctx, base);
	// 82841420: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82841424: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82841428: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8284142C: 817D02A4  lwz r11, 0x2a4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(676 as u32) ) } as u64;
	// 82841430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82841434: 419A0124  beq cr6, 0x82841558
	if ctx.cr[6].eq {
	pc = 0x82841558; continue 'dispatch;
	}
	// 82841438: 4811F129  bl 0x82960560
	ctx.lr = 0x8284143C;
	sub_82960560(ctx, base);
	// 8284143C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82841440: 41820118  beq 0x82841558
	if ctx.cr[0].eq {
	pc = 0x82841558; continue 'dispatch;
	}
	// 82841444: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841448: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284144C: 808B17D0  lwz r4, 0x17d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6096 as u32) ) } as u64;
	// 82841450: 485B25B9  bl 0x82df3a08
	ctx.lr = 0x82841454;
	sub_82DF3A08(ctx, base);
	// 82841454: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82841458: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 8284145C: 4BFAB9A5  bl 0x827ece00
	ctx.lr = 0x82841460;
	sub_827ECE00(ctx, base);
	// 82841460: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82841464: 485B1EA5  bl 0x82df3308
	ctx.lr = 0x82841468;
	sub_82DF3308(ctx, base);
	// 82841468: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8284146C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841470: 485B1FB9  bl 0x82df3428
	ctx.lr = 0x82841474;
	sub_82DF3428(ctx, base);
	// 82841474: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841478: 4182000C  beq 0x82841484
	if ctx.cr[0].eq {
	pc = 0x82841484; continue 'dispatch;
	}
	// 8284147C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82841480: 4BFAD761  bl 0x827eebe0
	ctx.lr = 0x82841484;
	sub_827EEBE0(ctx, base);
	// 82841484: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82841488: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8284148C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82841490: 4BFFFF01  bl 0x82841390
	ctx.lr = 0x82841494;
	sub_82841390(ctx, base);
	// 82841494: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82841498: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8284149C: 388BD108  addi r4, r11, -0x2ef8
	ctx.r[4].s64 = ctx.r[11].s64 + -12024;
	// 828414A0: 38A00302  li r5, 0x302
	ctx.r[5].s64 = 770;
	// 828414A4: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828414A8: 485B0F41  bl 0x82df23e8
	ctx.lr = 0x828414AC;
	sub_82DF23E8(ctx, base);
	// 828414AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828414B0: 41820018  beq 0x828414c8
	if ctx.cr[0].eq {
	pc = 0x828414C8; continue 'dispatch;
	}
	// 828414B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828414B8: C02B964C  lfs f1, -0x69b4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828414BC: 4BFF8BED  bl 0x8283a0a8
	ctx.lr = 0x828414C0;
	sub_8283A0A8(ctx, base);
	// 828414C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828414C4: 48000008  b 0x828414cc
	pc = 0x828414CC; continue 'dispatch;
	// 828414C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828414CC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828414D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828414D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828414D8: 4BFF9BD9  bl 0x8283b0b0
	ctx.lr = 0x828414DC;
	sub_8283B0B0(ctx, base);
	// 828414DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828414E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828414E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828414E8: 4BA7EB19  bl 0x822c0000
	ctx.lr = 0x828414EC;
	sub_822C0000(ctx, base);
	// 828414EC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828414F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828414F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828414F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828414FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82841500: 419A0024  beq cr6, 0x82841524
	if ctx.cr[6].eq {
	pc = 0x82841524; continue 'dispatch;
	}
	// 82841504: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82841508: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284150C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841510: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82841514: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82841518: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284151C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82841520: 4082FFE8  bne 0x82841508
	if !ctx.cr[0].eq {
	pc = 0x82841508; continue 'dispatch;
	}
	// 82841524: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82841528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284152C: 4BFAE175  bl 0x827ef6a0
	ctx.lr = 0x82841530;
	sub_827EF6A0(ctx, base);
	// 82841530: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82841534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841538: 419A0008  beq cr6, 0x82841540
	if ctx.cr[6].eq {
	pc = 0x82841540; continue 'dispatch;
	}
	// 8284153C: 4BA7F355  bl 0x822c0890
	ctx.lr = 0x82841540;
	sub_822C0890(ctx, base);
	// 82841540: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82841544: 419A000C  beq cr6, 0x82841550
	if ctx.cr[6].eq {
	pc = 0x82841550; continue 'dispatch;
	}
	// 82841548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284154C: 4BA7F345  bl 0x822c0890
	ctx.lr = 0x82841550;
	sub_822C0890(ctx, base);
	// 82841550: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82841554: 917D02A4  stw r11, 0x2a4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 82841558: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8284155C: 48966C5C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82841560 size=544
    let mut pc: u32 = 0x82841560;
    'dispatch: loop {
        match pc {
            0x82841560 => {
    //   block [0x82841560..0x82841780)
	// 82841560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82841564: 48966BF9  bl 0x831a815c
	ctx.lr = 0x82841568;
	sub_831A8130(ctx, base);
	// 82841568: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284156C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82841570: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82841574: 817D02A4  lwz r11, 0x2a4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(676 as u32) ) } as u64;
	// 82841578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284157C: 419A01FC  beq cr6, 0x82841778
	if ctx.cr[6].eq {
	pc = 0x82841778; continue 'dispatch;
	}
	// 82841580: 4811EFE1  bl 0x82960560
	ctx.lr = 0x82841584;
	sub_82960560(ctx, base);
	// 82841584: 7C7A1B79  or. r26, r3, r3
	ctx.r[26].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82841588: 418201F0  beq 0x82841778
	if ctx.cr[0].eq {
	pc = 0x82841778; continue 'dispatch;
	}
	// 8284158C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841594: 808B17D0  lwz r4, 0x17d0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6096 as u32) ) } as u64;
	// 82841598: 485B2471  bl 0x82df3a08
	ctx.lr = 0x8284159C;
	sub_82DF3A08(ctx, base);
	// 8284159C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828415A0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 828415A4: 4BFAB85D  bl 0x827ece00
	ctx.lr = 0x828415A8;
	sub_827ECE00(ctx, base);
	// 828415A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828415AC: 485B1D5D  bl 0x82df3308
	ctx.lr = 0x828415B0;
	sub_82DF3308(ctx, base);
	// 828415B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828415B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828415B8: 485B1E71  bl 0x82df3428
	ctx.lr = 0x828415BC;
	sub_82DF3428(ctx, base);
	// 828415BC: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828415C0: 4182000C  beq 0x828415cc
	if ctx.cr[0].eq {
	pc = 0x828415CC; continue 'dispatch;
	}
	// 828415C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828415C8: 4BFAD619  bl 0x827eebe0
	ctx.lr = 0x828415CC;
	sub_827EEBE0(ctx, base);
	// 828415CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828415D0: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 828415D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 828415D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828415DC: 4BFFD21D  bl 0x8283e7f8
	ctx.lr = 0x828415E0;
	sub_8283E7F8(ctx, base);
	// 828415E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828415E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828415E8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828415EC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828415F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828415F4: 4BA82E6D  bl 0x822c4460
	ctx.lr = 0x828415F8;
	sub_822C4460(ctx, base);
	// 828415F8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828415FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841600: 419A0008  beq cr6, 0x82841608
	if ctx.cr[6].eq {
	pc = 0x82841608; continue 'dispatch;
	}
	// 82841604: 4BA7F28D  bl 0x822c0890
	ctx.lr = 0x82841608;
	sub_822C0890(ctx, base);
	// 82841608: 83210054  lwz r25, 0x54(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8284160C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82841610: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82841614: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82841618: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8284161C: 419A0024  beq cr6, 0x82841640
	if ctx.cr[6].eq {
	pc = 0x82841640; continue 'dispatch;
	}
	// 82841620: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	// 82841624: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82841628: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284162C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82841630: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82841634: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82841638: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284163C: 4082FFE8  bne 0x82841624
	if !ctx.cr[0].eq {
	pc = 0x82841624; continue 'dispatch;
	}
	// 82841640: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82841644: 80DD02A8  lwz r6, 0x2a8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(680 as u32) ) } as u64;
	// 82841648: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 8284164C: 3B8BD108  addi r28, r11, -0x2ef8
	ctx.r[28].s64 = ctx.r[11].s64 + -12024;
	// 82841650: 38A0031C  li r5, 0x31c
	ctx.r[5].s64 = 796;
	// 82841654: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82841658: 387D0028  addi r3, r29, 0x28
	ctx.r[3].s64 = ctx.r[29].s64 + 40;
	// 8284165C: 4861598D  bl 0x82e56fe8
	ctx.lr = 0x82841660;
	sub_82E56FE8(ctx, base);
	// 82841660: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82841664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841668: 419A0008  beq cr6, 0x82841670
	if ctx.cr[6].eq {
	pc = 0x82841670; continue 'dispatch;
	}
	// 8284166C: 4BA7F225  bl 0x822c0890
	ctx.lr = 0x82841670;
	sub_822C0890(ctx, base);
	// 82841670: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 82841674: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82841678: 4BFFEAF9  bl 0x82840170
	ctx.lr = 0x8284167C;
	sub_82840170(ctx, base);
	// 8284167C: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82841680: 83610078  lwz r27, 0x78(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82841684: 480000CC  b 0x82841750
	pc = 0x82841750; continue 'dispatch;
	// 82841688: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8284168C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82841694: 4BFFFCFD  bl 0x82841390
	ctx.lr = 0x82841698;
	sub_82841390(ctx, base);
	// 82841698: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8284169C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828416A0: 38A00325  li r5, 0x325
	ctx.r[5].s64 = 805;
	// 828416A4: 38600068  li r3, 0x68
	ctx.r[3].s64 = 104;
	// 828416A8: 485B0D41  bl 0x82df23e8
	ctx.lr = 0x828416AC;
	sub_82DF23E8(ctx, base);
	// 828416AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828416B0: 41820014  beq 0x828416c4
	if ctx.cr[0].eq {
	pc = 0x828416C4; continue 'dispatch;
	}
	// 828416B4: C03E0004  lfs f1, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828416B8: 4BFF89F1  bl 0x8283a0a8
	ctx.lr = 0x828416BC;
	sub_8283A0A8(ctx, base);
	// 828416BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828416C0: 48000008  b 0x828416c8
	pc = 0x828416C8; continue 'dispatch;
	// 828416C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828416C8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828416CC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828416D0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828416D4: 4BFF99DD  bl 0x8283b0b0
	ctx.lr = 0x828416D8;
	sub_8283B0B0(ctx, base);
	// 828416D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828416DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828416E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828416E4: 4BA7E91D  bl 0x822c0000
	ctx.lr = 0x828416E8;
	sub_822C0000(ctx, base);
	// 828416E8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828416EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828416F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828416F4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 828416F8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828416FC: 419A0024  beq cr6, 0x82841720
	if ctx.cr[6].eq {
	pc = 0x82841720; continue 'dispatch;
	}
	// 82841700: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82841704: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82841708: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284170C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82841710: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82841714: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82841718: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8284171C: 4082FFE8  bne 0x82841704
	if !ctx.cr[0].eq {
	pc = 0x82841704; continue 'dispatch;
	}
	// 82841720: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82841724: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82841728: 4BFADF79  bl 0x827ef6a0
	ctx.lr = 0x8284172C;
	sub_827EF6A0(ctx, base);
	// 8284172C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82841730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841734: 419A0008  beq cr6, 0x8284173c
	if ctx.cr[6].eq {
	pc = 0x8284173C; continue 'dispatch;
	}
	// 82841738: 4BA7F159  bl 0x822c0890
	ctx.lr = 0x8284173C;
	sub_822C0890(ctx, base);
	// 8284173C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82841740: 419A000C  beq cr6, 0x8284174c
	if ctx.cr[6].eq {
	pc = 0x8284174C; continue 'dispatch;
	}
	// 82841744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841748: 4BA7F149  bl 0x822c0890
	ctx.lr = 0x8284174C;
	sub_822C0890(ctx, base);
	// 8284174C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82841750: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82841754: 409AFF34  bne cr6, 0x82841688
	if !ctx.cr[6].eq {
	pc = 0x82841688; continue 'dispatch;
	}
	// 82841758: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8284175C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82841760: 917D02A4  stw r11, 0x2a4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 82841764: 4BC2889D  bl 0x8246a000
	ctx.lr = 0x82841768;
	sub_8246A000(ctx, base);
	// 82841768: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8284176C: 419A000C  beq cr6, 0x82841778
	if ctx.cr[6].eq {
	pc = 0x82841778; continue 'dispatch;
	}
	// 82841770: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82841774: 4BA7F11D  bl 0x822c0890
	ctx.lr = 0x82841778;
	sub_822C0890(ctx, base);
	// 82841778: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8284177C: 48966A30  b 0x831a81ac
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82841780 size=116
    let mut pc: u32 = 0x82841780;
    'dispatch: loop {
        match pc {
            0x82841780 => {
    //   block [0x82841780..0x828417F4)
	// 82841780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82841784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82841788: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8284178C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82841790: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82841794: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82841798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284179C: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 828417A0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 828417A4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828417F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828417F8 size=464
    let mut pc: u32 = 0x828417F8;
    'dispatch: loop {
        match pc {
            0x828417F8 => {
    //   block [0x828417F8..0x828419C8)
	// 828417F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828417FC: 48966965  bl 0x831a8160
	ctx.lr = 0x82841800;
	sub_831A8130(ctx, base);
	// 82841800: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82841804: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82841808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284180C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82841810: 4BFD5E79  bl 0x82817688
	ctx.lr = 0x82841814;
	sub_82817688(ctx, base);
	// 82841814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841818: 4BFAAD61  bl 0x827ec578
	ctx.lr = 0x8284181C;
	sub_827EC578(ctx, base);
	// 8284181C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82841820: 40820054  bne 0x82841874
	if !ctx.cr[0].eq {
	pc = 0x82841874; continue 'dispatch;
	}
	// 82841824: 817F027C  lwz r11, 0x27c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(636 as u32) ) } as u64;
	// 82841828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284182C: 419A0048  beq cr6, 0x82841874
	if ctx.cr[6].eq {
	pc = 0x82841874; continue 'dispatch;
	}
	// 82841830: 813F0278  lwz r9, 0x278(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(632 as u32) ) } as u64;
	// 82841834: 3BDF026C  addi r30, r31, 0x26c
	ctx.r[30].s64 = ctx.r[31].s64 + 620;
	// 82841838: 815F0274  lwz r10, 0x274(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(628 as u32) ) } as u64;
	// 8284183C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82841840: 552907FE  clrlwi r9, r9, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 82841844: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82841848: 41990008  bgt cr6, 0x82841850
	if ctx.cr[6].gt {
	pc = 0x82841850; continue 'dispatch;
	}
	// 8284184C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82841850: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82841854: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82841858: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8284185C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841860: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82841864: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82841868: 4BFAB771  bl 0x827ecfd8
	ctx.lr = 0x8284186C;
	sub_827ECFD8(ctx, base);
	// 8284186C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82841870: 4BFAD289  bl 0x827eeaf8
	ctx.lr = 0x82841874;
	sub_827EEAF8(ctx, base);
	// 82841874: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841878: C3FD0000  lfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8284187C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841880: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82841884: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82841888: 4E800421  bctrl
	ctx.lr = 0x8284188C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8284188C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841894: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82841898: 4BFF8D79  bl 0x8283a610
	ctx.lr = 0x8284189C;
	sub_8283A610(ctx, base);
	// 8284189C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828418A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828418A4: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 828418A8: C3FD0000  lfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828418AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828418B0: 4E800421  bctrl
	ctx.lr = 0x828418B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828418B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828418B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828418BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 828418C0: 4BFFB319  bl 0x8283cbd8
	ctx.lr = 0x828418C4;
	sub_8283CBD8(ctx, base);
	// 828418C4: 807F0280  lwz r3, 0x280(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 828418C8: 3B9F0280  addi r28, r31, 0x280
	ctx.r[28].s64 = ctx.r[31].s64 + 640;
	// 828418CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828418D0: 419A00EC  beq cr6, 0x828419bc
	if ctx.cr[6].eq {
	pc = 0x828419BC; continue 'dispatch;
	}
	// 828418D4: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828418D8: 809F02A0  lwz r4, 0x2a0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(672 as u32) ) } as u64;
	// 828418DC: C1BF0298  lfs f13, 0x298(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(664 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828418E0: 3B7F0298  addi r27, r31, 0x298
	ctx.r[27].s64 = ctx.r[31].s64 + 664;
	// 828418E4: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 828418E8: 3B5F02A0  addi r26, r31, 0x2a0
	ctx.r[26].s64 = ctx.r[31].s64 + 672;
	// 828418EC: 4BFF831D  bl 0x82839c08
	ctx.lr = 0x828418F0;
	sub_82839C08(ctx, base);
	// 828418F0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828418F4: 418200C8  beq 0x828419bc
	if ctx.cr[0].eq {
	pc = 0x828419BC; continue 'dispatch;
	}
	// 828418F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 828418FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841900: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82841904: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82841908: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8284190C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82841910: 481D1D71  bl 0x82a13680
	ctx.lr = 0x82841914;
	sub_82A13680(ctx, base);
	// 82841914: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82841918: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8284191C: 389F0264  addi r4, r31, 0x264
	ctx.r[4].s64 = ctx.r[31].s64 + 612;
	// 82841920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841924: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82841928: 4BFD9431  bl 0x8281ad58
	ctx.lr = 0x8284192C;
	sub_8281AD58(ctx, base);
	// 8284192C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82841930: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82841934: 813F0288  lwz r9, 0x288(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 82841938: 48000014  b 0x8284194c
	pc = 0x8284194C; continue 'dispatch;
	// 8284193C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841940: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82841944: 409A0014  bne cr6, 0x82841958
	if !ctx.cr[6].eq {
	pc = 0x82841958; continue 'dispatch;
	}
	// 82841948: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8284194C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82841950: 409AFFEC  bne cr6, 0x8284193c
	if !ctx.cr[6].eq {
	pc = 0x8284193C; continue 'dispatch;
	}
	// 82841954: 4800000C  b 0x82841960
	pc = 0x82841960; continue 'dispatch;
	// 82841958: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284195C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82841960: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841964: 41820014  beq 0x82841978
	if ctx.cr[0].eq {
	pc = 0x82841978; continue 'dispatch;
	}
	// 82841968: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 8284196C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82841970: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841974: 4BFD918D  bl 0x8281ab00
	ctx.lr = 0x82841978;
	sub_8281AB00(ctx, base);
	// 82841978: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284197C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82841980: 419A0034  beq cr6, 0x828419b4
	if ctx.cr[6].eq {
	pc = 0x828419B4; continue 'dispatch;
	}
	// 82841984: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841988: 481D1CF9  bl 0x82a13680
	ctx.lr = 0x8284198C;
	sub_82A13680(ctx, base);
	// 8284198C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841990: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82841994: 4BFD8FF5  bl 0x8281a988
	ctx.lr = 0x82841998;
	sub_8281A988(ctx, base);
	// 82841998: 38FF029C  addi r7, r31, 0x29c
	ctx.r[7].s64 = ctx.r[31].s64 + 668;
	// 8284199C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 828419A0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 828419A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828419A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828419AC: 4BFFF60D  bl 0x82840fb8
	ctx.lr = 0x828419B0;
	sub_82840FB8(ctx, base);
	// 828419B0: 93BF0288  stw r29, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[29].u32 ) };
	// 828419B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828419B8: 4BC28649  bl 0x8246a000
	ctx.lr = 0x828419BC;
	sub_8246A000(ctx, base);
	// 828419BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828419C0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 828419C4: 489667EC  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828419C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828419C8 size=164
    let mut pc: u32 = 0x828419C8;
    'dispatch: loop {
        match pc {
            0x828419C8 => {
    //   block [0x828419C8..0x82841A6C)
	// 828419C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828419CC: 4896679D  bl 0x831a8168
	ctx.lr = 0x828419D0;
	sub_831A8130(ctx, base);
	// 828419D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828419D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828419D8: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 828419DC: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 828419E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828419E4: 813F0288  lwz r9, 0x288(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(648 as u32) ) } as u64;
	// 828419E8: 48000014  b 0x828419fc
	pc = 0x828419FC; continue 'dispatch;
	// 828419EC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828419F0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828419F4: 409A006C  bne cr6, 0x82841a60
	if !ctx.cr[6].eq {
	pc = 0x82841A60; continue 'dispatch;
	}
	// 828419F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 828419FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82841A00: 409AFFEC  bne cr6, 0x828419ec
	if !ctx.cr[6].eq {
	pc = 0x828419EC; continue 'dispatch;
	}
	// 82841A04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82841A08: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841A0C: 4182004C  beq 0x82841a58
	if ctx.cr[0].eq {
	pc = 0x82841A58; continue 'dispatch;
	}
	// 82841A10: 3BDF0280  addi r30, r31, 0x280
	ctx.r[30].s64 = ctx.r[31].s64 + 640;
	// 82841A14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82841A18: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82841A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841A20: 4BFD90E1  bl 0x8281ab00
	ctx.lr = 0x82841A24;
	sub_8281AB00(ctx, base);
	// 82841A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841A28: 839F0280  lwz r28, 0x280(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(640 as u32) ) } as u64;
	// 82841A2C: 481D1C55  bl 0x82a13680
	ctx.lr = 0x82841A30;
	sub_82A13680(ctx, base);
	// 82841A30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841A34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82841A38: 4BFD8F51  bl 0x8281a988
	ctx.lr = 0x82841A3C;
	sub_8281A988(ctx, base);
	// 82841A3C: 38FF029C  addi r7, r31, 0x29c
	ctx.r[7].s64 = ctx.r[31].s64 + 668;
	// 82841A40: 38DF0298  addi r6, r31, 0x298
	ctx.r[6].s64 = ctx.r[31].s64 + 664;
	// 82841A44: 38BF02A0  addi r5, r31, 0x2a0
	ctx.r[5].s64 = ctx.r[31].s64 + 672;
	// 82841A48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82841A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841A50: 4BFFF569  bl 0x82840fb8
	ctx.lr = 0x82841A54;
	sub_82840FB8(ctx, base);
	// 82841A54: 93BF0288  stw r29, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[29].u32 ) };
	// 82841A58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82841A5C: 4896675C  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
	// 82841A60: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841A64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82841A68: 4BFFFFA0  b 0x82841a08
	pc = 0x82841A08; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82841A70 size=324
    let mut pc: u32 = 0x82841A70;
    'dispatch: loop {
        match pc {
            0x82841A70 => {
    //   block [0x82841A70..0x82841BB4)
	// 82841A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82841A74: 489666F1  bl 0x831a8164
	ctx.lr = 0x82841A78;
	sub_831A8130(ctx, base);
	// 82841A78: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82841A7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82841A80: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82841A84: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82841A88: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82841A8C: 4BAAE74D  bl 0x822f01d8
	ctx.lr = 0x82841A90;
	sub_822F01D8(ctx, base);
	// 82841A90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82841A94: 4BFABD85  bl 0x827ed818
	ctx.lr = 0x82841A98;
	sub_827ED818(ctx, base);
	// 82841A98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841A9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82841AA0: 4BCCDA79  bl 0x8250f518
	ctx.lr = 0x82841AA4;
	sub_8250F518(ctx, base);
	// 82841AA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82841AAC: 386BFF6C  addi r3, r11, -0x94
	ctx.r[3].s64 = ctx.r[11].s64 + -148;
	// 82841AB0: 409A0008  bne cr6, 0x82841ab8
	if !ctx.cr[6].eq {
	pc = 0x82841AB8; continue 'dispatch;
	}
	// 82841AB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82841AB8: 4BCE6589  bl 0x82528040
	ctx.lr = 0x82841ABC;
	sub_82528040(ctx, base);
	// 82841ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82841AC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82841AC4: 485B01CD  bl 0x82df1c90
	ctx.lr = 0x82841AC8;
	sub_82DF1C90(ctx, base);
	// 82841AC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82841ACC: 419A0058  beq cr6, 0x82841b24
	if ctx.cr[6].eq {
	pc = 0x82841B24; continue 'dispatch;
	}
	// 82841AD0: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82841AD4: 3D408335  lis r10, -0x7ccb
	ctx.r[10].s64 = -2093678592;
	// 82841AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841ADC: 80AB6768  lwz r5, 0x6768(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26472 as u32) ) } as u64;
	// 82841AE0: 808A6750  lwz r4, 0x6750(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26448 as u32) ) } as u64;
	// 82841AE4: 4BAB5CBD  bl 0x822f77a0
	ctx.lr = 0x82841AE8;
	sub_822F77A0(ctx, base);
	// 82841AE8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82841AEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82841AF0: 4BAA33D1  bl 0x822e4ec0
	ctx.lr = 0x82841AF4;
	sub_822E4EC0(ctx, base);
	// 82841AF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82841AF8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82841AFC: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 82841B00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82841B04: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82841B08: 4BC4A781  bl 0x8248c288
	ctx.lr = 0x82841B0C;
	sub_8248C288(ctx, base);
	// 82841B0C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82841B10: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82841B14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82841B18: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82841B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841B20: 4BAA9BA1  bl 0x822eb6c0
	ctx.lr = 0x82841B24;
	sub_822EB6C0(ctx, base);
	// 82841B24: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82841B28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82841B2C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82841B30: 4800005C  b 0x82841b8c
	pc = 0x82841B8C; continue 'dispatch;
	// 82841B34: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82841B38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841B3C: 419A000C  beq cr6, 0x82841b48
	if ctx.cr[6].eq {
	pc = 0x82841B48; continue 'dispatch;
	}
	// 82841B40: 4BF98491  bl 0x827d9fd0
	ctx.lr = 0x82841B44;
	sub_827D9FD0(ctx, base);
	// 82841B44: 48000008  b 0x82841b4c
	pc = 0x82841B4C; continue 'dispatch;
	// 82841B48: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82841B4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82841B50: 419A0010  beq cr6, 0x82841b60
	if ctx.cr[6].eq {
	pc = 0x82841B60; continue 'dispatch;
	}
	// 82841B54: 487C7465  bl 0x83008fb8
	ctx.lr = 0x82841B58;
	sub_83008FB8(ctx, base);
	// 82841B58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82841B5C: 48000008  b 0x82841b64
	pc = 0x82841B64; continue 'dispatch;
	// 82841B60: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82841B64: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82841B68: 419A0014  beq cr6, 0x82841b7c
	if ctx.cr[6].eq {
	pc = 0x82841B7C; continue 'dispatch;
	}
	// 82841B6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82841B70: 4BFABCB1  bl 0x827ed820
	ctx.lr = 0x82841B74;
	sub_827ED820(ctx, base);
	// 82841B74: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82841B78: 409A0024  bne cr6, 0x82841b9c
	if !ctx.cr[6].eq {
	pc = 0x82841B9C; continue 'dispatch;
	}
	// 82841B7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82841B80: 4BCA7679  bl 0x824e91f8
	ctx.lr = 0x82841B84;
	sub_824E91F8(ctx, base);
	// 82841B84: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82841B88: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82841B8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82841B90: 409AFFA4  bne cr6, 0x82841b34
	if !ctx.cr[6].eq {
	pc = 0x82841B34; continue 'dispatch;
	}
	// 82841B94: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82841B98: 48000008  b 0x82841ba0
	pc = 0x82841BA0; continue 'dispatch;
	// 82841B9C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82841BA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82841BA4: 4BAAEE75  bl 0x822f0a18
	ctx.lr = 0x82841BA8;
	sub_822F0A18(ctx, base);
	// 82841BA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841BAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82841BB0: 48966604  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82841BB8 size=1060
    let mut pc: u32 = 0x82841BB8;
    'dispatch: loop {
        match pc {
            0x82841BB8 => {
    //   block [0x82841BB8..0x82841FDC)
	// 82841BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82841BBC: 489665AD  bl 0x831a8168
	ctx.lr = 0x82841BC0;
	sub_831A8130(ctx, base);
	// 82841BC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82841BC4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82841BC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82841BCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82841BD0: 579D063F  clrlwi. r29, r28, 0x18
	ctx.r[29].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82841BD4: 40820038  bne 0x82841c0c
	if !ctx.cr[0].eq {
	pc = 0x82841C0C; continue 'dispatch;
	}
	// 82841BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841BDC: 48967DAD  bl 0x831a9988
	ctx.lr = 0x82841BE0;
	sub_831A9988(ctx, base);
	// 82841BE0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841BE4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841BE8: 386B26B0  addi r3, r11, 0x26b0
	ctx.r[3].s64 = ctx.r[11].s64 + 9904;
	// 82841BEC: 4896650D  bl 0x831a80f8
	ctx.lr = 0x82841BF0;
	sub_831A80F8(ctx, base);
	// 82841BF0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841BF4: 41820018  beq 0x82841c0c
	if ctx.cr[0].eq {
	pc = 0x82841C0C; continue 'dispatch;
	}
	// 82841BF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841BFC: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841C00: 4BFF8201  bl 0x82839e00
	ctx.lr = 0x82841C04;
	sub_82839E00(ctx, base);
	// 82841C04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82841C08: 480003CC  b 0x82841fd4
	pc = 0x82841FD4; continue 'dispatch;
	// 82841C0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841C10: 409A00AC  bne cr6, 0x82841cbc
	if !ctx.cr[6].eq {
	pc = 0x82841CBC; continue 'dispatch;
	}
	// 82841C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841C18: 48967D71  bl 0x831a9988
	ctx.lr = 0x82841C1C;
	sub_831A9988(ctx, base);
	// 82841C1C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841C20: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841C24: 386B2678  addi r3, r11, 0x2678
	ctx.r[3].s64 = ctx.r[11].s64 + 9848;
	// 82841C28: 489664D1  bl 0x831a80f8
	ctx.lr = 0x82841C2C;
	sub_831A80F8(ctx, base);
	// 82841C2C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841C30: 41820014  beq 0x82841c44
	if ctx.cr[0].eq {
	pc = 0x82841C44; continue 'dispatch;
	}
	// 82841C34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841C38: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841C3C: 4BFFF7DD  bl 0x82841418
	ctx.lr = 0x82841C40;
	sub_82841418(ctx, base);
	// 82841C40: 4BFFFFC4  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841C44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841C48: 409A0074  bne cr6, 0x82841cbc
	if !ctx.cr[6].eq {
	pc = 0x82841CBC; continue 'dispatch;
	}
	// 82841C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841C50: 48967D39  bl 0x831a9988
	ctx.lr = 0x82841C54;
	sub_831A9988(ctx, base);
	// 82841C54: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841C58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841C5C: 386B263C  addi r3, r11, 0x263c
	ctx.r[3].s64 = ctx.r[11].s64 + 9788;
	// 82841C60: 48966499  bl 0x831a80f8
	ctx.lr = 0x82841C64;
	sub_831A80F8(ctx, base);
	// 82841C64: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841C68: 41820014  beq 0x82841c7c
	if ctx.cr[0].eq {
	pc = 0x82841C7C; continue 'dispatch;
	}
	// 82841C6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841C70: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841C74: 4BFFF8ED  bl 0x82841560
	ctx.lr = 0x82841C78;
	sub_82841560(ctx, base);
	// 82841C78: 4BFFFF8C  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841C7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841C80: 409A003C  bne cr6, 0x82841cbc
	if !ctx.cr[6].eq {
	pc = 0x82841CBC; continue 'dispatch;
	}
	// 82841C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841C88: 48967D01  bl 0x831a9988
	ctx.lr = 0x82841C8C;
	sub_831A9988(ctx, base);
	// 82841C8C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841C90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841C94: 386B2604  addi r3, r11, 0x2604
	ctx.r[3].s64 = ctx.r[11].s64 + 9732;
	// 82841C98: 48966461  bl 0x831a80f8
	ctx.lr = 0x82841C9C;
	sub_831A80F8(ctx, base);
	// 82841C9C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841CA0: 41820014  beq 0x82841cb4
	if ctx.cr[0].eq {
	pc = 0x82841CB4; continue 'dispatch;
	}
	// 82841CA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841CA8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841CAC: 4BFFE07D  bl 0x8283fd28
	ctx.lr = 0x82841CB0;
	sub_8283FD28(ctx, base);
	// 82841CB0: 4BFFFF54  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841CB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841CB8: 419A030C  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841CC0: 48967CC9  bl 0x831a9988
	ctx.lr = 0x82841CC4;
	sub_831A9988(ctx, base);
	// 82841CC4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841CC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841CCC: 386B25D0  addi r3, r11, 0x25d0
	ctx.r[3].s64 = ctx.r[11].s64 + 9680;
	// 82841CD0: 48966429  bl 0x831a80f8
	ctx.lr = 0x82841CD4;
	sub_831A80F8(ctx, base);
	// 82841CD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841CD8: 41820014  beq 0x82841cec
	if ctx.cr[0].eq {
	pc = 0x82841CEC; continue 'dispatch;
	}
	// 82841CDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841CE0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841CE4: 4BFFDE15  bl 0x8283faf8
	ctx.lr = 0x82841CE8;
	sub_8283FAF8(ctx, base);
	// 82841CE8: 4BFFFF1C  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841CEC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841CF0: 419A02D4  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841CF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841CF8: 48967C91  bl 0x831a9988
	ctx.lr = 0x82841CFC;
	sub_831A9988(ctx, base);
	// 82841CFC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841D00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841D04: 386B259C  addi r3, r11, 0x259c
	ctx.r[3].s64 = ctx.r[11].s64 + 9628;
	// 82841D08: 489663F1  bl 0x831a80f8
	ctx.lr = 0x82841D0C;
	sub_831A80F8(ctx, base);
	// 82841D0C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841D10: 41820014  beq 0x82841d24
	if ctx.cr[0].eq {
	pc = 0x82841D24; continue 'dispatch;
	}
	// 82841D14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841D18: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841D1C: 4BFF80D5  bl 0x82839df0
	ctx.lr = 0x82841D20;
	sub_82839DF0(ctx, base);
	// 82841D20: 4BFFFEE4  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841D24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841D28: 419A029C  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841D30: 48967C59  bl 0x831a9988
	ctx.lr = 0x82841D34;
	sub_831A9988(ctx, base);
	// 82841D34: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841D38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841D3C: 386B2568  addi r3, r11, 0x2568
	ctx.r[3].s64 = ctx.r[11].s64 + 9576;
	// 82841D40: 489663B9  bl 0x831a80f8
	ctx.lr = 0x82841D44;
	sub_831A80F8(ctx, base);
	// 82841D44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841D48: 41820014  beq 0x82841d5c
	if ctx.cr[0].eq {
	pc = 0x82841D5C; continue 'dispatch;
	}
	// 82841D4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841D50: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841D54: 4BFF80BD  bl 0x82839e10
	ctx.lr = 0x82841D58;
	sub_82839E10(ctx, base);
	// 82841D58: 4BFFFEAC  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841D5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841D60: 419A0264  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841D68: 48967C21  bl 0x831a9988
	ctx.lr = 0x82841D6C;
	sub_831A9988(ctx, base);
	// 82841D6C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841D70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841D74: 386B2530  addi r3, r11, 0x2530
	ctx.r[3].s64 = ctx.r[11].s64 + 9520;
	// 82841D78: 48966381  bl 0x831a80f8
	ctx.lr = 0x82841D7C;
	sub_831A80F8(ctx, base);
	// 82841D7C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841D80: 41820014  beq 0x82841d94
	if ctx.cr[0].eq {
	pc = 0x82841D94; continue 'dispatch;
	}
	// 82841D84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841D88: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841D8C: 4BFFC21D  bl 0x8283dfa8
	ctx.lr = 0x82841D90;
	sub_8283DFA8(ctx, base);
	// 82841D90: 4BFFFE74  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841D94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841D98: 419A022C  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841DA0: 48967BE9  bl 0x831a9988
	ctx.lr = 0x82841DA4;
	sub_831A9988(ctx, base);
	// 82841DA4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841DA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841DAC: 386B24F8  addi r3, r11, 0x24f8
	ctx.r[3].s64 = ctx.r[11].s64 + 9464;
	// 82841DB0: 48966349  bl 0x831a80f8
	ctx.lr = 0x82841DB4;
	sub_831A80F8(ctx, base);
	// 82841DB4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841DB8: 41820014  beq 0x82841dcc
	if ctx.cr[0].eq {
	pc = 0x82841DCC; continue 'dispatch;
	}
	// 82841DBC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841DC0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841DC4: 4BFF89AD  bl 0x8283a770
	ctx.lr = 0x82841DC8;
	sub_8283A770(ctx, base);
	// 82841DC8: 4BFFFE3C  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841DCC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841DD0: 419A01F4  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841DD8: 48967BB1  bl 0x831a9988
	ctx.lr = 0x82841DDC;
	sub_831A9988(ctx, base);
	// 82841DDC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841DE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841DE4: 386B24BC  addi r3, r11, 0x24bc
	ctx.r[3].s64 = ctx.r[11].s64 + 9404;
	// 82841DE8: 48966311  bl 0x831a80f8
	ctx.lr = 0x82841DEC;
	sub_831A80F8(ctx, base);
	// 82841DEC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841DF0: 41820014  beq 0x82841e04
	if ctx.cr[0].eq {
	pc = 0x82841E04; continue 'dispatch;
	}
	// 82841DF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841DF8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841DFC: 4BFFFBCD  bl 0x828419c8
	ctx.lr = 0x82841E00;
	sub_828419C8(ctx, base);
	// 82841E00: 4BFFFE04  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841E04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841E08: 419A01BC  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841E10: 48967B79  bl 0x831a9988
	ctx.lr = 0x82841E14;
	sub_831A9988(ctx, base);
	// 82841E14: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841E18: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841E1C: 386B2488  addi r3, r11, 0x2488
	ctx.r[3].s64 = ctx.r[11].s64 + 9352;
	// 82841E20: 489662D9  bl 0x831a80f8
	ctx.lr = 0x82841E24;
	sub_831A80F8(ctx, base);
	// 82841E24: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841E28: 41820014  beq 0x82841e3c
	if ctx.cr[0].eq {
	pc = 0x82841E3C; continue 'dispatch;
	}
	// 82841E2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841E30: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841E34: 4BFF7FED  bl 0x82839e20
	ctx.lr = 0x82841E38;
	sub_82839E20(ctx, base);
	// 82841E38: 4BFFFDCC  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841E3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841E40: 419A0184  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841E48: 48967B41  bl 0x831a9988
	ctx.lr = 0x82841E4C;
	sub_831A9988(ctx, base);
	// 82841E4C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841E50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841E54: 386B2454  addi r3, r11, 0x2454
	ctx.r[3].s64 = ctx.r[11].s64 + 9300;
	// 82841E58: 489662A1  bl 0x831a80f8
	ctx.lr = 0x82841E5C;
	sub_831A80F8(ctx, base);
	// 82841E5C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841E60: 41820014  beq 0x82841e74
	if ctx.cr[0].eq {
	pc = 0x82841E74; continue 'dispatch;
	}
	// 82841E64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841E68: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841E6C: 4BFF7FD5  bl 0x82839e40
	ctx.lr = 0x82841E70;
	sub_82839E40(ctx, base);
	// 82841E70: 4BFFFD94  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841E74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841E78: 419A014C  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841E7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841E80: 48967B09  bl 0x831a9988
	ctx.lr = 0x82841E84;
	sub_831A9988(ctx, base);
	// 82841E84: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841E88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841E8C: 386B2420  addi r3, r11, 0x2420
	ctx.r[3].s64 = ctx.r[11].s64 + 9248;
	// 82841E90: 48966269  bl 0x831a80f8
	ctx.lr = 0x82841E94;
	sub_831A80F8(ctx, base);
	// 82841E94: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841E98: 41820014  beq 0x82841eac
	if ctx.cr[0].eq {
	pc = 0x82841EAC; continue 'dispatch;
	}
	// 82841E9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841EA0: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841EA4: 4BFFC24D  bl 0x8283e0f0
	ctx.lr = 0x82841EA8;
	sub_8283E0F0(ctx, base);
	// 82841EA8: 4BFFFD5C  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841EAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841EB0: 419A0114  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841EB8: 48967AD1  bl 0x831a9988
	ctx.lr = 0x82841EBC;
	sub_831A9988(ctx, base);
	// 82841EBC: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841EC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841EC4: 386B23F0  addi r3, r11, 0x23f0
	ctx.r[3].s64 = ctx.r[11].s64 + 9200;
	// 82841EC8: 48966231  bl 0x831a80f8
	ctx.lr = 0x82841ECC;
	sub_831A80F8(ctx, base);
	// 82841ECC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841ED0: 41820014  beq 0x82841ee4
	if ctx.cr[0].eq {
	pc = 0x82841EE4; continue 'dispatch;
	}
	// 82841ED4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841ED8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841EDC: 4BFFC3DD  bl 0x8283e2b8
	ctx.lr = 0x82841EE0;
	sub_8283E2B8(ctx, base);
	// 82841EE0: 4BFFFD24  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841EE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841EE8: 419A00DC  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841EF0: 48967A99  bl 0x831a9988
	ctx.lr = 0x82841EF4;
	sub_831A9988(ctx, base);
	// 82841EF4: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82841EF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841EFC: 386B5C00  addi r3, r11, 0x5c00
	ctx.r[3].s64 = ctx.r[11].s64 + 23552;
	// 82841F00: 489661F9  bl 0x831a80f8
	ctx.lr = 0x82841F04;
	sub_831A80F8(ctx, base);
	// 82841F04: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841F08: 41820014  beq 0x82841f1c
	if ctx.cr[0].eq {
	pc = 0x82841F1C; continue 'dispatch;
	}
	// 82841F0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841F10: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841F14: 4BFF8875  bl 0x8283a788
	ctx.lr = 0x82841F18;
	sub_8283A788(ctx, base);
	// 82841F18: 4BFFFCEC  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841F1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841F20: 419A00A4  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841F28: 48967A61  bl 0x831a9988
	ctx.lr = 0x82841F2C;
	sub_831A9988(ctx, base);
	// 82841F2C: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82841F30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841F34: 386B59D8  addi r3, r11, 0x59d8
	ctx.r[3].s64 = ctx.r[11].s64 + 23000;
	// 82841F38: 489661C1  bl 0x831a80f8
	ctx.lr = 0x82841F3C;
	sub_831A80F8(ctx, base);
	// 82841F3C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841F40: 41820014  beq 0x82841f54
	if ctx.cr[0].eq {
	pc = 0x82841F54; continue 'dispatch;
	}
	// 82841F44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841F48: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841F4C: 4BF8D28D  bl 0x827cf1d8
	ctx.lr = 0x82841F50;
	sub_827CF1D8(ctx, base);
	// 82841F50: 48000084  b 0x82841fd4
	pc = 0x82841FD4; continue 'dispatch;
	// 82841F54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841F58: 419A006C  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841F60: 48967A29  bl 0x831a9988
	ctx.lr = 0x82841F64;
	sub_831A9988(ctx, base);
	// 82841F64: 3D608326  lis r11, -0x7cda
	ctx.r[11].s64 = -2094661632;
	// 82841F68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841F6C: 386B3984  addi r3, r11, 0x3984
	ctx.r[3].s64 = ctx.r[11].s64 + 14724;
	// 82841F70: 48966189  bl 0x831a80f8
	ctx.lr = 0x82841F74;
	sub_831A80F8(ctx, base);
	// 82841F74: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841F78: 41820014  beq 0x82841f8c
	if ctx.cr[0].eq {
	pc = 0x82841F8C; continue 'dispatch;
	}
	// 82841F7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841F80: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841F84: 4BFFAE2D  bl 0x8283cdb0
	ctx.lr = 0x82841F88;
	sub_8283CDB0(ctx, base);
	// 82841F88: 4BFFFC7C  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841F8C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82841F90: 419A0034  beq cr6, 0x82841fc4
	if ctx.cr[6].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841F94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82841F98: 489679F1  bl 0x831a9988
	ctx.lr = 0x82841F9C;
	sub_831A9988(ctx, base);
	// 82841F9C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82841FA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82841FA4: 386BDBD4  addi r3, r11, -0x242c
	ctx.r[3].s64 = ctx.r[11].s64 + -9260;
	// 82841FA8: 48966151  bl 0x831a80f8
	ctx.lr = 0x82841FAC;
	sub_831A80F8(ctx, base);
	// 82841FAC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82841FB0: 41820014  beq 0x82841fc4
	if ctx.cr[0].eq {
	pc = 0x82841FC4; continue 'dispatch;
	}
	// 82841FB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841FB8: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82841FBC: 4BFFDE6D  bl 0x8283fe28
	ctx.lr = 0x82841FC0;
	sub_8283FE28(ctx, base);
	// 82841FC0: 4BFFFC44  b 0x82841c04
	pc = 0x82841C04; continue 'dispatch;
	// 82841FC4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82841FC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82841FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82841FD0: 4BFD7861  bl 0x82819830
	ctx.lr = 0x82841FD4;
	sub_82819830(ctx, base);
	// 82841FD4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82841FD8: 489661E0  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82841FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82841FE0 size=412
    let mut pc: u32 = 0x82841FE0;
    'dispatch: loop {
        match pc {
            0x82841FE0 => {
    //   block [0x82841FE0..0x8284217C)
	// 82841FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82841FE4: 48966171  bl 0x831a8154
	ctx.lr = 0x82841FE8;
	sub_831A8130(ctx, base);
	// 82841FE8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82841FEC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82841FF0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82841FF4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82841FF8: 3BABBA80  addi r29, r11, -0x4580
	ctx.r[29].s64 = ctx.r[11].s64 + -17792;
	// 82841FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82842000: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82842004: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82842008: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 8284200C: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82842010: 4BFD60D9  bl 0x828180e8
	ctx.lr = 0x82842014;
	sub_828180E8(ctx, base);
	// 82842014: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842018: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8284201C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82842020: 396BD28C  addi r11, r11, -0x2d74
	ctx.r[11].s64 = ctx.r[11].s64 + -11636;
	// 82842024: 394AD278  addi r10, r10, -0x2d88
	ctx.r[10].s64 = ctx.r[10].s64 + -11656;
	// 82842028: 3929D22C  addi r9, r9, -0x2dd4
	ctx.r[9].s64 = ctx.r[9].s64 + -11732;
	// 8284202C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842030: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82842034: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842038: 913F0208  stw r9, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[9].u32 ) };
	// 8284203C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82842040: 388BD108  addi r4, r11, -0x2ef8
	ctx.r[4].s64 = ctx.r[11].s64 + -12024;
	// 82842044: 38A00086  li r5, 0x86
	ctx.r[5].s64 = 134;
	// 82842048: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8284204C: 485B039D  bl 0x82df23e8
	ctx.lr = 0x82842050;
	sub_82DF23E8(ctx, base);
	// 82842050: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82842054: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842058: 41820018  beq 0x82842070
	if ctx.cr[0].eq {
	pc = 0x82842070; continue 'dispatch;
	}
	// 8284205C: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 82842060: 388B6880  addi r4, r11, 0x6880
	ctx.r[4].s64 = ctx.r[11].s64 + 26752;
	// 82842064: 485D108D  bl 0x82e130f0
	ctx.lr = 0x82842068;
	sub_82E130F0(ctx, base);
	// 82842068: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8284206C: 48000008  b 0x82842074
	pc = 0x82842074; continue 'dispatch;
	// 82842070: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82842074: 939F0254  stw r28, 0x254(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(596 as u32), ctx.r[28].u32 ) };
	// 82842078: 397F0254  addi r11, r31, 0x254
	ctx.r[11].s64 = ctx.r[31].s64 + 596;
	// 8284207C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82842080: 3B6B0004  addi r27, r11, 4
	ctx.r[27].s64 = ctx.r[11].s64 + 4;
	// 82842084: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82842088: 4BA9EF91  bl 0x822e1018
	ctx.lr = 0x8284208C;
	sub_822E1018(ctx, base);
	// 8284208C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82842090: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82842094: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82842098: 4BA7DF69  bl 0x822c0000
	ctx.lr = 0x8284209C;
	sub_822C0000(ctx, base);
	// 8284209C: 93DF025C  stw r30, 0x25c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(604 as u32), ctx.r[30].u32 ) };
	// 828420A0: 93DF0260  stw r30, 0x260(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(608 as u32), ctx.r[30].u32 ) };
	// 828420A4: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828420A8: 93DF0264  stw r30, 0x264(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
	// 828420AC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828420B0: 93DF0268  stw r30, 0x268(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(616 as u32), ctx.r[30].u32 ) };
	// 828420B4: 392B36FC  addi r9, r11, 0x36fc
	ctx.r[9].s64 = ctx.r[11].s64 + 14076;
	// 828420B8: 93DF0270  stw r30, 0x270(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(624 as u32), ctx.r[30].u32 ) };
	// 828420BC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 828420C0: 93DF0274  stw r30, 0x274(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(628 as u32), ctx.r[30].u32 ) };
	// 828420C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828420C8: 93DF0278  stw r30, 0x278(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(632 as u32), ctx.r[30].u32 ) };
	// 828420CC: 387F02B0  addi r3, r31, 0x2b0
	ctx.r[3].s64 = ctx.r[31].s64 + 688;
	// 828420D0: 93DF027C  stw r30, 0x27c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(636 as u32), ctx.r[30].u32 ) };
	// 828420D4: C00ACA7C  lfs f0, -0x3584(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-13700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828420D8: 93DF0280  stw r30, 0x280(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(640 as u32), ctx.r[30].u32 ) };
	// 828420DC: 93DF0284  stw r30, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[30].u32 ) };
	// 828420E0: C3E808A4  lfs f31, 0x8a4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2212 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 828420E4: 931F0288  stw r24, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[24].u32 ) };
	// 828420E8: 816B36FC  lwz r11, 0x36fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(14076 as u32) ) } as u64;
	// 828420EC: 917F028C  stw r11, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[11].u32 ) };
	// 828420F0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828420F4: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 828420F8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828420FC: D01F0298  stfs f0, 0x298(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(664 as u32), tmp.u32 ) };
	// 82842100: D3FF029C  stfs f31, 0x29c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(668 as u32), tmp.u32 ) };
	// 82842104: 917F0294  stw r11, 0x294(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(660 as u32), ctx.r[11].u32 ) };
	// 82842108: 92FF02A0  stw r23, 0x2a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(672 as u32), ctx.r[23].u32 ) };
	// 8284210C: 93DF02A4  stw r30, 0x2a4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(676 as u32), ctx.r[30].u32 ) };
	// 82842110: 933F02A8  stw r25, 0x2a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(680 as u32), ctx.r[25].u32 ) };
	// 82842114: 4BFFF66D  bl 0x82841780
	ctx.lr = 0x82842118;
	sub_82841780(ctx, base);
	// 82842118: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8284211C: D01F0300  stfs f0, 0x300(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(768 as u32), tmp.u32 ) };
	// 82842120: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82842124: 3D408338  lis r10, -0x7cc8
	ctx.r[10].s64 = -2093481984;
	// 82842128: 39200330  li r9, 0x330
	ctx.r[9].s64 = 816;
	// 8284212C: 394A6910  addi r10, r10, 0x6910
	ctx.r[10].s64 = ctx.r[10].s64 + 26896;
	// 82842130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842134: C1AB08A8  lfs f13, 0x8a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2216 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82842138: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8284213C: D01F0304  stfs f0, 0x304(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(772 as u32), tmp.u32 ) };
	// 82842140: C01D0008  lfs f0, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82842144: D01F0308  stfs f0, 0x308(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(776 as u32), tmp.u32 ) };
	// 82842148: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8284214C: D01F030C  stfs f0, 0x30c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(780 as u32), tmp.u32 ) };
	// 82842150: D1BF0310  stfs f13, 0x310(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(784 as u32), tmp.u32 ) };
	// 82842154: 93DF0314  stw r30, 0x314(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(788 as u32), ctx.r[30].u32 ) };
	// 82842158: 93DF0318  stw r30, 0x318(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(792 as u32), ctx.r[30].u32 ) };
	// 8284215C: D3FF031C  stfs f31, 0x31c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(796 as u32), tmp.u32 ) };
	// 82842160: 93DF0320  stw r30, 0x320(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(800 as u32), ctx.r[30].u32 ) };
	// 82842164: 93DF0324  stw r30, 0x324(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(804 as u32), ctx.r[30].u32 ) };
	// 82842168: 13E050C7  vcmpequd (lvx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82842180 size=328
    let mut pc: u32 = 0x82842180;
    'dispatch: loop {
        match pc {
            0x82842180 => {
    //   block [0x82842180..0x828422C8)
	// 82842180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842184: 48965FDD  bl 0x831a8160
	ctx.lr = 0x82842188;
	sub_831A8130(ctx, base);
	// 82842188: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8284218C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842190: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82842194: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82842198: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 8284219C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828421A0: 3B6BB5C0  addi r27, r11, -0x4a40
	ctx.r[27].s64 = ctx.r[11].s64 + -19008;
	// 828421A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828421A8: 816AB5D0  lwz r11, -0x4a30(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18992 as u32) ) } as u64;
	// 828421AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828421B0: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 828421B4: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 828421B8: 4082001C  bne 0x828421d4
	if !ctx.cr[0].eq {
	pc = 0x828421D4; continue 'dispatch;
	}
	// 828421BC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 828421C0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 828421C4: 392928F0  addi r9, r9, 0x28f0
	ctx.r[9].s64 = ctx.r[9].s64 + 10480;
	// 828421C8: 916AB5D0  stw r11, -0x4a30(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18992 as u32), ctx.r[11].u32 ) };
	// 828421CC: 13E048C7  vcmpequd (lvx128) v31, v0, v9
	tmp.u32 = ctx.r[9].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828422C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828422C8 size=512
    let mut pc: u32 = 0x828422C8;
    'dispatch: loop {
        match pc {
            0x828422C8 => {
    //   block [0x828422C8..0x828424C8)
	// 828422C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828422CC: 48965E9D  bl 0x831a8168
	ctx.lr = 0x828422D0;
	sub_831A8130(ctx, base);
	// 828422D0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 828422D4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828424C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828424C8 size=80
    let mut pc: u32 = 0x828424C8;
    'dispatch: loop {
        match pc {
            0x828424C8 => {
    //   block [0x828424C8..0x82842518)
	// 828424C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828424CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828424D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828424D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828424D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828424DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828424E0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 828424E4: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828424E8: 487C5C41  bl 0x83008128
	ctx.lr = 0x828424EC;
	sub_83008128(ctx, base);
	// 828424EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828424F0: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 828424F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828424F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828424FC: 4E800421  bctrl
	ctx.lr = 0x82842500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842500: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8284250C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842510: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842518 size=164
    let mut pc: u32 = 0x82842518;
    'dispatch: loop {
        match pc {
            0x82842518 => {
    //   block [0x82842518..0x828425BC)
	// 82842518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284251C: 48965C4D  bl 0x831a8168
	ctx.lr = 0x82842520;
	sub_831A8130(ctx, base);
	// 82842520: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842524: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82842528: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8284252C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842530: 57BC063F  clrlwi. r28, r29, 0x18
	ctx.r[28].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82842534: 40820038  bne 0x8284256c
	if !ctx.cr[0].eq {
	pc = 0x8284256C; continue 'dispatch;
	}
	// 82842538: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284253C: 4896744D  bl 0x831a9988
	ctx.lr = 0x82842540;
	sub_831A9988(ctx, base);
	// 82842540: 3D608325  lis r11, -0x7cdb
	ctx.r[11].s64 = -2094727168;
	// 82842544: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82842548: 386B3644  addi r3, r11, 0x3644
	ctx.r[3].s64 = ctx.r[11].s64 + 13892;
	// 8284254C: 48965BAD  bl 0x831a80f8
	ctx.lr = 0x82842550;
	sub_831A80F8(ctx, base);
	// 82842550: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82842554: 41820018  beq 0x8284256c
	if ctx.cr[0].eq {
	pc = 0x8284256C; continue 'dispatch;
	}
	// 82842558: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8284255C: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 82842560: 4BFFFF69  bl 0x828424c8
	ctx.lr = 0x82842564;
	sub_828424C8(ctx, base);
	// 82842564: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82842568: 4800004C  b 0x828425b4
	pc = 0x828425B4; continue 'dispatch;
	// 8284256C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82842570: 419A0034  beq cr6, 0x828425a4
	if ctx.cr[6].eq {
	pc = 0x828425A4; continue 'dispatch;
	}
	// 82842574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842578: 48967411  bl 0x831a9988
	ctx.lr = 0x8284257C;
	sub_831A9988(ctx, base);
	// 8284257C: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82842580: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82842584: 386BC8E4  addi r3, r11, -0x371c
	ctx.r[3].s64 = ctx.r[11].s64 + -14108;
	// 82842588: 48965B71  bl 0x831a80f8
	ctx.lr = 0x8284258C;
	sub_831A80F8(ctx, base);
	// 8284258C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82842590: 41820014  beq 0x828425a4
	if ctx.cr[0].eq {
	pc = 0x828425A4; continue 'dispatch;
	}
	// 82842594: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82842598: 387EFFD8  addi r3, r30, -0x28
	ctx.r[3].s64 = ctx.r[30].s64 + -40;
	// 8284259C: 4BE28755  bl 0x8266acf0
	ctx.lr = 0x828425A0;
	sub_8266ACF0(ctx, base);
	// 828425A0: 4BFFFFC4  b 0x82842564
	pc = 0x82842564; continue 'dispatch;
	// 828425A4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828425A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828425AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828425B0: 4BE54C51  bl 0x82697200
	ctx.lr = 0x828425B4;
	sub_82697200(ctx, base);
	// 828425B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828425B8: 48965C00  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828425C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828425C0 size=196
    let mut pc: u32 = 0x828425C0;
    'dispatch: loop {
        match pc {
            0x828425C0 => {
    //   block [0x828425C0..0x82842684)
	// 828425C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828425C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828425C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828425CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828425D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828425D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828425D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828425DC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828425E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828425E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828425E8: 4BA7E351  bl 0x822c0938
	ctx.lr = 0x828425EC;
	sub_822C0938(ctx, base);
	// 828425EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828425F0: 41820028  beq 0x82842618
	if ctx.cr[0].eq {
	pc = 0x82842618; continue 'dispatch;
	}
	// 828425F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828425F8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828425FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842600: 392BD3C8  addi r9, r11, -0x2c38
	ctx.r[9].s64 = ctx.r[11].s64 + -11320;
	// 82842604: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842608: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8284260C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842610: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842614: 48000008  b 0x8284261c
	pc = 0x8284261C; continue 'dispatch;
	// 82842618: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8284261C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842624: 409A0044  bne cr6, 0x82842668
	if !ctx.cr[6].eq {
	pc = 0x82842668; continue 'dispatch;
	}
	// 82842628: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8284262C: 419A001C  beq cr6, 0x82842648
	if ctx.cr[6].eq {
	pc = 0x82842648; continue 'dispatch;
	}
	// 82842630: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842634: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284263C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842640: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842644: 4E800421  bctrl
	ctx.lr = 0x82842648;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842648: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8284264C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842654: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842658: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 8284265C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842660: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842664: 4BA7D99D  bl 0x822c0000
	ctx.lr = 0x82842668;
	sub_822C0000(ctx, base);
	// 82842668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284266C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842678: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284267C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842680: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842688 size=196
    let mut pc: u32 = 0x82842688;
    'dispatch: loop {
        match pc {
            0x82842688 => {
    //   block [0x82842688..0x8284274C)
	// 82842688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284268C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284269C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828426A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828426A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828426A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828426AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828426B0: 4BA7E289  bl 0x822c0938
	ctx.lr = 0x828426B4;
	sub_822C0938(ctx, base);
	// 828426B4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828426B8: 41820028  beq 0x828426e0
	if ctx.cr[0].eq {
	pc = 0x828426E0; continue 'dispatch;
	}
	// 828426BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828426C0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828426C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828426C8: 392BD3DC  addi r9, r11, -0x2c24
	ctx.r[9].s64 = ctx.r[11].s64 + -11300;
	// 828426CC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828426D0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828426D4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828426D8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828426DC: 48000008  b 0x828426e4
	pc = 0x828426E4; continue 'dispatch;
	// 828426E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828426E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828426E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828426EC: 409A0044  bne cr6, 0x82842730
	if !ctx.cr[6].eq {
	pc = 0x82842730; continue 'dispatch;
	}
	// 828426F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828426F4: 419A001C  beq cr6, 0x82842710
	if ctx.cr[6].eq {
	pc = 0x82842710; continue 'dispatch;
	}
	// 828426F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828426FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842704: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8284270C: 4E800421  bctrl
	ctx.lr = 0x82842710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842710: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842714: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284271C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842720: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842724: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842728: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8284272C: 4BA7D8D5  bl 0x822c0000
	ctx.lr = 0x82842730;
	sub_822C0000(ctx, base);
	// 82842730: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842734: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842738: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8284273C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842740: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842744: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842750 size=196
    let mut pc: u32 = 0x82842750;
    'dispatch: loop {
        match pc {
            0x82842750 => {
    //   block [0x82842750..0x82842814)
	// 82842750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8284275C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842764: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8284276C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842770: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842774: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842778: 4BA7E1C1  bl 0x822c0938
	ctx.lr = 0x8284277C;
	sub_822C0938(ctx, base);
	// 8284277C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842780: 41820028  beq 0x828427a8
	if ctx.cr[0].eq {
	pc = 0x828427A8; continue 'dispatch;
	}
	// 82842784: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842788: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8284278C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842790: 392BD3F0  addi r9, r11, -0x2c10
	ctx.r[9].s64 = ctx.r[11].s64 + -11280;
	// 82842794: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842798: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8284279C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828427A0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828427A4: 48000008  b 0x828427ac
	pc = 0x828427AC; continue 'dispatch;
	// 828427A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828427AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828427B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828427B4: 409A0044  bne cr6, 0x828427f8
	if !ctx.cr[6].eq {
	pc = 0x828427F8; continue 'dispatch;
	}
	// 828427B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828427BC: 419A001C  beq cr6, 0x828427d8
	if ctx.cr[6].eq {
	pc = 0x828427D8; continue 'dispatch;
	}
	// 828427C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828427C4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 828427C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828427CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828427D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828427D4: 4E800421  bctrl
	ctx.lr = 0x828427D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828427D8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828427DC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828427E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828427E4: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828427E8: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 828427EC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828427F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828427F4: 4BA7D80D  bl 0x822c0000
	ctx.lr = 0x828427F8;
	sub_822C0000(ctx, base);
	// 828427F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828427FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284280C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842818 size=196
    let mut pc: u32 = 0x82842818;
    'dispatch: loop {
        match pc {
            0x82842818 => {
    //   block [0x82842818..0x828428DC)
	// 82842818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284281C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284282C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842830: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842834: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842838: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8284283C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842840: 4BA7E0F9  bl 0x822c0938
	ctx.lr = 0x82842844;
	sub_822C0938(ctx, base);
	// 82842844: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842848: 41820028  beq 0x82842870
	if ctx.cr[0].eq {
	pc = 0x82842870; continue 'dispatch;
	}
	// 8284284C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842850: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82842854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842858: 392BD404  addi r9, r11, -0x2bfc
	ctx.r[9].s64 = ctx.r[11].s64 + -11260;
	// 8284285C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842860: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82842864: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842868: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8284286C: 48000008  b 0x82842874
	pc = 0x82842874; continue 'dispatch;
	// 82842870: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842874: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284287C: 409A0044  bne cr6, 0x828428c0
	if !ctx.cr[6].eq {
	pc = 0x828428C0; continue 'dispatch;
	}
	// 82842880: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842884: 419A001C  beq cr6, 0x828428a0
	if ctx.cr[6].eq {
	pc = 0x828428A0; continue 'dispatch;
	}
	// 82842888: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284288C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842894: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8284289C: 4E800421  bctrl
	ctx.lr = 0x828428A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828428A0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 828428A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 828428A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828428AC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 828428B0: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 828428B4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828428B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828428BC: 4BA7D745  bl 0x822c0000
	ctx.lr = 0x828428C0;
	sub_822C0000(ctx, base);
	// 828428C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828428C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828428C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828428CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828428D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828428D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828428D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828428E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828428E0 size=196
    let mut pc: u32 = 0x828428E0;
    'dispatch: loop {
        match pc {
            0x828428E0 => {
    //   block [0x828428E0..0x828429A4)
	// 828428E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828428E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828428E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828428EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828428F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828428F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828428F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828428FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842900: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842904: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842908: 4BA7E031  bl 0x822c0938
	ctx.lr = 0x8284290C;
	sub_822C0938(ctx, base);
	// 8284290C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842910: 41820028  beq 0x82842938
	if ctx.cr[0].eq {
	pc = 0x82842938; continue 'dispatch;
	}
	// 82842914: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842918: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 8284291C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842920: 392BD418  addi r9, r11, -0x2be8
	ctx.r[9].s64 = ctx.r[11].s64 + -11240;
	// 82842924: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8284292C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842930: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842934: 48000008  b 0x8284293c
	pc = 0x8284293C; continue 'dispatch;
	// 82842938: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8284293C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842944: 409A0044  bne cr6, 0x82842988
	if !ctx.cr[6].eq {
	pc = 0x82842988; continue 'dispatch;
	}
	// 82842948: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8284294C: 419A001C  beq cr6, 0x82842968
	if ctx.cr[6].eq {
	pc = 0x82842968; continue 'dispatch;
	}
	// 82842950: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842954: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8284295C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842960: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842964: 4E800421  bctrl
	ctx.lr = 0x82842968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842968: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 8284296C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842974: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842978: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 8284297C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842980: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842984: 4BA7D67D  bl 0x822c0000
	ctx.lr = 0x82842988;
	sub_822C0000(ctx, base);
	// 82842988: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284298C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842990: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842994: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842998: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284299C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828429A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828429A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828429A8 size=196
    let mut pc: u32 = 0x828429A8;
    'dispatch: loop {
        match pc {
            0x828429A8 => {
    //   block [0x828429A8..0x82842A6C)
	// 828429A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828429AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828429B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828429B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828429B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828429BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828429C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828429C4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 828429C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828429CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828429D0: 4BA7DF69  bl 0x822c0938
	ctx.lr = 0x828429D4;
	sub_822C0938(ctx, base);
	// 828429D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828429D8: 41820028  beq 0x82842a00
	if ctx.cr[0].eq {
	pc = 0x82842A00; continue 'dispatch;
	}
	// 828429DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828429E0: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 828429E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828429E8: 392BD42C  addi r9, r11, -0x2bd4
	ctx.r[9].s64 = ctx.r[11].s64 + -11220;
	// 828429EC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828429F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828429F4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828429F8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828429FC: 48000008  b 0x82842a04
	pc = 0x82842A04; continue 'dispatch;
	// 82842A00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842A04: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842A08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842A0C: 409A0044  bne cr6, 0x82842a50
	if !ctx.cr[6].eq {
	pc = 0x82842A50; continue 'dispatch;
	}
	// 82842A10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842A14: 419A001C  beq cr6, 0x82842a30
	if ctx.cr[6].eq {
	pc = 0x82842A30; continue 'dispatch;
	}
	// 82842A18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842A1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842A24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842A28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842A2C: 4E800421  bctrl
	ctx.lr = 0x82842A30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842A30: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842A34: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842A38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842A3C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842A40: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842A44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842A48: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842A4C: 4BA7D5B5  bl 0x822c0000
	ctx.lr = 0x82842A50;
	sub_822C0000(ctx, base);
	// 82842A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842A54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842A58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842A5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842A60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842A64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842A68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842A70 size=196
    let mut pc: u32 = 0x82842A70;
    'dispatch: loop {
        match pc {
            0x82842A70 => {
    //   block [0x82842A70..0x82842B34)
	// 82842A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842A78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842A7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842A84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842A88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842A8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842A90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842A94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842A98: 4BA7DEA1  bl 0x822c0938
	ctx.lr = 0x82842A9C;
	sub_822C0938(ctx, base);
	// 82842A9C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842AA0: 41820028  beq 0x82842ac8
	if ctx.cr[0].eq {
	pc = 0x82842AC8; continue 'dispatch;
	}
	// 82842AA4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842AA8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82842AAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842AB0: 392BD440  addi r9, r11, -0x2bc0
	ctx.r[9].s64 = ctx.r[11].s64 + -11200;
	// 82842AB4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842AB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82842ABC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842AC0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842AC4: 48000008  b 0x82842acc
	pc = 0x82842ACC; continue 'dispatch;
	// 82842AC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842ACC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842AD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842AD4: 409A0044  bne cr6, 0x82842b18
	if !ctx.cr[6].eq {
	pc = 0x82842B18; continue 'dispatch;
	}
	// 82842AD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842ADC: 419A001C  beq cr6, 0x82842af8
	if ctx.cr[6].eq {
	pc = 0x82842AF8; continue 'dispatch;
	}
	// 82842AE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842AE4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842AE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842AEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842AF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842AF4: 4E800421  bctrl
	ctx.lr = 0x82842AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842AF8: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842AFC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842B04: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842B08: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842B0C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842B10: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842B14: 4BA7D4ED  bl 0x822c0000
	ctx.lr = 0x82842B18;
	sub_822C0000(ctx, base);
	// 82842B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842B1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842B28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842B2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842B30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842B38 size=196
    let mut pc: u32 = 0x82842B38;
    'dispatch: loop {
        match pc {
            0x82842B38 => {
    //   block [0x82842B38..0x82842BFC)
	// 82842B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842B3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842B40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842B44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842B4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842B54: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842B58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842B5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842B60: 4BA7DDD9  bl 0x822c0938
	ctx.lr = 0x82842B64;
	sub_822C0938(ctx, base);
	// 82842B64: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842B68: 41820028  beq 0x82842b90
	if ctx.cr[0].eq {
	pc = 0x82842B90; continue 'dispatch;
	}
	// 82842B6C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842B70: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82842B74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842B78: 392BD454  addi r9, r11, -0x2bac
	ctx.r[9].s64 = ctx.r[11].s64 + -11180;
	// 82842B7C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842B80: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82842B84: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842B88: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842B8C: 48000008  b 0x82842b94
	pc = 0x82842B94; continue 'dispatch;
	// 82842B90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842B94: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842B9C: 409A0044  bne cr6, 0x82842be0
	if !ctx.cr[6].eq {
	pc = 0x82842BE0; continue 'dispatch;
	}
	// 82842BA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842BA4: 419A001C  beq cr6, 0x82842bc0
	if ctx.cr[6].eq {
	pc = 0x82842BC0; continue 'dispatch;
	}
	// 82842BA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842BAC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842BB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842BB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842BB8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842BBC: 4E800421  bctrl
	ctx.lr = 0x82842BC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842BC0: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842BC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842BC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842BCC: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842BD0: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842BD4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842BD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842BDC: 4BA7D425  bl 0x822c0000
	ctx.lr = 0x82842BE0;
	sub_822C0000(ctx, base);
	// 82842BE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842BE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842BE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842BEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842BF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842C00 size=196
    let mut pc: u32 = 0x82842C00;
    'dispatch: loop {
        match pc {
            0x82842C00 => {
    //   block [0x82842C00..0x82842CC4)
	// 82842C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842C08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842C0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842C10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842C14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842C18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842C1C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842C20: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842C24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842C28: 4BA7DD11  bl 0x822c0938
	ctx.lr = 0x82842C2C;
	sub_822C0938(ctx, base);
	// 82842C2C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842C30: 41820028  beq 0x82842c58
	if ctx.cr[0].eq {
	pc = 0x82842C58; continue 'dispatch;
	}
	// 82842C34: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842C38: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82842C3C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842C40: 392BD468  addi r9, r11, -0x2b98
	ctx.r[9].s64 = ctx.r[11].s64 + -11160;
	// 82842C44: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842C48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82842C4C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842C50: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842C54: 48000008  b 0x82842c5c
	pc = 0x82842C5C; continue 'dispatch;
	// 82842C58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842C5C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842C64: 409A0044  bne cr6, 0x82842ca8
	if !ctx.cr[6].eq {
	pc = 0x82842CA8; continue 'dispatch;
	}
	// 82842C68: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842C6C: 419A001C  beq cr6, 0x82842c88
	if ctx.cr[6].eq {
	pc = 0x82842C88; continue 'dispatch;
	}
	// 82842C70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842C74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842C7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842C80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842C84: 4E800421  bctrl
	ctx.lr = 0x82842C88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842C88: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842C8C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842C94: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842C98: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842C9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842CA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842CA4: 4BA7D35D  bl 0x822c0000
	ctx.lr = 0x82842CA8;
	sub_822C0000(ctx, base);
	// 82842CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842CAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842CB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842CBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842CC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842CC8 size=196
    let mut pc: u32 = 0x82842CC8;
    'dispatch: loop {
        match pc {
            0x82842CC8 => {
    //   block [0x82842CC8..0x82842D8C)
	// 82842CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842CD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842CD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842CD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842CDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842CE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842CE4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842CE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842CEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842CF0: 4BA7DC49  bl 0x822c0938
	ctx.lr = 0x82842CF4;
	sub_822C0938(ctx, base);
	// 82842CF4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842CF8: 41820028  beq 0x82842d20
	if ctx.cr[0].eq {
	pc = 0x82842D20; continue 'dispatch;
	}
	// 82842CFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842D00: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82842D04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842D08: 392BD47C  addi r9, r11, -0x2b84
	ctx.r[9].s64 = ctx.r[11].s64 + -11140;
	// 82842D0C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842D10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82842D14: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842D18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842D1C: 48000008  b 0x82842d24
	pc = 0x82842D24; continue 'dispatch;
	// 82842D20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842D24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842D28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842D2C: 409A0044  bne cr6, 0x82842d70
	if !ctx.cr[6].eq {
	pc = 0x82842D70; continue 'dispatch;
	}
	// 82842D30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842D34: 419A001C  beq cr6, 0x82842d50
	if ctx.cr[6].eq {
	pc = 0x82842D50; continue 'dispatch;
	}
	// 82842D38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842D3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842D44: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842D48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842D4C: 4E800421  bctrl
	ctx.lr = 0x82842D50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842D50: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842D54: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842D58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842D5C: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842D60: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842D64: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842D68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842D6C: 4BA7D295  bl 0x822c0000
	ctx.lr = 0x82842D70;
	sub_822C0000(ctx, base);
	// 82842D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842D74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842D78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842D7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842D80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842D84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842D88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82842D90 size=196
    let mut pc: u32 = 0x82842D90;
    'dispatch: loop {
        match pc {
            0x82842D90 => {
    //   block [0x82842D90..0x82842E54)
	// 82842D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82842D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82842D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82842DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842DA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842DAC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82842DB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82842DB4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842DB8: 4BA7DB81  bl 0x822c0938
	ctx.lr = 0x82842DBC;
	sub_822C0938(ctx, base);
	// 82842DBC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82842DC0: 41820028  beq 0x82842de8
	if ctx.cr[0].eq {
	pc = 0x82842DE8; continue 'dispatch;
	}
	// 82842DC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82842DC8: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82842DCC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82842DD0: 392BD490  addi r9, r11, -0x2b70
	ctx.r[9].s64 = ctx.r[11].s64 + -11120;
	// 82842DD4: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82842DD8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82842DDC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82842DE0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82842DE4: 48000008  b 0x82842dec
	pc = 0x82842DEC; continue 'dispatch;
	// 82842DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82842DEC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82842DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82842DF4: 409A0044  bne cr6, 0x82842e38
	if !ctx.cr[6].eq {
	pc = 0x82842E38; continue 'dispatch;
	}
	// 82842DF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82842DFC: 419A001C  beq cr6, 0x82842e18
	if ctx.cr[6].eq {
	pc = 0x82842E18; continue 'dispatch;
	}
	// 82842E00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842E04: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82842E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82842E0C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82842E10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82842E14: 4E800421  bctrl
	ctx.lr = 0x82842E18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82842E18: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82842E1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82842E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82842E24: 394A0828  addi r10, r10, 0x828
	ctx.r[10].s64 = ctx.r[10].s64 + 2088;
	// 82842E28: 816B26E4  lwz r11, 0x26e4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9956 as u32) ) } as u64;
	// 82842E2C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82842E30: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82842E34: 4BA7D1CD  bl 0x822c0000
	ctx.lr = 0x82842E38;
	sub_822C0000(ctx, base);
	// 82842E38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82842E3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82842E40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82842E44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82842E48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82842E4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82842E50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82842E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82842E58 size=540
    let mut pc: u32 = 0x82842E58;
    'dispatch: loop {
        match pc {
            0x82842E58 => {
    //   block [0x82842E58..0x82843074)
	// 82842E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82842E5C: 48965311  bl 0x831a816c
	ctx.lr = 0x82842E60;
	sub_831A8130(ctx, base);
	// 82842E60: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82842E64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82842E68: 4BCCEC81  bl 0x82511ae8
	ctx.lr = 0x82842E6C;
	sub_82511AE8(ctx, base);
	// 82842E6C: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82842E70: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82842E74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82842E78: 3BEBB63C  addi r31, r11, -0x49c4
	ctx.r[31].s64 = ctx.r[11].s64 + -18884;
	// 82842E7C: 816AB640  lwz r11, -0x49c0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18880 as u32) ) } as u64;
	// 82842E80: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82842E84: 4082002C  bne 0x82842eb0
	if !ctx.cr[0].eq {
	pc = 0x82842EB0; continue 'dispatch;
	}
	// 82842E88: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82842E8C: 39200080  li r9, 0x80
	ctx.r[9].s64 = 128;
	// 82842E90: 916AB640  stw r11, -0x49c0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18880 as u32), ctx.r[11].u32 ) };
	// 82842E94: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82842E98: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82842E9C: 993F0000  stb r9, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82842EA0: 394000FF  li r10, 0xff
	ctx.r[10].s64 = 255;
	// 82842EA4: 991F0001  stb r8, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[8].u8 ) };
	// 82842EA8: 997F0002  stb r11, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[11].u8 ) };
	// 82842EAC: 995F0003  stb r10, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 82842EB0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82842EB4: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82842EB8: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82842EBC: 396BC4C0  addi r11, r11, -0x3b40
	ctx.r[11].s64 = ctx.r[11].s64 + -15168;
	// 82842EC0: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 82842EC4: 394A5930  addi r10, r10, 0x5930
	ctx.r[10].s64 = ctx.r[10].s64 + 22832;
	// 82842EC8: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 82842ECC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82842ED0: 13C058C7  vcmpequd (lvx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82842ED4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843078 size=356
    let mut pc: u32 = 0x82843078;
    'dispatch: loop {
        match pc {
            0x82843078 => {
    //   block [0x82843078..0x828431DC)
	// 82843078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284307C: 489650E5  bl 0x831a8160
	ctx.lr = 0x82843080;
	sub_831A8130(ctx, base);
	// 82843080: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843084: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82843088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8284308C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82843090: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82843094: 4BE539C5  bl 0x82696a58
	ctx.lr = 0x82843098;
	sub_82696A58(ctx, base);
	// 82843098: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8284309C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828430A0: 388BD4B0  addi r4, r11, -0x2b50
	ctx.r[4].s64 = ctx.r[11].s64 + -11088;
	// 828430A4: 38A000EC  li r5, 0xec
	ctx.r[5].s64 = 236;
	// 828430A8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828430AC: 4BA7D32D  bl 0x822c03d8
	ctx.lr = 0x828430B0;
	sub_822C03D8(ctx, base);
	// 828430B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828430B4: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 828430B8: 3B6BD4A0  addi r27, r11, -0x2b60
	ctx.r[27].s64 = ctx.r[11].s64 + -11104;
	// 828430BC: 41820030  beq 0x828430ec
	if ctx.cr[0].eq {
	pc = 0x828430EC; continue 'dispatch;
	}
	// 828430C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 828430C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828430C8: 485B0941  bl 0x82df3a08
	ctx.lr = 0x828430CC;
	sub_82DF3A08(ctx, base);
	// 828430CC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828430D0: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 828430D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828430D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828430DC: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828430E0: 4BD69331  bl 0x825ac410
	ctx.lr = 0x828430E4;
	sub_825AC410(ctx, base);
	// 828430E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828430E8: 48000008  b 0x828430f0
	pc = 0x828430F0; continue 'dispatch;
	// 828430EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828430F0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 828430F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828430F8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828430FC: 4BCB02BD  bl 0x824f33b8
	ctx.lr = 0x82843100;
	sub_824F33B8(ctx, base);
	// 82843100: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82843104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82843108: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8284310C: 4BA7CEF5  bl 0x822c0000
	ctx.lr = 0x82843110;
	sub_822C0000(ctx, base);
	// 82843110: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82843114: 4182000C  beq 0x82843120
	if ctx.cr[0].eq {
	pc = 0x82843120; continue 'dispatch;
	}
	// 82843118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284311C: 485B030D  bl 0x82df3428
	ctx.lr = 0x82843120;
	sub_82DF3428(ctx, base);
	// 82843120: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82843124: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82843128: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8284312C: 3BAB2AD0  addi r29, r11, 0x2ad0
	ctx.r[29].s64 = ctx.r[11].s64 + 10960;
	// 82843130: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82843134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843138: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284313C: 485B08CD  bl 0x82df3a08
	ctx.lr = 0x82843140;
	sub_82DF3A08(ctx, base);
	// 82843140: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82843144: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82843148: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8284314C: 4BD68C75  bl 0x825abdc0
	ctx.lr = 0x82843150;
	sub_825ABDC0(ctx, base);
	// 82843150: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843154: 485B02D5  bl 0x82df3428
	ctx.lr = 0x82843158;
	sub_82DF3428(ctx, base);
	// 82843158: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8284315C: 397D000C  addi r11, r29, 0xc
	ctx.r[11].s64 = ctx.r[29].s64 + 12;
	// 82843160: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82843164: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82843168: 4198FFCC  blt cr6, 0x82843134
	if ctx.cr[6].lt {
	pc = 0x82843134; continue 'dispatch;
	}
	// 8284316C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82843170: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843174: 485B0895  bl 0x82df3a08
	ctx.lr = 0x82843178;
	sub_82DF3A08(ctx, base);
	// 82843178: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8284317C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82843180: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82843184: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82843188: 419A0024  beq cr6, 0x828431ac
	if ctx.cr[6].eq {
	pc = 0x828431AC; continue 'dispatch;
	}
	// 8284318C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82843190: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82843194: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843198: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8284319C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828431A0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828431A4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828431A8: 4082FFE8  bne 0x82843190
	if !ctx.cr[0].eq {
	pc = 0x82843190; continue 'dispatch;
	}
	// 828431AC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 828431B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828431B4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828431B8: 4BD5EF59  bl 0x825a2110
	ctx.lr = 0x828431BC;
	sub_825A2110(ctx, base);
	// 828431BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828431C0: 485B0269  bl 0x82df3428
	ctx.lr = 0x828431C4;
	sub_82DF3428(ctx, base);
	// 828431C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828431C8: 419A000C  beq cr6, 0x828431d4
	if ctx.cr[6].eq {
	pc = 0x828431D4; continue 'dispatch;
	}
	// 828431CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828431D0: 4BA7D6C1  bl 0x822c0890
	ctx.lr = 0x828431D4;
	sub_822C0890(ctx, base);
	// 828431D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828431D8: 48964FD8  b 0x831a81b0
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828431E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828431E0 size=120
    let mut pc: u32 = 0x828431E0;
    'dispatch: loop {
        match pc {
            0x828431E0 => {
    //   block [0x828431E0..0x82843258)
	// 828431E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828431E4: 48964F89  bl 0x831a816c
	ctx.lr = 0x828431E8;
	sub_831A8130(ctx, base);
	// 828431E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828431EC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828431F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828431F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828431F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828431FC: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82843200: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82843204: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82843208: 485AF1E1  bl 0x82df23e8
	ctx.lr = 0x8284320C;
	sub_82DF23E8(ctx, base);
	// 8284320C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82843210: 41820014  beq 0x82843224
	if ctx.cr[0].eq {
	pc = 0x82843224; continue 'dispatch;
	}
	// 82843214: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82843218: 480092D1  bl 0x8284c4e8
	ctx.lr = 0x8284321C;
	sub_8284C4E8(ctx, base);
	// 8284321C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843220: 48000008  b 0x82843228
	pc = 0x82843228; continue 'dispatch;
	// 82843224: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82843228: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8284322C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82843230: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82843234: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843238: 4BFFF901  bl 0x82842b38
	ctx.lr = 0x8284323C;
	sub_82842B38(ctx, base);
	// 8284323C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82843240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82843244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843248: 4BA7CDB9  bl 0x822c0000
	ctx.lr = 0x8284324C;
	sub_822C0000(ctx, base);
	// 8284324C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82843250: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82843254: 48964F68  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843258 size=120
    let mut pc: u32 = 0x82843258;
    'dispatch: loop {
        match pc {
            0x82843258 => {
    //   block [0x82843258..0x828432D0)
	// 82843258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284325C: 48964F11  bl 0x831a816c
	ctx.lr = 0x82843260;
	sub_831A8130(ctx, base);
	// 82843260: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843264: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82843268: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8284326C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82843270: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82843274: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82843278: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 8284327C: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82843280: 485AF169  bl 0x82df23e8
	ctx.lr = 0x82843284;
	sub_82DF23E8(ctx, base);
	// 82843284: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82843288: 41820014  beq 0x8284329c
	if ctx.cr[0].eq {
	pc = 0x8284329C; continue 'dispatch;
	}
	// 8284328C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82843290: 48008D51  bl 0x8284bfe0
	ctx.lr = 0x82843294;
	sub_8284BFE0(ctx, base);
	// 82843294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843298: 48000008  b 0x828432a0
	pc = 0x828432A0; continue 'dispatch;
	// 8284329C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828432A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828432A4: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 828432A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828432AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828432B0: 4BFFF951  bl 0x82842c00
	ctx.lr = 0x828432B4;
	sub_82842C00(ctx, base);
	// 828432B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828432B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828432BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828432C0: 4BA7CD41  bl 0x822c0000
	ctx.lr = 0x828432C4;
	sub_822C0000(ctx, base);
	// 828432C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828432C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828432CC: 48964EF0  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828432D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828432D0 size=112
    let mut pc: u32 = 0x828432D0;
    'dispatch: loop {
        match pc {
            0x828432D0 => {
    //   block [0x828432D0..0x82843340)
	// 828432D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828432D4: 48964E99  bl 0x831a816c
	ctx.lr = 0x828432D8;
	sub_831A8130(ctx, base);
	// 828432D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828432DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 828432E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828432E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828432E8: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 828432EC: 38A00073  li r5, 0x73
	ctx.r[5].s64 = 115;
	// 828432F0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 828432F4: 485AF0F5  bl 0x82df23e8
	ctx.lr = 0x828432F8;
	sub_82DF23E8(ctx, base);
	// 828432F8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828432FC: 41820010  beq 0x8284330c
	if ctx.cr[0].eq {
	pc = 0x8284330C; continue 'dispatch;
	}
	// 82843300: 48008C11  bl 0x8284bf10
	ctx.lr = 0x82843304;
	sub_8284BF10(ctx, base);
	// 82843304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843308: 48000008  b 0x82843310
	pc = 0x82843310; continue 'dispatch;
	// 8284330C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82843310: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82843314: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82843318: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8284331C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843320: 4BFFF9A9  bl 0x82842cc8
	ctx.lr = 0x82843324;
	sub_82842CC8(ctx, base);
	// 82843324: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82843328: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8284332C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843330: 4BA7CCD1  bl 0x822c0000
	ctx.lr = 0x82843334;
	sub_822C0000(ctx, base);
	// 82843334: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82843338: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284333C: 48964E80  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843340 size=128
    let mut pc: u32 = 0x82843340;
    'dispatch: loop {
        match pc {
            0x82843340 => {
    //   block [0x82843340..0x828433C0)
	// 82843340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843344: 48964E29  bl 0x831a816c
	ctx.lr = 0x82843348;
	sub_831A8130(ctx, base);
	// 82843348: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284334C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82843350: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82843354: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82843358: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8284335C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82843360: 388BA66C  addi r4, r11, -0x5994
	ctx.r[4].s64 = ctx.r[11].s64 + -22932;
	// 82843364: 38A00089  li r5, 0x89
	ctx.r[5].s64 = 137;
	// 82843368: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 8284336C: 485AF07D  bl 0x82df23e8
	ctx.lr = 0x82843370;
	sub_82DF23E8(ctx, base);
	// 82843370: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82843374: 41820018  beq 0x8284338c
	if ctx.cr[0].eq {
	pc = 0x8284338C; continue 'dispatch;
	}
	// 82843378: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8284337C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82843380: 48008C19  bl 0x8284bf98
	ctx.lr = 0x82843384;
	sub_8284BF98(ctx, base);
	// 82843384: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843388: 48000008  b 0x82843390
	pc = 0x82843390; continue 'dispatch;
	// 8284338C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82843390: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82843394: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82843398: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8284339C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828433A0: 4BFFF9F1  bl 0x82842d90
	ctx.lr = 0x828433A4;
	sub_82842D90(ctx, base);
	// 828433A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828433A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828433AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828433B0: 4BA7CC51  bl 0x822c0000
	ctx.lr = 0x828433B4;
	sub_822C0000(ctx, base);
	// 828433B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828433B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828433BC: 48964E00  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828433C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828433C0 size=176
    let mut pc: u32 = 0x828433C0;
    'dispatch: loop {
        match pc {
            0x828433C0 => {
    //   block [0x828433C0..0x82843470)
	// 828433C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828433C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828433C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828433CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828433D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828433D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828433D8: 4BE52F01  bl 0x826962d8
	ctx.lr = 0x828433DC;
	sub_826962D8(ctx, base);
	// 828433DC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828433E0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 828433E4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 828433E8: 396BD584  addi r11, r11, -0x2a7c
	ctx.r[11].s64 = ctx.r[11].s64 + -10876;
	// 828433EC: 394AD570  addi r10, r10, -0x2a90
	ctx.r[10].s64 = ctx.r[10].s64 + -10896;
	// 828433F0: 3929D524  addi r9, r9, -0x2adc
	ctx.r[9].s64 = ctx.r[9].s64 + -10972;
	// 828433F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828433F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828433FC: 915E0028  stw r10, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843400: 913E00E8  stw r9, 0xe8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843404: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843408: 9BFE0138  stb r31, 0x138(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(312 as u32), ctx.r[31].u8 ) };
	// 8284340C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843410: 4BE51ED1  bl 0x826952e0
	ctx.lr = 0x82843414;
	sub_826952E0(ctx, base);
	// 82843414: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 82843418: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 8284341C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843420: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82843424: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843428: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 8284342C: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 82843430: 4BE51E61  bl 0x82695290
	ctx.lr = 0x82843434;
	sub_82695290(ctx, base);
	// 82843434: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 82843438: 9BE10055  stb r31, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[31].u8 ) };
	// 8284343C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843440: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82843444: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82843448: 9BE10056  stb r31, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[31].u8 ) };
	// 8284344C: 9BE10057  stb r31, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[31].u8 ) };
	// 82843450: 4BE51E69  bl 0x826952b8
	ctx.lr = 0x82843454;
	sub_826952B8(ctx, base);
	// 82843454: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843458: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8284345C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843460: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843464: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82843468: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8284346C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82843470 size=8
    let mut pc: u32 = 0x82843470;
    'dispatch: loop {
        match pc {
            0x82843470 => {
    //   block [0x82843470..0x82843478)
	// 82843470: 3863FFD8  addi r3, r3, -0x28
	ctx.r[3].s64 = ctx.r[3].s64 + -40;
	// 82843474: 480006AC  b 0x82843b20
	sub_82843B20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843478 size=208
    let mut pc: u32 = 0x82843478;
    'dispatch: loop {
        match pc {
            0x82843478 => {
    //   block [0x82843478..0x82843548)
	// 82843478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284347C: 48964CED  bl 0x831a8168
	ctx.lr = 0x82843480;
	sub_831A8130(ctx, base);
	// 82843480: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843484: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82843488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284348C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82843490: 4BFDAF89  bl 0x8281e418
	ctx.lr = 0x82843494;
	sub_8281E418(ctx, base);
	// 82843494: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82843498: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284349C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828434A0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 828434A4: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 828434A8: 419A0024  beq cr6, 0x828434cc
	if ctx.cr[6].eq {
	pc = 0x828434CC; continue 'dispatch;
	}
	// 828434AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828434B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828434B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828434B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828434BC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828434C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828434C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828434C8: 4082FFE8  bne 0x828434b0
	if !ctx.cr[0].eq {
	pc = 0x828434B0; continue 'dispatch;
	}
	// 828434CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828434D0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828434D4: 388BD4B0  addi r4, r11, -0x2b50
	ctx.r[4].s64 = ctx.r[11].s64 + -11088;
	// 828434D8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828434DC: 38A00074  li r5, 0x74
	ctx.r[5].s64 = 116;
	// 828434E0: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 828434E4: 48613B05  bl 0x82e56fe8
	ctx.lr = 0x828434E8;
	sub_82E56FE8(ctx, base);
	// 828434E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828434EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828434F0: 419A0008  beq cr6, 0x828434f8
	if ctx.cr[6].eq {
	pc = 0x828434F8; continue 'dispatch;
	}
	// 828434F4: 4BA7D39D  bl 0x822c0890
	ctx.lr = 0x828434F8;
	sub_822C0890(ctx, base);
	// 828434F8: 3D608207  lis r11, -0x7df9
	ctx.r[11].s64 = -2113470464;
	// 828434FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843500: 388B1548  addi r4, r11, 0x1548
	ctx.r[4].s64 = ctx.r[11].s64 + 5448;
	// 82843504: 485B0505  bl 0x82df3a08
	ctx.lr = 0x82843508;
	sub_82DF3A08(ctx, base);
	// 82843508: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8284350C: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 82843510: 485AFDF9  bl 0x82df3308
	ctx.lr = 0x82843514;
	sub_82DF3308(ctx, base);
	// 82843514: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82843518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284351C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82843520: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82843524: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 82843528: 485AFF01  bl 0x82df3428
	ctx.lr = 0x8284352C;
	sub_82DF3428(ctx, base);
	// 8284352C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82843530: 419A000C  beq cr6, 0x8284353c
	if ctx.cr[6].eq {
	pc = 0x8284353C; continue 'dispatch;
	}
	// 82843534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843538: 4BA7D359  bl 0x822c0890
	ctx.lr = 0x8284353C;
	sub_822C0890(ctx, base);
	// 8284353C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843540: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82843544: 48964C74  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843548 size=208
    let mut pc: u32 = 0x82843548;
    'dispatch: loop {
        match pc {
            0x82843548 => {
    //   block [0x82843548..0x82843618)
	// 82843548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284354C: 48964C1D  bl 0x831a8168
	ctx.lr = 0x82843550;
	sub_831A8130(ctx, base);
	// 82843550: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843554: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82843558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284355C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82843560: 4BFDAEB9  bl 0x8281e418
	ctx.lr = 0x82843564;
	sub_8281E418(ctx, base);
	// 82843564: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82843568: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8284356C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82843570: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82843574: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82843578: 419A0024  beq cr6, 0x8284359c
	if ctx.cr[6].eq {
	pc = 0x8284359C; continue 'dispatch;
	}
	// 8284357C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82843580: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82843584: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843588: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8284358C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82843590: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82843594: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843598: 4082FFE8  bne 0x82843580
	if !ctx.cr[0].eq {
	pc = 0x82843580; continue 'dispatch;
	}
	// 8284359C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828435A0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 828435A4: 388BD4B0  addi r4, r11, -0x2b50
	ctx.r[4].s64 = ctx.r[11].s64 + -11088;
	// 828435A8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 828435AC: 38A0007E  li r5, 0x7e
	ctx.r[5].s64 = 126;
	// 828435B0: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 828435B4: 48613A35  bl 0x82e56fe8
	ctx.lr = 0x828435B8;
	sub_82E56FE8(ctx, base);
	// 828435B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828435BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828435C0: 419A0008  beq cr6, 0x828435c8
	if ctx.cr[6].eq {
	pc = 0x828435C8; continue 'dispatch;
	}
	// 828435C4: 4BA7D2CD  bl 0x822c0890
	ctx.lr = 0x828435C8;
	sub_822C0890(ctx, base);
	// 828435C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828435CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828435D0: 388BD5D4  addi r4, r11, -0x2a2c
	ctx.r[4].s64 = ctx.r[11].s64 + -10796;
	// 828435D4: 485B0435  bl 0x82df3a08
	ctx.lr = 0x828435D8;
	sub_82DF3A08(ctx, base);
	// 828435D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828435DC: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 828435E0: 485AFD29  bl 0x82df3308
	ctx.lr = 0x828435E4;
	sub_82DF3308(ctx, base);
	// 828435E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 828435E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828435EC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828435F0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 828435F4: 697E0001  xori r30, r11, 1
	ctx.r[30].u64 = ctx.r[11].u64 ^ 1;
	// 828435F8: 485AFE31  bl 0x82df3428
	ctx.lr = 0x828435FC;
	sub_82DF3428(ctx, base);
	// 828435FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82843600: 419A000C  beq cr6, 0x8284360c
	if ctx.cr[6].eq {
	pc = 0x8284360C; continue 'dispatch;
	}
	// 82843604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843608: 4BA7D289  bl 0x822c0890
	ctx.lr = 0x8284360C;
	sub_822C0890(ctx, base);
	// 8284360C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843610: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82843614: 48964BA4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82843618 size=200
    let mut pc: u32 = 0x82843618;
    'dispatch: loop {
        match pc {
            0x82843618 => {
    //   block [0x82843618..0x828436E0)
	// 82843618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284361C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843620: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82843624: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843628: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284362C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843630: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82843634: 4BFFFE45  bl 0x82843478
	ctx.lr = 0x82843638;
	sub_82843478(ctx, base);
	// 82843638: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8284363C: 4182008C  beq 0x828436c8
	if ctx.cr[0].eq {
	pc = 0x828436C8; continue 'dispatch;
	}
	// 82843640: 389F013C  addi r4, r31, 0x13c
	ctx.r[4].s64 = ctx.r[31].s64 + 316;
	// 82843644: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82843648: 4BFFFC11  bl 0x82843258
	ctx.lr = 0x8284364C;
	sub_82843258(ctx, base);
	// 8284364C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82843650: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82843654: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82843658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8284365C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82843660: 419A0024  beq cr6, 0x82843684
	if ctx.cr[6].eq {
	pc = 0x82843684; continue 'dispatch;
	}
	// 82843664: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82843668: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284366C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843670: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82843674: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82843678: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284367C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843680: 4082FFE8  bne 0x82843668
	if !ctx.cr[0].eq {
	pc = 0x82843668; continue 'dispatch;
	}
	// 82843684: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82843688: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 8284368C: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82843690: 388AD4B0  addi r4, r10, -0x2b50
	ctx.r[4].s64 = ctx.r[10].s64 + -11088;
	// 82843694: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82843698: 38A000F9  li r5, 0xf9
	ctx.r[5].s64 = 249;
	// 8284369C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828436A0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 828436A4: 4861539D  bl 0x82e58a40
	ctx.lr = 0x828436A8;
	sub_82E58A40(ctx, base);
	// 828436A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828436AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828436B0: 419A0008  beq cr6, 0x828436b8
	if ctx.cr[6].eq {
	pc = 0x828436B8; continue 'dispatch;
	}
	// 828436B4: 4BA7D1DD  bl 0x822c0890
	ctx.lr = 0x828436B8;
	sub_822C0890(ctx, base);
	// 828436B8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 828436BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828436C0: 419A0008  beq cr6, 0x828436c8
	if ctx.cr[6].eq {
	pc = 0x828436C8; continue 'dispatch;
	}
	// 828436C4: 4BA7D1CD  bl 0x822c0890
	ctx.lr = 0x828436C8;
	sub_822C0890(ctx, base);
	// 828436C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828436CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828436D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828436D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828436D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828436DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828436E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828436E0 size=196
    let mut pc: u32 = 0x828436E0;
    'dispatch: loop {
        match pc {
            0x828436E0 => {
    //   block [0x828436E0..0x828437A4)
	// 828436E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828436E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828436E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828436EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828436F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828436F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828436F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828436FC: 4BFFFD7D  bl 0x82843478
	ctx.lr = 0x82843700;
	sub_82843478(ctx, base);
	// 82843700: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82843704: 41820088  beq 0x8284378c
	if ctx.cr[0].eq {
	pc = 0x8284378C; continue 'dispatch;
	}
	// 82843708: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8284370C: 4BFFFBC5  bl 0x828432d0
	ctx.lr = 0x82843710;
	sub_828432D0(ctx, base);
	// 82843710: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82843714: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82843718: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8284371C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82843720: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82843724: 419A0024  beq cr6, 0x82843748
	if ctx.cr[6].eq {
	pc = 0x82843748; continue 'dispatch;
	}
	// 82843728: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8284372C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82843730: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843734: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82843738: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8284373C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82843740: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843744: 4082FFE8  bne 0x8284372c
	if !ctx.cr[0].eq {
	pc = 0x8284372C; continue 'dispatch;
	}
	// 82843748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8284374C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843750: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82843754: 388AD4B0  addi r4, r10, -0x2b50
	ctx.r[4].s64 = ctx.r[10].s64 + -11088;
	// 82843758: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8284375C: 38A0011A  li r5, 0x11a
	ctx.r[5].s64 = 282;
	// 82843760: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82843764: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82843768: 486152D9  bl 0x82e58a40
	ctx.lr = 0x8284376C;
	sub_82E58A40(ctx, base);
	// 8284376C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82843770: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82843774: 419A0008  beq cr6, 0x8284377c
	if ctx.cr[6].eq {
	pc = 0x8284377C; continue 'dispatch;
	}
	// 82843778: 4BA7D119  bl 0x822c0890
	ctx.lr = 0x8284377C;
	sub_822C0890(ctx, base);
	// 8284377C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82843780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82843784: 419A0008  beq cr6, 0x8284378c
	if ctx.cr[6].eq {
	pc = 0x8284378C; continue 'dispatch;
	}
	// 82843788: 4BA7D109  bl 0x822c0890
	ctx.lr = 0x8284378C;
	sub_822C0890(ctx, base);
	// 8284378C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843798: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8284379C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828437A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828437A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828437A8 size=208
    let mut pc: u32 = 0x828437A8;
    'dispatch: loop {
        match pc {
            0x828437A8 => {
    //   block [0x828437A8..0x82843878)
	// 828437A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828437AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828437B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828437B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828437B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828437BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828437C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828437C4: 4BFFFCB5  bl 0x82843478
	ctx.lr = 0x828437C8;
	sub_82843478(ctx, base);
	// 828437C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828437CC: 41820094  beq 0x82843860
	if ctx.cr[0].eq {
	pc = 0x82843860; continue 'dispatch;
	}
	// 828437D0: 3D608338  lis r11, -0x7cc8
	ctx.r[11].s64 = -2093481984;
	// 828437D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828437D8: 388B6910  addi r4, r11, 0x6910
	ctx.r[4].s64 = ctx.r[11].s64 + 26896;
	// 828437DC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 828437E0: 4BFBAF61  bl 0x827fe740
	ctx.lr = 0x828437E4;
	sub_827FE740(ctx, base);
	// 828437E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 828437E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828437EC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828437F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828437F4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828437F8: 419A0024  beq cr6, 0x8284381c
	if ctx.cr[6].eq {
	pc = 0x8284381C; continue 'dispatch;
	}
	// 828437FC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82843800: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82843804: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843808: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8284380C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82843810: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82843814: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843818: 4082FFE8  bne 0x82843800
	if !ctx.cr[0].eq {
	pc = 0x82843800; continue 'dispatch;
	}
	// 8284381C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82843820: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843824: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82843828: 388AD4B0  addi r4, r10, -0x2b50
	ctx.r[4].s64 = ctx.r[10].s64 + -11088;
	// 8284382C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82843830: 38A0013B  li r5, 0x13b
	ctx.r[5].s64 = 315;
	// 82843834: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82843838: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 8284383C: 48615205  bl 0x82e58a40
	ctx.lr = 0x82843840;
	sub_82E58A40(ctx, base);
	// 82843840: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82843844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82843848: 419A0008  beq cr6, 0x82843850
	if ctx.cr[6].eq {
	pc = 0x82843850; continue 'dispatch;
	}
	// 8284384C: 4BA7D045  bl 0x822c0890
	ctx.lr = 0x82843850;
	sub_822C0890(ctx, base);
	// 82843850: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82843854: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82843858: 419A0008  beq cr6, 0x82843860
	if ctx.cr[6].eq {
	pc = 0x82843860; continue 'dispatch;
	}
	// 8284385C: 4BA7D035  bl 0x822c0890
	ctx.lr = 0x82843860;
	sub_822C0890(ctx, base);
	// 82843860: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843864: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843868: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8284386C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82843870: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843878 size=272
    let mut pc: u32 = 0x82843878;
    'dispatch: loop {
        match pc {
            0x82843878 => {
    //   block [0x82843878..0x82843988)
	// 82843878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284387C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82843884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843888: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8284388C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843890: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82843894: 4BE531C5  bl 0x82696a58
	ctx.lr = 0x82843898;
	sub_82696A58(ctx, base);
	// 82843898: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 8284389C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828438A0: 388BD628  addi r4, r11, -0x29d8
	ctx.r[4].s64 = ctx.r[11].s64 + -10712;
	// 828438A4: 485B0165  bl 0x82df3a08
	ctx.lr = 0x828438A8;
	sub_82DF3A08(ctx, base);
	// 828438A8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828438AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828438B0: 388BD61C  addi r4, r11, -0x29e4
	ctx.r[4].s64 = ctx.r[11].s64 + -10724;
	// 828438B4: 485B0155  bl 0x82df3a08
	ctx.lr = 0x828438B8;
	sub_82DF3A08(ctx, base);
	// 828438B8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 828438BC: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 828438C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828438C4: 38BF0054  addi r5, r31, 0x54
	ctx.r[5].s64 = ctx.r[31].s64 + 84;
	// 828438C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828438CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828438D0: 4BD5FB49  bl 0x825a3418
	ctx.lr = 0x828438D4;
	sub_825A3418(ctx, base);
	// 828438D4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828438D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828438DC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 828438E0: 4BD5E5F9  bl 0x825a1ed8
	ctx.lr = 0x828438E4;
	sub_825A1ED8(ctx, base);
	// 828438E4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 828438E8: 485AFB41  bl 0x82df3428
	ctx.lr = 0x828438EC;
	sub_82DF3428(ctx, base);
	// 828438EC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 828438F0: 4BA853C9  bl 0x822c8cb8
	ctx.lr = 0x828438F4;
	sub_822C8CB8(ctx, base);
	// 828438F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828438F8: 485AFB31  bl 0x82df3428
	ctx.lr = 0x828438FC;
	sub_82DF3428(ctx, base);
	// 828438FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843900: 485AFB29  bl 0x82df3428
	ctx.lr = 0x82843904;
	sub_82DF3428(ctx, base);
	// 82843904: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843908: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8284390C: 388BD5F4  addi r4, r11, -0x2a0c
	ctx.r[4].s64 = ctx.r[11].s64 + -10764;
	// 82843910: 485B00F9  bl 0x82df3a08
	ctx.lr = 0x82843914;
	sub_82DF3A08(ctx, base);
	// 82843914: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8284391C: 388BD5E8  addi r4, r11, -0x2a18
	ctx.r[4].s64 = ctx.r[11].s64 + -10776;
	// 82843920: 485B00E9  bl 0x82df3a08
	ctx.lr = 0x82843924;
	sub_82DF3A08(ctx, base);
	// 82843924: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82843928: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8284392C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82843930: 38BF0058  addi r5, r31, 0x58
	ctx.r[5].s64 = ctx.r[31].s64 + 88;
	// 82843934: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82843938: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8284393C: 4BD5FADD  bl 0x825a3418
	ctx.lr = 0x82843940;
	sub_825A3418(ctx, base);
	// 82843940: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82843944: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8284394C: 4BD5E58D  bl 0x825a1ed8
	ctx.lr = 0x82843950;
	sub_825A1ED8(ctx, base);
	// 82843950: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82843954: 485AFAD5  bl 0x82df3428
	ctx.lr = 0x82843958;
	sub_82DF3428(ctx, base);
	// 82843958: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 8284395C: 4BA8535D  bl 0x822c8cb8
	ctx.lr = 0x82843960;
	sub_822C8CB8(ctx, base);
	// 82843960: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843964: 485AFAC5  bl 0x82df3428
	ctx.lr = 0x82843968;
	sub_82DF3428(ctx, base);
	// 82843968: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8284396C: 485AFABD  bl 0x82df3428
	ctx.lr = 0x82843970;
	sub_82DF3428(ctx, base);
	// 82843970: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82843974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8284397C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82843980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82843988 size=228
    let mut pc: u32 = 0x82843988;
    'dispatch: loop {
        match pc {
            0x82843988 => {
    //   block [0x82843988..0x82843A6C)
	// 82843988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284398C: 489647E1  bl 0x831a816c
	ctx.lr = 0x82843990;
	sub_831A8130(ctx, base);
	// 82843990: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843998: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8284399C: 4BFFFBAD  bl 0x82843548
	ctx.lr = 0x828439A0;
	sub_82843548(ctx, base);
	// 828439A0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828439A4: 418200C0  beq 0x82843a64
	if ctx.cr[0].eq {
	pc = 0x82843A64; continue 'dispatch;
	}
	// 828439A8: 38BF0140  addi r5, r31, 0x140
	ctx.r[5].s64 = ctx.r[31].s64 + 320;
	// 828439AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828439B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828439B4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 828439B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828439BC: 4BFFF985  bl 0x82843340
	ctx.lr = 0x828439C0;
	sub_82843340(ctx, base);
	// 828439C0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828439C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828439C8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 828439CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828439D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828439D4: 4BA80A8D  bl 0x822c4460
	ctx.lr = 0x828439D8;
	sub_822C4460(ctx, base);
	// 828439D8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828439DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828439E0: 419A0008  beq cr6, 0x828439e8
	if ctx.cr[6].eq {
	pc = 0x828439E8; continue 'dispatch;
	}
	// 828439E4: 4BA7CEAD  bl 0x822c0890
	ctx.lr = 0x828439E8;
	sub_822C0890(ctx, base);
	// 828439E8: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828439EC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828439F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828439F4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 828439F8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 828439FC: 419A0024  beq cr6, 0x82843a20
	if ctx.cr[6].eq {
	pc = 0x82843A20; continue 'dispatch;
	}
	// 82843A00: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82843A04: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82843A08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843A0C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82843A10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82843A14: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82843A18: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82843A1C: 4082FFE8  bne 0x82843a04
	if !ctx.cr[0].eq {
	pc = 0x82843A04; continue 'dispatch;
	}
	// 82843A20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82843A24: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843A28: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82843A2C: 388AD4B0  addi r4, r10, -0x2b50
	ctx.r[4].s64 = ctx.r[10].s64 + -11088;
	// 82843A30: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82843A34: 38A00171  li r5, 0x171
	ctx.r[5].s64 = 369;
	// 82843A38: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82843A3C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82843A40: 48615001  bl 0x82e58a40
	ctx.lr = 0x82843A44;
	sub_82E58A40(ctx, base);
	// 82843A44: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82843A48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82843A4C: 419A0008  beq cr6, 0x82843a54
	if ctx.cr[6].eq {
	pc = 0x82843A54; continue 'dispatch;
	}
	// 82843A50: 4BA7CE41  bl 0x822c0890
	ctx.lr = 0x82843A54;
	sub_822C0890(ctx, base);
	// 82843A54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82843A58: 419A000C  beq cr6, 0x82843a64
	if ctx.cr[6].eq {
	pc = 0x82843A64; continue 'dispatch;
	}
	// 82843A5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843A60: 4BA7CE31  bl 0x822c0890
	ctx.lr = 0x82843A64;
	sub_822C0890(ctx, base);
	// 82843A64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82843A68: 48964754  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843A70 size=176
    let mut pc: u32 = 0x82843A70;
    'dispatch: loop {
        match pc {
            0x82843A70 => {
    //   block [0x82843A70..0x82843B20)
	// 82843A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843A74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843A78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82843A7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843A80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843A84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82843A88: 4BE52921  bl 0x826963a8
	ctx.lr = 0x82843A8C;
	sub_826963A8(ctx, base);
	// 82843A8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843A90: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843A94: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843A98: 396BD584  addi r11, r11, -0x2a7c
	ctx.r[11].s64 = ctx.r[11].s64 + -10876;
	// 82843A9C: 394AD570  addi r10, r10, -0x2a90
	ctx.r[10].s64 = ctx.r[10].s64 + -10896;
	// 82843AA0: 3929D524  addi r9, r9, -0x2adc
	ctx.r[9].s64 = ctx.r[9].s64 + -10972;
	// 82843AA4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843AA8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82843AAC: 915E0028  stw r10, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843AB0: 913E00E8  stw r9, 0xe8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843AB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843AB8: 9BFE0138  stb r31, 0x138(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(312 as u32), ctx.r[31].u8 ) };
	// 82843ABC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843AC0: 4BE51821  bl 0x826952e0
	ctx.lr = 0x82843AC4;
	sub_826952E0(ctx, base);
	// 82843AC4: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 82843AC8: 9BE10051  stb r31, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[31].u8 ) };
	// 82843ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843AD0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82843AD4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843AD8: 9BE10052  stb r31, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[31].u8 ) };
	// 82843ADC: 9BE10053  stb r31, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[31].u8 ) };
	// 82843AE0: 4BE517B1  bl 0x82695290
	ctx.lr = 0x82843AE4;
	sub_82695290(ctx, base);
	// 82843AE4: 39600080  li r11, 0x80
	ctx.r[11].s64 = 128;
	// 82843AE8: 9BE10055  stb r31, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[31].u8 ) };
	// 82843AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843AF0: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82843AF4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82843AF8: 9BE10056  stb r31, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[31].u8 ) };
	// 82843AFC: 9BE10057  stb r31, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[31].u8 ) };
	// 82843B00: 4BE517B9  bl 0x826952b8
	ctx.lr = 0x82843B04;
	sub_826952B8(ctx, base);
	// 82843B04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82843B08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82843B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843B14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82843B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843B20 size=112
    let mut pc: u32 = 0x82843B20;
    'dispatch: loop {
        match pc {
            0x82843B20 => {
    //   block [0x82843B20..0x82843B90)
	// 82843B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843B28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82843B2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843B30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843B38: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843B3C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843B40: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843B44: 396BD584  addi r11, r11, -0x2a7c
	ctx.r[11].s64 = ctx.r[11].s64 + -10876;
	// 82843B48: 394AD570  addi r10, r10, -0x2a90
	ctx.r[10].s64 = ctx.r[10].s64 + -10896;
	// 82843B4C: 3929D524  addi r9, r9, -0x2adc
	ctx.r[9].s64 = ctx.r[9].s64 + -10972;
	// 82843B50: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843B54: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843B58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82843B5C: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843B60: 4BDD96F1  bl 0x8261d250
	ctx.lr = 0x82843B64;
	sub_8261D250(ctx, base);
	// 82843B64: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82843B68: 4182000C  beq 0x82843b74
	if ctx.cr[0].eq {
	pc = 0x82843B74; continue 'dispatch;
	}
	// 82843B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843B70: 485AE869  bl 0x82df23d8
	ctx.lr = 0x82843B74;
	sub_82DF23D8(ctx, base);
	// 82843B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82843B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843B84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82843B88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843B8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843B90 size=128
    let mut pc: u32 = 0x82843B90;
    'dispatch: loop {
        match pc {
            0x82843B90 => {
    //   block [0x82843B90..0x82843C10)
	// 82843B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843B98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843B9C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843BA4: 4BFFF81D  bl 0x828433c0
	ctx.lr = 0x82843BA8;
	sub_828433C0(ctx, base);
	// 82843BA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843BAC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843BB0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843BB4: 396BD6D4  addi r11, r11, -0x292c
	ctx.r[11].s64 = ctx.r[11].s64 + -10540;
	// 82843BB8: 394AD6C0  addi r10, r10, -0x2940
	ctx.r[10].s64 = ctx.r[10].s64 + -10560;
	// 82843BBC: 3929D674  addi r9, r9, -0x298c
	ctx.r[9].s64 = ctx.r[9].s64 + -10636;
	// 82843BC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843BC4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843BC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843BCC: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843BD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843BD4: 388BD648  addi r4, r11, -0x29b8
	ctx.r[4].s64 = ctx.r[11].s64 + -10680;
	// 82843BD8: 4BA85719  bl 0x822c92f0
	ctx.lr = 0x82843BDC;
	sub_822C92F0(ctx, base);
	// 82843BDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843BE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843BE4: 4BE535AD  bl 0x82697190
	ctx.lr = 0x82843BE8;
	sub_82697190(ctx, base);
	// 82843BE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843BEC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843BF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843BF4: 4BA8523D  bl 0x822c8e30
	ctx.lr = 0x82843BF8;
	sub_822C8E30(ctx, base);
	// 82843BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843BFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843C08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82843C10 size=156
    let mut pc: u32 = 0x82843C10;
    'dispatch: loop {
        match pc {
            0x82843C10 => {
    //   block [0x82843C10..0x82843CAC)
	// 82843C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843C18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843C1C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843C20: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82843C24: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82843C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843C2C: C06B9524  lfs f3, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82843C30: C04AD7BC  lfs f2, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82843C34: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82843C38: 4BFFFE39  bl 0x82843a70
	ctx.lr = 0x82843C3C;
	sub_82843A70(ctx, base);
	// 82843C3C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843C40: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843C44: 396BD79C  addi r11, r11, -0x2864
	ctx.r[11].s64 = ctx.r[11].s64 + -10340;
	// 82843C48: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843C4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843C50: 394AD788  addi r10, r10, -0x2878
	ctx.r[10].s64 = ctx.r[10].s64 + -10360;
	// 82843C54: 3929D73C  addi r9, r9, -0x28c4
	ctx.r[9].s64 = ctx.r[9].s64 + -10436;
	// 82843C58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82843C5C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843C60: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843C64: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843C68: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82843C6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843C70: 388AD724  addi r4, r10, -0x28dc
	ctx.r[4].s64 = ctx.r[10].s64 + -10460;
	// 82843C74: 4BA8567D  bl 0x822c92f0
	ctx.lr = 0x82843C78;
	sub_822C92F0(ctx, base);
	// 82843C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843C7C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843C80: 4BE53511  bl 0x82697190
	ctx.lr = 0x82843C84;
	sub_82697190(ctx, base);
	// 82843C84: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843C88: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843C8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843C90: 4BA851A1  bl 0x822c8e30
	ctx.lr = 0x82843C94;
	sub_822C8E30(ctx, base);
	// 82843C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843C98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843C9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843CA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82843CB0 size=148
    let mut pc: u32 = 0x82843CB0;
    'dispatch: loop {
        match pc {
            0x82843CB0 => {
    //   block [0x82843CB0..0x82843D44)
	// 82843CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843CB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843CBC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843CC0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82843CC4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82843CC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843CCC: C06B9524  lfs f3, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82843CD0: C04AD7BC  lfs f2, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82843CD4: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82843CD8: 4BFFFD99  bl 0x82843a70
	ctx.lr = 0x82843CDC;
	sub_82843A70(ctx, base);
	// 82843CDC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843CE0: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843CE4: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843CE8: 396BD86C  addi r11, r11, -0x2794
	ctx.r[11].s64 = ctx.r[11].s64 + -10132;
	// 82843CEC: 394AD858  addi r10, r10, -0x27a8
	ctx.r[10].s64 = ctx.r[10].s64 + -10152;
	// 82843CF0: 3929D80C  addi r9, r9, -0x27f4
	ctx.r[9].s64 = ctx.r[9].s64 + -10228;
	// 82843CF4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843CF8: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843CFC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843D00: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843D04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843D08: 388BD7EC  addi r4, r11, -0x2814
	ctx.r[4].s64 = ctx.r[11].s64 + -10260;
	// 82843D0C: 4BA855E5  bl 0x822c92f0
	ctx.lr = 0x82843D10;
	sub_822C92F0(ctx, base);
	// 82843D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843D18: 4BE53479  bl 0x82697190
	ctx.lr = 0x82843D1C;
	sub_82697190(ctx, base);
	// 82843D1C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843D20: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843D24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843D28: 4BA85109  bl 0x822c8e30
	ctx.lr = 0x82843D2C;
	sub_822C8E30(ctx, base);
	// 82843D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843D30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843D34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843D38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843D3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82843D48 size=148
    let mut pc: u32 = 0x82843D48;
    'dispatch: loop {
        match pc {
            0x82843D48 => {
    //   block [0x82843D48..0x82843DDC)
	// 82843D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843D50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843D54: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843D58: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82843D5C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82843D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843D64: C06B9524  lfs f3, -0x6adc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27356 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82843D68: C04AD7BC  lfs f2, -0x2844(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10308 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82843D6C: FC201890  fmr f1, f3
	ctx.f[1].f64 = ctx.f[3].f64;
	// 82843D70: 4BFFFD01  bl 0x82843a70
	ctx.lr = 0x82843D74;
	sub_82843A70(ctx, base);
	// 82843D74: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843D78: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843D7C: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843D80: 396BD934  addi r11, r11, -0x26cc
	ctx.r[11].s64 = ctx.r[11].s64 + -9932;
	// 82843D84: 394AD920  addi r10, r10, -0x26e0
	ctx.r[10].s64 = ctx.r[10].s64 + -9952;
	// 82843D88: 3929D8D4  addi r9, r9, -0x272c
	ctx.r[9].s64 = ctx.r[9].s64 + -10028;
	// 82843D8C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843D90: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843D94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843D98: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843D9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843DA0: 388BD8BC  addi r4, r11, -0x2744
	ctx.r[4].s64 = ctx.r[11].s64 + -10052;
	// 82843DA4: 4BA8554D  bl 0x822c92f0
	ctx.lr = 0x82843DA8;
	sub_822C92F0(ctx, base);
	// 82843DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843DAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843DB0: 4BE533E1  bl 0x82697190
	ctx.lr = 0x82843DB4;
	sub_82697190(ctx, base);
	// 82843DB4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843DB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843DC0: 4BA85071  bl 0x822c8e30
	ctx.lr = 0x82843DC4;
	sub_822C8E30(ctx, base);
	// 82843DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843DC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843DD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843DE0 size=140
    let mut pc: u32 = 0x82843DE0;
    'dispatch: loop {
        match pc {
            0x82843DE0 => {
    //   block [0x82843DE0..0x82843E6C)
	// 82843DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843DEC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843DF0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843DF4: 4BFFF5CD  bl 0x828433c0
	ctx.lr = 0x82843DF8;
	sub_828433C0(ctx, base);
	// 82843DF8: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843DFC: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843E00: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 82843E04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82843E08: 394ADA04  addi r10, r10, -0x25fc
	ctx.r[10].s64 = ctx.r[10].s64 + -9724;
	// 82843E0C: 3929D9F0  addi r9, r9, -0x2610
	ctx.r[9].s64 = ctx.r[9].s64 + -9744;
	// 82843E10: 917F013C  stw r11, 0x13c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82843E14: 3908D9A4  addi r8, r8, -0x265c
	ctx.r[8].s64 = ctx.r[8].s64 + -9820;
	// 82843E18: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82843E1C: 913F0028  stw r9, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82843E20: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843E24: 911F00E8  stw r8, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[8].u32 ) };
	// 82843E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843E2C: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82843E30: 388AD984  addi r4, r10, -0x267c
	ctx.r[4].s64 = ctx.r[10].s64 + -9852;
	// 82843E34: 4BA854BD  bl 0x822c92f0
	ctx.lr = 0x82843E38;
	sub_822C92F0(ctx, base);
	// 82843E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843E3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843E40: 4BE53351  bl 0x82697190
	ctx.lr = 0x82843E44;
	sub_82697190(ctx, base);
	// 82843E44: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843E48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843E4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843E50: 4BA84FE1  bl 0x822c8e30
	ctx.lr = 0x82843E54;
	sub_822C8E30(ctx, base);
	// 82843E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843E58: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843E5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843E60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843E70 size=128
    let mut pc: u32 = 0x82843E70;
    'dispatch: loop {
        match pc {
            0x82843E70 => {
    //   block [0x82843E70..0x82843EF0)
	// 82843E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843E78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843E7C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843E80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843E84: 4BFFF53D  bl 0x828433c0
	ctx.lr = 0x82843E88;
	sub_828433C0(ctx, base);
	// 82843E88: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843E8C: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843E90: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843E94: 396BDAD4  addi r11, r11, -0x252c
	ctx.r[11].s64 = ctx.r[11].s64 + -9516;
	// 82843E98: 394ADAC0  addi r10, r10, -0x2540
	ctx.r[10].s64 = ctx.r[10].s64 + -9536;
	// 82843E9C: 3929DA74  addi r9, r9, -0x258c
	ctx.r[9].s64 = ctx.r[9].s64 + -9612;
	// 82843EA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843EA4: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843EA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843EAC: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843EB0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843EB4: 388BDA54  addi r4, r11, -0x25ac
	ctx.r[4].s64 = ctx.r[11].s64 + -9644;
	// 82843EB8: 4BA85439  bl 0x822c92f0
	ctx.lr = 0x82843EBC;
	sub_822C92F0(ctx, base);
	// 82843EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843EC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843EC4: 4BE532CD  bl 0x82697190
	ctx.lr = 0x82843EC8;
	sub_82697190(ctx, base);
	// 82843EC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843ECC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843ED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843ED4: 4BA84F5D  bl 0x822c8e30
	ctx.lr = 0x82843ED8;
	sub_822C8E30(ctx, base);
	// 82843ED8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843EDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843EE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843EE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843EE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843EEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82843EF0 size=8
    let mut pc: u32 = 0x82843EF0;
    'dispatch: loop {
        match pc {
            0x82843EF0 => {
    //   block [0x82843EF0..0x82843EF8)
	// 82843EF0: 3863FF18  addi r3, r3, -0xe8
	ctx.r[3].s64 = ctx.r[3].s64 + -232;
	// 82843EF4: 4BFFFC2C  b 0x82843b20
	sub_82843B20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82843EF8 size=128
    let mut pc: u32 = 0x82843EF8;
    'dispatch: loop {
        match pc {
            0x82843EF8 => {
    //   block [0x82843EF8..0x82843F78)
	// 82843EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82843F00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82843F04: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843F08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843F0C: 4BFFF4B5  bl 0x828433c0
	ctx.lr = 0x82843F10;
	sub_828433C0(ctx, base);
	// 82843F10: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843F14: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82843F18: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 82843F1C: 396BDBA4  addi r11, r11, -0x245c
	ctx.r[11].s64 = ctx.r[11].s64 + -9308;
	// 82843F20: 394ADB90  addi r10, r10, -0x2470
	ctx.r[10].s64 = ctx.r[10].s64 + -9328;
	// 82843F24: 3929DB44  addi r9, r9, -0x24bc
	ctx.r[9].s64 = ctx.r[9].s64 + -9404;
	// 82843F28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82843F2C: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82843F30: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843F34: 913F00E8  stw r9, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[9].u32 ) };
	// 82843F38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843F3C: 388BDB24  addi r4, r11, -0x24dc
	ctx.r[4].s64 = ctx.r[11].s64 + -9436;
	// 82843F40: 4BA853B1  bl 0x822c92f0
	ctx.lr = 0x82843F44;
	sub_822C92F0(ctx, base);
	// 82843F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843F48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82843F4C: 4BE53245  bl 0x82697190
	ctx.lr = 0x82843F50;
	sub_82697190(ctx, base);
	// 82843F50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82843F54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82843F58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82843F5C: 4BA84ED5  bl 0x822c8e30
	ctx.lr = 0x82843F60;
	sub_822C8E30(ctx, base);
	// 82843F60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82843F64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82843F68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82843F6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82843F70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82843F74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82843F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82843F78 size=400
    let mut pc: u32 = 0x82843F78;
    'dispatch: loop {
        match pc {
            0x82843F78 => {
    //   block [0x82843F78..0x82844108)
	// 82843F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82843F7C: 489641ED  bl 0x831a8168
	ctx.lr = 0x82843F80;
	sub_831A8130(ctx, base);
	// 82843F80: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82843F84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82843F88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82843F8C: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 82843F90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82843F94: 38A000AA  li r5, 0xaa
	ctx.r[5].s64 = 170;
	// 82843F98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82843F9C: 3860013C  li r3, 0x13c
	ctx.r[3].s64 = 316;
	// 82843FA0: 485AE449  bl 0x82df23e8
	ctx.lr = 0x82843FA4;
	sub_82DF23E8(ctx, base);
	// 82843FA4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82843FA8: 41820010  beq 0x82843fb8
	if ctx.cr[0].eq {
	pc = 0x82843FB8; continue 'dispatch;
	}
	// 82843FAC: 4BFFFBE5  bl 0x82843b90
	ctx.lr = 0x82843FB0;
	sub_82843B90(ctx, base);
	// 82843FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82843FB4: 48000008  b 0x82843fbc
	pc = 0x82843FBC; continue 'dispatch;
	// 82843FB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82843FBC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82843FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82843FC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82843FC8: 4BFFE5F9  bl 0x828425c0
	ctx.lr = 0x82843FCC;
	sub_828425C0(ctx, base);
	// 82843FCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82843FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82843FD4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82843FD8: 4BA7C029  bl 0x822c0000
	ctx.lr = 0x82843FDC;
	sub_822C0000(ctx, base);
	// 82843FDC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82843FE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82843FE4: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82843FE8: 409A0008  bne cr6, 0x82843ff0
	if !ctx.cr[6].eq {
	pc = 0x82843FF0; continue 'dispatch;
	}
	// 82843FEC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82843FF0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82843FF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82843FF8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82843FFC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82844000: 419A0024  beq cr6, 0x82844024
	if ctx.cr[6].eq {
	pc = 0x82844024; continue 'dispatch;
	}
	// 82844004: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844008: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8284400C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844010: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82844014: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82844018: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284401C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844020: 4082FFE8  bne 0x82844008
	if !ctx.cr[0].eq {
	pc = 0x82844008; continue 'dispatch;
	}
	// 82844024: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82844028: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284402C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82844030: 419A0024  beq cr6, 0x82844054
	if ctx.cr[6].eq {
	pc = 0x82844054; continue 'dispatch;
	}
	// 82844034: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844038: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284403C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844040: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82844044: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82844048: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284404C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844050: 4082FFE8  bne 0x82844038
	if !ctx.cr[0].eq {
	pc = 0x82844038; continue 'dispatch;
	}
	// 82844054: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82844058: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8284405C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82844060: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82844064: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82844068: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8284406C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82844074: 4BF54EBD  bl 0x82798f30
	ctx.lr = 0x82844078;
	sub_82798F30(ctx, base);
	// 82844078: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284407C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844080: 38A000AC  li r5, 0xac
	ctx.r[5].s64 = 172;
	// 82844084: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82844088: 4BA7C351  bl 0x822c03d8
	ctx.lr = 0x8284408C;
	sub_822C03D8(ctx, base);
	// 8284408C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844090: 41820014  beq 0x828440a4
	if ctx.cr[0].eq {
	pc = 0x828440A4; continue 'dispatch;
	}
	// 82844094: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82844098: 4BF575D1  bl 0x8279b668
	ctx.lr = 0x8284409C;
	sub_8279B668(ctx, base);
	// 8284409C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828440A0: 48000008  b 0x828440a8
	pc = 0x828440A8; continue 'dispatch;
	// 828440A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828440A8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828440AC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828440B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828440B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828440B8: 4BD53B99  bl 0x82597c50
	ctx.lr = 0x828440BC;
	sub_82597C50(ctx, base);
	// 828440BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828440C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828440C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828440C8: 4BA7BF39  bl 0x822c0000
	ctx.lr = 0x828440CC;
	sub_822C0000(ctx, base);
	// 828440CC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828440D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828440D4: 419A0008  beq cr6, 0x828440dc
	if ctx.cr[6].eq {
	pc = 0x828440DC; continue 'dispatch;
	}
	// 828440D8: 4BA7C7B9  bl 0x822c0890
	ctx.lr = 0x828440DC;
	sub_822C0890(ctx, base);
	// 828440DC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828440E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828440E4: 419A0008  beq cr6, 0x828440ec
	if ctx.cr[6].eq {
	pc = 0x828440EC; continue 'dispatch;
	}
	// 828440E8: 4BA7C7A9  bl 0x822c0890
	ctx.lr = 0x828440EC;
	sub_822C0890(ctx, base);
	// 828440EC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828440F0: 419A000C  beq cr6, 0x828440fc
	if ctx.cr[6].eq {
	pc = 0x828440FC; continue 'dispatch;
	}
	// 828440F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828440F8: 4BA7C799  bl 0x822c0890
	ctx.lr = 0x828440FC;
	sub_822C0890(ctx, base);
	// 828440FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82844100: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82844104: 489640B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82844108 size=400
    let mut pc: u32 = 0x82844108;
    'dispatch: loop {
        match pc {
            0x82844108 => {
    //   block [0x82844108..0x82844298)
	// 82844108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284410C: 4896405D  bl 0x831a8168
	ctx.lr = 0x82844110;
	sub_831A8130(ctx, base);
	// 82844110: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844114: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82844118: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8284411C: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 82844120: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844124: 38A000D3  li r5, 0xd3
	ctx.r[5].s64 = 211;
	// 82844128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284412C: 38600140  li r3, 0x140
	ctx.r[3].s64 = 320;
	// 82844130: 485AE2B9  bl 0x82df23e8
	ctx.lr = 0x82844134;
	sub_82DF23E8(ctx, base);
	// 82844134: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844138: 41820010  beq 0x82844148
	if ctx.cr[0].eq {
	pc = 0x82844148; continue 'dispatch;
	}
	// 8284413C: 4BFFFAD5  bl 0x82843c10
	ctx.lr = 0x82844140;
	sub_82843C10(ctx, base);
	// 82844140: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844144: 48000008  b 0x8284414c
	pc = 0x8284414C; continue 'dispatch;
	// 82844148: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8284414C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82844150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844154: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844158: 4BFFE531  bl 0x82842688
	ctx.lr = 0x8284415C;
	sub_82842688(ctx, base);
	// 8284415C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844164: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844168: 4BA7BE99  bl 0x822c0000
	ctx.lr = 0x8284416C;
	sub_822C0000(ctx, base);
	// 8284416C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82844170: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82844174: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82844178: 409A0008  bne cr6, 0x82844180
	if !ctx.cr[6].eq {
	pc = 0x82844180; continue 'dispatch;
	}
	// 8284417C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82844180: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82844184: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82844188: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284418C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82844190: 419A0024  beq cr6, 0x828441b4
	if ctx.cr[6].eq {
	pc = 0x828441B4; continue 'dispatch;
	}
	// 82844194: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844198: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8284419C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828441A0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828441A4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828441A8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828441AC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828441B0: 4082FFE8  bne 0x82844198
	if !ctx.cr[0].eq {
	pc = 0x82844198; continue 'dispatch;
	}
	// 828441B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828441B8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828441BC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828441C0: 419A0024  beq cr6, 0x828441e4
	if ctx.cr[6].eq {
	pc = 0x828441E4; continue 'dispatch;
	}
	// 828441C4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828441C8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828441CC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828441D0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828441D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828441D8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828441DC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828441E0: 4082FFE8  bne 0x828441c8
	if !ctx.cr[0].eq {
	pc = 0x828441C8; continue 'dispatch;
	}
	// 828441E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828441E8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828441EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828441F0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 828441F4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828441F8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828441FC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82844204: 4BF54D2D  bl 0x82798f30
	ctx.lr = 0x82844208;
	sub_82798F30(ctx, base);
	// 82844208: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284420C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844210: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 82844214: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82844218: 4BA7C1C1  bl 0x822c03d8
	ctx.lr = 0x8284421C;
	sub_822C03D8(ctx, base);
	// 8284421C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844220: 41820014  beq 0x82844234
	if ctx.cr[0].eq {
	pc = 0x82844234; continue 'dispatch;
	}
	// 82844224: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82844228: 4BF57441  bl 0x8279b668
	ctx.lr = 0x8284422C;
	sub_8279B668(ctx, base);
	// 8284422C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844230: 48000008  b 0x82844238
	pc = 0x82844238; continue 'dispatch;
	// 82844234: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82844238: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8284423C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82844240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844248: 4BD53A09  bl 0x82597c50
	ctx.lr = 0x8284424C;
	sub_82597C50(ctx, base);
	// 8284424C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844250: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844258: 4BA7BDA9  bl 0x822c0000
	ctx.lr = 0x8284425C;
	sub_822C0000(ctx, base);
	// 8284425C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82844260: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844264: 419A0008  beq cr6, 0x8284426c
	if ctx.cr[6].eq {
	pc = 0x8284426C; continue 'dispatch;
	}
	// 82844268: 4BA7C629  bl 0x822c0890
	ctx.lr = 0x8284426C;
	sub_822C0890(ctx, base);
	// 8284426C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82844270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844274: 419A0008  beq cr6, 0x8284427c
	if ctx.cr[6].eq {
	pc = 0x8284427C; continue 'dispatch;
	}
	// 82844278: 4BA7C619  bl 0x822c0890
	ctx.lr = 0x8284427C;
	sub_822C0890(ctx, base);
	// 8284427C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82844280: 419A000C  beq cr6, 0x8284428c
	if ctx.cr[6].eq {
	pc = 0x8284428C; continue 'dispatch;
	}
	// 82844284: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844288: 4BA7C609  bl 0x822c0890
	ctx.lr = 0x8284428C;
	sub_822C0890(ctx, base);
	// 8284428C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82844290: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82844294: 48963F24  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82844298 size=400
    let mut pc: u32 = 0x82844298;
    'dispatch: loop {
        match pc {
            0x82844298 => {
    //   block [0x82844298..0x82844428)
	// 82844298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284429C: 48963ECD  bl 0x831a8168
	ctx.lr = 0x828442A0;
	sub_831A8130(ctx, base);
	// 828442A0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828442A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828442A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828442AC: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 828442B0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828442B4: 38A00105  li r5, 0x105
	ctx.r[5].s64 = 261;
	// 828442B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828442BC: 3860013C  li r3, 0x13c
	ctx.r[3].s64 = 316;
	// 828442C0: 485AE129  bl 0x82df23e8
	ctx.lr = 0x828442C4;
	sub_82DF23E8(ctx, base);
	// 828442C4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828442C8: 41820010  beq 0x828442d8
	if ctx.cr[0].eq {
	pc = 0x828442D8; continue 'dispatch;
	}
	// 828442CC: 4BFFF9E5  bl 0x82843cb0
	ctx.lr = 0x828442D0;
	sub_82843CB0(ctx, base);
	// 828442D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828442D4: 48000008  b 0x828442dc
	pc = 0x828442DC; continue 'dispatch;
	// 828442D8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828442DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 828442E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828442E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828442E8: 4BFFE469  bl 0x82842750
	ctx.lr = 0x828442EC;
	sub_82842750(ctx, base);
	// 828442EC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828442F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828442F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828442F8: 4BA7BD09  bl 0x822c0000
	ctx.lr = 0x828442FC;
	sub_822C0000(ctx, base);
	// 828442FC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82844300: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82844304: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82844308: 409A0008  bne cr6, 0x82844310
	if !ctx.cr[6].eq {
	pc = 0x82844310; continue 'dispatch;
	}
	// 8284430C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82844310: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82844314: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82844318: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284431C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82844320: 419A0024  beq cr6, 0x82844344
	if ctx.cr[6].eq {
	pc = 0x82844344; continue 'dispatch;
	}
	// 82844324: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844328: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8284432C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844330: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82844334: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82844338: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284433C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844340: 4082FFE8  bne 0x82844328
	if !ctx.cr[0].eq {
	pc = 0x82844328; continue 'dispatch;
	}
	// 82844344: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82844348: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284434C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82844350: 419A0024  beq cr6, 0x82844374
	if ctx.cr[6].eq {
	pc = 0x82844374; continue 'dispatch;
	}
	// 82844354: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844358: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284435C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844360: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82844364: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82844368: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284436C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844370: 4082FFE8  bne 0x82844358
	if !ctx.cr[0].eq {
	pc = 0x82844358; continue 'dispatch;
	}
	// 82844374: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82844378: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8284437C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82844380: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82844384: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82844388: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8284438C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844390: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82844394: 4BF54B9D  bl 0x82798f30
	ctx.lr = 0x82844398;
	sub_82798F30(ctx, base);
	// 82844398: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284439C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828443A0: 38A00107  li r5, 0x107
	ctx.r[5].s64 = 263;
	// 828443A4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828443A8: 4BA7C031  bl 0x822c03d8
	ctx.lr = 0x828443AC;
	sub_822C03D8(ctx, base);
	// 828443AC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828443B0: 41820014  beq 0x828443c4
	if ctx.cr[0].eq {
	pc = 0x828443C4; continue 'dispatch;
	}
	// 828443B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828443B8: 4BF572B1  bl 0x8279b668
	ctx.lr = 0x828443BC;
	sub_8279B668(ctx, base);
	// 828443BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828443C0: 48000008  b 0x828443c8
	pc = 0x828443C8; continue 'dispatch;
	// 828443C4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828443C8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828443CC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828443D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828443D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828443D8: 4BD53879  bl 0x82597c50
	ctx.lr = 0x828443DC;
	sub_82597C50(ctx, base);
	// 828443DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828443E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828443E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828443E8: 4BA7BC19  bl 0x822c0000
	ctx.lr = 0x828443EC;
	sub_822C0000(ctx, base);
	// 828443EC: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828443F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828443F4: 419A0008  beq cr6, 0x828443fc
	if ctx.cr[6].eq {
	pc = 0x828443FC; continue 'dispatch;
	}
	// 828443F8: 4BA7C499  bl 0x822c0890
	ctx.lr = 0x828443FC;
	sub_822C0890(ctx, base);
	// 828443FC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82844400: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844404: 419A0008  beq cr6, 0x8284440c
	if ctx.cr[6].eq {
	pc = 0x8284440C; continue 'dispatch;
	}
	// 82844408: 4BA7C489  bl 0x822c0890
	ctx.lr = 0x8284440C;
	sub_822C0890(ctx, base);
	// 8284440C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82844410: 419A000C  beq cr6, 0x8284441c
	if ctx.cr[6].eq {
	pc = 0x8284441C; continue 'dispatch;
	}
	// 82844414: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844418: 4BA7C479  bl 0x822c0890
	ctx.lr = 0x8284441C;
	sub_822C0890(ctx, base);
	// 8284441C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82844420: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82844424: 48963D94  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82844428 size=400
    let mut pc: u32 = 0x82844428;
    'dispatch: loop {
        match pc {
            0x82844428 => {
    //   block [0x82844428..0x828445B8)
	// 82844428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284442C: 48963D3D  bl 0x831a8168
	ctx.lr = 0x82844430;
	sub_831A8130(ctx, base);
	// 82844430: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844434: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82844438: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8284443C: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 82844440: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844444: 38A00126  li r5, 0x126
	ctx.r[5].s64 = 294;
	// 82844448: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284444C: 3860013C  li r3, 0x13c
	ctx.r[3].s64 = 316;
	// 82844450: 485ADF99  bl 0x82df23e8
	ctx.lr = 0x82844454;
	sub_82DF23E8(ctx, base);
	// 82844454: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844458: 41820010  beq 0x82844468
	if ctx.cr[0].eq {
	pc = 0x82844468; continue 'dispatch;
	}
	// 8284445C: 4BFFF8ED  bl 0x82843d48
	ctx.lr = 0x82844460;
	sub_82843D48(ctx, base);
	// 82844460: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844464: 48000008  b 0x8284446c
	pc = 0x8284446C; continue 'dispatch;
	// 82844468: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8284446C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82844470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844478: 4BFFE3A1  bl 0x82842818
	ctx.lr = 0x8284447C;
	sub_82842818(ctx, base);
	// 8284447C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844480: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844484: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844488: 4BA7BB79  bl 0x822c0000
	ctx.lr = 0x8284448C;
	sub_822C0000(ctx, base);
	// 8284448C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82844490: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82844494: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82844498: 409A0008  bne cr6, 0x828444a0
	if !ctx.cr[6].eq {
	pc = 0x828444A0; continue 'dispatch;
	}
	// 8284449C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828444A0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828444A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828444A8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828444AC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828444B0: 419A0024  beq cr6, 0x828444d4
	if ctx.cr[6].eq {
	pc = 0x828444D4; continue 'dispatch;
	}
	// 828444B4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828444B8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828444BC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828444C0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828444C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828444C8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828444CC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828444D0: 4082FFE8  bne 0x828444b8
	if !ctx.cr[0].eq {
	pc = 0x828444B8; continue 'dispatch;
	}
	// 828444D4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828444D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828444DC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 828444E0: 419A0024  beq cr6, 0x82844504
	if ctx.cr[6].eq {
	pc = 0x82844504; continue 'dispatch;
	}
	// 828444E4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828444E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 828444EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828444F0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828444F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828444F8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828444FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844500: 4082FFE8  bne 0x828444e8
	if !ctx.cr[0].eq {
	pc = 0x828444E8; continue 'dispatch;
	}
	// 82844504: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82844508: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8284450C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82844510: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82844514: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82844518: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8284451C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844520: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82844524: 4BF54A0D  bl 0x82798f30
	ctx.lr = 0x82844528;
	sub_82798F30(ctx, base);
	// 82844528: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284452C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844530: 38A00128  li r5, 0x128
	ctx.r[5].s64 = 296;
	// 82844534: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82844538: 4BA7BEA1  bl 0x822c03d8
	ctx.lr = 0x8284453C;
	sub_822C03D8(ctx, base);
	// 8284453C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844540: 41820014  beq 0x82844554
	if ctx.cr[0].eq {
	pc = 0x82844554; continue 'dispatch;
	}
	// 82844544: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82844548: 4BF57121  bl 0x8279b668
	ctx.lr = 0x8284454C;
	sub_8279B668(ctx, base);
	// 8284454C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844550: 48000008  b 0x82844558
	pc = 0x82844558; continue 'dispatch;
	// 82844554: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82844558: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8284455C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82844560: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844568: 4BD536E9  bl 0x82597c50
	ctx.lr = 0x8284456C;
	sub_82597C50(ctx, base);
	// 8284456C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844570: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844578: 4BA7BA89  bl 0x822c0000
	ctx.lr = 0x8284457C;
	sub_822C0000(ctx, base);
	// 8284457C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82844580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844584: 419A0008  beq cr6, 0x8284458c
	if ctx.cr[6].eq {
	pc = 0x8284458C; continue 'dispatch;
	}
	// 82844588: 4BA7C309  bl 0x822c0890
	ctx.lr = 0x8284458C;
	sub_822C0890(ctx, base);
	// 8284458C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82844590: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844594: 419A0008  beq cr6, 0x8284459c
	if ctx.cr[6].eq {
	pc = 0x8284459C; continue 'dispatch;
	}
	// 82844598: 4BA7C2F9  bl 0x822c0890
	ctx.lr = 0x8284459C;
	sub_822C0890(ctx, base);
	// 8284459C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828445A0: 419A000C  beq cr6, 0x828445ac
	if ctx.cr[6].eq {
	pc = 0x828445AC; continue 'dispatch;
	}
	// 828445A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828445A8: 4BA7C2E9  bl 0x822c0890
	ctx.lr = 0x828445AC;
	sub_822C0890(ctx, base);
	// 828445AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828445B0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828445B4: 48963C04  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828445B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828445B8 size=400
    let mut pc: u32 = 0x828445B8;
    'dispatch: loop {
        match pc {
            0x828445B8 => {
    //   block [0x828445B8..0x82844748)
	// 828445B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828445BC: 48963BAD  bl 0x831a8168
	ctx.lr = 0x828445C0;
	sub_831A8130(ctx, base);
	// 828445C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828445C4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828445C8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828445CC: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 828445D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828445D4: 38A00147  li r5, 0x147
	ctx.r[5].s64 = 327;
	// 828445D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828445DC: 38600144  li r3, 0x144
	ctx.r[3].s64 = 324;
	// 828445E0: 485ADE09  bl 0x82df23e8
	ctx.lr = 0x828445E4;
	sub_82DF23E8(ctx, base);
	// 828445E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828445E8: 41820010  beq 0x828445f8
	if ctx.cr[0].eq {
	pc = 0x828445F8; continue 'dispatch;
	}
	// 828445EC: 4BFFF7F5  bl 0x82843de0
	ctx.lr = 0x828445F0;
	sub_82843DE0(ctx, base);
	// 828445F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828445F4: 48000008  b 0x828445fc
	pc = 0x828445FC; continue 'dispatch;
	// 828445F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828445FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82844600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844604: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844608: 4BFFE2D9  bl 0x828428e0
	ctx.lr = 0x8284460C;
	sub_828428E0(ctx, base);
	// 8284460C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844614: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844618: 4BA7B9E9  bl 0x822c0000
	ctx.lr = 0x8284461C;
	sub_822C0000(ctx, base);
	// 8284461C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82844620: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82844624: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82844628: 409A0008  bne cr6, 0x82844630
	if !ctx.cr[6].eq {
	pc = 0x82844630; continue 'dispatch;
	}
	// 8284462C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82844630: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82844634: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82844638: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284463C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82844640: 419A0024  beq cr6, 0x82844664
	if ctx.cr[6].eq {
	pc = 0x82844664; continue 'dispatch;
	}
	// 82844644: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844648: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8284464C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844650: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82844654: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82844658: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284465C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844660: 4082FFE8  bne 0x82844648
	if !ctx.cr[0].eq {
	pc = 0x82844648; continue 'dispatch;
	}
	// 82844664: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82844668: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284466C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82844670: 419A0024  beq cr6, 0x82844694
	if ctx.cr[6].eq {
	pc = 0x82844694; continue 'dispatch;
	}
	// 82844674: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844678: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284467C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844680: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82844684: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82844688: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284468C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844690: 4082FFE8  bne 0x82844678
	if !ctx.cr[0].eq {
	pc = 0x82844678; continue 'dispatch;
	}
	// 82844694: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82844698: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8284469C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828446A0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 828446A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828446A8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828446AC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828446B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828446B4: 4BF5487D  bl 0x82798f30
	ctx.lr = 0x828446B8;
	sub_82798F30(ctx, base);
	// 828446B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828446BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828446C0: 38A00149  li r5, 0x149
	ctx.r[5].s64 = 329;
	// 828446C4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828446C8: 4BA7BD11  bl 0x822c03d8
	ctx.lr = 0x828446CC;
	sub_822C03D8(ctx, base);
	// 828446CC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828446D0: 41820014  beq 0x828446e4
	if ctx.cr[0].eq {
	pc = 0x828446E4; continue 'dispatch;
	}
	// 828446D4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828446D8: 4BF56F91  bl 0x8279b668
	ctx.lr = 0x828446DC;
	sub_8279B668(ctx, base);
	// 828446DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828446E0: 48000008  b 0x828446e8
	pc = 0x828446E8; continue 'dispatch;
	// 828446E4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 828446E8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 828446EC: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 828446F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828446F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828446F8: 4BD53559  bl 0x82597c50
	ctx.lr = 0x828446FC;
	sub_82597C50(ctx, base);
	// 828446FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844704: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844708: 4BA7B8F9  bl 0x822c0000
	ctx.lr = 0x8284470C;
	sub_822C0000(ctx, base);
	// 8284470C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82844710: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844714: 419A0008  beq cr6, 0x8284471c
	if ctx.cr[6].eq {
	pc = 0x8284471C; continue 'dispatch;
	}
	// 82844718: 4BA7C179  bl 0x822c0890
	ctx.lr = 0x8284471C;
	sub_822C0890(ctx, base);
	// 8284471C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82844720: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844724: 419A0008  beq cr6, 0x8284472c
	if ctx.cr[6].eq {
	pc = 0x8284472C; continue 'dispatch;
	}
	// 82844728: 4BA7C169  bl 0x822c0890
	ctx.lr = 0x8284472C;
	sub_822C0890(ctx, base);
	// 8284472C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82844730: 419A000C  beq cr6, 0x8284473c
	if ctx.cr[6].eq {
	pc = 0x8284473C; continue 'dispatch;
	}
	// 82844734: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844738: 4BA7C159  bl 0x822c0890
	ctx.lr = 0x8284473C;
	sub_822C0890(ctx, base);
	// 8284473C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82844740: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82844744: 48963A74  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82844748 size=400
    let mut pc: u32 = 0x82844748;
    'dispatch: loop {
        match pc {
            0x82844748 => {
    //   block [0x82844748..0x828448D8)
	// 82844748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8284474C: 48963A1D  bl 0x831a8168
	ctx.lr = 0x82844750;
	sub_831A8130(ctx, base);
	// 82844750: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844754: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82844758: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8284475C: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 82844760: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844764: 38A0017D  li r5, 0x17d
	ctx.r[5].s64 = 381;
	// 82844768: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284476C: 3860013C  li r3, 0x13c
	ctx.r[3].s64 = 316;
	// 82844770: 485ADC79  bl 0x82df23e8
	ctx.lr = 0x82844774;
	sub_82DF23E8(ctx, base);
	// 82844774: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844778: 41820010  beq 0x82844788
	if ctx.cr[0].eq {
	pc = 0x82844788; continue 'dispatch;
	}
	// 8284477C: 4BFFF6F5  bl 0x82843e70
	ctx.lr = 0x82844780;
	sub_82843E70(ctx, base);
	// 82844780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844784: 48000008  b 0x8284478c
	pc = 0x8284478C; continue 'dispatch;
	// 82844788: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8284478C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82844790: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844794: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844798: 4BFFE211  bl 0x828429a8
	ctx.lr = 0x8284479C;
	sub_828429A8(ctx, base);
	// 8284479C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828447A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828447A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828447A8: 4BA7B859  bl 0x822c0000
	ctx.lr = 0x828447AC;
	sub_822C0000(ctx, base);
	// 828447AC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 828447B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828447B4: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 828447B8: 409A0008  bne cr6, 0x828447c0
	if !ctx.cr[6].eq {
	pc = 0x828447C0; continue 'dispatch;
	}
	// 828447BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828447C0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828447C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828447C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828447CC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 828447D0: 419A0024  beq cr6, 0x828447f4
	if ctx.cr[6].eq {
	pc = 0x828447F4; continue 'dispatch;
	}
	// 828447D4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 828447D8: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 828447DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828447E0: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 828447E4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 828447E8: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828447EC: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828447F0: 4082FFE8  bne 0x828447d8
	if !ctx.cr[0].eq {
	pc = 0x828447D8; continue 'dispatch;
	}
	// 828447F4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 828447F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828447FC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82844800: 419A0024  beq cr6, 0x82844824
	if ctx.cr[6].eq {
	pc = 0x82844824; continue 'dispatch;
	}
	// 82844804: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844808: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284480C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844810: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82844814: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82844818: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284481C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844820: 4082FFE8  bne 0x82844808
	if !ctx.cr[0].eq {
	pc = 0x82844808; continue 'dispatch;
	}
	// 82844824: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82844828: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 8284482C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82844830: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 82844834: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82844838: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8284483C: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844840: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82844844: 4BF546ED  bl 0x82798f30
	ctx.lr = 0x82844848;
	sub_82798F30(ctx, base);
	// 82844848: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8284484C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844850: 38A0017F  li r5, 0x17f
	ctx.r[5].s64 = 383;
	// 82844854: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82844858: 4BA7BB81  bl 0x822c03d8
	ctx.lr = 0x8284485C;
	sub_822C03D8(ctx, base);
	// 8284485C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844860: 41820014  beq 0x82844874
	if ctx.cr[0].eq {
	pc = 0x82844874; continue 'dispatch;
	}
	// 82844864: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82844868: 4BF56E01  bl 0x8279b668
	ctx.lr = 0x8284486C;
	sub_8279B668(ctx, base);
	// 8284486C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844870: 48000008  b 0x82844878
	pc = 0x82844878; continue 'dispatch;
	// 82844874: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82844878: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 8284487C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82844880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844888: 4BD533C9  bl 0x82597c50
	ctx.lr = 0x8284488C;
	sub_82597C50(ctx, base);
	// 8284488C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844890: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844894: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844898: 4BA7B769  bl 0x822c0000
	ctx.lr = 0x8284489C;
	sub_822C0000(ctx, base);
	// 8284489C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 828448A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828448A4: 419A0008  beq cr6, 0x828448ac
	if ctx.cr[6].eq {
	pc = 0x828448AC; continue 'dispatch;
	}
	// 828448A8: 4BA7BFE9  bl 0x822c0890
	ctx.lr = 0x828448AC;
	sub_822C0890(ctx, base);
	// 828448AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 828448B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828448B4: 419A0008  beq cr6, 0x828448bc
	if ctx.cr[6].eq {
	pc = 0x828448BC; continue 'dispatch;
	}
	// 828448B8: 4BA7BFD9  bl 0x822c0890
	ctx.lr = 0x828448BC;
	sub_822C0890(ctx, base);
	// 828448BC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828448C0: 419A000C  beq cr6, 0x828448cc
	if ctx.cr[6].eq {
	pc = 0x828448CC; continue 'dispatch;
	}
	// 828448C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828448C8: 4BA7BFC9  bl 0x822c0890
	ctx.lr = 0x828448CC;
	sub_822C0890(ctx, base);
	// 828448CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828448D0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 828448D4: 489638E4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828448D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828448D8 size=400
    let mut pc: u32 = 0x828448D8;
    'dispatch: loop {
        match pc {
            0x828448D8 => {
    //   block [0x828448D8..0x82844A68)
	// 828448D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828448DC: 4896388D  bl 0x831a8168
	ctx.lr = 0x828448E0;
	sub_831A8130(ctx, base);
	// 828448E0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828448E4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 828448E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828448EC: 3BCBD4B0  addi r30, r11, -0x2b50
	ctx.r[30].s64 = ctx.r[11].s64 + -11088;
	// 828448F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828448F4: 38A00199  li r5, 0x199
	ctx.r[5].s64 = 409;
	// 828448F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828448FC: 3860013C  li r3, 0x13c
	ctx.r[3].s64 = 316;
	// 82844900: 485ADAE9  bl 0x82df23e8
	ctx.lr = 0x82844904;
	sub_82DF23E8(ctx, base);
	// 82844904: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82844908: 41820010  beq 0x82844918
	if ctx.cr[0].eq {
	pc = 0x82844918; continue 'dispatch;
	}
	// 8284490C: 4BFFF5ED  bl 0x82843ef8
	ctx.lr = 0x82844910;
	sub_82843EF8(ctx, base);
	// 82844910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844914: 48000008  b 0x8284491c
	pc = 0x8284491C; continue 'dispatch;
	// 82844918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8284491C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82844920: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844924: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844928: 4BFFE149  bl 0x82842a70
	ctx.lr = 0x8284492C;
	sub_82842A70(ctx, base);
	// 8284492C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844934: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844938: 4BA7B6C9  bl 0x822c0000
	ctx.lr = 0x8284493C;
	sub_822C0000(ctx, base);
	// 8284493C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82844940: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82844944: 396A00E8  addi r11, r10, 0xe8
	ctx.r[11].s64 = ctx.r[10].s64 + 232;
	// 82844948: 409A0008  bne cr6, 0x82844950
	if !ctx.cr[6].eq {
	pc = 0x82844950; continue 'dispatch;
	}
	// 8284494C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82844950: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82844954: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82844958: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284495C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82844960: 419A0024  beq cr6, 0x82844984
	if ctx.cr[6].eq {
	pc = 0x82844984; continue 'dispatch;
	}
	// 82844964: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844968: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 8284496C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844970: 7D205828  lwarx r9, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82844974: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82844978: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8284497C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844980: 4082FFE8  bne 0x82844968
	if !ctx.cr[0].eq {
	pc = 0x82844968; continue 'dispatch;
	}
	// 82844984: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82844988: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8284498C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82844990: 419A0024  beq cr6, 0x828449b4
	if ctx.cr[6].eq {
	pc = 0x828449B4; continue 'dispatch;
	}
	// 82844994: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	// 82844998: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8284499C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828449A0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 828449A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 828449A8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828449AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828449B0: 4082FFE8  bne 0x82844998
	if !ctx.cr[0].eq {
	pc = 0x82844998; continue 'dispatch;
	}
	// 828449B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828449B8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 828449BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 828449C0: 38CABA80  addi r6, r10, -0x4580
	ctx.r[6].s64 = ctx.r[10].s64 + -17792;
	// 828449C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 828449C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 828449CC: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 828449D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828449D4: 4BF5455D  bl 0x82798f30
	ctx.lr = 0x828449D8;
	sub_82798F30(ctx, base);
	// 828449D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828449DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 828449E0: 38A0019B  li r5, 0x19b
	ctx.r[5].s64 = 411;
	// 828449E4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828449E8: 4BA7B9F1  bl 0x822c03d8
	ctx.lr = 0x828449EC;
	sub_822C03D8(ctx, base);
	// 828449EC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 828449F0: 41820014  beq 0x82844a04
	if ctx.cr[0].eq {
	pc = 0x82844A04; continue 'dispatch;
	}
	// 828449F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 828449F8: 4BF56C71  bl 0x8279b668
	ctx.lr = 0x828449FC;
	sub_8279B668(ctx, base);
	// 828449FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844A00: 48000008  b 0x82844a08
	pc = 0x82844A08; continue 'dispatch;
	// 82844A04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82844A08: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82844A0C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82844A10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844A14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844A18: 4BD53239  bl 0x82597c50
	ctx.lr = 0x82844A1C;
	sub_82597C50(ctx, base);
	// 82844A1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844A20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82844A24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844A28: 4BA7B5D9  bl 0x822c0000
	ctx.lr = 0x82844A2C;
	sub_822C0000(ctx, base);
	// 82844A2C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82844A30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844A34: 419A0008  beq cr6, 0x82844a3c
	if ctx.cr[6].eq {
	pc = 0x82844A3C; continue 'dispatch;
	}
	// 82844A38: 4BA7BE59  bl 0x822c0890
	ctx.lr = 0x82844A3C;
	sub_822C0890(ctx, base);
	// 82844A3C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82844A40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844A44: 419A0008  beq cr6, 0x82844a4c
	if ctx.cr[6].eq {
	pc = 0x82844A4C; continue 'dispatch;
	}
	// 82844A48: 4BA7BE49  bl 0x822c0890
	ctx.lr = 0x82844A4C;
	sub_822C0890(ctx, base);
	// 82844A4C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82844A50: 419A000C  beq cr6, 0x82844a5c
	if ctx.cr[6].eq {
	pc = 0x82844A5C; continue 'dispatch;
	}
	// 82844A54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844A58: 4BA7BE39  bl 0x822c0890
	ctx.lr = 0x82844A5C;
	sub_822C0890(ctx, base);
	// 82844A5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82844A60: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82844A64: 48963754  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82844A68 size=160
    let mut pc: u32 = 0x82844A68;
    'dispatch: loop {
        match pc {
            0x82844A68 => {
    //   block [0x82844A68..0x82844B08)
	// 82844A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82844A6C: 489636F9  bl 0x831a8164
	ctx.lr = 0x82844A70;
	sub_831A8130(ctx, base);
	// 82844A70: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844A74: 3D608335  lis r11, -0x7ccb
	ctx.r[11].s64 = -2093678592;
	// 82844A78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82844A80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82844A84: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82844A88: 808B67CC  lwz r4, 0x67cc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26572 as u32) ) } as u64;
	// 82844A8C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82844A90: 4BAA04A1  bl 0x822e4f30
	ctx.lr = 0x82844A94;
	sub_822E4F30(ctx, base);
	// 82844A94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82844A98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82844A9C: 4BAA0425  bl 0x822e4ec0
	ctx.lr = 0x82844AA0;
	sub_822E4EC0(ctx, base);
	// 82844AA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82844AA4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82844AA8: E89B0000  ld r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 82844AAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82844AB0: E8630000  ld r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82844AB4: 4BC477D5  bl 0x8248c288
	ctx.lr = 0x82844AB8;
	sub_8248C288(ctx, base);
	// 82844AB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82844ABC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82844AC0: 4BE4F2A1  bl 0x82693d60
	ctx.lr = 0x82844AC4;
	sub_82693D60(ctx, base);
	// 82844AC4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82844AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82844ACC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82844AD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82844AD4: 4BE519BD  bl 0x82696490
	ctx.lr = 0x82844AD8;
	sub_82696490(ctx, base);
	// 82844AD8: 3D608328  lis r11, -0x7cd8
	ctx.r[11].s64 = -2094530560;
	// 82844ADC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82844AE0: 808BE264  lwz r4, -0x1d9c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-7580 as u32) ) } as u64;
	// 82844AE4: 485AEF25  bl 0x82df3a08
	ctx.lr = 0x82844AE8;
	sub_82DF3A08(ctx, base);
	// 82844AE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82844AEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82844AF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844AF4: 4BCC3C8D  bl 0x82508780
	ctx.lr = 0x82844AF8;
	sub_82508780(ctx, base);
	// 82844AF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82844AFC: 485AE92D  bl 0x82df3428
	ctx.lr = 0x82844B00;
	sub_82DF3428(ctx, base);
	// 82844B00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82844B04: 489636B0  b 0x831a81b4
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82844B08 size=348
    let mut pc: u32 = 0x82844B08;
    'dispatch: loop {
        match pc {
            0x82844B08 => {
    //   block [0x82844B08..0x82844C64)
	// 82844B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82844B0C: 48963661  bl 0x831a816c
	ctx.lr = 0x82844B10;
	sub_831A8130(ctx, base);
	// 82844B10: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844B14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82844B18: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82844B1C: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82844B20: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82844B24: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 82844B28: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82844B2C: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82844B30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82844B34: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82844B38: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82844B3C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82844B40: C02B6218  lfs f1, 0x6218(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(25112 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844B44: 4BFD6105  bl 0x8281ac48
	ctx.lr = 0x82844B48;
	sub_8281AC48(ctx, base);
	// 82844B48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82844B4C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844B50: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82844B54: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82844B58: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82844B5C: 4BA7F905  bl 0x822c4460
	ctx.lr = 0x82844B60;
	sub_822C4460(ctx, base);
	// 82844B60: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82844B64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844B68: 419A0008  beq cr6, 0x82844b70
	if ctx.cr[6].eq {
	pc = 0x82844B70; continue 'dispatch;
	}
	// 82844B6C: 4BA7BD25  bl 0x822c0890
	ctx.lr = 0x82844B70;
	sub_822C0890(ctx, base);
	// 82844B70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82844B74: 4BCCCF75  bl 0x82511ae8
	ctx.lr = 0x82844B78;
	sub_82511AE8(ctx, base);
	// 82844B78: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 82844B7C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82844B80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82844B84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82844B88: C02B89AC  lfs f1, -0x7654(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-30292 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844B8C: 4BFD61CD  bl 0x8281ad58
	ctx.lr = 0x82844B90;
	sub_8281AD58(ctx, base);
	// 82844B90: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82844B94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844B98: 419A0008  beq cr6, 0x82844ba0
	if ctx.cr[6].eq {
	pc = 0x82844BA0; continue 'dispatch;
	}
	// 82844B9C: 4BA7BCF5  bl 0x822c0890
	ctx.lr = 0x82844BA0;
	sub_822C0890(ctx, base);
	// 82844BA0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82844BA4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82844BA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82844BAC: 4BFFE635  bl 0x828431e0
	ctx.lr = 0x82844BB0;
	sub_828431E0(ctx, base);
	// 82844BB0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82844BB4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82844BB8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82844BBC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82844BC0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82844BC4: 4BA7F89D  bl 0x822c4460
	ctx.lr = 0x82844BC8;
	sub_822C4460(ctx, base);
	// 82844BC8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82844BCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844BD0: 419A0008  beq cr6, 0x82844bd8
	if ctx.cr[6].eq {
	pc = 0x82844BD8; continue 'dispatch;
	}
	// 82844BD4: 4BA7BCBD  bl 0x822c0890
	ctx.lr = 0x82844BD8;
	sub_822C0890(ctx, base);
	// 82844BD8: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82844BDC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82844BE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82844BE4: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82844BE8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82844BEC: 419A0024  beq cr6, 0x82844c10
	if ctx.cr[6].eq {
	pc = 0x82844C10; continue 'dispatch;
	}
	// 82844BF0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82844BF4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82844BF8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844BFC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82844C00: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82844C04: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82844C08: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82844C0C: 4082FFE8  bne 0x82844bf4
	if !ctx.cr[0].eq {
	pc = 0x82844BF4; continue 'dispatch;
	}
	// 82844C10: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82844C14: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 82844C18: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 82844C1C: 388AD4B0  addi r4, r10, -0x2b50
	ctx.r[4].s64 = ctx.r[10].s64 + -11088;
	// 82844C20: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82844C24: 38A000C7  li r5, 0xc7
	ctx.r[5].s64 = 199;
	// 82844C28: C02B08A4  lfs f1, 0x8a4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2212 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82844C2C: 387E0028  addi r3, r30, 0x28
	ctx.r[3].s64 = ctx.r[30].s64 + 40;
	// 82844C30: 48613E11  bl 0x82e58a40
	ctx.lr = 0x82844C34;
	sub_82E58A40(ctx, base);
	// 82844C34: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82844C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82844C3C: 419A0008  beq cr6, 0x82844c44
	if ctx.cr[6].eq {
	pc = 0x82844C44; continue 'dispatch;
	}
	// 82844C40: 4BA7BC51  bl 0x822c0890
	ctx.lr = 0x82844C44;
	sub_822C0890(ctx, base);
	// 82844C44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82844C48: 419A000C  beq cr6, 0x82844c54
	if ctx.cr[6].eq {
	pc = 0x82844C54; continue 'dispatch;
	}
	// 82844C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82844C50: 4BA7BC41  bl 0x822c0890
	ctx.lr = 0x82844C54;
	sub_822C0890(ctx, base);
	// 82844C54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82844C58: 4BC253A9  bl 0x8246a000
	ctx.lr = 0x82844C5C;
	sub_8246A000(ctx, base);
	// 82844C5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82844C60: 4896355C  b 0x831a81bc
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82844C68 size=4
    let mut pc: u32 = 0x82844C68;
    'dispatch: loop {
        match pc {
            0x82844C68 => {
    //   block [0x82844C68..0x82844C6C)
	// 82844C68: 4BFFFE00  b 0x82844a68
	sub_82844A68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82844C70 size=152
    let mut pc: u32 = 0x82844C70;
    'dispatch: loop {
        match pc {
            0x82844C70 => {
    //   block [0x82844C70..0x82844D08)
	// 82844C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82844C74: 489634F5  bl 0x831a8168
	ctx.lr = 0x82844C78;
	sub_831A8130(ctx, base);
	// 82844C78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844C7C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82844C80: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82844C84: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82844C88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82844C8C: 3BEBB698  addi r31, r11, -0x4968
	ctx.r[31].s64 = ctx.r[11].s64 + -18792;
	// 82844C90: 817C0098  lwz r11, 0x98(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(152 as u32) ) } as u64;
	// 82844C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82844C98: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82844C9C: 4098002C  bge cr6, 0x82844cc8
	if !ctx.cr[6].lt {
	pc = 0x82844CC8; continue 'dispatch;
	}
	// 82844CA0: 485AE511  bl 0x82df31b0
	ctx.lr = 0x82844CA4;
	sub_82DF31B0(ctx, base);
	// 82844CA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82844CA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82844CAC: 485AED5D  bl 0x82df3a08
	ctx.lr = 0x82844CB0;
	sub_82DF3A08(ctx, base);
	// 82844CB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82844CB4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82844CB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844CBC: 4BD5C8CD  bl 0x825a1588
	ctx.lr = 0x82844CC0;
	sub_825A1588(ctx, base);
	// 82844CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82844CC4: 48000028  b 0x82844cec
	pc = 0x82844CEC; continue 'dispatch;
	// 82844CC8: 485AE4E9  bl 0x82df31b0
	ctx.lr = 0x82844CCC;
	sub_82DF31B0(ctx, base);
	// 82844CCC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82844CD0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844CD4: 485AED35  bl 0x82df3a08
	ctx.lr = 0x82844CD8;
	sub_82DF3A08(ctx, base);
	// 82844CD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82844CDC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82844CE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82844CE4: 4BD5C8A5  bl 0x825a1588
	ctx.lr = 0x82844CE8;
	sub_825A1588(ctx, base);
	// 82844CE8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82844CEC: 485AE73D  bl 0x82df3428
	ctx.lr = 0x82844CF0;
	sub_82DF3428(ctx, base);
	// 82844CF0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82844CF4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82844CF8: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 82844CFC: 4198FF94  blt cr6, 0x82844c90
	if ctx.cr[6].lt {
	pc = 0x82844C90; continue 'dispatch;
	}
	// 82844D00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82844D04: 489634B4  b 0x831a81b8
	sub_831A8180(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82844D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82844D08 size=80
    let mut pc: u32 = 0x82844D08;
    'dispatch: loop {
        match pc {
            0x82844D08 => {
    //   block [0x82844D08..0x82844D58)
	// 82844D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82844D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82844D10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82844D14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82844D18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82844D1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82844D20: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82844D24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82844D28: 4BCCAD29  bl 0x8250fa50
	ctx.lr = 0x82844D2C;
	sub_8250FA50(ctx, base);
	// 82844D2C: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 82844D30: 48617969  bl 0x82e5c698
	ctx.lr = 0x82844D34;
	sub_82E5C698(ctx, base);
	// 82844D34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82844D38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82844D3C: 4BCCD32D  bl 0x82512068
	ctx.lr = 0x82844D40;
	sub_82512068(ctx, base);
	// 82844D40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82844D44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82844D48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82844D4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82844D50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82844D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


