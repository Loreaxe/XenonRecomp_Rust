pub fn sub_82F62A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62A10 size=12
    let mut pc: u32 = 0x82F62A10;
    'dispatch: loop {
        match pc {
            0x82F62A10 => {
    //   block [0x82F62A10..0x82F62A1C)
	// 82F62A10: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62A14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82F62A18: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62A1C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62A1C size=44
    let mut pc: u32 = 0x82F62A1C;
    'dispatch: loop {
        match pc {
            0x82F62A1C => {
    //   block [0x82F62A1C..0x82F62A48)
	// 82F62A1C: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62A20: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62A24: 550AD1BE  srwi r10, r8, 6
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F62A28: 7D4A4278  xor r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[8].u64;
	// 82F62A2C: 7D4A5838  and r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82F62A30: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 82F62A34: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F62A38: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F62A3C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62A40: 2F07FFFE  cmpwi cr6, r7, -2
	ctx.cr[6].compare_i32(ctx.r[7].s32, -2, &mut ctx.xer);
	// 82F62A44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62A48 size=12
    let mut pc: u32 = 0x82F62A48;
    'dispatch: loop {
        match pc {
            0x82F62A48 => {
    //   block [0x82F62A48..0x82F62A54)
	// 82F62A48: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62A4C: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F62A50: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62A54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62A54 size=48
    let mut pc: u32 = 0x82F62A54;
    'dispatch: loop {
        match pc {
            0x82F62A54 => {
    //   block [0x82F62A54..0x82F62A84)
	// 82F62A54: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82F62A58: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82F62A5C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62A60: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F62A64: 409A0010  bne cr6, 0x82f62a74
	if !ctx.cr[6].eq {
	pc = 0x82F62A74; continue 'dispatch;
	}
	// 82F62A68: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F62A6C: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F62A70: 419A0024  beq cr6, 0x82f62a94
	if ctx.cr[6].eq {
		sub_82F62A94(ctx, base);
		return;
	}
	// 82F62A74: 7D475378  mr r7, r10
	ctx.r[7].u64 = ctx.r[10].u64;
	// 82F62A78: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62A7C: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82F62A80: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62A84(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62A84 size=16
    let mut pc: u32 = 0x82F62A84;
    'dispatch: loop {
        match pc {
            0x82F62A84 => {
    //   block [0x82F62A84..0x82F62A94)
	// 82F62A84: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 * 12;
	// 82F62A88: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F62A8C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F62A90: 4BFFFFCC  b 0x82f62a5c
	sub_82F62A54(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62A94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62A94 size=72
    let mut pc: u32 = 0x82F62A94;
    'dispatch: loop {
        match pc {
            0x82F62A94 => {
    //   block [0x82F62A94..0x82F62ADC)
	// 82F62A94: 3900FFFE  li r8, -2
	ctx.r[8].s64 = -2;
	// 82F62A98: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82F62A9C: 409A0040  bne cr6, 0x82f62adc
	if !ctx.cr[6].eq {
		sub_82F62ADC(ctx, base);
		return;
	}
	// 82F62AA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62AA4: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82F62AA8: 419A0044  beq cr6, 0x82f62aec
	if ctx.cr[6].eq {
		sub_82F62ADC(ctx, base);
		return;
	}
	// 82F62AAC: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 * 12;
	// 82F62AB0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F62AB4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82F62AB8: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 82F62ABC: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F62AC0: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82F62AC4: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F62AC8: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82F62ACC: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F62AD0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F62AD4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82F62AD8: 48000014  b 0x82f62aec
	sub_82F62ADC(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62ADC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F62ADC size=40
    let mut pc: u32 = 0x82F62ADC;
    'dispatch: loop {
        match pc {
            0x82F62ADC => {
    //   block [0x82F62ADC..0x82F62B04)
	// 82F62ADC: 1D47000C  mulli r10, r7, 0xc
	ctx.r[10].s64 = ctx.r[7].s64 * 12;
	// 82F62AE0: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62AE4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82F62AE8: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82F62AEC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F62AF0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62AF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62AF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F62AFC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F62B00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F62B08 size=64
    let mut pc: u32 = 0x82F62B08;
    'dispatch: loop {
        match pc {
            0x82F62B08 => {
    //   block [0x82F62B08..0x82F62B48)
	// 82F62B08: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62B0C: E9440012  lwa r10, 0x10(r4)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as i32) as i64;
	// 82F62B10: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F62B14: E924000E  lwa r9, 0xc(r4)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as i32) as i64;
	// 82F62B18: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82F62B1C: 4182002C  beq 0x82f62b48
	if ctx.cr[0].eq {
		sub_82F62B48(ctx, base);
		return;
	}
	// 82F62B20: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82F62B24: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F62B28: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82F62B2C: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F62B30: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F62B34: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F62B38: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F62B3C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F62B40: D1A1FFF0  stfs f13, -0x10(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82F62B44: 48000028  b 0x82f62b6c
	sub_82F62B48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F62B48 size=60
    let mut pc: u32 = 0x82F62B48;
    'dispatch: loop {
        match pc {
            0x82F62B48 => {
    //   block [0x82F62B48..0x82F62B84)
	// 82F62B48: F941FFF8  std r10, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[10].u64 ) };
	// 82F62B4C: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82F62B50: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F62B54: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F62B58: C9A1FFF8  lfd f13, -8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82F62B5C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F62B60: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F62B64: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82F62B68: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F62B6C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82F62B70: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F62B74: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F62B78: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F62B7C: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F62B80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F62B88 size=140
    let mut pc: u32 = 0x82F62B88;
    'dispatch: loop {
        match pc {
            0x82F62B88 => {
    //   block [0x82F62B88..0x82F62C14)
	// 82F62B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F62B8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F62B90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F62B94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F62B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F62B9C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F62BA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F62BA4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F62BA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F62BAC: 4BFFF1E5  bl 0x82f61d90
	ctx.lr = 0x82F62BB0;
	sub_82F61D90(ctx, base);
	// 82F62BB0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F62BB4: 41820044  beq 0x82f62bf8
	if ctx.cr[0].eq {
	pc = 0x82F62BF8; continue 'dispatch;
	}
	// 82F62BB8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F62BBC: 397F0758  addi r11, r31, 0x758
	ctx.r[11].s64 = ctx.r[31].s64 + 1880;
	// 82F62BC0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F62BC4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62BC8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62BCC: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82F62BD0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62BD4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62BD8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F62BDC: 813F0758  lwz r9, 0x758(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1880 as u32) ) } as u64;
	// 82F62BE0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F62BE4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F62BE8: 817F0758  lwz r11, 0x758(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(1880 as u32) ) } as u64;
	// 82F62BEC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F62BF0: 915F0758  stw r10, 0x758(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1880 as u32), ctx.r[10].u32 ) };
	// 82F62BF4: 48000008  b 0x82f62bfc
	pc = 0x82F62BFC; continue 'dispatch;
	// 82F62BF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F62BFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F62C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F62C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F62C08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F62C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F62C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F62C18 size=364
    let mut pc: u32 = 0x82F62C18;
    'dispatch: loop {
        match pc {
            0x82F62C18 => {
    //   block [0x82F62C18..0x82F62D84)
	// 82F62C18: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82F62C1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F62C20: 83E4001C  lwz r31, 0x1c(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F62C24: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F62C28: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F62C2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F62C30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F62C34: C00B0BD0  lfs f0, 0xbd0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3024 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F62C38: C1AA1144  lfs f13, 0x1144(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4420 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F62C3C: FCE00090  fmr f7, f0
	ctx.f[7].f64 = ctx.f[0].f64;
	// 82F62C40: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	// 82F62C44: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 82F62C48: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 82F62C4C: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82F62C50: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 82F62C54: 419A0128  beq cr6, 0x82f62d7c
	if ctx.cr[6].eq {
	pc = 0x82F62D7C; continue 'dispatch;
	}
	// 82F62C58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F62C5C: 80A40028  lwz r5, 0x28(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F62C60: C06B0C18  lfs f3, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82F62C64: 54CAE13A  rlwinm r10, r6, 0x1c, 4, 0x1d
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82F62C68: 54CB06BE  clrlwi r11, r6, 0x1a
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x0000003Fu64;
	// 82F62C6C: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 82F62C70: 7D4A282E  lwzx r10, r10, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82F62C74: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F62C78: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62C7C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82F62C80: 409900F0  ble cr6, 0x82f62d70
	if !ctx.cr[6].gt {
	pc = 0x82F62D70; continue 'dispatch;
	}
	// 82F62C84: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F62C88: FC801890  fmr f4, f3
	ctx.f[4].f64 = ctx.f[3].f64;
	// 82F62C8C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62C90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F62C94: 7D495A14  add r10, r9, r11
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F62C98: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82F62C9C: 80E80014  lwz r7, 0x14(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F62CA0: 5548D1BA  rlwinm r8, r10, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82F62CA4: 554A1D78  rlwinm r10, r10, 3, 0x15, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82F62CA8: 7D08382E  lwzx r8, r8, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82F62CAC: 7D48502A  ldx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	// 82F62CB0: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82F62CB4: 419A0078  beq cr6, 0x82f62d2c
	if ctx.cr[6].eq {
	pc = 0x82F62D2C; continue 'dispatch;
	}
	// 82F62CB8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82F62CBC: 5549D1BA  rlwinm r9, r10, 0x1a, 6, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82F62CC0: 55481D78  rlwinm r8, r10, 3, 0x15, 0x1c
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82F62CC4: 7D29382E  lwzx r9, r9, r7
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82F62CC8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82F62CCC: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F62CD0: FF0B3800  fcmpu cr6, f11, f7
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[7].f64);
	// 82F62CD4: 40980008  bge cr6, 0x82f62cdc
	if !ctx.cr[6].lt {
	pc = 0x82F62CDC; continue 'dispatch;
	}
	// 82F62CD8: FCE05890  fmr f7, f11
	ctx.f[7].f64 = ctx.f[11].f64;
	// 82F62CDC: C1890004  lfs f12, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F62CE0: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 82F62CE4: 40980008  bge cr6, 0x82f62cec
	if !ctx.cr[6].lt {
	pc = 0x82F62CEC; continue 'dispatch;
	}
	// 82F62CE8: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 82F62CEC: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 82F62CF0: 40990008  ble cr6, 0x82f62cf8
	if !ctx.cr[6].gt {
	pc = 0x82F62CF8; continue 'dispatch;
	}
	// 82F62CF4: FD205890  fmr f9, f11
	ctx.f[9].f64 = ctx.f[11].f64;
	// 82F62CF8: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 82F62CFC: 40990008  ble cr6, 0x82f62d04
	if !ctx.cr[6].gt {
	pc = 0x82F62D04; continue 'dispatch;
	}
	// 82F62D00: FD406090  fmr f10, f12
	ctx.f[10].f64 = ctx.f[12].f64;
	// 82F62D04: C041FFF4  lfs f2, -0xc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F62D08: E9290000  ld r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 82F62D0C: ED6B00B2  fmuls f11, f11, f2
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[2].f64) as f32) as f64);
	// 82F62D10: C041FFF0  lfs f2, -0x10(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F62D14: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F62D18: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F62D1C: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82F62D20: ED8C58B8  fmsubs f12, f12, f2, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[2].f64 - ctx.f[11].f64) as f32) as f64);
	// 82F62D24: EC8C202A  fadds f4, f12, f4
	ctx.f[4].f64 = ((ctx.f[12].f64 + ctx.f[4].f64) as f32) as f64;
	// 82F62D28: 4082FF94  bne 0x82f62cbc
	if !ctx.cr[0].eq {
	pc = 0x82F62CBC; continue 'dispatch;
	}
	// 82F62D2C: FF073000  fcmpu cr6, f7, f6
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[6].f64);
	// 82F62D30: 4198001C  blt cr6, 0x82f62d4c
	if ctx.cr[6].lt {
	pc = 0x82F62D4C; continue 'dispatch;
	}
	// 82F62D34: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82F62D38: 41980014  blt cr6, 0x82f62d4c
	if ctx.cr[6].lt {
	pc = 0x82F62D4C; continue 'dispatch;
	}
	// 82F62D3C: FF092800  fcmpu cr6, f9, f5
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[5].f64);
	// 82F62D40: 4199000C  bgt cr6, 0x82f62d4c
	if ctx.cr[6].gt {
	pc = 0x82F62D4C; continue 'dispatch;
	}
	// 82F62D44: FF0A6800  fcmpu cr6, f10, f13
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[13].f64);
	// 82F62D48: 40990028  ble cr6, 0x82f62d70
	if !ctx.cr[6].gt {
	pc = 0x82F62D70; continue 'dispatch;
	}
	// 82F62D4C: FCC03890  fmr f6, f7
	ctx.f[6].f64 = ctx.f[7].f64;
	// 82F62D50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F62D54: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	// 82F62D58: FCA04890  fmr f5, f9
	ctx.f[5].f64 = ctx.f[9].f64;
	// 82F62D5C: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82F62D60: FF041800  fcmpu cr6, f4, f3
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[3].f64);
	// 82F62D64: 41990008  bgt cr6, 0x82f62d6c
	if ctx.cr[6].gt {
	pc = 0x82F62D6C; continue 'dispatch;
	}
	// 82F62D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F62D6C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F62D70: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82F62D74: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F62D78: 4198FEEC  blt cr6, 0x82f62c64
	if ctx.cr[6].lt {
	pc = 0x82F62C64; continue 'dispatch;
	}
	// 82F62D7C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82F62D80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F62D88 size=164
    let mut pc: u32 = 0x82F62D88;
    'dispatch: loop {
        match pc {
            0x82F62D88 => {
    //   block [0x82F62D88..0x82F62E2C)
	// 82F62D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F62D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F62D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F62D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F62D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F62D9C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F62DA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F62DA4: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82F62DA8: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82F62DAC: 409A0048  bne cr6, 0x82f62df4
	if !ctx.cr[6].eq {
	pc = 0x82F62DF4; continue 'dispatch;
	}
	// 82F62DB0: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82F62DB4: 4182001C  beq 0x82f62dd0
	if ctx.cr[0].eq {
	pc = 0x82F62DD0; continue 'dispatch;
	}
	// 82F62DB8: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82F62DBC: 4182000C  beq 0x82f62dc8
	if ctx.cr[0].eq {
	pc = 0x82F62DC8; continue 'dispatch;
	}
	// 82F62DC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F62DC4: 409A0054  bne cr6, 0x82f62e18
	if !ctx.cr[6].eq {
	pc = 0x82F62E18; continue 'dispatch;
	}
	// 82F62DC8: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F62DCC: 4082004C  bne 0x82f62e18
	if !ctx.cr[0].eq {
	pc = 0x82F62E18; continue 'dispatch;
	}
	// 82F62DD0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62DD4: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82F62DD8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F62DDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F62DE0: 419A0008  beq cr6, 0x82f62de8
	if ctx.cr[6].eq {
	pc = 0x82F62DE8; continue 'dispatch;
	}
	// 82F62DE4: 4BF9AABD  bl 0x82efd8a0
	ctx.lr = 0x82F62DE8;
	sub_82EFD8A0(ctx, base);
	// 82F62DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F62DEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F62DF0: 48000028  b 0x82f62e18
	pc = 0x82F62E18; continue 'dispatch;
	// 82F62DF4: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F62DF8: 41990010  bgt cr6, 0x82f62e08
	if ctx.cr[6].gt {
	pc = 0x82F62E08; continue 'dispatch;
	}
	// 82F62DFC: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F62E00: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F62E04: 41990014  bgt cr6, 0x82f62e18
	if ctx.cr[6].gt {
	pc = 0x82F62E18; continue 'dispatch;
	}
	// 82F62E08: 548BF0BE  srwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F62E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F62E10: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82F62E14: 4BFEA3CD  bl 0x82f4d1e0
	ctx.lr = 0x82F62E18;
	sub_82F4D1E0(ctx, base);
	// 82F62E18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F62E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F62E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F62E24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F62E28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F62E30 size=100
    let mut pc: u32 = 0x82F62E30;
    'dispatch: loop {
        match pc {
            0x82F62E30 => {
    //   block [0x82F62E30..0x82F62E94)
	// 82F62E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F62E34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F62E38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F62E3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F62E40: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62E44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F62E48: 419A0034  beq cr6, 0x82f62e7c
	if ctx.cr[6].eq {
	pc = 0x82F62E7C; continue 'dispatch;
	}
	// 82F62E4C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62E50: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62E54: 5569D1BE  srwi r9, r11, 6
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F62E58: 7D2B5A78  xor r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 82F62E5C: 7D655038  and r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82F62E60: 4BFFF321  bl 0x82f62180
	ctx.lr = 0x82F62E64;
	sub_82F62180(ctx, base);
	// 82F62E64: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F62E68: 41800014  blt 0x82f62e7c
	if ctx.cr[0].lt {
	pc = 0x82F62E7C; continue 'dispatch;
	}
	// 82F62E6C: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 * 12;
	// 82F62E70: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82F62E74: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82F62E78: 48000008  b 0x82f62e80
	pc = 0x82F62E80; continue 'dispatch;
	// 82F62E7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F62E80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F62E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F62E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F62E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F62E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F62E98 size=328
    let mut pc: u32 = 0x82F62E98;
    'dispatch: loop {
        match pc {
            0x82F62E98 => {
    //   block [0x82F62E98..0x82F62FE0)
	// 82F62E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F62E9C: 4BD46565  bl 0x82ca9400
	ctx.lr = 0x82F62EA0;
	sub_82CA93D0(ctx, base);
	// 82F62EA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F62EA4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82F62EA8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F62EAC: 409A0008  bne cr6, 0x82f62eb4
	if !ctx.cr[6].eq {
	pc = 0x82F62EB4; continue 'dispatch;
	}
	// 82F62EB0: 48000124  b 0x82f62fd4
	pc = 0x82F62FD4; continue 'dispatch;
	// 82F62EB4: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82F62EB8: 4098000C  bge cr6, 0x82f62ec4
	if !ctx.cr[6].lt {
	pc = 0x82F62EC4; continue 'dispatch;
	}
	// 82F62EBC: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82F62EC0: 4800004C  b 0x82f62f0c
	pc = 0x82F62F0C; continue 'dispatch;
	// 82F62EC4: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82F62EC8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82F62ECC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F62ED0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F62ED4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F62ED8: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F62EDC: 4B290ED5  bl 0x821f3db0
	ctx.lr = 0x82F62EE0;
	sub_821F3DB0(ctx, base);
	// 82F62EE0: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F62EE4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F62EE8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F62EEC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F62EF0: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F62EF4: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F62EF8: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F62EFC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F62F00: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82F62F04: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F62F08: 7D3F5830  slw r31, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82F62F0C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82F62F10: 1D7F001C  mulli r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 * 28;
	// 82F62F14: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F62F18: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82F62F1C: 4BF9A945  bl 0x82efd860
	ctx.lr = 0x82F62F20;
	sub_82EFD860(ctx, base);
	// 82F62F20: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82F62F24: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82F62F28: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82F62F2C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F62F30: 3B60FFFE  li r27, -2
	ctx.r[27].s64 = -2;
	// 82F62F34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F62F38: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F62F3C: 419A0020  beq cr6, 0x82f62f5c
	if ctx.cr[6].eq {
	pc = 0x82F62F5C; continue 'dispatch;
	}
	// 82F62F40: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82F62F44: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F62F48: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F62F4C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F62F50: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82F62F54: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82F62F58: 4082FFEC  bne 0x82f62f44
	if !ctx.cr[0].eq {
	pc = 0x82F62F44; continue 'dispatch;
	}
	// 82F62F5C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62F60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F62F64: 419A0060  beq cr6, 0x82f62fc4
	if ctx.cr[6].eq {
	pc = 0x82F62FC4; continue 'dispatch;
	}
	// 82F62F68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62F6C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82F62F70: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82F62F74: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62F78: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82F62F7C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F62F80: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F62F84: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F62F88: 419A0028  beq cr6, 0x82f62fb0
	if ctx.cr[6].eq {
	pc = 0x82F62FB0; continue 'dispatch;
	}
	// 82F62F8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F62F90: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82F62F94: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F62F98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F62F9C: 5569D1BE  srwi r9, r11, 6
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F62FA0: 7D2A5278  xor r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 ^ ctx.r[10].u64;
	// 82F62FA4: 7D455A78  xor r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 82F62FA8: 480004D1  bl 0x82f63478
	ctx.lr = 0x82F62FAC;
	sub_82F63478(ctx, base);
	// 82F62FAC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F62FB0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F62FB4: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82F62FB8: 4082FFBC  bne 0x82f62f74
	if !ctx.cr[0].eq {
	pc = 0x82F62F74; continue 'dispatch;
	}
	// 82F62FBC: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F62FC0: 4BF9A8E1  bl 0x82efd8a0
	ctx.lr = 0x82F62FC4;
	sub_82EFD8A0(ctx, base);
	// 82F62FC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F62FC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F62FCC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F62FD0: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F62FD4: 4BFFF91D  bl 0x82f628f0
	ctx.lr = 0x82F62FD8;
	sub_82F628F0(ctx, base);
	// 82F62FD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F62FDC: 4BD46474  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F62FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F62FE0 size=348
    let mut pc: u32 = 0x82F62FE0;
    'dispatch: loop {
        match pc {
            0x82F62FE0 => {
    //   block [0x82F62FE0..0x82F6313C)
	// 82F62FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F62FE4: 4BD4641D  bl 0x82ca9400
	ctx.lr = 0x82F62FE8;
	sub_82CA93D0(ctx, base);
	// 82F62FE8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F62FEC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82F62FF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F62FF4: 409A0008  bne cr6, 0x82f62ffc
	if !ctx.cr[6].eq {
	pc = 0x82F62FFC; continue 'dispatch;
	}
	// 82F62FF8: 48000138  b 0x82f63130
	pc = 0x82F63130; continue 'dispatch;
	// 82F62FFC: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82F63000: 4098000C  bge cr6, 0x82f6300c
	if !ctx.cr[6].lt {
	pc = 0x82F6300C; continue 'dispatch;
	}
	// 82F63004: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82F63008: 4800004C  b 0x82f63054
	pc = 0x82F63054; continue 'dispatch;
	// 82F6300C: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82F63010: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82F63014: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F63018: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6301C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F63020: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F63024: 4B290D8D  bl 0x821f3db0
	ctx.lr = 0x82F63028;
	sub_821F3DB0(ctx, base);
	// 82F63028: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F6302C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F63030: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F63034: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F63038: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6303C: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F63040: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F63044: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F63048: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82F6304C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F63050: 7D3F5830  slw r31, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82F63054: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82F63058: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6305C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F63060: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82F63064: 4BF9A7FD  bl 0x82efd860
	ctx.lr = 0x82F63068;
	sub_82EFD860(ctx, base);
	// 82F63068: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82F6306C: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82F63070: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82F63074: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F63078: 3B60FFFE  li r27, -2
	ctx.r[27].s64 = -2;
	// 82F6307C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F63080: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F63084: 419A0020  beq cr6, 0x82f630a4
	if ctx.cr[6].eq {
	pc = 0x82F630A4; continue 'dispatch;
	}
	// 82F63088: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82F6308C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F63090: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F63094: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F63098: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82F6309C: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82F630A0: 4082FFEC  bne 0x82f6308c
	if !ctx.cr[0].eq {
	pc = 0x82F6308C; continue 'dispatch;
	}
	// 82F630A4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F630A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F630AC: 419A0074  beq cr6, 0x82f63120
	if ctx.cr[6].eq {
	pc = 0x82F63120; continue 'dispatch;
	}
	// 82F630B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F630B4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82F630B8: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82F630BC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F630C0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82F630C4: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F630C8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F630CC: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F630D0: 419A003C  beq cr6, 0x82f6310c
	if ctx.cr[6].eq {
	pc = 0x82F6310C; continue 'dispatch;
	}
	// 82F630D4: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F630D8: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82F630DC: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F630E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F630E4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F630E8: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F630EC: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F630F0: 5528D1BE  srwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F630F4: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F630F8: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F630FC: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F63100: 7D654A78  xor r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F63104: 4800059D  bl 0x82f636a0
	ctx.lr = 0x82F63108;
	sub_82F636A0(ctx, base);
	// 82F63108: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F6310C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F63110: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82F63114: 4082FFA8  bne 0x82f630bc
	if !ctx.cr[0].eq {
	pc = 0x82F630BC; continue 'dispatch;
	}
	// 82F63118: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6311C: 4BF9A785  bl 0x82efd8a0
	ctx.lr = 0x82F63120;
	sub_82EFD8A0(ctx, base);
	// 82F63120: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F63124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F63128: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F6312C: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F63130: 4BFB8919  bl 0x82f1ba48
	ctx.lr = 0x82F63134;
	sub_82F1BA48(ctx, base);
	// 82F63134: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F63138: 4BD46318  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F63140 size=196
    let mut pc: u32 = 0x82F63140;
    'dispatch: loop {
        match pc {
            0x82F63140 => {
    //   block [0x82F63140..0x82F63204)
	// 82F63140: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82F63144: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63148: 1D65001C  mulli r11, r5, 0x1c
	ctx.r[11].s64 = ctx.r[5].s64 * 28;
	// 82F6314C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F63150: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82F63154: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F63158: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6315C: 2F0AFFFE  cmpwi cr6, r10, -2
	ctx.cr[6].compare_i32(ctx.r[10].s32, -2, &mut ctx.xer);
	// 82F63160: 419A0098  beq cr6, 0x82f631f8
	if ctx.cr[6].eq {
	pc = 0x82F631F8; continue 'dispatch;
	}
	// 82F63164: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63168: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6316C: 5546D1BE  srwi r6, r10, 6
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82F63170: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63174: 7CC73A78  xor r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 ^ ctx.r[7].u64;
	// 82F63178: 7CEA5278  xor r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 ^ ctx.r[10].u64;
	// 82F6317C: 7D4A4038  and r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 82F63180: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82F63184: 409A0074  bne cr6, 0x82f631f8
	if !ctx.cr[6].eq {
	pc = 0x82F631F8; continue 'dispatch;
	}
	// 82F63188: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6318C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82F63190: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63194: 54FFD1BE  srwi r31, r7, 6
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shr(6);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82F63198: 7FE63278  xor r6, r31, r6
	ctx.r[6].u64 = ctx.r[31].u64 ^ ctx.r[6].u64;
	// 82F6319C: 7CC73A78  xor r7, r6, r7
	ctx.r[7].u64 = ctx.r[6].u64 ^ ctx.r[7].u64;
	// 82F631A0: 7CE74038  and r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82F631A4: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82F631A8: 409A0034  bne cr6, 0x82f631dc
	if !ctx.cr[6].eq {
	pc = 0x82F631DC; continue 'dispatch;
	}
	// 82F631AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F631B0: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F631B4: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F631B8: 409A0018  bne cr6, 0x82f631d0
	if !ctx.cr[6].eq {
	pc = 0x82F631D0; continue 'dispatch;
	}
	// 82F631BC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F631C0: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F631C4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82F631C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F631CC: 419A0008  beq cr6, 0x82f631d4
	if ctx.cr[6].eq {
	pc = 0x82F631D4; continue 'dispatch;
	}
	// 82F631D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F631D4: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F631D8: 40820024  bne 0x82f631fc
	if !ctx.cr[0].eq {
	pc = 0x82F631FC; continue 'dispatch;
	}
	// 82F631DC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F631E0: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82F631E4: 419A0014  beq cr6, 0x82f631f8
	if ctx.cr[6].eq {
	pc = 0x82F631F8; continue 'dispatch;
	}
	// 82F631E8: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 82F631EC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F631F0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F631F4: 4BFFFF94  b 0x82f63188
	pc = 0x82F63188; continue 'dispatch;
	// 82F631F8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F631FC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82F63200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63208 size=228
    let mut pc: u32 = 0x82F63208;
    'dispatch: loop {
        match pc {
            0x82F63208 => {
    //   block [0x82F63208..0x82F632EC)
	// 82F63208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6320C: 4BD461F5  bl 0x82ca9400
	ctx.lr = 0x82F63210;
	sub_82CA93D0(ctx, base);
	// 82F63210: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63214: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F63218: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6321C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82F63220: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63224: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82F63228: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F6322C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F63230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63234: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F63238: 419A00A8  beq cr6, 0x82f632e0
	if ctx.cr[6].eq {
	pc = 0x82F632E0; continue 'dispatch;
	}
	// 82F6323C: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F63240: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F63244: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63248: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F6324C: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63250: 5528D1BE  srwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F63254: 837D0004  lwz r27, 4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63258: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F6325C: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63260: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F63264: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F63268: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82F6326C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F63270: 409A0070  bne cr6, 0x82f632e0
	if !ctx.cr[6].eq {
	pc = 0x82F632E0; continue 'dispatch;
	}
	// 82F63274: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F63278: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F6327C: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F63280: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63284: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63288: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6328C: 5528D1BE  srwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F63290: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F63294: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63298: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F6329C: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F632A0: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82F632A4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F632A8: 409A0014  bne cr6, 0x82f632bc
	if !ctx.cr[6].eq {
	pc = 0x82F632BC; continue 'dispatch;
	}
	// 82F632AC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82F632B0: 4BFFEC59  bl 0x82f61f08
	ctx.lr = 0x82F632B4;
	sub_82F61F08(ctx, base);
	// 82F632B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F632B8: 40820020  bne 0x82f632d8
	if !ctx.cr[0].eq {
	pc = 0x82F632D8; continue 'dispatch;
	}
	// 82F632BC: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F632C0: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82F632C4: 419A001C  beq cr6, 0x82f632e0
	if ctx.cr[6].eq {
	pc = 0x82F632E0; continue 'dispatch;
	}
	// 82F632C8: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F632CC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F632D0: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F632D4: 4BFFFFA0  b 0x82f63274
	pc = 0x82F63274; continue 'dispatch;
	// 82F632D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F632DC: 48000008  b 0x82f632e4
	pc = 0x82F632E4; continue 'dispatch;
	// 82F632E0: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F632E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F632E8: 4BD46168  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F632F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F632F0 size=392
    let mut pc: u32 = 0x82F632F0;
    'dispatch: loop {
        match pc {
            0x82F632F0 => {
    //   block [0x82F632F0..0x82F63478)
	// 82F632F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F632F4: 4BD46105  bl 0x82ca93f8
	ctx.lr = 0x82F632F8;
	sub_82CA93D0(ctx, base);
	// 82F632F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F632FC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82F63300: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82F63304: 83B80000  lwz r29, 0(r24)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63308: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F6330C: 419A0164  beq cr6, 0x82f63470
	if ctx.cr[6].eq {
	pc = 0x82F63470; continue 'dispatch;
	}
	// 82F63310: 895C0006  lbz r10, 6(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F63314: 897C0007  lbz r11, 7(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F63318: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6331C: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63320: A15C0004  lhz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63324: 5528D1BE  srwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F63328: 837D0004  lwz r27, 4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6332C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F63330: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63334: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F63338: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F6333C: 7D7ED838  and r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82F63340: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63344: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F63348: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F6334C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63350: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F63354: 419A011C  beq cr6, 0x82f63470
	if ctx.cr[6].eq {
	pc = 0x82F63470; continue 'dispatch;
	}
	// 82F63358: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F6335C: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F63360: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63364: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63368: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6336C: 5528D1BE  srwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F63370: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F63374: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F63378: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F6337C: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F63380: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82F63384: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F63388: 409A00E8  bne cr6, 0x82f63470
	if !ctx.cr[6].eq {
	pc = 0x82F63470; continue 'dispatch;
	}
	// 82F6338C: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82F63390: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 82F63394: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F63398: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F6339C: 897F000B  lbz r11, 0xb(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F633A0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F633A4: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F633A8: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F633AC: 5528D1BE  srwi r8, r9, 6
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F633B0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F633B4: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F633B8: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F633BC: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F633C0: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82F633C4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82F633C8: 409A0014  bne cr6, 0x82f633dc
	if !ctx.cr[6].eq {
	pc = 0x82F633DC; continue 'dispatch;
	}
	// 82F633CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82F633D0: 4BFFEB39  bl 0x82f61f08
	ctx.lr = 0x82F633D4;
	sub_82F61F08(ctx, base);
	// 82F633D4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F633D8: 40820024  bne 0x82f633fc
	if !ctx.cr[0].eq {
	pc = 0x82F633FC; continue 'dispatch;
	}
	// 82F633DC: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 82F633E0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F633E4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82F633E8: 419A0088  beq cr6, 0x82f63470
	if ctx.cr[6].eq {
	pc = 0x82F63470; continue 'dispatch;
	}
	// 82F633EC: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F633F0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F633F4: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F633F8: 4BFFFF9C  b 0x82f63394
	pc = 0x82F63394; continue 'dispatch;
	// 82F633FC: 3920FFFE  li r9, -2
	ctx.r[9].s64 = -2;
	// 82F63400: 7F1AF000  cmpw cr6, r26, r30
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82F63404: 409A0048  bne cr6, 0x82f6344c
	if !ctx.cr[6].eq {
	pc = 0x82F6344C; continue 'dispatch;
	}
	// 82F63408: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6340C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82F63410: 419A004C  beq cr6, 0x82f6345c
	if ctx.cr[6].eq {
	pc = 0x82F6345C; continue 'dispatch;
	}
	// 82F63414: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63418: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6341C: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F63420: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82F63424: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63428: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F6342C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F63430: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82F63434: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F63438: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82F6343C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F63440: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F63444: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82F63448: 48000014  b 0x82f6345c
	pc = 0x82F6345C; continue 'dispatch;
	// 82F6344C: 572B2036  slwi r11, r25, 4
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63450: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63454: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F63458: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F6345C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F63460: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63464: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63468: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6346C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F63470: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F63474: 4BD45FD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63478 size=548
    let mut pc: u32 = 0x82F63478;
    'dispatch: loop {
        match pc {
            0x82F63478 => {
    //   block [0x82F63478..0x82F6369C)
	// 82F63478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6347C: 4BD45F91  bl 0x82ca940c
	ctx.lr = 0x82F63480;
	sub_82CA93D0(ctx, base);
	// 82F63480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F63488: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6348C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F63490: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F63498: 409A000C  bne cr6, 0x82f634a4
	if !ctx.cr[6].eq {
	pc = 0x82F634A4; continue 'dispatch;
	}
	// 82F6349C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F634A0: 4800002C  b 0x82f634cc
	pc = 0x82F634CC; continue 'dispatch;
	// 82F634A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F634A8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F634AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F634B0: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F634B4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F634B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F634BC: 40990018  ble cr6, 0x82f634d4
	if !ctx.cr[6].gt {
	pc = 0x82F634D4; continue 'dispatch;
	}
	// 82F634C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F634C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F634C8: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F634CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F634D0: 4BFFF9C9  bl 0x82f62e98
	ctx.lr = 0x82F634D4;
	sub_82F62E98(ctx, base);
	// 82F634D4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F634D8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F634DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F634E0: 7D29F038  and r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 82F634E4: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82F634E8: 1D69001C  mulli r11, r9, 0x1c
	ctx.r[11].s64 = ctx.r[9].s64 * 28;
	// 82F634EC: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F634F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F634F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F634F8: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F634FC: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F63500: 2F07FFFE  cmpwi cr6, r7, -2
	ctx.cr[6].compare_i32(ctx.r[7].s32, -2, &mut ctx.xer);
	// 82F63504: 409A004C  bne cr6, 0x82f63550
	if !ctx.cr[6].eq {
	pc = 0x82F63550; continue 'dispatch;
	}
	// 82F63508: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F6350C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82F63510: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F63514: 395D0008  addi r10, r29, 8
	ctx.r[10].s64 = ctx.r[29].s64 + 8;
	// 82F63518: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6351C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F63520: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F63524: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63528: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6352C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63530: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F63534: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F63538: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F6353C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F63540: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82F63544: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F63548: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82F6354C: 48000148  b 0x82f63694
	pc = 0x82F63694; continue 'dispatch;
	// 82F63550: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63554: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 82F63558: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82F6355C: 7D7E4038  and r30, r11, r8
	ctx.r[30].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 82F63560: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 * 28;
	// 82F63564: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F63568: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6356C: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F63570: 409AFFE8  bne cr6, 0x82f63558
	if !ctx.cr[6].eq {
	pc = 0x82F63558; continue 'dispatch;
	}
	// 82F63574: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63578: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 * 28;
	// 82F6357C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63580: 54C4D1BE  srwi r4, r6, 6
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shr(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F63584: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F63588: 7C852A78  xor r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 ^ ctx.r[5].u64;
	// 82F6358C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F63590: 7CA63278  xor r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 ^ ctx.r[6].u64;
	// 82F63594: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F63598: 7CC64038  and r6, r6, r8
	ctx.r[6].u64 = ctx.r[6].u64 & ctx.r[8].u64;
	// 82F6359C: 7F064840  cmplw cr6, r6, r9
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F635A0: 409A0060  bne cr6, 0x82f63600
	if !ctx.cr[6].eq {
	pc = 0x82F63600; continue 'dispatch;
	}
	// 82F635A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F635A8: 419A0044  beq cr6, 0x82f635ec
	if ctx.cr[6].eq {
	pc = 0x82F635EC; continue 'dispatch;
	}
	// 82F635AC: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82F635B0: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82F635B4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F635B8: 39030008  addi r8, r3, 8
	ctx.r[8].s64 = ctx.r[3].s64 + 8;
	// 82F635BC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F635C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82F635C4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F635C8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F635CC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F635D0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F635D4: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F635D8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F635DC: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F635E0: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F635E4: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F635E8: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82F635EC: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82F635F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F635F4: 4BD45E8D  bl 0x82ca9480
	ctx.lr = 0x82F635F8;
	sub_82CA9480(ctx, base);
	// 82F635F8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F635FC: 48000098  b 0x82f63694
	pc = 0x82F63694; continue 'dispatch;
	// 82F63600: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63604: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63608: 54C4D1BE  srwi r4, r6, 6
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shr(6);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6360C: 7C852A78  xor r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 ^ ctx.r[5].u64;
	// 82F63610: 7CA63278  xor r6, r5, r6
	ctx.r[6].u64 = ctx.r[5].u64 ^ ctx.r[6].u64;
	// 82F63614: 7CC84038  and r8, r6, r8
	ctx.r[8].u64 = ctx.r[6].u64 & ctx.r[8].u64;
	// 82F63618: 48000008  b 0x82f63620
	pc = 0x82F63620; continue 'dispatch;
	// 82F6361C: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63620: 1D08001C  mulli r8, r8, 0x1c
	ctx.r[8].s64 = ctx.r[8].s64 * 28;
	// 82F63624: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82F63628: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82F6362C: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63630: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82F63634: 409AFFE8  bne cr6, 0x82f6361c
	if !ctx.cr[6].eq {
	pc = 0x82F6361C; continue 'dispatch;
	}
	// 82F63638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6363C: 419A0040  beq cr6, 0x82f6367c
	if ctx.cr[6].eq {
	pc = 0x82F6367C; continue 'dispatch;
	}
	// 82F63640: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82F63644: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82F63648: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6364C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F63650: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82F63654: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63658: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F6365C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63660: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F63664: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F63668: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6366C: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F63670: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F63674: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F63678: 914B0018  stw r10, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82F6367C: 93C80000  stw r30, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F63680: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 82F63684: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F63688: 4BD45DF9  bl 0x82ca9480
	ctx.lr = 0x82F6368C;
	sub_82CA9480(ctx, base);
	// 82F6368C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F63690: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F63694: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F63698: 4BD45DC4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F636A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F636A0 size=508
    let mut pc: u32 = 0x82F636A0;
    'dispatch: loop {
        match pc {
            0x82F636A0 => {
    //   block [0x82F636A0..0x82F6389C)
	// 82F636A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F636A4: 4BD45D65  bl 0x82ca9408
	ctx.lr = 0x82F636A8;
	sub_82CA93D0(ctx, base);
	// 82F636A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F636AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F636B0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F636B4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F636B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F636BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F636C0: 409A000C  bne cr6, 0x82f636cc
	if !ctx.cr[6].eq {
	pc = 0x82F636CC; continue 'dispatch;
	}
	// 82F636C4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F636C8: 4800002C  b 0x82f636f4
	pc = 0x82F636F4; continue 'dispatch;
	// 82F636CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F636D0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F636D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F636D8: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F636DC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F636E0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F636E4: 40990018  ble cr6, 0x82f636fc
	if !ctx.cr[6].gt {
	pc = 0x82F636FC; continue 'dispatch;
	}
	// 82F636E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F636EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F636F0: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F636F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F636F8: 4BFFF8E9  bl 0x82f62fe0
	ctx.lr = 0x82F636FC;
	sub_82F62FE0(ctx, base);
	// 82F636FC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63700: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63704: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63708: 7D29F038  and r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 82F6370C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82F63710: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63714: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F63718: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6371C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F63720: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63724: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 82F63728: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 82F6372C: 409A0028  bne cr6, 0x82f63754
	if !ctx.cr[6].eq {
	pc = 0x82F63754; continue 'dispatch;
	}
	// 82F63730: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F63734: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F63738: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6373C: 91660004  stw r11, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F63740: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63744: 91660008  stw r11, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F63748: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6374C: 9166000C  stw r11, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F63750: 48000144  b 0x82f63894
	pc = 0x82F63894; continue 'dispatch;
	// 82F63754: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63758: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82F6375C: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 82F63760: 7D654038  and r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 82F63764: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63768: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6376C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63770: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F63774: 409AFFE8  bne cr6, 0x82f6375c
	if !ctx.cr[6].eq {
	pc = 0x82F6375C; continue 'dispatch;
	}
	// 82F63778: 8BE6000A  lbz r31, 0xa(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F6377C: 54A72036  slwi r7, r5, 4
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82F63780: 8866000B  lbz r3, 0xb(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F63784: 39660004  addi r11, r6, 4
	ctx.r[11].s64 = ctx.r[6].s64 + 4;
	// 82F63788: 83C60004  lwz r30, 4(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6378C: 7CE75214  add r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82F63790: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F63794: A3E60008  lhz r31, 8(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63798: 57DCD1BE  srwi r28, r30, 6
	ctx.r[28].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82F6379C: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82F637A0: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82F637A4: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F637A8: 7C63E278  xor r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[28].u64;
	// 82F637AC: 7C63F278  xor r3, r3, r30
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[30].u64;
	// 82F637B0: 7C634038  and r3, r3, r8
	ctx.r[3].u64 = ctx.r[3].u64 & ctx.r[8].u64;
	// 82F637B4: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F637B8: 409A0048  bne cr6, 0x82f63800
	if !ctx.cr[6].eq {
	pc = 0x82F63800; continue 'dispatch;
	}
	// 82F637BC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82F637C0: 419A0020  beq cr6, 0x82f637e0
	if ctx.cr[6].eq {
	pc = 0x82F637E0; continue 'dispatch;
	}
	// 82F637C4: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F637C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F637CC: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F637D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F637D4: 91470008  stw r10, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F637D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F637DC: 9147000C  stw r10, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F637E0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F637E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F637E8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F637EC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F637F0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F637F4: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F637F8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F637FC: 48000098  b 0x82f63894
	pc = 0x82F63894; continue 'dispatch;
	// 82F63800: 8BEB0006  lbz r31, 6(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F63804: 886B0007  lbz r3, 7(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F63808: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6380C: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F63810: A3EB0004  lhz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63814: 57DCD1BE  srwi r28, r30, 6
	ctx.r[28].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82F63818: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82F6381C: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F63820: 7C63E278  xor r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[28].u64;
	// 82F63824: 7C63F278  xor r3, r3, r30
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[30].u64;
	// 82F63828: 7C684038  and r8, r3, r8
	ctx.r[8].u64 = ctx.r[3].u64 & ctx.r[8].u64;
	// 82F6382C: 48000008  b 0x82f63834
	pc = 0x82F63834; continue 'dispatch;
	// 82F63830: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63834: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F63838: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82F6383C: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82F63840: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63844: 7F034800  cmpw cr6, r3, r9
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82F63848: 409AFFE8  bne cr6, 0x82f63830
	if !ctx.cr[6].eq {
	pc = 0x82F63830; continue 'dispatch;
	}
	// 82F6384C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82F63850: 419A0020  beq cr6, 0x82f63870
	if ctx.cr[6].eq {
	pc = 0x82F63870; continue 'dispatch;
	}
	// 82F63854: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F63858: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6385C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F63860: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63864: 91470008  stw r10, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F63868: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6386C: 9147000C  stw r10, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F63870: 90A80000  stw r5, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F63874: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F63878: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6387C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F63880: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63884: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F63888: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6388C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F63890: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82F63894: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F63898: 4BD45BC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F638A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F638A0 size=120
    let mut pc: u32 = 0x82F638A0;
    'dispatch: loop {
        match pc {
            0x82F638A0 => {
    //   block [0x82F638A0..0x82F63918)
	// 82F638A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F638A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F638A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F638AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F638B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F638B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F638B8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82F638BC: 54AA1838  slwi r10, r5, 3
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F638C0: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82F638C4: 7D4A2214  add r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82F638C8: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82F638CC: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82F638D0: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82F638D4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82F638D8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F638DC: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82F638E0: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82F638E4: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82F638E8: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82F638EC: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 82F638F0: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F638F4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F638F8: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82F638FC: 4803875D  bl 0x82f9c058
	ctx.lr = 0x82F63900;
	sub_82F9C058(ctx, base);
	// 82F63900: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F63904: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F63908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6390C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F63910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F63914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63918 size=228
    let mut pc: u32 = 0x82F63918;
    'dispatch: loop {
        match pc {
            0x82F63918 => {
    //   block [0x82F63918..0x82F639FC)
	// 82F63918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6391C: 4BD45AE9  bl 0x82ca9404
	ctx.lr = 0x82F63920;
	sub_82CA93D0(ctx, base);
	// 82F63920: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F63928: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82F6392C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F63930: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82F63934: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F63938: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82F6393C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82F63940: 90DF0018  stw r6, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82F63944: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 82F63948: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82F6394C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82F63950: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82F63954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F63958: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82F6395C: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 82F63960: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F63964: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82F63968: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82F6396C: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82F63970: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82F63974: 48065B55  bl 0x82fc94c8
	ctx.lr = 0x82F63978;
	sub_82FC94C8(ctx, base);
	// 82F63978: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F6397C: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F63980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F63984: 7D2AEA14  add r9, r10, r29
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82F63988: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F6398C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63990: 395E000C  addi r10, r30, 0xc
	ctx.r[10].s64 = ctx.r[30].s64 + 12;
	// 82F63994: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82F63998: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6399C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F639A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F639A4: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F639A8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F639AC: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82F639B0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F639B4: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82F639B8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F639BC: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 82F639C0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F639C4: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82F639C8: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F639CC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82F639D0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82F639D4: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82F639D8: 896B0024  lbz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F639DC: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82F639E0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F639E4: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F639E8: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82F639EC: 4803866D  bl 0x82f9c058
	ctx.lr = 0x82F639F0;
	sub_82F9C058(ctx, base);
	// 82F639F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F639F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F639F8: 4BD45A5C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63A00 size=116
    let mut pc: u32 = 0x82F63A00;
    'dispatch: loop {
        match pc {
            0x82F63A00 => {
    //   block [0x82F63A00..0x82F63A74)
	// 82F63A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F63A08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F63A0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63A10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F63A14: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82F63A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F63A1C: 419A0018  beq cr6, 0x82f63a34
	if ctx.cr[6].eq {
	pc = 0x82F63A34; continue 'dispatch;
	}
	// 82F63A20: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63A24: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F63A28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63A2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F63A30: 4E800421  bctrl
	ctx.lr = 0x82F63A34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F63A34: 83FF003C  lwz r31, 0x3c(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82F63A38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F63A3C: 419A0024  beq cr6, 0x82f63a60
	if ctx.cr[6].eq {
	pc = 0x82F63A60; continue 'dispatch;
	}
	// 82F63A40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63A44: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F63A48: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F63A4C: 40820014  bne 0x82f63a60
	if !ctx.cr[0].eq {
	pc = 0x82F63A60; continue 'dispatch;
	}
	// 82F63A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F63A54: 4BFA7D95  bl 0x82f0b7e8
	ctx.lr = 0x82F63A58;
	sub_82F0B7E8(ctx, base);
	// 82F63A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F63A5C: 4BF99E45  bl 0x82efd8a0
	ctx.lr = 0x82F63A60;
	sub_82EFD8A0(ctx, base);
	// 82F63A60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F63A64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F63A68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F63A6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F63A70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63A78 size=136
    let mut pc: u32 = 0x82F63A78;
    'dispatch: loop {
        match pc {
            0x82F63A78 => {
    //   block [0x82F63A78..0x82F63B00)
	// 82F63A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F63A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F63A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F63A88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F63A90: 4BFFEE61  bl 0x82f628f0
	ctx.lr = 0x82F63A94;
	sub_82F628F0(ctx, base);
	// 82F63A94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F63A98: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F63A9C: 4BFFF2ED  bl 0x82f62d88
	ctx.lr = 0x82F63AA0;
	sub_82F62D88(ctx, base);
	// 82F63AA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F63AA4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F63AA8: 4BFFEEC1  bl 0x82f62968
	ctx.lr = 0x82F63AAC;
	sub_82F62968(ctx, base);
	// 82F63AAC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F63AB0: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82F63AB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F63AB8: 419A001C  beq cr6, 0x82f63ad4
	if ctx.cr[6].eq {
	pc = 0x82F63AD4; continue 'dispatch;
	}
	// 82F63ABC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63AC0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82F63AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F63AC8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F63ACC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F63AD0: 4E800421  bctrl
	ctx.lr = 0x82F63AD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F63AD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F63AD8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F63ADC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F63AE0: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82F63AE4: 997F0025  stb r11, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 82F63AE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F63AEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F63AF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F63AF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F63AF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F63AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F63B00 size=460
    let mut pc: u32 = 0x82F63B00;
    'dispatch: loop {
        match pc {
            0x82F63B00 => {
    //   block [0x82F63B00..0x82F63CCC)
	// 82F63B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63B04: 4BD45909  bl 0x82ca940c
	ctx.lr = 0x82F63B08;
	sub_82CA93D0(ctx, base);
	// 82F63B08: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82F63B0C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82F63B10: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82F63B14: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63B18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F63B1C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F63B20: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F63B24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F63B28: 392B22A0  addi r9, r11, 0x22a0
	ctx.r[9].s64 = ctx.r[11].s64 + 8864;
	// 82F63B2C: 394A2298  addi r10, r10, 0x2298
	ctx.r[10].s64 = ctx.r[10].s64 + 8856;
	// 82F63B30: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F63B34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F63B38: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F63B3C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F63B40: 3BA0007F  li r29, 0x7f
	ctx.r[29].s64 = 127;
	// 82F63B44: 997F0015  stb r11, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82F63B48: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82F63B4C: 997F0016  stb r11, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[11].u8 ) };
	// 82F63B50: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 82F63B54: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82F63B58: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82F63B5C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82F63B60: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82F63B64: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82F63B68: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82F63B6C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82F63B70: 48069799  bl 0x82fcd308
	ctx.lr = 0x82F63B74;
	sub_82FCD308(ctx, base);
	// 82F63B74: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82F63B78: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82F63B7C: 93DF08E0  stw r30, 0x8e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2272 as u32), ctx.r[30].u32 ) };
	// 82F63B80: 397F08F4  addi r11, r31, 0x8f4
	ctx.r[11].s64 = ctx.r[31].s64 + 2292;
	// 82F63B84: 93DF08E4  stw r30, 0x8e4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2276 as u32), ctx.r[30].u32 ) };
	// 82F63B88: 93DF08E8  stw r30, 0x8e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2280 as u32), ctx.r[30].u32 ) };
	// 82F63B8C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82F63B90: 93BF08EC  stw r29, 0x8ec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2284 as u32), ctx.r[29].u32 ) };
	// 82F63B94: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82F63B98: 93DF08F0  stw r30, 0x8f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2288 as u32), ctx.r[30].u32 ) };
	// 82F63B9C: 38C00040  li r6, 0x40
	ctx.r[6].s64 = 64;
	// 82F63BA0: 917F08F4  stw r11, 0x8f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2292 as u32), ctx.r[11].u32 ) };
	// 82F63BA4: C3E90C14  lfs f31, 0xc14(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F63BA8: 917F08F8  stw r11, 0x8f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2296 as u32), ctx.r[11].u32 ) };
	// 82F63BAC: C0080A4C  lfs f0, 0xa4c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F63BB0: 93DF08FC  stw r30, 0x8fc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2300 as u32), ctx.r[30].u32 ) };
	// 82F63BB4: 387F0930  addi r3, r31, 0x930
	ctx.r[3].s64 = ctx.r[31].s64 + 2352;
	// 82F63BB8: D3FF0900  stfs f31, 0x900(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2304 as u32), tmp.u32 ) };
	// 82F63BBC: 90FF0908  stw r7, 0x908(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2312 as u32), ctx.r[7].u32 ) };
	// 82F63BC0: D3FF0904  stfs f31, 0x904(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2308 as u32), tmp.u32 ) };
	// 82F63BC4: 915F090C  stw r10, 0x90c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2316 as u32), ctx.r[10].u32 ) };
	// 82F63BC8: D01F0914  stfs f0, 0x914(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2324 as u32), tmp.u32 ) };
	// 82F63BCC: 915F0910  stw r10, 0x910(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2320 as u32), ctx.r[10].u32 ) };
	// 82F63BD0: 397F0900  addi r11, r31, 0x900
	ctx.r[11].s64 = ctx.r[31].s64 + 2304;
	// 82F63BD4: 93DF0918  stw r30, 0x918(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2328 as u32), ctx.r[30].u32 ) };
	// 82F63BD8: 93DF091C  stw r30, 0x91c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2332 as u32), ctx.r[30].u32 ) };
	// 82F63BDC: 93DF0920  stw r30, 0x920(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2336 as u32), ctx.r[30].u32 ) };
	// 82F63BE0: 93DF0924  stw r30, 0x924(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2340 as u32), ctx.r[30].u32 ) };
	// 82F63BE4: 90DF0928  stw r6, 0x928(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2344 as u32), ctx.r[6].u32 ) };
	// 82F63BE8: 9BDF092C  stb r30, 0x92c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2348 as u32), ctx.r[30].u8 ) };
	// 82F63BEC: 4BFE634D  bl 0x82f49f38
	ctx.lr = 0x82F63BF0;
	sub_82F49F38(ctx, base);
	// 82F63BF0: 387F0980  addi r3, r31, 0x980
	ctx.r[3].s64 = ctx.r[31].s64 + 2432;
	// 82F63BF4: 4BFE6345  bl 0x82f49f38
	ctx.lr = 0x82F63BF8;
	sub_82F49F38(ctx, base);
	// 82F63BF8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F63BFC: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82F63C00: 39200200  li r9, 0x200
	ctx.r[9].s64 = 512;
	// 82F63C04: 3BBF09E0  addi r29, r31, 0x9e0
	ctx.r[29].s64 = ctx.r[31].s64 + 2528;
	// 82F63C08: 913F09D0  stw r9, 0x9d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2512 as u32), ctx.r[9].u32 ) };
	// 82F63C0C: C00B0B24  lfs f0, 0xb24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F63C10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F63C14: D01F09D4  stfs f0, 0x9d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2516 as u32), tmp.u32 ) };
	// 82F63C18: C00A10EC  lfs f0, 0x10ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F63C1C: D01F09D8  stfs f0, 0x9d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2520 as u32), tmp.u32 ) };
	// 82F63C20: 48008D59  bl 0x82f6c978
	ctx.lr = 0x82F63C24;
	sub_82F6C978(ctx, base);
	// 82F63C24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F63C28: C01F09D4  lfs f0, 0x9d4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F63C2C: FFC00050  fneg f30, f0
	ctx.f[30].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F63C30: C82B0D38  lfd f1, 0xd38(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82F63C34: 4B3304E5  bl 0x82294118
	ctx.lr = 0x82F63C38;
	sub_82294118(ctx, base);
	// 82F63C38: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F63C3C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82F63C40: 4B3304D9  bl 0x82294118
	ctx.lr = 0x82F63C44;
	sub_82294118(ctx, base);
	// 82F63C44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F63C48: FC400818  frsp f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F63C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F63C50: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82F63C54: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82F63C58: C0CB0C18  lfs f6, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82F63C5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F63C60: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 82F63C64: 48008BAD  bl 0x82f6c810
	ctx.lr = 0x82F63C68;
	sub_82F6C810(ctx, base);
	// 82F63C68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F63C6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F63C70: 48008B89  bl 0x82f6c7f8
	ctx.lr = 0x82F63C74;
	sub_82F6C7F8(ctx, base);
	// 82F63C74: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82F63C78: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82F63C7C: 93FF0008  stw r31, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82F63C80: 396BEC58  addi r11, r11, -0x13a8
	ctx.r[11].s64 = ctx.r[11].s64 + -5032;
	// 82F63C84: 93FF0010  stw r31, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82F63C88: 393F07E0  addi r9, r31, 0x7e0
	ctx.r[9].s64 = ctx.r[31].s64 + 2016;
	// 82F63C8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82F63C90: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63C94: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F63C98: 4099000C  ble cr6, 0x82f63ca4
	if !ctx.cr[6].gt {
	pc = 0x82F63CA4; continue 'dispatch;
	}
	// 82F63C9C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F63CA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82F63CA4: 7D49F1AE  stbx r10, r9, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[30].u32), ctx.r[10].u8) };
	// 82F63CA8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82F63CAC: 2B1E0100  cmplwi cr6, r30, 0x100
	ctx.cr[6].compare_u32(ctx.r[30].u32, 256 as u32, &mut ctx.xer);
	// 82F63CB0: 4198FFE0  blt cr6, 0x82f63c90
	if ctx.cr[6].lt {
	pc = 0x82F63C90; continue 'dispatch;
	}
	// 82F63CB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F63CB8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F63CBC: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82F63CC0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82F63CC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82F63CC8: 4BD45794  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63CD0 size=328
    let mut pc: u32 = 0x82F63CD0;
    'dispatch: loop {
        match pc {
            0x82F63CD0 => {
    //   block [0x82F63CD0..0x82F63E18)
	// 82F63CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63CD4: 4BD4572D  bl 0x82ca9400
	ctx.lr = 0x82F63CD8;
	sub_82CA93D0(ctx, base);
	// 82F63CD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63CDC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F63CE0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82F63CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F63CE8: 419A0128  beq cr6, 0x82f63e10
	if ctx.cr[6].eq {
	pc = 0x82F63E10; continue 'dispatch;
	}
	// 82F63CEC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F63CF0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82F63CF4: 409A011C  bne cr6, 0x82f63e10
	if !ctx.cr[6].eq {
	pc = 0x82F63E10; continue 'dispatch;
	}
	// 82F63CF8: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63CFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F63D00: 419A0110  beq cr6, 0x82f63e10
	if ctx.cr[6].eq {
	pc = 0x82F63E10; continue 'dispatch;
	}
	// 82F63D04: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F63D0C: 40990104  ble cr6, 0x82f63e10
	if !ctx.cr[6].gt {
	pc = 0x82F63E10; continue 'dispatch;
	}
	// 82F63D10: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63D14: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82F63D18: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F63D1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F63D20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63D24: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F63D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F63D2C: 4E800421  bctrl
	ctx.lr = 0x82F63D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F63D30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F63D34: 397F001C  addi r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 + 28;
	// 82F63D38: 9BA10064  stb r29, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u8 ) };
	// 82F63D3C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82F63D40: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82F63D44: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82F63D48: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82F63D4C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63D50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82F63D54: 409A0010  bne cr6, 0x82f63d64
	if !ctx.cr[6].eq {
	pc = 0x82F63D64; continue 'dispatch;
	}
	// 82F63D58: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82F63D5C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82F63D60: 48000090  b 0x82f63df0
	pc = 0x82F63DF0; continue 'dispatch;
	// 82F63D64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82F63D68: 39490008  addi r10, r9, 8
	ctx.r[10].s64 = ctx.r[9].s64 + 8;
	// 82F63D6C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63D70: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82F63D74: 409A0018  bne cr6, 0x82f63d8c
	if !ctx.cr[6].eq {
	pc = 0x82F63D8C; continue 'dispatch;
	}
	// 82F63D78: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63D7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F63D80: 394A001C  addi r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + 28;
	// 82F63D84: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F63D88: 4099FFE4  ble cr6, 0x82f63d6c
	if !ctx.cr[6].gt {
	pc = 0x82F63D6C; continue 'dispatch;
	}
	// 82F63D8C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82F63D90: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82F63D94: 4800005C  b 0x82f63df0
	pc = 0x82F63DF0; continue 'dispatch;
	// 82F63D98: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F63D9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F63DA0: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 82F63DA4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63DA8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F63DAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F63DB0: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82F63DB4: 409A0034  bne cr6, 0x82f63de8
	if !ctx.cr[6].eq {
	pc = 0x82F63DE8; continue 'dispatch;
	}
	// 82F63DB8: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63DBC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82F63DC0: 810B0020  lwz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82F63DC4: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82F63DC8: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F63DCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F63DD0: 80CB0014  lwz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F63DD4: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63DD8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63DDC: 817A005C  lwz r11, 0x5c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F63DE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F63DE4: 4E800421  bctrl
	ctx.lr = 0x82F63DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F63DE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F63DEC: 48004225  bl 0x82f68010
	ctx.lr = 0x82F63DF0;
	sub_82F68010(ctx, base);
	// 82F63DF0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F63DF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F63DF8: 4BFD6BC1  bl 0x82f3a9b8
	ctx.lr = 0x82F63DFC;
	sub_82F3A9B8(ctx, base);
	// 82F63DFC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F63E00: 4182FF98  beq 0x82f63d98
	if ctx.cr[0].eq {
	pc = 0x82F63D98; continue 'dispatch;
	}
	// 82F63E04: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82F63E08: 2B1C0002  cmplwi cr6, r28, 2
	ctx.cr[6].compare_u32(ctx.r[28].u32, 2 as u32, &mut ctx.xer);
	// 82F63E0C: 4198FF40  blt cr6, 0x82f63d4c
	if ctx.cr[6].lt {
	pc = 0x82F63D4C; continue 'dispatch;
	}
	// 82F63E10: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F63E14: 4BD4563C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63E18 size=108
    let mut pc: u32 = 0x82F63E18;
    'dispatch: loop {
        match pc {
            0x82F63E18 => {
    //   block [0x82F63E18..0x82F63E84)
	// 82F63E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F63E20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F63E24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63E28: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63E2C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F63E30: 419A003C  beq cr6, 0x82f63e6c
	if ctx.cr[6].eq {
	pc = 0x82F63E6C; continue 'dispatch;
	}
	// 82F63E34: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63E38: 81040004  lwz r8, 4(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63E3C: 5569D1BE  srwi r9, r11, 6
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F63E40: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63E44: 7D294278  xor r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 ^ ctx.r[8].u64;
	// 82F63E48: 7D2B5A78  xor r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 ^ ctx.r[11].u64;
	// 82F63E4C: 7D655038  and r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82F63E50: 4BFFF2F1  bl 0x82f63140
	ctx.lr = 0x82F63E54;
	sub_82F63140(ctx, base);
	// 82F63E54: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F63E58: 41800014  blt 0x82f63e6c
	if ctx.cr[0].lt {
	pc = 0x82F63E6C; continue 'dispatch;
	}
	// 82F63E5C: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 82F63E60: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82F63E64: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82F63E68: 48000008  b 0x82f63e70
	pc = 0x82F63E70; continue 'dispatch;
	// 82F63E6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F63E70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F63E74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F63E78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F63E7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F63E80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63E88 size=128
    let mut pc: u32 = 0x82F63E88;
    'dispatch: loop {
        match pc {
            0x82F63E88 => {
    //   block [0x82F63E88..0x82F63F08)
	// 82F63E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63E8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F63E90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F63E94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63E98: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63E9C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F63EA0: 419A0050  beq cr6, 0x82f63ef0
	if ctx.cr[6].eq {
	pc = 0x82F63EF0; continue 'dispatch;
	}
	// 82F63EA4: 89240006  lbz r9, 6(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F63EA8: 89640007  lbz r11, 7(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F63EAC: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63EB0: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F63EB4: A1240004  lhz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63EB8: 5507D1BE  srwi r7, r8, 6
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(6);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82F63EBC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63EC0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F63EC4: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F63EC8: 7D6B3A78  xor r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82F63ECC: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F63ED0: 7D655038  and r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82F63ED4: 4BFFF335  bl 0x82f63208
	ctx.lr = 0x82F63ED8;
	sub_82F63208(ctx, base);
	// 82F63ED8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F63EDC: 41800014  blt 0x82f63ef0
	if ctx.cr[0].lt {
	pc = 0x82F63EF0; continue 'dispatch;
	}
	// 82F63EE0: 546B2036  slwi r11, r3, 4
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F63EE4: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82F63EE8: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82F63EEC: 48000008  b 0x82f63ef4
	pc = 0x82F63EF4; continue 'dispatch;
	// 82F63EF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F63EF4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F63EF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F63EFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F63F00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F63F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F63F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F63F08 size=688
    let mut pc: u32 = 0x82F63F08;
    'dispatch: loop {
        match pc {
            0x82F63F08 => {
    //   block [0x82F63F08..0x82F641B8)
	// 82F63F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F63F0C: 4BD45501  bl 0x82ca940c
	ctx.lr = 0x82F63F10;
	sub_82CA93D0(ctx, base);
	// 82F63F10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F63F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F63F18: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F63F1C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F63F20: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F63F28: 409A000C  bne cr6, 0x82f63f34
	if !ctx.cr[6].eq {
	pc = 0x82F63F34; continue 'dispatch;
	}
	// 82F63F2C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F63F30: 4800002C  b 0x82f63f5c
	pc = 0x82F63F5C; continue 'dispatch;
	// 82F63F34: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63F38: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63F3C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F63F40: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F63F44: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F63F48: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F63F4C: 40990018  ble cr6, 0x82f63f64
	if !ctx.cr[6].gt {
	pc = 0x82F63F64; continue 'dispatch;
	}
	// 82F63F50: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63F54: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F63F58: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F63F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F63F60: 4BFFEF39  bl 0x82f62e98
	ctx.lr = 0x82F63F64;
	sub_82F62E98(ctx, base);
	// 82F63F64: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63F68: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63F6C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63F70: 7D28F038  and r8, r9, r30
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 82F63F74: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82F63F78: 1D68001C  mulli r11, r8, 0x1c
	ctx.r[11].s64 = ctx.r[8].s64 * 28;
	// 82F63F7C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F63F80: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63F84: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F63F88: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63F8C: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 82F63F90: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 82F63F94: 409A0078  bne cr6, 0x82f6400c
	if !ctx.cr[6].eq {
	pc = 0x82F6400C; continue 'dispatch;
	}
	// 82F63F98: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63F9C: 39660004  addi r11, r6, 4
	ctx.r[11].s64 = ctx.r[6].s64 + 4;
	// 82F63FA0: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63FA4: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82F63FA8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F63FAC: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82F63FB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82F63FB4: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82F63FB8: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63FBC: 80880008  lwz r4, 8(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63FC0: 8068000C  lwz r3, 0xc(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F63FC4: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63FC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F63FCC: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F63FD0: 90890008  stw r4, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82F63FD4: 9069000C  stw r3, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82F63FD8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F63FDC: 8167000C  lwz r11, 0xc(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F63FE0: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F63FE4: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F63FE8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F63FEC: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F63FF0: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F63FF4: 91660018  stw r11, 0x18(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82F63FF8: 9146000C  stw r10, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F63FFC: 91060010  stw r8, 0x10(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82F64000: F9260004  std r9, 4(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u64 ) };
	// 82F64004: 90E60014  stw r7, 0x14(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 82F64008: 480001A8  b 0x82f641b0
	pc = 0x82F641B0; continue 'dispatch;
	// 82F6400C: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64010: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 82F64014: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 82F64018: 7D653838  and r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 82F6401C: 1D65001C  mulli r11, r5, 0x1c
	ctx.r[11].s64 = ctx.r[5].s64 * 28;
	// 82F64020: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F64024: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64028: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6402C: 409AFFE8  bne cr6, 0x82f64014
	if !ctx.cr[6].eq {
	pc = 0x82F64014; continue 'dispatch;
	}
	// 82F64030: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64034: 1D45001C  mulli r10, r5, 0x1c
	ctx.r[10].s64 = ctx.r[5].s64 * 28;
	// 82F64038: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6403C: 547FD1BE  srwi r31, r3, 6
	ctx.r[31].u32 = ctx.r[3].u32.wrapping_shr(6);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82F64040: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82F64044: 7FFF5A78  xor r31, r31, r11
	ctx.r[31].u64 = ctx.r[31].u64 ^ ctx.r[11].u64;
	// 82F64048: 39660004  addi r11, r6, 4
	ctx.r[11].s64 = ctx.r[6].s64 + 4;
	// 82F6404C: 7FE31A78  xor r3, r31, r3
	ctx.r[3].u64 = ctx.r[31].u64 ^ ctx.r[3].u64;
	// 82F64050: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82F64054: 7C633838  and r3, r3, r7
	ctx.r[3].u64 = ctx.r[3].u64 & ctx.r[7].u64;
	// 82F64058: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F6405C: 409A008C  bne cr6, 0x82f640e8
	if !ctx.cr[6].eq {
	pc = 0x82F640E8; continue 'dispatch;
	}
	// 82F64060: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F64064: 419A0040  beq cr6, 0x82f640a4
	if ctx.cr[6].eq {
	pc = 0x82F640A4; continue 'dispatch;
	}
	// 82F64068: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F6406C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 82F64070: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64074: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82F64078: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82F6407C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64080: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82F64084: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64088: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F6408C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F64090: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F64094: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F64098: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82F6409C: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F640A0: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82F640A4: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F640A8: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 82F640AC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F640B0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F640B4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F640B8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F640BC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F640C0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F640C4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82F640C8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F640CC: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F640D0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F640D4: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F640D8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F640DC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F640E0: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F640E4: 480000CC  b 0x82f641b0
	pc = 0x82F641B0; continue 'dispatch;
	// 82F640E8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F640EC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F640F0: 547ED1BE  srwi r30, r3, 6
	ctx.r[30].u32 = ctx.r[3].u32.wrapping_shr(6);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82F640F4: 7FDFFA78  xor r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 ^ ctx.r[31].u64;
	// 82F640F8: 7FE31A78  xor r3, r31, r3
	ctx.r[3].u64 = ctx.r[31].u64 ^ ctx.r[3].u64;
	// 82F640FC: 7C673838  and r7, r3, r7
	ctx.r[7].u64 = ctx.r[3].u64 & ctx.r[7].u64;
	// 82F64100: 48000008  b 0x82f64108
	pc = 0x82F64108; continue 'dispatch;
	// 82F64104: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64108: 1CE7001C  mulli r7, r7, 0x1c
	ctx.r[7].s64 = ctx.r[7].s64 * 28;
	// 82F6410C: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 82F64110: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82F64114: 80670000  lwz r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64118: 7F034000  cmpw cr6, r3, r8
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82F6411C: 409AFFE8  bne cr6, 0x82f64104
	if !ctx.cr[6].eq {
	pc = 0x82F64104; continue 'dispatch;
	}
	// 82F64120: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F64124: 419A0044  beq cr6, 0x82f64168
	if ctx.cr[6].eq {
	pc = 0x82F64168; continue 'dispatch;
	}
	// 82F64128: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F6412C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 82F64130: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 82F64134: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82F64138: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6413C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F64140: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64144: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82F64148: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6414C: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F64150: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F64154: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F64158: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6415C: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82F64160: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64164: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82F64168: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F6416C: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 82F64170: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64174: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F64178: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6417C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F64180: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64184: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F64188: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6418C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64190: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82F64194: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64198: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82F6419C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F641A0: 910B0010  stw r8, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82F641A4: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F641A8: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82F641AC: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F641B0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F641B4: 4BD452A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F641B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F641B8 size=524
    let mut pc: u32 = 0x82F641B8;
    'dispatch: loop {
        match pc {
            0x82F641B8 => {
    //   block [0x82F641B8..0x82F643C4)
	// 82F641B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F641BC: 4BD4524D  bl 0x82ca9408
	ctx.lr = 0x82F641C0;
	sub_82CA93D0(ctx, base);
	// 82F641C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F641C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F641C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F641CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F641D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F641D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F641D8: 409A000C  bne cr6, 0x82f641e4
	if !ctx.cr[6].eq {
	pc = 0x82F641E4; continue 'dispatch;
	}
	// 82F641DC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F641E0: 4800002C  b 0x82f6420c
	pc = 0x82F6420C; continue 'dispatch;
	// 82F641E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F641E8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F641EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F641F0: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F641F4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F641F8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F641FC: 40990018  ble cr6, 0x82f64214
	if !ctx.cr[6].gt {
	pc = 0x82F64214; continue 'dispatch;
	}
	// 82F64200: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64204: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F64208: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6420C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F64210: 4BFFEDD1  bl 0x82f62fe0
	ctx.lr = 0x82F64214;
	sub_82F62FE0(ctx, base);
	// 82F64214: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64218: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6421C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64220: 7D29F038  and r9, r9, r30
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 82F64224: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82F64228: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6422C: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F64230: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64234: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F64238: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6423C: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 82F64240: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 82F64244: 409A0028  bne cr6, 0x82f6426c
	if !ctx.cr[6].eq {
	pc = 0x82F6426C; continue 'dispatch;
	}
	// 82F64248: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6424C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F64250: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64254: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82F64258: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6425C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F64260: F9660004  std r11, 4(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u64 ) };
	// 82F64264: 9126000C  stw r9, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F64268: 48000154  b 0x82f643bc
	pc = 0x82F643BC; continue 'dispatch;
	// 82F6426C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64270: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82F64274: 39650001  addi r11, r5, 1
	ctx.r[11].s64 = ctx.r[5].s64 + 1;
	// 82F64278: 7D654038  and r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 82F6427C: 54AB2036  slwi r11, r5, 4
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F64280: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F64284: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64288: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6428C: 409AFFE8  bne cr6, 0x82f64274
	if !ctx.cr[6].eq {
	pc = 0x82F64274; continue 'dispatch;
	}
	// 82F64290: 8BE6000A  lbz r31, 0xa(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(10 as u32) ) } as u64;
	// 82F64294: 54A72036  slwi r7, r5, 4
	ctx.r[7].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82F64298: 8866000B  lbz r3, 0xb(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F6429C: 39660004  addi r11, r6, 4
	ctx.r[11].s64 = ctx.r[6].s64 + 4;
	// 82F642A0: 83C60004  lwz r30, 4(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F642A4: 7CE75214  add r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82F642A8: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F642AC: A3E60008  lhz r31, 8(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F642B0: 57DCD1BE  srwi r28, r30, 6
	ctx.r[28].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82F642B4: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82F642B8: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 82F642BC: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F642C0: 7C63E278  xor r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[28].u64;
	// 82F642C4: 7C63F278  xor r3, r3, r30
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[30].u64;
	// 82F642C8: 7C634038  and r3, r3, r8
	ctx.r[3].u64 = ctx.r[3].u64 & ctx.r[8].u64;
	// 82F642CC: 7F034840  cmplw cr6, r3, r9
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F642D0: 409A0050  bne cr6, 0x82f64320
	if !ctx.cr[6].eq {
	pc = 0x82F64320; continue 'dispatch;
	}
	// 82F642D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82F642D8: 419A0020  beq cr6, 0x82f642f8
	if ctx.cr[6].eq {
	pc = 0x82F642F8; continue 'dispatch;
	}
	// 82F642DC: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F642E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F642E4: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F642E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F642EC: 91470008  stw r10, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F642F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F642F4: 9147000C  stw r10, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F642F8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F642FC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64300: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F64304: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64308: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6430C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64310: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64314: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F64318: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F6431C: 480000A0  b 0x82f643bc
	pc = 0x82F643BC; continue 'dispatch;
	// 82F64320: 8BEB0006  lbz r31, 6(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F64324: 886B0007  lbz r3, 7(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F64328: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6432C: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F64330: A3EB0004  lhz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64334: 57DCD1BE  srwi r28, r30, 6
	ctx.r[28].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82F64338: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82F6433C: 7C63FA78  xor r3, r3, r31
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[31].u64;
	// 82F64340: 7C63E278  xor r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[28].u64;
	// 82F64344: 7C63F278  xor r3, r3, r30
	ctx.r[3].u64 = ctx.r[3].u64 ^ ctx.r[30].u64;
	// 82F64348: 7C684038  and r8, r3, r8
	ctx.r[8].u64 = ctx.r[3].u64 & ctx.r[8].u64;
	// 82F6434C: 48000008  b 0x82f64354
	pc = 0x82F64354; continue 'dispatch;
	// 82F64350: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64354: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F64358: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82F6435C: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 82F64360: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64364: 7F034800  cmpw cr6, r3, r9
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82F64368: 409AFFE8  bne cr6, 0x82f64350
	if !ctx.cr[6].eq {
	pc = 0x82F64350; continue 'dispatch;
	}
	// 82F6436C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82F64370: 419A0020  beq cr6, 0x82f64390
	if ctx.cr[6].eq {
	pc = 0x82F64390; continue 'dispatch;
	}
	// 82F64374: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F64378: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6437C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F64380: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64384: 91470008  stw r10, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F64388: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6438C: 9147000C  stw r10, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F64390: 90A80000  stw r5, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F64394: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F64398: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6439C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F643A0: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F643A4: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F643A8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F643AC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F643B0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F643B4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82F643B8: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F643BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F643C0: 4BD45098  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F643C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F643C8 size=96
    let mut pc: u32 = 0x82F643C8;
    'dispatch: loop {
        match pc {
            0x82F643C8 => {
    //   block [0x82F643C8..0x82F64428)
	// 82F643C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F643CC: 4BD45041  bl 0x82ca940c
	ctx.lr = 0x82F643D0;
	sub_82CA93D0(ctx, base);
	// 82F643D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F643D4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F643D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F643DC: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F643E0: 4182000C  beq 0x82f643ec
	if ctx.cr[0].eq {
	pc = 0x82F643EC; continue 'dispatch;
	}
	// 82F643E4: 8BC4001C  lbz r30, 0x1c(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F643E8: 48000008  b 0x82f643f0
	pc = 0x82F643F0; continue 'dispatch;
	// 82F643EC: 83C40004  lwz r30, 4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F643F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F643F4: 3BE4001E  addi r31, r4, 0x1e
	ctx.r[31].s64 = ctx.r[4].s64 + 30;
	// 82F643F8: 409A0008  bne cr6, 0x82f64400
	if !ctx.cr[6].eq {
	pc = 0x82F64400; continue 'dispatch;
	}
	// 82F643FC: 3BE4002A  addi r31, r4, 0x2a
	ctx.r[31].s64 = ctx.r[4].s64 + 42;
	// 82F64400: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F64404: 48036D7D  bl 0x82f9b180
	ctx.lr = 0x82F64408;
	sub_82F9B180(ctx, base);
	// 82F64408: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82F6440C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F64410: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F64414: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F64418: 4BFFF489  bl 0x82f638a0
	ctx.lr = 0x82F6441C;
	sub_82F638A0(ctx, base);
	// 82F6441C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F64420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F64424: 4BD45038  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F64428 size=180
    let mut pc: u32 = 0x82F64428;
    'dispatch: loop {
        match pc {
            0x82F64428 => {
    //   block [0x82F64428..0x82F644DC)
	// 82F64428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6442C: 4BD44FD9  bl 0x82ca9404
	ctx.lr = 0x82F64430;
	sub_82CA93D0(ctx, base);
	// 82F64430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64434: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82F64438: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6443C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82F64440: 419A0088  beq cr6, 0x82f644c8
	if ctx.cr[6].eq {
	pc = 0x82F644C8; continue 'dispatch;
	}
	// 82F64444: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64448: 556A0FFF  rlwinm. r10, r11, 1, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6444C: 4182002C  beq 0x82f64478
	if ctx.cr[0].eq {
	pc = 0x82F64478; continue 'dispatch;
	}
	// 82F64450: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64454: 3D2000FF  lis r9, 0xff
	ctx.r[9].s64 = 16711680;
	// 82F64458: 6129FFFF  ori r9, r9, 0xffff
	ctx.r[9].u64 = ctx.r[9].u64 | 65535;
	// 82F6445C: 556B023E  clrlwi r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00FFFFFFu64;
	// 82F64460: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F64464: 409A000C  bne cr6, 0x82f64470
	if !ctx.cr[6].eq {
	pc = 0x82F64470; continue 'dispatch;
	}
	// 82F64468: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82F6446C: 48000010  b 0x82f6447c
	pc = 0x82F6447C; continue 'dispatch;
	// 82F64470: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82F64474: 48000008  b 0x82f6447c
	pc = 0x82F6447C; continue 'dispatch;
	// 82F64478: 83A40008  lwz r29, 8(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6447C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F64480: 419A000C  beq cr6, 0x82f6448c
	if ctx.cr[6].eq {
	pc = 0x82F6448C; continue 'dispatch;
	}
	// 82F64484: 8BC4001C  lbz r30, 0x1c(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F64488: 48000008  b 0x82f64490
	pc = 0x82F64490; continue 'dispatch;
	// 82F6448C: 83C40004  lwz r30, 4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64490: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F64494: 3BE4001E  addi r31, r4, 0x1e
	ctx.r[31].s64 = ctx.r[4].s64 + 30;
	// 82F64498: 409A0008  bne cr6, 0x82f644a0
	if !ctx.cr[6].eq {
	pc = 0x82F644A0; continue 'dispatch;
	}
	// 82F6449C: 3BE4002A  addi r31, r4, 0x2a
	ctx.r[31].s64 = ctx.r[4].s64 + 42;
	// 82F644A0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F644A4: 48036CDD  bl 0x82f9b180
	ctx.lr = 0x82F644A8;
	sub_82F9B180(ctx, base);
	// 82F644A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82F644AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F644B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F644B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F644B8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82F644BC: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82F644C0: 4BFFF459  bl 0x82f63918
	ctx.lr = 0x82F644C4;
	sub_82F63918(ctx, base);
	// 82F644C4: 4800000C  b 0x82f644d0
	pc = 0x82F644D0; continue 'dispatch;
	// 82F644C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F644CC: 4BFFFEFD  bl 0x82f643c8
	ctx.lr = 0x82F644D0;
	sub_82F643C8(ctx, base);
	// 82F644D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F644D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F644D8: 4BD44F7C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F644E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F644E0 size=220
    let mut pc: u32 = 0x82F644E0;
    'dispatch: loop {
        match pc {
            0x82F644E0 => {
    //   block [0x82F644E0..0x82F645BC)
	// 82F644E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F644E4: 4BD44F15  bl 0x82ca93f8
	ctx.lr = 0x82F644E8;
	sub_82CA93D0(ctx, base);
	// 82F644E8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F644EC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82F644F0: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 82F644F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F644F8: 4BF98B19  bl 0x82efd010
	ctx.lr = 0x82F644FC;
	sub_82EFD010(ctx, base);
	// 82F644FC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F64500: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F64504: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 82F64508: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82F6450C: 396B22EC  addi r11, r11, 0x22ec
	ctx.r[11].s64 = ctx.r[11].s64 + 8940;
	// 82F64510: 3BC00400  li r30, 0x400
	ctx.r[30].s64 = 1024;
	// 82F64514: 3BA00200  li r29, 0x200
	ctx.r[29].s64 = 512;
	// 82F64518: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6451C: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82F64520: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82F64524: 3B400030  li r26, 0x30
	ctx.r[26].s64 = 48;
	// 82F64528: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82F6452C: 3B600002  li r27, 2
	ctx.r[27].s64 = 2;
	// 82F64530: 933F001C  stw r25, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[25].u32 ) };
	// 82F64534: 3B800100  li r28, 0x100
	ctx.r[28].s64 = 256;
	// 82F64538: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 82F6453C: 937F0024  stw r27, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[27].u32 ) };
	// 82F64540: C00A0C14  lfs f0, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64544: 939F0028  stw r28, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[28].u32 ) };
	// 82F64548: C1A9169C  lfs f13, 0x169c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(5788 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6454C: 93BF002C  stw r29, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[29].u32 ) };
	// 82F64550: C18822E8  lfs f12, 0x22e8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8936 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F64554: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82F64558: 9B1F0030  stb r24, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[24].u8 ) };
	// 82F6455C: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82F64560: 93BF003C  stw r29, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 82F64564: D19F0044  stfs f12, 0x44(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82F64568: 38600A00  li r3, 0xa00
	ctx.r[3].s64 = 2560;
	// 82F6456C: 4BF992F5  bl 0x82efd860
	ctx.lr = 0x82F64570;
	sub_82EFD860(ctx, base);
	// 82F64570: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F64574: 4182000C  beq 0x82f64580
	if ctx.cr[0].eq {
	pc = 0x82F64580; continue 'dispatch;
	}
	// 82F64578: 4BFFF589  bl 0x82f63b00
	ctx.lr = 0x82F6457C;
	sub_82F63B00(ctx, base);
	// 82F6457C: 48000008  b 0x82f64584
	pc = 0x82F64584; continue 'dispatch;
	// 82F64580: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F64584: 907F0048  stw r3, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 82F64588: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6458C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82F64590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F64594: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82F64598: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82F6459C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82F645A0: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82F645A4: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82F645A8: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82F645AC: 4BFFDCED  bl 0x82f62298
	ctx.lr = 0x82F645B0;
	sub_82F62298(ctx, base);
	// 82F645B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F645B4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82F645B8: 4BD44E90  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F645C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F645C0 size=584
    let mut pc: u32 = 0x82F645C0;
    'dispatch: loop {
        match pc {
            0x82F645C0 => {
    //   block [0x82F645C0..0x82F64808)
	// 82F645C0: DBE1FFF8  stfd f31, -8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[31].u64 ) };
	// 82F645C4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F645C8: C1440004  lfs f10, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F645CC: C0A40000  lfs f5, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82F645D0: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F645D4: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F645D8: C06A000C  lfs f3, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82F645DC: C0CA0000  lfs f6, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82F645E0: FF035000  fcmpu cr6, f3, f10
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[10].f64);
	// 82F645E4: C04A0004  lfs f2, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F645E8: C08A0008  lfs f4, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82F645EC: 41980020  blt cr6, 0x82f6460c
	if ctx.cr[6].lt {
	pc = 0x82F6460C; continue 'dispatch;
	}
	// 82F645F0: FF0D1000  fcmpu cr6, f13, f2
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[2].f64);
	// 82F645F4: 41980018  blt cr6, 0x82f6460c
	if ctx.cr[6].lt {
	pc = 0x82F6460C; continue 'dispatch;
	}
	// 82F645F8: FF0B3000  fcmpu cr6, f11, f6
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[6].f64);
	// 82F645FC: 41980010  blt cr6, 0x82f6460c
	if ctx.cr[6].lt {
	pc = 0x82F6460C; continue 'dispatch;
	}
	// 82F64600: FF042800  fcmpu cr6, f4, f5
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[5].f64);
	// 82F64604: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F64608: 40980008  bge cr6, 0x82f64610
	if !ctx.cr[6].lt {
	pc = 0x82F64610; continue 'dispatch;
	}
	// 82F6460C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F64610: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64614: 4082001C  bne 0x82f64630
	if !ctx.cr[0].eq {
	pc = 0x82F64630; continue 'dispatch;
	}
	// 82F64618: C1A1FFEC  lfs f13, -0x14(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6461C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F64620: C161FFE8  lfs f11, -0x18(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F64624: C181FFE4  lfs f12, -0x1c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F64628: C001FFE0  lfs f0, -0x20(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6462C: 48000048  b 0x82f64674
	pc = 0x82F64674; continue 'dispatch;
	// 82F64630: FF062800  fcmpu cr6, f6, f5
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[5].f64);
	// 82F64634: 4099000C  ble cr6, 0x82f64640
	if !ctx.cr[6].gt {
	pc = 0x82F64640; continue 'dispatch;
	}
	// 82F64638: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 82F6463C: 48000008  b 0x82f64644
	pc = 0x82F64644; continue 'dispatch;
	// 82F64640: FC002890  fmr f0, f5
	ctx.f[0].f64 = ctx.f[5].f64;
	// 82F64644: FF045800  fcmpu cr6, f4, f11
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[11].f64);
	// 82F64648: 41990008  bgt cr6, 0x82f64650
	if ctx.cr[6].gt {
	pc = 0x82F64650; continue 'dispatch;
	}
	// 82F6464C: FD602090  fmr f11, f4
	ctx.f[11].f64 = ctx.f[4].f64;
	// 82F64650: FF025000  fcmpu cr6, f2, f10
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[10].f64);
	// 82F64654: 4099000C  ble cr6, 0x82f64660
	if !ctx.cr[6].gt {
	pc = 0x82F64660; continue 'dispatch;
	}
	// 82F64658: FD801090  fmr f12, f2
	ctx.f[12].f64 = ctx.f[2].f64;
	// 82F6465C: 48000008  b 0x82f64664
	pc = 0x82F64664; continue 'dispatch;
	// 82F64660: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 82F64664: FF036800  fcmpu cr6, f3, f13
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[13].f64);
	// 82F64668: 41990008  bgt cr6, 0x82f64670
	if ctx.cr[6].gt {
	pc = 0x82F64670; continue 'dispatch;
	}
	// 82F6466C: FDA01890  fmr f13, f3
	ctx.f[13].f64 = ctx.f[3].f64;
	// 82F64670: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F64674: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64678: 4082001C  bne 0x82f64694
	if !ctx.cr[0].eq {
	pc = 0x82F64694; continue 'dispatch;
	}
	// 82F6467C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F64680: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64684: FD200090  fmr f9, f0
	ctx.f[9].f64 = ctx.f[0].f64;
	// 82F64688: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	// 82F6468C: FCE00090  fmr f7, f0
	ctx.f[7].f64 = ctx.f[0].f64;
	// 82F64690: 48000024  b 0x82f646b4
	pc = 0x82F646B4; continue 'dispatch;
	// 82F64694: FD206090  fmr f9, f12
	ctx.f[9].f64 = ctx.f[12].f64;
	// 82F64698: FD005890  fmr f8, f11
	ctx.f[8].f64 = ctx.f[11].f64;
	// 82F6469C: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 82F646A0: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82F646A4: 40980010  bge cr6, 0x82f646b4
	if !ctx.cr[6].lt {
	pc = 0x82F646B4; continue 'dispatch;
	}
	// 82F646A8: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82F646AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F646B0: 41980008  blt cr6, 0x82f646b8
	if ctx.cr[6].lt {
	pc = 0x82F646B8; continue 'dispatch;
	}
	// 82F646B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F646B8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F646BC: 41820030  beq 0x82f646ec
	if ctx.cr[0].eq {
	pc = 0x82F646EC; continue 'dispatch;
	}
	// 82F646C0: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F646C4: FC002890  fmr f0, f5
	ctx.f[0].f64 = ctx.f[5].f64;
	// 82F646C8: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F646CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F646D0: D0AA0000  stfs f5, 0(r10)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F646D4: D14A0004  stfs f10, 4(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F646D8: D00A0008  stfs f0, 8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F646DC: D14A000C  stfs f10, 0xc(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F646E0: D1AA0018  stfs f13, 0x18(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82F646E4: D18A001C  stfs f12, 0x1c(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82F646E8: 48000118  b 0x82f64800
	pc = 0x82F64800; continue 'dispatch;
	// 82F646EC: FF003000  fcmpu cr6, f0, f6
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[6].f64);
	// 82F646F0: 409A0020  bne cr6, 0x82f64710
	if !ctx.cr[6].eq {
	pc = 0x82F64710; continue 'dispatch;
	}
	// 82F646F4: FF082000  fcmpu cr6, f8, f4
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[4].f64);
	// 82F646F8: 409A0018  bne cr6, 0x82f64710
	if !ctx.cr[6].eq {
	pc = 0x82F64710; continue 'dispatch;
	}
	// 82F646FC: FF091000  fcmpu cr6, f9, f2
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[2].f64);
	// 82F64700: 409A0010  bne cr6, 0x82f64710
	if !ctx.cr[6].eq {
	pc = 0x82F64710; continue 'dispatch;
	}
	// 82F64704: FF071800  fcmpu cr6, f7, f3
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[3].f64);
	// 82F64708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6470C: 419A0008  beq cr6, 0x82f64714
	if ctx.cr[6].eq {
	pc = 0x82F64714; continue 'dispatch;
	}
	// 82F64710: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F64714: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64718: 418200E4  beq 0x82f647fc
	if ctx.cr[0].eq {
	pc = 0x82F647FC; continue 'dispatch;
	}
	// 82F6471C: C14A0010  lfs f10, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F64720: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82F64724: C16A0014  lfs f11, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F64728: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82F6472C: C18A0018  lfs f12, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F64730: C1AA001C  lfs f13, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F64734: 419A0024  beq cr6, 0x82f64758
	if ctx.cr[6].eq {
	pc = 0x82F64758; continue 'dispatch;
	}
	// 82F64738: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6473C: ECA03028  fsubs f5, f0, f6
	ctx.f[5].f64 = (((ctx.f[0].f64 - ctx.f[6].f64) as f32) as f64);
	// 82F64740: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F64744: EFE43028  fsubs f31, f4, f6
	ctx.f[31].f64 = (((ctx.f[4].f64 - ctx.f[6].f64) as f32) as f64);
	// 82F64748: ED4A0828  fsubs f10, f10, f1
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[1].f64) as f32) as f64);
	// 82F6474C: ED4502B2  fmuls f10, f5, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82F64750: ED4AF824  fdivs f10, f10, f31
	ctx.f[10].f64 = ((ctx.f[10].f64 / ctx.f[31].f64) as f32) as f64;
	// 82F64754: ED4A082A  fadds f10, f10, f1
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[1].f64) as f32) as f64;
	// 82F64758: FF024800  fcmpu cr6, f2, f9
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[9].f64);
	// 82F6475C: 419A0028  beq cr6, 0x82f64784
	if ctx.cr[6].eq {
	pc = 0x82F64784; continue 'dispatch;
	}
	// 82F64760: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F64764: ECA91028  fsubs f5, f9, f2
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[2].f64) as f32) as f64);
	// 82F64768: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6476C: EFE31028  fsubs f31, f3, f2
	ctx.f[31].f64 = (((ctx.f[3].f64 - ctx.f[2].f64) as f32) as f64);
	// 82F64770: ED6B0828  fsubs f11, f11, f1
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[1].f64) as f32) as f64);
	// 82F64774: C02A0014  lfs f1, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F64778: ED6B0172  fmuls f11, f11, f5
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[5].f64) as f32) as f64);
	// 82F6477C: ED6BF824  fdivs f11, f11, f31
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[31].f64) as f32) as f64;
	// 82F64780: ED6B082A  fadds f11, f11, f1
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64;
	// 82F64784: FF044000  fcmpu cr6, f4, f8
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[8].f64);
	// 82F64788: 419A0028  beq cr6, 0x82f647b0
	if ctx.cr[6].eq {
	pc = 0x82F647B0; continue 'dispatch;
	}
	// 82F6478C: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F64790: ECA44028  fsubs f5, f4, f8
	ctx.f[5].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 82F64794: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F64798: ECC43028  fsubs f6, f4, f6
	ctx.f[6].f64 = (((ctx.f[4].f64 - ctx.f[6].f64) as f32) as f64);
	// 82F6479C: ED8C0828  fsubs f12, f12, f1
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[1].f64) as f32) as f64);
	// 82F647A0: C08A0018  lfs f4, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82F647A4: ED8C0172  fmuls f12, f12, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[5].f64) as f32) as f64);
	// 82F647A8: ED8C3024  fdivs f12, f12, f6
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[6].f64) as f32) as f64;
	// 82F647AC: ED846028  fsubs f12, f4, f12
	ctx.f[12].f64 = (((ctx.f[4].f64 - ctx.f[12].f64) as f32) as f64);
	// 82F647B0: FF033800  fcmpu cr6, f3, f7
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[7].f64);
	// 82F647B4: 419A0028  beq cr6, 0x82f647dc
	if ctx.cr[6].eq {
	pc = 0x82F647DC; continue 'dispatch;
	}
	// 82F647B8: C0AB0004  lfs f5, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82F647BC: ECC33828  fsubs f6, f3, f7
	ctx.f[6].f64 = (((ctx.f[3].f64 - ctx.f[7].f64) as f32) as f64);
	// 82F647C0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F647C4: EC831028  fsubs f4, f3, f2
	ctx.f[4].f64 = (((ctx.f[3].f64 - ctx.f[2].f64) as f32) as f64);
	// 82F647C8: EDAD2828  fsubs f13, f13, f5
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[5].f64) as f32) as f64);
	// 82F647CC: C0AA001C  lfs f5, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82F647D0: EDAD01B2  fmuls f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 82F647D4: EDAD2024  fdivs f13, f13, f4
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[4].f64) as f32) as f64;
	// 82F647D8: EDA56828  fsubs f13, f5, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F647DC: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F647E0: D12A0004  stfs f9, 4(r10)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F647E4: D10A0008  stfs f8, 8(r10)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F647E8: D0EA000C  stfs f7, 0xc(r10)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F647EC: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F647F0: D16B0004  stfs f11, 4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F647F4: D18B0008  stfs f12, 8(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F647F8: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F647FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F64800: CBE1FFF8  lfd f31, -8(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82F64804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F64808 size=164
    let mut pc: u32 = 0x82F64808;
    'dispatch: loop {
        match pc {
            0x82F64808 => {
    //   block [0x82F64808..0x82F648AC)
	// 82F64808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6480C: 4BD44C01  bl 0x82ca940c
	ctx.lr = 0x82F64810;
	sub_82CA93D0(ctx, base);
	// 82F64810: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F64818: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6481C: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82F64820: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F64824: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64828: 419A001C  beq cr6, 0x82f64844
	if ctx.cr[6].eq {
	pc = 0x82F64844; continue 'dispatch;
	}
	// 82F6482C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64830: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82F64834: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F64838: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F6483C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F64840: 4E800421  bctrl
	ctx.lr = 0x82F64844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F64844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F64848: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F6484C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F64850: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F64854: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F64858: 4BFFE111  bl 0x82f62968
	ctx.lr = 0x82F6485C;
	sub_82F62968(ctx, base);
	// 82F6485C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F64860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64864: 419A0008  beq cr6, 0x82f6486c
	if ctx.cr[6].eq {
	pc = 0x82F6486C; continue 'dispatch;
	}
	// 82F64868: 4BF99039  bl 0x82efd8a0
	ctx.lr = 0x82F6486C;
	sub_82EFD8A0(ctx, base);
	// 82F6486C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F64870: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F64874: 4BFFE515  bl 0x82f62d88
	ctx.lr = 0x82F64878;
	sub_82F62D88(ctx, base);
	// 82F64878: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6487C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64880: 419A0008  beq cr6, 0x82f64888
	if ctx.cr[6].eq {
	pc = 0x82F64888; continue 'dispatch;
	}
	// 82F64884: 4BF9901D  bl 0x82efd8a0
	ctx.lr = 0x82F64888;
	sub_82EFD8A0(ctx, base);
	// 82F64888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6488C: 4BFFE065  bl 0x82f628f0
	ctx.lr = 0x82F64890;
	sub_82F628F0(ctx, base);
	// 82F64890: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64894: 4182000C  beq 0x82f648a0
	if ctx.cr[0].eq {
	pc = 0x82F648A0; continue 'dispatch;
	}
	// 82F64898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6489C: 4BF99005  bl 0x82efd8a0
	ctx.lr = 0x82F648A0;
	sub_82EFD8A0(ctx, base);
	// 82F648A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F648A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F648A8: 4BD44BB4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F648B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F648B0 size=356
    let mut pc: u32 = 0x82F648B0;
    'dispatch: loop {
        match pc {
            0x82F648B0 => {
    //   block [0x82F648B0..0x82F64A14)
	// 82F648B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F648B4: 4BD44B51  bl 0x82ca9404
	ctx.lr = 0x82F648B8;
	sub_82CA93D0(ctx, base);
	// 82F648B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F648BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F648C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F648C4: 93A100AC  stw r29, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 82F648C8: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 82F648CC: 3BFE08E0  addi r31, r30, 0x8e0
	ctx.r[31].s64 = ctx.r[30].s64 + 2272;
	// 82F648D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F648D4: 4BFFE55D  bl 0x82f62e30
	ctx.lr = 0x82F648D8;
	sub_82F62E30(ctx, base);
	// 82F648D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F648DC: 418200B0  beq 0x82f6498c
	if ctx.cr[0].eq {
	pc = 0x82F6498C; continue 'dispatch;
	}
	// 82F648E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F648E4: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 82F648E8: 48068CD1  bl 0x82fcd5b8
	ctx.lr = 0x82F648EC;
	sub_82FCD5B8(ctx, base);
	// 82F648EC: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 82F648F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F648F4: 4BFEE58D  bl 0x82f52e80
	ctx.lr = 0x82F648F8;
	sub_82F52E80(ctx, base);
	// 82F648F8: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 82F648FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F64900: 4BFFE111  bl 0x82f62a10
	ctx.lr = 0x82F64904;
	sub_82F62A10(ctx, base);
	// 82F64904: 3B9E0028  addi r28, r30, 0x28
	ctx.r[28].s64 = ctx.r[30].s64 + 40;
	// 82F64908: 83FE002C  lwz r31, 0x2c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6490C: 48000078  b 0x82f64984
	pc = 0x82F64984; continue 'dispatch;
	// 82F64910: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64914: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82F64918: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6491C: 419A0044  beq cr6, 0x82f64960
	if ctx.cr[6].eq {
	pc = 0x82F64960; continue 'dispatch;
	}
	// 82F64920: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64924: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F64928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6492C: 40990034  ble cr6, 0x82f64960
	if !ctx.cr[6].gt {
	pc = 0x82F64960; continue 'dispatch;
	}
	// 82F64930: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F64934: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64938: 7F08E840  cmplw cr6, r8, r29
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82F6493C: 419A0020  beq cr6, 0x82f6495c
	if ctx.cr[6].eq {
	pc = 0x82F6495C; continue 'dispatch;
	}
	// 82F64940: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64944: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F64948: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82F6494C: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64950: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F64954: 4198FFE0  blt cr6, 0x82f64934
	if ctx.cr[6].lt {
	pc = 0x82F64934; continue 'dispatch;
	}
	// 82F64958: 48000008  b 0x82f64960
	pc = 0x82F64960; continue 'dispatch;
	// 82F6495C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F64960: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64964: 4182001C  beq 0x82f64980
	if ctx.cr[0].eq {
	pc = 0x82F64980; continue 'dispatch;
	}
	// 82F64968: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6496C: 4182000C  beq 0x82f64978
	if ctx.cr[0].eq {
	pc = 0x82F64978; continue 'dispatch;
	}
	// 82F64970: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F64974: 4BFFFE95  bl 0x82f64808
	ctx.lr = 0x82F64978;
	sub_82F64808(ctx, base);
	// 82F64978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6497C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F64980: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64984: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82F64988: 409AFF88  bne cr6, 0x82f64910
	if !ctx.cr[6].eq {
	pc = 0x82F64910; continue 'dispatch;
	}
	// 82F6498C: 83FE08F8  lwz r31, 0x8f8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2296 as u32) ) } as u64;
	// 82F64990: 3B7E08F4  addi r27, r30, 0x8f4
	ctx.r[27].s64 = ctx.r[30].s64 + 2292;
	// 82F64994: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82F64998: 419A0074  beq cr6, 0x82f64a0c
	if ctx.cr[6].eq {
	pc = 0x82F64A0C; continue 'dispatch;
	}
	// 82F6499C: 3BBE08E4  addi r29, r30, 0x8e4
	ctx.r[29].s64 = ctx.r[30].s64 + 2276;
	// 82F649A0: 3B9E08FC  addi r28, r30, 0x8fc
	ctx.r[28].s64 = ctx.r[30].s64 + 2300;
	// 82F649A4: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F649A8: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F649AC: 4BF938ED  bl 0x82ef8298
	ctx.lr = 0x82F649B0;
	sub_82EF8298(ctx, base);
	// 82F649B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F649B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F649B8: A15F000C  lhz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F649BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F649C0: 893F000E  lbz r9, 0xe(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 82F649C4: 891F000F  lbz r8, 0xf(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(15 as u32) ) } as u64;
	// 82F649C8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F649CC: B1410054  sth r10, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u16 ) };
	// 82F649D0: 99210056  stb r9, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[9].u8 ) };
	// 82F649D4: 99010057  stb r8, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[8].u8 ) };
	// 82F649D8: 4BFFE919  bl 0x82f632f0
	ctx.lr = 0x82F649DC;
	sub_82F632F0(ctx, base);
	// 82F649DC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F649E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F649E4: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82F649E8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F649EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F649F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F649F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F649F8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F649FC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F64A00: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82F64A04: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82F64A08: 409AFF9C  bne cr6, 0x82f649a4
	if !ctx.cr[6].eq {
	pc = 0x82F649A4; continue 'dispatch;
	}
	// 82F64A0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F64A10: 4BD44A44  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F64A18 size=160
    let mut pc: u32 = 0x82F64A18;
    'dispatch: loop {
        match pc {
            0x82F64A18 => {
    //   block [0x82F64A18..0x82F64AB8)
	// 82F64A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F64A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F64A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F64A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F64A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64A2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F64A30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F64A34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F64A38: 419A0068  beq cr6, 0x82f64aa0
	if ctx.cr[6].eq {
	pc = 0x82F64AA0; continue 'dispatch;
	}
	// 82F64A3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F64A40: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64A44: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F64A48: 419A0020  beq cr6, 0x82f64a68
	if ctx.cr[6].eq {
	pc = 0x82F64A68; continue 'dispatch;
	}
	// 82F64A4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64A50: 419A000C  beq cr6, 0x82f64a5c
	if ctx.cr[6].eq {
	pc = 0x82F64A5C; continue 'dispatch;
	}
	// 82F64A54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F64A58: 4BFFFDB1  bl 0x82f64808
	ctx.lr = 0x82F64A5C;
	sub_82F64808(ctx, base);
	// 82F64A5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F64A60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F64A64: 4800003C  b 0x82f64aa0
	pc = 0x82F64AA0; continue 'dispatch;
	// 82F64A68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64A6C: 419A000C  beq cr6, 0x82f64a78
	if ctx.cr[6].eq {
	pc = 0x82F64A78; continue 'dispatch;
	}
	// 82F64A70: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F64A74: 4BFFFD95  bl 0x82f64808
	ctx.lr = 0x82F64A78;
	sub_82F64808(ctx, base);
	// 82F64A78: 397E0018  addi r11, r30, 0x18
	ctx.r[11].s64 = ctx.r[30].s64 + 24;
	// 82F64A7C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64A80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64A84: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F64A88: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64A8C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64A90: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F64A94: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F64A98: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F64A9C: 93FE0024  stw r31, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 82F64AA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F64AA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F64AA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F64AAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F64AB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F64AB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F64AB8 size=88
    let mut pc: u32 = 0x82F64AB8;
    'dispatch: loop {
        match pc {
            0x82F64AB8 => {
    //   block [0x82F64AB8..0x82F64B10)
	// 82F64AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F64ABC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F64AC0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64AC4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F64AC8: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82F64ACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F64AD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F64AD4: 892B0006  lbz r9, 6(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F64AD8: 894B0007  lbz r10, 7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F64ADC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64AE0: 7D4A4A78  xor r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 ^ ctx.r[9].u64;
	// 82F64AE4: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64AE8: 5509D1BE  srwi r9, r8, 6
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F64AEC: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82F64AF0: 7D4B5A78  xor r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 82F64AF4: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82F64AF8: 7D654278  xor r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F64AFC: 4BFFF6BD  bl 0x82f641b8
	ctx.lr = 0x82F64B00;
	sub_82F641B8(ctx, base);
	// 82F64B00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F64B04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F64B08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F64B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F64B10 size=8
    let mut pc: u32 = 0x82F64B10;
    'dispatch: loop {
        match pc {
            0x82F64B10 => {
    //   block [0x82F64B10..0x82F64B18)
	// 82F64B10: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64B14: 4BFFFD9C  b 0x82f648b0
	sub_82F648B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F64B18 size=136
    let mut pc: u32 = 0x82F64B18;
    'dispatch: loop {
        match pc {
            0x82F64B18 => {
    //   block [0x82F64B18..0x82F64BA0)
	// 82F64B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F64B1C: 4BD448E9  bl 0x82ca9404
	ctx.lr = 0x82F64B20;
	sub_82CA93D0(ctx, base);
	// 82F64B20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64B24: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F64B28: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82F64B2C: 3B9E0028  addi r28, r30, 0x28
	ctx.r[28].s64 = ctx.r[30].s64 + 40;
	// 82F64B30: 83FE002C  lwz r31, 0x2c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F64B34: 48000024  b 0x82f64b58
	pc = 0x82F64B58; continue 'dispatch;
	// 82F64B38: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64B3C: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82F64B40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64B44: 419A000C  beq cr6, 0x82f64b50
	if ctx.cr[6].eq {
	pc = 0x82F64B50; continue 'dispatch;
	}
	// 82F64B48: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F64B4C: 4BFFFCBD  bl 0x82f64808
	ctx.lr = 0x82F64B50;
	sub_82F64808(ctx, base);
	// 82F64B50: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64B54: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F64B58: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82F64B5C: 409AFFDC  bne cr6, 0x82f64b38
	if !ctx.cr[6].eq {
	pc = 0x82F64B38; continue 'dispatch;
	}
	// 82F64B60: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 82F64B64: 4806604D  bl 0x82fcabb0
	ctx.lr = 0x82F64B68;
	sub_82FCABB0(ctx, base);
	// 82F64B68: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64B6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F64B70: 419A0028  beq cr6, 0x82f64b98
	if ctx.cr[6].eq {
	pc = 0x82F64B98; continue 'dispatch;
	}
	// 82F64B74: 897E0014  lbz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64B78: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F64B7C: 4182001C  beq 0x82f64b98
	if ctx.cr[0].eq {
	pc = 0x82F64B98; continue 'dispatch;
	}
	// 82F64B80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64B84: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82F64B88: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F64B8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F64B90: 4E800421  bctrl
	ctx.lr = 0x82F64B94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F64B94: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F64B98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F64B9C: 4BD448B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F64BA0 size=156
    let mut pc: u32 = 0x82F64BA0;
    'dispatch: loop {
        match pc {
            0x82F64BA0 => {
    //   block [0x82F64BA0..0x82F64C3C)
	// 82F64BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F64BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F64BA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F64BAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F64BB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F64BB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F64BBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64BC0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F64BC4: 419A0060  beq cr6, 0x82f64c24
	if ctx.cr[6].eq {
	pc = 0x82F64C24; continue 'dispatch;
	}
	// 82F64BC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F64BCC: 419A0008  beq cr6, 0x82f64bd4
	if ctx.cr[6].eq {
	pc = 0x82F64BD4; continue 'dispatch;
	}
	// 82F64BD0: 4BFFFF49  bl 0x82f64b18
	ctx.lr = 0x82F64BD4;
	sub_82F64B18(ctx, base);
	// 82F64BD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F64BD8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F64BDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F64BE0: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82F64BE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F64BE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64BEC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64BF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F64BF4: 4E800421  bctrl
	ctx.lr = 0x82F64BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F64BF8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F64BFC: 556B035D  rlwinm. r11, r11, 0, 0xd, 0xe
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64C00: 41820024  beq 0x82f64c24
	if ctx.cr[0].eq {
	pc = 0x82F64C24; continue 'dispatch;
	}
	// 82F64C04: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64C08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F64C0C: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 82F64C10: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82F64C14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64C18: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82F64C1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F64C20: 4E800421  bctrl
	ctx.lr = 0x82F64C24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F64C24: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F64C28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F64C2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F64C30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F64C34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F64C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F64C40 size=356
    let mut pc: u32 = 0x82F64C40;
    'dispatch: loop {
        match pc {
            0x82F64C40 => {
    //   block [0x82F64C40..0x82F64DA4)
	// 82F64C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F64C44: 4BD447BD  bl 0x82ca9400
	ctx.lr = 0x82F64C48;
	sub_82CA93D0(ctx, base);
	// 82F64C48: DBC1FFB8  stfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 82F64C4C: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82F64C50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64C54: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64C58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F64C5C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82F64C60: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F64C64: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64C68: 4BFFFF39  bl 0x82f64ba0
	ctx.lr = 0x82F64C6C;
	sub_82F64BA0(ctx, base);
	// 82F64C6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F64C70: 419A0120  beq cr6, 0x82f64d90
	if ctx.cr[6].eq {
	pc = 0x82F64D90; continue 'dispatch;
	}
	// 82F64C74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F64C78: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82F64C7C: 409A0114  bne cr6, 0x82f64d90
	if !ctx.cr[6].eq {
	pc = 0x82F64D90; continue 'dispatch;
	}
	// 82F64C80: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64C84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F64C88: 419A0108  beq cr6, 0x82f64d90
	if ctx.cr[6].eq {
	pc = 0x82F64D90; continue 'dispatch;
	}
	// 82F64C8C: 897E0025  lbz r11, 0x25(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(37 as u32) ) } as u64;
	// 82F64C90: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F64C94: 408200FC  bne 0x82f64d90
	if !ctx.cr[0].eq {
	pc = 0x82F64D90; continue 'dispatch;
	}
	// 82F64C98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F64C9C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64CA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F64CA4: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82F64CA8: 409A0008  bne cr6, 0x82f64cb0
	if !ctx.cr[6].eq {
	pc = 0x82F64CB0; continue 'dispatch;
	}
	// 82F64CAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F64CB0: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64CB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F64CB8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82F64CBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F64CC0: 409900C8  ble cr6, 0x82f64d88
	if !ctx.cr[6].gt {
	pc = 0x82F64D88; continue 'dispatch;
	}
	// 82F64CC4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F64CC8: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F64CCC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82F64CD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82F64CD4: 3B6BEC58  addi r27, r11, -0x13a8
	ctx.r[27].s64 = ctx.r[11].s64 + -5032;
	// 82F64CD8: C3CA0BFC  lfs f30, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82F64CDC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F64CE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F64CE4: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82F64CE8: 419A0070  beq cr6, 0x82f64d58
	if ctx.cr[6].eq {
	pc = 0x82F64D58; continue 'dispatch;
	}
	// 82F64CEC: 89240006  lbz r9, 6(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F64CF0: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F64CF4: 41820064  beq 0x82f64d58
	if ctx.cr[0].eq {
	pc = 0x82F64D58; continue 'dispatch;
	}
	// 82F64CF8: A1640010  lhz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F64CFC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F64D00: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F64D04: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F64D08: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F64D0C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F64D10: EC00F7FA  fmadds f0, f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82F64D14: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82F64D18: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82F64D1C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F64D20: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 82F64D24: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F64D28: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F64D2C: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82F64D30: 4199001C  bgt cr6, 0x82f64d4c
	if ctx.cr[6].gt {
	pc = 0x82F64D4C; continue 'dispatch;
	}
	// 82F64D34: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82F64D38: 395B0004  addi r10, r27, 4
	ctx.r[10].s64 = ctx.r[27].s64 + 4;
	// 82F64D3C: 896B07E0  lbz r11, 0x7e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2016 as u32) ) } as u64;
	// 82F64D40: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82F64D44: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F64D48: 48000008  b 0x82f64d50
	pc = 0x82F64D50; continue 'dispatch;
	// 82F64D4C: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82F64D50: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F64D54: 409A003C  bne cr6, 0x82f64d90
	if !ctx.cr[6].eq {
	pc = 0x82F64D90; continue 'dispatch;
	}
	// 82F64D58: 80A4000C  lwz r5, 0xc(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F64D5C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82F64D60: 419A0014  beq cr6, 0x82f64d74
	if ctx.cr[6].eq {
	pc = 0x82F64D74; continue 'dispatch;
	}
	// 82F64D64: 387A0030  addi r3, r26, 0x30
	ctx.r[3].s64 = ctx.r[26].s64 + 48;
	// 82F64D68: 4BFFDE21  bl 0x82f62b88
	ctx.lr = 0x82F64D6C;
	sub_82F62B88(ctx, base);
	// 82F64D6C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64D70: 41820020  beq 0x82f64d90
	if ctx.cr[0].eq {
	pc = 0x82F64D90; continue 'dispatch;
	}
	// 82F64D74: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64D78: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82F64D7C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82F64D80: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F64D84: 4198FF58  blt cr6, 0x82f64cdc
	if ctx.cr[6].lt {
	pc = 0x82F64CDC; continue 'dispatch;
	}
	// 82F64D88: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F64D8C: 48000008  b 0x82f64d94
	pc = 0x82F64D94; continue 'dispatch;
	// 82F64D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F64D94: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F64D98: CBC1FFB8  lfd f30, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82F64D9C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82F64DA0: 4BD446B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F64DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F64DA8 size=1260
    let mut pc: u32 = 0x82F64DA8;
    'dispatch: loop {
        match pc {
            0x82F64DA8 => {
    //   block [0x82F64DA8..0x82F65294)
	// 82F64DA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F64DAC: 4BD44641  bl 0x82ca93ec
	ctx.lr = 0x82F64DB0;
	sub_82CA93D0(ctx, base);
	// 82F64DB0: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 82F64DB4: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82F64DB8: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F64DBC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F64DC0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F64DC4: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 82F64DC8: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 82F64DCC: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82F64DD0: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 82F64DD4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F64DD8: 419A04AC  beq cr6, 0x82f65284
	if ctx.cr[6].eq {
	pc = 0x82F65284; continue 'dispatch;
	}
	// 82F64DDC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F64DE0: 4BFE7391  bl 0x82f4c170
	ctx.lr = 0x82F64DE4;
	sub_82F4C170(ctx, base);
	// 82F64DE4: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F64DE8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82F64DEC: C1BD09D8  lfs f13, 0x9d8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2520 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F64DF0: 57F8063F  clrlwi. r24, r31, 0x18
	ctx.r[24].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82F64DF4: C00B1240  lfs f0, 0x1240(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4672 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64DF8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82F64DFC: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 82F64E00: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F64E04: 4182020C  beq 0x82f65010
	if ctx.cr[0].eq {
	pc = 0x82F65010; continue 'dispatch;
	}
	// 82F64E08: 38600094  li r3, 0x94
	ctx.r[3].s64 = 148;
	// 82F64E0C: 4BF98A55  bl 0x82efd860
	ctx.lr = 0x82F64E10;
	sub_82EFD860(ctx, base);
	// 82F64E10: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F64E14: 41820014  beq 0x82f64e28
	if ctx.cr[0].eq {
	pc = 0x82F64E28; continue 'dispatch;
	}
	// 82F64E18: 388003C8  li r4, 0x3c8
	ctx.r[4].s64 = 968;
	// 82F64E1C: 4BFE739D  bl 0x82f4c1b8
	ctx.lr = 0x82F64E20;
	sub_82F4C1B8(ctx, base);
	// 82F64E20: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82F64E24: 48000008  b 0x82f64e2c
	pc = 0x82F64E2C; continue 'dispatch;
	// 82F64E28: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 82F64E2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F64E30: 3BFD0930  addi r31, r29, 0x930
	ctx.r[31].s64 = ctx.r[29].s64 + 2352;
	// 82F64E34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F64E38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F64E3C: C02B0A54  lfs f1, 0xa54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F64E40: 4BFE66C1  bl 0x82f4b500
	ctx.lr = 0x82F64E44;
	sub_82F4B500(ctx, base);
	// 82F64E44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F64E48: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82F64E4C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82F64E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F64E54: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F64E58: C04A9404  lfs f2, -0x6bfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F64E5C: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82F64E60: C0290C14  lfs f1, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F64E64: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82F64E68: 480615F9  bl 0x82fc6460
	ctx.lr = 0x82F64E6C;
	sub_82FC6460(ctx, base);
	// 82F64E6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F64E70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F64E74: 4BFFDDA5  bl 0x82f62c18
	ctx.lr = 0x82F64E78;
	sub_82F62C18(ctx, base);
	// 82F64E78: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F64E7C: 4182000C  beq 0x82f64e88
	if ctx.cr[0].eq {
	pc = 0x82F64E88; continue 'dispatch;
	}
	// 82F64E80: FDA0F090  fmr f13, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[30].f64;
	// 82F64E84: 48000008  b 0x82f64e8c
	pc = 0x82F64E8C; continue 'dispatch;
	// 82F64E88: FDA0F050  fneg f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F64E8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F64E90: 3B9D0900  addi r28, r29, 0x900
	ctx.r[28].s64 = ctx.r[29].s64 + 2304;
	// 82F64E94: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64E98: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F64E9C: D01D0900  stfs f0, 0x900(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(2304 as u32), tmp.u32 ) };
	// 82F64EA0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82F64EA4: 40980008  bge cr6, 0x82f64eac
	if !ctx.cr[6].lt {
	pc = 0x82F64EAC; continue 'dispatch;
	}
	// 82F64EA8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F64EAC: D01C0004  stfs f0, 4(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F64EB0: 935D0908  stw r26, 0x908(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(2312 as u32), ctx.r[26].u32 ) };
	// 82F64EB4: 3BDD0980  addi r30, r29, 0x980
	ctx.r[30].s64 = ctx.r[29].s64 + 2432;
	// 82F64EB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F64EBC: 48061475  bl 0x82fc6330
	ctx.lr = 0x82F64EC0;
	sub_82FC6330(ctx, base);
	// 82F64EC0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82F64EC4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82F64EC8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82F64ECC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F64ED0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F64ED4: 4805A305  bl 0x82fbf1d8
	ctx.lr = 0x82F64ED8;
	sub_82FBF1D8(ctx, base);
	// 82F64ED8: 817D099C  lwz r11, 0x99c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2460 as u32) ) } as u64;
	// 82F64EDC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82F64EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F64EE4: 40990128  ble cr6, 0x82f6500c
	if !ctx.cr[6].gt {
	pc = 0x82F6500C; continue 'dispatch;
	}
	// 82F64EE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F64EEC: C3EBBE14  lfs f31, -0x41ec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F64EF0: 815D09A8  lwz r10, 0x9a8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2472 as u32) ) } as u64;
	// 82F64EF4: 5789E13A  rlwinm r9, r28, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 82F64EF8: 578B06BE  clrlwi r11, r28, 0x1a
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x0000003Fu64;
	// 82F64EFC: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 * 24;
	// 82F64F00: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F64F04: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F64F08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64F0C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82F64F10: 409900EC  ble cr6, 0x82f64ffc
	if !ctx.cr[6].gt {
	pc = 0x82F64FFC; continue 'dispatch;
	}
	// 82F64F14: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64F18: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F64F1C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64F20: 5569D1BA  rlwinm r9, r11, 0x1a, 6, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82F64F24: 556B1D78  rlwinm r11, r11, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82F64F28: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64F2C: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F64F30: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F64F34: 4BFE339D  bl 0x82f482d0
	ctx.lr = 0x82F64F38;
	sub_82F482D0(ctx, base);
	// 82F64F38: 932100C0  stw r25, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u32 ) };
	// 82F64F3C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F64F40: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 82F64F44: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64F48: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F64F4C: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F64F50: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F64F54: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 82F64F58: FC00681E  fctiwz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82F64F5C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F64F60: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 82F64F64: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82F64F68: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82F64F6C: 4BFE44CD  bl 0x82f49438
	ctx.lr = 0x82F64F70;
	sub_82F49438(ctx, base);
	// 82F64F70: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64F74: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 82F64F78: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82F64F7C: 40990060  ble cr6, 0x82f64fdc
	if !ctx.cr[6].gt {
	pc = 0x82F64FDC; continue 'dispatch;
	}
	// 82F64F80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F64F84: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F64F88: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F64F8C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82F64F90: 5569D1BA  rlwinm r9, r11, 0x1a, 6, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82F64F94: 556B1D78  rlwinm r11, r11, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82F64F98: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F64F9C: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F64FA0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F64FA4: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F64FA8: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F64FAC: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F64FB0: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82F64FB4: D9A10060  stfd f13, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[13].u64 ) };
	// 82F64FB8: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82F64FBC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F64FC0: D8010060  stfd f0, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[0].u64 ) };
	// 82F64FC4: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82F64FC8: 4BFE6839  bl 0x82f4b800
	ctx.lr = 0x82F64FCC;
	sub_82F4B800(ctx, base);
	// 82F64FCC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F64FD0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82F64FD4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F64FD8: 4198FFA8  blt cr6, 0x82f64f80
	if ctx.cr[6].lt {
	pc = 0x82F64F80; continue 'dispatch;
	}
	// 82F64FDC: 816100E8  lwz r11, 0xe8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 82F64FE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F64FE4: 419A0018  beq cr6, 0x82f64ffc
	if ctx.cr[6].eq {
	pc = 0x82F64FFC; continue 'dispatch;
	}
	// 82F64FE8: 38BB0034  addi r5, r27, 0x34
	ctx.r[5].s64 = ctx.r[27].s64 + 52;
	// 82F64FEC: 389B0028  addi r4, r27, 0x28
	ctx.r[4].s64 = ctx.r[27].s64 + 40;
	// 82F64FF0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F64FF4: 4BFE3D2D  bl 0x82f48d20
	ctx.lr = 0x82F64FF8;
	sub_82F48D20(ctx, base);
	// 82F64FF8: 9B5B0069  stb r26, 0x69(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(105 as u32), ctx.r[26].u8 ) };
	// 82F64FFC: 817D099C  lwz r11, 0x99c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(2460 as u32) ) } as u64;
	// 82F65000: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82F65004: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F65008: 4198FEE8  blt cr6, 0x82f64ef0
	if ctx.cr[6].lt {
	pc = 0x82F64EF0; continue 'dispatch;
	}
	// 82F6500C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82F65010: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F65014: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82F65018: 4BFE37B1  bl 0x82f487c8
	ctx.lr = 0x82F6501C;
	sub_82F487C8(ctx, base);
	// 82F6501C: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 82F65020: 81410144  lwz r10, 0x144(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 82F65024: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F65028: 40980214  bge cr6, 0x82f6523c
	if !ctx.cr[6].lt {
	pc = 0x82F6523C; continue 'dispatch;
	}
	// 82F6502C: 56DE063E  clrlwi r30, r22, 0x18
	ctx.r[30].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 82F65030: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82F65034: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82F65038: 4BFE4479  bl 0x82f494b0
	ctx.lr = 0x82F6503C;
	sub_82F494B0(ctx, base);
	// 82F6503C: E941010E  lwa r10, 0x10c(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as i32) as i64;
	// 82F65040: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 82F65044: C9810070  lfd f12, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82F65048: E9610112  lwa r11, 0x110(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as i32) as i64;
	// 82F6504C: C0010124  lfs f0, 0x124(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65050: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82F65054: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82F65058: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F6505C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F65060: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F65064: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F65068: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F6506C: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F65070: EFEC0032  fmuls f31, f12, f0
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F65074: 4BFE325D  bl 0x82f482d0
	ctx.lr = 0x82F65078;
	sub_82F482D0(ctx, base);
	// 82F65078: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F6507C: 932100C0  stw r25, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u32 ) };
	// 82F65080: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F65084: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F65088: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 82F6508C: 419A0024  beq cr6, 0x82f650b0
	if ctx.cr[6].eq {
	pc = 0x82F650B0; continue 'dispatch;
	}
	// 82F65090: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F65094: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82F65098: 387D09E0  addi r3, r29, 0x9e0
	ctx.r[3].s64 = ctx.r[29].s64 + 2528;
	// 82F6509C: 48007AED  bl 0x82f6cb88
	ctx.lr = 0x82F650A0;
	sub_82F6CB88(ctx, base);
	// 82F650A0: C3E100B0  lfs f31, 0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F650A4: C3C100B4  lfs f30, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82F650A8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F650AC: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F650B0: FC00F01E  fctiwz f0, f30
	ctx.f[0].s64 = if ctx.f[30].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[30].f64.trunc() as i32 as i64 };
	// 82F650B4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82F650B8: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F650BC: FDA0F81E  fctiwz f13, f31
	ctx.f[13].s64 = if ctx.f[31].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[31].f64.trunc() as i32 as i64 };
	// 82F650C0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F650C4: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82F650C8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F650CC: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F650D0: 4BFE4369  bl 0x82f49438
	ctx.lr = 0x82F650D4;
	sub_82F49438(ctx, base);
	// 82F650D4: 4800011C  b 0x82f651f0
	pc = 0x82F651F0; continue 'dispatch;
	// 82F650D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82F650DC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82F650E0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82F650E4: 4BFE3225  bl 0x82f48308
	ctx.lr = 0x82F650E8;
	sub_82F48308(ctx, base);
	// 82F650E8: 89610090  lbz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F650EC: C0010088  lfs f0, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F650F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F650F4: C1A1008C  lfs f13, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F650F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F650FC: 418200A8  beq 0x82f651a4
	if ctx.cr[0].eq {
	pc = 0x82F651A4; continue 'dispatch;
	}
	// 82F65100: C1810080  lfs f12, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F65104: C1610084  lfs f11, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F65108: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F6510C: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F65110: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82F65114: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82F65118: 419A0048  beq cr6, 0x82f65160
	if ctx.cr[6].eq {
	pc = 0x82F65160; continue 'dispatch;
	}
	// 82F6511C: 3BFD09E0  addi r31, r29, 0x9e0
	ctx.r[31].s64 = ctx.r[29].s64 + 2528;
	// 82F65120: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F65124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F65128: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82F6512C: 48007A5D  bl 0x82f6cb88
	ctx.lr = 0x82F65130;
	sub_82F6CB88(ctx, base);
	// 82F65130: C00100A0  lfs f0, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65134: C1A100A4  lfs f13, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65138: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82F6513C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F65140: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 82F65144: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F65148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6514C: 48007A3D  bl 0x82f6cb88
	ctx.lr = 0x82F65150;
	sub_82F6CB88(ctx, base);
	// 82F65150: C00100A8  lfs f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65154: C1A100AC  lfs f13, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65158: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82F6515C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82F65160: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F65164: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F65168: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82F6516C: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F65170: FD80601E  fctiwz f12, f12
	ctx.f[12].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82F65174: D9810058  stfd f12, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[12].u64 ) };
	// 82F65178: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6517C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82F65180: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82F65184: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F65188: D9A10078  stfd f13, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[13].u64 ) };
	// 82F6518C: 80E1007C  lwz r7, 0x7c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82F65190: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F65194: D9610058  stfd f11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[11].u64 ) };
	// 82F65198: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F6519C: 4BFE667D  bl 0x82f4b818
	ctx.lr = 0x82F651A0;
	sub_82F4B818(ctx, base);
	// 82F651A0: 48000050  b 0x82f651f0
	pc = 0x82F651F0; continue 'dispatch;
	// 82F651A4: D0010050  stfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F651A8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F651AC: 419A0024  beq cr6, 0x82f651d0
	if ctx.cr[6].eq {
	pc = 0x82F651D0; continue 'dispatch;
	}
	// 82F651B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F651B4: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 82F651B8: 387D09E0  addi r3, r29, 0x9e0
	ctx.r[3].s64 = ctx.r[29].s64 + 2528;
	// 82F651BC: 480079CD  bl 0x82f6cb88
	ctx.lr = 0x82F651C0;
	sub_82F6CB88(ctx, base);
	// 82F651C0: C0010098  lfs f0, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F651C4: C1A1009C  lfs f13, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F651C8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F651CC: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F651D0: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82F651D4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F651D8: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F651DC: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82F651E0: D8010078  stfd f0, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[0].u64 ) };
	// 82F651E4: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82F651E8: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F651EC: 4BFE6615  bl 0x82f4b800
	ctx.lr = 0x82F651F0;
	sub_82F4B800(ctx, base);
	// 82F651F0: 81410104  lwz r10, 0x104(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82F651F4: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 82F651F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F651FC: 4198FEDC  blt cr6, 0x82f650d8
	if ctx.cr[6].lt {
	pc = 0x82F650D8; continue 'dispatch;
	}
	// 82F65200: 816100E8  lwz r11, 0xe8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 82F65204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F65208: 419A0018  beq cr6, 0x82f65220
	if ctx.cr[6].eq {
	pc = 0x82F65220; continue 'dispatch;
	}
	// 82F6520C: 38B70034  addi r5, r23, 0x34
	ctx.r[5].s64 = ctx.r[23].s64 + 52;
	// 82F65210: 38970028  addi r4, r23, 0x28
	ctx.r[4].s64 = ctx.r[23].s64 + 40;
	// 82F65214: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F65218: 4BFE3B09  bl 0x82f48d20
	ctx.lr = 0x82F6521C;
	sub_82F48D20(ctx, base);
	// 82F6521C: 9B570069  stb r26, 0x69(r23)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[23].u32.wrapping_add(105 as u32), ctx.r[26].u8 ) };
	// 82F65220: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82F65224: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82F65228: 4BFE44C9  bl 0x82f496f0
	ctx.lr = 0x82F6522C;
	sub_82F496F0(ctx, base);
	// 82F6522C: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 82F65230: 81410144  lwz r10, 0x144(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 82F65234: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F65238: 4198FDF8  blt cr6, 0x82f65030
	if ctx.cr[6].lt {
	pc = 0x82F65030; continue 'dispatch;
	}
	// 82F6523C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82F65240: 409A000C  bne cr6, 0x82f6524c
	if !ctx.cr[6].eq {
	pc = 0x82F6524C; continue 'dispatch;
	}
	// 82F65244: 56CB063F  clrlwi. r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65248: 41820010  beq 0x82f65258
	if ctx.cr[0].eq {
	pc = 0x82F65258; continue 'dispatch;
	}
	// 82F6524C: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82F65250: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82F65254: 4BFE522D  bl 0x82f4a480
	ctx.lr = 0x82F65258;
	sub_82F4A480(ctx, base);
	// 82F65258: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82F6525C: 419A000C  beq cr6, 0x82f65268
	if ctx.cr[6].eq {
	pc = 0x82F65268; continue 'dispatch;
	}
	// 82F65260: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F65264: 4BF93035  bl 0x82ef8298
	ctx.lr = 0x82F65268;
	sub_82EF8298(ctx, base);
	// 82F65268: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6526C: 386100DC  addi r3, r1, 0xdc
	ctx.r[3].s64 = ctx.r[1].s64 + 220;
	// 82F65270: 4BFE57F9  bl 0x82f4aa68
	ctx.lr = 0x82F65274;
	sub_82F4AA68(ctx, base);
	// 82F65274: 806100DC  lwz r3, 0xdc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82F65278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6527C: 419A0008  beq cr6, 0x82f65284
	if ctx.cr[6].eq {
	pc = 0x82F65284; continue 'dispatch;
	}
	// 82F65280: 4BF98621  bl 0x82efd8a0
	ctx.lr = 0x82F65284;
	sub_82EFD8A0(ctx, base);
	// 82F65284: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 82F65288: CBC1FF90  lfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 82F6528C: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82F65290: 4BD441AC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F65298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F65298 size=956
    let mut pc: u32 = 0x82F65298;
    'dispatch: loop {
        match pc {
            0x82F65298 => {
    //   block [0x82F65298..0x82F65654)
	// 82F65298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6529C: 4BD44151  bl 0x82ca93ec
	ctx.lr = 0x82F652A0;
	sub_82CA93D0(ctx, base);
	// 82F652A0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F652A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F652A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F652AC: 93C100FC  stw r30, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[30].u32 ) };
	// 82F652B0: 388100FC  addi r4, r1, 0xfc
	ctx.r[4].s64 = ctx.r[1].s64 + 252;
	// 82F652B4: 3BBF08E0  addi r29, r31, 0x8e0
	ctx.r[29].s64 = ctx.r[31].s64 + 2272;
	// 82F652B8: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82F652BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F652C0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F652C4: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82F652C8: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 82F652CC: 7D354B78  mr r21, r9
	ctx.r[21].u64 = ctx.r[9].u64;
	// 82F652D0: 4BFFDB61  bl 0x82f62e30
	ctx.lr = 0x82F652D4;
	sub_82F62E30(ctx, base);
	// 82F652D4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F652D8: 40820024  bne 0x82f652fc
	if !ctx.cr[0].eq {
	pc = 0x82F652FC; continue 'dispatch;
	}
	// 82F652DC: 57CBD1BE  srwi r11, r30, 6
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F652E0: 388100FC  addi r4, r1, 0xfc
	ctx.r[4].s64 = ctx.r[1].s64 + 252;
	// 82F652E4: 7D65F278  xor r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[30].u64;
	// 82F652E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F652EC: 4BF95F7D  bl 0x82efb268
	ctx.lr = 0x82F652F0;
	sub_82EFB268(ctx, base);
	// 82F652F0: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82F652F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F652F8: 4BFEC961  bl 0x82f51c58
	ctx.lr = 0x82F652FC;
	sub_82F51C58(ctx, base);
	// 82F652FC: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F65300: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F65304: 556BDFFF  rlwinm. r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65308: 41820028  beq 0x82f65330
	if ctx.cr[0].eq {
	pc = 0x82F65330; continue 'dispatch;
	}
	// 82F6530C: 2B1C0028  cmplwi cr6, r28, 0x28
	ctx.cr[6].compare_u32(ctx.r[28].u32, 40 as u32, &mut ctx.xer);
	// 82F65310: 41990020  bgt cr6, 0x82f65330
	if ctx.cr[6].gt {
	pc = 0x82F65330; continue 'dispatch;
	}
	// 82F65314: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65318: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82F6531C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F65320: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F65324: 4E800421  bctrl
	ctx.lr = 0x82F65328;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F65328: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6532C: 40820008  bne 0x82f65334
	if !ctx.cr[0].eq {
	pc = 0x82F65334; continue 'dispatch;
	}
	// 82F65330: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82F65334: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 82F65338: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82F6533C: 56CA063E  clrlwi r10, r22, 0x18
	ctx.r[10].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 82F65340: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 82F65344: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82F65348: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82F6534C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82F65350: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82F65354: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 82F65358: 571B043E  clrlwi r27, r24, 0x10
	ctx.r[27].u64 = ctx.r[24].u32 as u64 & 0x0000FFFFu64;
	// 82F6535C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82F65360: 579A063E  clrlwi r26, r28, 0x18
	ctx.r[26].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82F65364: B361005C  sth r27, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u16 ) };
	// 82F65368: 5579063E  clrlwi r25, r11, 0x18
	ctx.r[25].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F6536C: 9B41005E  stb r26, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[26].u8 ) };
	// 82F65370: 3BBF08FC  addi r29, r31, 0x8fc
	ctx.r[29].s64 = ctx.r[31].s64 + 2300;
	// 82F65374: 9B21005F  stb r25, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[25].u8 ) };
	// 82F65378: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F6537C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F65380: 4BFFEB09  bl 0x82f63e88
	ctx.lr = 0x82F65384;
	sub_82F63E88(ctx, base);
	// 82F65384: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65388: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82F6538C: 40820008  bne 0x82f65394
	if !ctx.cr[0].eq {
	pc = 0x82F65394; continue 'dispatch;
	}
	// 82F65390: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F65394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F65398: 419A0060  beq cr6, 0x82f653f8
	if ctx.cr[6].eq {
	pc = 0x82F653F8; continue 'dispatch;
	}
	// 82F6539C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F653A0: 395F08F4  addi r10, r31, 0x8f4
	ctx.r[10].s64 = ctx.r[31].s64 + 2292;
	// 82F653A4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F653A8: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F653AC: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82F653B0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F653B4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F653B8: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82F653BC: 811F08F4  lwz r8, 0x8f4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2292 as u32) ) } as u64;
	// 82F653C0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F653C4: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F653C8: 815F08F4  lwz r10, 0x8f4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2292 as u32) ) } as u64;
	// 82F653CC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F653D0: 913F08F4  stw r9, 0x8f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2292 as u32), ctx.r[9].u32 ) };
	// 82F653D4: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F653D8: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F653DC: 41820014  beq 0x82f653f0
	if ctx.cr[0].eq {
	pc = 0x82F653F0; continue 'dispatch;
	}
	// 82F653E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F653E4: 892A000F  lbz r9, 0xf(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(15 as u32) ) } as u64;
	// 82F653E8: 61290080  ori r9, r9, 0x80
	ctx.r[9].u64 = ctx.r[9].u64 | 128;
	// 82F653EC: 992A000F  stb r9, 0xf(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(15 as u32), ctx.r[9].u8 ) };
	// 82F653F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F653F4: 48000254  b 0x82f65648
	pc = 0x82F65648; continue 'dispatch;
	// 82F653F8: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F653FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F65400: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82F65404: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65408: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6540C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F65410: 4E800421  bctrl
	ctx.lr = 0x82F65414;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F65414: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82F65418: 4082000C  bne 0x82f65424
	if !ctx.cr[0].eq {
	pc = 0x82F65424; continue 'dispatch;
	}
	// 82F6541C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F65420: 4800022C  b 0x82f6564c
	pc = 0x82F6564C; continue 'dispatch;
	// 82F65424: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6542C: 419A0008  beq cr6, 0x82f65434
	if ctx.cr[6].eq {
	pc = 0x82F65434; continue 'dispatch;
	}
	// 82F65430: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65434: 815F09D0  lwz r10, 0x9d0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2512 as u32) ) } as u64;
	// 82F65438: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6543C: 419800BC  blt cr6, 0x82f654f8
	if ctx.cr[6].lt {
	pc = 0x82F654F8; continue 'dispatch;
	}
	// 82F65440: 817F08F8  lwz r11, 0x8f8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2296 as u32) ) } as u64;
	// 82F65444: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F65448: 894B000F  lbz r10, 0xf(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 82F6544C: 554A0031  rlwinm. r10, r10, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F65450: 41820038  beq 0x82f65488
	if ctx.cr[0].eq {
	pc = 0x82F65488; continue 'dispatch;
	}
	// 82F65454: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 82F65458: 419A0020  beq cr6, 0x82f65478
	if ctx.cr[6].eq {
	pc = 0x82F65478; continue 'dispatch;
	}
	// 82F6545C: 897F0016  lbz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 82F65460: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65464: 41820014  beq 0x82f65478
	if ctx.cr[0].eq {
	pc = 0x82F65478; continue 'dispatch;
	}
	// 82F65468: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6546C: 38750014  addi r3, r21, 0x14
	ctx.r[3].s64 = ctx.r[21].s64 + 20;
	// 82F65470: 388B22F0  addi r4, r11, 0x22f0
	ctx.r[4].s64 = ctx.r[11].s64 + 8944;
	// 82F65474: 4BFC8CA5  bl 0x82f2e118
	ctx.lr = 0x82F65478;
	sub_82F2E118(ctx, base);
	// 82F65478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6547C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F65480: 997F0016  stb r11, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[11].u8 ) };
	// 82F65484: 480001C8  b 0x82f6564c
	pc = 0x82F6564C; continue 'dispatch;
	// 82F65488: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6548C: 4BF92E0D  bl 0x82ef8298
	ctx.lr = 0x82F65490;
	sub_82EF8298(ctx, base);
	// 82F65490: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F65494: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F65498: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6549C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F654A0: A12B000C  lhz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F654A4: 890B000E  lbz r8, 0xe(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(14 as u32) ) } as u64;
	// 82F654A8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82F654AC: B121005C  sth r9, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u16 ) };
	// 82F654B0: 9901005E  stb r8, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[8].u8 ) };
	// 82F654B4: 896B000F  lbz r11, 0xf(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 82F654B8: 9961005F  stb r11, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[11].u8 ) };
	// 82F654BC: 4BFFDE35  bl 0x82f632f0
	ctx.lr = 0x82F654C0;
	sub_82F632F0(ctx, base);
	// 82F654C0: 397F08E4  addi r11, r31, 0x8e4
	ctx.r[11].s64 = ctx.r[31].s64 + 2276;
	// 82F654C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F654C8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82F654CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F654D0: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F654D4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82F654D8: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82F654DC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F654E0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F654E4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F654E8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F654EC: 815F08F0  lwz r10, 0x8f0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2288 as u32) ) } as u64;
	// 82F654F0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F654F4: 917F08F0  stw r11, 0x8f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2288 as u32), ctx.r[11].u32 ) };
	// 82F654F8: 387F08E4  addi r3, r31, 0x8e4
	ctx.r[3].s64 = ctx.r[31].s64 + 2276;
	// 82F654FC: 4BFFD2ED  bl 0x82f627e8
	ctx.lr = 0x82F65500;
	sub_82F627E8(ctx, base);
	// 82F65500: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F65504: 38600094  li r3, 0x94
	ctx.r[3].s64 = 148;
	// 82F65508: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6550C: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82F65510: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F65514: B36B000C  sth r27, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[27].u16 ) };
	// 82F65518: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6551C: 9B4B000E  stb r26, 0xe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[26].u8 ) };
	// 82F65520: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F65524: 9B2B000F  stb r25, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[25].u8 ) };
	// 82F65528: 4BF98339  bl 0x82efd860
	ctx.lr = 0x82F6552C;
	sub_82EFD860(ctx, base);
	// 82F6552C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65530: 41820010  beq 0x82f65540
	if ctx.cr[0].eq {
	pc = 0x82F65540; continue 'dispatch;
	}
	// 82F65534: 388000F2  li r4, 0xf2
	ctx.r[4].s64 = 242;
	// 82F65538: 4BFE6C81  bl 0x82f4c1b8
	ctx.lr = 0x82F6553C;
	sub_82F4C1B8(ctx, base);
	// 82F6553C: 48000008  b 0x82f65544
	pc = 0x82F65544; continue 'dispatch;
	// 82F65540: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F65544: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F65548: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82F6554C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82F65550: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82F65554: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F65558: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6555C: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F65560: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F65564: 4E800421  bctrl
	ctx.lr = 0x82F65568;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F65568: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6556C: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 82F65570: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82F65574: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82F65578: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F6557C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F65580: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F65584: 4BFFF825  bl 0x82f64da8
	ctx.lr = 0x82F65588;
	sub_82F64DA8(ctx, base);
	// 82F65588: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6558C: C001007C  lfs f0, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65590: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F65594: C1A10078  lfs f13, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65598: 395F08F4  addi r10, r31, 0x8f4
	ctx.r[10].s64 = ctx.r[31].s64 + 2292;
	// 82F6559C: C1810074  lfs f12, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F655A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F655A4: C1610070  lfs f11, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F655A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82F655AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F655B0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F655B4: D18B004C  stfs f12, 0x4c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82F655B8: D1AB0050  stfs f13, 0x50(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F655BC: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F655C0: D16B0048  stfs f11, 0x48(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82F655C4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F655C8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F655CC: 992B0068  stb r9, 0x68(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[9].u8 ) };
	// 82F655D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F655D4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F655D8: 892B0044  lbz r9, 0x44(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82F655DC: 61290008  ori r9, r9, 8
	ctx.r[9].u64 = ctx.r[9].u64 | 8;
	// 82F655E0: 992B0044  stb r9, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[9].u8 ) };
	// 82F655E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F655E8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F655EC: 893C0045  lbz r9, 0x45(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(69 as u32) ) } as u64;
	// 82F655F0: 992B0045  stb r9, 0x45(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(69 as u32), ctx.r[9].u8 ) };
	// 82F655F4: 813F08F4  lwz r9, 0x8f4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2292 as u32) ) } as u64;
	// 82F655F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F655FC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82F65600: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F65604: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F65608: 817F08F4  lwz r11, 0x8f4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(2292 as u32) ) } as u64;
	// 82F6560C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82F65610: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82F65614: 911F08F4  stw r8, 0x8f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2292 as u32), ctx.r[8].u32 ) };
	// 82F65618: B3610064  sth r27, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u16 ) };
	// 82F6561C: 9B410066  stb r26, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[26].u8 ) };
	// 82F65620: 9B210067  stb r25, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[25].u8 ) };
	// 82F65624: 4BFFF495  bl 0x82f64ab8
	ctx.lr = 0x82F65628;
	sub_82F64AB8(ctx, base);
	// 82F65628: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6562C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65630: 41820014  beq 0x82f65644
	if ctx.cr[0].eq {
	pc = 0x82F65644; continue 'dispatch;
	}
	// 82F65634: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F65638: 894B000F  lbz r10, 0xf(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) } as u64;
	// 82F6563C: 614A0080  ori r10, r10, 0x80
	ctx.r[10].u64 = ctx.r[10].u64 | 128;
	// 82F65640: 994B000F  stb r10, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[10].u8 ) };
	// 82F65644: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F65648: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6564C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82F65650: 4BD43DEC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F65658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F65658 size=284
    let mut pc: u32 = 0x82F65658;
    'dispatch: loop {
        match pc {
            0x82F65658 => {
    //   block [0x82F65658..0x82F65774)
	// 82F65658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6565C: 4BD43DAD  bl 0x82ca9408
	ctx.lr = 0x82F65660;
	sub_82CA93D0(ctx, base);
	// 82F65660: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F65664: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F65668: 4BFFF4B1  bl 0x82f64b18
	ctx.lr = 0x82F6566C;
	sub_82F64B18(ctx, base);
	// 82F6566C: 397E0028  addi r11, r30, 0x28
	ctx.r[11].s64 = ctx.r[30].s64 + 40;
	// 82F65670: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 82F65674: 917E0028  stw r11, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82F65678: 917E002C  stw r11, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82F6567C: 4BFFD005  bl 0x82f62680
	ctx.lr = 0x82F65680;
	sub_82F62680(ctx, base);
	// 82F65680: 815E08E0  lwz r10, 0x8e0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2272 as u32) ) } as u64;
	// 82F65684: 3B9E08E0  addi r28, r30, 0x8e0
	ctx.r[28].s64 = ctx.r[30].s64 + 2272;
	// 82F65688: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6568C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F65690: 409A0010  bne cr6, 0x82f656a0
	if !ctx.cr[6].eq {
	pc = 0x82F656A0; continue 'dispatch;
	}
	// 82F65694: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82F65698: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82F6569C: 48000034  b 0x82f656d0
	pc = 0x82F656D0; continue 'dispatch;
	// 82F656A0: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 82F656A4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82F656A8: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F656AC: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82F656B0: 409A0018  bne cr6, 0x82f656c8
	if !ctx.cr[6].eq {
	pc = 0x82F656C8; continue 'dispatch;
	}
	// 82F656B4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F656B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F656BC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 82F656C0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F656C4: 4099FFE4  ble cr6, 0x82f656a8
	if !ctx.cr[6].gt {
	pc = 0x82F656A8; continue 'dispatch;
	}
	// 82F656C8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F656CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82F656D0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82F656D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F656D8: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82F656DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F656E0: 4BFD52D9  bl 0x82f3a9b8
	ctx.lr = 0x82F656E4;
	sub_82F3A9B8(ctx, base);
	// 82F656E4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F656E8: 4082004C  bne 0x82f65734
	if !ctx.cr[0].eq {
	pc = 0x82F65734; continue 'dispatch;
	}
	// 82F656EC: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82F656F0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82F656F4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82F656F8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F656FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F65700: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F65704: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82F65708: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6570C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F65710: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F65714: 4BFED76D  bl 0x82f52e80
	ctx.lr = 0x82F65718;
	sub_82F52E80(ctx, base);
	// 82F65718: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6571C: 4BFFD165  bl 0x82f62880
	ctx.lr = 0x82F65720;
	sub_82F62880(ctx, base);
	// 82F65720: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F65724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F65728: 4BFD5291  bl 0x82f3a9b8
	ctx.lr = 0x82F6572C;
	sub_82F3A9B8(ctx, base);
	// 82F6572C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65730: 4182FFC8  beq 0x82f656f8
	if ctx.cr[0].eq {
	pc = 0x82F656F8; continue 'dispatch;
	}
	// 82F65734: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F65738: 4802A841  bl 0x82f8ff78
	ctx.lr = 0x82F6573C;
	sub_82F8FF78(ctx, base);
	// 82F6573C: 3BBE08F4  addi r29, r30, 0x8f4
	ctx.r[29].s64 = ctx.r[30].s64 + 2292;
	// 82F65740: 83FE08F8  lwz r31, 0x8f8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(2296 as u32) ) } as u64;
	// 82F65744: 48000010  b 0x82f65754
	pc = 0x82F65754; continue 'dispatch;
	// 82F65748: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6574C: 4BF92B4D  bl 0x82ef8298
	ctx.lr = 0x82F65750;
	sub_82EF8298(ctx, base);
	// 82F65750: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F65754: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82F65758: 409AFFF0  bne cr6, 0x82f65748
	if !ctx.cr[6].eq {
	pc = 0x82F65748; continue 'dispatch;
	}
	// 82F6575C: 387E08E4  addi r3, r30, 0x8e4
	ctx.r[3].s64 = ctx.r[30].s64 + 2276;
	// 82F65760: 4BFFD021  bl 0x82f62780
	ctx.lr = 0x82F65764;
	sub_82F62780(ctx, base);
	// 82F65764: 387E08FC  addi r3, r30, 0x8fc
	ctx.r[3].s64 = ctx.r[30].s64 + 2300;
	// 82F65768: 4BFB62E1  bl 0x82f1ba48
	ctx.lr = 0x82F6576C;
	sub_82F1BA48(ctx, base);
	// 82F6576C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F65770: 4BD43CE8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F65778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F65778 size=4472
    let mut pc: u32 = 0x82F65778;
    'dispatch: loop {
        match pc {
            0x82F65778 => {
    //   block [0x82F65778..0x82F668F0)
	// 82F65778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6577C: 4BD43C55  bl 0x82ca93d0
	ctx.lr = 0x82F65780;
	sub_82CA93D0(ctx, base);
	// 82F65780: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82F65784: 4BD48545  bl 0x82cadcc8
	ctx.lr = 0x82F65788;
	sub_82CADCA0(ctx, base);
	// 82F65788: 9421FBF0  stwu r1, -0x410(r1)
	ea = ctx.r[1].u32.wrapping_add(-1040 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6578C: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82F65790: 90A10434  stw r5, 0x434(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1076 as u32), ctx.r[5].u32 ) };
	// 82F65794: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 82F65798: 90E10444  stw r7, 0x444(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1092 as u32), ctx.r[7].u32 ) };
	// 82F6579C: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 82F657A0: 93810454  stw r28, 0x454(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1108 as u32), ctx.r[28].u32 ) };
	// 82F657A4: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 82F657A8: 9221042C  stw r17, 0x42c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1068 as u32), ctx.r[17].u32 ) };
	// 82F657AC: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 82F657B0: 9241044C  stw r18, 0x44c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1100 as u32), ctx.r[18].u32 ) };
	// 82F657B4: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F657B8: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82F657BC: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82F657C0: 3BBC0018  addi r29, r28, 0x18
	ctx.r[29].s64 = ctx.r[28].s64 + 24;
	// 82F657C4: 7DF37B78  mr r19, r15
	ctx.r[19].u64 = ctx.r[15].u64;
	// 82F657C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F657CC: 419A0008  beq cr6, 0x82f657d4
	if ctx.cr[6].eq {
	pc = 0x82F657D4; continue 'dispatch;
	}
	// 82F657D0: 57FF083C  slwi r31, r31, 1
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82F657D4: 3BD10010  addi r30, r17, 0x10
	ctx.r[30].s64 = ctx.r[17].s64 + 16;
	// 82F657D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F657DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F657E0: 4BFFD189  bl 0x82f62968
	ctx.lr = 0x82F657E4;
	sub_82F62968(ctx, base);
	// 82F657E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F657E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F657EC: 4BFFCDCD  bl 0x82f625b8
	ctx.lr = 0x82F657F0;
	sub_82F625B8(ctx, base);
	// 82F657F0: 99F10024  stb r15, 0x24(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(36 as u32), ctx.r[15].u8 ) };
	// 82F657F4: 99F10025  stb r15, 0x25(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(37 as u32), ctx.r[15].u8 ) };
	// 82F657F8: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82F657FC: 4800717D  bl 0x82f6c978
	ctx.lr = 0x82F65800;
	sub_82F6C978(ctx, base);
	// 82F65800: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 82F65804: 48007175  bl 0x82f6c978
	ctx.lr = 0x82F65808;
	sub_82F6C978(ctx, base);
	// 82F65808: 897C0007  lbz r11, 7(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F6580C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65810: 41820040  beq 0x82f65850
	if ctx.cr[0].eq {
	pc = 0x82F65850; continue 'dispatch;
	}
	// 82F65814: 38920020  addi r4, r18, 0x20
	ctx.r[4].s64 = ctx.r[18].s64 + 32;
	// 82F65818: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82F6581C: 48006FDD  bl 0x82f6c7f8
	ctx.lr = 0x82F65820;
	sub_82F6C7F8(ctx, base);
	// 82F65820: 38940030  addi r4, r20, 0x30
	ctx.r[4].s64 = ctx.r[20].s64 + 48;
	// 82F65824: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82F65828: 48007201  bl 0x82f6ca28
	ctx.lr = 0x82F6582C;
	sub_82F6CA28(ctx, base);
	// 82F6582C: 38810230  addi r4, r1, 0x230
	ctx.r[4].s64 = ctx.r[1].s64 + 560;
	// 82F65830: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 82F65834: 48006FC5  bl 0x82f6c7f8
	ctx.lr = 0x82F65838;
	sub_82F6C7F8(ctx, base);
	// 82F65838: 38810210  addi r4, r1, 0x210
	ctx.r[4].s64 = ctx.r[1].s64 + 528;
	// 82F6583C: 38610310  addi r3, r1, 0x310
	ctx.r[3].s64 = ctx.r[1].s64 + 784;
	// 82F65840: 48006FB9  bl 0x82f6c7f8
	ctx.lr = 0x82F65844;
	sub_82F6C7F8(ctx, base);
	// 82F65844: 38810310  addi r4, r1, 0x310
	ctx.r[4].s64 = ctx.r[1].s64 + 784;
	// 82F65848: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 82F6584C: 480073CD  bl 0x82f6cc18
	ctx.lr = 0x82F65850;
	sub_82F6CC18(ctx, base);
	// 82F65850: 38920020  addi r4, r18, 0x20
	ctx.r[4].s64 = ctx.r[18].s64 + 32;
	// 82F65854: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 82F65858: 48006FA1  bl 0x82f6c7f8
	ctx.lr = 0x82F6585C;
	sub_82F6C7F8(ctx, base);
	// 82F6585C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F65860: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F65864: 38A10128  addi r5, r1, 0x128
	ctx.r[5].s64 = ctx.r[1].s64 + 296;
	// 82F65868: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82F6586C: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 82F65870: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F65874: C32A0C14  lfs f25, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82F65878: D3E102A8  stfs f31, 0x2a8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(680 as u32), tmp.u32 ) };
	// 82F6587C: D3E102B8  stfs f31, 0x2b8(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(696 as u32), tmp.u32 ) };
	// 82F65880: D3210128  stfs f25, 0x128(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82F65884: D3E1012C  stfs f31, 0x12c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), tmp.u32 ) };
	// 82F65888: 48007301  bl 0x82f6cb88
	ctx.lr = 0x82F6588C;
	sub_82F6CB88(ctx, base);
	// 82F6588C: C1A10130  lfs f13, 0x130(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65890: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82F65894: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F65898: C00B0DB0  lfs f0, 0xdb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6589C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82F658A0: 40990018  ble cr6, 0x82f658b8
	if !ctx.cr[6].gt {
	pc = 0x82F658B8; continue 'dispatch;
	}
	// 82F658A4: C1A10134  lfs f13, 0x134(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F658A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F658AC: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82F658B0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82F658B4: 41990008  bgt cr6, 0x82f658bc
	if ctx.cr[6].gt {
	pc = 0x82F658BC; continue 'dispatch;
	}
	// 82F658B8: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F658BC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F658C0: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 82F658C4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82F658C8: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 82F658CC: 920100A8  stw r16, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[16].u32 ) };
	// 82F658D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F658D4: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82F658D8: 419A0028  beq cr6, 0x82f65900
	if ctx.cr[6].eq {
	pc = 0x82F65900; continue 'dispatch;
	}
	// 82F658DC: 897C0013  lbz r11, 0x13(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(19 as u32) ) } as u64;
	// 82F658E0: 7DF07B78  mr r16, r15
	ctx.r[16].u64 = ctx.r[15].u64;
	// 82F658E4: 556A06B5  rlwinm. r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F658E8: 920100A8  stw r16, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[16].u32 ) };
	// 82F658EC: 4082000C  bne 0x82f658f8
	if !ctx.cr[0].eq {
	pc = 0x82F658F8; continue 'dispatch;
	}
	// 82F658F0: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F658F4: 4182000C  beq 0x82f65900
	if ctx.cr[0].eq {
	pc = 0x82F65900; continue 'dispatch;
	}
	// 82F658F8: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 82F658FC: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82F65900: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F65904: D3F2006C  stfs f31, 0x6c(r18)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82F65908: D3F20070  stfs f31, 0x70(r18)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82F6590C: 7E178378  mr r23, r16
	ctx.r[23].u64 = ctx.r[16].u64;
	// 82F65910: 7F10F840  cmplw cr6, r16, r31
	ctx.cr[6].compare_u32(ctx.r[16].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F65914: C34B0BFC  lfs f26, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82F65918: 419905F0  bgt cr6, 0x82f65f08
	if ctx.cr[6].gt {
	pc = 0x82F65F08; continue 'dispatch;
	}
	// 82F6591C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F65920: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82F65924: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82F65928: 3CE08202  lis r7, -0x7dfe
	ctx.r[7].s64 = -2113798144;
	// 82F6592C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82F65930: C36ABDF4  lfs f27, -0x420c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82F65934: C3897A14  lfs f28, 0x7a14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(31252 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82F65938: 3AABEC58  addi r21, r11, -0x13a8
	ctx.r[21].s64 = ctx.r[11].s64 + -5032;
	// 82F6593C: C3C80C98  lfs f30, 0xc98(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3224 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82F65940: C3A78470  lfs f29, -0x7b90(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-31632 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82F65944: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82F65948: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 82F6594C: 419A0008  beq cr6, 0x82f65954
	if ctx.cr[6].eq {
	pc = 0x82F65954; continue 'dispatch;
	}
	// 82F65950: 3B3C000C  addi r25, r28, 0xc
	ctx.r[25].s64 = ctx.r[28].s64 + 12;
	// 82F65954: 816E0038  lwz r11, 0x38(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F65958: 7E1A8378  mr r26, r16
	ctx.r[26].u64 = ctx.r[16].u64;
	// 82F6595C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82F65960: 40990008  ble cr6, 0x82f65968
	if !ctx.cr[6].gt {
	pc = 0x82F65968; continue 'dispatch;
	}
	// 82F65964: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82F65968: 81610434  lwz r11, 0x434(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1076 as u32) ) } as u64;
	// 82F6596C: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82F65970: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82F65974: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82F65978: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6597C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82F65980: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F65984: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82F65988: 4200FFF0  bdnz 0x82f65978
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82F65978; continue 'dispatch;
	}
	// 82F6598C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F65990: 4BFFC861  bl 0x82f621f0
	ctx.lr = 0x82F65994;
	sub_82F621F0(ctx, base);
	// 82F65994: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65998: 41820564  beq 0x82f65efc
	if ctx.cr[0].eq {
	pc = 0x82F65EFC; continue 'dispatch;
	}
	// 82F6599C: 82C100B0  lwz r22, 0xb0(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82F659A0: 830100B8  lwz r24, 0xb8(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82F659A4: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F659A8: 570A103A  slwi r10, r24, 2
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F659AC: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 82F659B0: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82F659B4: 4BFFEA15  bl 0x82f643c8
	ctx.lr = 0x82F659B8;
	sub_82F643C8(ctx, base);
	// 82F659B8: 81410250  lwz r10, 0x250(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(592 as u32) ) } as u64;
	// 82F659BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F659C0: 419A0014  beq cr6, 0x82f659d4
	if ctx.cr[6].eq {
	pc = 0x82F659D4; continue 'dispatch;
	}
	// 82F659C4: 81610254  lwz r11, 0x254(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(596 as u32) ) } as u64;
	// 82F659C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F659CC: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F659D0: 41980008  blt cr6, 0x82f659d8
	if ctx.cr[6].lt {
	pc = 0x82F659D8; continue 'dispatch;
	}
	// 82F659D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F659D8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F659DC: 408204F4  bne 0x82f65ed0
	if !ctx.cr[0].eq {
	pc = 0x82F65ED0; continue 'dispatch;
	}
	// 82F659E0: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82F659E4: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82F659E8: 409A0010  bne cr6, 0x82f659f8
	if !ctx.cr[6].eq {
	pc = 0x82F659F8; continue 'dispatch;
	}
	// 82F659EC: A16A0006  lhz r11, 6(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F659F0: 716BFFDF  andi. r11, r11, 0xffdf
	ctx.r[11].u64 = ctx.r[11].u64 & 65503;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F659F4: B16A0006  sth r11, 6(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82F659F8: A17B0000  lhz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F659FC: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 82F65A00: 41980008  blt cr6, 0x82f65a08
	if ctx.cr[6].lt {
	pc = 0x82F65A08; continue 'dispatch;
	}
	// 82F65A04: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F65A08: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82F65A0C: 409A0010  bne cr6, 0x82f65a1c
	if !ctx.cr[6].eq {
	pc = 0x82F65A1C; continue 'dispatch;
	}
	// 82F65A10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F65A14: 99710024  stb r11, 0x24(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82F65A18: 480004A8  b 0x82f65ec0
	pc = 0x82F65EC0; continue 'dispatch;
	// 82F65A1C: A17B0006  lhz r11, 6(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F65A20: 556ABA7E  srwi r10, r11, 9
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(9);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F65A24: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F65A28: 40820498  bne 0x82f65ec0
	if !ctx.cr[0].eq {
	pc = 0x82F65EC0; continue 'dispatch;
	}
	// 82F65A2C: 556B8FFF  rlwinm. r11, r11, 0x11, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65A30: 4082000C  bne 0x82f65a3c
	if !ctx.cr[0].eq {
	pc = 0x82F65A3C; continue 'dispatch;
	}
	// 82F65A34: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82F65A38: 419AFFD8  beq cr6, 0x82f65a10
	if ctx.cr[6].eq {
	pc = 0x82F65A10; continue 'dispatch;
	}
	// 82F65A3C: 83A1028C  lwz r29, 0x28c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(652 as u32) ) } as u64;
	// 82F65A40: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F65A44: 419A000C  beq cr6, 0x82f65a50
	if ctx.cr[6].eq {
	pc = 0x82F65A50; continue 'dispatch;
	}
	// 82F65A48: 83FD0010  lwz r31, 0x10(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F65A4C: 48000008  b 0x82f65a54
	pc = 0x82F65A54; continue 'dispatch;
	// 82F65A50: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 82F65A54: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82F65A58: 7F1F9840  cmplw cr6, r31, r19
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82F65A5C: 419A0044  beq cr6, 0x82f65aa0
	if ctx.cr[6].eq {
	pc = 0x82F65AA0; continue 'dispatch;
	}
	// 82F65A60: 3BCE08E0  addi r30, r14, 0x8e0
	ctx.r[30].s64 = ctx.r[14].s64 + 2272;
	// 82F65A64: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82F65A68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F65A6C: 7FF3FB78  mr r19, r31
	ctx.r[19].u64 = ctx.r[31].u64;
	// 82F65A70: 4BFFD3C1  bl 0x82f62e30
	ctx.lr = 0x82F65A74;
	sub_82F62E30(ctx, base);
	// 82F65A74: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65A78: 40820028  bne 0x82f65aa0
	if !ctx.cr[0].eq {
	pc = 0x82F65AA0; continue 'dispatch;
	}
	// 82F65A7C: 57EBD1BE  srwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F65A80: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82F65A84: 7D65FA78  xor r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[31].u64;
	// 82F65A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F65A8C: 4BF957DD  bl 0x82efb268
	ctx.lr = 0x82F65A90;
	sub_82EFB268(ctx, base);
	// 82F65A90: 388E0004  addi r4, r14, 4
	ctx.r[4].s64 = ctx.r[14].s64 + 4;
	// 82F65A94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F65A98: 4BFEC1C1  bl 0x82f51c58
	ctx.lr = 0x82F65A9C;
	sub_82F51C58(ctx, base);
	// 82F65A9C: 83A1028C  lwz r29, 0x28c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(652 as u32) ) } as u64;
	// 82F65AA0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F65AA4: 4BFFC37D  bl 0x82f61e20
	ctx.lr = 0x82F65AA8;
	sub_82F61E20(ctx, base);
	// 82F65AA8: C0120060  lfs f0, 0x60(r18)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65AAC: EFE10032  fmuls f31, f1, f0
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F65AB0: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	// 82F65AB4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82F65AB8: 9941007F  stb r10, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[10].u8 ) };
	// 82F65ABC: B1E1007C  sth r15, 0x7c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[15].u16 ) };
	// 82F65AC0: 99E1007E  stb r15, 0x7e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(126 as u32), ctx.r[15].u8 ) };
	// 82F65AC4: 99E10080  stb r15, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[15].u8 ) };
	// 82F65AC8: 99E10081  stb r15, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[15].u8 ) };
	// 82F65ACC: 99E10082  stb r15, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[15].u8 ) };
	// 82F65AD0: 99E10083  stb r15, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[15].u8 ) };
	// 82F65AD4: A17B0000  lhz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65AD8: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 82F65ADC: EC1FD02A  fadds f0, f31, f26
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[26].f64) as f32) as f64;
	// 82F65AE0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82F65AE4: D8010068  stfd f0, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.f[0].u64 ) };
	// 82F65AE8: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82F65AEC: 41980008  blt cr6, 0x82f65af4
	if ctx.cr[6].lt {
	pc = 0x82F65AF4; continue 'dispatch;
	}
	// 82F65AF0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F65AF4: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F65AF8: 7DFE7B78  mr r30, r15
	ctx.r[30].u64 = ctx.r[15].u64;
	// 82F65AFC: B161007C  sth r11, 0x7c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u16 ) };
	// 82F65B00: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F65B04: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82F65B08: 409A023C  bne cr6, 0x82f65d44
	if !ctx.cr[6].eq {
	pc = 0x82F65D44; continue 'dispatch;
	}
	// 82F65B0C: 89590007  lbz r10, 7(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F65B10: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F65B14: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F65B18: 40820008  bne 0x82f65b20
	if !ctx.cr[0].eq {
	pc = 0x82F65B20; continue 'dispatch;
	}
	// 82F65B1C: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 82F65B20: 81340014  lwz r9, 0x14(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F65B24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F65B28: 419A0010  beq cr6, 0x82f65b38
	if ctx.cr[6].eq {
	pc = 0x82F65B38; continue 'dispatch;
	}
	// 82F65B2C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F65B30: 554807FE  clrlwi r8, r10, 0x1f
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82F65B34: 48000008  b 0x82f65b3c
	pc = 0x82F65B3C; continue 'dispatch;
	// 82F65B38: 7DE87B78  mr r8, r15
	ctx.r[8].u64 = ctx.r[15].u64;
	// 82F65B3C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F65B40: 419A0010  beq cr6, 0x82f65b50
	if ctx.cr[6].eq {
	pc = 0x82F65B50; continue 'dispatch;
	}
	// 82F65B44: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F65B48: 5547FFFE  rlwinm r7, r10, 0x1f, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82F65B4C: 48000008  b 0x82f65b54
	pc = 0x82F65B54; continue 'dispatch;
	// 82F65B50: 7DE77B78  mr r7, r15
	ctx.r[7].u64 = ctx.r[15].u64;
	// 82F65B54: 5565043E  clrlwi r5, r11, 0x10
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82F65B58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F65B5C: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82F65B60: 4BFFF739  bl 0x82f65298
	ctx.lr = 0x82F65B64;
	sub_82F65298(ctx, base);
	// 82F65B64: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F65B68: 418201D4  beq 0x82f65d3c
	if ctx.cr[0].eq {
	pc = 0x82F65D3C; continue 'dispatch;
	}
	// 82F65B6C: 897E0068  lbz r11, 0x68(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) } as u64;
	// 82F65B70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65B74: 41820028  beq 0x82f65b9c
	if ctx.cr[0].eq {
	pc = 0x82F65B9C; continue 'dispatch;
	}
	// 82F65B78: C01E0054  lfs f0, 0x54(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65B7C: C1BE004C  lfs f13, 0x4c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65B80: C19E0050  lfs f12, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F65B84: C17E0048  lfs f11, 0x48(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F65B88: D1A100D4  stfs f13, 0xd4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82F65B8C: D00100DC  stfs f0, 0xdc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82F65B90: D16100D0  stfs f11, 0xd0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82F65B94: D18100D8  stfs f12, 0xd8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82F65B98: 4800002C  b 0x82f65bc4
	pc = 0x82F65BC4; continue 'dispatch;
	// 82F65B9C: A09B0000  lhz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65BA0: 2B04FFFF  cmplwi cr6, r4, 0xffff
	ctx.cr[6].compare_u32(ctx.r[4].u32, 65535 as u32, &mut ctx.xer);
	// 82F65BA4: 41980008  blt cr6, 0x82f65bac
	if ctx.cr[6].lt {
	pc = 0x82F65BAC; continue 'dispatch;
	}
	// 82F65BA8: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82F65BAC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F65BB0: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 82F65BB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65BB8: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F65BBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F65BC0: 4E800421  bctrl
	ctx.lr = 0x82F65BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F65BC4: 89790007  lbz r11, 7(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F65BC8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65BCC: 40820038  bne 0x82f65c04
	if !ctx.cr[0].eq {
	pc = 0x82F65C04; continue 'dispatch;
	}
	// 82F65BD0: 397C0003  addi r11, r28, 3
	ctx.r[11].s64 = ctx.r[28].s64 + 3;
	// 82F65BD4: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F65BD8: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82F65BDC: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82F65BE0: 4199001C  bgt cr6, 0x82f65bfc
	if ctx.cr[6].gt {
	pc = 0x82F65BFC; continue 'dispatch;
	}
	// 82F65BE4: 7D6B7214  add r11, r11, r14
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 82F65BE8: 39550004  addi r10, r21, 4
	ctx.r[10].s64 = ctx.r[21].s64 + 4;
	// 82F65BEC: 896B07E0  lbz r11, 0x7e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2016 as u32) ) } as u64;
	// 82F65BF0: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 82F65BF4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F65BF8: 48000008  b 0x82f65c00
	pc = 0x82F65C00; continue 'dispatch;
	// 82F65BFC: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82F65C00: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82F65C04: 89590009  lbz r10, 9(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(9 as u32) ) } as u64;
	// 82F65C08: C192006C  lfs f12, 0x6c(r18)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F65C0C: 8979000B  lbz r11, 0xb(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(11 as u32) ) } as u64;
	// 82F65C10: 89390008  lbz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F65C14: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82F65C18: F9410100  std r10, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[10].u64 ) };
	// 82F65C1C: F9610108  std r11, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u64 ) };
	// 82F65C20: C9A10108  lfd f13, 0x108(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	// 82F65C24: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F65C28: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82F65C2C: C8010100  lfd f0, 0x100(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82F65C30: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F65C34: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F65C38: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 82F65C3C: C96100F8  lfd f11, 0xf8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82F65C40: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82F65C44: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F65C48: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F65C4C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82F65C50: EDA00772  fmuls f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82F65C54: EC0B6FBA  fmadds f0, f11, f30, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F65C58: EDAA6FBA  fmadds f13, f10, f30, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F65C5C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F65C60: 40990008  ble cr6, 0x82f65c68
	if !ctx.cr[6].gt {
	pc = 0x82F65C68; continue 'dispatch;
	}
	// 82F65C64: D012006C  stfs f0, 0x6c(r18)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82F65C68: C0120070  lfs f0, 0x70(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65C6C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82F65C70: 40990008  ble cr6, 0x82f65c78
	if !ctx.cr[6].gt {
	pc = 0x82F65C78; continue 'dispatch;
	}
	// 82F65C74: D1B20070  stfs f13, 0x70(r18)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82F65C78: 39610202  addi r11, r1, 0x202
	ctx.r[11].s64 = ctx.r[1].s64 + 514;
	// 82F65C7C: C00100DC  lfs f0, 0xdc(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65C80: 3BEE0030  addi r31, r14, 0x30
	ctx.r[31].s64 = ctx.r[14].s64 + 48;
	// 82F65C84: C1A100D4  lfs f13, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65C88: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82F65C8C: 39410200  addi r10, r1, 0x200
	ctx.r[10].s64 = ctx.r[1].s64 + 512;
	// 82F65C90: 39210078  addi r9, r1, 0x78
	ctx.r[9].s64 = ctx.r[1].s64 + 120;
	// 82F65C94: C0520060  lfs f2, 0x60(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(96 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F65C98: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82F65C9C: EC606828  fsubs f3, f0, f13
	ctx.f[3].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F65CA0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F65CA4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F65CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F65CAC: 48063E45  bl 0x82fc9af0
	ctx.lr = 0x82F65CB0;
	sub_82FC9AF0(ctx, base);
	// 82F65CB0: 89790007  lbz r11, 7(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F65CB4: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65CB8: 41820084  beq 0x82f65d3c
	if ctx.cr[0].eq {
	pc = 0x82F65D3C; continue 'dispatch;
	}
	// 82F65CBC: 897E0045  lbz r11, 0x45(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(69 as u32) ) } as u64;
	// 82F65CC0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65CC4: 40820078  bne 0x82f65d3c
	if !ctx.cr[0].eq {
	pc = 0x82F65D3C; continue 'dispatch;
	}
	// 82F65CC8: 89790008  lbz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F65CCC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65CD0: 4082006C  bne 0x82f65d3c
	if !ctx.cr[0].eq {
	pc = 0x82F65D3C; continue 'dispatch;
	}
	// 82F65CD4: 8961007E  lbz r11, 0x7e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 82F65CD8: C1A100D0  lfs f13, 0xd0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65CDC: C00100D8  lfs f0, 0xd8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65CE0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F65CE4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F65CE8: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F65CEC: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F65CF0: F9610110  std r11, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 82F65CF4: C9A10110  lfd f13, 0x110(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 82F65CF8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F65CFC: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82F65D00: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F65D04: 794B0020  clrldi r11, r10, 0x20
	ctx.r[11].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82F65D08: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 82F65D0C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F65D10: C9A100A0  lfd f13, 0xa0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82F65D14: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F65D18: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82F65D1C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F65D20: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82F65D24: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F65D28: 40980014  bge cr6, 0x82f65d3c
	if !ctx.cr[6].lt {
	pc = 0x82F65D3C; continue 'dispatch;
	}
	// 82F65D2C: 8961007F  lbz r11, 0x7f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(127 as u32) ) } as u64;
	// 82F65D30: 616A0004  ori r10, r11, 4
	ctx.r[10].u64 = ctx.r[11].u64 | 4;
	// 82F65D34: 9941007F  stb r10, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[10].u8 ) };
	// 82F65D38: 48000008  b 0x82f65d40
	pc = 0x82F65D40; continue 'dispatch;
	// 82F65D3C: 8941007F  lbz r10, 0x7f(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(127 as u32) ) } as u64;
	// 82F65D40: 83A1028C  lwz r29, 0x28c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(652 as u32) ) } as u64;
	// 82F65D44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F65D48: 419A0010  beq cr6, 0x82f65d58
	if ctx.cr[6].eq {
	pc = 0x82F65D58; continue 'dispatch;
	}
	// 82F65D4C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F65D50: 556BFFFE  rlwinm r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82F65D54: 48000008  b 0x82f65d5c
	pc = 0x82F65D5C; continue 'dispatch;
	// 82F65D58: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F65D5C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65D60: 41820010  beq 0x82f65d70
	if ctx.cr[0].eq {
	pc = 0x82F65D70; continue 'dispatch;
	}
	// 82F65D64: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82F65D68: 616A0008  ori r10, r11, 8
	ctx.r[10].u64 = ctx.r[11].u64 | 8;
	// 82F65D6C: 48000008  b 0x82f65d74
	pc = 0x82F65D74; continue 'dispatch;
	// 82F65D70: 714A00F7  andi. r10, r10, 0xf7
	ctx.r[10].u64 = ctx.r[10].u64 & 247;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F65D74: 9941007F  stb r10, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[10].u8 ) };
	// 82F65D78: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F65D7C: 419A0010  beq cr6, 0x82f65d8c
	if ctx.cr[6].eq {
	pc = 0x82F65D8C; continue 'dispatch;
	}
	// 82F65D80: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F65D84: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82F65D88: 48000008  b 0x82f65d90
	pc = 0x82F65D90; continue 'dispatch;
	// 82F65D8C: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F65D90: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65D94: 614B0010  ori r11, r10, 0x10
	ctx.r[11].u64 = ctx.r[10].u64 | 16;
	// 82F65D98: 40820008  bne 0x82f65da0
	if !ctx.cr[0].eq {
	pc = 0x82F65DA0; continue 'dispatch;
	}
	// 82F65D9C: 714B00EF  andi. r11, r10, 0xef
	ctx.r[11].u64 = ctx.r[10].u64 & 239;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65DA0: 9961007F  stb r11, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[11].u8 ) };
	// 82F65DA4: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 82F65DA8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82F65DAC: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82F65DB0: 388101F0  addi r4, r1, 0x1f0
	ctx.r[4].s64 = ctx.r[1].s64 + 496;
	// 82F65DB4: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82F65DB8: 4BFFC5B9  bl 0x82f62370
	ctx.lr = 0x82F65DBC;
	sub_82F62370(ctx, base);
	// 82F65DBC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65DC0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82F65DC4: 40820008  bne 0x82f65dcc
	if !ctx.cr[0].eq {
	pc = 0x82F65DCC; continue 'dispatch;
	}
	// 82F65DC8: 9BB10025  stb r29, 0x25(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(37 as u32), ctx.r[29].u8 ) };
	// 82F65DCC: 81610204  lwz r11, 0x204(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(516 as u32) ) } as u64;
	// 82F65DD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F65DD4: 419A00C4  beq cr6, 0x82f65e98
	if ctx.cr[6].eq {
	pc = 0x82F65E98; continue 'dispatch;
	}
	// 82F65DD8: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82F65DDC: 409A0010  bne cr6, 0x82f65dec
	if !ctx.cr[6].eq {
	pc = 0x82F65DEC; continue 'dispatch;
	}
	// 82F65DE0: A17B0006  lhz r11, 6(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F65DE4: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 82F65DE8: B17B0006  sth r11, 6(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82F65DEC: 81710014  lwz r11, 0x14(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F65DF0: 38710010  addi r3, r17, 0x10
	ctx.r[3].s64 = ctx.r[17].s64 + 16;
	// 82F65DF4: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82F65DF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F65DFC: 4BFFCB6D  bl 0x82f62968
	ctx.lr = 0x82F65E00;
	sub_82F62968(ctx, base);
	// 82F65E00: 81710010  lwz r11, 0x10(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F65E04: 1D5F001C  mulli r10, r31, 0x1c
	ctx.r[10].s64 = ctx.r[31].s64 * 28;
	// 82F65E08: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F65E0C: 388101F0  addi r4, r1, 0x1f0
	ctx.r[4].s64 = ctx.r[1].s64 + 496;
	// 82F65E10: 386BFFE4  addi r3, r11, -0x1c
	ctx.r[3].s64 = ctx.r[11].s64 + -28;
	// 82F65E14: 38A0001C  li r5, 0x1c
	ctx.r[5].s64 = 28;
	// 82F65E18: 4BD43669  bl 0x82ca9480
	ctx.lr = 0x82F65E1C;
	sub_82CA9480(ctx, base);
	// 82F65E1C: 934100F4  stw r26, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[26].u32 ) };
	// 82F65E20: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82F65E24: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82F65E28: 83E10204  lwz r31, 0x204(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(516 as u32) ) } as u64;
	// 82F65E2C: 93E100F0  stw r31, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[31].u32 ) };
	// 82F65E30: 4BFFDFE9  bl 0x82f63e18
	ctx.lr = 0x82F65E34;
	sub_82F63E18(ctx, base);
	// 82F65E34: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65E38: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 82F65E3C: 40820008  bne 0x82f65e44
	if !ctx.cr[0].eq {
	pc = 0x82F65E44; continue 'dispatch;
	}
	// 82F65E40: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F65E44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F65E48: 409A0040  bne cr6, 0x82f65e88
	if !ctx.cr[6].eq {
	pc = 0x82F65E88; continue 'dispatch;
	}
	// 82F65E4C: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 82F65E50: 93E1015C  stw r31, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[31].u32 ) };
	// 82F65E54: 39410150  addi r10, r1, 0x150
	ctx.r[10].s64 = ctx.r[1].s64 + 336;
	// 82F65E58: 91E10150  stw r15, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[15].u32 ) };
	// 82F65E5C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82F65E60: 57E9D1BE  srwi r9, r31, 6
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F65E64: 91E10158  stw r15, 0x158(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[15].u32 ) };
	// 82F65E68: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82F65E6C: 93A10154  stw r29, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[29].u32 ) };
	// 82F65E70: 7D2BFA78  xor r11, r9, r31
	ctx.r[11].u64 = ctx.r[9].u64 ^ ctx.r[31].u64;
	// 82F65E74: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82F65E78: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 82F65E7C: 7D65D278  xor r5, r11, r26
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[26].u64;
	// 82F65E80: 4BFFE089  bl 0x82f63f08
	ctx.lr = 0x82F65E84;
	sub_82F63F08(ctx, base);
	// 82F65E84: 48000038  b 0x82f65ebc
	pc = 0x82F65EBC; continue 'dispatch;
	// 82F65E88: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F65E8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F65E90: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F65E94: 48000028  b 0x82f65ebc
	pc = 0x82F65EBC; continue 'dispatch;
	// 82F65E98: 2B170001  cmplwi cr6, r23, 1
	ctx.cr[6].compare_u32(ctx.r[23].u32, 1 as u32, &mut ctx.xer);
	// 82F65E9C: 409A0010  bne cr6, 0x82f65eac
	if !ctx.cr[6].eq {
	pc = 0x82F65EAC; continue 'dispatch;
	}
	// 82F65EA0: A17B0006  lhz r11, 6(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F65EA4: 556B047E  clrlwi r11, r11, 0x11
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00007FFFu64;
	// 82F65EA8: B17B0006  sth r11, 6(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 82F65EAC: 9BB10024  stb r29, 0x24(r17)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[17].u32.wrapping_add(36 as u32), ctx.r[29].u8 ) };
	// 82F65EB0: 89720078  lbz r11, 0x78(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F65EB4: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 82F65EB8: 99720078  stb r11, 0x78(r18)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[18].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82F65EBC: 83810454  lwz r28, 0x454(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82F65EC0: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 82F65EC4: 4BFFBFAD  bl 0x82f61e70
	ctx.lr = 0x82F65EC8;
	sub_82F61E70(ctx, base);
	// 82F65EC8: 83E10090  lwz r31, 0x90(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F65ECC: 4BFFFAEC  b 0x82f659b8
	pc = 0x82F659B8; continue 'dispatch;
	// 82F65ED0: 38610250  addi r3, r1, 0x250
	ctx.r[3].s64 = ctx.r[1].s64 + 592;
	// 82F65ED4: 4BFFDB2D  bl 0x82f63a00
	ctx.lr = 0x82F65ED8;
	sub_82F63A00(ctx, base);
	// 82F65ED8: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F65EDC: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F65EE0: 4098000C  bge cr6, 0x82f65eec
	if !ctx.cr[6].lt {
	pc = 0x82F65EEC; continue 'dispatch;
	}
	// 82F65EE4: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82F65EE8: 930100B8  stw r24, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[24].u32 ) };
	// 82F65EEC: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F65EF0: 4BFFC301  bl 0x82f621f0
	ctx.lr = 0x82F65EF4;
	sub_82F621F0(ctx, base);
	// 82F65EF4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F65EF8: 4082FAAC  bne 0x82f659a4
	if !ctx.cr[0].eq {
	pc = 0x82F659A4; continue 'dispatch;
	}
	// 82F65EFC: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 82F65F00: 7F17F840  cmplw cr6, r23, r31
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F65F04: 4099FA40  ble cr6, 0x82f65944
	if !ctx.cr[6].gt {
	pc = 0x82F65944; continue 'dispatch;
	}
	// 82F65F08: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82F65F0C: C012006C  lfs f0, 0x6c(r18)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65F10: C1B20070  lfs f13, 0x70(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F65F14: 891C0018  lbz r8, 0x18(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F65F18: C1920004  lfs f12, 4(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F65F1C: 39720004  addi r11, r18, 4
	ctx.r[11].s64 = ctx.r[18].s64 + 4;
	// 82F65F20: C1720008  lfs f11, 8(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F65F24: 395C0018  addi r10, r28, 0x18
	ctx.r[10].s64 = ctx.r[28].s64 + 24;
	// 82F65F28: C152000C  lfs f10, 0xc(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F65F2C: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F65F30: C3690AC8  lfs f27, 0xac8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2760 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82F65F34: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82F65F38: C1320010  lfs f9, 0x10(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82F65F3C: ED0D06F2  fmuls f8, f13, f27
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82F65F40: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82F65F44: D1A100E0  stfs f13, 0xe0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82F65F48: ED8B4028  fsubs f12, f11, f8
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 82F65F4C: D18100E4  stfs f12, 0xe4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82F65F50: ED60502A  fadds f11, f0, f10
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82F65F54: D16100E8  stfs f11, 0xe8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82F65F58: ED48482A  fadds f10, f8, f9
	ctx.f[10].f64 = ((ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64;
	// 82F65F5C: D14100EC  stfs f10, 0xec(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82F65F60: 41820094  beq 0x82f65ff4
	if ctx.cr[0].eq {
	pc = 0x82F65FF4; continue 'dispatch;
	}
	// 82F65F64: A95C001E  lha r10, 0x1e(r28)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(30 as u32) ) } as i16) as i64;
	// 82F65F68: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F65F6C: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82F65F70: A93C001C  lha r9, 0x1c(r28)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as i16) as i64;
	// 82F65F74: C12B0008  lfs f9, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82F65F78: C0CB000C  lfs f6, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82F65F7C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F65F80: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82F65F84: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 82F65F88: C8E100A0  lfd f7, 0xa0(r1)
	ctx.f[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82F65F8C: F94100A0  std r10, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u64 ) };
	// 82F65F90: C8A100A0  lfd f5, 0xa0(r1)
	ctx.f[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82F65F94: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 82F65F98: FCE03E9C  fcfid f7, f7
	ctx.f[7].f64 = (ctx.f[7].s64 as f64);
	// 82F65F9C: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82F65FA0: FC803818  frsp f4, f7
	ctx.f[4].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82F65FA4: EDA5682A  fadds f13, f5, f13
	ctx.f[13].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 82F65FA8: ED65582A  fadds f11, f5, f11
	ctx.f[11].f64 = ((ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64;
	// 82F65FAC: ECE4602A  fadds f7, f4, f12
	ctx.f[7].f64 = ((ctx.f[4].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F65FB0: ED84502A  fadds f12, f4, f10
	ctx.f[12].f64 = ((ctx.f[4].f64 + ctx.f[10].f64) as f32) as f64;
	// 82F65FB4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82F65FB8: 41990008  bgt cr6, 0x82f65fc0
	if ctx.cr[6].gt {
	pc = 0x82F65FC0; continue 'dispatch;
	}
	// 82F65FBC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82F65FC0: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 82F65FC4: 41990008  bgt cr6, 0x82f65fcc
	if ctx.cr[6].gt {
	pc = 0x82F65FCC; continue 'dispatch;
	}
	// 82F65FC8: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 82F65FCC: FF074000  fcmpu cr6, f7, f8
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[8].f64);
	// 82F65FD0: 41990008  bgt cr6, 0x82f65fd8
	if ctx.cr[6].gt {
	pc = 0x82F65FD8; continue 'dispatch;
	}
	// 82F65FD4: FD003890  fmr f8, f7
	ctx.f[8].f64 = ctx.f[7].f64;
	// 82F65FD8: FF0C3000  fcmpu cr6, f12, f6
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[6].f64);
	// 82F65FDC: 41990008  bgt cr6, 0x82f65fe4
	if ctx.cr[6].gt {
	pc = 0x82F65FE4; continue 'dispatch;
	}
	// 82F65FE0: FD803090  fmr f12, f6
	ctx.f[12].f64 = ctx.f[6].f64;
	// 82F65FE4: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82F65FE8: D10100E4  stfs f8, 0xe4(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82F65FEC: D16100E8  stfs f11, 0xe8(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82F65FF0: D18100EC  stfs f12, 0xec(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82F65FF4: 81510000  lwz r10, 0(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F65FF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F65FFC: 409A0010  bne cr6, 0x82f6600c
	if !ctx.cr[6].eq {
	pc = 0x82F6600C; continue 'dispatch;
	}
	// 82F66000: 7DFE7B78  mr r30, r15
	ctx.r[30].u64 = ctx.r[15].u64;
	// 82F66004: 91E1006C  stw r15, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[15].u32 ) };
	// 82F66008: 48000038  b 0x82f66040
	pc = 0x82F66040; continue 'dispatch;
	// 82F6600C: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F66010: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82F66014: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66018: 2F09FFFE  cmpwi cr6, r9, -2
	ctx.cr[6].compare_i32(ctx.r[9].s32, -2, &mut ctx.xer);
	// 82F6601C: 409A001C  bne cr6, 0x82f66038
	if !ctx.cr[6].eq {
	pc = 0x82F66038; continue 'dispatch;
	}
	// 82F66020: 81310000  lwz r9, 0(r17)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66024: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F66028: 394A001C  addi r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + 28;
	// 82F6602C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F66030: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F66034: 4099FFE0  ble cr6, 0x82f66014
	if !ctx.cr[6].gt {
	pc = 0x82F66014; continue 'dispatch;
	}
	// 82F66038: 7E3E8B78  mr r30, r17
	ctx.r[30].u64 = ctx.r[17].u64;
	// 82F6603C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82F66040: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82F66044: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82F66048: 91E10088  stw r15, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[15].u32 ) };
	// 82F6604C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F66050: 91E1008C  stw r15, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[15].u32 ) };
	// 82F66054: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	// 82F66058: 4BFD4961  bl 0x82f3a9b8
	ctx.lr = 0x82F6605C;
	sub_82F3A9B8(ctx, base);
	// 82F6605C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66060: 40820054  bne 0x82f660b4
	if !ctx.cr[0].eq {
	pc = 0x82F660B4; continue 'dispatch;
	}
	// 82F66064: 91E10088  stw r15, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[15].u32 ) };
	// 82F66068: 91E1008C  stw r15, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[15].u32 ) };
	// 82F6606C: 48000008  b 0x82f66074
	pc = 0x82F66074; continue 'dispatch;
	// 82F66070: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82F66074: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82F66078: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F6607C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66080: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 82F66084: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F66088: 93EA0014  stw r31, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82F6608C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66090: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F66094: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F66098: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82F6609C: 48001F75  bl 0x82f68010
	ctx.lr = 0x82F660A0;
	sub_82F68010(ctx, base);
	// 82F660A0: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82F660A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F660A8: 4BFD4911  bl 0x82f3a9b8
	ctx.lr = 0x82F660AC;
	sub_82F3A9B8(ctx, base);
	// 82F660AC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F660B0: 4182FFC0  beq 0x82f66070
	if ctx.cr[0].eq {
	pc = 0x82F66070; continue 'dispatch;
	}
	// 82F660B4: 8381042C  lwz r28, 0x42c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1068 as u32) ) } as u64;
	// 82F660B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F660BC: 3ADC0004  addi r22, r28, 4
	ctx.r[22].s64 = ctx.r[28].s64 + 4;
	// 82F660C0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82F660C4: 4BFFCCC5  bl 0x82f62d88
	ctx.lr = 0x82F660C8;
	sub_82F62D88(ctx, base);
	// 82F660C8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82F660CC: 809C0014  lwz r4, 0x14(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F660D0: 4BFFCCB9  bl 0x82f62d88
	ctx.lr = 0x82F660D4;
	sub_82F62D88(ctx, base);
	// 82F660D4: 83A100A8  lwz r29, 0xa8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82F660D8: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F660DC: 7DF47B78  mr r20, r15
	ctx.r[20].u64 = ctx.r[15].u64;
	// 82F660E0: 7FB1EB78  mr r17, r29
	ctx.r[17].u64 = ctx.r[29].u64;
	// 82F660E4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F660E8: 419907F8  bgt cr6, 0x82f668e0
	if ctx.cr[6].gt {
	pc = 0x82F668E0; continue 'dispatch;
	}
	// 82F660EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F660F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F660F4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82F660F8: C38B233C  lfs f28, 0x233c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9020 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82F660FC: C3AA0B60  lfs f29, 0xb60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2912 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82F66100: C3C90A90  lfs f30, 0xa90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2704 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82F66104: 2B110001  cmplwi cr6, r17, 1
	ctx.cr[6].compare_u32(ctx.r[17].u32, 1 as u32, &mut ctx.xer);
	// 82F66108: 409A000C  bne cr6, 0x82f66114
	if !ctx.cr[6].eq {
	pc = 0x82F66114; continue 'dispatch;
	}
	// 82F6610C: 82010454  lwz r16, 0x454(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82F66110: 4800000C  b 0x82f6611c
	pc = 0x82F6611C; continue 'dispatch;
	// 82F66114: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82F66118: 3A0B000C  addi r16, r11, 0xc
	ctx.r[16].s64 = ctx.r[11].s64 + 12;
	// 82F6611C: 816E0038  lwz r11, 0x38(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F66120: 7FB2EB78  mr r18, r29
	ctx.r[18].u64 = ctx.r[29].u64;
	// 82F66124: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82F66128: 40990008  ble cr6, 0x82f66130
	if !ctx.cr[6].gt {
	pc = 0x82F66130; continue 'dispatch;
	}
	// 82F6612C: 7E328B78  mr r18, r17
	ctx.r[18].u64 = ctx.r[17].u64;
	// 82F66130: 81610434  lwz r11, 0x434(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1076 as u32) ) } as u64;
	// 82F66134: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 82F66138: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 82F6613C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82F66140: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66144: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82F66148: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6614C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82F66150: 4200FFF0  bdnz 0x82f66140
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82F66140; continue 'dispatch;
	}
	// 82F66154: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F66158: 4BFFC099  bl 0x82f621f0
	ctx.lr = 0x82F6615C;
	sub_82F621F0(ctx, base);
	// 82F6615C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66160: 41820770  beq 0x82f668d0
	if ctx.cr[0].eq {
	pc = 0x82F668D0; continue 'dispatch;
	}
	// 82F66164: 826100B0  lwz r19, 0xb0(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82F66168: 82A100B8  lwz r21, 0xb8(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82F6616C: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66170: 56AA103A  slwi r10, r21, 2
	ctx.r[10].u32 = ctx.r[21].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F66174: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F66178: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82F6617C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F66180: 4BFFC989  bl 0x82f62b08
	ctx.lr = 0x82F66184;
	sub_82F62B08(ctx, base);
	// 82F66184: 8141044C  lwz r10, 0x44c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1100 as u32) ) } as u64;
	// 82F66188: 81610444  lwz r11, 0x444(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1092 as u32) ) } as u64;
	// 82F6618C: C1810060  lfs f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F66190: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F66194: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66198: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F6619C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F661A0: F94100A0  std r10, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u64 ) };
	// 82F661A4: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F661A8: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F661AC: C98100A0  lfd f12, 0xa0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 82F661B0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F661B4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82F661B8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F661BC: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82F661C0: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82F661C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F661C8: 556B0FFF  rlwinm. r11, r11, 1, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F661CC: 41820018  beq 0x82f661e4
	if ctx.cr[0].eq {
	pc = 0x82F661E4; continue 'dispatch;
	}
	// 82F661D0: A17F001A  lhz r11, 0x1a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 82F661D4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F661D8: F9610110  std r11, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u64 ) };
	// 82F661DC: C8010110  lfd f0, 0x110(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 82F661E0: 48000014  b 0x82f661f4
	pc = 0x82F661F4; continue 'dispatch;
	// 82F661E4: A17F0026  lhz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 82F661E8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F661EC: F96100F8  std r11, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u64 ) };
	// 82F661F0: C80100F8  lfd f0, 0xf8(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	// 82F661F4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F661F8: 89700007  lbz r11, 7(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[16].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F661FC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66200: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F66204: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82F66208: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82F6620C: 41820068  beq 0x82f66274
	if ctx.cr[0].eq {
	pc = 0x82F66274; continue 'dispatch;
	}
	// 82F66210: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82F66214: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82F66218: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82F6621C: 4800696D  bl 0x82f6cb88
	ctx.lr = 0x82F66220;
	sub_82F6CB88(ctx, base);
	// 82F66220: C0010120  lfs f0, 0x120(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66224: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82F66228: EC20D02A  fadds f1, f0, f26
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82F6622C: C0010124  lfs f0, 0x124(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66230: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82F66234: 4B2C615D  bl 0x8222c390
	ctx.lr = 0x82F66238;
	sub_8222C390(ctx, base);
	// 82F66238: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F6623C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82F66240: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66244: EC20D02A  fadds f1, f0, f26
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82F66248: 4B2C6149  bl 0x8222c390
	ctx.lr = 0x82F6624C;
	sub_8222C390(ctx, base);
	// 82F6624C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F66250: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82F66254: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82F66258: 38810118  addi r4, r1, 0x118
	ctx.r[4].s64 = ctx.r[1].s64 + 280;
	// 82F6625C: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 82F66260: 48006929  bl 0x82f6cb88
	ctx.lr = 0x82F66264;
	sub_82F6CB88(ctx, base);
	// 82F66264: C0010118  lfs f0, 0x118(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66268: C1A1011C  lfs f13, 0x11c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6626C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82F66270: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82F66274: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F66278: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82F6627C: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 82F66280: 4BFFE1A9  bl 0x82f64428
	ctx.lr = 0x82F66284;
	sub_82F64428(ctx, base);
	// 82F66284: 1F14001C  mulli r24, r20, 0x1c
	ctx.r[24].s64 = ctx.r[20].s64 * 28;
	// 82F66288: 816102C0  lwz r11, 0x2c0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(704 as u32) ) } as u64;
	// 82F6628C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F66290: 419A0014  beq cr6, 0x82f662a4
	if ctx.cr[6].eq {
	pc = 0x82F662A4; continue 'dispatch;
	}
	// 82F66294: 814102C4  lwz r10, 0x2c4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(708 as u32) ) } as u64;
	// 82F66298: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6629C: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	// 82F662A0: 41980008  blt cr6, 0x82f662a8
	if ctx.cr[6].lt {
	pc = 0x82F662A8; continue 'dispatch;
	}
	// 82F662A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F662A8: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F662AC: 408205F8  bne 0x82f668a4
	if !ctx.cr[0].eq {
	pc = 0x82F668A4; continue 'dispatch;
	}
	// 82F662B0: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82F662B4: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 82F662B8: 5549D1BE  srwi r9, r10, 6
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(6);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F662BC: 552907FF  clrlwi. r9, r9, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82F662C0: 4082000C  bne 0x82f662cc
	if !ctx.cr[0].eq {
	pc = 0x82F662CC; continue 'dispatch;
	}
	// 82F662C4: A2EB0002  lhz r23, 2(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82F662C8: 4800000C  b 0x82f662d4
	pc = 0x82F662D4; continue 'dispatch;
	// 82F662CC: A12B0002  lhz r9, 2(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82F662D0: 7EE900D0  neg r23, r9
	ctx.r[23].s64 = -ctx.r[9].s64;
	// 82F662D4: A3CB0000  lhz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F662D8: 2B1EFFFF  cmplwi cr6, r30, 0xffff
	ctx.cr[6].compare_u32(ctx.r[30].u32, 65535 as u32, &mut ctx.xer);
	// 82F662DC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82F662E0: 41980008  blt cr6, 0x82f662e8
	if ctx.cr[6].lt {
	pc = 0x82F662E8; continue 'dispatch;
	}
	// 82F662E4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F662E8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82F662EC: 409A0010  bne cr6, 0x82f662fc
	if !ctx.cr[6].eq {
	pc = 0x82F662FC; continue 'dispatch;
	}
	// 82F662F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F662F4: 997C0024  stb r11, 0x24(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82F662F8: 48000580  b 0x82f66878
	pc = 0x82F66878; continue 'dispatch;
	// 82F662FC: 554BBE7E  rlwinm r11, r10, 0x17, 0x19, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000001FFu64;
	// 82F66300: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66304: 40820574  bne 0x82f66878
	if !ctx.cr[0].eq {
	pc = 0x82F66878; continue 'dispatch;
	}
	// 82F66308: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 82F6630C: 409A0014  bne cr6, 0x82f66320
	if !ctx.cr[6].eq {
	pc = 0x82F66320; continue 'dispatch;
	}
	// 82F66310: 554BDD7E  rlwinm r11, r10, 0x1b, 0x15, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82F66314: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66318: 41820560  beq 0x82f66878
	if ctx.cr[0].eq {
	pc = 0x82F66878; continue 'dispatch;
	}
	// 82F6631C: 4800000C  b 0x82f66328
	pc = 0x82F66328; continue 'dispatch;
	// 82F66320: 554B8FFF  rlwinm. r11, r10, 0x11, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66324: 4182FFCC  beq 0x82f662f0
	if ctx.cr[0].eq {
	pc = 0x82F662F0; continue 'dispatch;
	}
	// 82F66328: 397C0010  addi r11, r28, 0x10
	ctx.r[11].s64 = ctx.r[28].s64 + 16;
	// 82F6632C: 817C0010  lwz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F66330: 9241008C  stw r18, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[18].u32 ) };
	// 82F66334: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82F66338: 7FABC214  add r29, r11, r24
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82F6633C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F66340: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82F66344: 3B18001C  addi r24, r24, 0x1c
	ctx.r[24].s64 = ctx.r[24].s64 + 28;
	// 82F66348: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6634C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82F66350: 4BFFDAC9  bl 0x82f63e18
	ctx.lr = 0x82F66354;
	sub_82F63E18(ctx, base);
	// 82F66354: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66358: 3B430008  addi r26, r3, 8
	ctx.r[26].s64 = ctx.r[3].s64 + 8;
	// 82F6635C: 40820008  bne 0x82f66364
	if !ctx.cr[0].eq {
	pc = 0x82F66364; continue 'dispatch;
	}
	// 82F66360: 7DFA7B78  mr r26, r15
	ctx.r[26].u64 = ctx.r[15].u64;
	// 82F66364: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F66368: 7DFB7B78  mr r27, r15
	ctx.r[27].u64 = ctx.r[15].u64;
	// 82F6636C: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66370: 81160000  lwz r8, 0(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66374: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82F66378: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6637C: 1D4A0024  mulli r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 * 36;
	// 82F66380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F66384: 7FEA4214  add r31, r10, r8
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82F66388: 419A02F8  beq cr6, 0x82f66680
	if ctx.cr[6].eq {
	pc = 0x82F66680; continue 'dispatch;
	}
	// 82F6638C: 894E0014  lbz r10, 0x14(r14)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[14].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F66390: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66394: 40820014  bne 0x82f663a8
	if !ctx.cr[0].eq {
	pc = 0x82F663A8; continue 'dispatch;
	}
	// 82F66398: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6639C: A14B0020  lhz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82F663A0: 554A047E  clrlwi r10, r10, 0x11
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 82F663A4: B14B0020  sth r10, 0x20(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u16 ) };
	// 82F663A8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F663AC: C00E0044  lfs f0, 0x44(r14)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F663B0: 394B0018  addi r10, r11, 0x18
	ctx.r[10].s64 = ctx.r[11].s64 + 24;
	// 82F663B4: A14B0018  lhz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F663B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F663BC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F663C0: F9410108  std r10, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 82F663C4: C9A10108  lfd f13, 0x108(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	// 82F663C8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F663CC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F663D0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F663D4: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82F663D8: C00E0048  lfs f0, 0x48(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F663DC: A14B001A  lhz r10, 0x1a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 82F663E0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F663E4: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F663E8: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F663EC: F9410100  std r10, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[10].u64 ) };
	// 82F663F0: C9810100  lfd f12, 0x100(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82F663F4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F663F8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F663FC: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F66400: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82F66404: A14B001C  lhz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F66408: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 82F6640C: C00E0044  lfs f0, 0x44(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66410: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F66414: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F66418: F9410198  std r10, 0x198(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[10].u64 ) };
	// 82F6641C: C9610198  lfd f11, 0x198(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) };
	// 82F66420: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82F66424: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82F66428: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F6642C: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82F66430: C00E0048  lfs f0, 0x48(r14)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66434: A14B001E  lhz r10, 0x1e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(30 as u32) ) } as u64;
	// 82F66438: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 82F6643C: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F66440: F9410168  std r10, 0x168(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[10].u64 ) };
	// 82F66444: C9A10168  lfd f13, 0x168(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 82F66448: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F6644C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F66450: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82F66454: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82F66458: A12B0018  lhz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6645C: 895D0007  lbz r10, 7(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F66460: 5547FFBC  rlwinm r7, r10, 0x1f, 0x1e, 0x1e
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82F66464: A90B0020  lha r8, 0x20(r11)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as i16) as i64;
	// 82F66468: 7D484850  subf r10, r8, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82F6646C: 60E90001  ori r9, r7, 1
	ctx.r[9].u64 = ctx.r[7].u64 | 1;
	// 82F66470: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F66474: 79280020  clrldi r8, r9, 0x20
	ctx.r[8].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82F66478: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F6647C: F9010178  std r8, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[8].u64 ) };
	// 82F66480: C8010178  lfd f0, 0x178(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82F66484: F9410188  std r10, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[10].u64 ) };
	// 82F66488: C9A10188  lfd f13, 0x188(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 82F6648C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F66490: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82F66494: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F66498: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F6649C: EDAD06F2  fmuls f13, f13, f27
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[27].f64) as f32) as f64);
	// 82F664A0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F664A4: EDAD0024  fdivs f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82F664A8: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F664AC: A14B001A  lhz r10, 0x1a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 82F664B0: A90B0022  lha r8, 0x22(r11)
	ctx.r[8].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as i16) as i64;
	// 82F664B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82F664B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F664BC: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F664C0: F9410160  std r10, 0x160(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[10].u64 ) };
	// 82F664C4: C9810160  lfd f12, 0x160(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 82F664C8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F664CC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F664D0: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82F664D4: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F664D8: A14B001C  lhz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F664DC: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 82F664E0: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82F664E4: FFE06090  fmr f31, f12
	ctx.f[31].f64 = ctx.f[12].f64;
	// 82F664E8: F94101A8  std r10, 0x1a8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[10].u64 ) };
	// 82F664EC: C98101A8  lfd f12, 0x1a8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) };
	// 82F664F0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F664F4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F664F8: ED8C06F2  fmuls f12, f12, f27
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82F664FC: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82F66500: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82F66504: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F66508: A16B001E  lhz r11, 0x1e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(30 as u32) ) } as u64;
	// 82F6650C: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82F66510: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F66514: F9610170  std r11, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u64 ) };
	// 82F66518: C8010170  lfd f0, 0x170(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 82F6651C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F66520: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F66524: EC00FEFA  fmadds f0, f0, f27, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[31].f64) as f32) as f64);
	// 82F66528: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F6652C: 409A0020  bne cr6, 0x82f6654c
	if !ctx.cr[6].eq {
	pc = 0x82F6654C; continue 'dispatch;
	}
	// 82F66530: 89610070  lbz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82F66534: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66538: 40820014  bne 0x82f6654c
	if !ctx.cr[0].eq {
	pc = 0x82F6654C; continue 'dispatch;
	}
	// 82F6653C: 897D0008  lbz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F66540: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66544: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F66548: 41820008  beq 0x82f66550
	if ctx.cr[0].eq {
	pc = 0x82F66550; continue 'dispatch;
	}
	// 82F6654C: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82F66550: 895D0007  lbz r10, 7(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(7 as u32) ) } as u64;
	// 82F66554: 557B063E  clrlwi r27, r11, 0x18
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F66558: 554B07FF  clrlwi. r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6655C: 41820034  beq 0x82f66590
	if ctx.cr[0].eq {
	pc = 0x82F66590; continue 'dispatch;
	}
	// 82F66560: A17D0012  lhz r11, 0x12(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(18 as u32) ) } as u64;
	// 82F66564: 8141044C  lwz r10, 0x44c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1100 as u32) ) } as u64;
	// 82F66568: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F6656C: F96101C8  std r11, 0x1c8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(456 as u32), ctx.r[11].u64 ) };
	// 82F66570: C9A101C8  lfd f13, 0x1c8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(456 as u32) ) };
	// 82F66574: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F66578: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F6657C: C00A0060  lfs f0, 0x60(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66580: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F66584: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82F66588: EC190024  fdivs f0, f25, f0
	ctx.f[0].f64 = ((ctx.f[25].f64 / ctx.f[0].f64) as f32) as f64;
	// 82F6658C: 48000030  b 0x82f665bc
	pc = 0x82F665BC; continue 'dispatch;
	// 82F66590: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82F66594: 4BFFB88D  bl 0x82f61e20
	ctx.lr = 0x82F66598;
	sub_82F61E20(ctx, base);
	// 82F66598: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6659C: EC010772  fmuls f0, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[29].f64) as f32) as f64);
	// 82F665A0: 7DFB7B78  mr r27, r15
	ctx.r[27].u64 = ctx.r[15].u64;
	// 82F665A4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F665A8: F9610180  std r11, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u64 ) };
	// 82F665AC: C9A10180  lfd f13, 0x180(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82F665B0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F665B4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F665B8: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82F665BC: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F665C0: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F665C4: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F665C8: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82F665CC: C15F000C  lfs f10, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F665D0: ED6002F2  fmuls f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82F665D4: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F665D8: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F665DC: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F665E0: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 82F665E4: D17F0008  stfs f11, 8(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F665E8: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F665EC: 409A0078  bne cr6, 0x82f66664
	if !ctx.cr[6].eq {
	pc = 0x82F66664; continue 'dispatch;
	}
	// 82F665F0: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82F665F4: A94B001C  lha r10, 0x1c(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as i16) as i64;
	// 82F665F8: F94101B8  std r10, 0x1b8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[10].u64 ) };
	// 82F665FC: C94101B8  lfd f10, 0x1b8(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) };
	// 82F66600: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 82F66604: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82F66608: ED8A602A  fadds f12, f10, f12
	ctx.f[12].f64 = ((ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F6660C: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F66610: A94B001E  lha r10, 0x1e(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(30 as u32) ) } as i16) as i64;
	// 82F66614: F9410190  std r10, 0x190(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[10].u64 ) };
	// 82F66618: C9810190  lfd f12, 0x190(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) };
	// 82F6661C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F66620: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F66624: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82F66628: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6662C: A94B001C  lha r10, 0x1c(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as i16) as i64;
	// 82F66630: F94101C0  std r10, 0x1c0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(448 as u32), ctx.r[10].u64 ) };
	// 82F66634: C9A101C0  lfd f13, 0x1c0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(448 as u32) ) };
	// 82F66638: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F6663C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F66640: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82F66644: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F66648: A96B001E  lha r11, 0x1e(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(30 as u32) ) } as i16) as i64;
	// 82F6664C: F96101A0  std r11, 0x1a0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u64 ) };
	// 82F66650: C9A101A0  lfd f13, 0x1a0(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) };
	// 82F66654: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F66658: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F6665C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82F66660: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F66664: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82F66668: 4BFFB7B9  bl 0x82f61e20
	ctx.lr = 0x82F6666C;
	sub_82F61E20(ctx, base);
	// 82F6666C: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 82F66670: D80101D0  stfd f0, 0x1d0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.f[0].u64 ) };
	// 82F66674: A16101D6  lhz r11, 0x1d6(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(470 as u32) ) } as u64;
	// 82F66678: B17D0010  sth r11, 0x10(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82F6667C: 48000120  b 0x82f6679c
	pc = 0x82F6679C; continue 'dispatch;
	// 82F66680: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66684: 2B1EFFFF  cmplwi cr6, r30, 0xffff
	ctx.cr[6].compare_u32(ctx.r[30].u32, 65535 as u32, &mut ctx.xer);
	// 82F66688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6668C: 838B0010  lwz r28, 0x10(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F66690: 41980008  blt cr6, 0x82f66698
	if ctx.cr[6].lt {
	pc = 0x82F66698; continue 'dispatch;
	}
	// 82F66694: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82F66698: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6669C: 4BFE991D  bl 0x82f4ffb8
	ctx.lr = 0x82F666A0;
	sub_82F4FFB8(ctx, base);
	// 82F666A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F666A4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82F666A8: 4BFFB779  bl 0x82f61e20
	ctx.lr = 0x82F666AC;
	sub_82F61E20(ctx, base);
	// 82F666AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F666B0: EFE10732  fmuls f31, f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[28].f64) as f32) as f64);
	// 82F666B4: 4BFE8BBD  bl 0x82f4f270
	ctx.lr = 0x82F666B8;
	sub_82F4F270(ctx, base);
	// 82F666B8: A17D0018  lhz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F666BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F666C0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F666C4: F96101B0  std r11, 0x1b0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[11].u64 ) };
	// 82F666C8: C80101B0  lfd f0, 0x1b0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(432 as u32) ) };
	// 82F666CC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F666D0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F666D4: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F666D8: EF0007F2  fmuls f24, f0, f31
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F666DC: 4BFE8B95  bl 0x82f4f270
	ctx.lr = 0x82F666E0;
	sub_82F4F270(ctx, base);
	// 82F666E0: C01E0024  lfs f0, 0x24(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F666E4: A15D001A  lhz r10, 0x1a(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(26 as u32) ) } as u64;
	// 82F666E8: C1BE0020  lfs f13, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F666EC: 397E0018  addi r11, r30, 0x18
	ctx.r[11].s64 = ctx.r[30].s64 + 24;
	// 82F666F0: C19E001C  lfs f12, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F666F4: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 82F666F8: C17E0018  lfs f11, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F666FC: 8381042C  lwz r28, 0x42c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1068 as u32) ) } as u64;
	// 82F66700: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F66704: F96101E0  std r11, 0x1e0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(480 as u32), ctx.r[11].u64 ) };
	// 82F66708: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6670C: C98101E0  lfd f12, 0x1e0(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(480 as u32) ) };
	// 82F66710: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F66714: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F66718: C01E001C  lfs f0, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6671C: C1BE0018  lfs f13, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F66720: C15E0020  lfs f10, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F66724: C17E0024  lfs f11, 0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F66728: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82F6672C: D17F001C  stfs f11, 0x1c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82F66730: FDA0669C  fcfid f13, f12
	ctx.f[13].f64 = (ctx.f[12].s64 as f64);
	// 82F66734: D15F0018  stfs f10, 0x18(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82F66738: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82F6673C: C17E002C  lfs f11, 0x2c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F66740: C11F0000  lfs f8, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82F66744: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F66748: C01E0028  lfs f0, 0x28(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6674C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F66750: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F66754: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F66758: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F6675C: C13F0008  lfs f9, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82F66760: ED00402A  fadds f8, f0, f8
	ctx.f[8].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 82F66764: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 82F66768: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6676C: ED8B602A  fadds f12, f11, f12
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F66770: ED6B502A  fadds f11, f11, f10
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 82F66774: EC000632  fmuls f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82F66778: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F6677C: ED480632  fmuls f10, f8, f24
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[24].f64) as f32) as f64);
	// 82F66780: D15F0000  stfs f10, 0(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F66784: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F66788: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6678C: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F66790: EC0B0372  fmuls f0, f11, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F66794: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F66798: B1FD0010  sth r15, 0x10(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[15].u16 ) };
	// 82F6679C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F667A0: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F667A4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F667A8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82F667AC: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82F667B0: 41820054  beq 0x82f66804
	if ctx.cr[0].eq {
	pc = 0x82F66804; continue 'dispatch;
	}
	// 82F667B4: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82F667B8: 38810138  addi r4, r1, 0x138
	ctx.r[4].s64 = ctx.r[1].s64 + 312;
	// 82F667BC: 38610230  addi r3, r1, 0x230
	ctx.r[3].s64 = ctx.r[1].s64 + 560;
	// 82F667C0: 480063C9  bl 0x82f6cb88
	ctx.lr = 0x82F667C4;
	sub_82F6CB88(ctx, base);
	// 82F667C4: C0010138  lfs f0, 0x138(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F667C8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82F667CC: EC20D02A  fadds f1, f0, f26
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82F667D0: C001013C  lfs f0, 0x13c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F667D4: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82F667D8: 4B2C5BB9  bl 0x8222c390
	ctx.lr = 0x82F667DC;
	sub_8222C390(ctx, base);
	// 82F667DC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F667E0: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82F667E4: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82F667E8: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 82F667EC: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 82F667F0: 48006399  bl 0x82f6cb88
	ctx.lr = 0x82F667F4;
	sub_82F6CB88(ctx, base);
	// 82F667F4: C0010140  lfs f0, 0x140(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F667F8: C1A10144  lfs f13, 0x144(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F667FC: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82F66800: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82F66804: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F66808: 2B110001  cmplwi cr6, r17, 1
	ctx.cr[6].compare_u32(ctx.r[17].u32, 1 as u32, &mut ctx.xer);
	// 82F6680C: C17F0008  lfs f11, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F66810: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F66814: C15F0004  lfs f10, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F66818: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82F6681C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F66820: EC0D502A  fadds f0, f13, f10
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82F66824: C17F000C  lfs f11, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F66828: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6682C: EC0D582A  fadds f0, f13, f11
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82F66830: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F66834: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F66838: 409A0014  bne cr6, 0x82f6684c
	if !ctx.cr[6].eq {
	pc = 0x82F6684C; continue 'dispatch;
	}
	// 82F6683C: 814102F4  lwz r10, 0x2f4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(756 as u32) ) } as u64;
	// 82F66840: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82F66844: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82F66848: 4800000C  b 0x82f66854
	pc = 0x82F66854; continue 'dispatch;
	// 82F6684C: 81610454  lwz r11, 0x454(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1108 as u32) ) } as u64;
	// 82F66850: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82F66854: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66858: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82F6685C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66860: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82F66864: 4BFFDD5D  bl 0x82f645c0
	ctx.lr = 0x82F66868;
	sub_82F645C0(ctx, base);
	// 82F66868: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6686C: 83A100A8  lwz r29, 0xa8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82F66870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F66874: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F66878: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 82F6687C: 4BFFB5F5  bl 0x82f61e70
	ctx.lr = 0x82F66880;
	sub_82F61E70(ctx, base);
	// 82F66880: 7EEB07B4  extsw r11, r23
	ctx.r[11].s64 = ctx.r[23].s32 as i64;
	// 82F66884: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F66888: F96101D8  std r11, 0x1d8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[11].u64 ) };
	// 82F6688C: C9A101D8  lfd f13, 0x1d8(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(472 as u32) ) };
	// 82F66890: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F66894: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F66898: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82F6689C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82F668A0: 4BFFF9E8  b 0x82f66288
	pc = 0x82F66288; continue 'dispatch;
	// 82F668A4: 386102C0  addi r3, r1, 0x2c0
	ctx.r[3].s64 = ctx.r[1].s64 + 704;
	// 82F668A8: 4BFFD159  bl 0x82f63a00
	ctx.lr = 0x82F668AC;
	sub_82F63A00(ctx, base);
	// 82F668AC: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F668B0: 7F155840  cmplw cr6, r21, r11
	ctx.cr[6].compare_u32(ctx.r[21].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F668B4: 4098000C  bge cr6, 0x82f668c0
	if !ctx.cr[6].lt {
	pc = 0x82F668C0; continue 'dispatch;
	}
	// 82F668B8: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 82F668BC: 92A100B8  stw r21, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[21].u32 ) };
	// 82F668C0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F668C4: 4BFFB92D  bl 0x82f621f0
	ctx.lr = 0x82F668C8;
	sub_82F621F0(ctx, base);
	// 82F668C8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F668CC: 4082F8A0  bne 0x82f6616c
	if !ctx.cr[0].eq {
	pc = 0x82F6616C; continue 'dispatch;
	}
	// 82F668D0: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F668D4: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 82F668D8: 7F115840  cmplw cr6, r17, r11
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F668DC: 4099F828  ble cr6, 0x82f66104
	if !ctx.cr[6].gt {
	pc = 0x82F66104; continue 'dispatch;
	}
	// 82F668E0: 38210410  addi r1, r1, 0x410
	ctx.r[1].s64 = ctx.r[1].s64 + 1040;
	// 82F668E4: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82F668E8: 4BD4742D  bl 0x82cadd14
	ctx.lr = 0x82F668EC;
	sub_82CADCEC(ctx, base);
	// 82F668EC: 4BD42B34  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F668F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F668F0 size=164
    let mut pc: u32 = 0x82F668F0;
    'dispatch: loop {
        match pc {
            0x82F668F0 => {
    //   block [0x82F668F0..0x82F66994)
	// 82F668F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F668F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F668F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F668FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66908: 4BFFED51  bl 0x82f65658
	ctx.lr = 0x82F6690C;
	sub_82F65658(ctx, base);
	// 82F6690C: 3BDF0980  addi r30, r31, 0x980
	ctx.r[30].s64 = ctx.r[31].s64 + 2432;
	// 82F66910: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 82F66914: 4805C815  bl 0x82fc3128
	ctx.lr = 0x82F66918;
	sub_82FC3128(ctx, base);
	// 82F66918: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82F6691C: 4805C80D  bl 0x82fc3128
	ctx.lr = 0x82F66920;
	sub_82FC3128(ctx, base);
	// 82F66920: 3BDF0930  addi r30, r31, 0x930
	ctx.r[30].s64 = ctx.r[31].s64 + 2352;
	// 82F66924: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 82F66928: 4805C801  bl 0x82fc3128
	ctx.lr = 0x82F6692C;
	sub_82FC3128(ctx, base);
	// 82F6692C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82F66930: 4805C7F9  bl 0x82fc3128
	ctx.lr = 0x82F66934;
	sub_82FC3128(ctx, base);
	// 82F66934: 387F0918  addi r3, r31, 0x918
	ctx.r[3].s64 = ctx.r[31].s64 + 2328;
	// 82F66938: 4805C7F1  bl 0x82fc3128
	ctx.lr = 0x82F6693C;
	sub_82FC3128(ctx, base);
	// 82F6693C: 387F08FC  addi r3, r31, 0x8fc
	ctx.r[3].s64 = ctx.r[31].s64 + 2300;
	// 82F66940: 4BFB5109  bl 0x82f1ba48
	ctx.lr = 0x82F66944;
	sub_82F1BA48(ctx, base);
	// 82F66944: 387F08E4  addi r3, r31, 0x8e4
	ctx.r[3].s64 = ctx.r[31].s64 + 2276;
	// 82F66948: 4BFFBE39  bl 0x82f62780
	ctx.lr = 0x82F6694C;
	sub_82F62780(ctx, base);
	// 82F6694C: 387F08E0  addi r3, r31, 0x8e0
	ctx.r[3].s64 = ctx.r[31].s64 + 2272;
	// 82F66950: 48029629  bl 0x82f8ff78
	ctx.lr = 0x82F66954;
	sub_82F8FF78(ctx, base);
	// 82F66954: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82F66958: 48065831  bl 0x82fcc188
	ctx.lr = 0x82F6695C;
	sub_82FCC188(ctx, base);
	// 82F6695C: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82F66960: 4BFFBD21  bl 0x82f62680
	ctx.lr = 0x82F66964;
	sub_82F62680(ctx, base);
	// 82F66964: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F66968: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6696C: 396B2290  addi r11, r11, 0x2290
	ctx.r[11].s64 = ctx.r[11].s64 + 8848;
	// 82F66970: 394AEAEC  addi r10, r10, -0x1514
	ctx.r[10].s64 = ctx.r[10].s64 + -5396;
	// 82F66974: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F66978: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6697C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F66980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6698C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66998 size=392
    let mut pc: u32 = 0x82F66998;
    'dispatch: loop {
        match pc {
            0x82F66998 => {
    //   block [0x82F66998..0x82F66B20)
	// 82F66998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6699C: 4BD42A5D  bl 0x82ca93f8
	ctx.lr = 0x82F669A0;
	sub_82CA93D0(ctx, base);
	// 82F669A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F669A4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82F669A8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F669AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F669B0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82F669B4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82F669B8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F669BC: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 82F669C0: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 82F669C4: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82F669C8: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F669CC: 4BFFE1D5  bl 0x82f64ba0
	ctx.lr = 0x82F669D0;
	sub_82F64BA0(ctx, base);
	// 82F669D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F669D4: 419A0090  beq cr6, 0x82f66a64
	if ctx.cr[6].eq {
	pc = 0x82F66A64; continue 'dispatch;
	}
	// 82F669D8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F669DC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F669E0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F669E4: 409A0070  bne cr6, 0x82f66a54
	if !ctx.cr[6].eq {
	pc = 0x82F66A54; continue 'dispatch;
	}
	// 82F669E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F669EC: 419A00F4  beq cr6, 0x82f66ae0
	if ctx.cr[6].eq {
	pc = 0x82F66AE0; continue 'dispatch;
	}
	// 82F669F0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82F669F4: 419A000C  beq cr6, 0x82f66a00
	if ctx.cr[6].eq {
	pc = 0x82F66A00; continue 'dispatch;
	}
	// 82F669F8: 4BFFD081  bl 0x82f63a78
	ctx.lr = 0x82F669FC;
	sub_82F63A78(ctx, base);
	// 82F669FC: 480000E4  b 0x82f66ae0
	pc = 0x82F66AE0; continue 'dispatch;
	// 82F66A00: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82F66A04: 4BF96E5D  bl 0x82efd860
	ctx.lr = 0x82F66A08;
	sub_82EFD860(ctx, base);
	// 82F66A08: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66A0C: 4182003C  beq 0x82f66a48
	if ctx.cr[0].eq {
	pc = 0x82F66A48; continue 'dispatch;
	}
	// 82F66A10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F66A14: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F66A18: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F66A1C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F66A20: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F66A24: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F66A28: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F66A2C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82F66A30: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82F66A34: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82F66A38: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82F66A3C: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82F66A40: 99630025  stb r11, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 82F66A44: 48000008  b 0x82f66a4c
	pc = 0x82F66A4C; continue 'dispatch;
	// 82F66A48: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F66A4C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F66A50: 48000090  b 0x82f66ae0
	pc = 0x82F66AE0; continue 'dispatch;
	// 82F66A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F66A58: 419A000C  beq cr6, 0x82f66a64
	if ctx.cr[6].eq {
	pc = 0x82F66A64; continue 'dispatch;
	}
	// 82F66A5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F66A60: 4BFFDDA9  bl 0x82f64808
	ctx.lr = 0x82F66A64;
	sub_82F64808(ctx, base);
	// 82F66A64: 387E0018  addi r3, r30, 0x18
	ctx.r[3].s64 = ctx.r[30].s64 + 24;
	// 82F66A68: 4BFFBC81  bl 0x82f626e8
	ctx.lr = 0x82F66A6C;
	sub_82F626E8(ctx, base);
	// 82F66A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66A70: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82F66A74: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82F66A78: 4BF96DE9  bl 0x82efd860
	ctx.lr = 0x82F66A7C;
	sub_82EFD860(ctx, base);
	// 82F66A7C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66A80: 4182003C  beq 0x82f66abc
	if ctx.cr[0].eq {
	pc = 0x82F66ABC; continue 'dispatch;
	}
	// 82F66A84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F66A88: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F66A8C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F66A90: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F66A94: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F66A98: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F66A9C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F66AA0: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82F66AA4: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82F66AA8: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82F66AAC: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82F66AB0: 99630024  stb r11, 0x24(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82F66AB4: 99630025  stb r11, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 82F66AB8: 48000008  b 0x82f66ac0
	pc = 0x82F66AC0; continue 'dispatch;
	// 82F66ABC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F66AC0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F66AC4: 397E0028  addi r11, r30, 0x28
	ctx.r[11].s64 = ctx.r[30].s64 + 40;
	// 82F66AC8: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66ACC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F66AD0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F66AD4: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66AD8: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82F66ADC: 93FE0028  stw r31, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 82F66AE0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82F66AE4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F66AE8: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 82F66AEC: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82F66AF0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82F66AF4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82F66AF8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82F66AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F66B00: 4BFFEC79  bl 0x82f65778
	ctx.lr = 0x82F66B04;
	sub_82F65778(ctx, base);
	// 82F66B04: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66B08: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 82F66B0C: 808B0014  lwz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F66B10: 48064691  bl 0x82fcb1a0
	ctx.lr = 0x82F66B14;
	sub_82FCB1A0(ctx, base);
	// 82F66B14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66B18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F66B1C: 4BD4292C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66B20 size=108
    let mut pc: u32 = 0x82F66B20;
    'dispatch: loop {
        match pc {
            0x82F66B20 => {
    //   block [0x82F66B20..0x82F66B8C)
	// 82F66B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66B28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F66B2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66B30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66B38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F66B3C: 396B22EC  addi r11, r11, 0x22ec
	ctx.r[11].s64 = ctx.r[11].s64 + 8940;
	// 82F66B40: 83DF0048  lwz r30, 0x48(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F66B44: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F66B48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F66B4C: 419A0014  beq cr6, 0x82f66b60
	if ctx.cr[6].eq {
	pc = 0x82F66B60; continue 'dispatch;
	}
	// 82F66B50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F66B54: 4BFFFD9D  bl 0x82f668f0
	ctx.lr = 0x82F66B58;
	sub_82F668F0(ctx, base);
	// 82F66B58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F66B5C: 4BF96D45  bl 0x82efd8a0
	ctx.lr = 0x82F66B60;
	sub_82EFD8A0(ctx, base);
	// 82F66B60: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F66B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66B68: 396BD140  addi r11, r11, -0x2ec0
	ctx.r[11].s64 = ctx.r[11].s64 + -11968;
	// 82F66B6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F66B70: 4BF96EA9  bl 0x82efda18
	ctx.lr = 0x82F66B74;
	sub_82EFDA18(ctx, base);
	// 82F66B74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F66B78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66B7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66B80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F66B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66B90 size=76
    let mut pc: u32 = 0x82F66B90;
    'dispatch: loop {
        match pc {
            0x82F66B90 => {
    //   block [0x82F66B90..0x82F66BDC)
	// 82F66B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66B94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66B98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F66B9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66BA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66BA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F66BAC: 4BFFFF75  bl 0x82f66b20
	ctx.lr = 0x82F66BB0;
	sub_82F66B20(ctx, base);
	// 82F66BB0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66BB4: 4182000C  beq 0x82f66bc0
	if ctx.cr[0].eq {
	pc = 0x82F66BC0; continue 'dispatch;
	}
	// 82F66BB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66BBC: 4BF96CE5  bl 0x82efd8a0
	ctx.lr = 0x82F66BC0;
	sub_82EFD8A0(ctx, base);
	// 82F66BC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66BC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F66BC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66BCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66BD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F66BD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66BD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66BE0 size=52
    let mut pc: u32 = 0x82F66BE0;
    'dispatch: loop {
        match pc {
            0x82F66BE0 => {
    //   block [0x82F66BE0..0x82F66C14)
	// 82F66BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66BE8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66BEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66BF0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F66BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66BF8: 4E800421  bctrl
	ctx.lr = 0x82F66BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66BFC: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F66C00: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82F66C04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66C08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66C0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66C18 size=96
    let mut pc: u32 = 0x82F66C18;
    'dispatch: loop {
        match pc {
            0x82F66C18 => {
    //   block [0x82F66C18..0x82F66C78)
	// 82F66C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F66C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66C30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F66C34: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F66C3C: 419A0018  beq cr6, 0x82f66c54
	if ctx.cr[6].eq {
	pc = 0x82F66C54; continue 'dispatch;
	}
	// 82F66C40: 4BFFFFD9  bl 0x82f66c18
	ctx.lr = 0x82F66C44;
	sub_82F66C18(ctx, base);
	// 82F66C44: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82F66C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F66C4C: 48005D55  bl 0x82f6c9a0
	ctx.lr = 0x82F66C50;
	sub_82F6C9A0(ctx, base);
	// 82F66C50: 48000010  b 0x82f66c60
	pc = 0x82F66C60; continue 'dispatch;
	// 82F66C54: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82F66C58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F66C5C: 48005B9D  bl 0x82f6c7f8
	ctx.lr = 0x82F66C60;
	sub_82F6C7F8(ctx, base);
	// 82F66C60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F66C64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66C68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66C6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F66C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66C78 size=104
    let mut pc: u32 = 0x82F66C78;
    'dispatch: loop {
        match pc {
            0x82F66C78 => {
    //   block [0x82F66C78..0x82F66CE0)
	// 82F66C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66C80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F66C84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66C88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66C8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F66C90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F66C94: 807E0028  lwz r3, 0x28(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F66C9C: 419A0018  beq cr6, 0x82f66cb4
	if ctx.cr[6].eq {
	pc = 0x82F66CB4; continue 'dispatch;
	}
	// 82F66CA0: 4BFFFFD9  bl 0x82f66c78
	ctx.lr = 0x82F66CA4;
	sub_82F66C78(ctx, base);
	// 82F66CA4: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82F66CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66CAC: 48005CF5  bl 0x82f6c9a0
	ctx.lr = 0x82F66CB0;
	sub_82F6C9A0(ctx, base);
	// 82F66CB0: 48000018  b 0x82f66cc8
	pc = 0x82F66CC8; continue 'dispatch;
	// 82F66CB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F66CB8: 48005CC1  bl 0x82f6c978
	ctx.lr = 0x82F66CBC;
	sub_82F6C978(ctx, base);
	// 82F66CBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F66CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66CC4: 48005B35  bl 0x82f6c7f8
	ctx.lr = 0x82F66CC8;
	sub_82F6C7F8(ctx, base);
	// 82F66CC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F66CCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66CD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66CD4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F66CD8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66CDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F66CE0 size=12
    let mut pc: u32 = 0x82F66CE0;
    'dispatch: loop {
        match pc {
            0x82F66CE0 => {
    //   block [0x82F66CE0..0x82F66CEC)
	// 82F66CE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F66CE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F66CE8: 48000014  b 0x82f66cfc
	sub_82F66CF8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66CEC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F66CEC size=12
    let mut pc: u32 = 0x82F66CEC;
    'dispatch: loop {
        match pc {
            0x82F66CEC => {
    //   block [0x82F66CEC..0x82F66CF8)
	// 82F66CEC: 806B0074  lwz r3, 0x74(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82F66CF0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82F66CF4: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F66CF8 size=16
    let mut pc: u32 = 0x82F66CF8;
    'dispatch: loop {
        match pc {
            0x82F66CF8 => {
    //   block [0x82F66CF8..0x82F66D08)
	// 82F66CF8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66CFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F66D00: 409AFFEC  bne cr6, 0x82f66cec
	if !ctx.cr[6].eq {
		sub_82F66CEC(ctx, base);
		return;
	}
	// 82F66D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66D08 size=60
    let mut pc: u32 = 0x82F66D08;
    'dispatch: loop {
        match pc {
            0x82F66D08 => {
    //   block [0x82F66D08..0x82F66D44)
	// 82F66D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66D10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66D14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66D18: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F66D1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66D20: 4E800421  bctrl
	ctx.lr = 0x82F66D24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66D24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66D28: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F66D2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66D30: 4E800421  bctrl
	ctx.lr = 0x82F66D34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66D34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66D38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66D3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66D48 size=128
    let mut pc: u32 = 0x82F66D48;
    'dispatch: loop {
        match pc {
            0x82F66D48 => {
    //   block [0x82F66D48..0x82F66DC8)
	// 82F66D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66D50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66D54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66D58: 83E30028  lwz r31, 0x28(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66D5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F66D60: 419A0034  beq cr6, 0x82f66d94
	if ctx.cr[6].eq {
	pc = 0x82F66D94; continue 'dispatch;
	}
	// 82F66D64: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F66D68: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F66D6C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F66D70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66D74: 4E800421  bctrl
	ctx.lr = 0x82F66D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66D78: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82F66D7C: 419A0010  beq cr6, 0x82f66d8c
	if ctx.cr[6].eq {
	pc = 0x82F66D8C; continue 'dispatch;
	}
	// 82F66D80: 83FF0028  lwz r31, 0x28(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66D84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F66D88: 409AFFDC  bne cr6, 0x82f66d64
	if !ctx.cr[6].eq {
	pc = 0x82F66D64; continue 'dispatch;
	}
	// 82F66D8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F66D90: 409A000C  bne cr6, 0x82f66d9c
	if !ctx.cr[6].eq {
	pc = 0x82F66D9C; continue 'dispatch;
	}
	// 82F66D94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F66D98: 4800001C  b 0x82f66db4
	pc = 0x82F66DB4; continue 'dispatch;
	// 82F66D9C: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F66DA0: 48025089  bl 0x82f8be28
	ctx.lr = 0x82F66DA4;
	sub_82F8BE28(ctx, base);
	// 82F66DA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66DA8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F66DAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66DB0: 4E800421  bctrl
	ctx.lr = 0x82F66DB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66DB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66DB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66DBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66DC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66DC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F66DC8 size=16
    let mut pc: u32 = 0x82F66DC8;
    'dispatch: loop {
        match pc {
            0x82F66DC8 => {
    //   block [0x82F66DC8..0x82F66DD8)
	// 82F66DC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66DCC: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F66DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66DD4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66DD8 size=48
    let mut pc: u32 = 0x82F66DD8;
    'dispatch: loop {
        match pc {
            0x82F66DD8 => {
    //   block [0x82F66DD8..0x82F66E08)
	// 82F66DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66DE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66DE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66DE8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F66DEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66DF0: 4E800421  bctrl
	ctx.lr = 0x82F66DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66DF4: 886300D8  lbz r3, 0xd8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(216 as u32) ) } as u64;
	// 82F66DF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66DFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66E00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66E08 size=60
    let mut pc: u32 = 0x82F66E08;
    'dispatch: loop {
        match pc {
            0x82F66E08 => {
    //   block [0x82F66E08..0x82F66E44)
	// 82F66E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66E10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66E14: 8163FFF0  lwz r11, -0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82F66E18: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82F66E1C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F66E20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66E24: 4E800421  bctrl
	ctx.lr = 0x82F66E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66E28: 896300D9  lbz r11, 0xd9(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(217 as u32) ) } as u64;
	// 82F66E2C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F66E30: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F66E34: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66E38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66E3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66E48 size=96
    let mut pc: u32 = 0x82F66E48;
    'dispatch: loop {
        match pc {
            0x82F66E48 => {
    //   block [0x82F66E48..0x82F66EA8)
	// 82F66E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66E50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66E54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66E58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66E5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66E60: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82F66E64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66E68: 4E800421  bctrl
	ctx.lr = 0x82F66E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66E6C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82F66E70: 41980010  blt cr6, 0x82f66e80
	if ctx.cr[6].lt {
	pc = 0x82F66E80; continue 'dispatch;
	}
	// 82F66E74: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82F66E78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F66E7C: 40990008  ble cr6, 0x82f66e84
	if !ctx.cr[6].gt {
	pc = 0x82F66E84; continue 'dispatch;
	}
	// 82F66E80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F66E84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66E8C: 40820008  bne 0x82f66e94
	if !ctx.cr[0].eq {
	pc = 0x82F66E94; continue 'dispatch;
	}
	// 82F66E90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F66E94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66E98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66E9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66EA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66EA8 size=248
    let mut pc: u32 = 0x82F66EA8;
    'dispatch: loop {
        match pc {
            0x82F66EA8 => {
    //   block [0x82F66EA8..0x82F66FA0)
	// 82F66EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66EAC: 4BD42559  bl 0x82ca9404
	ctx.lr = 0x82F66EB0;
	sub_82CA93D0(ctx, base);
	// 82F66EB0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82F66EB4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66EB8: 83E30028  lwz r31, 0x28(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66EBC: 38830050  addi r4, r3, 0x50
	ctx.r[4].s64 = ctx.r[3].s64 + 80;
	// 82F66EC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F66EC4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F66EC8: 48005931  bl 0x82f6c7f8
	ctx.lr = 0x82F66ECC;
	sub_82F6C7F8(ctx, base);
	// 82F66ECC: 48000030  b 0x82f66efc
	pc = 0x82F66EFC; continue 'dispatch;
	// 82F66ED0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66ED4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66ED8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66EDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66EE0: 4E800421  bctrl
	ctx.lr = 0x82F66EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66EE4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F66EE8: 4082002C  bne 0x82f66f14
	if !ctx.cr[0].eq {
	pc = 0x82F66F14; continue 'dispatch;
	}
	// 82F66EEC: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82F66EF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F66EF4: 48005B35  bl 0x82f6ca28
	ctx.lr = 0x82F66EF8;
	sub_82F6CA28(ctx, base);
	// 82F66EF8: 83FF0028  lwz r31, 0x28(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66EFC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F66F00: 409AFFD0  bne cr6, 0x82f66ed0
	if !ctx.cr[6].eq {
	pc = 0x82F66ED0; continue 'dispatch;
	}
	// 82F66F04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F66F08: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82F66F0C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82F66F10: 4BD42544  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82F66F14: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82F66F18: 48005A61  bl 0x82f6c978
	ctx.lr = 0x82F66F1C;
	sub_82F6C978(ctx, base);
	// 82F66F1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66F20: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82F66F24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F66F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F66F2C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F66F30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66F34: 4E800421  bctrl
	ctx.lr = 0x82F66F38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66F38: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 82F66F3C: 4BF96925  bl 0x82efd860
	ctx.lr = 0x82F66F40;
	sub_82EFD860(ctx, base);
	// 82F66F40: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F66F44: 4182FFC0  beq 0x82f66f04
	if ctx.cr[0].eq {
	pc = 0x82F66F04; continue 'dispatch;
	}
	// 82F66F48: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 82F66F4C: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 82F66F50: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 82F66F54: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 82F66F58: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F66F5C: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 82F66F60: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F66F64: 3B810060  addi r28, r1, 0x60
	ctx.r[28].s64 = ctx.r[1].s64 + 96;
	// 82F66F68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F66F6C: 3B7F0050  addi r27, r31, 0x50
	ctx.r[27].s64 = ctx.r[31].s64 + 80;
	// 82F66F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F66F74: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F66F78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F66F7C: 4E800421  bctrl
	ctx.lr = 0x82F66F80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F66F80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F66F84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F66F88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F66F8C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82F66F90: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F66F94: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 82F66F98: 4805B9F9  bl 0x82fc2990
	ctx.lr = 0x82F66F9C;
	sub_82FC2990(ctx, base);
	// 82F66F9C: 4BFFFF6C  b 0x82f66f08
	pc = 0x82F66F08; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F66FA0 size=88
    let mut pc: u32 = 0x82F66FA0;
    'dispatch: loop {
        match pc {
            0x82F66FA0 => {
    //   block [0x82F66FA0..0x82F66FF8)
	// 82F66FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F66FA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F66FA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F66FAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F66FB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F66FB4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F66FB8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F66FBC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66FC0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F66FC4: 40820008  bne 0x82f66fcc
	if !ctx.cr[0].eq {
	pc = 0x82F66FCC; continue 'dispatch;
	}
	// 82F66FC8: 48006AC1  bl 0x82f6da88
	ctx.lr = 0x82F66FCC;
	sub_82F6DA88(ctx, base);
	// 82F66FCC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F66FD0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F66FD4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F66FD8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F66FDC: 40820008  bne 0x82f66fe4
	if !ctx.cr[0].eq {
	pc = 0x82F66FE4; continue 'dispatch;
	}
	// 82F66FE0: 48006AA9  bl 0x82f6da88
	ctx.lr = 0x82F66FE4;
	sub_82F6DA88(ctx, base);
	// 82F66FE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F66FE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F66FEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F66FF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F66FF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F66FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F66FF8 size=28
    let mut pc: u32 = 0x82F66FF8;
    'dispatch: loop {
        match pc {
            0x82F66FF8 => {
    //   block [0x82F66FF8..0x82F67014)
	// 82F66FF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F66FFC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F67000: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F67008: 419A000C  beq cr6, 0x82f67014
	if ctx.cr[6].eq {
		sub_82F67014(ctx, base);
		return;
	}
	// 82F6700C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82F67010: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67014(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F67014 size=8
    let mut pc: u32 = 0x82F67014;
    'dispatch: loop {
        match pc {
            0x82F67014 => {
    //   block [0x82F67014..0x82F6701C)
	// 82F67014: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82F67018: 4BFD1F38  b 0x82f38f50
	sub_82F38F50(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67020 size=228
    let mut pc: u32 = 0x82F67020;
    'dispatch: loop {
        match pc {
            0x82F67020 => {
    //   block [0x82F67020..0x82F67104)
	// 82F67020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67024: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F67028: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6702C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F67030: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67038: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6703C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F67040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F67044: 419A0044  beq cr6, 0x82f67088
	if ctx.cr[6].eq {
	pc = 0x82F67088; continue 'dispatch;
	}
	// 82F67048: 4BFFFFD9  bl 0x82f67020
	ctx.lr = 0x82F6704C;
	sub_82F67020(ctx, base);
	// 82F6704C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82F67050: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67054: 388B230C  addi r4, r11, 0x230c
	ctx.r[4].s64 = ctx.r[11].s64 + 8972;
	// 82F67058: 4BF97929  bl 0x82efe980
	ctx.lr = 0x82F6705C;
	sub_82EFE980(ctx, base);
	// 82F6705C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67060: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67068: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6706C: 4E800421  bctrl
	ctx.lr = 0x82F67070;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67070: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F67074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67078: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6707C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67080: 4BF97901  bl 0x82efe980
	ctx.lr = 0x82F67084;
	sub_82EFE980(ctx, base);
	// 82F67084: 48000068  b 0x82f670ec
	pc = 0x82F670EC; continue 'dispatch;
	// 82F67088: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6708C: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F67090: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67094: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67098: 4E800421  bctrl
	ctx.lr = 0x82F6709C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6709C: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82F670A0: 409A0044  bne cr6, 0x82f670e4
	if !ctx.cr[6].eq {
	pc = 0x82F670E4; continue 'dispatch;
	}
	// 82F670A4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F670A8: 38A0003F  li r5, 0x3f
	ctx.r[5].s64 = 63;
	// 82F670AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F670B0: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82F670B4: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 82F670B8: 4BD428F9  bl 0x82ca99b0
	ctx.lr = 0x82F670BC;
	sub_82CA99B0(ctx, base);
	// 82F670BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F670C0: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82F670C4: 80DF01A0  lwz r6, 0x1a0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82F670C8: 38AB1A58  addi r5, r11, 0x1a58
	ctx.r[5].s64 = ctx.r[11].s64 + 6744;
	// 82F670CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F670D0: 4BF90201  bl 0x82ef72d0
	ctx.lr = 0x82F670D4;
	sub_82EF72D0(ctx, base);
	// 82F670D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F670D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F670DC: 4BF974BD  bl 0x82efe598
	ctx.lr = 0x82F670E0;
	sub_82EFE598(ctx, base);
	// 82F670E0: 4800000C  b 0x82f670ec
	pc = 0x82F670EC; continue 'dispatch;
	// 82F670E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F670E8: 4BF97E61  bl 0x82efef48
	ctx.lr = 0x82F670EC;
	sub_82EFEF48(ctx, base);
	// 82F670EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F670F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F670F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F670F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F670FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F67100: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67108 size=96
    let mut pc: u32 = 0x82F67108;
    'dispatch: loop {
        match pc {
            0x82F67108 => {
    //   block [0x82F67108..0x82F67168)
	// 82F67108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6710C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F67110: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F67114: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67118: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6711C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67120: 48024C49  bl 0x82f8bd68
	ctx.lr = 0x82F67124;
	sub_82F8BD68(ctx, base);
	// 82F67124: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F67128: 4082000C  bne 0x82f67134
	if !ctx.cr[0].eq {
	pc = 0x82F67134; continue 'dispatch;
	}
	// 82F6712C: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F67130: 806B0074  lwz r3, 0x74(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82F67134: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F67138: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6713C: 396BC000  addi r11, r11, -0x4000
	ctx.r[11].s64 = ctx.r[11].s64 + -16384;
	// 82F67140: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82F67144: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F67148: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6714C: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82F67150: 4BFA3C79  bl 0x82f0adc8
	ctx.lr = 0x82F67154;
	sub_82F0ADC8(ctx, base);
	// 82F67154: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F67158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6715C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F67160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F67164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67168 size=100
    let mut pc: u32 = 0x82F67168;
    'dispatch: loop {
        match pc {
            0x82F67168 => {
    //   block [0x82F67168..0x82F671CC)
	// 82F67168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6716C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F67170: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F67174: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67178: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6717C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67180: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82F67184: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82F67188: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6718C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F67190: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67194: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F67198: C80B0008  lfd f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82F6719C: D81F0008  stfd f0, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.f[0].u64 ) };
	// 82F671A0: C80B0010  lfd f0, 0x10(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82F671A4: D81F0010  stfd f0, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.f[0].u64 ) };
	// 82F671A8: C80B0018  lfd f0, 0x18(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F671AC: D81F0018  stfd f0, 0x18(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.f[0].u64 ) };
	// 82F671B0: 48005649  bl 0x82f6c7f8
	ctx.lr = 0x82F671B4;
	sub_82F6C7F8(ctx, base);
	// 82F671B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F671B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F671BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F671C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F671C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F671C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F671D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F671D0 size=172
    let mut pc: u32 = 0x82F671D0;
    'dispatch: loop {
        match pc {
            0x82F671D0 => {
    //   block [0x82F671D0..0x82F6727C)
	// 82F671D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F671D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F671D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F671DC: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82F671E0: 4BD46AF9  bl 0x82cadcd8
	ctx.lr = 0x82F671E4;
	sub_82CADCA0(ctx, base);
	// 82F671E4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F671E8: FFA01890  fmr f29, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82F671EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F671F0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F671F4: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82F671F8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82F671FC: 4B2D2CB5  bl 0x82239eb0
	ctx.lr = 0x82F67200;
	sub_82239EB0(ctx, base);
	// 82F67200: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F67204: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82F67208: 4B2D2D89  bl 0x82239f90
	ctx.lr = 0x82F6720C;
	sub_82239F90(ctx, base);
	// 82F6720C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F67210: C1BF0010  lfs f13, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F67214: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F67218: ED6D0732  fmuls f11, f13, f28
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[28].f64) as f32) as f64);
	// 82F6721C: ED4C0732  fmuls f10, f12, f28
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 82F67220: C13F0000  lfs f9, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82F67224: C11F0004  lfs f8, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82F67228: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6722C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F67230: ED69583A  fmadds f11, f9, f0, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82F67234: EC08503A  fmadds f0, f8, f0, f10
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82F67238: EDA96F38  fmsubs f13, f9, f28, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[28].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6723C: ED886738  fmsubs f12, f8, f28, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[28].f64 - ctx.f[12].f64) as f32) as f64);
	// 82F67240: ED6B07F2  fmuls f11, f11, f31
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F67244: D17F0010  stfs f11, 0x10(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82F67248: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82F6724C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82F67250: EC0D07F2  fmuls f0, f13, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82F67254: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F67258: EC0C07B2  fmuls f0, f12, f30
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82F6725C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F67260: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67264: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82F67268: 4BD46ABD  bl 0x82cadd24
	ctx.lr = 0x82F6726C;
	sub_82CADCEC(ctx, base);
	// 82F6726C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F67270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F67274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F67278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67280 size=88
    let mut pc: u32 = 0x82F67280;
    'dispatch: loop {
        match pc {
            0x82F67280 => {
    //   block [0x82F67280..0x82F672D8)
	// 82F67280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F67288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6728C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67294: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F67298: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6729C: 419A0028  beq cr6, 0x82f672c4
	if ctx.cr[6].eq {
	pc = 0x82F672C4; continue 'dispatch;
	}
	// 82F672A0: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 82F672A4: 48024B85  bl 0x82f8be28
	ctx.lr = 0x82F672A8;
	sub_82F8BE28(ctx, base);
	// 82F672A8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F672AC: 41820018  beq 0x82f672c4
	if ctx.cr[0].eq {
	pc = 0x82F672C4; continue 'dispatch;
	}
	// 82F672B0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F672B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F672B8: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F672BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F672C0: 4BFEC181  bl 0x82f53440
	ctx.lr = 0x82F672C4;
	sub_82F53440(ctx, base);
	// 82F672C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F672C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F672CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F672D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F672D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F672D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F672D8 size=160
    let mut pc: u32 = 0x82F672D8;
    'dispatch: loop {
        match pc {
            0x82F672D8 => {
    //   block [0x82F672D8..0x82F67378)
	// 82F672D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F672DC: 4BD42131  bl 0x82ca940c
	ctx.lr = 0x82F672E0;
	sub_82CA93D0(ctx, base);
	// 82F672E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F672E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F672E8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F672EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F672F0: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82F672F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F672F8: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F672FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67300: 4E800421  bctrl
	ctx.lr = 0x82F67304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67304: 3BC30078  addi r30, r3, 0x78
	ctx.r[30].s64 = ctx.r[3].s64 + 120;
	// 82F67308: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6730C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82F67310: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F67314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67318: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6731C: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F67320: 38AB0104  addi r5, r11, 0x104
	ctx.r[5].s64 = ctx.r[11].s64 + 260;
	// 82F67324: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82F67328: 4E800421  bctrl
	ctx.lr = 0x82F6732C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6732C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F67330: 4182002C  beq 0x82f6735c
	if ctx.cr[0].eq {
	pc = 0x82F6735C; continue 'dispatch;
	}
	// 82F67334: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F67338: 83BF0080  lwz r29, 0x80(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6733C: 3BFF0080  addi r31, r31, 0x80
	ctx.r[31].s64 = ctx.r[31].s64 + 128;
	// 82F67340: 4800A2C1  bl 0x82f71600
	ctx.lr = 0x82F67344;
	sub_82F71600(ctx, base);
	// 82F67344: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82F67348: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82F6734C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67350: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67358: 4E800421  bctrl
	ctx.lr = 0x82F6735C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6735C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F67360: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F67364: 4198000C  blt cr6, 0x82f67370
	if ctx.cr[6].lt {
	pc = 0x82F67370; continue 'dispatch;
	}
	// 82F67368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6736C: 4800AFB5  bl 0x82f72320
	ctx.lr = 0x82F67370;
	sub_82F72320(ctx, base);
	// 82F67370: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67374: 4BD420E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67378 size=120
    let mut pc: u32 = 0x82F67378;
    'dispatch: loop {
        match pc {
            0x82F67378 => {
    //   block [0x82F67378..0x82F673F0)
	// 82F67378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6737C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F67380: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F67384: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67388: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6738C: 897F009C  lbz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82F67390: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F67394: 41820014  beq 0x82f673a8
	if ctx.cr[0].eq {
	pc = 0x82F673A8; continue 'dispatch;
	}
	// 82F67398: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6739C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F673A0: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F673A4: 48000038  b 0x82f673dc
	pc = 0x82F673DC; continue 'dispatch;
	// 82F673A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F673AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F673B0: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82F673B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F673B8: 4E800421  bctrl
	ctx.lr = 0x82F673BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F673BC: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F673C0: 419A0018  beq cr6, 0x82f673d8
	if ctx.cr[6].eq {
	pc = 0x82F673D8; continue 'dispatch;
	}
	// 82F673C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F673C8: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 82F673CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F673D0: 4E800421  bctrl
	ctx.lr = 0x82F673D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F673D4: 48000008  b 0x82f673dc
	pc = 0x82F673DC; continue 'dispatch;
	// 82F673D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F673DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F673E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F673E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F673E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F673EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F673F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F673F0 size=24
    let mut pc: u32 = 0x82F673F0;
    'dispatch: loop {
        match pc {
            0x82F673F0 => {
    //   block [0x82F673F0..0x82F67408)
	// 82F673F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F673F4: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82F673F8: 90630004  stw r3, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82F673FC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F67400: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F67404: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F67408 size=28
    let mut pc: u32 = 0x82F67408;
    'dispatch: loop {
        match pc {
            0x82F67408 => {
    //   block [0x82F67408..0x82F67424)
	// 82F67408: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82F6740C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82F67410: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F67414: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67418: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6741C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67420: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F67428 size=120
    let mut pc: u32 = 0x82F67428;
    'dispatch: loop {
        match pc {
            0x82F67428 => {
    //   block [0x82F67428..0x82F674A0)
	// 82F67428: 3D805555  lis r12, 0x5555
	ctx.r[12].s64 = 1431633920;
	// 82F6742C: 546BF87E  srwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F67430: 618C5555  ori r12, r12, 0x5555
	ctx.r[12].u64 = ctx.r[12].u64 | 21845;
	// 82F67434: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	// 82F67438: 7C6A6038  and r10, r3, r12
	ctx.r[10].u64 = ctx.r[3].u64 & ctx.r[12].u64;
	// 82F6743C: 3D80D555  lis r12, -0x2aab
	ctx.r[12].s64 = -715849728;
	// 82F67440: 618C5555  ori r12, r12, 0x5555
	ctx.r[12].u64 = ctx.r[12].u64 | 21845;
	// 82F67444: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F67448: 3D80F333  lis r12, -0xccd
	ctx.r[12].s64 = -214761472;
	// 82F6744C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F67450: 618C3333  ori r12, r12, 0x3333
	ctx.r[12].u64 = ctx.r[12].u64 | 13107;
	// 82F67454: 556AF0BE  srwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F67458: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 82F6745C: 3D803333  lis r12, 0x3333
	ctx.r[12].s64 = 858980352;
	// 82F67460: 618C3333  ori r12, r12, 0x3333
	ctx.r[12].u64 = ctx.r[12].u64 | 13107;
	// 82F67464: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F67468: 3D80FF0F  lis r12, -0xf1
	ctx.r[12].s64 = -15794176;
	// 82F6746C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F67470: 618C0F0F  ori r12, r12, 0xf0f
	ctx.r[12].u64 = ctx.r[12].u64 | 3855;
	// 82F67474: 556AE13E  srwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F67478: 7D4A6038  and r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[12].u64;
	// 82F6747C: 3D800F0F  lis r12, 0xf0f
	ctx.r[12].s64 = 252641280;
	// 82F67480: 618C0F0F  ori r12, r12, 0xf0f
	ctx.r[12].u64 = ctx.r[12].u64 | 3855;
	// 82F67484: 7D6B6038  and r11, r11, r12
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F67488: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6748C: 7D4B4B96  divwu r10, r11, r9
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[9].u32;
	// 82F67490: 1D4A00FF  mulli r10, r10, 0xff
	ctx.r[10].s64 = ctx.r[10].s64 * 255;
	// 82F67494: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82F67498: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F6749C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F674A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F674A0 size=148
    let mut pc: u32 = 0x82F674A0;
    'dispatch: loop {
        match pc {
            0x82F674A0 => {
    //   block [0x82F674A0..0x82F67534)
	// 82F674A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F674A4: 4BD41F65  bl 0x82ca9408
	ctx.lr = 0x82F674A8;
	sub_82CA93D0(ctx, base);
	// 82F674A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F674AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F674B0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F674B4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82F674B8: 4BF96491  bl 0x82efd948
	ctx.lr = 0x82F674BC;
	sub_82EFD948(ctx, base);
	// 82F674BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F674C0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F674C4: 396B106C  addi r11, r11, 0x106c
	ctx.r[11].s64 = ctx.r[11].s64 + 4204;
	// 82F674C8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F674CC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F674D0: 39692870  addi r11, r9, 0x2870
	ctx.r[11].s64 = ctx.r[9].s64 + 10352;
	// 82F674D4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82F674D8: 394A27E0  addi r10, r10, 0x27e0
	ctx.r[10].s64 = ctx.r[10].s64 + 10208;
	// 82F674DC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F674E0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F674E4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F674E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F674EC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82F674F0: C0080C18  lfs f0, 0xc18(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F674F4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F674F8: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F674FC: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82F67500: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82F67504: B3DF0024  sth r30, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u16 ) };
	// 82F67508: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82F6750C: 480370FD  bl 0x82f9e608
	ctx.lr = 0x82F67510;
	sub_82F9E608(ctx, base);
	// 82F67510: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82F67514: 48005465  bl 0x82f6c978
	ctx.lr = 0x82F67518;
	sub_82F6C978(ctx, base);
	// 82F67518: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6751C: 9BDF0070  stb r30, 0x70(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u8 ) };
	// 82F67520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67524: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 82F67528: 997F0078  stb r11, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 82F6752C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67530: 4BD41F28  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F67538 size=8
    let mut pc: u32 = 0x82F67538;
    'dispatch: loop {
        match pc {
            0x82F67538 => {
    //   block [0x82F67538..0x82F67540)
	// 82F67538: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82F6753C: 48000D6C  b 0x82f682a8
	sub_82F682A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F67540 size=44
    let mut pc: u32 = 0x82F67540;
    'dispatch: loop {
        match pc {
            0x82F67540 => {
    //   block [0x82F67540..0x82F6756C)
	// 82F67540: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F67544: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F67548: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6754C: 396B27E0  addi r11, r11, 0x27e0
	ctx.r[11].s64 = ctx.r[11].s64 + 10208;
	// 82F67550: 394A2870  addi r10, r10, 0x2870
	ctx.r[10].s64 = ctx.r[10].s64 + 10352;
	// 82F67554: 3929106C  addi r9, r9, 0x106c
	ctx.r[9].s64 = ctx.r[9].s64 + 4204;
	// 82F67558: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6755C: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F67560: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82F67564: 91230010  stw r9, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F67568: 4BF964B0  b 0x82efda18
	sub_82EFDA18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67570 size=300
    let mut pc: u32 = 0x82F67570;
    'dispatch: loop {
        match pc {
            0x82F67570 => {
    //   block [0x82F67570..0x82F6769C)
	// 82F67570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67574: 4BD41E91  bl 0x82ca9404
	ctx.lr = 0x82F67578;
	sub_82CA93D0(ctx, base);
	// 82F67578: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6757C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67580: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67584: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F67588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6758C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82F67590: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67594: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82F67598: 3B9F000C  addi r28, r31, 0xc
	ctx.r[28].s64 = ctx.r[31].s64 + 12;
	// 82F6759C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F675A0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F675A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F675A8: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F675AC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F675B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F675B4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82F675B8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F675BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F675C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F675C4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F675C8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F675CC: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82F675D0: 4BF96999  bl 0x82efdf68
	ctx.lr = 0x82F675D4;
	sub_82EFDF68(ctx, base);
	// 82F675D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82F675D8: 419A0020  beq cr6, 0x82f675f8
	if ctx.cr[6].eq {
	pc = 0x82F675F8; continue 'dispatch;
	}
	// 82F675DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F675E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F675E4: 4BFFFA3D  bl 0x82f67020
	ctx.lr = 0x82F675E8;
	sub_82F67020(ctx, base);
	// 82F675E8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82F675EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F675F0: 388B230C  addi r4, r11, 0x230c
	ctx.r[4].s64 = ctx.r[11].s64 + 8972;
	// 82F675F4: 4BF9738D  bl 0x82efe980
	ctx.lr = 0x82F675F8;
	sub_82EFE980(ctx, base);
	// 82F675F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F675FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F67600: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67604: 4BF9737D  bl 0x82efe980
	ctx.lr = 0x82F67608;
	sub_82EFE980(ctx, base);
	// 82F67608: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6760C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F67610: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82F67614: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67618: 4BFA3689  bl 0x82f0aca0
	ctx.lr = 0x82F6761C;
	sub_82F0ACA0(ctx, base);
	// 82F6761C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F67620: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F67624: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67628: 4BFAAE99  bl 0x82f124c0
	ctx.lr = 0x82F6762C;
	sub_82F124C0(ctx, base);
	// 82F6762C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F67630: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F67634: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F67638: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6763C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F67640: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F67644: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F67648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6764C: 409A0008  bne cr6, 0x82f67654
	if !ctx.cr[6].eq {
	pc = 0x82F67654; continue 'dispatch;
	}
	// 82F67650: 48006439  bl 0x82f6da88
	ctx.lr = 0x82F67654;
	sub_82F6DA88(ctx, base);
	// 82F67654: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F67658: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82F6765C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F67660: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F67664: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82F67668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6766C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F67670: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82F67674: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F67678: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6767C: 4082FFE8  bne 0x82f67664
	if !ctx.cr[0].eq {
	pc = 0x82F67664; continue 'dispatch;
	}
	// 82F67680: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F67684: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F67688: 40820008  bne 0x82f67690
	if !ctx.cr[0].eq {
	pc = 0x82F67690; continue 'dispatch;
	}
	// 82F6768C: 4BF96215  bl 0x82efd8a0
	ctx.lr = 0x82F67690;
	sub_82EFD8A0(ctx, base);
	// 82F67690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67694: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F67698: 4BD41DBC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F676A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F676A0 size=244
    let mut pc: u32 = 0x82F676A0;
    'dispatch: loop {
        match pc {
            0x82F676A0 => {
    //   block [0x82F676A0..0x82F67794)
	// 82F676A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F676A4: 4BD41D65  bl 0x82ca9408
	ctx.lr = 0x82F676A8;
	sub_82CA93D0(ctx, base);
	// 82F676A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F676AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F676B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F676B4: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82F676B8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82F676BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F676C0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F676C4: 4BFAADFD  bl 0x82f124c0
	ctx.lr = 0x82F676C8;
	sub_82F124C0(ctx, base);
	// 82F676C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F676CC: 4BF9689D  bl 0x82efdf68
	ctx.lr = 0x82F676D0;
	sub_82EFDF68(ctx, base);
	// 82F676D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82F676D4: 419A0020  beq cr6, 0x82f676f4
	if ctx.cr[6].eq {
	pc = 0x82F676F4; continue 'dispatch;
	}
	// 82F676D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F676DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F676E0: 4BFFF941  bl 0x82f67020
	ctx.lr = 0x82F676E4;
	sub_82F67020(ctx, base);
	// 82F676E4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82F676E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F676EC: 388B230C  addi r4, r11, 0x230c
	ctx.r[4].s64 = ctx.r[11].s64 + 8972;
	// 82F676F0: 4BF97291  bl 0x82efe980
	ctx.lr = 0x82F676F4;
	sub_82EFE980(ctx, base);
	// 82F676F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F676F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F676FC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67700: 4BF97281  bl 0x82efe980
	ctx.lr = 0x82F67704;
	sub_82EFE980(ctx, base);
	// 82F67704: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67708: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6770C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82F67710: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67714: 4BFA358D  bl 0x82f0aca0
	ctx.lr = 0x82F67718;
	sub_82F0ACA0(ctx, base);
	// 82F67718: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F6771C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F67720: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67724: 4BFAAD9D  bl 0x82f124c0
	ctx.lr = 0x82F67728;
	sub_82F124C0(ctx, base);
	// 82F67728: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6772C: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F67730: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F67734: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F67738: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F6773C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F67740: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F67744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F67748: 409A0008  bne cr6, 0x82f67750
	if !ctx.cr[6].eq {
	pc = 0x82F67750; continue 'dispatch;
	}
	// 82F6774C: 4800633D  bl 0x82f6da88
	ctx.lr = 0x82F67750;
	sub_82F6DA88(ctx, base);
	// 82F67750: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F67754: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82F67758: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6775C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F67760: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82F67764: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F67768: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F6776C: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82F67770: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F67774: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F67778: 4082FFE8  bne 0x82f67760
	if !ctx.cr[0].eq {
	pc = 0x82F67760; continue 'dispatch;
	}
	// 82F6777C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F67780: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F67784: 40820008  bne 0x82f6778c
	if !ctx.cr[0].eq {
	pc = 0x82F6778C; continue 'dispatch;
	}
	// 82F67788: 4BF96119  bl 0x82efd8a0
	ctx.lr = 0x82F6778C;
	sub_82EFD8A0(ctx, base);
	// 82F6778C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67790: 4BD41CC8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67798 size=48
    let mut pc: u32 = 0x82F67798;
    'dispatch: loop {
        match pc {
            0x82F67798 => {
    //   block [0x82F67798..0x82F677C8)
	// 82F67798: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6779C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F677A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F677A4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F677A8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F677AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F677B0: 4E800421  bctrl
	ctx.lr = 0x82F677B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F677B4: 80630138  lwz r3, 0x138(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 82F677B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F677BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F677C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F677C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F677C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F677C8 size=212
    let mut pc: u32 = 0x82F677C8;
    'dispatch: loop {
        match pc {
            0x82F677C8 => {
    //   block [0x82F677C8..0x82F6789C)
	// 82F677C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F677CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F677D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F677D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F677D8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82F677DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F677E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F677E4: 808300AC  lwz r4, 0xac(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F677E8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F677EC: 409A0088  bne cr6, 0x82f67874
	if !ctx.cr[6].eq {
	pc = 0x82F67874; continue 'dispatch;
	}
	// 82F677F0: 3BE30050  addi r31, r3, 0x50
	ctx.r[31].s64 = ctx.r[3].s64 + 80;
	// 82F677F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F677F8: 48005559  bl 0x82f6cd50
	ctx.lr = 0x82F677FC;
	sub_82F6CD50(ctx, base);
	// 82F677FC: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82F67800: 7C00F7AE  stfiwx f0, 0, r30
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32, tmp.u32) };
	// 82F67804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67808: 48005551  bl 0x82f6cd58
	ctx.lr = 0x82F6780C;
	sub_82F6CD58(ctx, base);
	// 82F6780C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82F67810: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82F67814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67818: 7C1E5FAE  stfiwx f0, r30, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82F6781C: 48005545  bl 0x82f6cd60
	ctx.lr = 0x82F67820;
	sub_82F6CD60(ctx, base);
	// 82F67820: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F67824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67828: CBEB79B8  lfd f31, 0x79b8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31160 as u32) ) };
	// 82F6782C: FC0107F2  fmul f0, f1, f31
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 82F67830: D81E0008  stfd f0, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.f[0].u64 ) };
	// 82F67834: 48005545  bl 0x82f6cd78
	ctx.lr = 0x82F67838;
	sub_82F6CD78(ctx, base);
	// 82F67838: FC0107F2  fmul f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 82F6783C: D81E0010  stfd f0, 0x10(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.f[0].u64 ) };
	// 82F67840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67844: 4800554D  bl 0x82f6cd90
	ctx.lr = 0x82F67848;
	sub_82F6CD90(ctx, base);
	// 82F67848: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F6784C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F67850: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F67854: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 82F67858: C80B11E0  lfd f0, 0x11e0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4576 as u32) ) };
	// 82F6785C: FDA10032  fmul f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82F67860: C80A2878  lfd f0, 0x2878(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(10360 as u32) ) };
	// 82F67864: FC0D0032  fmul f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82F67868: D81E0018  stfd f0, 0x18(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.f[0].u64 ) };
	// 82F6786C: 48004F8D  bl 0x82f6c7f8
	ctx.lr = 0x82F67870;
	sub_82F6C7F8(ctx, base);
	// 82F67870: 4800000C  b 0x82f6787c
	pc = 0x82F6787C; continue 'dispatch;
	// 82F67874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67878: 4BFFF8F1  bl 0x82f67168
	ctx.lr = 0x82F6787C;
	sub_82F67168(ctx, base);
	// 82F6787C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67880: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F67884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F67888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6788C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82F67890: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F67894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F67898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F678A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F678A0 size=108
    let mut pc: u32 = 0x82F678A0;
    'dispatch: loop {
        match pc {
            0x82F678A0 => {
    //   block [0x82F678A0..0x82F6790C)
	// 82F678A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F678A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F678A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F678AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F678B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F678B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F678B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F678BC: 807E00AC  lwz r3, 0xac(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F678C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F678C4: 419A000C  beq cr6, 0x82f678d0
	if ctx.cr[6].eq {
	pc = 0x82F678D0; continue 'dispatch;
	}
	// 82F678C8: 4BFFF8A1  bl 0x82f67168
	ctx.lr = 0x82F678CC;
	sub_82F67168(ctx, base);
	// 82F678CC: 48000028  b 0x82f678f4
	pc = 0x82F678F4; continue 'dispatch;
	// 82F678D0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82F678D4: 4BF95F8D  bl 0x82efd860
	ctx.lr = 0x82F678D8;
	sub_82EFD860(ctx, base);
	// 82F678D8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F678DC: 41820010  beq 0x82f678ec
	if ctx.cr[0].eq {
	pc = 0x82F678EC; continue 'dispatch;
	}
	// 82F678E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F678E4: 4BFFF885  bl 0x82f67168
	ctx.lr = 0x82F678E8;
	sub_82F67168(ctx, base);
	// 82F678E8: 48000008  b 0x82f678f0
	pc = 0x82F678F0; continue 'dispatch;
	// 82F678EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F678F0: 907E00AC  stw r3, 0xac(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 82F678F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F678F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F678FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F67900: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F67904: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F67908: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67910 size=100
    let mut pc: u32 = 0x82F67910;
    'dispatch: loop {
        match pc {
            0x82F67910 => {
    //   block [0x82F67910..0x82F67974)
	// 82F67910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F67918: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6791C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F67920: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67928: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6792C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F67930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F67934: 409A0024  bne cr6, 0x82f67958
	if !ctx.cr[6].eq {
	pc = 0x82F67958; continue 'dispatch;
	}
	// 82F67938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6793C: 4BFAAD2D  bl 0x82f12668
	ctx.lr = 0x82F67940;
	sub_82F12668(ctx, base);
	// 82F67940: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F67944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67948: 4BFFFE81  bl 0x82f677c8
	ctx.lr = 0x82F6794C;
	sub_82F677C8(ctx, base);
	// 82F6794C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F67950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67954: 4BFFFF4D  bl 0x82f678a0
	ctx.lr = 0x82F67958;
	sub_82F678A0(ctx, base);
	// 82F67958: 9BDF0090  stb r30, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82F6795C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F67960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F67964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F67968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6796C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F67970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67978 size=136
    let mut pc: u32 = 0x82F67978;
    'dispatch: loop {
        match pc {
            0x82F67978 => {
    //   block [0x82F67978..0x82F67A00)
	// 82F67978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6797C: 4BD41A8D  bl 0x82ca9408
	ctx.lr = 0x82F67980;
	sub_82CA93D0(ctx, base);
	// 82F67980: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67984: 8163FF80  lwz r11, -0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67988: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6798C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67990: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F67994: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82F67998: 816B00BC  lwz r11, 0xbc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 82F6799C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F679A0: 4E800421  bctrl
	ctx.lr = 0x82F679A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F679A4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F679A8: 41820050  beq 0x82f679f8
	if ctx.cr[0].eq {
	pc = 0x82F679F8; continue 'dispatch;
	}
	// 82F679AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F679B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F679B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F679B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F679BC: 4E800421  bctrl
	ctx.lr = 0x82F679C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F679C0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F679C4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F679C8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F679CC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F679D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F679D4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82F679D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F679DC: 4E800421  bctrl
	ctx.lr = 0x82F679E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F679E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F679E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F679E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F679EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F679F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F679F4: 4E800421  bctrl
	ctx.lr = 0x82F679F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F679F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F679FC: 4BD41A5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67A00 size=152
    let mut pc: u32 = 0x82F67A00;
    'dispatch: loop {
        match pc {
            0x82F67A00 => {
    //   block [0x82F67A00..0x82F67A98)
	// 82F67A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67A04: 4BD41A05  bl 0x82ca9408
	ctx.lr = 0x82F67A08;
	sub_82CA93D0(ctx, base);
	// 82F67A08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67A0C: 8163FF80  lwz r11, -0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67A10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67A14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67A18: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F67A1C: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82F67A20: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F67A24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67A28: 4E800421  bctrl
	ctx.lr = 0x82F67A2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67A2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F67A30: 4182005C  beq 0x82f67a8c
	if ctx.cr[0].eq {
	pc = 0x82F67A8C; continue 'dispatch;
	}
	// 82F67A34: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67A3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67A44: 4E800421  bctrl
	ctx.lr = 0x82F67A48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67A48: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67A4C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F67A50: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F67A54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F67A58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67A5C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F67A60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67A64: 4E800421  bctrl
	ctx.lr = 0x82F67A68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67A68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67A6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F67A70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67A78: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67A7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67A80: 4E800421  bctrl
	ctx.lr = 0x82F67A84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67A88: 48000008  b 0x82f67a90
	pc = 0x82F67A90; continue 'dispatch;
	// 82F67A8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F67A90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67A94: 4BD419C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67A98 size=160
    let mut pc: u32 = 0x82F67A98;
    'dispatch: loop {
        match pc {
            0x82F67A98 => {
    //   block [0x82F67A98..0x82F67B38)
	// 82F67A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67A9C: 4BD4196D  bl 0x82ca9408
	ctx.lr = 0x82F67AA0;
	sub_82CA93D0(ctx, base);
	// 82F67AA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67AA4: 8163FF80  lwz r11, -0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67AA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67AAC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67AB0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F67AB4: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82F67AB8: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F67ABC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67AC0: 4E800421  bctrl
	ctx.lr = 0x82F67AC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67AC4: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F67AC8: 41820040  beq 0x82f67b08
	if ctx.cr[0].eq {
	pc = 0x82F67B08; continue 'dispatch;
	}
	// 82F67ACC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67AD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67AD4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67AD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67ADC: 4E800421  bctrl
	ctx.lr = 0x82F67AE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67AE0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67AE4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F67AE8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F67AEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F67AF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67AF4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F67AF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67AFC: 4E800421  bctrl
	ctx.lr = 0x82F67B00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67B00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F67B04: 48000008  b 0x82f67b0c
	pc = 0x82F67B0C; continue 'dispatch;
	// 82F67B08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F67B0C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F67B10: 419A001C  beq cr6, 0x82f67b2c
	if ctx.cr[6].eq {
	pc = 0x82F67B2C; continue 'dispatch;
	}
	// 82F67B14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67B18: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67B20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67B24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67B28: 4E800421  bctrl
	ctx.lr = 0x82F67B2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67B2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67B30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67B34: 4BD41924  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67B38 size=196
    let mut pc: u32 = 0x82F67B38;
    'dispatch: loop {
        match pc {
            0x82F67B38 => {
    //   block [0x82F67B38..0x82F67BFC)
	// 82F67B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67B3C: 4BD418CD  bl 0x82ca9408
	ctx.lr = 0x82F67B40;
	sub_82CA93D0(ctx, base);
	// 82F67B40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67B44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F67B48: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82F67B4C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F67B50: 387DFF80  addi r3, r29, -0x80
	ctx.r[3].s64 = ctx.r[29].s64 + -128;
	// 82F67B54: 817DFF80  lwz r11, -0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67B58: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F67B5C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67B60: 4E800421  bctrl
	ctx.lr = 0x82F67B64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67B64: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F67B68: 4182008C  beq 0x82f67bf4
	if ctx.cr[0].eq {
	pc = 0x82F67BF4; continue 'dispatch;
	}
	// 82F67B6C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67B74: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67B7C: 4E800421  bctrl
	ctx.lr = 0x82F67B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67B80: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67B84: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F67B88: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F67B8C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82F67B90: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82F67B94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67B98: 4E800421  bctrl
	ctx.lr = 0x82F67B9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67B9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F67BA0: 419A0018  beq cr6, 0x82f67bb8
	if ctx.cr[6].eq {
	pc = 0x82F67BB8; continue 'dispatch;
	}
	// 82F67BA4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67BA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67BAC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67BB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67BB4: 4E800421  bctrl
	ctx.lr = 0x82F67BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67BB8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F67BC0: 419A0018  beq cr6, 0x82f67bd8
	if ctx.cr[6].eq {
	pc = 0x82F67BD8; continue 'dispatch;
	}
	// 82F67BC4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67BC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67BCC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67BD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67BD4: 4E800421  bctrl
	ctx.lr = 0x82F67BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67BD8: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82F67BDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67BE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67BE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67BF0: 4E800421  bctrl
	ctx.lr = 0x82F67BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67BF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67BF8: 4BD41860  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67C00 size=160
    let mut pc: u32 = 0x82F67C00;
    'dispatch: loop {
        match pc {
            0x82F67C00 => {
    //   block [0x82F67C00..0x82F67CA0)
	// 82F67C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67C04: 4BD41805  bl 0x82ca9408
	ctx.lr = 0x82F67C08;
	sub_82CA93D0(ctx, base);
	// 82F67C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67C0C: 8163FF80  lwz r11, -0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67C10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67C14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67C18: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F67C1C: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82F67C20: 816B00BC  lwz r11, 0xbc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(188 as u32) ) } as u64;
	// 82F67C24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67C28: 4E800421  bctrl
	ctx.lr = 0x82F67C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67C2C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F67C30: 41820040  beq 0x82f67c70
	if ctx.cr[0].eq {
	pc = 0x82F67C70; continue 'dispatch;
	}
	// 82F67C34: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67C38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67C3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67C40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67C44: 4E800421  bctrl
	ctx.lr = 0x82F67C48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67C48: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67C4C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F67C50: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F67C54: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F67C58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67C5C: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82F67C60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67C64: 4E800421  bctrl
	ctx.lr = 0x82F67C68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67C68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F67C6C: 48000008  b 0x82f67c74
	pc = 0x82F67C74; continue 'dispatch;
	// 82F67C70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F67C74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F67C78: 419A001C  beq cr6, 0x82f67c94
	if ctx.cr[6].eq {
	pc = 0x82F67C94; continue 'dispatch;
	}
	// 82F67C7C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67C80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67C88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67C8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67C90: 4E800421  bctrl
	ctx.lr = 0x82F67C94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67C94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67C98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67C9C: 4BD417BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67CA0 size=168
    let mut pc: u32 = 0x82F67CA0;
    'dispatch: loop {
        match pc {
            0x82F67CA0 => {
    //   block [0x82F67CA0..0x82F67D48)
	// 82F67CA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67CA4: 4BD41761  bl 0x82ca9404
	ctx.lr = 0x82F67CA8;
	sub_82CA93D0(ctx, base);
	// 82F67CA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67CAC: 8163FF80  lwz r11, -0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67CB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67CB4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67CB8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F67CBC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82F67CC0: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82F67CC4: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F67CC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67CCC: 4E800421  bctrl
	ctx.lr = 0x82F67CD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67CD0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F67CD4: 41820044  beq 0x82f67d18
	if ctx.cr[0].eq {
	pc = 0x82F67D18; continue 'dispatch;
	}
	// 82F67CD8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67CDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67CE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67CE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67CE8: 4E800421  bctrl
	ctx.lr = 0x82F67CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67CEC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67CF0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F67CF4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82F67CF8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F67CFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F67D00: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F67D04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67D08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67D0C: 4E800421  bctrl
	ctx.lr = 0x82F67D10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67D10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F67D14: 48000008  b 0x82f67d1c
	pc = 0x82F67D1C; continue 'dispatch;
	// 82F67D18: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F67D1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F67D20: 419A001C  beq cr6, 0x82f67d3c
	if ctx.cr[6].eq {
	pc = 0x82F67D3C; continue 'dispatch;
	}
	// 82F67D24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67D28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67D30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67D34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67D38: 4E800421  bctrl
	ctx.lr = 0x82F67D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67D40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F67D44: 4BD41710  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67D48 size=152
    let mut pc: u32 = 0x82F67D48;
    'dispatch: loop {
        match pc {
            0x82F67D48 => {
    //   block [0x82F67D48..0x82F67DE0)
	// 82F67D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67D4C: 4BD416C1  bl 0x82ca940c
	ctx.lr = 0x82F67D50;
	sub_82CA93D0(ctx, base);
	// 82F67D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67D54: 8163FF80  lwz r11, -0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F67D58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67D5C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67D60: 3863FF80  addi r3, r3, -0x80
	ctx.r[3].s64 = ctx.r[3].s64 + -128;
	// 82F67D64: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F67D68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67D6C: 4E800421  bctrl
	ctx.lr = 0x82F67D70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67D70: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F67D74: 4182003C  beq 0x82f67db0
	if ctx.cr[0].eq {
	pc = 0x82F67DB0; continue 'dispatch;
	}
	// 82F67D78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67D7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67D80: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67D84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67D88: 4E800421  bctrl
	ctx.lr = 0x82F67D8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67D8C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67D90: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F67D94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F67D98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F67D9C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F67DA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67DA4: 4E800421  bctrl
	ctx.lr = 0x82F67DA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67DA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F67DAC: 48000008  b 0x82f67db4
	pc = 0x82F67DB4; continue 'dispatch;
	// 82F67DB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F67DB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F67DB8: 419A001C  beq cr6, 0x82f67dd4
	if ctx.cr[6].eq {
	pc = 0x82F67DD4; continue 'dispatch;
	}
	// 82F67DBC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67DC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F67DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67DC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F67DCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67DD0: 4E800421  bctrl
	ctx.lr = 0x82F67DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67DD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F67DD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F67DDC: 4BD41680  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F67DE0 size=204
    let mut pc: u32 = 0x82F67DE0;
    'dispatch: loop {
        match pc {
            0x82F67DE0 => {
    //   block [0x82F67DE0..0x82F67EAC)
	// 82F67DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67DE4: 4BD41629  bl 0x82ca940c
	ctx.lr = 0x82F67DE8;
	sub_82CA93D0(ctx, base);
	// 82F67DE8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67DEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67DF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F67DF4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F67DF8: 897F0078  lbz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F67DFC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F67E00: 41820054  beq 0x82f67e54
	if ctx.cr[0].eq {
	pc = 0x82F67E54; continue 'dispatch;
	}
	// 82F67E04: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82F67E08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F67E0C: 480049ED  bl 0x82f6c7f8
	ctx.lr = 0x82F67E10;
	sub_82F6C7F8(ctx, base);
	// 82F67E10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F67E14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F67E18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F67E1C: 48004FB5  bl 0x82f6cdd0
	ctx.lr = 0x82F67E20;
	sub_82F6CDD0(ctx, base);
	// 82F67E20: A17F0024  lhz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F67E24: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F67E28: 4082002C  bne 0x82f67e54
	if !ctx.cr[0].eq {
	pc = 0x82F67E54; continue 'dispatch;
	}
	// 82F67E2C: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82F67E30: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82F67E34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82F67E38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F67E3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F67E40: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F67E44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67E48: 4E800421  bctrl
	ctx.lr = 0x82F67E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67E4C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F67E50: 40820044  bne 0x82f67e94
	if !ctx.cr[0].eq {
	pc = 0x82F67E94; continue 'dispatch;
	}
	// 82F67E54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F67E58: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F67E5C: 4BD41600  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82F67E60: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F67E64: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F67E68: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F67E6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F67E70: 4E800421  bctrl
	ctx.lr = 0x82F67E74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F67E74: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82F67E78: 409AFFDC  bne cr6, 0x82f67e54
	if !ctx.cr[6].eq {
	pc = 0x82F67E54; continue 'dispatch;
	}
	// 82F67E7C: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F67E80: 40820024  bne 0x82f67ea4
	if !ctx.cr[0].eq {
	pc = 0x82F67EA4; continue 'dispatch;
	}
	// 82F67E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67E88: 4BFEF2D9  bl 0x82f57160
	ctx.lr = 0x82F67E8C;
	sub_82F57160(ctx, base);
	// 82F67E8C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F67E90: 40820014  bne 0x82f67ea4
	if !ctx.cr[0].eq {
	pc = 0x82F67EA4; continue 'dispatch;
	}
	// 82F67E94: 83FF0028  lwz r31, 0x28(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F67E98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F67E9C: 409AFFC4  bne cr6, 0x82f67e60
	if !ctx.cr[6].eq {
	pc = 0x82F67E60; continue 'dispatch;
	}
	// 82F67EA0: 4BFFFFB4  b 0x82f67e54
	pc = 0x82F67E54; continue 'dispatch;
	// 82F67EA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F67EA8: 4BFFFFB0  b 0x82f67e58
	pc = 0x82F67E58; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F67EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F67EB0 size=352
    let mut pc: u32 = 0x82F67EB0;
    'dispatch: loop {
        match pc {
            0x82F67EB0 => {
    //   block [0x82F67EB0..0x82F68010)
	// 82F67EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F67EB4: 4BD41559  bl 0x82ca940c
	ctx.lr = 0x82F67EB8;
	sub_82CA93D0(ctx, base);
	// 82F67EB8: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F67EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F67EC0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F67EC4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F67EC8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F67ECC: 48004AAD  bl 0x82f6c978
	ctx.lr = 0x82F67ED0;
	sub_82F6C978(ctx, base);
	// 82F67ED0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F67ED4: 48036735  bl 0x82f9e608
	ctx.lr = 0x82F67ED8;
	sub_82F9E608(ctx, base);
	// 82F67ED8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82F67EDC: 395F0050  addi r10, r31, 0x50
	ctx.r[10].s64 = ctx.r[31].s64 + 80;
	// 82F67EE0: 13E0F0C7  vcmpequd (lvx128) v31, v0, v30
	tmp.u32 = ctx.r[30].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F68010 size=24
    let mut pc: u32 = 0x82F68010;
    'dispatch: loop {
        match pc {
            0x82F68010 => {
    //   block [0x82F68010..0x82F68028)
	// 82F68010: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68014: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68018: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6801C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68020: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F68024: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F68028 size=24
    let mut pc: u32 = 0x82F68028;
    'dispatch: loop {
        match pc {
            0x82F68028 => {
    //   block [0x82F68028..0x82F68040)
	// 82F68028: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6802C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F68030: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68034: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68038: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82F6803C: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F68040 size=28
    let mut pc: u32 = 0x82F68040;
    'dispatch: loop {
        match pc {
            0x82F68040 => {
    //   block [0x82F68040..0x82F6805C)
	// 82F68040: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68044: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68048: 1D2A001C  mulli r9, r10, 0x1c
	ctx.r[9].s64 = ctx.r[10].s64 * 28;
	// 82F6804C: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82F68050: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F68054: 2F09FFFE  cmpwi cr6, r9, -2
	ctx.cr[6].compare_i32(ctx.r[9].s32, -2, &mut ctx.xer);
	// 82F68058: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6805C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6805C size=36
    let mut pc: u32 = 0x82F6805C;
    'dispatch: loop {
        match pc {
            0x82F6805C => {
    //   block [0x82F6805C..0x82F68080)
	// 82F6805C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F68060: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F68064: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68068: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6806C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68070: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68074: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F68078: 4099FFC8  ble cr6, 0x82f68040
	if !ctx.cr[6].gt {
		sub_82F68040(ctx, base);
		return;
	}
	// 82F6807C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F68080 size=248
    let mut pc: u32 = 0x82F68080;
    'dispatch: loop {
        match pc {
            0x82F68080 => {
    //   block [0x82F68080..0x82F68178)
	// 82F68080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F68084: 4BD41379  bl 0x82ca93fc
	ctx.lr = 0x82F68088;
	sub_82CA93D0(ctx, base);
	// 82F68088: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6808C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F68090: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68094: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82F68098: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s64 = ctx.r[29].s64 * 28;
	// 82F6809C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82F680A0: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82F680A4: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F680A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F680AC: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F680B0: 419A00BC  beq cr6, 0x82f6816c
	if ctx.cr[6].eq {
	pc = 0x82F6816C; continue 'dispatch;
	}
	// 82F680B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F680B8: 3F400002  lis r26, 2
	ctx.r[26].s64 = 131072;
	// 82F680BC: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F680C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F680C4: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F680C8: 41980010  blt cr6, 0x82f680d8
	if ctx.cr[6].lt {
	pc = 0x82F680D8; continue 'dispatch;
	}
	// 82F680CC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82F680D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F680D4: 40990008  ble cr6, 0x82f680dc
	if !ctx.cr[6].gt {
	pc = 0x82F680DC; continue 'dispatch;
	}
	// 82F680D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F680DC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F680E0: 4182000C  beq 0x82f680ec
	if ctx.cr[0].eq {
	pc = 0x82F680EC; continue 'dispatch;
	}
	// 82F680E4: A97F000C  lha r11, 0xc(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as i16) as i64;
	// 82F680E8: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F680EC: 7D4BE038  and r11, r10, r28
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[28].u64;
	// 82F680F0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82F680F4: 409A0078  bne cr6, 0x82f6816c
	if !ctx.cr[6].eq {
	pc = 0x82F6816C; continue 'dispatch;
	}
	// 82F680F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F680FC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F68100: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F68104: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F68108: 41980010  blt cr6, 0x82f68118
	if ctx.cr[6].lt {
	pc = 0x82F68118; continue 'dispatch;
	}
	// 82F6810C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82F68110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68114: 40990008  ble cr6, 0x82f6811c
	if !ctx.cr[6].gt {
	pc = 0x82F6811C; continue 'dispatch;
	}
	// 82F68118: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6811C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68120: 4182000C  beq 0x82f6812c
	if ctx.cr[0].eq {
	pc = 0x82F6812C; continue 'dispatch;
	}
	// 82F68124: A9630008  lha r11, 8(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F68128: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F6812C: 7D4BE038  and r11, r10, r28
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[28].u64;
	// 82F68130: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82F68134: 409A0014  bne cr6, 0x82f68148
	if !ctx.cr[6].eq {
	pc = 0x82F68148; continue 'dispatch;
	}
	// 82F68138: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82F6813C: 4BFEAF15  bl 0x82f53050
	ctx.lr = 0x82F68140;
	sub_82F53050(ctx, base);
	// 82F68140: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68144: 40820020  bne 0x82f68164
	if !ctx.cr[0].eq {
	pc = 0x82F68164; continue 'dispatch;
	}
	// 82F68148: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6814C: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 82F68150: 419A001C  beq cr6, 0x82f6816c
	if ctx.cr[6].eq {
	pc = 0x82F6816C; continue 'dispatch;
	}
	// 82F68154: 1D7B001C  mulli r11, r27, 0x1c
	ctx.r[11].s64 = ctx.r[27].s64 * 28;
	// 82F68158: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82F6815C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F68160: 4BFFFF98  b 0x82f680f8
	pc = 0x82F680F8; continue 'dispatch;
	// 82F68164: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F68168: 48000008  b 0x82f68170
	pc = 0x82F68170; continue 'dispatch;
	// 82F6816C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F68170: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F68174: 4BD412D8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F68178 size=88
    let mut pc: u32 = 0x82F68178;
    'dispatch: loop {
        match pc {
            0x82F68178 => {
    //   block [0x82F68178..0x82F681D0)
	// 82F68178: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6817C: 1D65000C  mulli r11, r5, 0xc
	ctx.r[11].s64 = ctx.r[5].s64 * 12;
	// 82F68180: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F68184: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82F68188: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6818C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68190: 2F09FFFE  cmpwi cr6, r9, -2
	ctx.cr[6].compare_i32(ctx.r[9].s32, -2, &mut ctx.xer);
	// 82F68194: 419A0058  beq cr6, 0x82f681ec
	if ctx.cr[6].eq {
		sub_82F681EC(ctx, base);
		return;
	}
	// 82F68198: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6819C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F681A0: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F681A4: 7D294038  and r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 82F681A8: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82F681AC: 409A0040  bne cr6, 0x82f681ec
	if !ctx.cr[6].eq {
		sub_82F681EC(ctx, base);
		return;
	}
	// 82F681B0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F681B4: 80E90010  lwz r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F681B8: 7CE74038  and r7, r7, r8
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82F681BC: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82F681C0: 409A0010  bne cr6, 0x82f681d0
	if !ctx.cr[6].eq {
		sub_82F681D0(ctx, base);
		return;
	}
	// 82F681C4: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F681C8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82F681CC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F681D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F681D0 size=28
    let mut pc: u32 = 0x82F681D0;
    'dispatch: loop {
        match pc {
            0x82F681D0 => {
    //   block [0x82F681D0..0x82F681EC)
	// 82F681D0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F681D4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82F681D8: 419A0014  beq cr6, 0x82f681ec
	if ctx.cr[6].eq {
		sub_82F681EC(ctx, base);
		return;
	}
	// 82F681DC: 1D63000C  mulli r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 * 12;
	// 82F681E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F681E4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F681E8: 4BFFFFC8  b 0x82f681b0
	sub_82F68178(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F681EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F681EC size=8
    let mut pc: u32 = 0x82F681EC;
    'dispatch: loop {
        match pc {
            0x82F681EC => {
    //   block [0x82F681EC..0x82F681F4)
	// 82F681EC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F681F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F681F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F681F8 size=176
    let mut pc: u32 = 0x82F681F8;
    'dispatch: loop {
        match pc {
            0x82F681F8 => {
    //   block [0x82F681F8..0x82F682A8)
	// 82F681F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F681FC: 4BD41209  bl 0x82ca9404
	ctx.lr = 0x82F68200;
	sub_82CA93D0(ctx, base);
	// 82F68200: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F68204: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F68208: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6820C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F68210: 1D5E000C  mulli r10, r30, 0xc
	ctx.r[10].s64 = ctx.r[30].s64 * 12;
	// 82F68214: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68218: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6821C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82F68220: 3BEA0008  addi r31, r10, 8
	ctx.r[31].s64 = ctx.r[10].s64 + 8;
	// 82F68224: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F68228: 2F0AFFFE  cmpwi cr6, r10, -2
	ctx.cr[6].compare_i32(ctx.r[10].s32, -2, &mut ctx.xer);
	// 82F6822C: 419A0070  beq cr6, 0x82f6829c
	if ctx.cr[6].eq {
	pc = 0x82F6829C; continue 'dispatch;
	}
	// 82F68230: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68234: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68238: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6823C: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82F68240: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F68244: 409A0058  bne cr6, 0x82f6829c
	if !ctx.cr[6].eq {
	pc = 0x82F6829C; continue 'dispatch;
	}
	// 82F68248: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6824C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82F68250: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F68254: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F68258: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82F6825C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F68260: 409A0014  bne cr6, 0x82f68274
	if !ctx.cr[6].eq {
	pc = 0x82F68274; continue 'dispatch;
	}
	// 82F68264: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68268: 4BFAFC11  bl 0x82f17e78
	ctx.lr = 0x82F6826C;
	sub_82F17E78(ctx, base);
	// 82F6826C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68270: 40820024  bne 0x82f68294
	if !ctx.cr[0].eq {
	pc = 0x82F68294; continue 'dispatch;
	}
	// 82F68274: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68278: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82F6827C: 419A0020  beq cr6, 0x82f6829c
	if ctx.cr[6].eq {
	pc = 0x82F6829C; continue 'dispatch;
	}
	// 82F68280: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68284: 1D5C000C  mulli r10, r28, 0xc
	ctx.r[10].s64 = ctx.r[28].s64 * 12;
	// 82F68288: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6828C: 3BEA0008  addi r31, r10, 8
	ctx.r[31].s64 = ctx.r[10].s64 + 8;
	// 82F68290: 4BFFFFB8  b 0x82f68248
	pc = 0x82F68248; continue 'dispatch;
	// 82F68294: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F68298: 48000008  b 0x82f682a0
	pc = 0x82F682A0; continue 'dispatch;
	// 82F6829C: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F682A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F682A4: 4BD411B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F682A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F682A8 size=116
    let mut pc: u32 = 0x82F682A8;
    'dispatch: loop {
        match pc {
            0x82F682A8 => {
    //   block [0x82F682A8..0x82F6831C)
	// 82F682A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F682AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F682B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F682B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F682B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F682BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F682C0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F682C4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F682C8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F682CC: 396B27E0  addi r11, r11, 0x27e0
	ctx.r[11].s64 = ctx.r[11].s64 + 10208;
	// 82F682D0: 394A2870  addi r10, r10, 0x2870
	ctx.r[10].s64 = ctx.r[10].s64 + 10352;
	// 82F682D4: 3929106C  addi r9, r9, 0x106c
	ctx.r[9].s64 = ctx.r[9].s64 + 4204;
	// 82F682D8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F682DC: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F682E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F682E4: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F682E8: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82F682EC: 4BF9572D  bl 0x82efda18
	ctx.lr = 0x82F682F0;
	sub_82EFDA18(ctx, base);
	// 82F682F0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F682F4: 4182000C  beq 0x82f68300
	if ctx.cr[0].eq {
	pc = 0x82F68300; continue 'dispatch;
	}
	// 82F682F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F682FC: 4BF955A5  bl 0x82efd8a0
	ctx.lr = 0x82F68300;
	sub_82EFD8A0(ctx, base);
	// 82F68300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F68304: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F68308: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6830C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F68310: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F68314: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F68318: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F68320 size=48
    let mut pc: u32 = 0x82F68320;
    'dispatch: loop {
        match pc {
            0x82F68320 => {
    //   block [0x82F68320..0x82F68350)
	// 82F68320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F68324: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F68328: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6832C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68330: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F68334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68338: 4E800421  bctrl
	ctx.lr = 0x82F6833C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6833C: 4BFB40F5  bl 0x82f1c430
	ctx.lr = 0x82F68340;
	sub_82F1C430(ctx, base);
	// 82F68340: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F68344: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F68348: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6834C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F68350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F68350 size=4068
    let mut pc: u32 = 0x82F68350;
    'dispatch: loop {
        match pc {
            0x82F68350 => {
    //   block [0x82F68350..0x82F69334)
	// 82F68350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F68354: 4BD410B9  bl 0x82ca940c
	ctx.lr = 0x82F68358;
	sub_82CA93D0(ctx, base);
	// 82F68358: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82F6835C: 4BD45979  bl 0x82cadcd4
	ctx.lr = 0x82F68360;
	sub_82CADCA0(ctx, base);
	// 82F68360: 9421FDA0  stwu r1, -0x260(r1)
	ea = ctx.r[1].u32.wrapping_add(-608 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F68364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F68368: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6836C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F68370: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68374: 4182003C  beq 0x82f683b0
	if ctx.cr[0].eq {
	pc = 0x82F683B0; continue 'dispatch;
	}
	// 82F68378: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F6837C: 4198000C  blt cr6, 0x82f68388
	if ctx.cr[6].lt {
	pc = 0x82F68388; continue 'dispatch;
	}
	// 82F68380: 2F1D0015  cmpwi cr6, r29, 0x15
	ctx.cr[6].compare_i32(ctx.r[29].s32, 21, &mut ctx.xer);
	// 82F68384: 4099002C  ble cr6, 0x82f683b0
	if !ctx.cr[6].gt {
	pc = 0x82F683B0; continue 'dispatch;
	}
	// 82F68388: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6838C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F68390: 388B2948  addi r4, r11, 0x2948
	ctx.r[4].s64 = ctx.r[11].s64 + 10568;
	// 82F68394: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F68398: 4BFEDBE9  bl 0x82f55f80
	ctx.lr = 0x82F6839C;
	sub_82F55F80(ctx, base);
	// 82F6839C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F683A0: 38210260  addi r1, r1, 0x260
	ctx.r[1].s64 = ctx.r[1].s64 + 608;
	// 82F683A4: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82F683A8: 4BD45979  bl 0x82cadd20
	ctx.lr = 0x82F683AC;
	sub_82CADCEC(ctx, base);
	// 82F683AC: 4BD410B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82F683B0: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82F683B4: 419AFFE8  beq cr6, 0x82f6839c
	if ctx.cr[6].eq {
	pc = 0x82F6839C; continue 'dispatch;
	}
	// 82F683B8: 2F1D001F  cmpwi cr6, r29, 0x1f
	ctx.cr[6].compare_i32(ctx.r[29].s32, 31, &mut ctx.xer);
	// 82F683BC: 4199FFE0  bgt cr6, 0x82f6839c
	if ctx.cr[6].gt {
	pc = 0x82F6839C; continue 'dispatch;
	}
	// 82F683C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F683C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F683C8: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 82F683CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F683D0: 4E800421  bctrl
	ctx.lr = 0x82F683D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F683D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F683D8: 7D6BE830  slw r11, r11, r29
	if (ctx.r[29].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[29].u8 & 0x1F) as u32)) as u64;
	}
	// 82F683DC: 7C6B5839  and. r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F683E0: 4182FFBC  beq 0x82f6839c
	if ctx.cr[0].eq {
	pc = 0x82F6839C; continue 'dispatch;
	}
	// 82F683E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F683E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F683EC: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F683F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F683F4: 4E800421  bctrl
	ctx.lr = 0x82F683F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F683F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F683FC: 2B1D001F  cmplwi cr6, r29, 0x1f
	ctx.cr[6].compare_u32(ctx.r[29].u32, 31 as u32, &mut ctx.xer);
	// 82F68400: 4199FF9C  bgt cr6, 0x82f6839c
	if ctx.cr[6].gt {
	pc = 0x82F6839C; continue 'dispatch;
	}
	// 82F68404: 3D808204  lis r12, -0x7dfc
	ctx.r[12].s64 = -2113667072;
	// 82F68408: 398C2880  addi r12, r12, 0x2880
	ctx.r[12].s64 = ctx.r[12].s64 + 10368;
	// 82F6840C: 57A0083C  slwi r0, r29, 1
	ctx.r[0].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82F68410: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82F68414: 3D8082F7  lis r12, -0x7d09
	ctx.r[12].s64 = -2097741824;
	// 82F68418: 398C839C  addi r12, r12, -0x7c64
	ctx.r[12].s64 = ctx.r[12].s64 + -31844;
	// 82F6841C: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82F68420: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82F68424: 60000000  nop
	// 82F68428: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82F6842C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F68430: 480098D1  bl 0x82f71d00
	ctx.lr = 0x82F68434;
	sub_82F71D00(ctx, base);
	// 82F68434: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68438: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F6843C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F68440: 41820100  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68444: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F68448: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F6844C: 394007FF  li r10, 0x7ff
	ctx.r[10].s64 = 2047;
	// 82F68450: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68454: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68458: 794AA2C6  sldi r10, r10, 0x34
	ctx.r[10].u64 = ctx.r[10].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F6845C: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F68460: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68464: 409A0014  bne cr6, 0x82f68478
	if !ctx.cr[6].eq {
	pc = 0x82F68478; continue 'dispatch;
	}
	// 82F68468: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F6846C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F68470: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68474: 409A0008  bne cr6, 0x82f6847c
	if !ctx.cr[6].eq {
	pc = 0x82F6847C; continue 'dispatch;
	}
	// 82F68478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6847C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68480: 408200C0  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68484: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F68488: 39600FFF  li r11, 0xfff
	ctx.r[11].s64 = 4095;
	// 82F6848C: 796BA2C6  sldi r11, r11, 0x34
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 82F68490: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68494: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82F68498: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6849C: 419A0008  beq cr6, 0x82f684a4
	if ctx.cr[6].eq {
	pc = 0x82F684A4; continue 'dispatch;
	}
	// 82F684A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F684A4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F684A8: 40820024  bne 0x82f684cc
	if !ctx.cr[0].eq {
	pc = 0x82F684CC; continue 'dispatch;
	}
	// 82F684AC: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F684B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F684B4: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F684B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F684BC: 419A0008  beq cr6, 0x82f684c4
	if ctx.cr[6].eq {
	pc = 0x82F684C4; continue 'dispatch;
	}
	// 82F684C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F684C4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F684C8: 4182000C  beq 0x82f684d4
	if ctx.cr[0].eq {
	pc = 0x82F684D4; continue 'dispatch;
	}
	// 82F684CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F684D0: CBEB0D38  lfd f31, 0xd38(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82F684D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F684D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F684DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F684E0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F684E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F684E8: 4E800421  bctrl
	ctx.lr = 0x82F684EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F684EC: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F684F0: 38610170  addi r3, r1, 0x170
	ctx.r[3].s64 = ctx.r[1].s64 + 368;
	// 82F684F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F684F8: 48004301  bl 0x82f6c7f8
	ctx.lr = 0x82F684FC;
	sub_82F6C7F8(ctx, base);
	// 82F684FC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F68500: C80B1228  lfd f0, 0x1228(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4648 as u32) ) };
	// 82F68504: FC3F0032  fmul f1, f31, f0
	ctx.f[1].f64 = ctx.f[31].f64 * ctx.f[0].f64;
	// 82F68508: 4B2C3E89  bl 0x8222c390
	ctx.lr = 0x82F6850C;
	sub_8222C390(ctx, base);
	// 82F6850C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68510: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82F68514: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
	// 82F68518: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82F6851C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68520: E96B0002  lwa r11, 0(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 82F68524: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F68528: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6852C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F68530: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68534: D0010178  stfs f0, 0x178(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), tmp.u32 ) };
	// 82F68538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6853C: 480042BD  bl 0x82f6c7f8
	ctx.lr = 0x82F68540;
	sub_82F6C7F8(ctx, base);
	// 82F68540: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F68544: 4BFFFE5C  b 0x82f683a0
	pc = 0x82F683A0; continue 'dispatch;
	// 82F68548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6854C: 480097B5  bl 0x82f71d00
	ctx.lr = 0x82F68550;
	sub_82F71D00(ctx, base);
	// 82F68550: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68554: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F68558: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6855C: 4182FFE4  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68560: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F68564: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F68568: 394007FF  li r10, 0x7ff
	ctx.r[10].s64 = 2047;
	// 82F6856C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68570: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68574: 794AA2C6  sldi r10, r10, 0x34
	ctx.r[10].u64 = ctx.r[10].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F68578: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F6857C: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68580: 409A0014  bne cr6, 0x82f68594
	if !ctx.cr[6].eq {
	pc = 0x82F68594; continue 'dispatch;
	}
	// 82F68584: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F68588: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F6858C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68590: 409A0008  bne cr6, 0x82f68598
	if !ctx.cr[6].eq {
	pc = 0x82F68598; continue 'dispatch;
	}
	// 82F68594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68598: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6859C: 4082FFA4  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F685A0: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F685A4: 39600FFF  li r11, 0xfff
	ctx.r[11].s64 = 4095;
	// 82F685A8: 796BA2C6  sldi r11, r11, 0x34
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 82F685AC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F685B0: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82F685B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F685B8: 419A0008  beq cr6, 0x82f685c0
	if ctx.cr[6].eq {
	pc = 0x82F685C0; continue 'dispatch;
	}
	// 82F685BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F685C0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F685C4: 40820024  bne 0x82f685e8
	if !ctx.cr[0].eq {
	pc = 0x82F685E8; continue 'dispatch;
	}
	// 82F685C8: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F685CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F685D0: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F685D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F685D8: 419A0008  beq cr6, 0x82f685e0
	if ctx.cr[6].eq {
	pc = 0x82F685E0; continue 'dispatch;
	}
	// 82F685DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F685E0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F685E4: 4182000C  beq 0x82f685f0
	if ctx.cr[0].eq {
	pc = 0x82F685F0; continue 'dispatch;
	}
	// 82F685E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F685EC: CBEB0D38  lfd f31, 0xd38(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82F685F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F685F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F685F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F685FC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F68600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68604: 4E800421  bctrl
	ctx.lr = 0x82F68608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68608: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F6860C: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82F68610: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F68614: 480041E5  bl 0x82f6c7f8
	ctx.lr = 0x82F68618;
	sub_82F6C7F8(ctx, base);
	// 82F68618: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F6861C: C80B1228  lfd f0, 0x1228(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4648 as u32) ) };
	// 82F68620: FC3F0032  fmul f1, f31, f0
	ctx.f[1].f64 = ctx.f[31].f64 * ctx.f[0].f64;
	// 82F68624: 4B2C3D6D  bl 0x8222c390
	ctx.lr = 0x82F68628;
	sub_8222C390(ctx, base);
	// 82F68628: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6862C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82F68630: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82F68634: 38810110  addi r4, r1, 0x110
	ctx.r[4].s64 = ctx.r[1].s64 + 272;
	// 82F68638: 7C0B57AE  stfiwx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82F6863C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68640: E96B0006  lwa r11, 4(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 82F68644: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F68648: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6864C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F68650: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68654: D0010128  stfs f0, 0x128(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82F68658: 4BFFFEE0  b 0x82f68538
	pc = 0x82F68538; continue 'dispatch;
	// 82F6865C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F68660: 480096A1  bl 0x82f71d00
	ctx.lr = 0x82F68664;
	sub_82F71D00(ctx, base);
	// 82F68664: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68668: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F6866C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F68670: 4182FED0  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68674: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F68678: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F6867C: 394007FF  li r10, 0x7ff
	ctx.r[10].s64 = 2047;
	// 82F68680: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68684: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68688: 794AA2C6  sldi r10, r10, 0x34
	ctx.r[10].u64 = ctx.r[10].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F6868C: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F68690: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68694: 409A0014  bne cr6, 0x82f686a8
	if !ctx.cr[6].eq {
	pc = 0x82F686A8; continue 'dispatch;
	}
	// 82F68698: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F6869C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F686A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F686A4: 409A0008  bne cr6, 0x82f686ac
	if !ctx.cr[6].eq {
	pc = 0x82F686AC; continue 'dispatch;
	}
	// 82F686A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F686AC: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F686B0: 4082FE90  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F686B4: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F686B8: 39600FFF  li r11, 0xfff
	ctx.r[11].s64 = 4095;
	// 82F686BC: 796BA2C6  sldi r11, r11, 0x34
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 82F686C0: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F686C4: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82F686C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F686CC: 419A0008  beq cr6, 0x82f686d4
	if ctx.cr[6].eq {
	pc = 0x82F686D4; continue 'dispatch;
	}
	// 82F686D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F686D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F686D8: 4082FE68  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F686DC: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F686E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F686E4: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F686E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F686EC: 419A0008  beq cr6, 0x82f686f4
	if ctx.cr[6].eq {
	pc = 0x82F686F4; continue 'dispatch;
	}
	// 82F686F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F686F4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F686F8: 4082FE48  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F686FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68700: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F68704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F68708: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6870C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68710: 4E800421  bctrl
	ctx.lr = 0x82F68714;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68714: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68718: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F6871C: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82F68720: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F68724: 480040D5  bl 0x82f6c7f8
	ctx.lr = 0x82F68728;
	sub_82F6C7F8(ctx, base);
	// 82F68728: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6872C: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68730: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F68734: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82F68738: D1A100C8  stfs f13, 0xc8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82F6873C: 48004625  bl 0x82f6cd60
	ctx.lr = 0x82F68740;
	sub_82F6CD60(ctx, base);
	// 82F68740: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82F68744: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68748: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6874C: C80B0D38  lfd f0, 0xd38(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82F68750: DBEA0008  stfd f31, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.f[31].u64 ) };
	// 82F68754: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82F68758: 409A0010  bne cr6, 0x82f68768
	if !ctx.cr[6].eq {
	pc = 0x82F68768; continue 'dispatch;
	}
	// 82F6875C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68760: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82F68764: CBCB0CB8  lfd f30, 0xcb8(r11)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	// 82F68768: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6876C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F68770: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F68774: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82F68778: C9AB0018  lfd f13, 0x18(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F6877C: C80A0EE8  lfd f0, 0xee8(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3816 as u32) ) };
	// 82F68780: FFAD0032  fmul f29, f13, f0
	ctx.f[29].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82F68784: 4800460D  bl 0x82f6cd90
	ctx.lr = 0x82F68788;
	sub_82F6CD90(ctx, base);
	// 82F68788: FC1D0828  fsub f0, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[29].f64 - ctx.f[1].f64;
	// 82F6878C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F68790: FFA00018  frsp f29, f0
	ctx.f[29].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68794: 480045E5  bl 0x82f6cd78
	ctx.lr = 0x82F68798;
	sub_82F6CD78(ctx, base);
	// 82F68798: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6879C: C9BF0010  lfd f13, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 82F687A0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F687A4: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82F687A8: C80B79B8  lfd f0, 0x79b8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31160 as u32) ) };
	// 82F687AC: FD810032  fmul f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82F687B0: FC1E0032  fmul f0, f30, f0
	ctx.f[0].f64 = ctx.f[30].f64 * ctx.f[0].f64;
	// 82F687B4: FDAD6024  fdiv f13, f13, f12
	ctx.f[13].f64 = ctx.f[13].f64 / ctx.f[12].f64;
	// 82F687B8: FC1F0024  fdiv f0, f31, f0
	ctx.f[0].f64 = ctx.f[31].f64 / ctx.f[0].f64;
	// 82F687BC: FC406818  frsp f2, f13
	ctx.f[2].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F687C0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F687C4: 4BFFEA0D  bl 0x82f671d0
	ctx.lr = 0x82F687C8;
	sub_82F671D0(ctx, base);
	// 82F687C8: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82F687CC: 4BFFFD6C  b 0x82f68538
	pc = 0x82F68538; continue 'dispatch;
	// 82F687D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F687D4: 4800952D  bl 0x82f71d00
	ctx.lr = 0x82F687D8;
	sub_82F71D00(ctx, base);
	// 82F687D8: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F687DC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F687E0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F687E4: 4182FD5C  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F687E8: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F687EC: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F687F0: 394007FF  li r10, 0x7ff
	ctx.r[10].s64 = 2047;
	// 82F687F4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F687F8: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F687FC: 794AA2C6  sldi r10, r10, 0x34
	ctx.r[10].u64 = ctx.r[10].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F68800: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F68804: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68808: 409A0014  bne cr6, 0x82f6881c
	if !ctx.cr[6].eq {
	pc = 0x82F6881C; continue 'dispatch;
	}
	// 82F6880C: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F68810: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F68814: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68818: 409A0008  bne cr6, 0x82f68820
	if !ctx.cr[6].eq {
	pc = 0x82F68820; continue 'dispatch;
	}
	// 82F6881C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68820: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68824: 4082FD1C  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68828: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F6882C: 39600FFF  li r11, 0xfff
	ctx.r[11].s64 = 4095;
	// 82F68830: 796BA2C6  sldi r11, r11, 0x34
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 82F68834: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68838: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82F6883C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68840: 419A0008  beq cr6, 0x82f68848
	if ctx.cr[6].eq {
	pc = 0x82F68848; continue 'dispatch;
	}
	// 82F68844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68848: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6884C: 4082FCF4  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68850: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F68854: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68858: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F6885C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68860: 419A0008  beq cr6, 0x82f68868
	if ctx.cr[6].eq {
	pc = 0x82F68868; continue 'dispatch;
	}
	// 82F68864: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68868: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6886C: 4082FCD4  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68870: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68874: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F68878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6887C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F68880: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68884: 4E800421  bctrl
	ctx.lr = 0x82F68888;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68888: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6888C: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82F68890: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82F68894: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F68898: 48003F61  bl 0x82f6c7f8
	ctx.lr = 0x82F6889C;
	sub_82F6C7F8(ctx, base);
	// 82F6889C: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F688A0: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F688A4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82F688A8: D00100F8  stfs f0, 0xf8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82F688AC: D1A10108  stfs f13, 0x108(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82F688B0: 480044C9  bl 0x82f6cd78
	ctx.lr = 0x82F688B4;
	sub_82F6CD78(ctx, base);
	// 82F688B4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82F688B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F688BC: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F688C0: C80B0D38  lfd f0, 0xd38(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82F688C4: DBEA0010  stfd f31, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.f[31].u64 ) };
	// 82F688C8: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82F688CC: 409A0010  bne cr6, 0x82f688dc
	if !ctx.cr[6].eq {
	pc = 0x82F688DC; continue 'dispatch;
	}
	// 82F688D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F688D4: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	// 82F688D8: CBCB0CB8  lfd f30, 0xcb8(r11)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	// 82F688DC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F688E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F688E4: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82F688E8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82F688EC: C9AB0018  lfd f13, 0x18(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F688F0: C80A0EE8  lfd f0, 0xee8(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3816 as u32) ) };
	// 82F688F4: FFAD0032  fmul f29, f13, f0
	ctx.f[29].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82F688F8: 48004499  bl 0x82f6cd90
	ctx.lr = 0x82F688FC;
	sub_82F6CD90(ctx, base);
	// 82F688FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68900: FC1D0828  fsub f0, f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[29].f64 - ctx.f[1].f64;
	// 82F68904: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82F68908: CBAB79B8  lfd f29, 0x79b8(r11)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31160 as u32) ) };
	// 82F6890C: FDBE0772  fmul f13, f30, f29
	ctx.f[13].f64 = ctx.f[30].f64 * ctx.f[29].f64;
	// 82F68910: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68914: FC1F6824  fdiv f0, f31, f13
	ctx.f[0].f64 = ctx.f[31].f64 / ctx.f[13].f64;
	// 82F68918: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F6891C: 48004445  bl 0x82f6cd60
	ctx.lr = 0x82F68920;
	sub_82F6CD60(ctx, base);
	// 82F68920: FC010772  fmul f0, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[29].f64;
	// 82F68924: C9BF0008  lfd f13, 8(r31)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82F68928: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82F6892C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82F68930: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82F68934: FC0D0024  fdiv f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 / ctx.f[0].f64;
	// 82F68938: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F6893C: 4BFFE895  bl 0x82f671d0
	ctx.lr = 0x82F68940;
	sub_82F671D0(ctx, base);
	// 82F68940: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82F68944: 4BFFFBF4  b 0x82f68538
	pc = 0x82F68538; continue 'dispatch;
	// 82F68948: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6894C: 480093B5  bl 0x82f71d00
	ctx.lr = 0x82F68950;
	sub_82F71D00(ctx, base);
	// 82F68950: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68954: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F68958: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6895C: 4182FBE4  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68960: DBE10050  stfd f31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[31].u64 ) };
	// 82F68964: 396007FF  li r11, 0x7ff
	ctx.r[11].s64 = 2047;
	// 82F68968: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F6896C: 796AA2C6  sldi r10, r11, 0x34
	ctx.r[10].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F68970: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68974: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68978: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F6897C: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68980: 409A0014  bne cr6, 0x82f68994
	if !ctx.cr[6].eq {
	pc = 0x82F68994; continue 'dispatch;
	}
	// 82F68984: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F68988: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F6898C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68990: 409A0008  bne cr6, 0x82f68998
	if !ctx.cr[6].eq {
	pc = 0x82F68998; continue 'dispatch;
	}
	// 82F68994: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68998: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6899C: 4082FBA4  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F689A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F689A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F689A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F689AC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F689B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F689B4: 4E800421  bctrl
	ctx.lr = 0x82F689B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F689B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F689BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F689C0: CBCBE810  lfd f30, -0x17f0(r11)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-6128 as u32) ) };
	// 82F689C4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82F689C8: 4B297F29  bl 0x822008f0
	ctx.lr = 0x82F689CC;
	sub_822008F0(ctx, base);
	// 82F689CC: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F689D0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F689D4: C80B11E0  lfd f0, 0x11e0(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4576 as u32) ) };
	// 82F689D8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82F689DC: 4099000C  ble cr6, 0x82f689e8
	if !ctx.cr[6].gt {
	pc = 0x82F689E8; continue 'dispatch;
	}
	// 82F689E0: FFFFF028  fsub f31, f31, f30
	ctx.f[31].f64 = ctx.f[31].f64 - ctx.f[30].f64;
	// 82F689E4: 48000018  b 0x82f689fc
	pc = 0x82F689FC; continue 'dispatch;
	// 82F689E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F689EC: C80B2940  lfd f0, 0x2940(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(10560 as u32) ) };
	// 82F689F0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82F689F4: 40980008  bge cr6, 0x82f689fc
	if !ctx.cr[6].lt {
	pc = 0x82F689FC; continue 'dispatch;
	}
	// 82F689F8: FFFFF02A  fadd f31, f31, f30
	ctx.f[31].f64 = ctx.f[31].f64 + ctx.f[30].f64;
	// 82F689FC: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68A00: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F68A04: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F68A08: DBEB0018  stfd f31, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.f[31].u64 ) };
	// 82F68A0C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68A10: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82F68A14: 48003DE5  bl 0x82f6c7f8
	ctx.lr = 0x82F68A18;
	sub_82F6C7F8(ctx, base);
	// 82F68A18: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F68A1C: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68A20: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F68A24: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82F68A28: D1A100E8  stfs f13, 0xe8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82F68A2C: 48004365  bl 0x82f6cd90
	ctx.lr = 0x82F68A30;
	sub_82F6CD90(ctx, base);
	// 82F68A30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68A34: 83BF00AC  lwz r29, 0xac(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68A38: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F68A3C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82F68A40: C80B0EE8  lfd f0, 0xee8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3816 as u32) ) };
	// 82F68A44: FC1F0838  fmsub f0, f31, f0, f1
	ctx.f[0].f64 = ctx.f[31].f64 * ctx.f[0].f64 - ctx.f[1].f64;
	// 82F68A48: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68A4C: 4800432D  bl 0x82f6cd78
	ctx.lr = 0x82F68A50;
	sub_82F6CD78(ctx, base);
	// 82F68A50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68A54: C81D0010  lfd f0, 0x10(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	// 82F68A58: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F68A5C: CBEB79B8  lfd f31, 0x79b8(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31160 as u32) ) };
	// 82F68A60: FDA107F2  fmul f13, f1, f31
	ctx.f[13].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 82F68A64: FC006824  fdiv f0, f0, f13
	ctx.f[0].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 82F68A68: FFA00018  frsp f29, f0
	ctx.f[29].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68A6C: 480042F5  bl 0x82f6cd60
	ctx.lr = 0x82F68A70;
	sub_82F6CD60(ctx, base);
	// 82F68A70: FC0107F2  fmul f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 82F68A74: C9BF0008  lfd f13, 8(r31)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 82F68A78: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F68A7C: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82F68A80: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82F68A84: FC0D0024  fdiv f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 / ctx.f[0].f64;
	// 82F68A88: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68A8C: 4BFFE745  bl 0x82f671d0
	ctx.lr = 0x82F68A90;
	sub_82F671D0(ctx, base);
	// 82F68A90: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82F68A94: 4BFFFAA4  b 0x82f68538
	pc = 0x82F68538; continue 'dispatch;
	// 82F68A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F68A9C: 48009265  bl 0x82f71d00
	ctx.lr = 0x82F68AA0;
	sub_82F71D00(ctx, base);
	// 82F68AA0: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68AA4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82F68AA8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F68AAC: 4182FA94  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68AB0: DBC10050  stfd f30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[30].u64 ) };
	// 82F68AB4: 396007FF  li r11, 0x7ff
	ctx.r[11].s64 = 2047;
	// 82F68AB8: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F68ABC: 796AA2C6  sldi r10, r11, 0x34
	ctx.r[10].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F68AC0: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68AC4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68AC8: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F68ACC: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68AD0: 409A0014  bne cr6, 0x82f68ae4
	if !ctx.cr[6].eq {
	pc = 0x82F68AE4; continue 'dispatch;
	}
	// 82F68AD4: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F68AD8: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F68ADC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68AE0: 409A0008  bne cr6, 0x82f68ae8
	if !ctx.cr[6].eq {
	pc = 0x82F68AE8; continue 'dispatch;
	}
	// 82F68AE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68AE8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68AEC: 4082FA54  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68AF0: DBC10050  stfd f30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[30].u64 ) };
	// 82F68AF4: 39600FFF  li r11, 0xfff
	ctx.r[11].s64 = 4095;
	// 82F68AF8: 796BA2C6  sldi r11, r11, 0x34
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 82F68AFC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68B00: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82F68B04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68B08: 419A0008  beq cr6, 0x82f68b10
	if ctx.cr[6].eq {
	pc = 0x82F68B10; continue 'dispatch;
	}
	// 82F68B0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68B10: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68B14: 4082FA2C  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68B18: DBC10050  stfd f30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[30].u64 ) };
	// 82F68B1C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68B20: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68B24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68B28: 419A0008  beq cr6, 0x82f68b30
	if ctx.cr[6].eq {
	pc = 0x82F68B30; continue 'dispatch;
	}
	// 82F68B2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68B30: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F68B34: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68B38: CB6A0D38  lfd f27, 0xd38(r10)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3384 as u32) ) };
	// 82F68B3C: 41820008  beq 0x82f68b44
	if ctx.cr[0].eq {
	pc = 0x82F68B44; continue 'dispatch;
	}
	// 82F68B40: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82F68B44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68B48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F68B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F68B50: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F68B54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68B58: 4E800421  bctrl
	ctx.lr = 0x82F68B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68B5C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68B60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F68B64: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82F68B68: 48003C91  bl 0x82f6c7f8
	ctx.lr = 0x82F68B6C;
	sub_82F6C7F8(ctx, base);
	// 82F68B6C: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F68B70: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68B74: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82F68B78: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82F68B7C: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82F68B80: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82F68B84: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F68B88: 48003C71  bl 0x82f6c7f8
	ctx.lr = 0x82F68B8C;
	sub_82F6C7F8(ctx, base);
	// 82F68B8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68B90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F68B94: CB8B0EE8  lfd f28, 0xee8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3816 as u32) ) };
	// 82F68B98: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68B9C: C80B0018  lfd f0, 0x18(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F68BA0: FFE00732  fmul f31, f0, f28
	ctx.f[31].f64 = ctx.f[0].f64 * ctx.f[28].f64;
	// 82F68BA4: 480041ED  bl 0x82f6cd90
	ctx.lr = 0x82F68BA8;
	sub_82F6CD90(ctx, base);
	// 82F68BA8: FC1F0828  fsub f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64 - ctx.f[1].f64;
	// 82F68BAC: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68BB0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F68BB4: 4B2D12FD  bl 0x82239eb0
	ctx.lr = 0x82F68BB8;
	sub_82239EB0(ctx, base);
	// 82F68BB8: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F68BBC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F68BC0: 4B2D13D1  bl 0x82239f90
	ctx.lr = 0x82F68BC4;
	sub_82239F90(ctx, base);
	// 82F68BC4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F68BC8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68BCC: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 82F68BD0: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 82F68BD4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82F68BD8: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F68BDC: FCC0F890  fmr f6, f31
	ctx.f[6].f64 = ctx.f[31].f64;
	// 82F68BE0: FCA0F890  fmr f5, f31
	ctx.f[5].f64 = ctx.f[31].f64;
	// 82F68BE4: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82F68BE8: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F68BEC: 48003C25  bl 0x82f6c810
	ctx.lr = 0x82F68BF0;
	sub_82F6C810(ctx, base);
	// 82F68BF0: 388101C0  addi r4, r1, 0x1c0
	ctx.r[4].s64 = ctx.r[1].s64 + 448;
	// 82F68BF4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82F68BF8: 48003E31  bl 0x82f6ca28
	ctx.lr = 0x82F68BFC;
	sub_82F6CA28(ctx, base);
	// 82F68BFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68C00: 38A10130  addi r5, r1, 0x130
	ctx.r[5].s64 = ctx.r[1].s64 + 304;
	// 82F68C04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F68C08: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82F68C0C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F68C10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68C14: 4E800421  bctrl
	ctx.lr = 0x82F68C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68C18: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68C1C: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F68C20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68C24: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F68C28: C1AB0DB0  lfs f13, 0xdb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68C2C: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68C30: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82F68C34: 4099001C  ble cr6, 0x82f68c50
	if !ctx.cr[6].gt {
	pc = 0x82F68C50; continue 'dispatch;
	}
	// 82F68C38: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F68C3C: C9AB1228  lfd f13, 0x1228(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4648 as u32) ) };
	// 82F68C40: FDBE0372  fmul f13, f30, f13
	ctx.f[13].f64 = ctx.f[30].f64 * ctx.f[13].f64;
	// 82F68C44: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F68C48: EFCD0024  fdivs f30, f13, f0
	ctx.f[30].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82F68C4C: 48000008  b 0x82f68c54
	pc = 0x82F68C54; continue 'dispatch;
	// 82F68C50: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82F68C54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F68C58: 48004109  bl 0x82f6cd60
	ctx.lr = 0x82F68C5C;
	sub_82F6CD60(ctx, base);
	// 82F68C5C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F68C60: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68C64: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68C68: CBAB79B8  lfd f29, 0x79b8(r11)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31160 as u32) ) };
	// 82F68C6C: FC1E07F2  fmul f0, f30, f31
	ctx.f[0].f64 = ctx.f[30].f64 * ctx.f[31].f64;
	// 82F68C70: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82F68C74: FFC00772  fmul f30, f0, f29
	ctx.f[30].f64 = ctx.f[0].f64 * ctx.f[29].f64;
	// 82F68C78: DBCA0008  stfd f30, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.f[30].u64 ) };
	// 82F68C7C: 409A0010  bne cr6, 0x82f68c8c
	if !ctx.cr[6].eq {
	pc = 0x82F68C8C; continue 'dispatch;
	}
	// 82F68C80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68C84: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82F68C88: CBEB0CB8  lfd f31, 0xcb8(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	// 82F68C8C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68C90: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F68C94: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82F68C98: C80B0018  lfd f0, 0x18(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F68C9C: FF800732  fmul f28, f0, f28
	ctx.f[28].f64 = ctx.f[0].f64 * ctx.f[28].f64;
	// 82F68CA0: 480040F1  bl 0x82f6cd90
	ctx.lr = 0x82F68CA4;
	sub_82F6CD90(ctx, base);
	// 82F68CA4: FC1C0828  fsub f0, f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[28].f64 - ctx.f[1].f64;
	// 82F68CA8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F68CAC: FF800018  frsp f28, f0
	ctx.f[28].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68CB0: 480040C9  bl 0x82f6cd78
	ctx.lr = 0x82F68CB4;
	sub_82F6CD78(ctx, base);
	// 82F68CB4: FC010772  fmul f0, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[29].f64;
	// 82F68CB8: C9BD0010  lfd f13, 0x10(r29)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	// 82F68CBC: FD9F0772  fmul f12, f31, f29
	ctx.f[12].f64 = ctx.f[31].f64 * ctx.f[29].f64;
	// 82F68CC0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F68CC4: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82F68CC8: FC0D0024  fdiv f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 / ctx.f[0].f64;
	// 82F68CCC: FDBE6024  fdiv f13, f30, f12
	ctx.f[13].f64 = ctx.f[30].f64 / ctx.f[12].f64;
	// 82F68CD0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68CD4: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82F68CD8: FC400018  frsp f2, f0
	ctx.f[2].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68CDC: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F68CE0: 4BFFE4F1  bl 0x82f671d0
	ctx.lr = 0x82F68CE4;
	sub_82F671D0(ctx, base);
	// 82F68CE4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82F68CE8: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68CEC: C80B0008  lfd f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82F68CF0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68CF4: D80B0008  stfd f0, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[0].u64 ) };
	// 82F68CF8: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68CFC: C80B0010  lfd f0, 0x10(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82F68D00: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68D04: D80B0010  stfd f0, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.f[0].u64 ) };
	// 82F68D08: 4BFFF830  b 0x82f68538
	pc = 0x82F68538; continue 'dispatch;
	// 82F68D0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F68D10: 48008FF1  bl 0x82f71d00
	ctx.lr = 0x82F68D14;
	sub_82F71D00(ctx, base);
	// 82F68D14: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68D18: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82F68D1C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F68D20: 4182F820  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68D24: DBC10050  stfd f30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[30].u64 ) };
	// 82F68D28: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F68D2C: 394007FF  li r10, 0x7ff
	ctx.r[10].s64 = 2047;
	// 82F68D30: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68D34: 794AA2C6  sldi r10, r10, 0x34
	ctx.r[10].u64 = ctx.r[10].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F68D38: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68D3C: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F68D40: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68D44: 409A0014  bne cr6, 0x82f68d58
	if !ctx.cr[6].eq {
	pc = 0x82F68D58; continue 'dispatch;
	}
	// 82F68D48: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F68D4C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F68D50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68D54: 409A0008  bne cr6, 0x82f68d5c
	if !ctx.cr[6].eq {
	pc = 0x82F68D5C; continue 'dispatch;
	}
	// 82F68D58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68D5C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68D60: 4082F7E0  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68D64: DBC10050  stfd f30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[30].u64 ) };
	// 82F68D68: 39600FFF  li r11, 0xfff
	ctx.r[11].s64 = 4095;
	// 82F68D6C: 796BA2C6  sldi r11, r11, 0x34
	ctx.r[11].u64 = ctx.r[11].u64.wrapping_shl(52);
	ctx.r[11].u32 = ctx.r[11].u64 as u32;
	// 82F68D70: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68D74: 7F295840  cmpld cr6, r9, r11
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[11].u64, &mut ctx.xer);
	// 82F68D78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68D7C: 419A0008  beq cr6, 0x82f68d84
	if ctx.cr[6].eq {
	pc = 0x82F68D84; continue 'dispatch;
	}
	// 82F68D80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68D84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68D88: 4082F7B8  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68D8C: DBC10050  stfd f30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[30].u64 ) };
	// 82F68D90: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68D94: 7F2B5040  cmpld cr6, r11, r10
	ctx.cr[6].compare_u64(ctx.r[11].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68D98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68D9C: 419A0008  beq cr6, 0x82f68da4
	if ctx.cr[6].eq {
	pc = 0x82F68DA4; continue 'dispatch;
	}
	// 82F68DA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68DA4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F68DA8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68DAC: CB6A0D38  lfd f27, 0xd38(r10)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3384 as u32) ) };
	// 82F68DB0: 41820008  beq 0x82f68db8
	if ctx.cr[0].eq {
	pc = 0x82F68DB8; continue 'dispatch;
	}
	// 82F68DB4: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82F68DB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68DBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F68DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F68DC4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F68DC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68DCC: 4E800421  bctrl
	ctx.lr = 0x82F68DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68DD0: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68DD4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F68DD8: 388B0020  addi r4, r11, 0x20
	ctx.r[4].s64 = ctx.r[11].s64 + 32;
	// 82F68DDC: 48003A1D  bl 0x82f6c7f8
	ctx.lr = 0x82F68DE0;
	sub_82F6C7F8(ctx, base);
	// 82F68DE0: C01F0058  lfs f0, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F68DE4: C1BF0068  lfs f13, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68DE8: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82F68DEC: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82F68DF0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82F68DF4: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82F68DF8: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82F68DFC: 480039FD  bl 0x82f6c7f8
	ctx.lr = 0x82F68E00;
	sub_82F6C7F8(ctx, base);
	// 82F68E00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68E04: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F68E08: CB8B0EE8  lfd f28, 0xee8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3816 as u32) ) };
	// 82F68E0C: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68E10: C80B0018  lfd f0, 0x18(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F68E14: FFE00732  fmul f31, f0, f28
	ctx.f[31].f64 = ctx.f[0].f64 * ctx.f[28].f64;
	// 82F68E18: 48003F79  bl 0x82f6cd90
	ctx.lr = 0x82F68E1C;
	sub_82F6CD90(ctx, base);
	// 82F68E1C: FC1F0828  fsub f0, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64 - ctx.f[1].f64;
	// 82F68E20: FFE00018  frsp f31, f0
	ctx.f[31].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68E24: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F68E28: 4B2D1089  bl 0x82239eb0
	ctx.lr = 0x82F68E2C;
	sub_82239EB0(ctx, base);
	// 82F68E2C: FFA00818  frsp f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F68E30: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82F68E34: 4B2D115D  bl 0x82239f90
	ctx.lr = 0x82F68E38;
	sub_82239F90(ctx, base);
	// 82F68E38: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F68E3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68E40: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 82F68E44: FC80E890  fmr f4, f29
	ctx.f[4].f64 = ctx.f[29].f64;
	// 82F68E48: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82F68E4C: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F68E50: FCC0F890  fmr f6, f31
	ctx.f[6].f64 = ctx.f[31].f64;
	// 82F68E54: FCA0F890  fmr f5, f31
	ctx.f[5].f64 = ctx.f[31].f64;
	// 82F68E58: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82F68E5C: FC400050  fneg f2, f0
	ctx.f[2].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F68E60: 480039B1  bl 0x82f6c810
	ctx.lr = 0x82F68E64;
	sub_82F6C810(ctx, base);
	// 82F68E64: 388101F0  addi r4, r1, 0x1f0
	ctx.r[4].s64 = ctx.r[1].s64 + 496;
	// 82F68E68: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 82F68E6C: 48003BBD  bl 0x82f6ca28
	ctx.lr = 0x82F68E70;
	sub_82F6CA28(ctx, base);
	// 82F68E70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68E74: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 82F68E78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F68E7C: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 82F68E80: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F68E84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F68E88: 4E800421  bctrl
	ctx.lr = 0x82F68E8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F68E8C: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68E90: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F68E94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68E98: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F68E9C: C1AB0DB0  lfs f13, 0xdb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F68EA0: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68EA4: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82F68EA8: 4099001C  ble cr6, 0x82f68ec4
	if !ctx.cr[6].gt {
	pc = 0x82F68EC4; continue 'dispatch;
	}
	// 82F68EAC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F68EB0: C9AB1228  lfd f13, 0x1228(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(4648 as u32) ) };
	// 82F68EB4: FDBE0372  fmul f13, f30, f13
	ctx.f[13].f64 = ctx.f[30].f64 * ctx.f[13].f64;
	// 82F68EB8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F68EBC: EFCD0024  fdivs f30, f13, f0
	ctx.f[30].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82F68EC0: 48000008  b 0x82f68ec8
	pc = 0x82F68EC8; continue 'dispatch;
	// 82F68EC4: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82F68EC8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F68ECC: 48003EAD  bl 0x82f6cd78
	ctx.lr = 0x82F68ED0;
	sub_82F6CD78(ctx, base);
	// 82F68ED0: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82F68ED4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68ED8: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68EDC: CBAB79B8  lfd f29, 0x79b8(r11)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(31160 as u32) ) };
	// 82F68EE0: FC1E07F2  fmul f0, f30, f31
	ctx.f[0].f64 = ctx.f[30].f64 * ctx.f[31].f64;
	// 82F68EE4: FF1FD800  fcmpu cr6, f31, f27
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[27].f64);
	// 82F68EE8: FFC00772  fmul f30, f0, f29
	ctx.f[30].f64 = ctx.f[0].f64 * ctx.f[29].f64;
	// 82F68EEC: DBCA0010  stfd f30, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.f[30].u64 ) };
	// 82F68EF0: 409A0010  bne cr6, 0x82f68f00
	if !ctx.cr[6].eq {
	pc = 0x82F68F00; continue 'dispatch;
	}
	// 82F68EF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F68EF8: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82F68EFC: CBEB0CB8  lfd f31, 0xcb8(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	// 82F68F00: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F68F04: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F68F08: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82F68F0C: C80B0018  lfd f0, 0x18(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82F68F10: FF800732  fmul f28, f0, f28
	ctx.f[28].f64 = ctx.f[0].f64 * ctx.f[28].f64;
	// 82F68F14: 48003E7D  bl 0x82f6cd90
	ctx.lr = 0x82F68F18;
	sub_82F6CD90(ctx, base);
	// 82F68F18: FC1F0772  fmul f0, f31, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64 * ctx.f[29].f64;
	// 82F68F1C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F68F20: FDBC0828  fsub f13, f28, f1
	ctx.f[13].f64 = ctx.f[28].f64 - ctx.f[1].f64;
	// 82F68F24: FC1E0024  fdiv f0, f30, f0
	ctx.f[0].f64 = ctx.f[30].f64 / ctx.f[0].f64;
	// 82F68F28: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F68F2C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68F30: FFC00018  frsp f30, f0
	ctx.f[30].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68F34: 48003E2D  bl 0x82f6cd60
	ctx.lr = 0x82F68F38;
	sub_82F6CD60(ctx, base);
	// 82F68F38: FC010772  fmul f0, f1, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[29].f64;
	// 82F68F3C: C9BD0008  lfd f13, 8(r29)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 82F68F40: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F68F44: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82F68F48: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82F68F4C: FC0D0024  fdiv f0, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 / ctx.f[0].f64;
	// 82F68F50: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82F68F54: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F68F58: 4BFFE279  bl 0x82f671d0
	ctx.lr = 0x82F68F5C;
	sub_82F671D0(ctx, base);
	// 82F68F5C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82F68F60: 4BFFFD88  b 0x82f68ce8
	pc = 0x82F68CE8; continue 'dispatch;
	// 82F68F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F68F68: 48008D99  bl 0x82f71d00
	ctx.lr = 0x82F68F6C;
	sub_82F71D00(ctx, base);
	// 82F68F6C: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68F70: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F68F74: 4182F5CC  beq 0x82f68540
	if ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68F78: 398007FF  li r12, 0x7ff
	ctx.r[12].s64 = 2047;
	// 82F68F7C: D8210050  stfd f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[1].u64 ) };
	// 82F68F80: 394007FF  li r10, 0x7ff
	ctx.r[10].s64 = 2047;
	// 82F68F84: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F68F88: 798CA2C6  sldi r12, r12, 0x34
	ctx.r[12].u64 = ctx.r[12].u64.wrapping_shl(52);
	ctx.r[12].u32 = ctx.r[12].u64 as u32;
	// 82F68F8C: 794AA2C6  sldi r10, r10, 0x34
	ctx.r[10].u64 = ctx.r[10].u64.wrapping_shl(52);
	ctx.r[10].u32 = ctx.r[10].u64 as u32;
	// 82F68F90: 7D696038  and r9, r11, r12
	ctx.r[9].u64 = ctx.r[11].u64 & ctx.r[12].u64;
	// 82F68F94: 7F295040  cmpld cr6, r9, r10
	ctx.cr[6].compare_u64(ctx.r[9].u64, ctx.r[10].u64, &mut ctx.xer);
	// 82F68F98: 409A0014  bne cr6, 0x82f68fac
	if !ctx.cr[6].eq {
	pc = 0x82F68FAC; continue 'dispatch;
	}
	// 82F68F9C: 796B0300  clrldi r11, r11, 0xc
	ctx.r[11].u64 = ctx.r[11].u64 & 0x000FFFFFFFFFFFFFu64;
	// 82F68FA0: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 82F68FA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F68FA8: 409A0008  bne cr6, 0x82f68fb0
	if !ctx.cr[6].eq {
	pc = 0x82F68FB0; continue 'dispatch;
	}
	// 82F68FAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F68FB0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F68FB4: 4082F58C  bne 0x82f68540
	if !ctx.cr[0].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F68FB8: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82F68FBC: E95F0038  ld r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	// 82F68FC0: E91F0040  ld r8, 0x40(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	// 82F68FC4: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 82F68FC8: E8DF0030  ld r6, 0x30(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	// 82F68FCC: 38A10190  addi r5, r1, 0x190
	ctx.r[5].s64 = ctx.r[1].s64 + 400;
	// 82F68FD0: EBDF0048  ld r30, 0x48(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	// 82F68FD4: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 82F68FD8: FBC90018  std r30, 0x18(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u64 ) };
	// 82F68FDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F68FE0: C8072938  lfd f0, 0x2938(r7)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(10552 as u32) ) };
	// 82F68FE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F68FE8: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82F68FEC: F9090010  std r8, 0x10(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 82F68FF0: F9490008  std r10, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82F68FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F68FF8: F8C90000  std r6, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 82F68FFC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F69000: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F69004: D00101A8  stfs f0, 0x1a8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), tmp.u32 ) };
	// 82F69008: E9250010  ld r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	// 82F6900C: E9050000  ld r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 82F69010: F91F0030  std r8, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[8].u64 ) };
	// 82F69014: E9450008  ld r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 82F69018: E9050018  ld r8, 0x18(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	// 82F6901C: F93F0040  std r9, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 82F69020: F91F0048  std r8, 0x48(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[8].u64 ) };
	// 82F69024: F95F0038  std r10, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u64 ) };
	// 82F69028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6902C: 4E800421  bctrl
	ctx.lr = 0x82F69030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69030: 4BFFF510  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F69034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69038: 48009089  bl 0x82f720c0
	ctx.lr = 0x82F6903C;
	sub_82F720C0(ctx, base);
	// 82F6903C: 987F0078  stb r3, 0x78(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u8 ) };
	// 82F69040: 4BFFF500  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F69044: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69048: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6904C: 409A0118  bne cr6, 0x82f69164
	if !ctx.cr[6].eq {
	pc = 0x82F69164; continue 'dispatch;
	}
	// 82F69050: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82F69054: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82F69058: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6905C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F69060: 48008BB1  bl 0x82f71c10
	ctx.lr = 0x82F69064;
	sub_82F71C10(ctx, base);
	// 82F69064: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82F69068: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F6906C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69070: 4BF94F31  bl 0x82efdfa0
	ctx.lr = 0x82F69074;
	sub_82EFDFA0(ctx, base);
	// 82F69074: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82F69078: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82F6907C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82F69080: 396BEFF0  addi r11, r11, -0x1010
	ctx.r[11].s64 = ctx.r[11].s64 + -4112;
	// 82F69084: 38A9000C  addi r5, r9, 0xc
	ctx.r[5].s64 = ctx.r[9].s64 + 12;
	// 82F69088: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 82F6908C: 81480000  lwz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69090: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82F69094: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69098: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6909C: 2C060000  cmpwi r6, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F690A0: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82F690A4: 41820014  beq 0x82f690b8
	if ctx.cr[0].eq {
	pc = 0x82F690B8; continue 'dispatch;
	}
	// 82F690A8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F690AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F690B0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82F690B4: 419AFFE0  beq cr6, 0x82f69094
	if ctx.cr[6].eq {
	pc = 0x82F69094; continue 'dispatch;
	}
	// 82F690B8: 2C060000  cmpwi r6, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F690BC: 41820040  beq 0x82f690fc
	if ctx.cr[0].eq {
	pc = 0x82F690FC; continue 'dispatch;
	}
	// 82F690C0: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82F690C4: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82F690C8: 2B07000F  cmplwi cr6, r7, 0xf
	ctx.cr[6].compare_u32(ctx.r[7].u32, 15 as u32, &mut ctx.xer);
	// 82F690CC: 4198FFC0  blt cr6, 0x82f6908c
	if ctx.cr[6].lt {
	pc = 0x82F6908C; continue 'dispatch;
	}
	// 82F690D0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82F690D4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82F690D8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82F690DC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F690E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F690E4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82F690E8: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82F690EC: 7D40492D  stwcx. r10, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F690F0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F690F4: 4082FFE8  bne 0x82f690dc
	if !ctx.cr[0].eq {
	pc = 0x82F690DC; continue 'dispatch;
	}
	// 82F690F8: 48000030  b 0x82f69128
	pc = 0x82F69128; continue 'dispatch;
	// 82F690FC: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82F69100: 90FF0074  stw r7, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[7].u32 ) };
	// 82F69104: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82F69108: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82F6910C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82F69110: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F69114: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82F69118: 7D485A14  add r10, r8, r11
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82F6911C: 7D40492D  stwcx. r10, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F69120: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F69124: 4082FFE8  bne 0x82f6910c
	if !ctx.cr[0].eq {
	pc = 0x82F6910C; continue 'dispatch;
	}
	// 82F69128: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 82F6912C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69130: 40820008  bne 0x82f69138
	if !ctx.cr[0].eq {
	pc = 0x82F69138; continue 'dispatch;
	}
	// 82F69134: 4BF9476D  bl 0x82efd8a0
	ctx.lr = 0x82F69138;
	sub_82EFD8A0(ctx, base);
	// 82F69138: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82F6913C: 396A000C  addi r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 + 12;
	// 82F69140: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69144: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F69148: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6914C: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F69150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F69154: 409AF3EC  bne cr6, 0x82f68540
	if !ctx.cr[6].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F69158: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82F6915C: 4800492D  bl 0x82f6da88
	ctx.lr = 0x82F69160;
	sub_82F6DA88(ctx, base);
	// 82F69160: 4BFFF3E0  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F69164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69168: 48008B99  bl 0x82f71d00
	ctx.lr = 0x82F6916C;
	sub_82F71D00(ctx, base);
	// 82F6916C: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82F69170: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82F69174: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F69178: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 82F6917C: 41980008  blt cr6, 0x82f69184
	if ctx.cr[6].lt {
	pc = 0x82F69184; continue 'dispatch;
	}
	// 82F69180: 3960000E  li r11, 0xe
	ctx.r[11].s64 = 14;
	// 82F69184: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82F69188: 41990008  bgt cr6, 0x82f69190
	if ctx.cr[6].gt {
	pc = 0x82F69190; continue 'dispatch;
	}
	// 82F6918C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F69190: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82F69194: 4BFFF3AC  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F69198: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82F6919C: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F691A0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82F691A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F691A8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82F691AC: 48008A65  bl 0x82f71c10
	ctx.lr = 0x82F691B0;
	sub_82F71C10(ctx, base);
	// 82F691B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F691B4: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F691B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F691BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F691C0: 4E800421  bctrl
	ctx.lr = 0x82F691C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F691C4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F691C8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F691CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F691D0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F691D4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F691D8: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F691DC: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F691E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F691E4: 409AF35C  bne cr6, 0x82f68540
	if !ctx.cr[6].eq {
	pc = 0x82F68540; continue 'dispatch;
	}
	// 82F691E8: 4BFFFF74  b 0x82f6915c
	pc = 0x82F6915C; continue 'dispatch;
	// 82F691EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F691F0: 48008ED1  bl 0x82f720c0
	ctx.lr = 0x82F691F4;
	sub_82F720C0(ctx, base);
	// 82F691F4: 987F0092  stb r3, 0x92(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(146 as u32), ctx.r[3].u8 ) };
	// 82F691F8: 4BFFF348  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F691FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69200: 48008EC1  bl 0x82f720c0
	ctx.lr = 0x82F69204;
	sub_82F720C0(ctx, base);
	// 82F69204: 987F0091  stb r3, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[3].u8 ) };
	// 82F69208: 4BFFF338  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F6920C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69214: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6921C: 4E800421  bctrl
	ctx.lr = 0x82F69220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69220: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82F69224: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69228: 57A91838  slwi r9, r29, 3
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F6922C: 396BECD0  addi r11, r11, -0x1330
	ctx.r[11].s64 = ctx.r[11].s64 + -4912;
	// 82F69230: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82F69234: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F69238: 38882900  addi r4, r8, 0x2900
	ctx.r[4].s64 = ctx.r[8].s64 + 10496;
	// 82F6923C: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69240: 7CC9582E  lwzx r6, r9, r11
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82F69244: 4BFA4695  bl 0x82f0d8d8
	ctx.lr = 0x82F69248;
	sub_82F0D8D8(ctx, base);
	// 82F69248: 4BFFF2F8  b 0x82f68540
	pc = 0x82F68540; continue 'dispatch;
	// 82F6924C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69250: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69254: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F69258: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6925C: 4E800421  bctrl
	ctx.lr = 0x82F69260;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69260: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F69264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69268: 48008E59  bl 0x82f720c0
	ctx.lr = 0x82F6926C;
	sub_82F720C0(ctx, base);
	// 82F6926C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82F69270: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F69274: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F69278: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6927C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F69280: 997F0094  stb r11, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 82F69284: 4BFFF11C  b 0x82f683a0
	pc = 0x82F683A0; continue 'dispatch;
	// 82F69288: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6928C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69290: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F69294: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69298: 4E800421  bctrl
	ctx.lr = 0x82F6929C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6929C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F692A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F692A4: 48008A5D  bl 0x82f71d00
	ctx.lr = 0x82F692A8;
	sub_82F71D00(ctx, base);
	// 82F692A8: 39600098  li r11, 0x98
	ctx.r[11].s64 = 152;
	// 82F692AC: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82F692B0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F692B4: 7C1F5FAE  stfiwx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82F692B8: 4BFFF0E8  b 0x82f683a0
	pc = 0x82F683A0; continue 'dispatch;
	// 82F692BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F692C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F692C4: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F692C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F692CC: 4E800421  bctrl
	ctx.lr = 0x82F692D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F692D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F692D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F692D8: 48008DE9  bl 0x82f720c0
	ctx.lr = 0x82F692DC;
	sub_82F720C0(ctx, base);
	// 82F692DC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82F692E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F692E4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F692E8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F692EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F692F0: 997F009C  stb r11, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u8 ) };
	// 82F692F4: 4BFFF0AC  b 0x82f683a0
	pc = 0x82F683A0; continue 'dispatch;
	// 82F692F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F692FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69300: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F69304: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69308: 4E800421  bctrl
	ctx.lr = 0x82F6930C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6930C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F69310: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69314: 48008DAD  bl 0x82f720c0
	ctx.lr = 0x82F69318;
	sub_82F720C0(ctx, base);
	// 82F69318: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82F6931C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F69320: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F69324: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F69328: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6932C: 997F009D  stb r11, 0x9d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(157 as u32), ctx.r[11].u8 ) };
	// 82F69330: 4BFFF070  b 0x82f683a0
	pc = 0x82F683A0; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F69338 size=1932
    let mut pc: u32 = 0x82F69338;
    'dispatch: loop {
        match pc {
            0x82F69338 => {
    //   block [0x82F69338..0x82F69AC4)
	// 82F69338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6933C: 4BD400C9  bl 0x82ca9404
	ctx.lr = 0x82F69340;
	sub_82CA93D0(ctx, base);
	// 82F69340: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F69344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F69348: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6934C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F69350: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69354: 41820034  beq 0x82f69388
	if ctx.cr[0].eq {
	pc = 0x82F69388; continue 'dispatch;
	}
	// 82F69358: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F6935C: 4198000C  blt cr6, 0x82f69368
	if ctx.cr[6].lt {
	pc = 0x82F69368; continue 'dispatch;
	}
	// 82F69360: 2F1D0015  cmpwi cr6, r29, 0x15
	ctx.cr[6].compare_i32(ctx.r[29].s32, 21, &mut ctx.xer);
	// 82F69364: 40990024  ble cr6, 0x82f69388
	if !ctx.cr[6].gt {
	pc = 0x82F69388; continue 'dispatch;
	}
	// 82F69368: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6936C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F69370: 388B2984  addi r4, r11, 0x2984
	ctx.r[4].s64 = ctx.r[11].s64 + 10628;
	// 82F69374: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F69378: 4BFECC09  bl 0x82f55f80
	ctx.lr = 0x82F6937C;
	sub_82F55F80(ctx, base);
	// 82F6937C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F69380: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 82F69384: 4BD400D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
	// 82F69388: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82F6938C: 419AFFF0  beq cr6, 0x82f6937c
	if ctx.cr[6].eq {
	pc = 0x82F6937C; continue 'dispatch;
	}
	// 82F69390: 2F1D001F  cmpwi cr6, r29, 0x1f
	ctx.cr[6].compare_i32(ctx.r[29].s32, 31, &mut ctx.xer);
	// 82F69394: 4199FFE8  bgt cr6, 0x82f6937c
	if ctx.cr[6].gt {
	pc = 0x82F6937C; continue 'dispatch;
	}
	// 82F69398: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6939C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F693A0: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 82F693A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F693A8: 4E800421  bctrl
	ctx.lr = 0x82F693AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F693AC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82F693B0: 7F8BE830  slw r11, r28, r29
	if (ctx.r[29].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[28].u32) << ((ctx.r[29].u8 & 0x1F) as u32)) as u64;
	}
	// 82F693B4: 7C6B5839  and. r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F693B8: 4182FFC4  beq 0x82f6937c
	if ctx.cr[0].eq {
	pc = 0x82F6937C; continue 'dispatch;
	}
	// 82F693BC: 2B1D001F  cmplwi cr6, r29, 0x1f
	ctx.cr[6].compare_u32(ctx.r[29].u32, 31 as u32, &mut ctx.xer);
	// 82F693C0: 4199FFBC  bgt cr6, 0x82f6937c
	if ctx.cr[6].gt {
	pc = 0x82F6937C; continue 'dispatch;
	}
	// 82F693C4: 3D808204  lis r12, -0x7dfc
	ctx.r[12].s64 = -2113667072;
	// 82F693C8: 398C28C0  addi r12, r12, 0x28c0
	ctx.r[12].s64 = ctx.r[12].s64 + 10432;
	// 82F693CC: 57A0083C  slwi r0, r29, 1
	ctx.r[0].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82F693D0: 7C0C022E  lhzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82F693D4: 3D8082F7  lis r12, -0x7d09
	ctx.r[12].s64 = -2097741824;
	// 82F693D8: 398C937C  addi r12, r12, -0x6c84
	ctx.r[12].s64 = ctx.r[12].s64 + -27780;
	// 82F693DC: 7D8C0214  add r12, r12, r0
	ctx.r[12].u64 = ctx.r[12].u64 + ctx.r[0].u64;
	// 82F693E0: 7D8903A6  mtctr r12
	ctx.ctr.u64 = ctx.r[12].u64;
	// 82F693E4: 60000000  nop
	// 82F693E8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82F693EC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F693F0: 4BFA9279  bl 0x82f12668
	ctx.lr = 0x82F693F4;
	sub_82F12668(ctx, base);
	// 82F693F4: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82F693F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F693FC: 4BFFE3CD  bl 0x82f677c8
	ctx.lr = 0x82F69400;
	sub_82F677C8(ctx, base);
	// 82F69400: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F69404: E96B0002  lwa r11, 0(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i32) as i64;
	// 82F69408: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82F6940C: C9A10070  lfd f13, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82F69410: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F69414: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82F69418: C80ADDD8  lfd f0, -0x2228(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-8744 as u32) ) };
	// 82F6941C: FC2D0032  fmul f1, f13, f0
	ctx.f[1].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 82F69420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69424: 4BFA19A5  bl 0x82f0adc8
	ctx.lr = 0x82F69428;
	sub_82F0ADC8(ctx, base);
	// 82F69428: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6942C: 4BFFFF54  b 0x82f69380
	pc = 0x82F69380; continue 'dispatch;
	// 82F69430: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F69434: 4BFA9235  bl 0x82f12668
	ctx.lr = 0x82F69438;
	sub_82F12668(ctx, base);
	// 82F69438: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82F6943C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69440: 4BFFE389  bl 0x82f677c8
	ctx.lr = 0x82F69444;
	sub_82F677C8(ctx, base);
	// 82F69444: E9630006  lwa r11, 4(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as i32) as i64;
	// 82F69448: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82F6944C: C8010070  lfd f0, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82F69450: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82F69454: 4BFFFFC0  b 0x82f69414
	pc = 0x82F69414; continue 'dispatch;
	// 82F69458: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F6945C: 4BFA920D  bl 0x82f12668
	ctx.lr = 0x82F69460;
	sub_82F12668(ctx, base);
	// 82F69460: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82F69464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69468: 4BFFE361  bl 0x82f677c8
	ctx.lr = 0x82F6946C;
	sub_82F677C8(ctx, base);
	// 82F6946C: C8230008  lfd f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 82F69470: 4BFFFFB0  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F69474: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F69478: 4BFA91F1  bl 0x82f12668
	ctx.lr = 0x82F6947C;
	sub_82F12668(ctx, base);
	// 82F6947C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82F69480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69484: 4BFFE345  bl 0x82f677c8
	ctx.lr = 0x82F69488;
	sub_82F677C8(ctx, base);
	// 82F69488: C8230010  lfd f1, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 82F6948C: 4BFFFF94  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F69490: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69494: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82F69498: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6949C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82F694A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F694A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F694A8: 4E800421  bctrl
	ctx.lr = 0x82F694AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F694AC: C00100A8  lfs f0, 0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F694B0: C1A100A0  lfs f13, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F694B4: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F694B8: 4B2C2ED9  bl 0x8222c390
	ctx.lr = 0x82F694BC;
	sub_8222C390(ctx, base);
	// 82F694BC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F694C0: C80BDDD8  lfd f0, -0x2228(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8744 as u32) ) };
	// 82F694C4: FC210032  fmul f1, f1, f0
	ctx.f[1].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 82F694C8: 4BFFFF58  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F694CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F694D0: 38BF0050  addi r5, r31, 0x50
	ctx.r[5].s64 = ctx.r[31].s64 + 80;
	// 82F694D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F694D8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F694DC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F694E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F694E4: 4E800421  bctrl
	ctx.lr = 0x82F694E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F694E8: C00100BC  lfs f0, 0xbc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F694EC: C1A100B4  lfs f13, 0xb4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F694F0: 4BFFFFC4  b 0x82f694b4
	pc = 0x82F694B4; continue 'dispatch;
	// 82F694F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82F694F8: 4BFA9171  bl 0x82f12668
	ctx.lr = 0x82F694FC;
	sub_82F12668(ctx, base);
	// 82F694FC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82F69500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69504: 4BFFE2C5  bl 0x82f677c8
	ctx.lr = 0x82F69508;
	sub_82F677C8(ctx, base);
	// 82F69508: C8230018  lfd f1, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 82F6950C: 4BFFFF14  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F69510: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F69514: C1BF0048  lfs f13, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F69518: C00B0AA4  lfs f0, 0xaa4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6951C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F69520: 4BFFFF00  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F69524: 8BFF0078  lbz r31, 0x78(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F69528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6952C: 48008DF5  bl 0x82f72320
	ctx.lr = 0x82F69530;
	sub_82F72320(ctx, base);
	// 82F69530: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82F69534: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82F69538: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6953C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82F69540: 4BFFFE40  b 0x82f69380
	pc = 0x82F69380; continue 'dispatch;
	// 82F69544: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82F69548: 3D408330  lis r10, -0x7cd0
	ctx.r[10].s64 = -2094006272;
	// 82F6954C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69554: 394AEFF0  addi r10, r10, -0x1010
	ctx.r[10].s64 = ctx.r[10].s64 + -4112;
	// 82F69558: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6955C: 81290048  lwz r9, 0x48(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F69560: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F69564: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82F69568: 4E800421  bctrl
	ctx.lr = 0x82F6956C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6956C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F69570: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F69574: 386B0218  addi r3, r11, 0x218
	ctx.r[3].s64 = ctx.r[11].s64 + 536;
	// 82F69578: 48004729  bl 0x82f6dca0
	ctx.lr = 0x82F6957C;
	sub_82F6DCA0(ctx, base);
	// 82F6957C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F69580: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F69584: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82F69588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6958C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F69590: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F69594: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F69598: 4BFA17D1  bl 0x82f0ad68
	ctx.lr = 0x82F6959C;
	sub_82F0AD68(ctx, base);
	// 82F6959C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F695A0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F695A4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F695A8: 4082FE80  bne 0x82f69428
	if !ctx.cr[0].eq {
	pc = 0x82F69428; continue 'dispatch;
	}
	// 82F695AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F695B0: 480044D9  bl 0x82f6da88
	ctx.lr = 0x82F695B4;
	sub_82F6DA88(ctx, base);
	// 82F695B4: 4BFFFE74  b 0x82f69428
	pc = 0x82F69428; continue 'dispatch;
	// 82F695B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F695BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F695C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F695C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F695C8: 4E800421  bctrl
	ctx.lr = 0x82F695CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F695CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F695D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F695D4: 4BFA1795  bl 0x82f0ad68
	ctx.lr = 0x82F695D8;
	sub_82F0AD68(ctx, base);
	// 82F695D8: 4BFFFE50  b 0x82f69428
	pc = 0x82F69428; continue 'dispatch;
	// 82F695DC: 8BFF0092  lbz r31, 0x92(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(146 as u32) ) } as u64;
	// 82F695E0: 4BFFFF48  b 0x82f69528
	pc = 0x82F69528; continue 'dispatch;
	// 82F695E4: 8BFF0091  lbz r31, 0x91(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(145 as u32) ) } as u64;
	// 82F695E8: 4BFFFF40  b 0x82f69528
	pc = 0x82F69528; continue 'dispatch;
	// 82F695EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F695F0: 4BF94979  bl 0x82efdf68
	ctx.lr = 0x82F695F4;
	sub_82EFDF68(ctx, base);
	// 82F695F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F695F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F695FC: 816B0044  lwz r11, 0x44(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82F69600: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69604: 4E800421  bctrl
	ctx.lr = 0x82F69608;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69608: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82F6960C: 41820018  beq 0x82f69624
	if ctx.cr[0].eq {
	pc = 0x82F69624; continue 'dispatch;
	}
	// 82F69610: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69614: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F69618: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6961C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69620: 4E800421  bctrl
	ctx.lr = 0x82F69624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69624: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F69628: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82F6962C: 3B8B0C04  addi r28, r11, 0xc04
	ctx.r[28].s64 = ctx.r[11].s64 + 3076;
	// 82F69630: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82F69634: 419A0054  beq cr6, 0x82f69688
	if ctx.cr[6].eq {
	pc = 0x82F69688; continue 'dispatch;
	}
	// 82F69638: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6963C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F69640: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69644: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69648: 4E800421  bctrl
	ctx.lr = 0x82F6964C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6964C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F69650: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82F69654: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82F69658: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F6965C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69660: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69664: 4BF95A9D  bl 0x82eff100
	ctx.lr = 0x82F69668;
	sub_82EFF100(ctx, base);
	// 82F69668: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82F6966C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82F69670: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82F69674: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F69678: 4BF95A89  bl 0x82eff100
	ctx.lr = 0x82F6967C;
	sub_82EFF100(ctx, base);
	// 82F6967C: 83BD0028  lwz r29, 0x28(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F69680: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F69684: 409AFFAC  bne cr6, 0x82f69630
	if !ctx.cr[6].eq {
	pc = 0x82F69630; continue 'dispatch;
	}
	// 82F69688: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6968C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69690: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F69694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69698: 4E800421  bctrl
	ctx.lr = 0x82F6969C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6969C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F696A0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82F696A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F696A8: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F696AC: 388B0218  addi r4, r11, 0x218
	ctx.r[4].s64 = ctx.r[11].s64 + 536;
	// 82F696B0: 4BFA15F1  bl 0x82f0aca0
	ctx.lr = 0x82F696B4;
	sub_82F0ACA0(ctx, base);
	// 82F696B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F696B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F696BC: 4BFA16AD  bl 0x82f0ad68
	ctx.lr = 0x82F696C0;
	sub_82F0AD68(ctx, base);
	// 82F696C0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F696C4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F696C8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F696CC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F696D0: 40820008  bne 0x82f696d8
	if !ctx.cr[0].eq {
	pc = 0x82F696D8; continue 'dispatch;
	}
	// 82F696D4: 480043B5  bl 0x82f6da88
	ctx.lr = 0x82F696D8;
	sub_82F6DA88(ctx, base);
	// 82F696D8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82F696DC: 419A001C  beq cr6, 0x82f696f8
	if ctx.cr[6].eq {
	pc = 0x82F696F8; continue 'dispatch;
	}
	// 82F696E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F696E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F696E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F696EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F696F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F696F4: 4E800421  bctrl
	ctx.lr = 0x82F696F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F696F8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82F696FC: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 82F69700: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F69704: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F69708: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82F6970C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F69710: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F69714: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82F69718: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6971C: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F69720: 4082FFE8  bne 0x82f69708
	if !ctx.cr[0].eq {
	pc = 0x82F69708; continue 'dispatch;
	}
	// 82F69724: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F69728: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6972C: 4082FCFC  bne 0x82f69428
	if !ctx.cr[0].eq {
	pc = 0x82F69428; continue 'dispatch;
	}
	// 82F69730: 4BF94171  bl 0x82efd8a0
	ctx.lr = 0x82F69734;
	sub_82EFD8A0(ctx, base);
	// 82F69734: 4BFFFCF4  b 0x82f69428
	pc = 0x82F69428; continue 'dispatch;
	// 82F69738: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F6973C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69740: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F69744: 419A000C  beq cr6, 0x82f69750
	if ctx.cr[6].eq {
	pc = 0x82F69750; continue 'dispatch;
	}
	// 82F69748: 48008F89  bl 0x82f726d0
	ctx.lr = 0x82F6974C;
	sub_82F726D0(ctx, base);
	// 82F6974C: 4BFFFCDC  b 0x82f69428
	pc = 0x82F69428; continue 'dispatch;
	// 82F69750: 48008BD1  bl 0x82f72320
	ctx.lr = 0x82F69754;
	sub_82F72320(ctx, base);
	// 82F69754: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F69758: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82F6975C: 4BFFFCCC  b 0x82f69428
	pc = 0x82F69428; continue 'dispatch;
	// 82F69760: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69768: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F6976C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69770: 4E800421  bctrl
	ctx.lr = 0x82F69774;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69774: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F69778: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F6977C: 388B00D8  addi r4, r11, 0xd8
	ctx.r[4].s64 = ctx.r[11].s64 + 216;
	// 82F69780: 4BFFFE50  b 0x82f695d0
	pc = 0x82F695D0; continue 'dispatch;
	// 82F69784: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6978C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F69790: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69794: 4E800421  bctrl
	ctx.lr = 0x82F69798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69798: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6979C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F697A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F697A4: 4E800421  bctrl
	ctx.lr = 0x82F697A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F697A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F697AC: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82F697B0: 4BF947F1  bl 0x82efdfa0
	ctx.lr = 0x82F697B4;
	sub_82EFDFA0(ctx, base);
	// 82F697B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F697B8: 4BF947B1  bl 0x82efdf68
	ctx.lr = 0x82F697BC;
	sub_82EFDF68(ctx, base);
	// 82F697BC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82F697C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F697C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F697C8: 5528007F  clrlwi. r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82F697CC: 4182002C  beq 0x82f697f8
	if ctx.cr[0].eq {
	pc = 0x82F697F8; continue 'dispatch;
	}
	// 82F697D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F697D4: 88E9000C  lbz r7, 0xc(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F697D8: 2B07005C  cmplwi cr6, r7, 0x5c
	ctx.cr[6].compare_u32(ctx.r[7].u32, 92 as u32, &mut ctx.xer);
	// 82F697DC: 409A0010  bne cr6, 0x82f697ec
	if !ctx.cr[6].eq {
	pc = 0x82F697EC; continue 'dispatch;
	}
	// 82F697E0: 3960002F  li r11, 0x2f
	ctx.r[11].s64 = 47;
	// 82F697E4: 9969000C  stb r11, 0xc(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82F697E8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82F697EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F697F0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F697F4: 4198FFDC  blt cr6, 0x82f697d0
	if ctx.cr[6].lt {
	pc = 0x82F697D0; continue 'dispatch;
	}
	// 82F697F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F697FC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82F69800: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82F69804: 5544007E  clrlwi r4, r10, 1
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 82F69808: 4BFAF8C1  bl 0x82f190c8
	ctx.lr = 0x82F6980C;
	sub_82F190C8(ctx, base);
	// 82F6980C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69814: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F69818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6981C: 4E800421  bctrl
	ctx.lr = 0x82F69820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F69824: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82F69828: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6982C: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F69830: 388B0218  addi r4, r11, 0x218
	ctx.r[4].s64 = ctx.r[11].s64 + 536;
	// 82F69834: 4BFA146D  bl 0x82f0aca0
	ctx.lr = 0x82F69838;
	sub_82F0ACA0(ctx, base);
	// 82F69838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6983C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69840: 4BFA1529  bl 0x82f0ad68
	ctx.lr = 0x82F69844;
	sub_82F0AD68(ctx, base);
	// 82F69844: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F69848: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6984C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69850: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F69854: 40820008  bne 0x82f6985c
	if !ctx.cr[0].eq {
	pc = 0x82F6985C; continue 'dispatch;
	}
	// 82F69858: 48004231  bl 0x82f6da88
	ctx.lr = 0x82F6985C;
	sub_82F6DA88(ctx, base);
	// 82F6985C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82F69860: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82F69864: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F69868: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6986C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F69870: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F69874: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F69878: 7D3F5214  add r9, r31, r10
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82F6987C: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F69880: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F69884: 4082FFE8  bne 0x82f6986c
	if !ctx.cr[0].eq {
	pc = 0x82F6986C; continue 'dispatch;
	}
	// 82F69888: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6988C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69890: 40820008  bne 0x82f69898
	if !ctx.cr[0].eq {
	pc = 0x82F69898; continue 'dispatch;
	}
	// 82F69894: 4BF9400D  bl 0x82efd8a0
	ctx.lr = 0x82F69898;
	sub_82EFD8A0(ctx, base);
	// 82F69898: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82F6989C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F698A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F698A4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F698A8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F698AC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F698B0: 7D3F5214  add r9, r31, r10
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82F698B4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F698B8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F698BC: 4082FFE8  bne 0x82f698a4
	if !ctx.cr[0].eq {
	pc = 0x82F698A4; continue 'dispatch;
	}
	// 82F698C0: 4BFFFE64  b 0x82f69724
	pc = 0x82F69724; continue 'dispatch;
	// 82F698C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F698C8: 48008A59  bl 0x82f72320
	ctx.lr = 0x82F698CC;
	sub_82F72320(ctx, base);
	// 82F698CC: 9B9E0004  stb r28, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u8 ) };
	// 82F698D0: 4BFFFC64  b 0x82f69534
	pc = 0x82F69534; continue 'dispatch;
	// 82F698D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F698D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F698DC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F698E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F698E4: 4E800421  bctrl
	ctx.lr = 0x82F698E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F698E8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F698EC: 388A297C  addi r4, r10, 0x297c
	ctx.r[4].s64 = ctx.r[10].s64 + 10620;
	// 82F698F0: 4BFFFC80  b 0x82f69570
	pc = 0x82F69570; continue 'dispatch;
	// 82F698F4: 897F009C  lbz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82F698F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F698FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F69900: 41820020  beq 0x82f69920
	if ctx.cr[0].eq {
	pc = 0x82F69920; continue 'dispatch;
	}
	// 82F69904: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F69908: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6990C: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F69910: 48008A11  bl 0x82f72320
	ctx.lr = 0x82F69914;
	sub_82F72320(ctx, base);
	// 82F69914: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82F69918: 9BFE0004  stb r31, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u8 ) };
	// 82F6991C: 4BFFFE3C  b 0x82f69758
	pc = 0x82F69758; continue 'dispatch;
	// 82F69920: 48008A01  bl 0x82f72320
	ctx.lr = 0x82F69924;
	sub_82F72320(ctx, base);
	// 82F69924: 9B9E0000  stb r28, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82F69928: 4BFFFB00  b 0x82f69428
	pc = 0x82F69428; continue 'dispatch;
	// 82F6992C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F69930: C82B0D38  lfd f1, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82F69934: 4BFFFAEC  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F69938: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6993C: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82F69940: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82F69944: 3B610064  addi r27, r1, 0x64
	ctx.r[27].s64 = ctx.r[1].s64 + 100;
	// 82F69948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6994C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F69950: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69954: 4E800421  bctrl
	ctx.lr = 0x82F69958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69958: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6995C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F69960: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82F69964: 4BFCF91D  bl 0x82f39280
	ctx.lr = 0x82F69968;
	sub_82F39280(ctx, base);
	// 82F69968: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82F6996C: 4800300D  bl 0x82f6c978
	ctx.lr = 0x82F69970;
	sub_82F6C978(ctx, base);
	// 82F69970: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82F69974: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69978: 4BFFD2A1  bl 0x82f66c18
	ctx.lr = 0x82F6997C;
	sub_82F66C18(ctx, base);
	// 82F6997C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F69980: E9410066  lwa r10, 0x64(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as i32) as i64;
	// 82F69984: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82F69988: C00B0AC8  lfs f0, 0xac8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6998C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82F69990: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82F69994: E9610052  lwa r11, 0x50(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 82F69998: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82F6999C: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82F699A0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82F699A4: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82F699A8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F699AC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F699B0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F699B4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F699B8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F699BC: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82F699C0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F699C4: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82F699C8: 48003409  bl 0x82f6cdd0
	ctx.lr = 0x82F699CC;
	sub_82F6CDD0(ctx, base);
	// 82F699CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F699D0: C1A10088  lfs f13, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F699D4: C00B0AB4  lfs f0, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F699D8: 4BFFFB44  b 0x82f6951c
	pc = 0x82F6951C; continue 'dispatch;
	// 82F699DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F699E0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 82F699E4: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82F699E8: 3B610064  addi r27, r1, 0x64
	ctx.r[27].s64 = ctx.r[1].s64 + 100;
	// 82F699EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F699F0: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F699F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F699F8: 4E800421  bctrl
	ctx.lr = 0x82F699FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F699FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F69A00: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F69A04: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82F69A08: 4BFCF879  bl 0x82f39280
	ctx.lr = 0x82F69A0C;
	sub_82F39280(ctx, base);
	// 82F69A0C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82F69A10: 48002F69  bl 0x82f6c978
	ctx.lr = 0x82F69A14;
	sub_82F6C978(ctx, base);
	// 82F69A14: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82F69A18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69A1C: 4BFFD1FD  bl 0x82f66c18
	ctx.lr = 0x82F69A20;
	sub_82F66C18(ctx, base);
	// 82F69A20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F69A24: E9410052  lwa r10, 0x50(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as i32) as i64;
	// 82F69A28: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82F69A2C: C00B0AC8  lfs f0, 0xac8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F69A30: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82F69A34: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82F69A38: E9610066  lwa r11, 0x64(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as i32) as i64;
	// 82F69A3C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82F69A40: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82F69A44: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82F69A48: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82F69A4C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F69A50: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F69A54: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F69A58: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F69A5C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F69A60: D181007C  stfs f12, 0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82F69A64: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F69A68: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82F69A6C: 48003365  bl 0x82f6cdd0
	ctx.lr = 0x82F69A70;
	sub_82F6CDD0(ctx, base);
	// 82F69A70: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F69A74: C1A10094  lfs f13, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F69A78: C00B0AB4  lfs f0, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F69A7C: 4BFFFAA0  b 0x82f6951c
	pc = 0x82F6951C; continue 'dispatch;
	// 82F69A80: 897F0094  lbz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82F69A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69A88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F69A8C: 4182FCC4  beq 0x82f69750
	if ctx.cr[0].eq {
	pc = 0x82F69750; continue 'dispatch;
	}
	// 82F69A90: 4BFFFE74  b 0x82f69904
	pc = 0x82F69904; continue 'dispatch;
	// 82F69A94: E97F009A  lwa r11, 0x98(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as i32) as i64;
	// 82F69A98: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82F69A9C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82F69AA0: FC20069C  fcfid f1, f0
	ctx.f[1].f64 = (ctx.f[0].s64 as f64);
	// 82F69AA4: 4BFFF97C  b 0x82f69420
	pc = 0x82F69420; continue 'dispatch;
	// 82F69AA8: 897F009D  lbz r11, 0x9d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(157 as u32) ) } as u64;
	// 82F69AAC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F69AB0: 4182F8CC  beq 0x82f6937c
	if ctx.cr[0].eq {
	pc = 0x82F6937C; continue 'dispatch;
	}
	// 82F69AB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F69AB8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F69ABC: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F69AC0: 4BFFFA68  b 0x82f69528
	pc = 0x82F69528; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F69AC8 size=248
    let mut pc: u32 = 0x82F69AC8;
    'dispatch: loop {
        match pc {
            0x82F69AC8 => {
    //   block [0x82F69AC8..0x82F69BC0)
	// 82F69AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F69ACC: 4BD3F931  bl 0x82ca93fc
	ctx.lr = 0x82F69AD0;
	sub_82CA93D0(ctx, base);
	// 82F69AD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F69AD4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F69AD8: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69ADC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82F69AE0: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s64 = ctx.r[29].s64 * 28;
	// 82F69AE4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82F69AE8: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 82F69AEC: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F69AF0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69AF4: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F69AF8: 419A00BC  beq cr6, 0x82f69bb4
	if ctx.cr[6].eq {
	pc = 0x82F69BB4; continue 'dispatch;
	}
	// 82F69AFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69B00: 3F400002  lis r26, 2
	ctx.r[26].s64 = 131072;
	// 82F69B04: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69B08: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69B0C: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F69B10: 41980010  blt cr6, 0x82f69b20
	if ctx.cr[6].lt {
	pc = 0x82F69B20; continue 'dispatch;
	}
	// 82F69B14: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82F69B18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F69B1C: 40990008  ble cr6, 0x82f69b24
	if !ctx.cr[6].gt {
	pc = 0x82F69B24; continue 'dispatch;
	}
	// 82F69B20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F69B24: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69B28: 4182000C  beq 0x82f69b34
	if ctx.cr[0].eq {
	pc = 0x82F69B34; continue 'dispatch;
	}
	// 82F69B2C: A97F000C  lha r11, 0xc(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as i16) as i64;
	// 82F69B30: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F69B34: 7D4BE038  and r11, r10, r28
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[28].u64;
	// 82F69B38: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82F69B3C: 409A0078  bne cr6, 0x82f69bb4
	if !ctx.cr[6].eq {
	pc = 0x82F69BB4; continue 'dispatch;
	}
	// 82F69B40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69B44: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82F69B48: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69B4C: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F69B50: 41980010  blt cr6, 0x82f69b60
	if ctx.cr[6].lt {
	pc = 0x82F69B60; continue 'dispatch;
	}
	// 82F69B54: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82F69B58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F69B5C: 40990008  ble cr6, 0x82f69b64
	if !ctx.cr[6].gt {
	pc = 0x82F69B64; continue 'dispatch;
	}
	// 82F69B60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F69B64: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69B68: 4182000C  beq 0x82f69b74
	if ctx.cr[0].eq {
	pc = 0x82F69B74; continue 'dispatch;
	}
	// 82F69B6C: A9630008  lha r11, 8(r3)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F69B70: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F69B74: 7D4BE038  and r11, r10, r28
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[28].u64;
	// 82F69B78: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82F69B7C: 409A0014  bne cr6, 0x82f69b90
	if !ctx.cr[6].eq {
	pc = 0x82F69B90; continue 'dispatch;
	}
	// 82F69B80: 80990000  lwz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69B84: 4BFE94CD  bl 0x82f53050
	ctx.lr = 0x82F69B88;
	sub_82F53050(ctx, base);
	// 82F69B88: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69B8C: 40820020  bne 0x82f69bac
	if !ctx.cr[0].eq {
	pc = 0x82F69BAC; continue 'dispatch;
	}
	// 82F69B90: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69B94: 2F1BFFFF  cmpwi cr6, r27, -1
	ctx.cr[6].compare_i32(ctx.r[27].s32, -1, &mut ctx.xer);
	// 82F69B98: 419A001C  beq cr6, 0x82f69bb4
	if ctx.cr[6].eq {
	pc = 0x82F69BB4; continue 'dispatch;
	}
	// 82F69B9C: 1D7B001C  mulli r11, r27, 0x1c
	ctx.r[11].s64 = ctx.r[27].s64 * 28;
	// 82F69BA0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82F69BA4: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F69BA8: 4BFFFF98  b 0x82f69b40
	pc = 0x82F69B40; continue 'dispatch;
	// 82F69BAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F69BB0: 48000008  b 0x82f69bb8
	pc = 0x82F69BB8; continue 'dispatch;
	// 82F69BB4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F69BB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F69BBC: 4BD3F890  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F69BC0 size=20
    let mut pc: u32 = 0x82F69BC0;
    'dispatch: loop {
        match pc {
            0x82F69BC0 => {
    //   block [0x82F69BC0..0x82F69BD4)
	// 82F69BC0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69BC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82F69BC8: 409A000C  bne cr6, 0x82f69bd4
	if !ctx.cr[6].eq {
		sub_82F69BD4(ctx, base);
		return;
	}
	// 82F69BCC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F69BD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69BD4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F69BD4 size=64
    let mut pc: u32 = 0x82F69BD4;
    'dispatch: loop {
        match pc {
            0x82F69BD4 => {
    //   block [0x82F69BD4..0x82F69C14)
	// 82F69BD4: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69BD8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69BDC: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82F69BE0: 41980014  blt cr6, 0x82f69bf4
	if ctx.cr[6].lt {
	pc = 0x82F69BF4; continue 'dispatch;
	}
	// 82F69BE4: 3D000002  lis r8, 2
	ctx.r[8].s64 = 131072;
	// 82F69BE8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F69BEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F69BF0: 40990008  ble cr6, 0x82f69bf8
	if !ctx.cr[6].gt {
	pc = 0x82F69BF8; continue 'dispatch;
	}
	// 82F69BF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F69BF8: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F69BFC: 4182000C  beq 0x82f69c08
	if ctx.cr[0].eq {
	pc = 0x82F69C08; continue 'dispatch;
	}
	// 82F69C00: A9440008  lha r10, 8(r4)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F69C04: 7D4B5A78  xor r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 ^ ctx.r[11].u64;
	// 82F69C08: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69C0C: 7D455838  and r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82F69C10: 4BFFE470  b 0x82f68080
	sub_82F68080(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F69C18 size=368
    let mut pc: u32 = 0x82F69C18;
    'dispatch: loop {
        match pc {
            0x82F69C18 => {
    //   block [0x82F69C18..0x82F69D88)
	// 82F69C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F69C1C: 4BD3F7ED  bl 0x82ca9408
	ctx.lr = 0x82F69C20;
	sub_82CA93D0(ctx, base);
	// 82F69C20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F69C24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F69C28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82F69C2C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F69C30: 48000E11  bl 0x82f6aa40
	ctx.lr = 0x82F69C34;
	sub_82F6AA40(ctx, base);
	// 82F69C34: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69C38: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69C3C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69C40: 7D4AF038  and r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[30].u64;
	// 82F69C44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F69C48: 1D2A000C  mulli r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 * 12;
	// 82F69C4C: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F69C50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69C54: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F69C58: 80C90008  lwz r6, 8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69C5C: 3BC90008  addi r30, r9, 8
	ctx.r[30].s64 = ctx.r[9].s64 + 8;
	// 82F69C60: 2F06FFFE  cmpwi cr6, r6, -2
	ctx.cr[6].compare_i32(ctx.r[6].s32, -2, &mut ctx.xer);
	// 82F69C64: 409A002C  bne cr6, 0x82f69c90
	if !ctx.cr[6].eq {
	pc = 0x82F69C90; continue 'dispatch;
	}
	// 82F69C68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F69C6C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F69C70: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69C74: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F69C78: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F69C7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F69C80: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F69C84: 897C0004  lbz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69C88: 997E0008  stb r11, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82F69C8C: 480000F4  b 0x82f69d80
	pc = 0x82F69D80; continue 'dispatch;
	// 82F69C90: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69C94: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82F69C98: 393D0001  addi r9, r29, 1
	ctx.r[9].s64 = ctx.r[29].s64 + 1;
	// 82F69C9C: 7D3D3838  and r29, r9, r7
	ctx.r[29].u64 = ctx.r[9].u64 & ctx.r[7].u64;
	// 82F69CA0: 1D3D000C  mulli r9, r29, 0xc
	ctx.r[9].s64 = ctx.r[29].s64 * 12;
	// 82F69CA4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F69CA8: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69CAC: 2F09FFFE  cmpwi cr6, r9, -2
	ctx.cr[6].compare_i32(ctx.r[9].s32, -2, &mut ctx.xer);
	// 82F69CB0: 409AFFE8  bne cr6, 0x82f69c98
	if !ctx.cr[6].eq {
	pc = 0x82F69C98; continue 'dispatch;
	}
	// 82F69CB4: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69CB8: 1D3D000C  mulli r9, r29, 0xc
	ctx.r[9].s64 = ctx.r[29].s64 * 12;
	// 82F69CBC: 80A80010  lwz r5, 0x10(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F69CC0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F69CC4: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82F69CC8: 39090008  addi r8, r9, 8
	ctx.r[8].s64 = ctx.r[9].s64 + 8;
	// 82F69CCC: 7CA93838  and r9, r5, r7
	ctx.r[9].u64 = ctx.r[5].u64 & ctx.r[7].u64;
	// 82F69CD0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F69CD4: 409A004C  bne cr6, 0x82f69d20
	if !ctx.cr[6].eq {
	pc = 0x82F69D20; continue 'dispatch;
	}
	// 82F69CD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82F69CDC: 419A0024  beq cr6, 0x82f69d00
	if ctx.cr[6].eq {
	pc = 0x82F69D00; continue 'dispatch;
	}
	// 82F69CE0: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82F69CE4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69CE8: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F69CEC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F69CF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F69CF4: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F69CF8: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69CFC: 99680008  stb r11, 8(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82F69D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69D04: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69D08: 4BFA87B9  bl 0x82f124c0
	ctx.lr = 0x82F69D0C;
	sub_82F124C0(ctx, base);
	// 82F69D0C: 897C0004  lbz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69D10: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82F69D14: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F69D18: 48000068  b 0x82f69d80
	pc = 0x82F69D80; continue 'dispatch;
	// 82F69D1C: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69D20: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82F69D24: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F69D28: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82F69D2C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69D30: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82F69D34: 409AFFE8  bne cr6, 0x82f69d1c
	if !ctx.cr[6].eq {
	pc = 0x82F69D1C; continue 'dispatch;
	}
	// 82F69D38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82F69D3C: 419A0024  beq cr6, 0x82f69d60
	if ctx.cr[6].eq {
	pc = 0x82F69D60; continue 'dispatch;
	}
	// 82F69D40: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82F69D44: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69D48: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F69D4C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F69D50: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F69D54: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F69D58: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69D5C: 99680008  stb r11, 8(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82F69D60: 93A90000  stw r29, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F69D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69D68: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69D6C: 4BFA8755  bl 0x82f124c0
	ctx.lr = 0x82F69D70;
	sub_82F124C0(ctx, base);
	// 82F69D70: 895C0004  lbz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F69D74: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F69D78: 995F0004  stb r10, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82F69D7C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F69D80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F69D84: 4BD3F6D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F69D88 size=164
    let mut pc: u32 = 0x82F69D88;
    'dispatch: loop {
        match pc {
            0x82F69D88 => {
    //   block [0x82F69D88..0x82F69E2C)
	// 82F69D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F69D8C: 4BD3F681  bl 0x82ca940c
	ctx.lr = 0x82F69D90;
	sub_82CA93D0(ctx, base);
	// 82F69D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F69D94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F69D98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F69D9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F69DA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69DA4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F69DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F69DAC: 419A0008  beq cr6, 0x82f69db4
	if ctx.cr[6].eq {
	pc = 0x82F69DB4; continue 'dispatch;
	}
	// 82F69DB0: 9BBF0093  stb r29, 0x93(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(147 as u32), ctx.r[29].u8 ) };
	// 82F69DB4: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F69DB8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82F69DBC: 419A0014  beq cr6, 0x82f69dd0
	if ctx.cr[6].eq {
	pc = 0x82F69DD0; continue 'dispatch;
	}
	// 82F69DC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F69DC4: 80BF0028  lwz r5, 0x28(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F69DC8: 4BFFD8D9  bl 0x82f676a0
	ctx.lr = 0x82F69DCC;
	sub_82F676A0(ctx, base);
	// 82F69DCC: 48000058  b 0x82f69e24
	pc = 0x82F69E24; continue 'dispatch;
	// 82F69DD0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82F69DD4: 4BF93A8D  bl 0x82efd860
	ctx.lr = 0x82F69DD8;
	sub_82EFD860(ctx, base);
	// 82F69DD8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F69DDC: 41820018  beq 0x82f69df4
	if ctx.cr[0].eq {
	pc = 0x82F69DF4; continue 'dispatch;
	}
	// 82F69DE0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82F69DE4: 80BF0028  lwz r5, 0x28(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F69DE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F69DEC: 4BFFD785  bl 0x82f67570
	ctx.lr = 0x82F69DF0;
	sub_82F67570(ctx, base);
	// 82F69DF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F69DF4: 83DF008C  lwz r30, 0x8c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F69DF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F69DFC: 419A0024  beq cr6, 0x82f69e20
	if ctx.cr[6].eq {
	pc = 0x82F69E20; continue 'dispatch;
	}
	// 82F69E00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69E04: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69E08: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F69E0C: 41810014  bgt 0x82f69e20
	if ctx.cr[0].gt {
	pc = 0x82F69E20; continue 'dispatch;
	}
	// 82F69E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69E14: 4BFFD18D  bl 0x82f66fa0
	ctx.lr = 0x82F69E18;
	sub_82F66FA0(ctx, base);
	// 82F69E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69E1C: 4BF93A85  bl 0x82efd8a0
	ctx.lr = 0x82F69E20;
	sub_82EFD8A0(ctx, base);
	// 82F69E20: 93BF008C  stw r29, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82F69E24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F69E28: 4BD3F634  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F69E30 size=372
    let mut pc: u32 = 0x82F69E30;
    'dispatch: loop {
        match pc {
            0x82F69E30 => {
    //   block [0x82F69E30..0x82F69FA4)
	// 82F69E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F69E34: 4BD3F5D9  bl 0x82ca940c
	ctx.lr = 0x82F69E38;
	sub_82CA93D0(ctx, base);
	// 82F69E38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F69E3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F69E40: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F69E44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69E48: 409A0150  bne cr6, 0x82f69f98
	if !ctx.cr[6].eq {
	pc = 0x82F69F98; continue 'dispatch;
	}
	// 82F69E4C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F69E50: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F69E54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F69E58: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69E5C: 4E800421  bctrl
	ctx.lr = 0x82F69E60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69E60: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82F69E64: 409A0090  bne cr6, 0x82f69ef4
	if !ctx.cr[6].eq {
	pc = 0x82F69EF4; continue 'dispatch;
	}
	// 82F69E68: 897F01B4  lbz r11, 0x1b4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(436 as u32) ) } as u64;
	// 82F69E6C: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69E70: 41820084  beq 0x82f69ef4
	if ctx.cr[0].eq {
	pc = 0x82F69EF4; continue 'dispatch;
	}
	// 82F69E74: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82F69E78: 4BF939E9  bl 0x82efd860
	ctx.lr = 0x82F69E7C;
	sub_82EFD860(ctx, base);
	// 82F69E7C: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F69E80: 4182003C  beq 0x82f69ebc
	if ctx.cr[0].eq {
	pc = 0x82F69EBC; continue 'dispatch;
	}
	// 82F69E84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69E8C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F69E90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69E94: 4E800421  bctrl
	ctx.lr = 0x82F69E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69E98: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F69E9C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F69EA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82F69EA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69EA8: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F69EAC: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82F69EB0: 4BFFD6C1  bl 0x82f67570
	ctx.lr = 0x82F69EB4;
	sub_82F67570(ctx, base);
	// 82F69EB4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F69EB8: 48000008  b 0x82f69ec0
	pc = 0x82F69EC0; continue 'dispatch;
	// 82F69EBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F69EC0: 83DF008C  lwz r30, 0x8c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F69EC4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F69EC8: 419A0024  beq cr6, 0x82f69eec
	if ctx.cr[6].eq {
	pc = 0x82F69EEC; continue 'dispatch;
	}
	// 82F69ECC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69ED0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69ED4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F69ED8: 41810014  bgt 0x82f69eec
	if ctx.cr[0].gt {
	pc = 0x82F69EEC; continue 'dispatch;
	}
	// 82F69EDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69EE0: 4BFFD0C1  bl 0x82f66fa0
	ctx.lr = 0x82F69EE4;
	sub_82F66FA0(ctx, base);
	// 82F69EE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69EE8: 4BF939B9  bl 0x82efd8a0
	ctx.lr = 0x82F69EEC;
	sub_82EFD8A0(ctx, base);
	// 82F69EEC: 93BF008C  stw r29, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82F69EF0: 480000A8  b 0x82f69f98
	pc = 0x82F69F98; continue 'dispatch;
	// 82F69EF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F69EFC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F69F00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69F04: 4E800421  bctrl
	ctx.lr = 0x82F69F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69F08: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F69F0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F69F10: 4BFCFCD9  bl 0x82f39be8
	ctx.lr = 0x82F69F14;
	sub_82F39BE8(ctx, base);
	// 82F69F14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82F69F18: 4BF93949  bl 0x82efd860
	ctx.lr = 0x82F69F1C;
	sub_82EFD860(ctx, base);
	// 82F69F1C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F69F20: 4182001C  beq 0x82f69f3c
	if ctx.cr[0].eq {
	pc = 0x82F69F3C; continue 'dispatch;
	}
	// 82F69F24: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82F69F28: 80BF0028  lwz r5, 0x28(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F69F2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F69F30: 4BFFD641  bl 0x82f67570
	ctx.lr = 0x82F69F34;
	sub_82F67570(ctx, base);
	// 82F69F34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F69F38: 48000008  b 0x82f69f40
	pc = 0x82F69F40; continue 'dispatch;
	// 82F69F3C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F69F40: 83DF008C  lwz r30, 0x8c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F69F44: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F69F48: 419A0024  beq cr6, 0x82f69f6c
	if ctx.cr[6].eq {
	pc = 0x82F69F6C; continue 'dispatch;
	}
	// 82F69F4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69F50: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F69F54: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F69F58: 41810014  bgt 0x82f69f6c
	if ctx.cr[0].gt {
	pc = 0x82F69F6C; continue 'dispatch;
	}
	// 82F69F5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69F60: 4BFFD041  bl 0x82f66fa0
	ctx.lr = 0x82F69F64;
	sub_82F66FA0(ctx, base);
	// 82F69F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F69F68: 4BF93939  bl 0x82efd8a0
	ctx.lr = 0x82F69F6C;
	sub_82EFD8A0(ctx, base);
	// 82F69F6C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F69F70: 93BF008C  stw r29, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 82F69F74: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F69F78: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F69F7C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F69F80: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F69F84: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F69F88: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F69F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F69F90: 409A0008  bne cr6, 0x82f69f98
	if !ctx.cr[6].eq {
	pc = 0x82F69F98; continue 'dispatch;
	}
	// 82F69F94: 48003AF5  bl 0x82f6da88
	ctx.lr = 0x82F69F98;
	sub_82F6DA88(ctx, base);
	// 82F69F98: 807F008C  lwz r3, 0x8c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F69F9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F69FA0: 4BD3F4BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F69FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F69FA8 size=524
    let mut pc: u32 = 0x82F69FA8;
    'dispatch: loop {
        match pc {
            0x82F69FA8 => {
    //   block [0x82F69FA8..0x82F6A1B4)
	// 82F69FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F69FAC: 4BD3F461  bl 0x82ca940c
	ctx.lr = 0x82F69FB0;
	sub_82CA93D0(ctx, base);
	// 82F69FB0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82F69FB4: 4BD43D1D  bl 0x82cadcd0
	ctx.lr = 0x82F69FB8;
	sub_82CADCA0(ctx, base);
	// 82F69FB8: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F69FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F69FC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F69FC4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F69FC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F69FCC: 4E800421  bctrl
	ctx.lr = 0x82F69FD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F69FD0: 39630164  addi r11, r3, 0x164
	ctx.r[11].s64 = ctx.r[3].s64 + 356;
	// 82F69FD4: 81630164  lwz r11, 0x164(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) } as u64;
	// 82F69FD8: C383016C  lfs f28, 0x16c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(364 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82F69FDC: 8BA30169  lbz r29, 0x169(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(361 as u32) ) } as u64;
	// 82F69FE0: C3430170  lfs f26, 0x170(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(368 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82F69FE4: C3A30174  lfs f29, 0x174(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(372 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82F69FE8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F69FEC: C3630178  lfs f27, 0x178(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(376 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82F69FF0: C3E3017C  lfs f31, 0x17c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(380 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82F69FF4: C3C30180  lfs f30, 0x180(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(384 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82F69FF8: 409A01AC  bne cr6, 0x82f6a1a4
	if !ctx.cr[6].eq {
	pc = 0x82F6A1A4; continue 'dispatch;
	}
	// 82F69FFC: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 82F6A000: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82F6A004: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F6A008: 4BFCF279  bl 0x82f39280
	ctx.lr = 0x82F6A00C;
	sub_82F39280(ctx, base);
	// 82F6A00C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6A010: E941005A  lwa r10, 0x58(r1)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as i32) as i64;
	// 82F6A014: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F6A018: C00B0AC8  lfs f0, 0xac8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6A01C: E961006A  lwa r11, 0x68(r1)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as i32) as i64;
	// 82F6A020: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82F6A024: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82F6A028: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82F6A02C: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82F6A030: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82F6A034: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82F6A038: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82F6A03C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82F6A040: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6A044: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82F6A048: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6A04C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82F6A050: 48002929  bl 0x82f6c978
	ctx.lr = 0x82F6A054;
	sub_82F6C978(ctx, base);
	// 82F6A054: 83DF0028  lwz r30, 0x28(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F6A058: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6A05C: 419A0024  beq cr6, 0x82f6a080
	if ctx.cr[6].eq {
	pc = 0x82F6A080; continue 'dispatch;
	}
	// 82F6A060: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F6A064: 48002915  bl 0x82f6c978
	ctx.lr = 0x82F6A068;
	sub_82F6C978(ctx, base);
	// 82F6A068: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82F6A06C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6A070: 4BFFCBA9  bl 0x82f66c18
	ctx.lr = 0x82F6A074;
	sub_82F66C18(ctx, base);
	// 82F6A074: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82F6A078: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F6A07C: 4800277D  bl 0x82f6c7f8
	ctx.lr = 0x82F6A080;
	sub_82F6C7F8(ctx, base);
	// 82F6A080: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82F6A084: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6A088: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82F6A08C: 48002D45  bl 0x82f6cdd0
	ctx.lr = 0x82F6A090;
	sub_82F6CDD0(ctx, base);
	// 82F6A090: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6A094: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6A098: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 82F6A09C: EDBE682A  fadds f13, f30, f13
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64;
	// 82F6A0A0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F6A0A4: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F6A0A8: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6A0AC: 4182004C  beq 0x82f6a0f8
	if ctx.cr[0].eq {
	pc = 0x82F6A0F8; continue 'dispatch;
	}
	// 82F6A0B0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82F6A0B4: 41980008  blt cr6, 0x82f6a0bc
	if ctx.cr[6].lt {
	pc = 0x82F6A0BC; continue 'dispatch;
	}
	// 82F6A0B8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82F6A0BC: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82F6A0C0: 4098000C  bge cr6, 0x82f6a0cc
	if !ctx.cr[6].lt {
	pc = 0x82F6A0CC; continue 'dispatch;
	}
	// 82F6A0C4: D3810050  stfs f28, 0x50(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F6A0C8: 48000008  b 0x82f6a0d0
	pc = 0x82F6A0D0; continue 'dispatch;
	// 82F6A0CC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F6A0D0: FF0DD800  fcmpu cr6, f13, f27
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[27].f64);
	// 82F6A0D4: 4098000C  bge cr6, 0x82f6a0e0
	if !ctx.cr[6].lt {
	pc = 0x82F6A0E0; continue 'dispatch;
	}
	// 82F6A0D8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82F6A0DC: 48000008  b 0x82f6a0e4
	pc = 0x82F6A0E4; continue 'dispatch;
	// 82F6A0E0: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82F6A0E4: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82F6A0E8: 4098000C  bge cr6, 0x82f6a0f4
	if !ctx.cr[6].lt {
	pc = 0x82F6A0F4; continue 'dispatch;
	}
	// 82F6A0EC: D3410054  stfs f26, 0x54(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F6A0F0: 48000008  b 0x82f6a0f8
	pc = 0x82F6A0F8; continue 'dispatch;
	// 82F6A0F4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F6A0F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A0FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A104: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6A108: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A10C: 4E800421  bctrl
	ctx.lr = 0x82F6A110;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A110: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F6A114: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6A118: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 82F6A11C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F6A120: 9BC10090  stb r30, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u8 ) };
	// 82F6A124: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82F6A128: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A12C: CBEBDDD8  lfd f31, -0x2228(r11)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8744 as u32) ) };
	// 82F6A130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A134: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 82F6A138: D8010098  stfd f0, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.f[0].u64 ) };
	// 82F6A13C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A140: 816B00D8  lwz r11, 0xd8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 82F6A144: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A148: 4E800421  bctrl
	ctx.lr = 0x82F6A14C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A14C: 89610090  lbz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F6A150: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6A154: 4198000C  blt cr6, 0x82f6a160
	if ctx.cr[6].lt {
	pc = 0x82F6A160; continue 'dispatch;
	}
	// 82F6A158: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F6A15C: 480081C5  bl 0x82f72320
	ctx.lr = 0x82F6A160;
	sub_82F72320(ctx, base);
	// 82F6A160: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A164: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6A168: FC0007F2  fmul f0, f0, f31
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[31].f64;
	// 82F6A16C: D8010088  stfd f0, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[0].u64 ) };
	// 82F6A170: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F6A174: 9BC10080  stb r30, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 82F6A178: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82F6A17C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F6A180: 816B00D8  lwz r11, 0xd8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 82F6A184: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A188: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A18C: 4E800421  bctrl
	ctx.lr = 0x82F6A190;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A190: 89610080  lbz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6A194: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6A198: 4198000C  blt cr6, 0x82f6a1a4
	if ctx.cr[6].lt {
	pc = 0x82F6A1A4; continue 'dispatch;
	}
	// 82F6A19C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82F6A1A0: 48008181  bl 0x82f72320
	ctx.lr = 0x82F6A1A4;
	sub_82F72320(ctx, base);
	// 82F6A1A4: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82F6A1A8: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82F6A1AC: 4BD43B71  bl 0x82cadd1c
	ctx.lr = 0x82F6A1B0;
	sub_82CADCEC(ctx, base);
	// 82F6A1B0: 4BD3F2AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A1B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6A1B8 size=24
    let mut pc: u32 = 0x82F6A1B8;
    'dispatch: loop {
        match pc {
            0x82F6A1B8 => {
    //   block [0x82F6A1B8..0x82F6A1D0)
	// 82F6A1B8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A1BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6A1C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6A1C4: 409A000C  bne cr6, 0x82f6a1d0
	if !ctx.cr[6].eq {
		sub_82F6A1D0(ctx, base);
		return;
	}
	// 82F6A1C8: 9161FFF0  stw r11, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 82F6A1CC: 4800002C  b 0x82f6a1f8
	sub_82F6A1D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A1D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6A1D0 size=56
    let mut pc: u32 = 0x82F6A1D0;
    'dispatch: loop {
        match pc {
            0x82F6A1D0 => {
    //   block [0x82F6A1D0..0x82F6A208)
	// 82F6A1D0: 392A0008  addi r9, r10, 8
	ctx.r[9].s64 = ctx.r[10].s64 + 8;
	// 82F6A1D4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A1D8: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82F6A1DC: 409A0018  bne cr6, 0x82f6a1f4
	if !ctx.cr[6].eq {
	pc = 0x82F6A1F4; continue 'dispatch;
	}
	// 82F6A1E0: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A1E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6A1E8: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 82F6A1EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82F6A1F0: 4099FFE4  ble cr6, 0x82f6a1d4
	if !ctx.cr[6].gt {
	pc = 0x82F6A1D4; continue 'dispatch;
	}
	// 82F6A1F4: 9081FFF0  stw r4, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u32 ) };
	// 82F6A1F8: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82F6A1FC: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A200: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82F6A204: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A208 size=108
    let mut pc: u32 = 0x82F6A208;
    'dispatch: loop {
        match pc {
            0x82F6A208 => {
    //   block [0x82F6A208..0x82F6A274)
	// 82F6A208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A210: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A214: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A21C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6A224: 419A0038  beq cr6, 0x82f6a25c
	if ctx.cr[6].eq {
	pc = 0x82F6A25C; continue 'dispatch;
	}
	// 82F6A228: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A22C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A230: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A234: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6A238: 7D455838  and r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82F6A23C: 4BFFDFBD  bl 0x82f681f8
	ctx.lr = 0x82F6A240;
	sub_82F681F8(ctx, base);
	// 82F6A240: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F6A244: 41800018  blt 0x82f6a25c
	if ctx.cr[0].lt {
	pc = 0x82F6A25C; continue 'dispatch;
	}
	// 82F6A248: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 82F6A24C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A250: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 * 12;
	// 82F6A254: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6A258: 48000008  b 0x82f6a260
	pc = 0x82F6A260; continue 'dispatch;
	// 82F6A25C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6A260: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6A264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A26C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A270: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A278 size=88
    let mut pc: u32 = 0x82F6A278;
    'dispatch: loop {
        match pc {
            0x82F6A278 => {
    //   block [0x82F6A278..0x82F6A2D0)
	// 82F6A278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A27C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A280: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A284: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A288: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A28C: 4BFFFBA5  bl 0x82f69e30
	ctx.lr = 0x82F6A290;
	sub_82F69E30(ctx, base);
	// 82F6A290: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6A294: 4182000C  beq 0x82f6a2a0
	if ctx.cr[0].eq {
	pc = 0x82F6A2A0; continue 'dispatch;
	}
	// 82F6A298: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 82F6A29C: 48000020  b 0x82f6a2bc
	pc = 0x82F6A2BC; continue 'dispatch;
	// 82F6A2A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A2A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A2A8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82F6A2AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A2B0: 4E800421  bctrl
	ctx.lr = 0x82F6A2B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A2B4: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F6A2B8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82F6A2BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6A2C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A2C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A2C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A2CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A2D0 size=92
    let mut pc: u32 = 0x82F6A2D0;
    'dispatch: loop {
        match pc {
            0x82F6A2D0 => {
    //   block [0x82F6A2D0..0x82F6A32C)
	// 82F6A2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A2D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A2DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A2E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A2E4: 4BFFF8DD  bl 0x82f69bc0
	ctx.lr = 0x82F6A2E8;
	sub_82F69BC0(ctx, base);
	// 82F6A2E8: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F6A2EC: 41800018  blt 0x82f6a304
	if ctx.cr[0].lt {
	pc = 0x82F6A304; continue 'dispatch;
	}
	// 82F6A2F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A2F4: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 82F6A2F8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6A2FC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82F6A300: 48000008  b 0x82f6a308
	pc = 0x82F6A308; continue 'dispatch;
	// 82F6A304: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6A308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6A30C: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82F6A310: 409A0008  bne cr6, 0x82f6a318
	if !ctx.cr[6].eq {
	pc = 0x82F6A318; continue 'dispatch;
	}
	// 82F6A314: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6A318: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6A31C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A324: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A330 size=84
    let mut pc: u32 = 0x82F6A330;
    'dispatch: loop {
        match pc {
            0x82F6A330 => {
    //   block [0x82F6A330..0x82F6A384)
	// 82F6A330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A338: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A33C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A340: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6A344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A348: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82F6A34C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F6A350: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A354: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6A358: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A35C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6A360: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A364: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6A368: 4BFD3071  bl 0x82f3d3d8
	ctx.lr = 0x82F6A36C;
	sub_82F3D3D8(ctx, base);
	// 82F6A36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A370: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6A374: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A378: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A37C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A380: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A388 size=116
    let mut pc: u32 = 0x82F6A388;
    'dispatch: loop {
        match pc {
            0x82F6A388 => {
    //   block [0x82F6A388..0x82F6A3FC)
	// 82F6A388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A38C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A390: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A394: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A398: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82F6A39C: 419A0020  beq cr6, 0x82f6a3bc
	if ctx.cr[6].eq {
	pc = 0x82F6A3BC; continue 'dispatch;
	}
	// 82F6A3A0: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 82F6A3A4: 419A0018  beq cr6, 0x82f6a3bc
	if ctx.cr[6].eq {
	pc = 0x82F6A3BC; continue 'dispatch;
	}
	// 82F6A3A8: 81240008  lwz r9, 8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A3AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6A3B0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A3B4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82F6A3B8: 48000014  b 0x82f6a3cc
	pc = 0x82F6A3CC; continue 'dispatch;
	// 82F6A3BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6A3C0: B1410058  sth r10, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u16 ) };
	// 82F6A3C4: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 82F6A3C8: 9941005B  stb r10, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[10].u8 ) };
	// 82F6A3CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82F6A3D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6A3D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6A3D8: 386300A0  addi r3, r3, 0xa0
	ctx.r[3].s64 = ctx.r[3].s64 + 160;
	// 82F6A3DC: 4BFFFEF5  bl 0x82f6a2d0
	ctx.lr = 0x82F6A3E0;
	sub_82F6A2D0(ctx, base);
	// 82F6A3E0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82F6A3E4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6A3E8: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82F6A3EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6A3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A400 size=232
    let mut pc: u32 = 0x82F6A400;
    'dispatch: loop {
        match pc {
            0x82F6A400 => {
    //   block [0x82F6A400..0x82F6A4E8)
	// 82F6A400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A404: 4BD3EFF9  bl 0x82ca93fc
	ctx.lr = 0x82F6A408;
	sub_82CA93D0(ctx, base);
	// 82F6A408: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A40C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A410: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82F6A414: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82F6A418: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82F6A41C: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82F6A420: 419A0024  beq cr6, 0x82f6a444
	if ctx.cr[6].eq {
	pc = 0x82F6A444; continue 'dispatch;
	}
	// 82F6A424: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 82F6A428: 419A001C  beq cr6, 0x82f6a444
	if ctx.cr[6].eq {
	pc = 0x82F6A444; continue 'dispatch;
	}
	// 82F6A42C: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A430: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6A434: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A438: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82F6A43C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82F6A440: 48000014  b 0x82f6a454
	pc = 0x82F6A454; continue 'dispatch;
	// 82F6A444: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82F6A448: B3210058  sth r25, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u16 ) };
	// 82F6A44C: 9B21005A  stb r25, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[25].u8 ) };
	// 82F6A450: 9B21005B  stb r25, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[25].u8 ) };
	// 82F6A454: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6A458: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6A45C: 387A00A0  addi r3, r26, 0xa0
	ctx.r[3].s64 = ctx.r[26].s64 + 160;
	// 82F6A460: 4BFFFE71  bl 0x82f6a2d0
	ctx.lr = 0x82F6A464;
	sub_82F6A2D0(ctx, base);
	// 82F6A464: 7C7B1B79  or. r27, r3, r3
	ctx.r[27].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82F6A468: 41820074  beq 0x82f6a4dc
	if ctx.cr[0].eq {
	pc = 0x82F6A4DC; continue 'dispatch;
	}
	// 82F6A46C: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A470: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6A474: 419A0060  beq cr6, 0x82f6a4d4
	if ctx.cr[6].eq {
	pc = 0x82F6A4D4; continue 'dispatch;
	}
	// 82F6A478: 3BBC0008  addi r29, r28, 8
	ctx.r[29].s64 = ctx.r[28].s64 + 8;
	// 82F6A47C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82F6A480: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A484: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82F6A488: 38BA0080  addi r5, r26, 0x80
	ctx.r[5].s64 = ctx.r[26].s64 + 128;
	// 82F6A48C: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82F6A490: 409A0008  bne cr6, 0x82f6a498
	if !ctx.cr[6].eq {
	pc = 0x82F6A498; continue 'dispatch;
	}
	// 82F6A494: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82F6A498: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A49C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82F6A4A0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A4A4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F6A4A8: 813D0014  lwz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6A4AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A4B0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82F6A4B4: 552A2834  slwi r10, r9, 5
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6A4B8: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82F6A4BC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6A4C0: 390BFFE1  addi r8, r11, -0x1f
	ctx.r[8].s64 = ctx.r[11].s64 + -31;
	// 82F6A4C4: 4BFB2025  bl 0x82f1c4e8
	ctx.lr = 0x82F6A4C8;
	sub_82F1C4E8(ctx, base);
	// 82F6A4C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6A4CC: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82F6A4D0: 4082FFB0  bne 0x82f6a480
	if !ctx.cr[0].eq {
	pc = 0x82F6A480; continue 'dispatch;
	}
	// 82F6A4D4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6A4D8: 48000008  b 0x82f6a4e0
	pc = 0x82F6A4E0; continue 'dispatch;
	// 82F6A4DC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6A4E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6A4E4: 4BD3EF68  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A4E8 size=564
    let mut pc: u32 = 0x82F6A4E8;
    'dispatch: loop {
        match pc {
            0x82F6A4E8 => {
    //   block [0x82F6A4E8..0x82F6A71C)
	// 82F6A4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A4EC: 4BD3EF15  bl 0x82ca9400
	ctx.lr = 0x82F6A4F0;
	sub_82CA93D0(ctx, base);
	// 82F6A4F0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A4F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6A4F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6A4FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82F6A500: 419A0014  beq cr6, 0x82f6a514
	if ctx.cr[6].eq {
	pc = 0x82F6A514; continue 'dispatch;
	}
	// 82F6A504: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A508: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A50C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A510: 4E800421  bctrl
	ctx.lr = 0x82F6A514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A514: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A518: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6A51C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F6A520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A524: 4E800421  bctrl
	ctx.lr = 0x82F6A528;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A528: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A52C: 835F0074  lwz r26, 0x74(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 82F6A530: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82F6A534: 419A0018  beq cr6, 0x82f6a54c
	if ctx.cr[6].eq {
	pc = 0x82F6A54C; continue 'dispatch;
	}
	// 82F6A538: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A53C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82F6A540: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A548: 4E800421  bctrl
	ctx.lr = 0x82F6A54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A54C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82F6A550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6A554: 9B610080  stb r27, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u8 ) };
	// 82F6A558: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6A55C: 4BFFFE2D  bl 0x82f6a388
	ctx.lr = 0x82F6A560;
	sub_82F6A388(ctx, base);
	// 82F6A560: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6A564: 41820018  beq 0x82f6a57c
	if ctx.cr[0].eq {
	pc = 0x82F6A57C; continue 'dispatch;
	}
	// 82F6A568: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F6A56C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6A570: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6A574: 4BFFFE8D  bl 0x82f6a400
	ctx.lr = 0x82F6A578;
	sub_82F6A400(ctx, base);
	// 82F6A578: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82F6A57C: 3BBF0078  addi r29, r31, 0x78
	ctx.r[29].s64 = ctx.r[31].s64 + 120;
	// 82F6A580: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6A584: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F6A588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6A58C: 4BFAF105  bl 0x82f19690
	ctx.lr = 0x82F6A590;
	sub_82F19690(ctx, base);
	// 82F6A590: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A594: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6A598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6A59C: 40990104  ble cr6, 0x82f6a6a0
	if !ctx.cr[6].gt {
	pc = 0x82F6A6A0; continue 'dispatch;
	}
	// 82F6A5A0: 817C0080  lwz r11, 0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6A5A4: 3BDC0080  addi r30, r28, 0x80
	ctx.r[30].s64 = ctx.r[28].s64 + 128;
	// 82F6A5A8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82F6A5AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6A5B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6A5B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6A5B8: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6A5BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A5C0: 4E800421  bctrl
	ctx.lr = 0x82F6A5C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A5C4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6A5C8: 418200D4  beq 0x82f6a69c
	if ctx.cr[0].eq {
	pc = 0x82F6A69C; continue 'dispatch;
	}
	// 82F6A5CC: 89610080  lbz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6A5D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82F6A5D4: 419A00C4  beq cr6, 0x82f6a698
	if ctx.cr[6].eq {
	pc = 0x82F6A698; continue 'dispatch;
	}
	// 82F6A5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A5DC: 4BFAED4D  bl 0x82f19328
	ctx.lr = 0x82F6A5E0;
	sub_82F19328(ctx, base);
	// 82F6A5E0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6A5E4: 41820038  beq 0x82f6a61c
	if ctx.cr[0].eq {
	pc = 0x82F6A61C; continue 'dispatch;
	}
	// 82F6A5E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82F6A5EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6A5F0: 48007121  bl 0x82f71710
	ctx.lr = 0x82F6A5F4;
	sub_82F71710(ctx, base);
	// 82F6A5F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A5F8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F6A5FC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6A600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A604: 388929DC  addi r4, r9, 0x29dc
	ctx.r[4].s64 = ctx.r[9].s64 + 10716;
	// 82F6A608: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A60C: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A610: 4BFB17C9  bl 0x82f1bdd8
	ctx.lr = 0x82F6A614;
	sub_82F1BDD8(ctx, base);
	// 82F6A614: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6A618: 48004289  bl 0x82f6e8a0
	ctx.lr = 0x82F6A61C;
	sub_82F6E8A0(ctx, base);
	// 82F6A61C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A620: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82F6A624: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6A628: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82F6A62C: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F6A630: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F6A634: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82F6A638: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6A63C: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82F6A640: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A644: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6A648: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82F6A64C: 390BFFE1  addi r8, r11, -0x1f
	ctx.r[8].s64 = ctx.r[11].s64 + -31;
	// 82F6A650: 4BFB1E99  bl 0x82f1c4e8
	ctx.lr = 0x82F6A654;
	sub_82F1C4E8(ctx, base);
	// 82F6A654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A658: 4BFAECD1  bl 0x82f19328
	ctx.lr = 0x82F6A65C;
	sub_82F19328(ctx, base);
	// 82F6A65C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6A660: 41820038  beq 0x82f6a698
	if ctx.cr[0].eq {
	pc = 0x82F6A698; continue 'dispatch;
	}
	// 82F6A664: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82F6A668: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F6A66C: 480070A5  bl 0x82f71710
	ctx.lr = 0x82F6A670;
	sub_82F71710(ctx, base);
	// 82F6A670: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A674: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F6A678: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6A67C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A680: 388929B4  addi r4, r9, 0x29b4
	ctx.r[4].s64 = ctx.r[9].s64 + 10676;
	// 82F6A684: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A688: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A68C: 4BFB174D  bl 0x82f1bdd8
	ctx.lr = 0x82F6A690;
	sub_82F1BDD8(ctx, base);
	// 82F6A690: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F6A694: 4800420D  bl 0x82f6e8a0
	ctx.lr = 0x82F6A698;
	sub_82F6E8A0(ctx, base);
	// 82F6A698: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82F6A69C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A6A0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6A6A4: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F6A6A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6A6AC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F6A6B0: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F6A6B4: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6A6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6A6BC: 409A0008  bne cr6, 0x82f6a6c4
	if !ctx.cr[6].eq {
	pc = 0x82F6A6C4; continue 'dispatch;
	}
	// 82F6A6C0: 480033C9  bl 0x82f6da88
	ctx.lr = 0x82F6A6C4;
	sub_82F6DA88(ctx, base);
	// 82F6A6C4: 89610080  lbz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6A6C8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6A6CC: 4198000C  blt cr6, 0x82f6a6d8
	if ctx.cr[6].lt {
	pc = 0x82F6A6D8; continue 'dispatch;
	}
	// 82F6A6D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82F6A6D4: 48007C4D  bl 0x82f72320
	ctx.lr = 0x82F6A6D8;
	sub_82F72320(ctx, base);
	// 82F6A6D8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82F6A6DC: 419A001C  beq cr6, 0x82f6a6f8
	if ctx.cr[6].eq {
	pc = 0x82F6A6F8; continue 'dispatch;
	}
	// 82F6A6E0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A6E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A6E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82F6A6EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A6F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A6F4: 4E800421  bctrl
	ctx.lr = 0x82F6A6F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A6F8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A6FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A700: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6A704: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6A70C: 4E800421  bctrl
	ctx.lr = 0x82F6A710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6A710: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F6A714: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82F6A718: 4BD3ED38  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A720 size=136
    let mut pc: u32 = 0x82F6A720;
    'dispatch: loop {
        match pc {
            0x82F6A720 => {
    //   block [0x82F6A720..0x82F6A7A8)
	// 82F6A720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A728: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6A72C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A730: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A734: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6A738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6A73C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6A740: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A744: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6A748: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A74C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A750: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6A754: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F6A758: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A75C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A760: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6A764: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F6A768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6A76C: 40990018  ble cr6, 0x82f6a784
	if !ctx.cr[6].gt {
	pc = 0x82F6A784; continue 'dispatch;
	}
	// 82F6A770: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82F6A774: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F6A778: 4BFE0659  bl 0x82f4add0
	ctx.lr = 0x82F6A77C;
	sub_82F4ADD0(ctx, base);
	// 82F6A77C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6A780: 4805BBB1  bl 0x82fc6330
	ctx.lr = 0x82F6A784;
	sub_82FC6330(ctx, base);
	// 82F6A784: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A788: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6A78C: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82F6A790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6A794: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A798: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A79C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6A7A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A7A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A7A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A7A8 size=96
    let mut pc: u32 = 0x82F6A7A8;
    'dispatch: loop {
        match pc {
            0x82F6A7A8 => {
    //   block [0x82F6A7A8..0x82F6A808)
	// 82F6A7A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A7AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A7B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A7B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A7B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A7BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6A7C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6A7C4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6A7C8: 48000020  b 0x82f6a7e8
	pc = 0x82F6A7E8; continue 'dispatch;
	// 82F6A7CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6A7D0: 81440010  lwz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6A7D4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82F6A7D8: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 82F6A7DC: 40990018  ble cr6, 0x82f6a7f4
	if !ctx.cr[6].gt {
	pc = 0x82F6A7F4; continue 'dispatch;
	}
	// 82F6A7E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A7E4: 4BFFFF3D  bl 0x82f6a720
	ctx.lr = 0x82F6A7E8;
	sub_82F6A720(ctx, base);
	// 82F6A7E8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A7EC: 7F04F840  cmplw cr6, r4, r31
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F6A7F0: 409AFFDC  bne cr6, 0x82f6a7cc
	if !ctx.cr[6].eq {
	pc = 0x82F6A7CC; continue 'dispatch;
	}
	// 82F6A7F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6A7F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A7FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A808 size=124
    let mut pc: u32 = 0x82F6A808;
    'dispatch: loop {
        match pc {
            0x82F6A808 => {
    //   block [0x82F6A808..0x82F6A884)
	// 82F6A808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6A814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A81C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A820: 80640000  lwz r3, 0(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A824: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6A828: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82F6A82C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6A834: 409A0008  bne cr6, 0x82f6a83c
	if !ctx.cr[6].eq {
	pc = 0x82F6A83C; continue 'dispatch;
	}
	// 82F6A838: 48003979  bl 0x82f6e1b0
	ctx.lr = 0x82F6A83C;
	sub_82F6E1B0(ctx, base);
	// 82F6A83C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6A840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6A844: 4BFFF9C5  bl 0x82f6a208
	ctx.lr = 0x82F6A848;
	sub_82F6A208(ctx, base);
	// 82F6A848: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6A84C: 4182001C  beq 0x82f6a868
	if ctx.cr[0].eq {
	pc = 0x82F6A868; continue 'dispatch;
	}
	// 82F6A850: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6A854: 419A000C  beq cr6, 0x82f6a860
	if ctx.cr[6].eq {
	pc = 0x82F6A860; continue 'dispatch;
	}
	// 82F6A858: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A85C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82F6A860: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6A864: 48000008  b 0x82f6a86c
	pc = 0x82F6A86C; continue 'dispatch;
	// 82F6A868: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6A86C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6A870: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6A874: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6A878: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6A87C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6A880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6A888 size=332
    let mut pc: u32 = 0x82F6A888;
    'dispatch: loop {
        match pc {
            0x82F6A888 => {
    //   block [0x82F6A888..0x82F6A9D4)
	// 82F6A888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A88C: 4BD3EB71  bl 0x82ca93fc
	ctx.lr = 0x82F6A890;
	sub_82CA93D0(ctx, base);
	// 82F6A890: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A894: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82F6A898: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6A89C: 409A0008  bne cr6, 0x82f6a8a4
	if !ctx.cr[6].eq {
	pc = 0x82F6A8A4; continue 'dispatch;
	}
	// 82F6A8A0: 48000128  b 0x82f6a9c8
	pc = 0x82F6A9C8; continue 'dispatch;
	// 82F6A8A4: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82F6A8A8: 4098000C  bge cr6, 0x82f6a8b4
	if !ctx.cr[6].lt {
	pc = 0x82F6A8B4; continue 'dispatch;
	}
	// 82F6A8AC: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82F6A8B0: 4800004C  b 0x82f6a8fc
	pc = 0x82F6A8FC; continue 'dispatch;
	// 82F6A8B4: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82F6A8B8: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82F6A8BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F6A8C0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6A8C4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F6A8C8: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F6A8CC: 4B2894E5  bl 0x821f3db0
	ctx.lr = 0x82F6A8D0;
	sub_821F3DB0(ctx, base);
	// 82F6A8D0: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F6A8D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F6A8D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F6A8DC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F6A8E0: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6A8E4: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6A8E8: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F6A8EC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F6A8F0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82F6A8F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6A8F8: 7D3F5830  slw r31, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82F6A8FC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82F6A900: 1D7F000C  mulli r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 * 12;
	// 82F6A904: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82F6A908: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82F6A90C: 4BF92F55  bl 0x82efd860
	ctx.lr = 0x82F6A910;
	sub_82EFD860(ctx, base);
	// 82F6A910: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82F6A914: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82F6A918: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F6A91C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A920: 3B40FFFE  li r26, -2
	ctx.r[26].s64 = -2;
	// 82F6A924: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6A928: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6A92C: 419A0020  beq cr6, 0x82f6a94c
	if ctx.cr[6].eq {
	pc = 0x82F6A94C; continue 'dispatch;
	}
	// 82F6A930: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82F6A934: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A938: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6A93C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6A940: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82F6A944: 934A0008  stw r26, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82F6A948: 4082FFEC  bne 0x82f6a934
	if !ctx.cr[0].eq {
	pc = 0x82F6A934; continue 'dispatch;
	}
	// 82F6A94C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6A954: 419A0064  beq cr6, 0x82f6a9b8
	if ctx.cr[6].eq {
	pc = 0x82F6A9B8; continue 'dispatch;
	}
	// 82F6A958: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A95C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82F6A960: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82F6A964: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A968: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82F6A96C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F6A970: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6A974: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6A978: 419A002C  beq cr6, 0x82f6a9a4
	if ctx.cr[6].eq {
	pc = 0x82F6A9A4; continue 'dispatch;
	}
	// 82F6A97C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6A980: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82F6A984: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6A988: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6A98C: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6A990: 4BFFF289  bl 0x82f69c18
	ctx.lr = 0x82F6A994;
	sub_82F69C18(ctx, base);
	// 82F6A994: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6A998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6A99C: 4BFB118D  bl 0x82f1bb28
	ctx.lr = 0x82F6A9A0;
	sub_82F1BB28(ctx, base);
	// 82F6A9A0: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82F6A9A4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82F6A9A8: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82F6A9AC: 4082FFB8  bne 0x82f6a964
	if !ctx.cr[0].eq {
	pc = 0x82F6A964; continue 'dispatch;
	}
	// 82F6A9B0: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A9B4: 4BF92EED  bl 0x82efd8a0
	ctx.lr = 0x82F6A9B8;
	sub_82EFD8A0(ctx, base);
	// 82F6A9B8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6A9BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6A9C0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82F6A9C4: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6A9C8: 4BFB3ED9  bl 0x82f1e8a0
	ctx.lr = 0x82F6A9CC;
	sub_82F1E8A0(ctx, base);
	// 82F6A9CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6A9D0: 4BD3EA7C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6A9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6A9D8 size=100
    let mut pc: u32 = 0x82F6A9D8;
    'dispatch: loop {
        match pc {
            0x82F6A9D8 => {
    //   block [0x82F6A9D8..0x82F6AA3C)
	// 82F6A9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6A9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6A9E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6A9E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6A9E8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A9EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6A9F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6A9F4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F6A9F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6A9FC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6AA00: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AA04: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F6AA08: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6AA0C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82F6AA10: 80840004  lwz r4, 4(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AA14: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6AA18: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F6AA1C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82F6AA20: 4BFD29B9  bl 0x82f3d3d8
	ctx.lr = 0x82F6AA24;
	sub_82F3D3D8(ctx, base);
	// 82F6AA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6AA28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6AA2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6AA30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6AA34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6AA38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6AA40 size=20
    let mut pc: u32 = 0x82F6AA40;
    'dispatch: loop {
        match pc {
            0x82F6AA40 => {
    //   block [0x82F6AA40..0x82F6AA54)
	// 82F6AA40: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AA44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6AA48: 409A000C  bne cr6, 0x82f6aa54
	if !ctx.cr[6].eq {
		sub_82F6AA54(ctx, base);
		return;
	}
	// 82F6AA4C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F6AA50: 4BFFFE38  b 0x82f6a888
	sub_82F6A888(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AA54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6AA54 size=28
    let mut pc: u32 = 0x82F6AA54;
    'dispatch: loop {
        match pc {
            0x82F6AA54 => {
    //   block [0x82F6AA54..0x82F6AA70)
	// 82F6AA54: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AA58: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AA5C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6AA60: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F6AA64: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6AA68: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6AA6C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6AA70 size=16
    let mut pc: u32 = 0x82F6AA70;
    'dispatch: loop {
        match pc {
            0x82F6AA70 => {
    //   block [0x82F6AA70..0x82F6AA80)
	// 82F6AA70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AA74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6AA78: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6AA7C: 4BFFFE0C  b 0x82f6a888
	sub_82F6A888(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6AA80 size=4
    let mut pc: u32 = 0x82F6AA80;
    'dispatch: loop {
        match pc {
            0x82F6AA80 => {
    //   block [0x82F6AA80..0x82F6AA84)
	// 82F6AA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6AA88 size=100
    let mut pc: u32 = 0x82F6AA88;
    'dispatch: loop {
        match pc {
            0x82F6AA88 => {
    //   block [0x82F6AA88..0x82F6AAEC)
	// 82F6AA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6AA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6AA90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6AA94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6AA98: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6AA9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6AAA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6AAA4: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82F6AAA8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F6AAAC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AAB0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6AAB4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AAB8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F6AABC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6AAC0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6AAC4: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F6AAC8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6AACC: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F6AAD0: 4BFD2909  bl 0x82f3d3d8
	ctx.lr = 0x82F6AAD4;
	sub_82F3D3D8(ctx, base);
	// 82F6AAD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6AAD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6AADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6AAE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6AAE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6AAE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6AAF0 size=320
    let mut pc: u32 = 0x82F6AAF0;
    'dispatch: loop {
        match pc {
            0x82F6AAF0 => {
    //   block [0x82F6AAF0..0x82F6AC30)
	// 82F6AAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6AAF4: 4BD3E905  bl 0x82ca93f8
	ctx.lr = 0x82F6AAF8;
	sub_82CA93D0(ctx, base);
	// 82F6AAF8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6AAFC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82F6AB00: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82F6AB04: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82F6AB08: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AB0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6AB10: 419A0114  beq cr6, 0x82f6ac24
	if ctx.cr[6].eq {
	pc = 0x82F6AC24; continue 'dispatch;
	}
	// 82F6AB14: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AB18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6AB1C: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82F6AB20: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F6AB24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6AB28: 4E800421  bctrl
	ctx.lr = 0x82F6AB2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6AB2C: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AB30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F6AB34: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6AB38: 40990030  ble cr6, 0x82f6ab68
	if !ctx.cr[6].gt {
	pc = 0x82F6AB68; continue 'dispatch;
	}
	// 82F6AB3C: 37FEFFFF  addic. r31, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6AB40: 41800028  blt 0x82f6ab68
	if ctx.cr[0].lt {
	pc = 0x82F6AB68; continue 'dispatch;
	}
	// 82F6AB44: 3B5D0008  addi r26, r29, 8
	ctx.r[26].s64 = ctx.r[29].s64 + 8;
	// 82F6AB48: 57FC2036  slwi r28, r31, 4
	ctx.r[28].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82F6AB4C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AB50: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82F6AB54: 7C9C5A14  add r4, r28, r11
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82F6AB58: 4BFA5851  bl 0x82f103a8
	ctx.lr = 0x82F6AB5C;
	sub_82F103A8(ctx, base);
	// 82F6AB5C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6AB60: 3B9CFFF0  addi r28, r28, -0x10
	ctx.r[28].s64 = ctx.r[28].s64 + -16;
	// 82F6AB64: 4080FFE8  bge 0x82f6ab4c
	if !ctx.cr[0].lt {
	pc = 0x82F6AB4C; continue 'dispatch;
	}
	// 82F6AB68: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6AB6C: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6AB70: 397B0080  addi r11, r27, 0x80
	ctx.r[11].s64 = ctx.r[27].s64 + 128;
	// 82F6AB74: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6AB78: 3B6AF064  addi r27, r10, -0xf9c
	ctx.r[27].s64 = ctx.r[10].s64 + -3996;
	// 82F6AB7C: 815D001C  lwz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F6AB80: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82F6AB84: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82F6AB88: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82F6AB8C: 7D684850  subf r11, r8, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82F6AB90: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82F6AB94: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6AB98: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82F6AB9C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82F6ABA0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6ABA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6ABA8: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82F6ABAC: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 82F6ABB0: 3B8BFFE0  addi r28, r11, -0x20
	ctx.r[28].s64 = ctx.r[11].s64 + -32;
	// 82F6ABB4: 48003C75  bl 0x82f6e828
	ctx.lr = 0x82F6ABB8;
	sub_82F6E828(ctx, base);
	// 82F6ABB8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82F6ABBC: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82F6ABC0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82F6ABC4: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 82F6ABC8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82F6ABCC: 48003EA5  bl 0x82f6ea70
	ctx.lr = 0x82F6ABD0;
	sub_82F6EA70(ctx, base);
	// 82F6ABD0: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82F6ABD4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82F6ABD8: 48003CC9  bl 0x82f6e8a0
	ctx.lr = 0x82F6ABDC;
	sub_82F6E8A0(ctx, base);
	// 82F6ABDC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6ABE0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6ABE4: 396B106C  addi r11, r11, 0x106c
	ctx.r[11].s64 = ctx.r[11].s64 + 4204;
	// 82F6ABE8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82F6ABEC: 4099001C  ble cr6, 0x82f6ac08
	if !ctx.cr[6].gt {
	pc = 0x82F6AC08; continue 'dispatch;
	}
	// 82F6ABF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6ABF4: 419A0014  beq cr6, 0x82f6ac08
	if ctx.cr[6].eq {
	pc = 0x82F6AC08; continue 'dispatch;
	}
	// 82F6ABF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6ABFC: 4BFA5E0D  bl 0x82f10a08
	ctx.lr = 0x82F6AC00;
	sub_82F10A08(ctx, base);
	// 82F6AC00: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6AC04: 4082FFF4  bne 0x82f6abf8
	if !ctx.cr[0].eq {
	pc = 0x82F6ABF8; continue 'dispatch;
	}
	// 82F6AC08: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6AC0C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6AC10: 4198000C  blt cr6, 0x82f6ac1c
	if ctx.cr[6].lt {
	pc = 0x82F6AC1C; continue 'dispatch;
	}
	// 82F6AC14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6AC18: 48007709  bl 0x82f72320
	ctx.lr = 0x82F6AC1C;
	sub_82F72320(ctx, base);
	// 82F6AC1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6AC20: 48000008  b 0x82f6ac28
	pc = 0x82F6AC28; continue 'dispatch;
	// 82F6AC24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6AC28: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82F6AC2C: 4BD3E81C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AC30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6AC30 size=316
    let mut pc: u32 = 0x82F6AC30;
    'dispatch: loop {
        match pc {
            0x82F6AC30 => {
    //   block [0x82F6AC30..0x82F6AD6C)
	// 82F6AC30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6AC34: 4BD3E7C5  bl 0x82ca93f8
	ctx.lr = 0x82F6AC38;
	sub_82CA93D0(ctx, base);
	// 82F6AC38: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6AC3C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82F6AC40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82F6AC44: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82F6AC48: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82F6AC4C: 419A0114  beq cr6, 0x82f6ad60
	if ctx.cr[6].eq {
	pc = 0x82F6AD60; continue 'dispatch;
	}
	// 82F6AC50: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AC54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6AC58: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82F6AC5C: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F6AC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6AC64: 4E800421  bctrl
	ctx.lr = 0x82F6AC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6AC68: 83D90004  lwz r30, 4(r25)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AC6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F6AC70: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6AC74: 40990030  ble cr6, 0x82f6aca4
	if !ctx.cr[6].gt {
	pc = 0x82F6ACA4; continue 'dispatch;
	}
	// 82F6AC78: 37FEFFFF  addic. r31, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6AC7C: 41800028  blt 0x82f6aca4
	if ctx.cr[0].lt {
	pc = 0x82F6ACA4; continue 'dispatch;
	}
	// 82F6AC80: 3B5D0008  addi r26, r29, 8
	ctx.r[26].s64 = ctx.r[29].s64 + 8;
	// 82F6AC84: 57FC2036  slwi r28, r31, 4
	ctx.r[28].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82F6AC88: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AC8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82F6AC90: 7C9C5A14  add r4, r28, r11
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82F6AC94: 4BFA5715  bl 0x82f103a8
	ctx.lr = 0x82F6AC98;
	sub_82F103A8(ctx, base);
	// 82F6AC98: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6AC9C: 3B9CFFF0  addi r28, r28, -0x10
	ctx.r[28].s64 = ctx.r[28].s64 + -16;
	// 82F6ACA0: 4080FFE8  bge 0x82f6ac88
	if !ctx.cr[0].lt {
	pc = 0x82F6AC88; continue 'dispatch;
	}
	// 82F6ACA4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6ACA8: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6ACAC: 397B0080  addi r11, r27, 0x80
	ctx.r[11].s64 = ctx.r[27].s64 + 128;
	// 82F6ACB0: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6ACB4: 3B6AF064  addi r27, r10, -0xf9c
	ctx.r[27].s64 = ctx.r[10].s64 + -3996;
	// 82F6ACB8: 815D001C  lwz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F6ACBC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82F6ACC0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82F6ACC4: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82F6ACC8: 7D684850  subf r11, r8, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82F6ACCC: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82F6ACD0: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6ACD4: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82F6ACD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82F6ACDC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6ACE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6ACE4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82F6ACE8: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	// 82F6ACEC: 3B8BFFE0  addi r28, r11, -0x20
	ctx.r[28].s64 = ctx.r[11].s64 + -32;
	// 82F6ACF0: 48003B39  bl 0x82f6e828
	ctx.lr = 0x82F6ACF4;
	sub_82F6E828(ctx, base);
	// 82F6ACF4: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82F6ACF8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 82F6ACFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F6AD00: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 82F6AD04: 7F0903A6  mtctr r24
	ctx.ctr.u64 = ctx.r[24].u64;
	// 82F6AD08: 4E800421  bctrl
	ctx.lr = 0x82F6AD0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6AD0C: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82F6AD10: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82F6AD14: 48003B8D  bl 0x82f6e8a0
	ctx.lr = 0x82F6AD18;
	sub_82F6E8A0(ctx, base);
	// 82F6AD18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6AD1C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6AD20: 396B106C  addi r11, r11, 0x106c
	ctx.r[11].s64 = ctx.r[11].s64 + 4204;
	// 82F6AD24: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82F6AD28: 4099001C  ble cr6, 0x82f6ad44
	if !ctx.cr[6].gt {
	pc = 0x82F6AD44; continue 'dispatch;
	}
	// 82F6AD2C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6AD30: 419A0014  beq cr6, 0x82f6ad44
	if ctx.cr[6].eq {
	pc = 0x82F6AD44; continue 'dispatch;
	}
	// 82F6AD34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6AD38: 4BFA5CD1  bl 0x82f10a08
	ctx.lr = 0x82F6AD3C;
	sub_82F10A08(ctx, base);
	// 82F6AD3C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6AD40: 4082FFF4  bne 0x82f6ad34
	if !ctx.cr[0].eq {
	pc = 0x82F6AD34; continue 'dispatch;
	}
	// 82F6AD44: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6AD48: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6AD4C: 4198000C  blt cr6, 0x82f6ad58
	if ctx.cr[6].lt {
	pc = 0x82F6AD58; continue 'dispatch;
	}
	// 82F6AD50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6AD54: 480075CD  bl 0x82f72320
	ctx.lr = 0x82F6AD58;
	sub_82F72320(ctx, base);
	// 82F6AD58: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6AD5C: 48000008  b 0x82f6ad64
	pc = 0x82F6AD64; continue 'dispatch;
	// 82F6AD60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6AD64: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82F6AD68: 4BD3E6E0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AD70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6AD70 size=496
    let mut pc: u32 = 0x82F6AD70;
    'dispatch: loop {
        match pc {
            0x82F6AD70 => {
    //   block [0x82F6AD70..0x82F6AF60)
	// 82F6AD70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6AD74: 4BD3E695  bl 0x82ca9408
	ctx.lr = 0x82F6AD78;
	sub_82CA93D0(ctx, base);
	// 82F6AD78: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6AD7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6AD80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82F6AD84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6AD88: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F6AD8C: 9B810070  stb r28, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u8 ) };
	// 82F6AD90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AD94: 816B004C  lwz r11, 0x4c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82F6AD98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6AD9C: 4E800421  bctrl
	ctx.lr = 0x82F6ADA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6ADA0: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 82F6ADA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6ADA8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6ADAC: 389E0078  addi r4, r30, 0x78
	ctx.r[4].s64 = ctx.r[30].s64 + 120;
	// 82F6ADB0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6ADB4: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F6ADB8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82F6ADBC: 815E0078  lwz r10, 0x78(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F6ADC0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82F6ADC4: 396B0048  addi r11, r11, 0x48
	ctx.r[11].s64 = ctx.r[11].s64 + 72;
	// 82F6ADC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6ADCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82F6ADD0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6ADD4: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82F6ADD8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6ADDC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6ADE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6ADE4: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F6ADE8: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6ADEC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6ADF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6ADF4: 4E800421  bctrl
	ctx.lr = 0x82F6ADF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6ADF8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6ADFC: 41820120  beq 0x82f6af1c
	if ctx.cr[0].eq {
	pc = 0x82F6AF1C; continue 'dispatch;
	}
	// 82F6AE00: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82F6AE04: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6AE08: 48006909  bl 0x82f71710
	ctx.lr = 0x82F6AE0C;
	sub_82F71710(ctx, base);
	// 82F6AE0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82F6AE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6AE14: 419A0100  beq cr6, 0x82f6af14
	if ctx.cr[6].eq {
	pc = 0x82F6AF14; continue 'dispatch;
	}
	// 82F6AE18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F6AE1C: 419A0038  beq cr6, 0x82f6ae54
	if ctx.cr[6].eq {
	pc = 0x82F6AE54; continue 'dispatch;
	}
	// 82F6AE20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6AE24: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F6AE28: 480066A9  bl 0x82f714d0
	ctx.lr = 0x82F6AE2C;
	sub_82F714D0(ctx, base);
	// 82F6AE2C: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82F6AE30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F6AE34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6AE38: 4BFA5571  bl 0x82f103a8
	ctx.lr = 0x82F6AE3C;
	sub_82F103A8(ctx, base);
	// 82F6AE3C: 89610090  lbz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F6AE40: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6AE44: 41980028  blt cr6, 0x82f6ae6c
	if ctx.cr[6].lt {
	pc = 0x82F6AE6C; continue 'dispatch;
	}
	// 82F6AE48: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82F6AE4C: 480074D5  bl 0x82f72320
	ctx.lr = 0x82F6AE50;
	sub_82F72320(ctx, base);
	// 82F6AE50: 4800001C  b 0x82f6ae6c
	pc = 0x82F6AE6C; continue 'dispatch;
	// 82F6AE54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6AE58: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82F6AE5C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82F6AE60: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82F6AE64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6AE68: 4BFB4B91  bl 0x82f1f9f8
	ctx.lr = 0x82F6AE6C;
	sub_82F1F9F8(ctx, base);
	// 82F6AE6C: 9B810080  stb r28, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u8 ) };
	// 82F6AE70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6AE74: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6AE78: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82F6AE7C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AE80: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6AE84: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82F6AE88: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82F6AE8C: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6AE90: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6AE94: 3BEBFFE0  addi r31, r11, -0x20
	ctx.r[31].s64 = ctx.r[11].s64 + -32;
	// 82F6AE98: 48006639  bl 0x82f714d0
	ctx.lr = 0x82F6AE9C;
	sub_82F714D0(ctx, base);
	// 82F6AE9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82F6AEA0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82F6AEA4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82F6AEA8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82F6AEAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82F6AEB0: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 82F6AEB4: 4BFAF315  bl 0x82f1a1c8
	ctx.lr = 0x82F6AEB8;
	sub_82F1A1C8(ctx, base);
	// 82F6AEB8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F6AEBC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6AEC0: 48003BB1  bl 0x82f6ea70
	ctx.lr = 0x82F6AEC4;
	sub_82F6EA70(ctx, base);
	// 82F6AEC4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6AEC8: 386100BC  addi r3, r1, 0xbc
	ctx.r[3].s64 = ctx.r[1].s64 + 188;
	// 82F6AECC: 396BF064  addi r11, r11, -0xf9c
	ctx.r[11].s64 = ctx.r[11].s64 + -3996;
	// 82F6AED0: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82F6AED4: 480039CD  bl 0x82f6e8a0
	ctx.lr = 0x82F6AED8;
	sub_82F6E8A0(ctx, base);
	// 82F6AED8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6AEDC: 396B106C  addi r11, r11, 0x106c
	ctx.r[11].s64 = ctx.r[11].s64 + 4204;
	// 82F6AEE0: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82F6AEE4: 896100A0  lbz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82F6AEE8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6AEEC: 4198000C  blt cr6, 0x82f6aef8
	if ctx.cr[6].lt {
	pc = 0x82F6AEF8; continue 'dispatch;
	}
	// 82F6AEF0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82F6AEF4: 4800742D  bl 0x82f72320
	ctx.lr = 0x82F6AEF8;
	sub_82F72320(ctx, base);
	// 82F6AEF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6AEFC: 4BFA5B0D  bl 0x82f10a08
	ctx.lr = 0x82F6AF00;
	sub_82F10A08(ctx, base);
	// 82F6AF00: 89610080  lbz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82F6AF04: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6AF08: 4198000C  blt cr6, 0x82f6af14
	if ctx.cr[6].lt {
	pc = 0x82F6AF14; continue 'dispatch;
	}
	// 82F6AF0C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82F6AF10: 48007411  bl 0x82f72320
	ctx.lr = 0x82F6AF14;
	sub_82F72320(ctx, base);
	// 82F6AF14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6AF18: 48003989  bl 0x82f6e8a0
	ctx.lr = 0x82F6AF1C;
	sub_82F6E8A0(ctx, base);
	// 82F6AF1C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6AF20: 396A000C  addi r11, r10, 0xc
	ctx.r[11].s64 = ctx.r[10].s64 + 12;
	// 82F6AF24: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AF28: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F6AF2C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6AF30: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6AF34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6AF38: 409A000C  bne cr6, 0x82f6af44
	if !ctx.cr[6].eq {
	pc = 0x82F6AF44; continue 'dispatch;
	}
	// 82F6AF3C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82F6AF40: 48002B49  bl 0x82f6da88
	ctx.lr = 0x82F6AF44;
	sub_82F6DA88(ctx, base);
	// 82F6AF44: 89610070  lbz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82F6AF48: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82F6AF4C: 4198000C  blt cr6, 0x82f6af58
	if ctx.cr[6].lt {
	pc = 0x82F6AF58; continue 'dispatch;
	}
	// 82F6AF50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F6AF54: 480073CD  bl 0x82f72320
	ctx.lr = 0x82F6AF58;
	sub_82F72320(ctx, base);
	// 82F6AF58: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82F6AF5C: 4BD3E4FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6AF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6AF60 size=156
    let mut pc: u32 = 0x82F6AF60;
    'dispatch: loop {
        match pc {
            0x82F6AF60 => {
    //   block [0x82F6AF60..0x82F6AFFC)
	// 82F6AF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6AF64: 4BD3E4A9  bl 0x82ca940c
	ctx.lr = 0x82F6AF68;
	sub_82CA93D0(ctx, base);
	// 82F6AF68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6AF6C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AF70: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F6AF74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6AF78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6AF7C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6AF80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6AF84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6AF88: 4BFFC519  bl 0x82f674a0
	ctx.lr = 0x82F6AF8C;
	sub_82F674A0(ctx, base);
	// 82F6AF8C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6AF90: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6AF94: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6AF98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6AF9C: 4E800421  bctrl
	ctx.lr = 0x82F6AFA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6AFA0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6AFA4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82F6AFA8: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82F6AFAC: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82F6AFB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6AFB4: C00B0C1C  lfs f0, 0xc1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6AFB8: 3963013C  addi r11, r3, 0x13c
	ctx.r[11].s64 = ctx.r[3].s64 + 316;
	// 82F6AFBC: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82F6AFC0: 39082A10  addi r8, r8, 0x2a10
	ctx.r[8].s64 = ctx.r[8].s64 + 10768;
	// 82F6AFC4: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82F6AFC8: 38E72A04  addi r7, r7, 0x2a04
	ctx.r[7].s64 = ctx.r[7].s64 + 10756;
	// 82F6AFCC: C0090EE0  lfs f0, 0xee0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6AFD0: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82F6AFD4: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82F6AFD8: 995F0090  stb r10, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u8 ) };
	// 82F6AFDC: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 82F6AFE0: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82F6AFE4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F6AFE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6AFEC: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82F6AFF0: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 82F6AFF4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6AFF8: 4BD3E464  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6B000 size=8
    let mut pc: u32 = 0x82F6B000;
    'dispatch: loop {
        match pc {
            0x82F6B000 => {
    //   block [0x82F6B000..0x82F6B008)
	// 82F6B000: 80630098  lwz r3, 0x98(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82F6B004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6B008 size=12
    let mut pc: u32 = 0x82F6B008;
    'dispatch: loop {
        match pc {
            0x82F6B008 => {
    //   block [0x82F6B008..0x82F6B014)
	// 82F6B008: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6B00C: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 82F6B010: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B014(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6B014 size=8
    let mut pc: u32 = 0x82F6B014;
    'dispatch: loop {
        match pc {
            0x82F6B014 => {
    //   block [0x82F6B014..0x82F6B01C)
	// 82F6B014: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6B018: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6B020 size=8
    let mut pc: u32 = 0x82F6B020;
    'dispatch: loop {
        match pc {
            0x82F6B020 => {
    //   block [0x82F6B020..0x82F6B028)
	// 82F6B020: 3863FFF0  addi r3, r3, -0x10
	ctx.r[3].s64 = ctx.r[3].s64 + -16;
	// 82F6B024: 4800090C  b 0x82f6b930
	sub_82F6B930(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B028 size=96
    let mut pc: u32 = 0x82F6B028;
    'dispatch: loop {
        match pc {
            0x82F6B028 => {
    //   block [0x82F6B028..0x82F6B088)
	// 82F6B028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B02C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6B030: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6B034: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6B038: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B03C: 80840098  lwz r4, 0x98(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) } as u64;
	// 82F6B040: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B044: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6B048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6B04C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B050: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6B054: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B058: 4E800421  bctrl
	ctx.lr = 0x82F6B05C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B05C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82F6B060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6B064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6B068: 48001F49  bl 0x82f6cfb0
	ctx.lr = 0x82F6B06C;
	sub_82F6CFB0(ctx, base);
	// 82F6B06C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B070: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6B074: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6B078: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6B07C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6B080: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6B084: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B088 size=96
    let mut pc: u32 = 0x82F6B088;
    'dispatch: loop {
        match pc {
            0x82F6B088 => {
    //   block [0x82F6B088..0x82F6B0E8)
	// 82F6B088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B08C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6B090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6B094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6B098: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B09C: 80840098  lwz r4, 0x98(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) } as u64;
	// 82F6B0A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B0A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6B0A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6B0AC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B0B0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6B0B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B0B8: 4E800421  bctrl
	ctx.lr = 0x82F6B0BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B0BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82F6B0C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6B0C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6B0C8: 48001EE9  bl 0x82f6cfb0
	ctx.lr = 0x82F6B0CC;
	sub_82F6CFB0(ctx, base);
	// 82F6B0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B0D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6B0D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6B0D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6B0DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6B0E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6B0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B0E8 size=132
    let mut pc: u32 = 0x82F6B0E8;
    'dispatch: loop {
        match pc {
            0x82F6B0E8 => {
    //   block [0x82F6B0E8..0x82F6B16C)
	// 82F6B0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6B0F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6B0F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B0F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B0FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6B100: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82F6B104: 409A0008  bne cr6, 0x82f6b10c
	if !ctx.cr[6].eq {
	pc = 0x82F6B10C; continue 'dispatch;
	}
	// 82F6B108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6B10C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B110: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6B114: 419A0014  beq cr6, 0x82f6b128
	if ctx.cr[6].eq {
	pc = 0x82F6B128; continue 'dispatch;
	}
	// 82F6B118: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6B11C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82F6B120: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B124: 4BFFF5FD  bl 0x82f6a720
	ctx.lr = 0x82F6B128;
	sub_82F6A720(ctx, base);
	// 82F6B128: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6B12C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6B130: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6B134: 396B27E0  addi r11, r11, 0x27e0
	ctx.r[11].s64 = ctx.r[11].s64 + 10208;
	// 82F6B138: 394A2870  addi r10, r10, 0x2870
	ctx.r[10].s64 = ctx.r[10].s64 + 10352;
	// 82F6B13C: 3929106C  addi r9, r9, 0x106c
	ctx.r[9].s64 = ctx.r[9].s64 + 4204;
	// 82F6B140: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6B144: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6B148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B14C: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F6B150: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82F6B154: 4BF928C5  bl 0x82efda18
	ctx.lr = 0x82F6B158;
	sub_82EFDA18(ctx, base);
	// 82F6B158: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6B15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6B160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6B164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6B168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B170 size=100
    let mut pc: u32 = 0x82F6B170;
    'dispatch: loop {
        match pc {
            0x82F6B170 => {
    //   block [0x82F6B170..0x82F6B1D4)
	// 82F6B170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6B178: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6B17C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B180: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82F6B184: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B188: 41820030  beq 0x82f6b1b8
	if ctx.cr[0].eq {
	pc = 0x82F6B1B8; continue 'dispatch;
	}
	// 82F6B18C: 4BFD3CCD  bl 0x82f3ee58
	ctx.lr = 0x82F6B190;
	sub_82F3EE58(ctx, base);
	// 82F6B190: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6B194: 4182001C  beq 0x82f6b1b0
	if ctx.cr[0].eq {
	pc = 0x82F6B1B0; continue 'dispatch;
	}
	// 82F6B198: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6B19C: 419A000C  beq cr6, 0x82f6b1a8
	if ctx.cr[6].eq {
	pc = 0x82F6B1A8; continue 'dispatch;
	}
	// 82F6B1A0: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B1A4: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82F6B1A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6B1AC: 48000014  b 0x82f6b1c0
	pc = 0x82F6B1C0; continue 'dispatch;
	// 82F6B1B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6B1B4: 4800000C  b 0x82f6b1c0
	pc = 0x82F6B1C0; continue 'dispatch;
	// 82F6B1B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82F6B1BC: 4BFFF64D  bl 0x82f6a808
	ctx.lr = 0x82F6B1C0;
	sub_82F6A808(ctx, base);
	// 82F6B1C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6B1C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6B1C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6B1CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6B1D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B1D8 size=100
    let mut pc: u32 = 0x82F6B1D8;
    'dispatch: loop {
        match pc {
            0x82F6B1D8 => {
    //   block [0x82F6B1D8..0x82F6B23C)
	// 82F6B1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B1DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6B1E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6B1E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6B1E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B1EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B1F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6B1F4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F6B1F8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6B1FC: 4BFB23E5  bl 0x82f1d5e0
	ctx.lr = 0x82F6B200;
	sub_82F1D5E0(ctx, base);
	// 82F6B200: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6B208: 419A0008  beq cr6, 0x82f6b210
	if ctx.cr[6].eq {
	pc = 0x82F6B210; continue 'dispatch;
	}
	// 82F6B20C: 4BF92695  bl 0x82efd8a0
	ctx.lr = 0x82F6B210;
	sub_82EFD8A0(ctx, base);
	// 82F6B210: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B214: 4182000C  beq 0x82f6b220
	if ctx.cr[0].eq {
	pc = 0x82F6B220; continue 'dispatch;
	}
	// 82F6B218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B21C: 4B8DA595  bl 0x828457b0
	ctx.lr = 0x82F6B220;
	sub_828457B0(ctx, base);
	// 82F6B220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B224: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6B228: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6B22C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6B230: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6B234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6B238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B240 size=488
    let mut pc: u32 = 0x82F6B240;
    'dispatch: loop {
        match pc {
            0x82F6B240 => {
    //   block [0x82F6B240..0x82F6B428)
	// 82F6B240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B244: 4BD3E1C5  bl 0x82ca9408
	ctx.lr = 0x82F6B248;
	sub_82CA93D0(ctx, base);
	// 82F6B248: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B24C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B250: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82F6B254: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6B258: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6B260: 409A000C  bne cr6, 0x82f6b26c
	if !ctx.cr[6].eq {
	pc = 0x82F6B26C; continue 'dispatch;
	}
	// 82F6B264: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F6B268: 4800002C  b 0x82f6b294
	pc = 0x82F6B294; continue 'dispatch;
	// 82F6B26C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B270: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B274: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6B278: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F6B27C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6B280: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6B284: 40990018  ble cr6, 0x82f6b29c
	if !ctx.cr[6].gt {
	pc = 0x82F6B29C; continue 'dispatch;
	}
	// 82F6B288: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B28C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6B290: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6B294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B298: 4BFFF5F1  bl 0x82f6a888
	ctx.lr = 0x82F6B29C;
	sub_82F6A888(ctx, base);
	// 82F6B29C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B2A0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B2A4: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B2A8: 7D4AF038  and r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[30].u64;
	// 82F6B2AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6B2B0: 1D2A000C  mulli r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 * 12;
	// 82F6B2B4: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6B2B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B2BC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F6B2C0: 80C90008  lwz r6, 8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B2C4: 3BC90008  addi r30, r9, 8
	ctx.r[30].s64 = ctx.r[9].s64 + 8;
	// 82F6B2C8: 2F06FFFE  cmpwi cr6, r6, -2
	ctx.cr[6].compare_i32(ctx.r[6].s32, -2, &mut ctx.xer);
	// 82F6B2CC: 409A0054  bne cr6, 0x82f6b320
	if !ctx.cr[6].eq {
	pc = 0x82F6B320; continue 'dispatch;
	}
	// 82F6B2D0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B2D4: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F6B2D8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B2DC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B2E0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6B2E4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6B2E8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B2EC: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B2F0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6B2F4: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82F6B2F8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B2FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6B300: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6B304: 993E0008  stb r9, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 82F6B308: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B30C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B310: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6B314: 4082010C  bne 0x82f6b420
	if !ctx.cr[0].eq {
	pc = 0x82F6B420; continue 'dispatch;
	}
	// 82F6B318: 48002771  bl 0x82f6da88
	ctx.lr = 0x82F6B31C;
	sub_82F6DA88(ctx, base);
	// 82F6B31C: 48000104  b 0x82f6b420
	pc = 0x82F6B420; continue 'dispatch;
	// 82F6B320: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B324: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82F6B328: 393D0001  addi r9, r29, 1
	ctx.r[9].s64 = ctx.r[29].s64 + 1;
	// 82F6B32C: 7D3D3838  and r29, r9, r7
	ctx.r[29].u64 = ctx.r[9].u64 & ctx.r[7].u64;
	// 82F6B330: 1D3D000C  mulli r9, r29, 0xc
	ctx.r[9].s64 = ctx.r[29].s64 * 12;
	// 82F6B334: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F6B338: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B33C: 2F09FFFE  cmpwi cr6, r9, -2
	ctx.cr[6].compare_i32(ctx.r[9].s32, -2, &mut ctx.xer);
	// 82F6B340: 409AFFE8  bne cr6, 0x82f6b328
	if !ctx.cr[6].eq {
	pc = 0x82F6B328; continue 'dispatch;
	}
	// 82F6B344: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B348: 1D3D000C  mulli r9, r29, 0xc
	ctx.r[9].s64 = ctx.r[29].s64 * 12;
	// 82F6B34C: 80A80010  lwz r5, 0x10(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B350: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F6B354: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82F6B358: 39090008  addi r8, r9, 8
	ctx.r[8].s64 = ctx.r[9].s64 + 8;
	// 82F6B35C: 7CA93838  and r9, r5, r7
	ctx.r[9].u64 = ctx.r[5].u64 & ctx.r[7].u64;
	// 82F6B360: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6B364: 409A0054  bne cr6, 0x82f6b3b8
	if !ctx.cr[6].eq {
	pc = 0x82F6B3B8; continue 'dispatch;
	}
	// 82F6B368: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82F6B36C: 419A0024  beq cr6, 0x82f6b390
	if ctx.cr[6].eq {
	pc = 0x82F6B390; continue 'dispatch;
	}
	// 82F6B370: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82F6B374: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B378: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6B37C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B380: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6B384: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6B388: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B38C: 99680008  stb r11, 8(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82F6B390: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B394: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B398: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B39C: 4BFA7125  bl 0x82f124c0
	ctx.lr = 0x82F6B3A0;
	sub_82F124C0(ctx, base);
	// 82F6B3A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B3A4: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B3A8: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82F6B3AC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6B3B0: 48000070  b 0x82f6b420
	pc = 0x82F6B420; continue 'dispatch;
	// 82F6B3B4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B3B8: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 * 12;
	// 82F6B3BC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F6B3C0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82F6B3C4: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B3C8: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82F6B3CC: 409AFFE8  bne cr6, 0x82f6b3b4
	if !ctx.cr[6].eq {
	pc = 0x82F6B3B4; continue 'dispatch;
	}
	// 82F6B3D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82F6B3D4: 419A0024  beq cr6, 0x82f6b3f8
	if ctx.cr[6].eq {
	pc = 0x82F6B3F8; continue 'dispatch;
	}
	// 82F6B3D8: 90C80000  stw r6, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82F6B3DC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B3E0: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6B3E4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B3E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6B3EC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6B3F0: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B3F4: 99680008  stb r11, 8(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82F6B3F8: 93A90000  stw r29, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6B3FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B400: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B404: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B408: 4BFA70B9  bl 0x82f124c0
	ctx.lr = 0x82F6B40C;
	sub_82F124C0(ctx, base);
	// 82F6B40C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B410: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F6B414: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B418: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82F6B41C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6B420: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6B424: 4BD3E034  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6B428 size=144
    let mut pc: u32 = 0x82F6B428;
    'dispatch: loop {
        match pc {
            0x82F6B428 => {
    //   block [0x82F6B428..0x82F6B4B8)
	// 82F6B428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B42C: 4BD3DFE1  bl 0x82ca940c
	ctx.lr = 0x82F6B430;
	sub_82CA93D0(ctx, base);
	// 82F6B430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6B438: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82F6B43C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B440: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82F6B444: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B448: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B44C: 556B1FFF  rlwinm. r11, r11, 3, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B450: 41820058  beq 0x82f6b4a8
	if ctx.cr[0].eq {
	pc = 0x82F6B4A8; continue 'dispatch;
	}
	// 82F6B454: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B458: 816B0090  lwz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82F6B45C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B460: 4E800421  bctrl
	ctx.lr = 0x82F6B464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B464: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B468: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82F6B46C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B470: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82F6B474: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B478: 4E800421  bctrl
	ctx.lr = 0x82F6B47C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B47C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B480: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B484: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B488: 4E800421  bctrl
	ctx.lr = 0x82F6B48C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B48C: 21630006  subfic r11, r3, 6
	ctx.xer.ca = ctx.r[3].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[3].s64;
	// 82F6B490: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6B494: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82F6B498: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6B49C: 556607FE  clrlwi r6, r11, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82F6B4A0: 387D025C  addi r3, r29, 0x25c
	ctx.r[3].s64 = ctx.r[29].s64 + 604;
	// 82F6B4A4: 4BFFFCCD  bl 0x82f6b170
	ctx.lr = 0x82F6B4A8;
	sub_82F6B170(ctx, base);
	// 82F6B4A8: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6B4AC: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82F6B4B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6B4B4: 4BD3DFA8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6B4B8 size=280
    let mut pc: u32 = 0x82F6B4B8;
    'dispatch: loop {
        match pc {
            0x82F6B4B8 => {
    //   block [0x82F6B4B8..0x82F6B5D0)
	// 82F6B4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B4BC: 4BD3DF45  bl 0x82ca9400
	ctx.lr = 0x82F6B4C0;
	sub_82CA93D0(ctx, base);
	// 82F6B4C0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B4C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B4C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6B4CC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82F6B4D0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82F6B4D4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82F6B4D8: 386B0080  addi r3, r11, 0x80
	ctx.r[3].s64 = ctx.r[11].s64 + 128;
	// 82F6B4DC: 4802094D  bl 0x82f8be28
	ctx.lr = 0x82F6B4E0;
	sub_82F8BE28(ctx, base);
	// 82F6B4E0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F6B4E4: 418200E0  beq 0x82f6b5c4
	if ctx.cr[0].eq {
	pc = 0x82F6B5C4; continue 'dispatch;
	}
	// 82F6B4E8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82F6B4EC: 419800D8  blt cr6, 0x82f6b5c4
	if ctx.cr[6].lt {
	pc = 0x82F6B5C4; continue 'dispatch;
	}
	// 82F6B4F0: 3D607EFF  lis r11, 0x7eff
	ctx.r[11].s64 = 2130640896;
	// 82F6B4F4: 616BFFFD  ori r11, r11, 0xfffd
	ctx.r[11].u64 = ctx.r[11].u64 | 65533;
	// 82F6B4F8: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82F6B4FC: 419900C8  bgt cr6, 0x82f6b5c4
	if ctx.cr[6].gt {
	pc = 0x82F6B5C4; continue 'dispatch;
	}
	// 82F6B500: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6B504: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F6B508: A15F0024  lhz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F6B50C: 393F0050  addi r9, r31, 0x50
	ctx.r[9].s64 = ctx.r[31].s64 + 80;
	// 82F6B510: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82F6B514: C03F0020  lfs f1, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6B518: 38FF0030  addi r7, r31, 0x30
	ctx.r[7].s64 = ctx.r[31].s64 + 48;
	// 82F6B51C: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82F6B520: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82F6B524: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82F6B528: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F6B52C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82F6B530: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82F6B534: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82F6B538: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82F6B53C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82F6B540: B1410056  sth r10, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u16 ) };
	// 82F6B544: 4BFC6405  bl 0x82f31948
	ctx.lr = 0x82F6B548;
	sub_82F31948(ctx, base);
	// 82F6B548: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6B54C: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82F6B550: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82F6B554: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82F6B558: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82F6B55C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82F6B560: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82F6B564: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82F6B568: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82F6B56C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6B570: 4BFF04C9  bl 0x82f5ba38
	ctx.lr = 0x82F6B574;
	sub_82F5BA38(ctx, base);
	// 82F6B574: 4BFFB8D5  bl 0x82f66e48
	ctx.lr = 0x82F6B578;
	sub_82F66E48(ctx, base);
	// 82F6B578: 816100D4  lwz r11, 0xd4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82F6B57C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6B584: 419A001C  beq cr6, 0x82f6b5a0
	if ctx.cr[6].eq {
	pc = 0x82F6B5A0; continue 'dispatch;
	}
	// 82F6B588: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B58C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6B590: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6B594: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B598: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B59C: 4E800421  bctrl
	ctx.lr = 0x82F6B5A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B5A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6B5A4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82F6B5A8: 4BFB03F9  bl 0x82f1b9a0
	ctx.lr = 0x82F6B5AC;
	sub_82F1B9A0(ctx, base);
	// 82F6B5AC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82F6B5B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6B5B4: 419A0008  beq cr6, 0x82f6b5bc
	if ctx.cr[6].eq {
	pc = 0x82F6B5BC; continue 'dispatch;
	}
	// 82F6B5B8: 4BF922E9  bl 0x82efd8a0
	ctx.lr = 0x82F6B5BC;
	sub_82EFD8A0(ctx, base);
	// 82F6B5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B5C0: 48000008  b 0x82f6b5c8
	pc = 0x82F6B5C8; continue 'dispatch;
	// 82F6B5C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6B5C8: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82F6B5CC: 4BD3DE84  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B5D0 size=268
    let mut pc: u32 = 0x82F6B5D0;
    'dispatch: loop {
        match pc {
            0x82F6B5D0 => {
    //   block [0x82F6B5D0..0x82F6B6DC)
	// 82F6B5D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B5D4: 4BD3DE31  bl 0x82ca9404
	ctx.lr = 0x82F6B5D8;
	sub_82CA93D0(ctx, base);
	// 82F6B5D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B5DC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F6B5E0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6B5E4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6B5E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B5EC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B5F0: 556B1FFF  rlwinm. r11, r11, 3, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B5F4: 41820064  beq 0x82f6b658
	if ctx.cr[0].eq {
	pc = 0x82F6B658; continue 'dispatch;
	}
	// 82F6B5F8: 3BDCFF80  addi r30, r28, -0x80
	ctx.r[30].s64 = ctx.r[28].s64 + -128;
	// 82F6B5FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6B600: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6B604: 4BFFFE25  bl 0x82f6b428
	ctx.lr = 0x82F6B608;
	sub_82F6B428(ctx, base);
	// 82F6B608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B60C: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82F6B610: 419A0048  beq cr6, 0x82f6b658
	if ctx.cr[6].eq {
	pc = 0x82F6B658; continue 'dispatch;
	}
	// 82F6B614: 2F1F001F  cmpwi cr6, r31, 0x1f
	ctx.cr[6].compare_i32(ctx.r[31].s32, 31, &mut ctx.xer);
	// 82F6B618: 41990040  bgt cr6, 0x82f6b658
	if ctx.cr[6].gt {
	pc = 0x82F6B658; continue 'dispatch;
	}
	// 82F6B61C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6B624: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 82F6B628: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B62C: 4E800421  bctrl
	ctx.lr = 0x82F6B630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B630: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6B634: 7D6BF830  slw r11, r11, r31
	if (ctx.r[31].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[31].u8 & 0x1F) as u32)) as u64;
	}
	// 82F6B638: 7C6B5839  and. r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B63C: 4182001C  beq 0x82f6b658
	if ctx.cr[0].eq {
	pc = 0x82F6B658; continue 'dispatch;
	}
	// 82F6B640: 2F1F001F  cmpwi cr6, r31, 0x1f
	ctx.cr[6].compare_i32(ctx.r[31].s32, 31, &mut ctx.xer);
	// 82F6B644: 409A008C  bne cr6, 0x82f6b6d0
	if !ctx.cr[6].eq {
	pc = 0x82F6B6D0; continue 'dispatch;
	}
	// 82F6B648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6B64C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6B650: 997C001D  stb r11, 0x1d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 82F6B654: 48000080  b 0x82f6b6d4
	pc = 0x82F6B6D4; continue 'dispatch;
	// 82F6B658: 817CFF80  lwz r11, -0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F6B65C: 387CFF80  addi r3, r28, -0x80
	ctx.r[3].s64 = ctx.r[28].s64 + -128;
	// 82F6B660: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F6B664: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B668: 4E800421  bctrl
	ctx.lr = 0x82F6B66C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B66C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6B670: 41820060  beq 0x82f6b6d0
	if ctx.cr[0].eq {
	pc = 0x82F6B6D0; continue 'dispatch;
	}
	// 82F6B674: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B67C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B680: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B684: 4E800421  bctrl
	ctx.lr = 0x82F6B688;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B688: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B68C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F6B690: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F6B694: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6B698: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6B69C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B6A0: 4E800421  bctrl
	ctx.lr = 0x82F6B6A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B6A4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B6A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B6AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6B6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B6B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B6B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B6BC: 41820010  beq 0x82f6b6cc
	if ctx.cr[0].eq {
	pc = 0x82F6B6CC; continue 'dispatch;
	}
	// 82F6B6C0: 4E800421  bctrl
	ctx.lr = 0x82F6B6C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B6C4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6B6C8: 4800000C  b 0x82f6b6d4
	pc = 0x82F6B6D4; continue 'dispatch;
	// 82F6B6CC: 4E800421  bctrl
	ctx.lr = 0x82F6B6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B6D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6B6D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6B6D8: 4BD3DD7C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B6E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6B6E0 size=332
    let mut pc: u32 = 0x82F6B6E0;
    'dispatch: loop {
        match pc {
            0x82F6B6E0 => {
    //   block [0x82F6B6E0..0x82F6B82C)
	// 82F6B6E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B6E4: 4BD3DD19  bl 0x82ca93fc
	ctx.lr = 0x82F6B6E8;
	sub_82CA93D0(ctx, base);
	// 82F6B6E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B6EC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F6B6F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6B6F4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82F6B6F8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82F6B6FC: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82F6B700: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B704: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B708: 556B1FFF  rlwinm. r11, r11, 3, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B70C: 41820044  beq 0x82f6b750
	if ctx.cr[0].eq {
	pc = 0x82F6B750; continue 'dispatch;
	}
	// 82F6B710: 3BFEFF80  addi r31, r30, -0x80
	ctx.r[31].s64 = ctx.r[30].s64 + -128;
	// 82F6B714: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6B718: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B71C: 4BFFFD0D  bl 0x82f6b428
	ctx.lr = 0x82F6B720;
	sub_82F6B428(ctx, base);
	// 82F6B720: 817EFF80  lwz r11, -0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F6B724: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F6B728: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82F6B72C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F6B730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B734: 816B00D8  lwz r11, 0xd8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(216 as u32) ) } as u64;
	// 82F6B738: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B73C: 4E800421  bctrl
	ctx.lr = 0x82F6B740;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B740: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B744: 4182000C  beq 0x82f6b750
	if ctx.cr[0].eq {
	pc = 0x82F6B750; continue 'dispatch;
	}
	// 82F6B748: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6B74C: 480000D8  b 0x82f6b824
	pc = 0x82F6B824; continue 'dispatch;
	// 82F6B750: 897A007C  lbz r11, 0x7c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(124 as u32) ) } as u64;
	// 82F6B754: 216B0006  subfic r11, r11, 6
	ctx.xer.ca = ctx.r[11].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[11].s64;
	// 82F6B758: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82F6B75C: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B760: 41820018  beq 0x82f6b778
	if ctx.cr[0].eq {
	pc = 0x82F6B778; continue 'dispatch;
	}
	// 82F6B764: 817A0078  lwz r11, 0x78(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F6B768: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B76C: 816B0108  lwz r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) } as u64;
	// 82F6B770: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F6B774: 48000030  b 0x82f6b7a4
	pc = 0x82F6B7A4; continue 'dispatch;
	// 82F6B778: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B77C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6B784: 409A0008  bne cr6, 0x82f6b78c
	if !ctx.cr[6].eq {
	pc = 0x82F6B78C; continue 'dispatch;
	}
	// 82F6B788: 48002A29  bl 0x82f6e1b0
	ctx.lr = 0x82F6B78C;
	sub_82F6E1B0(ctx, base);
	// 82F6B78C: 817A0078  lwz r11, 0x78(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(120 as u32) ) } as u64;
	// 82F6B790: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B794: 816B0108  lwz r11, 0x108(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(264 as u32) ) } as u64;
	// 82F6B798: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B79C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B7A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6B7A4: 3BFA0078  addi r31, r26, 0x78
	ctx.r[31].s64 = ctx.r[26].s64 + 120;
	// 82F6B7A8: 409A0034  bne cr6, 0x82f6b7dc
	if !ctx.cr[6].eq {
	pc = 0x82F6B7DC; continue 'dispatch;
	}
	// 82F6B7AC: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B7B0: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 82F6B7B4: 419A0028  beq cr6, 0x82f6b7dc
	if ctx.cr[6].eq {
	pc = 0x82F6B7DC; continue 'dispatch;
	}
	// 82F6B7B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6B7BC: 837E0000  lwz r27, 0(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B7C0: 48005E41  bl 0x82f71600
	ctx.lr = 0x82F6B7C4;
	sub_82F71600(ctx, base);
	// 82F6B7C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82F6B7C8: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 82F6B7CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6B7D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6B7D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B7D8: 4E800421  bctrl
	ctx.lr = 0x82F6B7DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B7DC: 817EFF80  lwz r11, -0x80(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F6B7E0: 387EFF80  addi r3, r30, -0x80
	ctx.r[3].s64 = ctx.r[30].s64 + -128;
	// 82F6B7E4: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F6B7E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B7EC: 4E800421  bctrl
	ctx.lr = 0x82F6B7F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B7F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6B7F4: 4182002C  beq 0x82f6b820
	if ctx.cr[0].eq {
	pc = 0x82F6B820; continue 'dispatch;
	}
	// 82F6B7F8: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B7FC: 38630010  addi r3, r3, 0x10
	ctx.r[3].s64 = ctx.r[3].s64 + 16;
	// 82F6B800: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82F6B804: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82F6B808: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F6B80C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82F6B810: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6B814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B818: 4E800421  bctrl
	ctx.lr = 0x82F6B81C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B81C: 48000008  b 0x82f6b824
	pc = 0x82F6B824; continue 'dispatch;
	// 82F6B820: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6B824: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F6B828: 4BD3DC24  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B830 size=252
    let mut pc: u32 = 0x82F6B830;
    'dispatch: loop {
        match pc {
            0x82F6B830 => {
    //   block [0x82F6B830..0x82F6B92C)
	// 82F6B830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B834: 4BD3DBCD  bl 0x82ca9400
	ctx.lr = 0x82F6B838;
	sub_82CA93D0(ctx, base);
	// 82F6B838: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B83C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F6B840: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6B844: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6B848: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82F6B84C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B850: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B854: 556B1FFF  rlwinm. r11, r11, 3, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B858: 41820054  beq 0x82f6b8ac
	if ctx.cr[0].eq {
	pc = 0x82F6B8AC; continue 'dispatch;
	}
	// 82F6B85C: 3BFCFF80  addi r31, r28, -0x80
	ctx.r[31].s64 = ctx.r[28].s64 + -128;
	// 82F6B860: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6B864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B868: 4BFFFBC1  bl 0x82f6b428
	ctx.lr = 0x82F6B86C;
	sub_82F6B428(ctx, base);
	// 82F6B86C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6B870: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 82F6B874: 419A0038  beq cr6, 0x82f6b8ac
	if ctx.cr[6].eq {
	pc = 0x82F6B8AC; continue 'dispatch;
	}
	// 82F6B878: 2F1E001F  cmpwi cr6, r30, 0x1f
	ctx.cr[6].compare_i32(ctx.r[30].s32, 31, &mut ctx.xer);
	// 82F6B87C: 41990030  bgt cr6, 0x82f6b8ac
	if ctx.cr[6].gt {
	pc = 0x82F6B8AC; continue 'dispatch;
	}
	// 82F6B880: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B888: 816B00D4  lwz r11, 0xd4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 82F6B88C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B890: 4E800421  bctrl
	ctx.lr = 0x82F6B894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B894: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6B898: 7D6BF030  slw r11, r11, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 82F6B89C: 7C6B5839  and. r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B8A0: 4182000C  beq 0x82f6b8ac
	if ctx.cr[0].eq {
	pc = 0x82F6B8AC; continue 'dispatch;
	}
	// 82F6B8A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6B8A8: 4800007C  b 0x82f6b924
	pc = 0x82F6B924; continue 'dispatch;
	// 82F6B8AC: 817CFF80  lwz r11, -0x80(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-128 as u32) ) } as u64;
	// 82F6B8B0: 387CFF80  addi r3, r28, -0x80
	ctx.r[3].s64 = ctx.r[28].s64 + -128;
	// 82F6B8B4: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 82F6B8B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B8BC: 4E800421  bctrl
	ctx.lr = 0x82F6B8C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B8C0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6B8C4: 4182005C  beq 0x82f6b920
	if ctx.cr[0].eq {
	pc = 0x82F6B920; continue 'dispatch;
	}
	// 82F6B8C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B8CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B8D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B8D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B8D8: 4E800421  bctrl
	ctx.lr = 0x82F6B8DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B8DC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6B8E0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82F6B8E4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82F6B8E8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82F6B8EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6B8F0: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82F6B8F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B8F8: 4E800421  bctrl
	ctx.lr = 0x82F6B8FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B8FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B900: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6B904: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6B908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B90C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6B914: 4E800421  bctrl
	ctx.lr = 0x82F6B918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6B918: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6B91C: 48000008  b 0x82f6b924
	pc = 0x82F6B924; continue 'dispatch;
	// 82F6B920: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6B924: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F6B928: 4BD3DB28  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B930 size=76
    let mut pc: u32 = 0x82F6B930;
    'dispatch: loop {
        match pc {
            0x82F6B930 => {
    //   block [0x82F6B930..0x82F6B97C)
	// 82F6B930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6B938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6B93C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6B940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B948: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6B94C: 4BFFF79D  bl 0x82f6b0e8
	ctx.lr = 0x82F6B950;
	sub_82F6B0E8(ctx, base);
	// 82F6B950: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6B954: 4182000C  beq 0x82f6b960
	if ctx.cr[0].eq {
	pc = 0x82F6B960; continue 'dispatch;
	}
	// 82F6B958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B95C: 4BF91F45  bl 0x82efd8a0
	ctx.lr = 0x82F6B960;
	sub_82EFD8A0(ctx, base);
	// 82F6B960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6B964: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6B968: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6B96C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6B970: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6B974: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6B978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6B980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6B980 size=404
    let mut pc: u32 = 0x82F6B980;
    'dispatch: loop {
        match pc {
            0x82F6B980 => {
    //   block [0x82F6B980..0x82F6BB14)
	// 82F6B980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6B984: 4BD3DA81  bl 0x82ca9404
	ctx.lr = 0x82F6B988;
	sub_82CA93D0(ctx, base);
	// 82F6B988: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6B98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6B990: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6B994: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6B998: 48000549  bl 0x82f6bee0
	ctx.lr = 0x82F6B99C;
	sub_82F6BEE0(ctx, base);
	// 82F6B99C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B9A0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B9A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B9A8: 7D27F038  and r7, r9, r30
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[30].u64;
	// 82F6B9AC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82F6B9B0: 1D67001C  mulli r11, r7, 0x1c
	ctx.r[11].s64 = ctx.r[7].s64 * 28;
	// 82F6B9B4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6B9B8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6B9BC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F6B9C0: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6B9C4: 3B8B0008  addi r28, r11, 8
	ctx.r[28].s64 = ctx.r[11].s64 + 8;
	// 82F6B9C8: 2F03FFFE  cmpwi cr6, r3, -2
	ctx.cr[6].compare_i32(ctx.r[3].s32, -2, &mut ctx.xer);
	// 82F6B9CC: 409A001C  bne cr6, 0x82f6b9e8
	if !ctx.cr[6].eq {
	pc = 0x82F6B9E8; continue 'dispatch;
	}
	// 82F6B9D0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F6B9D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6B9D8: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6B9DC: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82F6B9E0: 4BFFF0A9  bl 0x82f6aa88
	ctx.lr = 0x82F6B9E4;
	sub_82F6AA88(ctx, base);
	// 82F6B9E4: 48000128  b 0x82f6bb0c
	pc = 0x82F6BB0C; continue 'dispatch;
	// 82F6B9E8: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6B9EC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82F6B9F0: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82F6B9F4: 7D7D2038  and r29, r11, r4
	ctx.r[29].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 82F6B9F8: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s64 = ctx.r[29].s64 * 28;
	// 82F6B9FC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F6BA00: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BA04: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6BA08: 409AFFE8  bne cr6, 0x82f6b9f0
	if !ctx.cr[6].eq {
	pc = 0x82F6B9F0; continue 'dispatch;
	}
	// 82F6BA0C: 1D5D001C  mulli r10, r29, 0x1c
	ctx.r[10].s64 = ctx.r[29].s64 * 28;
	// 82F6BA10: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BA14: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BA18: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82F6BA1C: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82F6BA20: 3CC00002  lis r6, 2
	ctx.r[6].s64 = 131072;
	// 82F6BA24: 38AA0008  addi r5, r10, 8
	ctx.r[5].s64 = ctx.r[10].s64 + 8;
	// 82F6BA28: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F6BA2C: 41980010  blt cr6, 0x82f6ba3c
	if ctx.cr[6].lt {
	pc = 0x82F6BA3C; continue 'dispatch;
	}
	// 82F6BA30: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F6BA34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6BA38: 40990008  ble cr6, 0x82f6ba40
	if !ctx.cr[6].gt {
	pc = 0x82F6BA40; continue 'dispatch;
	}
	// 82F6BA3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6BA40: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6BA44: 4182000C  beq 0x82f6ba50
	if ctx.cr[0].eq {
	pc = 0x82F6BA50; continue 'dispatch;
	}
	// 82F6BA48: A97E0008  lha r11, 8(r30)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6BA4C: 7D684278  xor r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82F6BA50: 7D0B2038  and r11, r8, r4
	ctx.r[11].u64 = ctx.r[8].u64 & ctx.r[4].u64;
	// 82F6BA54: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82F6BA58: 409A0030  bne cr6, 0x82f6ba88
	if !ctx.cr[6].eq {
	pc = 0x82F6BA88; continue 'dispatch;
	}
	// 82F6BA5C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82F6BA60: 419A0014  beq cr6, 0x82f6ba74
	if ctx.cr[6].eq {
	pc = 0x82F6BA74; continue 'dispatch;
	}
	// 82F6BA64: 90650000  stw r3, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82F6BA68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6BA6C: 38650004  addi r3, r5, 4
	ctx.r[3].s64 = ctx.r[5].s64 + 4;
	// 82F6BA70: 4BFFF019  bl 0x82f6aa88
	ctx.lr = 0x82F6BA74;
	sub_82F6AA88(ctx, base);
	// 82F6BA74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6BA78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6BA7C: 4BFFE8B5  bl 0x82f6a330
	ctx.lr = 0x82F6BA80;
	sub_82F6A330(ctx, base);
	// 82F6BA80: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6BA84: 48000088  b 0x82f6bb0c
	pc = 0x82F6BB0C; continue 'dispatch;
	// 82F6BA88: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BA8C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BA90: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F6BA94: 41980010  blt cr6, 0x82f6baa4
	if ctx.cr[6].lt {
	pc = 0x82F6BAA4; continue 'dispatch;
	}
	// 82F6BA98: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F6BA9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6BAA0: 40990008  ble cr6, 0x82f6baa8
	if !ctx.cr[6].gt {
	pc = 0x82F6BAA8; continue 'dispatch;
	}
	// 82F6BAA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6BAA8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6BAAC: 4182000C  beq 0x82f6bab8
	if ctx.cr[0].eq {
	pc = 0x82F6BAB8; continue 'dispatch;
	}
	// 82F6BAB0: A97E0008  lha r11, 8(r30)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6BAB4: 7D6A5278  xor r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82F6BAB8: 7D4B2038  and r11, r10, r4
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	// 82F6BABC: 48000008  b 0x82f6bac4
	pc = 0x82F6BAC4; continue 'dispatch;
	// 82F6BAC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BAC4: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 82F6BAC8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F6BACC: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F6BAD0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BAD4: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82F6BAD8: 409AFFE8  bne cr6, 0x82f6bac0
	if !ctx.cr[6].eq {
	pc = 0x82F6BAC0; continue 'dispatch;
	}
	// 82F6BADC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82F6BAE0: 419A0014  beq cr6, 0x82f6baf4
	if ctx.cr[6].eq {
	pc = 0x82F6BAF4; continue 'dispatch;
	}
	// 82F6BAE4: 90650000  stw r3, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82F6BAE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6BAEC: 38650004  addi r3, r5, 4
	ctx.r[3].s64 = ctx.r[5].s64 + 4;
	// 82F6BAF0: 4BFFEF99  bl 0x82f6aa88
	ctx.lr = 0x82F6BAF4;
	sub_82F6AA88(ctx, base);
	// 82F6BAF4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6BAF8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6BAFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6BB00: 4BFFE831  bl 0x82f6a330
	ctx.lr = 0x82F6BB04;
	sub_82F6A330(ctx, base);
	// 82F6BB04: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F6BB08: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6BB0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6BB10: 4BD3D944  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BB18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6BB18 size=100
    let mut pc: u32 = 0x82F6BB18;
    'dispatch: loop {
        match pc {
            0x82F6BB18 => {
    //   block [0x82F6BB18..0x82F6BB7C)
	// 82F6BB18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6BB1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6BB20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6BB24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6BB28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6BB2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6BB30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6BB34: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82F6BB38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6BB3C: 4BFDF295  bl 0x82f4add0
	ctx.lr = 0x82F6BB40;
	sub_82F4ADD0(ctx, base);
	// 82F6BB40: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6BB44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6BB48: 419A0008  beq cr6, 0x82f6bb50
	if ctx.cr[6].eq {
	pc = 0x82F6BB50; continue 'dispatch;
	}
	// 82F6BB4C: 4BF91D55  bl 0x82efd8a0
	ctx.lr = 0x82F6BB50;
	sub_82EFD8A0(ctx, base);
	// 82F6BB50: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6BB54: 4182000C  beq 0x82f6bb60
	if ctx.cr[0].eq {
	pc = 0x82F6BB60; continue 'dispatch;
	}
	// 82F6BB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6BB5C: 4BF91D45  bl 0x82efd8a0
	ctx.lr = 0x82F6BB60;
	sub_82EFD8A0(ctx, base);
	// 82F6BB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6BB64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6BB68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6BB6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6BB70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6BB74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6BB78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6BB80 size=120
    let mut pc: u32 = 0x82F6BB80;
    'dispatch: loop {
        match pc {
            0x82F6BB80 => {
    //   block [0x82F6BB80..0x82F6BBF8)
	// 82F6BB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6BB84: 4BD3D885  bl 0x82ca9408
	ctx.lr = 0x82F6BB88;
	sub_82CA93D0(ctx, base);
	// 82F6BB88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6BB8C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6BB90: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BB94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BB98: 419A0058  beq cr6, 0x82f6bbf0
	if ctx.cr[6].eq {
	pc = 0x82F6BBF0; continue 'dispatch;
	}
	// 82F6BB9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BBA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82F6BBA4: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82F6BBA8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BBAC: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82F6BBB0: 3BCB0008  addi r30, r11, 8
	ctx.r[30].s64 = ctx.r[11].s64 + 8;
	// 82F6BBB4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BBB8: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6BBBC: 419A0018  beq cr6, 0x82f6bbd4
	if ctx.cr[6].eq {
	pc = 0x82F6BBD4; continue 'dispatch;
	}
	// 82F6BBC0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6BBC4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82F6BBC8: 4BFFF611  bl 0x82f6b1d8
	ctx.lr = 0x82F6BBCC;
	sub_82F6B1D8(ctx, base);
	// 82F6BBCC: 3960FFFE  li r11, -2
	ctx.r[11].s64 = -2;
	// 82F6BBD0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6BBD4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F6BBD8: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82F6BBDC: 4082FFCC  bne 0x82f6bba8
	if !ctx.cr[0].eq {
	pc = 0x82F6BBA8; continue 'dispatch;
	}
	// 82F6BBE0: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BBE4: 4BF91CBD  bl 0x82efd8a0
	ctx.lr = 0x82F6BBE8;
	sub_82EFD8A0(ctx, base);
	// 82F6BBE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6BBEC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6BBF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6BBF4: 4BD3D864  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6BBF8 size=252
    let mut pc: u32 = 0x82F6BBF8;
    'dispatch: loop {
        match pc {
            0x82F6BBF8 => {
    //   block [0x82F6BBF8..0x82F6BCF4)
	// 82F6BBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6BBFC: 4BD3D811  bl 0x82ca940c
	ctx.lr = 0x82F6BC00;
	sub_82CA93D0(ctx, base);
	// 82F6BC00: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6BC04: 8163025C  lwz r11, 0x25c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(604 as u32) ) } as u64;
	// 82F6BC08: 3BC3025C  addi r30, r3, 0x25c
	ctx.r[30].s64 = ctx.r[3].s64 + 604;
	// 82F6BC0C: 3BA30218  addi r29, r3, 0x218
	ctx.r[29].s64 = ctx.r[3].s64 + 536;
	// 82F6BC10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BC14: 419A0010  beq cr6, 0x82f6bc24
	if ctx.cr[6].eq {
	pc = 0x82F6BC24; continue 'dispatch;
	}
	// 82F6BC18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BC1C: 2B0B007B  cmplwi cr6, r11, 0x7b
	ctx.cr[6].compare_u32(ctx.r[11].u32, 123 as u32, &mut ctx.xer);
	// 82F6BC20: 41990010  bgt cr6, 0x82f6bc30
	if ctx.cr[6].gt {
	pc = 0x82F6BC30; continue 'dispatch;
	}
	// 82F6BC24: 3880007B  li r4, 0x7b
	ctx.r[4].s64 = 123;
	// 82F6BC28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6BC2C: 4BFFEC5D  bl 0x82f6a888
	ctx.lr = 0x82F6BC30;
	sub_82F6A888(ctx, base);
	// 82F6BC30: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82F6BC34: 3BEBECD0  addi r31, r11, -0x1330
	ctx.r[31].s64 = ctx.r[11].s64 + -4912;
	// 82F6BC38: 816BECD0  lwz r11, -0x1330(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4912 as u32) ) } as u64;
	// 82F6BC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BC40: 419A00AC  beq cr6, 0x82f6bcec
	if ctx.cr[6].eq {
	pc = 0x82F6BCEC; continue 'dispatch;
	}
	// 82F6BC44: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82F6BC48: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82F6BC4C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82F6BC50: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82F6BC54: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BC58: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6BC5C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BC60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6BC64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6BC68: 409AFFF4  bne cr6, 0x82f6bc5c
	if !ctx.cr[6].eq {
	pc = 0x82F6BC5C; continue 'dispatch;
	}
	// 82F6BC6C: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82F6BC70: 3CC02000  lis r6, 0x2000
	ctx.r[6].s64 = 536870912;
	// 82F6BC74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6BC78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6BC7C: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82F6BC80: 48001E79  bl 0x82f6daf8
	ctx.lr = 0x82F6BC84;
	sub_82F6DAF8(ctx, base);
	// 82F6BC84: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F6BC88: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F6BC8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82F6BC90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6BC94: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6BC98: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6BC9C: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F6BCA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6BCA4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BCA8: 99410050  stb r10, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u8 ) };
	// 82F6BCAC: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6BCB0: 4BFFF591  bl 0x82f6b240
	ctx.lr = 0x82F6BCB4;
	sub_82F6B240(ctx, base);
	// 82F6BCB4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6BCB8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F6BCBC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6BCC0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6BCC4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82F6BCC8: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F6BCCC: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6BCD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BCD4: 409A0008  bne cr6, 0x82f6bcdc
	if !ctx.cr[6].eq {
	pc = 0x82F6BCDC; continue 'dispatch;
	}
	// 82F6BCD8: 48001DB1  bl 0x82f6da88
	ctx.lr = 0x82F6BCDC;
	sub_82F6DA88(ctx, base);
	// 82F6BCDC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82F6BCE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BCE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BCE8: 409AFF6C  bne cr6, 0x82f6bc54
	if !ctx.cr[6].eq {
	pc = 0x82F6BC54; continue 'dispatch;
	}
	// 82F6BCEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6BCF0: 4BD3D76C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6BCF8 size=112
    let mut pc: u32 = 0x82F6BCF8;
    'dispatch: loop {
        match pc {
            0x82F6BCF8 => {
    //   block [0x82F6BCF8..0x82F6BD68)
	// 82F6BCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6BCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6BD00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6BD04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6BD08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6BD0C: 48000010  b 0x82f6bd1c
	pc = 0x82F6BD1C; continue 'dispatch;
	// 82F6BD10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6BD14: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BD18: 4BFFEA09  bl 0x82f6a720
	ctx.lr = 0x82F6BD1C;
	sub_82F6A720(ctx, base);
	// 82F6BD1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BD20: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F6BD24: 409AFFEC  bne cr6, 0x82f6bd10
	if !ctx.cr[6].eq {
	pc = 0x82F6BD10; continue 'dispatch;
	}
	// 82F6BD28: 48000020  b 0x82f6bd48
	pc = 0x82F6BD48; continue 'dispatch;
	// 82F6BD2C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BD30: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6BD34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BD38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6BD3C: 4182000C  beq 0x82f6bd48
	if ctx.cr[0].eq {
	pc = 0x82F6BD48; continue 'dispatch;
	}
	// 82F6BD40: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F6BD44: 4BFFFDD5  bl 0x82f6bb18
	ctx.lr = 0x82F6BD48;
	sub_82F6BB18(ctx, base);
	// 82F6BD48: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BD4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BD50: 409AFFDC  bne cr6, 0x82f6bd2c
	if !ctx.cr[6].eq {
	pc = 0x82F6BD2C; continue 'dispatch;
	}
	// 82F6BD54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6BD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6BD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6BD60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6BD64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BD68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6BD68 size=376
    let mut pc: u32 = 0x82F6BD68;
    'dispatch: loop {
        match pc {
            0x82F6BD68 => {
    //   block [0x82F6BD68..0x82F6BEE0)
	// 82F6BD68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6BD6C: 4BD3D691  bl 0x82ca93fc
	ctx.lr = 0x82F6BD70;
	sub_82CA93D0(ctx, base);
	// 82F6BD70: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6BD74: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82F6BD78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6BD7C: 409A0008  bne cr6, 0x82f6bd84
	if !ctx.cr[6].eq {
	pc = 0x82F6BD84; continue 'dispatch;
	}
	// 82F6BD80: 48000154  b 0x82f6bed4
	pc = 0x82F6BED4; continue 'dispatch;
	// 82F6BD84: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82F6BD88: 4098000C  bge cr6, 0x82f6bd94
	if !ctx.cr[6].lt {
	pc = 0x82F6BD94; continue 'dispatch;
	}
	// 82F6BD8C: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82F6BD90: 4800004C  b 0x82f6bddc
	pc = 0x82F6BDDC; continue 'dispatch;
	// 82F6BD94: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82F6BD98: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82F6BD9C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F6BDA0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6BDA4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F6BDA8: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F6BDAC: 4B288005  bl 0x821f3db0
	ctx.lr = 0x82F6BDB0;
	sub_821F3DB0(ctx, base);
	// 82F6BDB0: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F6BDB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F6BDB8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F6BDBC: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F6BDC0: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6BDC4: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6BDC8: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F6BDCC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F6BDD0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82F6BDD4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6BDD8: 7D3F5830  slw r31, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82F6BDDC: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82F6BDE0: 1D7F001C  mulli r11, r31, 0x1c
	ctx.r[11].s64 = ctx.r[31].s64 * 28;
	// 82F6BDE4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82F6BDE8: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82F6BDEC: 4BF91A75  bl 0x82efd860
	ctx.lr = 0x82F6BDF0;
	sub_82EFD860(ctx, base);
	// 82F6BDF0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82F6BDF4: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82F6BDF8: 93630000  stw r27, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F6BDFC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6BE00: 3B40FFFE  li r26, -2
	ctx.r[26].s64 = -2;
	// 82F6BE04: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6BE08: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6BE0C: 419A0020  beq cr6, 0x82f6be2c
	if ctx.cr[6].eq {
	pc = 0x82F6BE2C; continue 'dispatch;
	}
	// 82F6BE10: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82F6BE14: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6BE18: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6BE1C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6BE20: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82F6BE24: 934A0008  stw r26, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82F6BE28: 4082FFEC  bne 0x82f6be14
	if !ctx.cr[0].eq {
	pc = 0x82F6BE14; continue 'dispatch;
	}
	// 82F6BE2C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BE34: 419A0090  beq cr6, 0x82f6bec4
	if ctx.cr[6].eq {
	pc = 0x82F6BEC4; continue 'dispatch;
	}
	// 82F6BE38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BE3C: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 82F6BE40: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82F6BE44: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BE48: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82F6BE4C: 3BCB0008  addi r30, r11, 8
	ctx.r[30].s64 = ctx.r[11].s64 + 8;
	// 82F6BE50: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BE54: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6BE58: 419A0058  beq cr6, 0x82f6beb0
	if ctx.cr[6].eq {
	pc = 0x82F6BEB0; continue 'dispatch;
	}
	// 82F6BE5C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BE60: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82F6BE64: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BE68: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F6BE6C: 41980014  blt cr6, 0x82f6be80
	if ctx.cr[6].lt {
	pc = 0x82F6BE80; continue 'dispatch;
	}
	// 82F6BE70: 3D400002  lis r10, 2
	ctx.r[10].s64 = 131072;
	// 82F6BE74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6BE78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6BE7C: 40990008  ble cr6, 0x82f6be84
	if !ctx.cr[6].gt {
	pc = 0x82F6BE84; continue 'dispatch;
	}
	// 82F6BE80: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82F6BE84: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6BE88: 4182000C  beq 0x82f6be94
	if ctx.cr[0].eq {
	pc = 0x82F6BE94; continue 'dispatch;
	}
	// 82F6BE8C: A97F0008  lha r11, 8(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6BE90: 7D652A78  xor r5, r11, r5
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[5].u64;
	// 82F6BE94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6BE98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6BE9C: 4BFFFAE5  bl 0x82f6b980
	ctx.lr = 0x82F6BEA0;
	sub_82F6B980(ctx, base);
	// 82F6BEA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6BEA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6BEA8: 4BFFF331  bl 0x82f6b1d8
	ctx.lr = 0x82F6BEAC;
	sub_82F6B1D8(ctx, base);
	// 82F6BEAC: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82F6BEB0: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82F6BEB4: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82F6BEB8: 4082FF8C  bne 0x82f6be44
	if !ctx.cr[0].eq {
	pc = 0x82F6BE44; continue 'dispatch;
	}
	// 82F6BEBC: 80790000  lwz r3, 0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BEC0: 4BF919E1  bl 0x82efd8a0
	ctx.lr = 0x82F6BEC4;
	sub_82EFD8A0(ctx, base);
	// 82F6BEC4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6BEC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6BECC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82F6BED0: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6BED4: 4BFFFCAD  bl 0x82f6bb80
	ctx.lr = 0x82F6BED8;
	sub_82F6BB80(ctx, base);
	// 82F6BED8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6BEDC: 4BD3D570  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6BEE0 size=20
    let mut pc: u32 = 0x82F6BEE0;
    'dispatch: loop {
        match pc {
            0x82F6BEE0 => {
    //   block [0x82F6BEE0..0x82F6BEF4)
	// 82F6BEE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BEE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BEE8: 409A000C  bne cr6, 0x82f6bef4
	if !ctx.cr[6].eq {
		sub_82F6BEF4(ctx, base);
		return;
	}
	// 82F6BEEC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F6BEF0: 4BFFFE78  b 0x82f6bd68
	sub_82F6BD68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BEF4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6BEF4 size=28
    let mut pc: u32 = 0x82F6BEF4;
    'dispatch: loop {
        match pc {
            0x82F6BEF4 => {
    //   block [0x82F6BEF4..0x82F6BF10)
	// 82F6BEF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BEF8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BEFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6BF00: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F6BF04: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6BF08: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6BF0C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6BF10 size=16
    let mut pc: u32 = 0x82F6BF10;
    'dispatch: loop {
        match pc {
            0x82F6BF10 => {
    //   block [0x82F6BF10..0x82F6BF20)
	// 82F6BF10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BF14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6BF18: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6BF1C: 4BFFFE4C  b 0x82f6bd68
	sub_82F6BD68(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6BF20 size=4
    let mut pc: u32 = 0x82F6BF20;
    'dispatch: loop {
        match pc {
            0x82F6BF20 => {
    //   block [0x82F6BF20..0x82F6BF24)
	// 82F6BF20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6BF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6BF28 size=568
    let mut pc: u32 = 0x82F6BF28;
    'dispatch: loop {
        match pc {
            0x82F6BF28 => {
    //   block [0x82F6BF28..0x82F6C160)
	// 82F6BF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6BF2C: 4BD3D4D9  bl 0x82ca9404
	ctx.lr = 0x82F6BF30;
	sub_82CA93D0(ctx, base);
	// 82F6BF30: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6BF34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6BF38: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6BF3C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6BF40: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6BF44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BF48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6BF4C: 409A000C  bne cr6, 0x82f6bf58
	if !ctx.cr[6].eq {
	pc = 0x82F6BF58; continue 'dispatch;
	}
	// 82F6BF50: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F6BF54: 4800002C  b 0x82f6bf80
	pc = 0x82F6BF80; continue 'dispatch;
	// 82F6BF58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BF5C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BF60: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6BF64: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F6BF68: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6BF6C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6BF70: 40990018  ble cr6, 0x82f6bf88
	if !ctx.cr[6].gt {
	pc = 0x82F6BF88; continue 'dispatch;
	}
	// 82F6BF74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BF78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6BF7C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6BF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6BF84: 4BFFFDE5  bl 0x82f6bd68
	ctx.lr = 0x82F6BF88;
	sub_82F6BD68(ctx, base);
	// 82F6BF88: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BF8C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6BF90: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BF94: 7D47F038  and r7, r10, r30
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[30].u64;
	// 82F6BF98: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6BF9C: 1D47001C  mulli r10, r7, 0x1c
	ctx.r[10].s64 = ctx.r[7].s64 * 28;
	// 82F6BFA0: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6BFA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6BFA8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6BFAC: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6BFB0: 3B8A0008  addi r28, r10, 8
	ctx.r[28].s64 = ctx.r[10].s64 + 8;
	// 82F6BFB4: 2F03FFFE  cmpwi cr6, r3, -2
	ctx.cr[6].compare_i32(ctx.r[3].s32, -2, &mut ctx.xer);
	// 82F6BFB8: 409A0044  bne cr6, 0x82f6bffc
	if !ctx.cr[6].eq {
	pc = 0x82F6BFFC; continue 'dispatch;
	}
	// 82F6BFBC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6BFC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6BFC4: 4BFFEA15  bl 0x82f6a9d8
	ctx.lr = 0x82F6BFC8;
	sub_82F6A9D8(ctx, base);
	// 82F6BFC8: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F6BFCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6BFD0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6BFD4: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82F6BFD8: 4BFFEAB1  bl 0x82f6aa88
	ctx.lr = 0x82F6BFDC;
	sub_82F6AA88(ctx, base);
	// 82F6BFDC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6BFE0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82F6BFE4: 4BFB15FD  bl 0x82f1d5e0
	ctx.lr = 0x82F6BFE8;
	sub_82F1D5E0(ctx, base);
	// 82F6BFE8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F6BFEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6BFF0: 419A0168  beq cr6, 0x82f6c158
	if ctx.cr[6].eq {
	pc = 0x82F6C158; continue 'dispatch;
	}
	// 82F6BFF4: 4BF918AD  bl 0x82efd8a0
	ctx.lr = 0x82F6BFF8;
	sub_82EFD8A0(ctx, base);
	// 82F6BFF8: 48000160  b 0x82f6c158
	pc = 0x82F6C158; continue 'dispatch;
	// 82F6BFFC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C000: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82F6C004: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 82F6C008: 7D5D2038  and r29, r10, r4
	ctx.r[29].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	// 82F6C00C: 1D5D001C  mulli r10, r29, 0x1c
	ctx.r[10].s64 = ctx.r[29].s64 * 28;
	// 82F6C010: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6C014: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C018: 2F0AFFFE  cmpwi cr6, r10, -2
	ctx.cr[6].compare_i32(ctx.r[10].s32, -2, &mut ctx.xer);
	// 82F6C01C: 409AFFE8  bne cr6, 0x82f6c004
	if !ctx.cr[6].eq {
	pc = 0x82F6C004; continue 'dispatch;
	}
	// 82F6C020: 1D3D001C  mulli r9, r29, 0x1c
	ctx.r[9].s64 = ctx.r[29].s64 * 28;
	// 82F6C024: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C028: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C02C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F6C030: 3BFC0004  addi r31, r28, 4
	ctx.r[31].s64 = ctx.r[28].s64 + 4;
	// 82F6C034: 3CC00002  lis r6, 2
	ctx.r[6].s64 = 131072;
	// 82F6C038: 38A90008  addi r5, r9, 8
	ctx.r[5].s64 = ctx.r[9].s64 + 8;
	// 82F6C03C: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82F6C040: 41980010  blt cr6, 0x82f6c050
	if ctx.cr[6].lt {
	pc = 0x82F6C050; continue 'dispatch;
	}
	// 82F6C044: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F6C048: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F6C04C: 40990008  ble cr6, 0x82f6c054
	if !ctx.cr[6].gt {
	pc = 0x82F6C054; continue 'dispatch;
	}
	// 82F6C050: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6C054: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6C058: 4182000C  beq 0x82f6c064
	if ctx.cr[0].eq {
	pc = 0x82F6C064; continue 'dispatch;
	}
	// 82F6C05C: A95F0008  lha r10, 8(r31)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6C060: 7D484278  xor r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 ^ ctx.r[8].u64;
	// 82F6C064: 7D0A2038  and r10, r8, r4
	ctx.r[10].u64 = ctx.r[8].u64 & ctx.r[4].u64;
	// 82F6C068: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82F6C06C: 409A004C  bne cr6, 0x82f6c0b8
	if !ctx.cr[6].eq {
	pc = 0x82F6C0B8; continue 'dispatch;
	}
	// 82F6C070: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82F6C074: 419A0014  beq cr6, 0x82f6c088
	if ctx.cr[6].eq {
	pc = 0x82F6C088; continue 'dispatch;
	}
	// 82F6C078: 90650000  stw r3, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82F6C07C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6C080: 38650004  addi r3, r5, 4
	ctx.r[3].s64 = ctx.r[5].s64 + 4;
	// 82F6C084: 4BFFEA05  bl 0x82f6aa88
	ctx.lr = 0x82F6C088;
	sub_82F6AA88(ctx, base);
	// 82F6C088: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C08C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F6C090: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C094: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6C098: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C09C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6C0A0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C0A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6C0A8: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C0AC: 4BFD132D  bl 0x82f3d3d8
	ctx.lr = 0x82F6C0B0;
	sub_82F3D3D8(ctx, base);
	// 82F6C0B0: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6C0B4: 480000A4  b 0x82f6c158
	pc = 0x82F6C158; continue 'dispatch;
	// 82F6C0B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C0BC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C0C0: 2B0A0400  cmplwi cr6, r10, 0x400
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1024 as u32, &mut ctx.xer);
	// 82F6C0C4: 41980010  blt cr6, 0x82f6c0d4
	if ctx.cr[6].lt {
	pc = 0x82F6C0D4; continue 'dispatch;
	}
	// 82F6C0C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F6C0CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F6C0D0: 40990008  ble cr6, 0x82f6c0d8
	if !ctx.cr[6].gt {
	pc = 0x82F6C0D8; continue 'dispatch;
	}
	// 82F6C0D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6C0D8: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6C0DC: 4182000C  beq 0x82f6c0e8
	if ctx.cr[0].eq {
	pc = 0x82F6C0E8; continue 'dispatch;
	}
	// 82F6C0E0: A95F0008  lha r10, 8(r31)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6C0E4: 7D494A78  xor r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 ^ ctx.r[9].u64;
	// 82F6C0E8: 7D2A2038  and r10, r9, r4
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[4].u64;
	// 82F6C0EC: 48000008  b 0x82f6c0f4
	pc = 0x82F6C0F4; continue 'dispatch;
	// 82F6C0F0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C0F4: 1D4A001C  mulli r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 * 28;
	// 82F6C0F8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6C0FC: 3BCA0008  addi r30, r10, 8
	ctx.r[30].s64 = ctx.r[10].s64 + 8;
	// 82F6C100: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C104: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82F6C108: 409AFFE8  bne cr6, 0x82f6c0f0
	if !ctx.cr[6].eq {
	pc = 0x82F6C0F0; continue 'dispatch;
	}
	// 82F6C10C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82F6C110: 419A0014  beq cr6, 0x82f6c124
	if ctx.cr[6].eq {
	pc = 0x82F6C124; continue 'dispatch;
	}
	// 82F6C114: 90650000  stw r3, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82F6C118: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6C11C: 38650004  addi r3, r5, 4
	ctx.r[3].s64 = ctx.r[5].s64 + 4;
	// 82F6C120: 4BFFE969  bl 0x82f6aa88
	ctx.lr = 0x82F6C124;
	sub_82F6AA88(ctx, base);
	// 82F6C124: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6C128: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82F6C12C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C130: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C134: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6C138: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C13C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6C140: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C144: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6C148: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C14C: 4BFD128D  bl 0x82f3d3d8
	ctx.lr = 0x82F6C150;
	sub_82F3D3D8(ctx, base);
	// 82F6C150: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F6C154: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6C158: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6C15C: 4BD3D2F8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C160 size=208
    let mut pc: u32 = 0x82F6C160;
    'dispatch: loop {
        match pc {
            0x82F6C160 => {
    //   block [0x82F6C160..0x82F6C230)
	// 82F6C160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6C168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6C16C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6C170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C174: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C178: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6C17C: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82F6C180: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6C184: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6C188: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6C18C: 4BFFB315  bl 0x82f674a0
	ctx.lr = 0x82F6C190;
	sub_82F674A0(ctx, base);
	// 82F6C190: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82F6C194: 480205C5  bl 0x82f8c758
	ctx.lr = 0x82F6C198;
	sub_82F8C758(ctx, base);
	// 82F6C198: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6C19C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6C1A0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6C1A4: 396B2AF0  addi r11, r11, 0x2af0
	ctx.r[11].s64 = ctx.r[11].s64 + 10992;
	// 82F6C1A8: 394AE1D4  addi r10, r10, -0x1e2c
	ctx.r[10].s64 = ctx.r[10].s64 + -7724;
	// 82F6C1AC: 39292AA0  addi r9, r9, 0x2aa0
	ctx.r[9].s64 = ctx.r[9].s64 + 10912;
	// 82F6C1B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6C1B4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6C1B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6C1BC: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 82F6C1C0: 419A000C  beq cr6, 0x82f6c1cc
	if ctx.cr[6].eq {
	pc = 0x82F6C1CC; continue 'dispatch;
	}
	// 82F6C1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6C1C8: 4BF8BBF1  bl 0x82ef7db8
	ctx.lr = 0x82F6C1CC;
	sub_82EF7DB8(ctx, base);
	// 82F6C1CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6C1D0: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 82F6C1D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F6C1D8: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82F6C1DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6C1E0: 995F0090  stb r10, 0x90(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u8 ) };
	// 82F6C1E4: 997F0091  stb r11, 0x91(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 82F6C1E8: 995F0092  stb r10, 0x92(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(146 as u32), ctx.r[10].u8 ) };
	// 82F6C1EC: 997F0094  stb r11, 0x94(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 82F6C1F0: 917F0098  stw r11, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82F6C1F4: 997F009C  stb r11, 0x9c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[11].u8 ) };
	// 82F6C1F8: 997F009D  stb r11, 0x9d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(157 as u32), ctx.r[11].u8 ) };
	// 82F6C1FC: 917F00A0  stw r11, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82F6C200: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82F6C204: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82F6C208: 917F00AC  stw r11, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82F6C20C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82F6C210: 997F009E  stb r11, 0x9e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(158 as u32), ctx.r[11].u8 ) };
	// 82F6C214: 995F0093  stb r10, 0x93(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(147 as u32), ctx.r[10].u8 ) };
	// 82F6C218: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6C21C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6C220: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6C224: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6C228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6C22C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C230 size=224
    let mut pc: u32 = 0x82F6C230;
    'dispatch: loop {
        match pc {
            0x82F6C230 => {
    //   block [0x82F6C230..0x82F6C310)
	// 82F6C230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C234: 4BD3D1D9  bl 0x82ca940c
	ctx.lr = 0x82F6C238;
	sub_82CA93D0(ctx, base);
	// 82F6C238: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C23C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6C240: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6C244: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6C248: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82F6C24C: 394A2AF0  addi r10, r10, 0x2af0
	ctx.r[10].s64 = ctx.r[10].s64 + 10992;
	// 82F6C250: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F6C254: 3929E1D4  addi r9, r9, -0x1e2c
	ctx.r[9].s64 = ctx.r[9].s64 + -7724;
	// 82F6C258: 39082AA0  addi r8, r8, 0x2aa0
	ctx.r[8].s64 = ctx.r[8].s64 + 10912;
	// 82F6C25C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6C260: 3BDF008C  addi r30, r31, 0x8c
	ctx.r[30].s64 = ctx.r[31].s64 + 140;
	// 82F6C264: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F6C268: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 82F6C26C: 911F0080  stw r8, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 82F6C270: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C274: 419A000C  beq cr6, 0x82f6c280
	if ctx.cr[6].eq {
	pc = 0x82F6C280; continue 'dispatch;
	}
	// 82F6C278: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82F6C27C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6C280: 807F00AC  lwz r3, 0xac(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6C284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6C288: 419A0008  beq cr6, 0x82f6c290
	if ctx.cr[6].eq {
	pc = 0x82F6C290; continue 'dispatch;
	}
	// 82F6C28C: 4BF91615  bl 0x82efd8a0
	ctx.lr = 0x82F6C290;
	sub_82EFD8A0(ctx, base);
	// 82F6C290: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 82F6C294: 4BFFF8ED  bl 0x82f6bb80
	ctx.lr = 0x82F6C298;
	sub_82F6BB80(ctx, base);
	// 82F6C298: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C29C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6C2A0: 419A0024  beq cr6, 0x82f6c2c4
	if ctx.cr[6].eq {
	pc = 0x82F6C2C4; continue 'dispatch;
	}
	// 82F6C2A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C2A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C2AC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6C2B0: 41810014  bgt 0x82f6c2c4
	if ctx.cr[0].gt {
	pc = 0x82F6C2C4; continue 'dispatch;
	}
	// 82F6C2B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6C2B8: 4BFFACE9  bl 0x82f66fa0
	ctx.lr = 0x82F6C2BC;
	sub_82F66FA0(ctx, base);
	// 82F6C2BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6C2C0: 4BF915E1  bl 0x82efd8a0
	ctx.lr = 0x82F6C2C4;
	sub_82EFD8A0(ctx, base);
	// 82F6C2C4: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82F6C2C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6C2CC: 419A0008  beq cr6, 0x82f6c2d4
	if ctx.cr[6].eq {
	pc = 0x82F6C2D4; continue 'dispatch;
	}
	// 82F6C2D0: 4BF8BFC9  bl 0x82ef8298
	ctx.lr = 0x82F6C2D4;
	sub_82EF8298(ctx, base);
	// 82F6C2D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6C2D8: 48020499  bl 0x82f8c770
	ctx.lr = 0x82F6C2DC;
	sub_82F8C770(ctx, base);
	// 82F6C2DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6C2E0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6C2E4: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6C2E8: 396B27E0  addi r11, r11, 0x27e0
	ctx.r[11].s64 = ctx.r[11].s64 + 10208;
	// 82F6C2EC: 394A2870  addi r10, r10, 0x2870
	ctx.r[10].s64 = ctx.r[10].s64 + 10352;
	// 82F6C2F0: 3929106C  addi r9, r9, 0x106c
	ctx.r[9].s64 = ctx.r[9].s64 + 4204;
	// 82F6C2F4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6C2F8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6C2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6C300: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82F6C304: 4BF91715  bl 0x82efda18
	ctx.lr = 0x82F6C308;
	sub_82EFDA18(ctx, base);
	// 82F6C308: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6C30C: 4BD3D150  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C310 size=308
    let mut pc: u32 = 0x82F6C310;
    'dispatch: loop {
        match pc {
            0x82F6C310 => {
    //   block [0x82F6C310..0x82F6C444)
	// 82F6C310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C314: 4BD3D0F9  bl 0x82ca940c
	ctx.lr = 0x82F6C318;
	sub_82CA93D0(ctx, base);
	// 82F6C318: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C31C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6C320: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6C324: 4BFFF85D  bl 0x82f6bb80
	ctx.lr = 0x82F6C328;
	sub_82F6BB80(ctx, base);
	// 82F6C328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C32C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F6C330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6C334: 419A0014  beq cr6, 0x82f6c348
	if ctx.cr[6].eq {
	pc = 0x82F6C348; continue 'dispatch;
	}
	// 82F6C338: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C33C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6C340: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82F6C344: 409A0008  bne cr6, 0x82f6c34c
	if !ctx.cr[6].eq {
	pc = 0x82F6C34C; continue 'dispatch;
	}
	// 82F6C348: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82F6C34C: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6C350: 408200EC  bne 0x82f6c43c
	if !ctx.cr[0].eq {
	pc = 0x82F6C43C; continue 'dispatch;
	}
	// 82F6C354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6C358: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82F6C35C: 419A0008  beq cr6, 0x82f6c364
	if ctx.cr[6].eq {
	pc = 0x82F6C364; continue 'dispatch;
	}
	// 82F6C360: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C364: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C368: 1D4A0005  mulli r10, r10, 5
	ctx.r[10].s64 = ctx.r[10].s64 * 5;
	// 82F6C36C: 5544F0BE  srwi r4, r10, 2
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6C370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6C374: 419A0010  beq cr6, 0x82f6c384
	if ctx.cr[6].eq {
	pc = 0x82F6C384; continue 'dispatch;
	}
	// 82F6C378: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C37C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F6C380: 4198000C  blt cr6, 0x82f6c38c
	if ctx.cr[6].lt {
	pc = 0x82F6C38C; continue 'dispatch;
	}
	// 82F6C384: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6C388: 4BFFF9E1  bl 0x82f6bd68
	ctx.lr = 0x82F6C38C;
	sub_82F6BD68(ctx, base);
	// 82F6C38C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6C390: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6C394: 4BFFDE25  bl 0x82f6a1b8
	ctx.lr = 0x82F6C398;
	sub_82F6A1B8(ctx, base);
	// 82F6C398: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82F6C39C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82F6C3A0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82F6C3A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6C3A8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6C3AC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82F6C3B0: 4BFCE609  bl 0x82f3a9b8
	ctx.lr = 0x82F6C3B4;
	sub_82F3A9B8(ctx, base);
	// 82F6C3B4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C3B8: 40820084  bne 0x82f6c43c
	if !ctx.cr[0].eq {
	pc = 0x82F6C43C; continue 'dispatch;
	}
	// 82F6C3BC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82F6C3C0: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82F6C3C4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6C3C8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82F6C3CC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82F6C3D0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82F6C3D4: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 * 28;
	// 82F6C3D8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C3DC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6C3E0: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82F6C3E4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6C3E8: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C3EC: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F6C3F0: 41980014  blt cr6, 0x82f6c404
	if ctx.cr[6].lt {
	pc = 0x82F6C404; continue 'dispatch;
	}
	// 82F6C3F4: 3D400002  lis r10, 2
	ctx.r[10].s64 = 131072;
	// 82F6C3F8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6C3FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6C400: 40990008  ble cr6, 0x82f6c408
	if !ctx.cr[6].gt {
	pc = 0x82F6C408; continue 'dispatch;
	}
	// 82F6C404: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82F6C408: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C40C: 4182000C  beq 0x82f6c418
	if ctx.cr[0].eq {
	pc = 0x82F6C418; continue 'dispatch;
	}
	// 82F6C410: A9640008  lha r11, 8(r4)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6C414: 7D652A78  xor r5, r11, r5
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[5].u64;
	// 82F6C418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6C41C: 4BFFF565  bl 0x82f6b980
	ctx.lr = 0x82F6C420;
	sub_82F6B980(ctx, base);
	// 82F6C420: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6C424: 4BFFBBED  bl 0x82f68010
	ctx.lr = 0x82F6C428;
	sub_82F68010(ctx, base);
	// 82F6C428: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82F6C42C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6C430: 4BFCE589  bl 0x82f3a9b8
	ctx.lr = 0x82F6C434;
	sub_82F3A9B8(ctx, base);
	// 82F6C434: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C438: 4182FF94  beq 0x82f6c3cc
	if ctx.cr[0].eq {
	pc = 0x82F6C3CC; continue 'dispatch;
	}
	// 82F6C43C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F6C440: 4BD3D01C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C448 size=192
    let mut pc: u32 = 0x82F6C448;
    'dispatch: loop {
        match pc {
            0x82F6C448 => {
    //   block [0x82F6C448..0x82F6C508)
	// 82F6C448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C44C: 4BD3CFB9  bl 0x82ca9404
	ctx.lr = 0x82F6C450;
	sub_82CA93D0(ctx, base);
	// 82F6C450: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C454: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6C458: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82F6C45C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C460: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C464: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C468: 2B0B0400  cmplwi cr6, r11, 0x400
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1024 as u32, &mut ctx.xer);
	// 82F6C46C: 41980014  blt cr6, 0x82f6c480
	if ctx.cr[6].lt {
	pc = 0x82F6C480; continue 'dispatch;
	}
	// 82F6C470: 3D400002  lis r10, 2
	ctx.r[10].s64 = 131072;
	// 82F6C474: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6C478: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6C47C: 40990008  ble cr6, 0x82f6c484
	if !ctx.cr[6].gt {
	pc = 0x82F6C484; continue 'dispatch;
	}
	// 82F6C480: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6C484: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C488: 4182000C  beq 0x82f6c494
	if ctx.cr[0].eq {
	pc = 0x82F6C494; continue 'dispatch;
	}
	// 82F6C48C: A97F0008  lha r11, 8(r31)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as i16) as i64;
	// 82F6C490: 7D7CE278  xor r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 ^ ctx.r[28].u64;
	// 82F6C494: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C498: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F6C49C: 419A0054  beq cr6, 0x82f6c4f0
	if ctx.cr[6].eq {
	pc = 0x82F6C4F0; continue 'dispatch;
	}
	// 82F6C4A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C4A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6C4A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F6C4AC: 7D65E038  and r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[28].u64;
	// 82F6C4B0: 4BFFD619  bl 0x82f69ac8
	ctx.lr = 0x82F6C4B4;
	sub_82F69AC8(ctx, base);
	// 82F6C4B4: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F6C4B8: 41800038  blt 0x82f6c4f0
	if ctx.cr[0].lt {
	pc = 0x82F6C4F0; continue 'dispatch;
	}
	// 82F6C4BC: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s64 = ctx.r[3].s64 * 28;
	// 82F6C4C0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C4C4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82F6C4C8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 82F6C4CC: 386A000C  addi r3, r10, 0xc
	ctx.r[3].s64 = ctx.r[10].s64 + 12;
	// 82F6C4D0: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82F6C4D4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C4D8: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6C4DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C4E0: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82F6C4E4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C4E8: 4BFD0EF1  bl 0x82f3d3d8
	ctx.lr = 0x82F6C4EC;
	sub_82F3D3D8(ctx, base);
	// 82F6C4EC: 48000014  b 0x82f6c500
	pc = 0x82F6C500; continue 'dispatch;
	// 82F6C4F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82F6C4F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6C4F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F6C4FC: 4BFFFA2D  bl 0x82f6bf28
	ctx.lr = 0x82F6C500;
	sub_82F6BF28(ctx, base);
	// 82F6C500: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6C504: 4BD3CF50  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C508 size=80
    let mut pc: u32 = 0x82F6C508;
    'dispatch: loop {
        match pc {
            0x82F6C508 => {
    //   block [0x82F6C508..0x82F6C558)
	// 82F6C508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C50C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6C510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6C514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6C518: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C51C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6C520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6C524: 809E00AC  lwz r4, 0xac(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6C528: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6C52C: 419A0008  beq cr6, 0x82f6c534
	if ctx.cr[6].eq {
	pc = 0x82F6C534; continue 'dispatch;
	}
	// 82F6C530: 4BFFB371  bl 0x82f678a0
	ctx.lr = 0x82F6C534;
	sub_82F678A0(ctx, base);
	// 82F6C534: 389E00A0  addi r4, r30, 0xa0
	ctx.r[4].s64 = ctx.r[30].s64 + 160;
	// 82F6C538: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 82F6C53C: 4BFFFDD5  bl 0x82f6c310
	ctx.lr = 0x82F6C540;
	sub_82F6C310(ctx, base);
	// 82F6C540: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6C544: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6C548: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6C54C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6C550: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6C554: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C558 size=252
    let mut pc: u32 = 0x82F6C558;
    'dispatch: loop {
        match pc {
            0x82F6C558 => {
    //   block [0x82F6C558..0x82F6C654)
	// 82F6C558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C55C: 4BD3CEB1  bl 0x82ca940c
	ctx.lr = 0x82F6C560;
	sub_82CA93D0(ctx, base);
	// 82F6C560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C564: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6C568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6C56C: 389E0050  addi r4, r30, 0x50
	ctx.r[4].s64 = ctx.r[30].s64 + 80;
	// 82F6C570: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82F6C574: 395F0030  addi r10, r31, 0x30
	ctx.r[10].s64 = ctx.r[31].s64 + 48;
	// 82F6C578: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6C57C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82F6C580: E97E0030  ld r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 82F6C584: F97F0030  std r11, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 82F6C588: E97E0038  ld r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 82F6C58C: F97F0038  std r11, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	// 82F6C590: E97E0040  ld r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) };
	// 82F6C594: F97F0040  std r11, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u64 ) };
	// 82F6C598: E97E0048  ld r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) };
	// 82F6C59C: F97F0048  std r11, 0x48(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u64 ) };
	// 82F6C5A0: 48000259  bl 0x82f6c7f8
	ctx.lr = 0x82F6C5A4;
	sub_82F6C7F8(ctx, base);
	// 82F6C5A4: 389E00A0  addi r4, r30, 0xa0
	ctx.r[4].s64 = ctx.r[30].s64 + 160;
	// 82F6C5A8: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 82F6C5AC: 4BFFFD65  bl 0x82f6c310
	ctx.lr = 0x82F6C5B0;
	sub_82F6C310(ctx, base);
	// 82F6C5B0: 809E00AC  lwz r4, 0xac(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(172 as u32) ) } as u64;
	// 82F6C5B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6C5B8: 419A000C  beq cr6, 0x82f6c5c4
	if ctx.cr[6].eq {
	pc = 0x82F6C5C4; continue 'dispatch;
	}
	// 82F6C5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6C5C0: 4BFFB2E1  bl 0x82f678a0
	ctx.lr = 0x82F6C5C4;
	sub_82F678A0(ctx, base);
	// 82F6C5C4: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F6C5C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C5CC: 419A0010  beq cr6, 0x82f6c5dc
	if ctx.cr[6].eq {
	pc = 0x82F6C5DC; continue 'dispatch;
	}
	// 82F6C5D0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C5D4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6C5D8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6C5DC: 83BF008C  lwz r29, 0x8c(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F6C5E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F6C5E4: 419A0024  beq cr6, 0x82f6c608
	if ctx.cr[6].eq {
	pc = 0x82F6C608; continue 'dispatch;
	}
	// 82F6C5E8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C5EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C5F0: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6C5F4: 41810014  bgt 0x82f6c608
	if ctx.cr[0].gt {
	pc = 0x82F6C608; continue 'dispatch;
	}
	// 82F6C5F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6C5FC: 4BFFA9A5  bl 0x82f66fa0
	ctx.lr = 0x82F6C600;
	sub_82F66FA0(ctx, base);
	// 82F6C600: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6C604: 4BF9129D  bl 0x82efd8a0
	ctx.lr = 0x82F6C608;
	sub_82EFD8A0(ctx, base);
	// 82F6C608: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F6C60C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82F6C610: 83BE008C  lwz r29, 0x8c(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F6C614: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F6C618: 419A0024  beq cr6, 0x82f6c63c
	if ctx.cr[6].eq {
	pc = 0x82F6C63C; continue 'dispatch;
	}
	// 82F6C61C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C620: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C624: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6C628: 41810014  bgt 0x82f6c63c
	if ctx.cr[0].gt {
	pc = 0x82F6C63C; continue 'dispatch;
	}
	// 82F6C62C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6C630: 4BFFA971  bl 0x82f66fa0
	ctx.lr = 0x82F6C634;
	sub_82F66FA0(ctx, base);
	// 82F6C634: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6C638: 4BF91269  bl 0x82efd8a0
	ctx.lr = 0x82F6C63C;
	sub_82EFD8A0(ctx, base);
	// 82F6C63C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6C640: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82F6C644: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 82F6C648: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82F6C64C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6C650: 4BD3CE0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C658 size=256
    let mut pc: u32 = 0x82F6C658;
    'dispatch: loop {
        match pc {
            0x82F6C658 => {
    //   block [0x82F6C658..0x82F6C758)
	// 82F6C658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C65C: 4BD3CDA9  bl 0x82ca9404
	ctx.lr = 0x82F6C660;
	sub_82CA93D0(ctx, base);
	// 82F6C660: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C664: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6C668: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82F6C66C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F6C670: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C674: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82F6C678: 419A0024  beq cr6, 0x82f6c69c
	if ctx.cr[6].eq {
	pc = 0x82F6C69C; continue 'dispatch;
	}
	// 82F6C67C: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 82F6C680: 419A001C  beq cr6, 0x82f6c69c
	if ctx.cr[6].eq {
	pc = 0x82F6C69C; continue 'dispatch;
	}
	// 82F6C684: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C688: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6C68C: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C690: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82F6C694: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82F6C698: 48000014  b 0x82f6c6ac
	pc = 0x82F6C6AC; continue 'dispatch;
	// 82F6C69C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82F6C6A0: B3C10058  sth r30, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u16 ) };
	// 82F6C6A4: 9BC1005A  stb r30, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[30].u8 ) };
	// 82F6C6A8: 9BC1005B  stb r30, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[30].u8 ) };
	// 82F6C6AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6C6B0: 3B8300A0  addi r28, r3, 0xa0
	ctx.r[28].s64 = ctx.r[3].s64 + 160;
	// 82F6C6B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6C6B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6C6BC: 4BFFDC15  bl 0x82f6a2d0
	ctx.lr = 0x82F6C6C0;
	sub_82F6A2D0(ctx, base);
	// 82F6C6C0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6C6C4: 40820060  bne 0x82f6c724
	if !ctx.cr[0].eq {
	pc = 0x82F6C724; continue 'dispatch;
	}
	// 82F6C6C8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82F6C6CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82F6C6D0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82F6C6D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F6C6D8: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82F6C6DC: 4BFB0F05  bl 0x82f1d5e0
	ctx.lr = 0x82F6C6E0;
	sub_82F1D5E0(ctx, base);
	// 82F6C6E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6C6E4: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82F6C6E8: 48005D49  bl 0x82f72430
	ctx.lr = 0x82F6C6EC;
	sub_82F72430(ctx, base);
	// 82F6C6EC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82F6C6F0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82F6C6F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6C6F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82F6C6FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6C700: 4BFFFD49  bl 0x82f6c448
	ctx.lr = 0x82F6C704;
	sub_82F6C448(ctx, base);
	// 82F6C704: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6C708: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82F6C70C: 4BFB0ED5  bl 0x82f1d5e0
	ctx.lr = 0x82F6C710;
	sub_82F1D5E0(ctx, base);
	// 82F6C710: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82F6C714: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6C718: 419A0038  beq cr6, 0x82f6c750
	if ctx.cr[6].eq {
	pc = 0x82F6C750; continue 'dispatch;
	}
	// 82F6C71C: 4BF91185  bl 0x82efd8a0
	ctx.lr = 0x82F6C720;
	sub_82EFD8A0(ctx, base);
	// 82F6C720: 48000030  b 0x82f6c750
	pc = 0x82F6C750; continue 'dispatch;
	// 82F6C724: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6C72C: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82F6C730: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6C734: 4BFB0EAD  bl 0x82f1d5e0
	ctx.lr = 0x82F6C738;
	sub_82F1D5E0(ctx, base);
	// 82F6C738: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C73C: 57CB2036  slwi r11, r30, 4
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6C740: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6C744: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6C748: 386BFFF0  addi r3, r11, -0x10
	ctx.r[3].s64 = ctx.r[11].s64 + -16;
	// 82F6C74C: 48005CE5  bl 0x82f72430
	ctx.lr = 0x82F6C750;
	sub_82F72430(ctx, base);
	// 82F6C750: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6C754: 4BD3CD00  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6C758 size=160
    let mut pc: u32 = 0x82F6C758;
    'dispatch: loop {
        match pc {
            0x82F6C758 => {
    //   block [0x82F6C758..0x82F6C7F8)
	// 82F6C758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6C75C: 4BD3CCA5  bl 0x82ca9400
	ctx.lr = 0x82F6C760;
	sub_82CA93D0(ctx, base);
	// 82F6C760: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6C764: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6C768: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82F6C76C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82F6C770: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C774: 4BFFACB5  bl 0x82f67428
	ctx.lr = 0x82F6C778;
	sub_82F67428(ctx, base);
	// 82F6C778: 547C063E  clrlwi r28, r3, 0x18
	ctx.r[28].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82F6C77C: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 82F6C780: 409A0018  bne cr6, 0x82f6c798
	if !ctx.cr[6].eq {
	pc = 0x82F6C798; continue 'dispatch;
	}
	// 82F6C784: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82F6C788: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6C78C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F6C790: 4BFFFEC9  bl 0x82f6c658
	ctx.lr = 0x82F6C794;
	sub_82F6C658(ctx, base);
	// 82F6C794: 4800005C  b 0x82f6c7f0
	pc = 0x82F6C7F0; continue 'dispatch;
	// 82F6C798: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82F6C79C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82F6C7A0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82F6C7A4: 419A004C  beq cr6, 0x82f6c7f0
	if ctx.cr[6].eq {
	pc = 0x82F6C7F0; continue 'dispatch;
	}
	// 82F6C7A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C7AC: 7D6BF039  and. r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[30].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6C7B0: 41820034  beq 0x82f6c7e4
	if ctx.cr[0].eq {
	pc = 0x82F6C7E4; continue 'dispatch;
	}
	// 82F6C7B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6C7B8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82F6C7BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6C7C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6C7C4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6C7C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82F6C7CC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82F6C7D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6C7D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82F6C7D8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82F6C7DC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82F6C7E0: 4BFFFE79  bl 0x82f6c658
	ctx.lr = 0x82F6C7E4;
	sub_82F6C658(ctx, base);
	// 82F6C7E4: 57DE083C  slwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82F6C7E8: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82F6C7EC: 4198FFBC  blt cr6, 0x82f6c7a8
	if ctx.cr[6].lt {
	pc = 0x82F6C7A8; continue 'dispatch;
	}
	// 82F6C7F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6C7F4: 4BD3CC5C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6C7F8 size=24
    let mut pc: u32 = 0x82F6C7F8;
    'dispatch: loop {
        match pc {
            0x82F6C7F8 => {
    //   block [0x82F6C7F8..0x82F6C810)
	// 82F6C7F8: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82F6C7FC: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6C810 size=144
    let mut pc: u32 = 0x82F6C810;
    'dispatch: loop {
        match pc {
            0x82F6C810 => {
    //   block [0x82F6C810..0x82F6C8A0)
	// 82F6C810: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6C814: D0410024  stfs f2, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82F6C818: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 82F6C81C: D021001C  stfs f1, 0x1c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82F6C820: 39210024  addi r9, r1, 0x24
	ctx.r[9].s64 = ctx.r[1].s64 + 36;
	// 82F6C824: D0810034  stfs f4, 0x34(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82F6C828: 3901001C  addi r8, r1, 0x1c
	ctx.r[8].s64 = ctx.r[1].s64 + 28;
	// 82F6C82C: D0C10044  stfs f6, 0x44(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82F6C830: 38E10034  addi r7, r1, 0x34
	ctx.r[7].s64 = ctx.r[1].s64 + 52;
	// 82F6C834: D061002C  stfs f3, 0x2c(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82F6C838: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C83C: 3961002C  addi r11, r1, 0x2c
	ctx.r[11].s64 = ctx.r[1].s64 + 44;
	// 82F6C840: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82F6C844: 38C1003C  addi r6, r1, 0x3c
	ctx.r[6].s64 = ctx.r[1].s64 + 60;
	// 82F6C848: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C84C: 39410044  addi r10, r1, 0x44
	ctx.r[10].s64 = ctx.r[1].s64 + 68;
	// 82F6C850: 13C04C07  vcmpneb. (lvlx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C854: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 82F6C858: 13A04407  vcmpneb. (lvlx128) v29, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C85C: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82F6C860: 13803C07  vcmpneb. (lvlx128) v28, v0, v7
	tmp.u32 = ctx.r[7].u32;
	// load shuffled into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C864: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82F6C868: 13605407  vcmpneb. (lvlx128) v27, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[59] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C86C: 13404C07  vcmpneb. (lvlx128) v26, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[58] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6C8A0 size=64
    let mut pc: u32 = 0x82F6C8A0;
    'dispatch: loop {
        match pc {
            0x82F6C8A0 => {
    //   block [0x82F6C8A0..0x82F6C8E0)
	// 82F6C8A0: 39210024  addi r9, r1, 0x24
	ctx.r[9].s64 = ctx.r[1].s64 + 36;
	// 82F6C8A4: D0410024  stfs f2, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82F6C8A8: 3941001C  addi r10, r1, 0x1c
	ctx.r[10].s64 = ctx.r[1].s64 + 28;
	// 82F6C8AC: D021001C  stfs f1, 0x1c(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82F6C8B0: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 82F6C8B4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C8B8: 13A04C07  vcmpneb. (lvlx128) v29, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C8BC: 13C05407  vcmpneb. (lvlx128) v30, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6C8E0 size=152
    let mut pc: u32 = 0x82F6C8E0;
    'dispatch: loop {
        match pc {
            0x82F6C8E0 => {
    //   block [0x82F6C8E0..0x82F6C978)
	// 82F6C8E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6C8E4: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C8E8: C18B0C1C  lfs f12, 0xc1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6C8EC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6C8F0: 4198007C  blt cr6, 0x82f6c96c
	if ctx.cr[6].lt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C8F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6C8F8: C1AB0BEC  lfs f13, 0xbec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6C8FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F6C900: 4199006C  bgt cr6, 0x82f6c96c
	if ctx.cr[6].gt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C904: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C908: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6C90C: 41980060  blt cr6, 0x82f6c96c
	if ctx.cr[6].lt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C910: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F6C914: 41990058  bgt cr6, 0x82f6c96c
	if ctx.cr[6].gt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C918: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C91C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6C920: 4198004C  blt cr6, 0x82f6c96c
	if ctx.cr[6].lt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C924: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F6C928: 41990044  bgt cr6, 0x82f6c96c
	if ctx.cr[6].gt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C92C: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C930: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6C934: 41980038  blt cr6, 0x82f6c96c
	if ctx.cr[6].lt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C938: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F6C93C: 41990030  bgt cr6, 0x82f6c96c
	if ctx.cr[6].gt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C940: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C944: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6C948: 41980024  blt cr6, 0x82f6c96c
	if ctx.cr[6].lt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C94C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F6C950: 4199001C  bgt cr6, 0x82f6c96c
	if ctx.cr[6].gt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C954: C0030018  lfs f0, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6C958: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6C95C: 41980010  blt cr6, 0x82f6c96c
	if ctx.cr[6].lt {
	pc = 0x82F6C96C; continue 'dispatch;
	}
	// 82F6C960: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82F6C964: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6C968: 40990008  ble cr6, 0x82f6c970
	if !ctx.cr[6].gt {
	pc = 0x82F6C970; continue 'dispatch;
	}
	// 82F6C96C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6C970: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F6C974: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6C978 size=40
    let mut pc: u32 = 0x82F6C978;
    'dispatch: loop {
        match pc {
            0x82F6C978 => {
    //   block [0x82F6C978..0x82F6C9A0)
	// 82F6C978: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F6C97C: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82F6C980: 396B1250  addi r11, r11, 0x1250
	ctx.r[11].s64 = ctx.r[11].s64 + 4688;
	// 82F6C984: 394AEB00  addi r10, r10, -0x1500
	ctx.r[10].s64 = ctx.r[10].s64 + -5376;
	// 82F6C988: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82F6C98C: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6C9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6C9A0 size=136
    let mut pc: u32 = 0x82F6C9A0;
    'dispatch: loop {
        match pc {
            0x82F6C9A0 => {
    //   block [0x82F6C9A0..0x82F6CA28)
	// 82F6C9A0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6C9A4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CA28 size=136
    let mut pc: u32 = 0x82F6CA28;
    'dispatch: loop {
        match pc {
            0x82F6CA28 => {
    //   block [0x82F6CA28..0x82F6CAB0)
	// 82F6CA28: 13E020C7  vcmpequd (lvx128) v31, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6CA2C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6CAB0 size=76
    let mut pc: u32 = 0x82F6CAB0;
    'dispatch: loop {
        match pc {
            0x82F6CAB0 => {
    //   block [0x82F6CAB0..0x82F6CAFC)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6CB00 size=136
    let mut pc: u32 = 0x82F6CB00;
    'dispatch: loop {
        match pc {
            0x82F6CB00 => {
    //   block [0x82F6CB00..0x82F6CB88)
	// 82F6CB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6CB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6CB08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6CB0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82F6CB10: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F6CB14: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6CB18: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F6CB1C: 38A92BF8  addi r5, r9, 0x2bf8
	ctx.r[5].s64 = ctx.r[9].s64 + 11256;
	// 82F6CB20: C1AB0008  lfs f13, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CB24: 38800200  li r4, 0x200
	ctx.r[4].s64 = 512;
	// 82F6CB28: C00A0AB4  lfs f0, 0xab4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CB2C: C0AB0014  lfs f5, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82F6CB30: EC6D0032  fmuls f3, f13, f0
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6CB34: C08B0010  lfs f4, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82F6CB38: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F6CB3C: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6CB40: D8A10048  stfd f5, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.f[5].u64 ) };
	// 82F6CB44: E9410048  ld r10, 0x48(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(72 as u32) ) };
	// 82F6CB48: D8810040  stfd f4, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.f[4].u64 ) };
	// 82F6CB4C: E9210040  ld r9, 0x40(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(64 as u32) ) };
	// 82F6CB50: D8610038  stfd f3, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[3].u64 ) };
	// 82F6CB54: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 82F6CB58: D8410030  stfd f2, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[2].u64 ) };
	// 82F6CB5C: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 82F6CB60: D8210028  stfd f1, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[1].u64 ) };
	// 82F6CB64: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 82F6CB68: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CB6C: ECCD0032  fmuls f6, f13, f0
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6CB70: D8C10050  stfd f6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[6].u64 ) };
	// 82F6CB74: 4BF8A75D  bl 0x82ef72d0
	ctx.lr = 0x82F6CB78;
	sub_82EF72D0(ctx, base);
	// 82F6CB78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6CB7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6CB80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6CB84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CB88 size=76
    let mut pc: u32 = 0x82F6CB88;
    'dispatch: loop {
        match pc {
            0x82F6CB88 => {
    //   block [0x82F6CB88..0x82F6CBD4)
	// 82F6CB88: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CB8C: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CB90: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CB94: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CB98: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CB9C: C1630008  lfs f11, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CBA0: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82F6CBA4: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82F6CBA8: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6CBAC: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CBB0: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CBB4: C1830018  lfs f12, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CBB8: C1630014  lfs f11, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CBBC: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F6CBC0: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82F6CBC4: EC005B7A  fmadds f0, f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82F6CBC8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82F6CBCC: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6CBD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CBD8 size=60
    let mut pc: u32 = 0x82F6CBD8;
    'dispatch: loop {
        match pc {
            0x82F6CBD8 => {
    //   block [0x82F6CBD8..0x82F6CC14)
	// 82F6CBD8: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CBDC: C0050000  lfs f0, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CBE0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CBE4: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CBE8: C1850004  lfs f12, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CBEC: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82F6CBF0: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6CBF4: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CBF8: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CBFC: C1830014  lfs f12, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CC00: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CC04: ED8C02F2  fmuls f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82F6CC08: EC00637A  fmadds f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82F6CC0C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6CC10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CC18 size=100
    let mut pc: u32 = 0x82F6CC18;
    'dispatch: loop {
        match pc {
            0x82F6CC18 => {
    //   block [0x82F6CC18..0x82F6CC7C)
	// 82F6CC18: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CC1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6CC20: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CC24: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6CC28: C0040014  lfs f0, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CC2C: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CC30: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CC34: EDAB6838  fmsubs f13, f11, f0, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6CC38: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82F6CC3C: 409A0040  bne cr6, 0x82f6cc7c
	if !ctx.cr[6].eq {
		sub_82F6CC7C(ctx, base);
		return;
	}
	// 82F6CC40: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82F6CC44: 3D408205  lis r10, -0x7dfb
	ctx.r[10].s64 = -2113601536;
	// 82F6CC48: 396B1250  addi r11, r11, 0x1250
	ctx.r[11].s64 = ctx.r[11].s64 + 4688;
	// 82F6CC4C: 394AEB00  addi r10, r10, -0x1500
	ctx.r[10].s64 = ctx.r[10].s64 + -5376;
	// 82F6CC50: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82F6CC54: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CC7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CC7C size=124
    let mut pc: u32 = 0x82F6CC7C;
    'dispatch: loop {
        match pc {
            0x82F6CC7C => {
    //   block [0x82F6CC7C..0x82F6CCF8)
	// 82F6CC7C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6CC80: C18B0C14  lfs f12, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CC84: EDAC6824  fdivs f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[13].f64) as f32) as f64;
	// 82F6CC88: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CC8C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6CC90: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CC94: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CC98: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82F6CC9C: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CCA0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CCA4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F6CCA8: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6CCAC: C0040010  lfs f0, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CCB0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CCB4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82F6CCB8: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82F6CCBC: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CCC0: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CCC4: C1840018  lfs f12, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CCC8: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CCCC: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82F6CCD0: EC00637E  fnmadds f0, f0, f13, f12
	ctx.f[0].f64 = -(ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64);
	// 82F6CCD4: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F6CCD8: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CCDC: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CCE0: C1840018  lfs f12, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CCE4: C1630014  lfs f11, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CCE8: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82F6CCEC: EC00637E  fnmadds f0, f0, f13, f12
	ctx.f[0].f64 = -(ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64);
	// 82F6CCF0: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82F6CCF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CCF8 size=56
    let mut pc: u32 = 0x82F6CCF8;
    'dispatch: loop {
        match pc {
            0x82F6CCF8 => {
    //   block [0x82F6CCF8..0x82F6CD30)
	// 82F6CCF8: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CCFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6CD00: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CD04: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CD08: C1830014  lfs f12, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CD0C: C1630000  lfs f11, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CD10: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CD14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6CD18: EDAC6AF8  fmsubs f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6CD1C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82F6CD20: 41980008  blt cr6, 0x82f6cd28
	if ctx.cr[6].lt {
	pc = 0x82F6CD28; continue 'dispatch;
	}
	// 82F6CD24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6CD28: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82F6CD2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CD30 size=28
    let mut pc: u32 = 0x82F6CD30;
    'dispatch: loop {
        match pc {
            0x82F6CD30 => {
    //   block [0x82F6CD30..0x82F6CD4C)
	// 82F6CD30: C1A30004  lfs f13, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CD34: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CD38: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CD3C: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CD40: C1830000  lfs f12, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CD44: EC2D0338  fmsubs f1, f13, f12, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82F6CD48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CD50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CD50 size=8
    let mut pc: u32 = 0x82F6CD50;
    'dispatch: loop {
        match pc {
            0x82F6CD50 => {
    //   block [0x82F6CD50..0x82F6CD58)
	// 82F6CD50: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6CD54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CD58 size=8
    let mut pc: u32 = 0x82F6CD58;
    'dispatch: loop {
        match pc {
            0x82F6CD58 => {
    //   block [0x82F6CD58..0x82F6CD60)
	// 82F6CD58: C0230018  lfs f1, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6CD5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CD60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CD60 size=24
    let mut pc: u32 = 0x82F6CD60;
    'dispatch: loop {
        match pc {
            0x82F6CD60 => {
    //   block [0x82F6CD60..0x82F6CD78)
	// 82F6CD60: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CD64: FC000032  fmul f0, f0, f0
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[0].f64;
	// 82F6CD68: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CD6C: FC0D037A  fmadd f0, f13, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64;
	// 82F6CD70: FC20002C  fsqrt f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64).sqrt();
	// 82F6CD74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CD78 size=24
    let mut pc: u32 = 0x82F6CD78;
    'dispatch: loop {
        match pc {
            0x82F6CD78 => {
    //   block [0x82F6CD78..0x82F6CD90)
	// 82F6CD78: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CD7C: FC000032  fmul f0, f0, f0
	ctx.f[0].f64 = ctx.f[0].f64 * ctx.f[0].f64;
	// 82F6CD80: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CD84: FC0D037A  fmadd f0, f13, f13, f0
	ctx.f[0].f64 = ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64;
	// 82F6CD88: FC20002C  fsqrt f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64).sqrt();
	// 82F6CD8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CD90 size=12
    let mut pc: u32 = 0x82F6CD90;
    'dispatch: loop {
        match pc {
            0x82F6CD90 => {
    //   block [0x82F6CD90..0x82F6CD9C)
	// 82F6CD90: C0430000  lfs f2, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F6CD94: C0230010  lfs f1, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6CD98: 4B231E10  b 0x8219eba8
	sub_8219EBA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CDA0 size=44
    let mut pc: u32 = 0x82F6CDA0;
    'dispatch: loop {
        match pc {
            0x82F6CDA0 => {
    //   block [0x82F6CDA0..0x82F6CDCC)
	// 82F6CDA0: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 82F6CDA4: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6CDA8: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 82F6CDAC: 13C020C7  vcmpequd (lvx128) v30, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6CDD0 size=160
    let mut pc: u32 = 0x82F6CDD0;
    'dispatch: loop {
        match pc {
            0x82F6CDD0 => {
    //   block [0x82F6CDD0..0x82F6CE70)
	// 82F6CDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6CDD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6CDD8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6CDDC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82F6CDE0: 13E018C7  vcmpequd (lvx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6CDE4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82F6CDE8: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 82F6CDEC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82F6CDF0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82F6CDF4: 13C358C7  vcmpequd (lvx128) v30, v3, v11
	tmp.u32 = ctx.r[3].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6CDF8: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CE70 size=52
    let mut pc: u32 = 0x82F6CE70;
    'dispatch: loop {
        match pc {
            0x82F6CE70 => {
    //   block [0x82F6CE70..0x82F6CEA4)
	// 82F6CE70: C0030010  lfs f0, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CE74: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CE78: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6CE7C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6CE80: C1830000  lfs f12, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CE84: C1630004  lfs f11, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CE88: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82F6CE8C: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F6CE90: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82F6CE94: 41980008  blt cr6, 0x82f6ce9c
	if ctx.cr[6].lt {
	pc = 0x82F6CE9C; continue 'dispatch;
	}
	// 82F6CE98: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82F6CE9C: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82F6CEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6CEA8 size=196
    let mut pc: u32 = 0x82F6CEA8;
    'dispatch: loop {
        match pc {
            0x82F6CEA8 => {
    //   block [0x82F6CEA8..0x82F6CF6C)
	// 82F6CEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6CEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6CEB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6CEB4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6CEB8: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CEBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6CEC0: C1840014  lfs f12, 0x14(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CEC4: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82F6CEC8: C164000C  lfs f11, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CECC: EC8C0028  fsubs f4, f12, f0
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82F6CED0: EC6B0028  fsubs f3, f11, f0
	ctx.f[3].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82F6CED4: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CED8: C1840010  lfs f12, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CEDC: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 82F6CEE0: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CEE4: EC4C6828  fsubs f2, f12, f13
	ctx.f[2].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6CEE8: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6CEEC: 4BFFF925  bl 0x82f6c810
	ctx.lr = 0x82F6CEF0;
	sub_82F6C810(ctx, base);
	// 82F6CEF0: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CEF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82F6CEF8: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	// 82F6CEFC: C1850014  lfs f12, 0x14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CF00: C165000C  lfs f11, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CF04: EC8C0028  fsubs f4, f12, f0
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82F6CF08: EC6B0028  fsubs f3, f11, f0
	ctx.f[3].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82F6CF0C: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6CF10: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CF14: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 82F6CF18: C1850010  lfs f12, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CF1C: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6CF20: EC4C6828  fsubs f2, f12, f13
	ctx.f[2].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82F6CF24: 4BFFF8ED  bl 0x82f6c810
	ctx.lr = 0x82F6CF28;
	sub_82F6C810(ctx, base);
	// 82F6CF28: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82F6CF2C: 13E0F8C7  vcmpequd (lvx128) v31, v0, v31
	tmp.u32 = ctx.r[31].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82F6CF30: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82F6CF34: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82F6CF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6CF3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6CF40: 13DF58C7  vcmpequd (lvx128) v30, v31, v11
	tmp.u32 = ctx.r[31].u32 + ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6CF70 size=64
    let mut pc: u32 = 0x82F6CF70;
    'dispatch: loop {
        match pc {
            0x82F6CF70 => {
    //   block [0x82F6CF70..0x82F6CFB0)
	// 82F6CF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6CF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6CF78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6CF7C: D0210050  stfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82F6CF80: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 82F6CF84: D0410054  stfs f2, 0x54(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82F6CF88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6CF8C: D0610058  stfs f3, 0x58(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82F6CF90: D041005C  stfs f2, 0x5c(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82F6CF94: D0610060  stfs f3, 0x60(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82F6CF98: D0810064  stfs f4, 0x64(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82F6CF9C: 4BFFFF0D  bl 0x82f6cea8
	ctx.lr = 0x82F6CFA0;
	sub_82F6CEA8(ctx, base);
	// 82F6CFA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6CFA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6CFA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6CFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6CFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82F6CFB0 size=436
    let mut pc: u32 = 0x82F6CFB0;
    'dispatch: loop {
        match pc {
            0x82F6CFB0 => {
    //   block [0x82F6CFB0..0x82F6D164)
	// 82F6CFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6CFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6CFB8: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 82F6CFBC: 4BD40D1D  bl 0x82cadcd8
	ctx.lr = 0x82F6CFC0;
	sub_82CADCA0(ctx, base);
	// 82F6CFC0: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6CFC4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82F6CFC8: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82F6CFCC: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82F6CFD0: EFCC0032  fmuls f30, f12, f0
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6CFD4: C1450008  lfs f10, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82F6CFD8: FD205890  fmr f9, f11
	ctx.f[9].f64 = ctx.f[11].f64;
	// 82F6CFDC: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 82F6CFE0: C0E30014  lfs f7, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82F6CFE4: C0C30000  lfs f6, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82F6CFE8: EC070032  fmuls f0, f7, f0
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82F6CFEC: C085000C  lfs f4, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82F6CFF0: EFA602B2  fmuls f29, f6, f10
	ctx.f[29].f64 = (((ctx.f[6].f64 * ctx.f[10].f64) as f32) as f64);
	// 82F6CFF4: C0A30010  lfs f5, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82F6CFF8: EF8602F2  fmuls f28, f6, f11
	ctx.f[28].f64 = (((ctx.f[6].f64 * ctx.f[11].f64) as f32) as f64);
	// 82F6CFFC: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 82F6D000: C0430008  lfs f2, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82F6D004: ED6502F2  fmuls f11, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82F6D008: C0230018  lfs f1, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82F6D00C: ED4502B2  fmuls f10, f5, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82F6D010: EFEC0372  fmuls f31, f12, f13
	ctx.f[31].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6D014: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82F6D018: ED4750FA  fmadds f10, f7, f3, f10
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[3].f64 + ctx.f[10].f64) as f32) as f64);
	// 82F6D01C: EFE6FA7A  fmadds f31, f6, f9, f31
	ctx.f[31].f64 = (((ctx.f[6].f64 * ctx.f[9].f64 + ctx.f[31].f64) as f32) as f64);
	// 82F6D020: ECC6F23A  fmadds f6, f6, f8, f30
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[8].f64 + ctx.f[30].f64) as f32) as f64);
	// 82F6D024: EDA56A7A  fmadds f13, f5, f9, f13
	ctx.f[13].f64 = (((ctx.f[5].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F6D028: ED25023A  fmadds f9, f5, f8, f0
	ctx.f[9].f64 = (((ctx.f[5].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82F6D02C: ECACE13A  fmadds f5, f12, f4, f28
	ctx.f[5].f64 = (((ctx.f[12].f64 * ctx.f[4].f64 + ctx.f[28].f64) as f32) as f64);
	// 82F6D030: ED0CE8FA  fmadds f8, f12, f3, f29
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[3].f64 + ctx.f[29].f64) as f32) as f64);
	// 82F6D034: EC87593A  fmadds f4, f7, f4, f11
	ctx.f[4].f64 = (((ctx.f[7].f64 * ctx.f[4].f64 + ctx.f[11].f64) as f32) as f64);
	// 82F6D038: ECEA082A  fadds f7, f10, f1
	ctx.f[7].f64 = ((ctx.f[10].f64 + ctx.f[1].f64) as f32) as f64;
	// 82F6D03C: EC1F102A  fadds f0, f31, f2
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[2].f64) as f32) as f64;
	// 82F6D040: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6D044: ED86102A  fadds f12, f6, f2
	ctx.f[12].f64 = ((ctx.f[6].f64 + ctx.f[2].f64) as f32) as f64;
	// 82F6D048: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F6D04C: EDAD082A  fadds f13, f13, f1
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64;
	// 82F6D050: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6D054: D1A4000C  stfs f13, 0xc(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F6D058: ED69082A  fadds f11, f9, f1
	ctx.f[11].f64 = ((ctx.f[9].f64 + ctx.f[1].f64) as f32) as f64;
	// 82F6D05C: ECC5102A  fadds f6, f5, f2
	ctx.f[6].f64 = ((ctx.f[5].f64 + ctx.f[2].f64) as f32) as f64;
	// 82F6D060: ED08102A  fadds f8, f8, f2
	ctx.f[8].f64 = ((ctx.f[8].f64 + ctx.f[2].f64) as f32) as f64;
	// 82F6D064: ECA4082A  fadds f5, f4, f1
	ctx.f[5].f64 = ((ctx.f[4].f64 + ctx.f[1].f64) as f32) as f64;
	// 82F6D068: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82F6D06C: 4098000C  bge cr6, 0x82f6d078
	if !ctx.cr[6].lt {
	pc = 0x82F6D078; continue 'dispatch;
	}
	// 82F6D070: FD200090  fmr f9, f0
	ctx.f[9].f64 = ctx.f[0].f64;
	// 82F6D074: 48000008  b 0x82f6d07c
	pc = 0x82F6D07C; continue 'dispatch;
	// 82F6D078: FD206090  fmr f9, f12
	ctx.f[9].f64 = ctx.f[12].f64;
	// 82F6D07C: D1240000  stfs f9, 0(r4)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6D080: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82F6D084: 4098000C  bge cr6, 0x82f6d090
	if !ctx.cr[6].lt {
	pc = 0x82F6D090; continue 'dispatch;
	}
	// 82F6D088: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 82F6D08C: 48000008  b 0x82f6d094
	pc = 0x82F6D094; continue 'dispatch;
	// 82F6D090: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 82F6D094: D1440004  stfs f10, 4(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6D098: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82F6D09C: 41980008  blt cr6, 0x82f6d0a4
	if ctx.cr[6].lt {
	pc = 0x82F6D0A4; continue 'dispatch;
	}
	// 82F6D0A0: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82F6D0A4: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F6D0A8: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82F6D0AC: 40980008  bge cr6, 0x82f6d0b4
	if !ctx.cr[6].lt {
	pc = 0x82F6D0B4; continue 'dispatch;
	}
	// 82F6D0B0: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 82F6D0B4: D164000C  stfs f11, 0xc(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F6D0B8: FF094000  fcmpu cr6, f9, f8
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[8].f64);
	// 82F6D0BC: 4098000C  bge cr6, 0x82f6d0c8
	if !ctx.cr[6].lt {
	pc = 0x82F6D0C8; continue 'dispatch;
	}
	// 82F6D0C0: FD804890  fmr f12, f9
	ctx.f[12].f64 = ctx.f[9].f64;
	// 82F6D0C4: 48000008  b 0x82f6d0cc
	pc = 0x82F6D0CC; continue 'dispatch;
	// 82F6D0C8: FD804090  fmr f12, f8
	ctx.f[12].f64 = ctx.f[8].f64;
	// 82F6D0CC: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6D0D0: FF0A3800  fcmpu cr6, f10, f7
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[7].f64);
	// 82F6D0D4: 4098000C  bge cr6, 0x82f6d0e0
	if !ctx.cr[6].lt {
	pc = 0x82F6D0E0; continue 'dispatch;
	}
	// 82F6D0D8: FDA05090  fmr f13, f10
	ctx.f[13].f64 = ctx.f[10].f64;
	// 82F6D0DC: 48000008  b 0x82f6d0e4
	pc = 0x82F6D0E4; continue 'dispatch;
	// 82F6D0E0: FDA03890  fmr f13, f7
	ctx.f[13].f64 = ctx.f[7].f64;
	// 82F6D0E4: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6D0E8: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 82F6D0EC: 41980008  blt cr6, 0x82f6d0f4
	if ctx.cr[6].lt {
	pc = 0x82F6D0F4; continue 'dispatch;
	}
	// 82F6D0F0: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	// 82F6D0F4: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F6D0F8: FF075800  fcmpu cr6, f7, f11
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[11].f64);
	// 82F6D0FC: 41980008  blt cr6, 0x82f6d104
	if ctx.cr[6].lt {
	pc = 0x82F6D104; continue 'dispatch;
	}
	// 82F6D100: FD603890  fmr f11, f7
	ctx.f[11].f64 = ctx.f[7].f64;
	// 82F6D104: D164000C  stfs f11, 0xc(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F6D108: FF0C3000  fcmpu cr6, f12, f6
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[6].f64);
	// 82F6D10C: 41980008  blt cr6, 0x82f6d114
	if ctx.cr[6].lt {
	pc = 0x82F6D114; continue 'dispatch;
	}
	// 82F6D110: FD803090  fmr f12, f6
	ctx.f[12].f64 = ctx.f[6].f64;
	// 82F6D114: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82F6D118: FF0D2800  fcmpu cr6, f13, f5
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[5].f64);
	// 82F6D11C: 41980008  blt cr6, 0x82f6d124
	if ctx.cr[6].lt {
	pc = 0x82F6D124; continue 'dispatch;
	}
	// 82F6D120: FDA02890  fmr f13, f5
	ctx.f[13].f64 = ctx.f[5].f64;
	// 82F6D124: D1A40004  stfs f13, 4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82F6D128: FF060000  fcmpu cr6, f6, f0
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[0].f64);
	// 82F6D12C: 41980008  blt cr6, 0x82f6d134
	if ctx.cr[6].lt {
	pc = 0x82F6D134; continue 'dispatch;
	}
	// 82F6D130: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 82F6D134: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82F6D138: FF055800  fcmpu cr6, f5, f11
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[11].f64);
	// 82F6D13C: 4098000C  bge cr6, 0x82f6d148
	if !ctx.cr[6].lt {
	pc = 0x82F6D148; continue 'dispatch;
	}
	// 82F6D140: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 82F6D144: 48000008  b 0x82f6d14c
	pc = 0x82F6D14C; continue 'dispatch;
	// 82F6D148: FC002890  fmr f0, f5
	ctx.f[0].f64 = ctx.f[5].f64;
	// 82F6D14C: D004000C  stfs f0, 0xc(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82F6D150: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 82F6D154: 4BD40BD1  bl 0x82cadd24
	ctx.lr = 0x82F6D158;
	sub_82CADCEC(ctx, base);
	// 82F6D158: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D15C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D160: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D168 size=40
    let mut pc: u32 = 0x82F6D168;
    'dispatch: loop {
        match pc {
            0x82F6D168 => {
    //   block [0x82F6D168..0x82F6D190)
	// 82F6D168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D170: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D174: 38A01505  li r5, 0x1505
	ctx.r[5].s64 = 5381;
	// 82F6D178: 4BF90C59  bl 0x82efddd0
	ctx.lr = 0x82F6D17C;
	sub_82EFDDD0(ctx, base);
	// 82F6D17C: 5463023E  clrlwi r3, r3, 8
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82F6D180: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D18C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D190 size=112
    let mut pc: u32 = 0x82F6D190;
    'dispatch: loop {
        match pc {
            0x82F6D190 => {
    //   block [0x82F6D190..0x82F6D200)
	// 82F6D190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D198: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6D19C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D1A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D1A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6D1A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D1AC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D1B0: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6D1B4: 554A00C7  rlwinm. r10, r10, 0, 3, 3
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6D1B8: 4182000C  beq 0x82f6d1c4
	if ctx.cr[0].eq {
	pc = 0x82F6D1C4; continue 'dispatch;
	}
	// 82F6D1BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6D1C0: 48000028  b 0x82f6d1e8
	pc = 0x82F6D1E8; continue 'dispatch;
	// 82F6D1C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6D1C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D1CC: 4BF98025  bl 0x82f051f0
	ctx.lr = 0x82F6D1D0;
	sub_82F051F0(ctx, base);
	// 82F6D1D0: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F6D1D4: 409A0014  bne cr6, 0x82f6d1e8
	if !ctx.cr[6].eq {
	pc = 0x82F6D1E8; continue 'dispatch;
	}
	// 82F6D1D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D1DC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D1E0: 654A1000  oris r10, r10, 0x1000
	ctx.r[10].u64 = ctx.r[10].u64 | 268435456;
	// 82F6D1E4: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6D1E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6D1EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D1F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D1F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6D1F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D1FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D200 size=112
    let mut pc: u32 = 0x82F6D200;
    'dispatch: loop {
        match pc {
            0x82F6D200 => {
    //   block [0x82F6D200..0x82F6D270)
	// 82F6D200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D208: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D20C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D210: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D214: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D218: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D21C: 554A00C7  rlwinm. r10, r10, 0, 3, 3
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6D220: 41820010  beq 0x82f6d230
	if ctx.cr[0].eq {
	pc = 0x82F6D230; continue 'dispatch;
	}
	// 82F6D224: 7D6B20AE  lbzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82F6D228: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 82F6D22C: 48000030  b 0x82f6d25c
	pc = 0x82F6D25C; continue 'dispatch;
	// 82F6D230: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6D234: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6D238: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6D23C: 4BF978DD  bl 0x82f04b18
	ctx.lr = 0x82F6D240;
	sub_82F04B18(ctx, base);
	// 82F6D240: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82F6D244: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82F6D248: 41820010  beq 0x82f6d258
	if ctx.cr[0].eq {
	pc = 0x82F6D258; continue 'dispatch;
	}
	// 82F6D24C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6D250: 4098FFE8  bge cr6, 0x82f6d238
	if !ctx.cr[6].lt {
	pc = 0x82F6D238; continue 'dispatch;
	}
	// 82F6D254: 48000008  b 0x82f6d25c
	pc = 0x82F6D25C; continue 'dispatch;
	// 82F6D258: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6D25C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6D260: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D264: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D268: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D26C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D270 size=108
    let mut pc: u32 = 0x82F6D270;
    'dispatch: loop {
        match pc {
            0x82F6D270 => {
    //   block [0x82F6D270..0x82F6D2DC)
	// 82F6D270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D278: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D27C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D284: 38600BEC  li r3, 0xbec
	ctx.r[3].s64 = 3052;
	// 82F6D288: 4BF905D9  bl 0x82efd860
	ctx.lr = 0x82F6D28C;
	sub_82EFD860(ctx, base);
	// 82F6D28C: 7C6B1B79  or. r11, r3, r3
	ctx.r[11].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6D290: 41820038  beq 0x82f6d2c8
	if ctx.cr[0].eq {
	pc = 0x82F6D2C8; continue 'dispatch;
	}
	// 82F6D294: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6D298: 3940007F  li r10, 0x7f
	ctx.r[10].s64 = 127;
	// 82F6D29C: 912B0BE8  stw r9, 0xbe8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3048 as u32), ctx.r[9].u32 ) };
	// 82F6D2A0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6D2A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82F6D2A8: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82F6D2AC: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6D2B0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6D2B4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D2B8: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82F6D2BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6D2C0: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82F6D2C4: 4082FFE0  bne 0x82f6d2a4
	if !ctx.cr[0].eq {
	pc = 0x82F6D2A4; continue 'dispatch;
	}
	// 82F6D2C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D2CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D2D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D2D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D2D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D2E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D2E0 size=104
    let mut pc: u32 = 0x82F6D2E0;
    'dispatch: loop {
        match pc {
            0x82F6D2E0 => {
    //   block [0x82F6D2E0..0x82F6D348)
	// 82F6D2E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D2E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D2E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D2EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D2F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D2F4: 386007F0  li r3, 0x7f0
	ctx.r[3].s64 = 2032;
	// 82F6D2F8: 4BF90569  bl 0x82efd860
	ctx.lr = 0x82F6D2FC;
	sub_82EFD860(ctx, base);
	// 82F6D2FC: 39630007  addi r11, r3, 7
	ctx.r[11].s64 = ctx.r[3].s64 + 7;
	// 82F6D300: 556B0039  rlwinm. r11, r11, 0, 0, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6D304: 41820030  beq 0x82f6d334
	if ctx.cr[0].eq {
	pc = 0x82F6D334; continue 'dispatch;
	}
	// 82F6D308: 906B07E4  stw r3, 0x7e4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2020 as u32), ctx.r[3].u32 ) };
	// 82F6D30C: 394000A8  li r10, 0xa8
	ctx.r[10].s64 = 168;
	// 82F6D310: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D314: 912B07E0  stw r9, 0x7e0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(2016 as u32), ctx.r[9].u32 ) };
	// 82F6D318: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F6D31C: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6D320: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6D324: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6D328: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6D32C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82F6D330: 4082FFEC  bne 0x82f6d31c
	if !ctx.cr[0].eq {
	pc = 0x82F6D31C; continue 'dispatch;
	}
	// 82F6D334: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D33C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D340: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D344: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D348 size=104
    let mut pc: u32 = 0x82F6D348;
    'dispatch: loop {
        match pc {
            0x82F6D348 => {
    //   block [0x82F6D348..0x82F6D3B0)
	// 82F6D348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D350: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D354: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D358: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D35C: 2B04000C  cmplwi cr6, r4, 0xc
	ctx.cr[6].compare_u32(ctx.r[4].u32, 12 as u32, &mut ctx.xer);
	// 82F6D360: 40980034  bge cr6, 0x82f6d394
	if !ctx.cr[6].lt {
	pc = 0x82F6D394; continue 'dispatch;
	}
	// 82F6D364: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6D368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6D36C: 409A0008  bne cr6, 0x82f6d374
	if !ctx.cr[6].eq {
	pc = 0x82F6D374; continue 'dispatch;
	}
	// 82F6D370: 4BFFFF71  bl 0x82f6d2e0
	ctx.lr = 0x82F6D374;
	sub_82F6D2E0(ctx, base);
	// 82F6D374: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6D378: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6D37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6D380: 419A001C  beq cr6, 0x82f6d39c
	if ctx.cr[6].eq {
	pc = 0x82F6D39C; continue 'dispatch;
	}
	// 82F6D384: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D388: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6D38C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F6D390: 4800000C  b 0x82f6d39c
	pc = 0x82F6D39C; continue 'dispatch;
	// 82F6D394: 38640001  addi r3, r4, 1
	ctx.r[3].s64 = ctx.r[4].s64 + 1;
	// 82F6D398: 4BF904C9  bl 0x82efd860
	ctx.lr = 0x82F6D39C;
	sub_82EFD860(ctx, base);
	// 82F6D39C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D3A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D3A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D3A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D3B0 size=72
    let mut pc: u32 = 0x82F6D3B0;
    'dispatch: loop {
        match pc {
            0x82F6D3B0 => {
    //   block [0x82F6D3B0..0x82F6D3F8)
	// 82F6D3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D3B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D3BC: 80A40008  lwz r5, 8(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6D3C0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6D3C4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82F6D3C8: 419A000C  beq cr6, 0x82f6d3d4
	if ctx.cr[6].eq {
	pc = 0x82F6D3D4; continue 'dispatch;
	}
	// 82F6D3CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6D3D0: 48000018  b 0x82f6d3e8
	pc = 0x82F6D3E8; continue 'dispatch;
	// 82F6D3D4: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D3D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D3DC: 4BD3CD15  bl 0x82caa0f0
	ctx.lr = 0x82F6D3E0;
	sub_82CAA0F0(ctx, base);
	// 82F6D3E0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82F6D3E4: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6D3E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D3F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D3F8 size=172
    let mut pc: u32 = 0x82F6D3F8;
    'dispatch: loop {
        match pc {
            0x82F6D3F8 => {
    //   block [0x82F6D3F8..0x82F6D4A4)
	// 82F6D3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D3FC: 4BD3C009  bl 0x82ca9404
	ctx.lr = 0x82F6D400;
	sub_82CA93D0(ctx, base);
	// 82F6D400: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D404: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6D408: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6D40C: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82F6D410: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6D414: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6D418: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82F6D41C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D420: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6D424: 7D4A582E  lwzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82F6D428: 2F0AFFFE  cmpwi cr6, r10, -2
	ctx.cr[6].compare_i32(ctx.r[10].s32, -2, &mut ctx.xer);
	// 82F6D42C: 419A006C  beq cr6, 0x82f6d498
	if ctx.cr[6].eq {
	pc = 0x82F6D498; continue 'dispatch;
	}
	// 82F6D430: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D434: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D438: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D43C: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82F6D440: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F6D444: 409A0054  bne cr6, 0x82f6d498
	if !ctx.cr[6].eq {
	pc = 0x82F6D498; continue 'dispatch;
	}
	// 82F6D448: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D44C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D450: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D454: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 82F6D458: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F6D45C: 409A0014  bne cr6, 0x82f6d470
	if !ctx.cr[6].eq {
	pc = 0x82F6D470; continue 'dispatch;
	}
	// 82F6D460: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6D464: 4BFFFF4D  bl 0x82f6d3b0
	ctx.lr = 0x82F6D468;
	sub_82F6D3B0(ctx, base);
	// 82F6D468: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6D46C: 40820024  bne 0x82f6d490
	if !ctx.cr[0].eq {
	pc = 0x82F6D490; continue 'dispatch;
	}
	// 82F6D470: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D474: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82F6D478: 419A0020  beq cr6, 0x82f6d498
	if ctx.cr[6].eq {
	pc = 0x82F6D498; continue 'dispatch;
	}
	// 82F6D47C: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 82F6D480: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D484: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6D488: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82F6D48C: 4BFFFFBC  b 0x82f6d448
	pc = 0x82F6D448; continue 'dispatch;
	// 82F6D490: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6D494: 48000008  b 0x82f6d49c
	pc = 0x82F6D49C; continue 'dispatch;
	// 82F6D498: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82F6D49C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6D4A0: 4BD3BFB4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D4A8 size=76
    let mut pc: u32 = 0x82F6D4A8;
    'dispatch: loop {
        match pc {
            0x82F6D4A8 => {
    //   block [0x82F6D4A8..0x82F6D4F4)
	// 82F6D4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D4B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D4B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D4B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D4BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D4C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6D4C4: 409A0008  bne cr6, 0x82f6d4cc
	if !ctx.cr[6].eq {
	pc = 0x82F6D4CC; continue 'dispatch;
	}
	// 82F6D4C8: 4BFFFDA9  bl 0x82f6d270
	ctx.lr = 0x82F6D4CC;
	sub_82F6D270(ctx, base);
	// 82F6D4CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D4D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6D4D4: 419A000C  beq cr6, 0x82f6d4e0
	if ctx.cr[6].eq {
	pc = 0x82F6D4E0; continue 'dispatch;
	}
	// 82F6D4D8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6D4DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6D4E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D4E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D4E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D4EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D4F8 size=128
    let mut pc: u32 = 0x82F6D4F8;
    'dispatch: loop {
        match pc {
            0x82F6D4F8 => {
    //   block [0x82F6D4F8..0x82F6D578)
	// 82F6D4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D4FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D500: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6D504: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D50C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6D510: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6D514: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6D51C: 419A0038  beq cr6, 0x82f6d554
	if ctx.cr[6].eq {
	pc = 0x82F6D554; continue 'dispatch;
	}
	// 82F6D520: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D524: 556B0043  rlwinm. r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6D528: 40820024  bne 0x82f6d54c
	if !ctx.cr[0].eq {
	pc = 0x82F6D54C; continue 'dispatch;
	}
	// 82F6D52C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6D530: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82F6D534: 40980014  bge cr6, 0x82f6d548
	if !ctx.cr[6].lt {
	pc = 0x82F6D548; continue 'dispatch;
	}
	// 82F6D538: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6D53C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D540: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82F6D544: 48000008  b 0x82f6d54c
	pc = 0x82F6D54C; continue 'dispatch;
	// 82F6D548: 4BF90359  bl 0x82efd8a0
	ctx.lr = 0x82F6D54C;
	sub_82EFD8A0(ctx, base);
	// 82F6D54C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6D550: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D554: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D558: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6D55C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82F6D560: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6D564: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D568: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D56C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6D570: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D574: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D578 size=128
    let mut pc: u32 = 0x82F6D578;
    'dispatch: loop {
        match pc {
            0x82F6D578 => {
    //   block [0x82F6D578..0x82F6D5F8)
	// 82F6D578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D57C: 4BD3BE91  bl 0x82ca940c
	ctx.lr = 0x82F6D580;
	sub_82CA93D0(ctx, base);
	// 82F6D580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D584: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6D588: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6D58C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82F6D590: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6D594: 419A0018  beq cr6, 0x82f6d5ac
	if ctx.cr[6].eq {
	pc = 0x82F6D5AC; continue 'dispatch;
	}
	// 82F6D598: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6D59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6D5A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D5A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6D5A8: 4E800421  bctrl
	ctx.lr = 0x82F6D5AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6D5AC: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6D5B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6D5B4: 419A0018  beq cr6, 0x82f6d5cc
	if ctx.cr[6].eq {
	pc = 0x82F6D5CC; continue 'dispatch;
	}
	// 82F6D5B8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6D5BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6D5C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D5C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6D5C8: 4E800421  bctrl
	ctx.lr = 0x82F6D5CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6D5CC: 93FE002C  stw r31, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 82F6D5D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82F6D5D4: 419A000C  beq cr6, 0x82f6d5e0
	if ctx.cr[6].eq {
	pc = 0x82F6D5E0; continue 'dispatch;
	}
	// 82F6D5D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6D5DC: 4800000C  b 0x82f6d5e8
	pc = 0x82F6D5E8; continue 'dispatch;
	// 82F6D5E0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82F6D5E4: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82F6D5E8: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 82F6D5EC: 4BF90FAD  bl 0x82efe598
	ctx.lr = 0x82F6D5F0;
	sub_82EFE598(ctx, base);
	// 82F6D5F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6D5F4: 4BD3BE68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D5F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D5F8 size=120
    let mut pc: u32 = 0x82F6D5F8;
    'dispatch: loop {
        match pc {
            0x82F6D5F8 => {
    //   block [0x82F6D5F8..0x82F6D670)
	// 82F6D5F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D5FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D604: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D60C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6D614: 419A0048  beq cr6, 0x82f6d65c
	if ctx.cr[6].eq {
	pc = 0x82F6D65C; continue 'dispatch;
	}
	// 82F6D618: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D61C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6D620: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82F6D624: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D628: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6D62C: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6D630: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82F6D634: 419A000C  beq cr6, 0x82f6d640
	if ctx.cr[6].eq {
	pc = 0x82F6D640; continue 'dispatch;
	}
	// 82F6D638: 3900FFFE  li r8, -2
	ctx.r[8].s64 = -2;
	// 82F6D63C: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82F6D640: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82F6D644: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6D648: 4082FFDC  bne 0x82f6d624
	if !ctx.cr[0].eq {
	pc = 0x82F6D624; continue 'dispatch;
	}
	// 82F6D64C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D650: 4BF90251  bl 0x82efd8a0
	ctx.lr = 0x82F6D654;
	sub_82EFD8A0(ctx, base);
	// 82F6D654: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6D658: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D65C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6D660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D668: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D66C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6D670 size=252
    let mut pc: u32 = 0x82F6D670;
    'dispatch: loop {
        match pc {
            0x82F6D670 => {
    //   block [0x82F6D670..0x82F6D76C)
	// 82F6D670: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82F6D674: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D678: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82F6D67C: 419A00E8  beq cr6, 0x82f6d764
	if ctx.cr[6].eq {
	pc = 0x82F6D764; continue 'dispatch;
	}
	// 82F6D680: 80A40000  lwz r5, 0(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D684: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D688: 81650010  lwz r11, 0x10(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D68C: 7D6A3838  and r10, r11, r7
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 82F6D690: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82F6D694: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6D698: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F6D69C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D6A0: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82F6D6A4: 419A00C0  beq cr6, 0x82f6d764
	if ctx.cr[6].eq {
	pc = 0x82F6D764; continue 'dispatch;
	}
	// 82F6D6A8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D6AC: 81080010  lwz r8, 0x10(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D6B0: 7D083838  and r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82F6D6B4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6D6B8: 409A00AC  bne cr6, 0x82f6d764
	if !ctx.cr[6].eq {
	pc = 0x82F6D764; continue 'dispatch;
	}
	// 82F6D6BC: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82F6D6C0: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82F6D6C4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D6C8: 83E80010  lwz r31, 0x10(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D6CC: 7FFF3838  and r31, r31, r7
	ctx.r[31].u64 = ctx.r[31].u64 & ctx.r[7].u64;
	// 82F6D6D0: 7F1F3040  cmplw cr6, r31, r6
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82F6D6D4: 409A000C  bne cr6, 0x82f6d6e0
	if !ctx.cr[6].eq {
	pc = 0x82F6D6E0; continue 'dispatch;
	}
	// 82F6D6D8: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82F6D6DC: 419A0024  beq cr6, 0x82f6d700
	if ctx.cr[6].eq {
	pc = 0x82F6D700; continue 'dispatch;
	}
	// 82F6D6E0: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 82F6D6E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D6E8: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82F6D6EC: 419A0078  beq cr6, 0x82f6d764
	if ctx.cr[6].eq {
	pc = 0x82F6D764; continue 'dispatch;
	}
	// 82F6D6F0: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82F6D6F4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6D6F8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82F6D6FC: 4BFFFFC8  b 0x82f6d6c4
	pc = 0x82F6D6C4; continue 'dispatch;
	// 82F6D700: 3900FFFE  li r8, -2
	ctx.r[8].s64 = -2;
	// 82F6D704: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82F6D708: 409A0038  bne cr6, 0x82f6d740
	if !ctx.cr[6].eq {
	pc = 0x82F6D740; continue 'dispatch;
	}
	// 82F6D70C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D710: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82F6D714: 419A003C  beq cr6, 0x82f6d750
	if ctx.cr[6].eq {
	pc = 0x82F6D750; continue 'dispatch;
	}
	// 82F6D718: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6D71C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F6D720: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6D724: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82F6D728: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D72C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82F6D730: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D734: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82F6D738: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6D73C: 48000014  b 0x82f6d750
	pc = 0x82F6D750; continue 'dispatch;
	// 82F6D740: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 82F6D744: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D748: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6D74C: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82F6D750: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82F6D754: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D758: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D75C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6D760: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D764: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82F6D768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D770 size=340
    let mut pc: u32 = 0x82F6D770;
    'dispatch: loop {
        match pc {
            0x82F6D770 => {
    //   block [0x82F6D770..0x82F6D8C4)
	// 82F6D770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D774: 4BD3BC99  bl 0x82ca940c
	ctx.lr = 0x82F6D778;
	sub_82CA93D0(ctx, base);
	// 82F6D778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D780: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6D784: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6D788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D78C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6D790: 409A000C  bne cr6, 0x82f6d79c
	if !ctx.cr[6].eq {
	pc = 0x82F6D79C; continue 'dispatch;
	}
	// 82F6D794: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82F6D798: 4800002C  b 0x82f6d7c4
	pc = 0x82F6D7C4; continue 'dispatch;
	// 82F6D79C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D7A0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D7A4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6D7A8: 1D290005  mulli r9, r9, 5
	ctx.r[9].s64 = ctx.r[9].s64 * 5;
	// 82F6D7AC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82F6D7B0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6D7B4: 40990018  ble cr6, 0x82f6d7cc
	if !ctx.cr[6].gt {
	pc = 0x82F6D7CC; continue 'dispatch;
	}
	// 82F6D7B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D7BC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6D7C0: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82F6D7C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6D7C8: 48000181  bl 0x82f6d948
	ctx.lr = 0x82F6D7CC;
	sub_82F6D948(ctx, base);
	// 82F6D7CC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D7D0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D7D4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D7D8: 7D4AF038  and r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[30].u64;
	// 82F6D7DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6D7E0: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82F6D7E4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D7E8: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82F6D7EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D7F0: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82F6D7F4: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D7F8: 2F04FFFE  cmpwi cr6, r4, -2
	ctx.cr[6].compare_i32(ctx.r[4].s32, -2, &mut ctx.xer);
	// 82F6D7FC: 409A0014  bne cr6, 0x82f6d810
	if !ctx.cr[6].eq {
	pc = 0x82F6D810; continue 'dispatch;
	}
	// 82F6D800: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F6D804: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D808: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D80C: 48000064  b 0x82f6d870
	pc = 0x82F6D870; continue 'dispatch;
	// 82F6D810: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D814: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 82F6D818: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 82F6D81C: 7D053838  and r5, r8, r7
	ctx.r[5].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82F6D820: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 82F6D824: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F6D828: 7D08582E  lwzx r8, r8, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82F6D82C: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82F6D830: 409AFFE8  bne cr6, 0x82f6d818
	if !ctx.cr[6].eq {
	pc = 0x82F6D818; continue 'dispatch;
	}
	// 82F6D834: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 82F6D838: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D83C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F6D840: 7CC85A14  add r6, r8, r11
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82F6D844: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6D848: 7D083838  and r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 82F6D84C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6D850: 409A002C  bne cr6, 0x82f6d87c
	if !ctx.cr[6].eq {
	pc = 0x82F6D87C; continue 'dispatch;
	}
	// 82F6D854: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82F6D858: 419A0010  beq cr6, 0x82f6d868
	if ctx.cr[6].eq {
	pc = 0x82F6D868; continue 'dispatch;
	}
	// 82F6D85C: 90860000  stw r4, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F6D860: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D864: 91660004  stw r11, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6D868: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D86C: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F6D870: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6D874: 48000048  b 0x82f6d8bc
	pc = 0x82F6D8BC; continue 'dispatch;
	// 82F6D878: 81080000  lwz r8, 0(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D87C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82F6D880: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82F6D884: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82F6D888: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D88C: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82F6D890: 409AFFE8  bne cr6, 0x82f6d878
	if !ctx.cr[6].eq {
	pc = 0x82F6D878; continue 'dispatch;
	}
	// 82F6D894: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82F6D898: 419A0010  beq cr6, 0x82f6d8a8
	if ctx.cr[6].eq {
	pc = 0x82F6D8A8; continue 'dispatch;
	}
	// 82F6D89C: 90860000  stw r4, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F6D8A0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D8A4: 91660004  stw r11, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6D8A8: 90A80000  stw r5, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82F6D8AC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82F6D8B0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D8B4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D8B8: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82F6D8BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6D8C0: 4BD3BB9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6D8C8 size=128
    let mut pc: u32 = 0x82F6D8C8;
    'dispatch: loop {
        match pc {
            0x82F6D8C8 => {
    //   block [0x82F6D8C8..0x82F6D948)
	// 82F6D8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D8CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6D8D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6D8D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6D8D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D8DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6D8E0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6D8E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6D8EC: 419A0040  beq cr6, 0x82f6d92c
	if ctx.cr[6].eq {
	pc = 0x82F6D92C; continue 'dispatch;
	}
	// 82F6D8F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D8F4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6D8F8: 7D655038  and r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82F6D8FC: 4BFFFAFD  bl 0x82f6d3f8
	ctx.lr = 0x82F6D900;
	sub_82F6D3F8(ctx, base);
	// 82F6D900: 2C030000  cmpwi r3, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82F6D904: 41800028  blt 0x82f6d92c
	if ctx.cr[0].lt {
	pc = 0x82F6D92C; continue 'dispatch;
	}
	// 82F6D908: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82F6D90C: 419A0018  beq cr6, 0x82f6d924
	if ctx.cr[6].eq {
	pc = 0x82F6D924; continue 'dispatch;
	}
	// 82F6D910: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6D914: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6D918: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6D91C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6D920: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6D924: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82F6D928: 48000008  b 0x82f6d930
	pc = 0x82F6D930; continue 'dispatch;
	// 82F6D92C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6D930: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6D934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6D938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6D93C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6D940: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6D944: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6D948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82F6D948 size=316
    let mut pc: u32 = 0x82F6D948;
    'dispatch: loop {
        match pc {
            0x82F6D948 => {
    //   block [0x82F6D948..0x82F6DA84)
	// 82F6D948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6D94C: 4BD3BAB5  bl 0x82ca9400
	ctx.lr = 0x82F6D950;
	sub_82CA93D0(ctx, base);
	// 82F6D950: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6D954: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82F6D958: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6D95C: 409A0008  bne cr6, 0x82f6d964
	if !ctx.cr[6].eq {
	pc = 0x82F6D964; continue 'dispatch;
	}
	// 82F6D960: 48000118  b 0x82f6da78
	pc = 0x82F6DA78; continue 'dispatch;
	// 82F6D964: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82F6D968: 4098000C  bge cr6, 0x82f6d974
	if !ctx.cr[6].lt {
	pc = 0x82F6D974; continue 'dispatch;
	}
	// 82F6D96C: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82F6D970: 4800004C  b 0x82f6d9bc
	pc = 0x82F6D9BC; continue 'dispatch;
	// 82F6D974: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82F6D978: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82F6D97C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82F6D980: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82F6D984: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82F6D988: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82F6D98C: 4B286425  bl 0x821f3db0
	ctx.lr = 0x82F6D990;
	sub_821F3DB0(ctx, base);
	// 82F6D990: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82F6D994: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82F6D998: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F6D99C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82F6D9A0: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82F6D9A4: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82F6D9A8: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82F6D9AC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82F6D9B0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82F6D9B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6D9B8: 7D3F5830  slw r31, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	// 82F6D9BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82F6D9C0: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82F6D9C4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F6D9C8: 55631838  slwi r3, r11, 3
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82F6D9CC: 4BF8FE95  bl 0x82efd860
	ctx.lr = 0x82F6D9D0;
	sub_82EFD860(ctx, base);
	// 82F6D9D0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82F6D9D4: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82F6D9D8: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82F6D9DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6D9E0: 3B60FFFE  li r27, -2
	ctx.r[27].s64 = -2;
	// 82F6D9E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6D9E8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6D9EC: 419A0020  beq cr6, 0x82f6da0c
	if ctx.cr[6].eq {
	pc = 0x82F6DA0C; continue 'dispatch;
	}
	// 82F6D9F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82F6D9F4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6D9F8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6D9FC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82F6DA00: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6DA04: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82F6DA08: 4082FFEC  bne 0x82f6d9f4
	if !ctx.cr[0].eq {
	pc = 0x82F6D9F4; continue 'dispatch;
	}
	// 82F6DA0C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6DA14: 419A0054  beq cr6, 0x82f6da68
	if ctx.cr[6].eq {
	pc = 0x82F6DA68; continue 'dispatch;
	}
	// 82F6DA18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DA1C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82F6DA20: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82F6DA24: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DA28: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82F6DA2C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82F6DA30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6DA34: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82F6DA38: 419A001C  beq cr6, 0x82f6da54
	if ctx.cr[6].eq {
	pc = 0x82F6DA54; continue 'dispatch;
	}
	// 82F6DA3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DA40: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82F6DA44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6DA48: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6DA4C: 4BFFFD25  bl 0x82f6d770
	ctx.lr = 0x82F6DA50;
	sub_82F6D770(ctx, base);
	// 82F6DA50: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82F6DA54: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F6DA58: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82F6DA5C: 4082FFC8  bne 0x82f6da24
	if !ctx.cr[0].eq {
	pc = 0x82F6DA24; continue 'dispatch;
	}
	// 82F6DA60: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DA64: 4BF8FE3D  bl 0x82efd8a0
	ctx.lr = 0x82F6DA68;
	sub_82EFD8A0(ctx, base);
	// 82F6DA68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DA6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6DA70: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82F6DA74: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6DA78: 4BFFFB81  bl 0x82f6d5f8
	ctx.lr = 0x82F6DA7C;
	sub_82F6D5F8(ctx, base);
	// 82F6DA7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82F6DA80: 4BD3B9D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DA88 size=108
    let mut pc: u32 = 0x82F6DA88;
    'dispatch: loop {
        match pc {
            0x82F6DA88 => {
    //   block [0x82F6DA88..0x82F6DAF4)
	// 82F6DA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6DA90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6DA94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DA98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6DA9C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6DAA0: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F6DAA4: 419A0020  beq cr6, 0x82f6dac4
	if ctx.cr[6].eq {
	pc = 0x82F6DAC4; continue 'dispatch;
	}
	// 82F6DAA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6DAAC: 419A0018  beq cr6, 0x82f6dac4
	if ctx.cr[6].eq {
	pc = 0x82F6DAC4; continue 'dispatch;
	}
	// 82F6DAB0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6DAB4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6DAB8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6DABC: 40820008  bne 0x82f6dac4
	if !ctx.cr[0].eq {
	pc = 0x82F6DAC4; continue 'dispatch;
	}
	// 82F6DAC0: 4BFFFFC9  bl 0x82f6da88
	ctx.lr = 0x82F6DAC4;
	sub_82F6DA88(ctx, base);
	// 82F6DAC4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82F6DAC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6DACC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DAD0: 4BFFFBA1  bl 0x82f6d670
	ctx.lr = 0x82F6DAD4;
	sub_82F6D670(ctx, base);
	// 82F6DAD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6DAD8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DADC: 4BFFFA1D  bl 0x82f6d4f8
	ctx.lr = 0x82F6DAE0;
	sub_82F6D4F8(ctx, base);
	// 82F6DAE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6DAE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6DAE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6DAEC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6DAF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DAF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DAF8 size=192
    let mut pc: u32 = 0x82F6DAF8;
    'dispatch: loop {
        match pc {
            0x82F6DAF8 => {
    //   block [0x82F6DAF8..0x82F6DBB8)
	// 82F6DAF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DAFC: 4BD3B905  bl 0x82ca9400
	ctx.lr = 0x82F6DB00;
	sub_82CA93D0(ctx, base);
	// 82F6DB00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DB04: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82F6DB08: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82F6DB0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6DB10: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82F6DB14: 38A01505  li r5, 0x1505
	ctx.r[5].s64 = 5381;
	// 82F6DB18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82F6DB1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6DB20: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82F6DB24: 4BF902AD  bl 0x82efddd0
	ctx.lr = 0x82F6DB28;
	sub_82EFDDD0(ctx, base);
	// 82F6DB28: 547A023E  clrlwi r26, r3, 8
	ctx.r[26].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82F6DB2C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82F6DB30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6DB34: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82F6DB38: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F6DB3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DB40: 4BFFFD89  bl 0x82f6d8c8
	ctx.lr = 0x82F6DB44;
	sub_82F6D8C8(ctx, base);
	// 82F6DB44: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6DB48: 41820018  beq 0x82f6db60
	if ctx.cr[0].eq {
	pc = 0x82F6DB60; continue 'dispatch;
	}
	// 82F6DB4C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DB50: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6DB54: 7D6BDB78  or r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[27].u64;
	// 82F6DB58: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82F6DB5C: 48000054  b 0x82f6dbb0
	pc = 0x82F6DBB0; continue 'dispatch;
	// 82F6DB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DB64: 4BFFF945  bl 0x82f6d4a8
	ctx.lr = 0x82F6DB68;
	sub_82F6D4A8(ctx, base);
	// 82F6DB68: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6DB6C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82F6DB70: 4182003C  beq 0x82f6dbac
	if ctx.cr[0].eq {
	pc = 0x82F6DBAC; continue 'dispatch;
	}
	// 82F6DB74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6DB78: 7F4ADB78  or r10, r26, r27
	ctx.r[10].u64 = ctx.r[26].u64 | ctx.r[27].u64;
	// 82F6DB7C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6DB80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6DB84: 654A4000  oris r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 1073741824;
	// 82F6DB88: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82F6DB8C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6DB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DB94: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6DB98: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6DB9C: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6DBA0: 4BFFFBD1  bl 0x82f6d770
	ctx.lr = 0x82F6DBA4;
	sub_82F6D770(ctx, base);
	// 82F6DBA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6DBA8: 48000008  b 0x82f6dbb0
	pc = 0x82F6DBB0; continue 'dispatch;
	// 82F6DBAC: 387E0014  addi r3, r30, 0x14
	ctx.r[3].s64 = ctx.r[30].s64 + 20;
	// 82F6DBB0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6DBB4: 4BD3B89C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DBB8 size=228
    let mut pc: u32 = 0x82F6DBB8;
    'dispatch: loop {
        match pc {
            0x82F6DBB8 => {
    //   block [0x82F6DBB8..0x82F6DC9C)
	// 82F6DBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DBBC: 4BD3B841  bl 0x82ca93fc
	ctx.lr = 0x82F6DBC0;
	sub_82CA93D0(ctx, base);
	// 82F6DBC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DBC4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82F6DBC8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82F6DBCC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6DBD0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82F6DBD4: 38A01505  li r5, 0x1505
	ctx.r[5].s64 = 5381;
	// 82F6DBD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6DBDC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82F6DBE0: 4BF901F1  bl 0x82efddd0
	ctx.lr = 0x82F6DBE4;
	sub_82EFDDD0(ctx, base);
	// 82F6DBE4: 5479023E  clrlwi r25, r3, 8
	ctx.r[25].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82F6DBE8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82F6DBEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6DBF0: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82F6DBF4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F6DBF8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DBFC: 4BFFFCCD  bl 0x82f6d8c8
	ctx.lr = 0x82F6DC00;
	sub_82F6D8C8(ctx, base);
	// 82F6DC00: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6DC04: 4182000C  beq 0x82f6dc10
	if ctx.cr[0].eq {
	pc = 0x82F6DC10; continue 'dispatch;
	}
	// 82F6DC08: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DC0C: 48000088  b 0x82f6dc94
	pc = 0x82F6DC94; continue 'dispatch;
	// 82F6DC10: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DC14: 4BFFF895  bl 0x82f6d4a8
	ctx.lr = 0x82F6DC18;
	sub_82F6D4A8(ctx, base);
	// 82F6DC18: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6DC1C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82F6DC20: 41820070  beq 0x82f6dc90
	if ctx.cr[0].eq {
	pc = 0x82F6DC90; continue 'dispatch;
	}
	// 82F6DC24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6DC28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DC2C: 4BFFF71D  bl 0x82f6d348
	ctx.lr = 0x82F6DC30;
	sub_82F6D348(ctx, base);
	// 82F6DC30: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82F6DC34: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82F6DC38: 41820018  beq 0x82f6dc50
	if ctx.cr[0].eq {
	pc = 0x82F6DC50; continue 'dispatch;
	}
	// 82F6DC3C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82F6DC40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82F6DC44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6DC48: 4BD3B839  bl 0x82ca9480
	ctx.lr = 0x82F6DC4C;
	sub_82CA9480(ctx, base);
	// 82F6DC4C: 7F7DF1AE  stbx r27, r29, r30
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[30].u32), ctx.r[27].u8) };
	// 82F6DC50: 57AB003E  slwi r11, r29, 0
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82F6DC54: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82F6DC58: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DC5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6DC60: 419A0028  beq cr6, 0x82f6dc88
	if ctx.cr[6].eq {
	pc = 0x82F6DC88; continue 'dispatch;
	}
	// 82F6DC64: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82F6DC68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6DC6C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82F6DC70: 933F0010  stw r25, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	// 82F6DC74: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82F6DC78: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6DC7C: 4BFFFAF5  bl 0x82f6d770
	ctx.lr = 0x82F6DC80;
	sub_82F6D770(ctx, base);
	// 82F6DC80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6DC84: 48000010  b 0x82f6dc94
	pc = 0x82F6DC94; continue 'dispatch;
	// 82F6DC88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82F6DC8C: 4BFFF86D  bl 0x82f6d4f8
	ctx.lr = 0x82F6DC90;
	sub_82F6D4F8(ctx, base);
	// 82F6DC90: 387C0014  addi r3, r28, 0x14
	ctx.r[3].s64 = ctx.r[28].s64 + 20;
	// 82F6DC94: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F6DC98: 4BD3B7B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DCA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6DCA0 size=16
    let mut pc: u32 = 0x82F6DCA0;
    'dispatch: loop {
        match pc {
            0x82F6DCA0 => {
    //   block [0x82F6DCA0..0x82F6DCB0)
	// 82F6DCA0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6DCA4: 409A000C  bne cr6, 0x82f6dcb0
	if !ctx.cr[6].eq {
		sub_82F6DCB0(ctx, base);
		return;
	}
	// 82F6DCA8: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82F6DCAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6DCB0 size=36
    let mut pc: u32 = 0x82F6DCB0;
    'dispatch: loop {
        match pc {
            0x82F6DCB0 => {
    //   block [0x82F6DCB0..0x82F6DCD4)
	// 82F6DCB0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6DCB4: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DCB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6DCBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6DCC0: 409AFFF4  bne cr6, 0x82f6dcb4
	if !ctx.cr[6].eq {
	pc = 0x82F6DCB4; continue 'dispatch;
	}
	// 82F6DCC4: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82F6DCC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6DCCC: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82F6DCD0: 4BFFFEE8  b 0x82f6dbb8
	sub_82F6DBB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DCD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DCD8 size=164
    let mut pc: u32 = 0x82F6DCD8;
    'dispatch: loop {
        match pc {
            0x82F6DCD8 => {
    //   block [0x82F6DCD8..0x82F6DD7C)
	// 82F6DCD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DCDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6DCE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6DCE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6DCE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DCEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6DCF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6DCF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6DCF8: 4BF90271  bl 0x82efdf68
	ctx.lr = 0x82F6DCFC;
	sub_82EFDF68(ctx, base);
	// 82F6DCFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6DD00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6DD04: 4BF909B5  bl 0x82efe6b8
	ctx.lr = 0x82F6DD08;
	sub_82EFE6B8(ctx, base);
	// 82F6DD08: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DD0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6DD10: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82F6DD14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DD18: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82F6DD1C: 4BFFFE9D  bl 0x82f6dbb8
	ctx.lr = 0x82F6DD20;
	sub_82F6DBB8(ctx, base);
	// 82F6DD20: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DD24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6DD28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6DD2C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 82F6DD30: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6DD34: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F6DD38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6DD3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F6DD40: 7D275214  add r9, r7, r10
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82F6DD44: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6DD48: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6DD4C: 4082FFE8  bne 0x82f6dd34
	if !ctx.cr[0].eq {
	pc = 0x82F6DD34; continue 'dispatch;
	}
	// 82F6DD50: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6DD54: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6DD58: 40820008  bne 0x82f6dd60
	if !ctx.cr[0].eq {
	pc = 0x82F6DD60; continue 'dispatch;
	}
	// 82F6DD5C: 4BF8FB45  bl 0x82efd8a0
	ctx.lr = 0x82F6DD60;
	sub_82EFD8A0(ctx, base);
	// 82F6DD60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6DD64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6DD68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6DD6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6DD70: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6DD74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6DD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DD80 size=312
    let mut pc: u32 = 0x82F6DD80;
    'dispatch: loop {
        match pc {
            0x82F6DD80 => {
    //   block [0x82F6DD80..0x82F6DEB8)
	// 82F6DD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DD84: 4BD3B679  bl 0x82ca93fc
	ctx.lr = 0x82F6DD88;
	sub_82CA93D0(ctx, base);
	// 82F6DD88: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DD8C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82F6DD90: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82F6DD94: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82F6DD98: 7FBFDA14  add r29, r31, r27
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 82F6DD9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6DDA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6DDA4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82F6DDA8: 4BFFF5A1  bl 0x82f6d348
	ctx.lr = 0x82F6DDAC;
	sub_82F6D348(ctx, base);
	// 82F6DDAC: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82F6DDB0: 418200FC  beq 0x82f6deac
	if ctx.cr[0].eq {
	pc = 0x82F6DEAC; continue 'dispatch;
	}
	// 82F6DDB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82F6DDB8: 419A0014  beq cr6, 0x82f6ddcc
	if ctx.cr[6].eq {
	pc = 0x82F6DDCC; continue 'dispatch;
	}
	// 82F6DDBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82F6DDC0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82F6DDC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DDC8: 4BD3B6B9  bl 0x82ca9480
	ctx.lr = 0x82F6DDCC;
	sub_82CA9480(ctx, base);
	// 82F6DDCC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82F6DDD0: 419A0014  beq cr6, 0x82f6dde4
	if ctx.cr[6].eq {
	pc = 0x82F6DDE4; continue 'dispatch;
	}
	// 82F6DDD4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82F6DDD8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82F6DDDC: 7C7EFA14  add r3, r30, r31
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82F6DDE0: 4BD3B6A1  bl 0x82ca9480
	ctx.lr = 0x82F6DDE4;
	sub_82CA9480(ctx, base);
	// 82F6DDE4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82F6DDE8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82F6DDEC: 38A01505  li r5, 0x1505
	ctx.r[5].s64 = 5381;
	// 82F6DDF0: 7F7EE9AE  stbx r27, r30, r29
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[29].u32), ctx.r[27].u8) };
	// 82F6DDF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82F6DDF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DDFC: 4BF8FFD5  bl 0x82efddd0
	ctx.lr = 0x82F6DE00;
	sub_82EFDDD0(ctx, base);
	// 82F6DE00: 547A023E  clrlwi r26, r3, 8
	ctx.r[26].u64 = ctx.r[3].u32 as u64 & 0x00FFFFFFu64;
	// 82F6DE04: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82F6DE08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82F6DE0C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82F6DE10: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82F6DE14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DE18: 4BFFFAB1  bl 0x82f6d8c8
	ctx.lr = 0x82F6DE1C;
	sub_82F6D8C8(ctx, base);
	// 82F6DE1C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6DE20: 4182002C  beq 0x82f6de4c
	if ctx.cr[0].eq {
	pc = 0x82F6DE4C; continue 'dispatch;
	}
	// 82F6DE24: 2B1D000C  cmplwi cr6, r29, 0xc
	ctx.cr[6].compare_u32(ctx.r[29].u32, 12 as u32, &mut ctx.xer);
	// 82F6DE28: 40980014  bge cr6, 0x82f6de3c
	if !ctx.cr[6].lt {
	pc = 0x82F6DE3C; continue 'dispatch;
	}
	// 82F6DE2C: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6DE30: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6DE34: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82F6DE38: 4800000C  b 0x82f6de44
	pc = 0x82F6DE44; continue 'dispatch;
	// 82F6DE3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DE40: 4BF8FA61  bl 0x82efd8a0
	ctx.lr = 0x82F6DE44;
	sub_82EFD8A0(ctx, base);
	// 82F6DE44: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DE48: 48000068  b 0x82f6deb0
	pc = 0x82F6DEB0; continue 'dispatch;
	// 82F6DE4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DE50: 4BFFF659  bl 0x82f6d4a8
	ctx.lr = 0x82F6DE54;
	sub_82F6D4A8(ctx, base);
	// 82F6DE54: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82F6DE58: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82F6DE5C: 41820030  beq 0x82f6de8c
	if ctx.cr[0].eq {
	pc = 0x82F6DE8C; continue 'dispatch;
	}
	// 82F6DE60: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82F6DE64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6DE68: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82F6DE6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6DE70: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F6DE74: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 82F6DE78: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82F6DE7C: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6DE80: 4BFFF8F1  bl 0x82f6d770
	ctx.lr = 0x82F6DE84;
	sub_82F6D770(ctx, base);
	// 82F6DE84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6DE88: 48000028  b 0x82f6deb0
	pc = 0x82F6DEB0; continue 'dispatch;
	// 82F6DE8C: 2B1D000C  cmplwi cr6, r29, 0xc
	ctx.cr[6].compare_u32(ctx.r[29].u32, 12 as u32, &mut ctx.xer);
	// 82F6DE90: 40980014  bge cr6, 0x82f6dea4
	if !ctx.cr[6].lt {
	pc = 0x82F6DEA4; continue 'dispatch;
	}
	// 82F6DE94: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6DE98: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6DE9C: 93DC000C  stw r30, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82F6DEA0: 4800000C  b 0x82f6deac
	pc = 0x82F6DEAC; continue 'dispatch;
	// 82F6DEA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6DEA8: 4BF8F9F9  bl 0x82efd8a0
	ctx.lr = 0x82F6DEAC;
	sub_82EFD8A0(ctx, base);
	// 82F6DEAC: 387C0014  addi r3, r28, 0x14
	ctx.r[3].s64 = ctx.r[28].s64 + 20;
	// 82F6DEB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82F6DEB4: 4BD3B598  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DEB8 size=124
    let mut pc: u32 = 0x82F6DEB8;
    'dispatch: loop {
        match pc {
            0x82F6DEB8 => {
    //   block [0x82F6DEB8..0x82F6DF34)
	// 82F6DEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6DEC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6DEC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6DEC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DECC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6DED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6DED4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6DED8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6DEDC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6DEE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82F6DEE4: 4BF96F55  bl 0x82f04e38
	ctx.lr = 0x82F6DEE8;
	sub_82F04E38(ctx, base);
	// 82F6DEE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DEEC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82F6DEF0: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DEF4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DEF8: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6DEFC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DF00: 4BFFFE81  bl 0x82f6dd80
	ctx.lr = 0x82F6DF04;
	sub_82F6DD80(ctx, base);
	// 82F6DF04: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F6DF08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6DF0C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6DF10: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6DF14: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6DF18: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6DF1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6DF20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6DF24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6DF28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6DF2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6DF30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6DF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6DF38 size=212
    let mut pc: u32 = 0x82F6DF38;
    'dispatch: loop {
        match pc {
            0x82F6DF38 => {
    //   block [0x82F6DF38..0x82F6E00C)
	// 82F6DF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6DF3C: 4BD3B4C1  bl 0x82ca93fc
	ctx.lr = 0x82F6DF40;
	sub_82CA93D0(ctx, base);
	// 82F6DF40: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6DF44: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82F6DF48: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82F6DF4C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82F6DF50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82F6DF54: 7F19D000  cmpw cr6, r25, r26
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82F6DF58: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DF5C: 409A0020  bne cr6, 0x82f6df7c
	if !ctx.cr[6].eq {
	pc = 0x82F6DF7C; continue 'dispatch;
	}
	// 82F6DF60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DF64: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82F6DF68: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6DF6C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6DF70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6DF74: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F6DF78: 48000088  b 0x82f6e000
	pc = 0x82F6E000; continue 'dispatch;
	// 82F6DF7C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DF80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82F6DF84: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82F6DF88: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82F6DF8C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6DF90: 7F1FC800  cmpw cr6, r31, r25
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82F6DF94: 409A0008  bne cr6, 0x82f6df9c
	if !ctx.cr[6].eq {
	pc = 0x82F6DF9C; continue 'dispatch;
	}
	// 82F6DF98: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82F6DF9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6DFA0: 4BF96B79  bl 0x82f04b18
	ctx.lr = 0x82F6DFA4;
	sub_82F04B18(ctx, base);
	// 82F6DFA4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82F6DFA8: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82F6DFAC: 419A001C  beq cr6, 0x82f6dfc8
	if ctx.cr[6].eq {
	pc = 0x82F6DFC8; continue 'dispatch;
	}
	// 82F6DFB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6DFB4: 419A000C  beq cr6, 0x82f6dfc0
	if ctx.cr[6].eq {
	pc = 0x82F6DFC0; continue 'dispatch;
	}
	// 82F6DFB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DFBC: 4BFFFFD4  b 0x82f6df90
	pc = 0x82F6DF90; continue 'dispatch;
	// 82F6DFC0: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82F6DFC4: 40980008  bge cr6, 0x82f6dfcc
	if !ctx.cr[6].lt {
	pc = 0x82F6DFCC; continue 'dispatch;
	}
	// 82F6DFC8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6DFCC: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82F6DFD0: 40980008  bge cr6, 0x82f6dfd8
	if !ctx.cr[6].lt {
	pc = 0x82F6DFD8; continue 'dispatch;
	}
	// 82F6DFD4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82F6DFD8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6DFDC: 7CBEE850  subf r5, r30, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82F6DFE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82F6DFE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6DFE8: 4BFFFBD1  bl 0x82f6dbb8
	ctx.lr = 0x82F6DFEC;
	sub_82F6DBB8(ctx, base);
	// 82F6DFEC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F6DFF0: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6DFF4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6DFF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6DFFC: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6E000: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82F6E004: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6E008: 4BD3B444  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E010 size=220
    let mut pc: u32 = 0x82F6E010;
    'dispatch: loop {
        match pc {
            0x82F6E010 => {
    //   block [0x82F6E010..0x82F6E0EC)
	// 82F6E010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E014: 4BD3B3F9  bl 0x82ca940c
	ctx.lr = 0x82F6E018;
	sub_82CA93D0(ctx, base);
	// 82F6E018: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E01C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6E020: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6E024: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82F6E028: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E02C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E030: 4BF8FF71  bl 0x82efdfa0
	ctx.lr = 0x82F6E034;
	sub_82EFDFA0(ctx, base);
	// 82F6E034: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F6E038: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6E03C: 4BF90FA5  bl 0x82efefe0
	ctx.lr = 0x82F6E040;
	sub_82EFEFE0(ctx, base);
	// 82F6E040: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6E044: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 82F6E048: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6E04C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6E050: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F6E054: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E058: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F6E05C: 7D3D5214  add r9, r29, r10
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82F6E060: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6E064: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E068: 4082FFE8  bne 0x82f6e050
	if !ctx.cr[0].eq {
	pc = 0x82F6E050; continue 'dispatch;
	}
	// 82F6E06C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6E070: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E074: 40820008  bne 0x82f6e07c
	if !ctx.cr[0].eq {
	pc = 0x82F6E07C; continue 'dispatch;
	}
	// 82F6E078: 4BF8F829  bl 0x82efd8a0
	ctx.lr = 0x82F6E07C;
	sub_82EFD8A0(ctx, base);
	// 82F6E07C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6E080: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E084: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82F6E088: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E08C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E090: 5565007E  clrlwi r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 82F6E094: 4BFFFB25  bl 0x82f6dbb8
	ctx.lr = 0x82F6E098;
	sub_82F6DBB8(ctx, base);
	// 82F6E098: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6E09C: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82F6E0A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6E0A4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6E0A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6E0AC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6E0B0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6E0B4: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F6E0B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E0BC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F6E0C0: 7D3D5214  add r9, r29, r10
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82F6E0C4: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6E0C8: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E0CC: 4082FFE8  bne 0x82f6e0b4
	if !ctx.cr[0].eq {
	pc = 0x82F6E0B4; continue 'dispatch;
	}
	// 82F6E0D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6E0D4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E0D8: 40820008  bne 0x82f6e0e0
	if !ctx.cr[0].eq {
	pc = 0x82F6E0E0; continue 'dispatch;
	}
	// 82F6E0DC: 4BF8F7C5  bl 0x82efd8a0
	ctx.lr = 0x82F6E0E0;
	sub_82EFD8A0(ctx, base);
	// 82F6E0E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6E0E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6E0E8: 4BD3B374  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E0F0 size=96
    let mut pc: u32 = 0x82F6E0F0;
    'dispatch: loop {
        match pc {
            0x82F6E0F0 => {
    //   block [0x82F6E0F0..0x82F6E150)
	// 82F6E0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E0F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E0F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E0FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E104: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6E108: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E10C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6E110: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6E114: 409AFFF4  bne cr6, 0x82f6e108
	if !ctx.cr[6].eq {
	pc = 0x82F6E108; continue 'dispatch;
	}
	// 82F6E118: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82F6E11C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E120: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6E124: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82F6E128: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E12C: 4BFFFA8D  bl 0x82f6dbb8
	ctx.lr = 0x82F6E130;
	sub_82F6DBB8(ctx, base);
	// 82F6E130: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F6E134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E138: 4BFA4389  bl 0x82f124c0
	ctx.lr = 0x82F6E13C;
	sub_82F124C0(ctx, base);
	// 82F6E13C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6E140: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E144: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E148: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E14C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E150 size=96
    let mut pc: u32 = 0x82F6E150;
    'dispatch: loop {
        match pc {
            0x82F6E150 => {
    //   block [0x82F6E150..0x82F6E1B0)
	// 82F6E150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E15C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E160: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E164: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E168: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E16C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E170: 80EA0014  lwz r7, 0x14(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6E174: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E178: 80AB0014  lwz r5, 0x14(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6E17C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E180: 4BFFFC01  bl 0x82f6dd80
	ctx.lr = 0x82F6E184;
	sub_82F6DD80(ctx, base);
	// 82F6E184: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F6E188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E18C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82F6E190: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6E194: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6E198: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6E19C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6E1A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E1A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E1A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E1AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E1B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E1B0 size=284
    let mut pc: u32 = 0x82F6E1B0;
    'dispatch: loop {
        match pc {
            0x82F6E1B0 => {
    //   block [0x82F6E1B0..0x82F6E2CC)
	// 82F6E1B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E1B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E1B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6E1BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E1C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E1C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E1C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82F6E1CC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E1D0: 4BF8FDD1  bl 0x82efdfa0
	ctx.lr = 0x82F6E1D4;
	sub_82EFDFA0(ctx, base);
	// 82F6E1D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82F6E1D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6E1DC: 4BF90E95  bl 0x82eff070
	ctx.lr = 0x82F6E1E0;
	sub_82EFF070(ctx, base);
	// 82F6E1E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82F6E1E4: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82F6E1E8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6E1EC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6E1F0: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F6E1F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E1F8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F6E1FC: 7D3E5214  add r9, r30, r10
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82F6E200: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6E204: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E208: 4082FFE8  bne 0x82f6e1f0
	if !ctx.cr[0].eq {
	pc = 0x82F6E1F0; continue 'dispatch;
	}
	// 82F6E20C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6E210: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E214: 40820008  bne 0x82f6e21c
	if !ctx.cr[0].eq {
	pc = 0x82F6E21C; continue 'dispatch;
	}
	// 82F6E218: 4BF8F689  bl 0x82efd8a0
	ctx.lr = 0x82F6E21C;
	sub_82EFD8A0(ctx, base);
	// 82F6E21C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6E220: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E224: 348B000C  addic. r4, r11, 0xc
	ctx.xer.ca = (ctx.r[11].u32 > (!(12 as u32)));
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82F6E228: 4082000C  bne 0x82f6e234
	if !ctx.cr[0].eq {
	pc = 0x82F6E234; continue 'dispatch;
	}
	// 82F6E22C: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82F6E230: 48000028  b 0x82f6e258
	pc = 0x82F6E258; continue 'dispatch;
	// 82F6E234: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82F6E238: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E23C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6E240: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82F6E244: 409AFFF4  bne cr6, 0x82f6e238
	if !ctx.cr[6].eq {
	pc = 0x82F6E238; continue 'dispatch;
	}
	// 82F6E248: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82F6E24C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82F6E250: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82F6E254: 4BFFF965  bl 0x82f6dbb8
	ctx.lr = 0x82F6E258;
	sub_82F6DBB8(ctx, base);
	// 82F6E258: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E25C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82F6E260: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82F6E264: 419A001C  beq cr6, 0x82f6e280
	if ctx.cr[6].eq {
	pc = 0x82F6E280; continue 'dispatch;
	}
	// 82F6E268: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82F6E26C: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82F6E270: 419A0010  beq cr6, 0x82f6e280
	if ctx.cr[6].eq {
	pc = 0x82F6E280; continue 'dispatch;
	}
	// 82F6E274: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6E278: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82F6E27C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82F6E280: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6E284: 39030008  addi r8, r3, 8
	ctx.r[8].s64 = ctx.r[3].s64 + 8;
	// 82F6E288: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82F6E28C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E290: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82F6E294: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82F6E298: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6E29C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E2A0: 4082FFE8  bne 0x82f6e288
	if !ctx.cr[0].eq {
	pc = 0x82F6E288; continue 'dispatch;
	}
	// 82F6E2A4: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 82F6E2A8: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E2AC: 40820008  bne 0x82f6e2b4
	if !ctx.cr[0].eq {
	pc = 0x82F6E2B4; continue 'dispatch;
	}
	// 82F6E2B0: 4BF8F5F1  bl 0x82efd8a0
	ctx.lr = 0x82F6E2B4;
	sub_82EFD8A0(ctx, base);
	// 82F6E2B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6E2B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E2BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E2C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6E2C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E2D0 size=152
    let mut pc: u32 = 0x82F6E2D0;
    'dispatch: loop {
        match pc {
            0x82F6E2D0 => {
    //   block [0x82F6E2D0..0x82F6E368)
	// 82F6E2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E2D4: 4BD3B139  bl 0x82ca940c
	ctx.lr = 0x82F6E2D8;
	sub_82CA93D0(ctx, base);
	// 82F6E2D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E2DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E2E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F6E2E4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82F6E2E8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F6E2EC: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82F6E2F0: 4BF8FC79  bl 0x82efdf68
	ctx.lr = 0x82F6E2F4;
	sub_82EFDF68(ctx, base);
	// 82F6E2F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82F6E2F8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82F6E2FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82F6E300: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82F6E304: 38A01505  li r5, 0x1505
	ctx.r[5].s64 = 5381;
	// 82F6E308: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82F6E30C: 3BAA0CA0  addi r29, r10, 0xca0
	ctx.r[29].s64 = ctx.r[10].s64 + 3232;
	// 82F6E310: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82F6E314: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6E318: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82F6E31C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6E320: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82F6E324: 4BF8FAAD  bl 0x82efddd0
	ctx.lr = 0x82F6E328;
	sub_82EFDDD0(ctx, base);
	// 82F6E328: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82F6E32C: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 82F6E330: 93FF0018  stw r31, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82F6E334: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82F6E338: 93BF0014  stw r29, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82F6E33C: 512AF00E  rlwimi r10, r9, 0x1e, 0, 7
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(30) as u64) & 0x00000000FF000000) | (ctx.r[10].u64 & 0xFFFFFFFF00FFFFFF);
	// 82F6E340: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82F6E344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E348: 915F0024  stw r10, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82F6E34C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82F6E350: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82F6E354: 5545003E  slwi r5, r10, 0
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82F6E358: 4BFFF419  bl 0x82f6d770
	ctx.lr = 0x82F6E35C;
	sub_82F6D770(ctx, base);
	// 82F6E35C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E360: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82F6E364: 4BD3B0F8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E368 size=500
    let mut pc: u32 = 0x82F6E368;
    'dispatch: loop {
        match pc {
            0x82F6E368 => {
    //   block [0x82F6E368..0x82F6E55C)
	// 82F6E368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E36C: 4BD3B091  bl 0x82ca93fc
	ctx.lr = 0x82F6E370;
	sub_82CA93D0(ctx, base);
	// 82F6E370: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6E37C: 4BF8FBED  bl 0x82efdf68
	ctx.lr = 0x82F6E380;
	sub_82EFDF68(ctx, base);
	// 82F6E380: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E384: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82F6E388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E38C: 419A00D8  beq cr6, 0x82f6e464
	if ctx.cr[6].eq {
	pc = 0x82F6E464; continue 'dispatch;
	}
	// 82F6E390: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82F6E394: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6E398: 3B6B934C  addi r27, r11, -0x6cb4
	ctx.r[27].s64 = ctx.r[11].s64 + -27828;
	// 82F6E39C: 3B2A2C8C  addi r25, r10, 0x2c8c
	ctx.r[25].s64 = ctx.r[10].s64 + 11404;
	// 82F6E3A0: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E3A4: 3B80007F  li r28, 0x7f
	ctx.r[28].s64 = 127;
	// 82F6E3A8: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82F6E3AC: 817D0BE8  lwz r11, 0xbe8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3048 as u32) ) } as u64;
	// 82F6E3B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82F6E3B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E3B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E3BC: 419A0070  beq cr6, 0x82f6e42c
	if ctx.cr[6].eq {
	pc = 0x82F6E42C; continue 'dispatch;
	}
	// 82F6E3C0: 2B1A0010  cmplwi cr6, r26, 0x10
	ctx.cr[6].compare_u32(ctx.r[26].u32, 16 as u32, &mut ctx.xer);
	// 82F6E3C4: 40980034  bge cr6, 0x82f6e3f8
	if !ctx.cr[6].lt {
	pc = 0x82F6E3F8; continue 'dispatch;
	}
	// 82F6E3C8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82F6E3CC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82F6E3D0: 409A0008  bne cr6, 0x82f6e3d8
	if !ctx.cr[6].eq {
	pc = 0x82F6E3D8; continue 'dispatch;
	}
	// 82F6E3D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6E3D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6E3DC: 4BF905A5  bl 0x82efe980
	ctx.lr = 0x82F6E3E0;
	sub_82EFE980(ctx, base);
	// 82F6E3E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6E3E4: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E3E8: 4BF90599  bl 0x82efe980
	ctx.lr = 0x82F6E3EC;
	sub_82EFE980(ctx, base);
	// 82F6E3EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82F6E3F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82F6E3F4: 4BF9058D  bl 0x82efe980
	ctx.lr = 0x82F6E3F8;
	sub_82EFE980(ctx, base);
	// 82F6E3F8: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6E3FC: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82F6E400: 556B0043  rlwinm. r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E404: 40820028  bne 0x82f6e42c
	if !ctx.cr[0].eq {
	pc = 0x82F6E42C; continue 'dispatch;
	}
	// 82F6E408: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82F6E40C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E410: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 82F6E414: 40980014  bge cr6, 0x82f6e428
	if !ctx.cr[6].lt {
	pc = 0x82F6E428; continue 'dispatch;
	}
	// 82F6E418: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6E41C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6E420: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82F6E424: 48000008  b 0x82f6e42c
	pc = 0x82F6E42C; continue 'dispatch;
	// 82F6E428: 4BF8F479  bl 0x82efd8a0
	ctx.lr = 0x82F6E42C;
	sub_82EFD8A0(ctx, base);
	// 82F6E42C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82F6E430: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 82F6E434: 4082FF80  bne 0x82f6e3b4
	if !ctx.cr[0].eq {
	pc = 0x82F6E3B4; continue 'dispatch;
	}
	// 82F6E438: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82F6E43C: 4BF8F465  bl 0x82efd8a0
	ctx.lr = 0x82F6E440;
	sub_82EFD8A0(ctx, base);
	// 82F6E440: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E448: 409AFF58  bne cr6, 0x82f6e3a0
	if !ctx.cr[6].eq {
	pc = 0x82F6E3A0; continue 'dispatch;
	}
	// 82F6E44C: 48000018  b 0x82f6e464
	pc = 0x82F6E464; continue 'dispatch;
	// 82F6E450: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6E454: 814B07E0  lwz r10, 0x7e0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2016 as u32) ) } as u64;
	// 82F6E458: 806B07E4  lwz r3, 0x7e4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2020 as u32) ) } as u64;
	// 82F6E45C: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82F6E460: 4BF8F441  bl 0x82efd8a0
	ctx.lr = 0x82F6E464;
	sub_82EFD8A0(ctx, base);
	// 82F6E464: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82F6E468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E46C: 409AFFE4  bne cr6, 0x82f6e450
	if !ctx.cr[6].eq {
	pc = 0x82F6E450; continue 'dispatch;
	}
	// 82F6E470: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82F6E474: 419A0048  beq cr6, 0x82f6e4bc
	if ctx.cr[6].eq {
	pc = 0x82F6E4BC; continue 'dispatch;
	}
	// 82F6E478: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6E47C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6E480: 419A003C  beq cr6, 0x82f6e4bc
	if ctx.cr[6].eq {
	pc = 0x82F6E4BC; continue 'dispatch;
	}
	// 82F6E484: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E488: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82F6E48C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82F6E490: 38892C48  addi r4, r9, 0x2c48
	ctx.r[4].s64 = ctx.r[9].s64 + 11336;
	// 82F6E494: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82F6E498: 386A0014  addi r3, r10, 0x14
	ctx.r[3].s64 = ctx.r[10].s64 + 20;
	// 82F6E49C: 4BFAD6ED  bl 0x82f1bb88
	ctx.lr = 0x82F6E4A0;
	sub_82F1BB88(ctx, base);
	// 82F6E4A0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6E4A4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82F6E4A8: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82F6E4AC: 388A2C28  addi r4, r10, 0x2c28
	ctx.r[4].s64 = ctx.r[10].s64 + 11304;
	// 82F6E4B0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6E4B4: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82F6E4B8: 4BFAD6D1  bl 0x82f1bb88
	ctx.lr = 0x82F6E4BC;
	sub_82F1BB88(ctx, base);
	// 82F6E4BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82F6E4C0: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 82F6E4C4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82F6E4C8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82F6E4CC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82F6E4D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E4D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82F6E4D8: 7D3E5214  add r9, r30, r10
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82F6E4DC: 7D20592D  stwcx. r9, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6E4E0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E4E4: 4082FFE8  bne 0x82f6e4cc
	if !ctx.cr[0].eq {
	pc = 0x82F6E4CC; continue 'dispatch;
	}
	// 82F6E4E8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82F6E4EC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E4F0: 40820008  bne 0x82f6e4f8
	if !ctx.cr[0].eq {
	pc = 0x82F6E4F8; continue 'dispatch;
	}
	// 82F6E4F4: 4BF8F3AD  bl 0x82efd8a0
	ctx.lr = 0x82F6E4F8;
	sub_82EFD8A0(ctx, base);
	// 82F6E4F8: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E4FC: 39030008  addi r8, r3, 8
	ctx.r[8].s64 = ctx.r[3].s64 + 8;
	// 82F6E500: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82F6E504: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E508: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82F6E50C: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82F6E510: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82F6E514: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82F6E518: 4082FFE8  bne 0x82f6e500
	if !ctx.cr[0].eq {
	pc = 0x82F6E500; continue 'dispatch;
	}
	// 82F6E51C: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 82F6E520: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E524: 40820008  bne 0x82f6e52c
	if !ctx.cr[0].eq {
	pc = 0x82F6E52C; continue 'dispatch;
	}
	// 82F6E528: 4BF8F379  bl 0x82efd8a0
	ctx.lr = 0x82F6E52C;
	sub_82EFD8A0(ctx, base);
	// 82F6E52C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82F6E530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6E534: 419A0018  beq cr6, 0x82f6e54c
	if ctx.cr[6].eq {
	pc = 0x82F6E54C; continue 'dispatch;
	}
	// 82F6E538: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E53C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6E540: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E544: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E548: 4E800421  bctrl
	ctx.lr = 0x82F6E54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E550: 4BFFF0A9  bl 0x82f6d5f8
	ctx.lr = 0x82F6E554;
	sub_82F6D5F8(ctx, base);
	// 82F6E554: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82F6E558: 4BD3AEF4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E560 size=116
    let mut pc: u32 = 0x82F6E560;
    'dispatch: loop {
        match pc {
            0x82F6E560 => {
    //   block [0x82F6E560..0x82F6E5D4)
	// 82F6E560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E568: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6E56C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E570: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E574: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6E578: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6E57C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E580: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E588: 409A0008  bne cr6, 0x82f6e590
	if !ctx.cr[6].eq {
	pc = 0x82F6E590; continue 'dispatch;
	}
	// 82F6E58C: 4BFFFC25  bl 0x82f6e1b0
	ctx.lr = 0x82F6E590;
	sub_82F6E1B0(ctx, base);
	// 82F6E590: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E594: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E598: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E59C: 409A000C  bne cr6, 0x82f6e5a8
	if !ctx.cr[6].eq {
	pc = 0x82F6E5A8; continue 'dispatch;
	}
	// 82F6E5A0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E5A4: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82F6E5A8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6E5AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82F6E5B0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6E5B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82F6E5B8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82F6E5BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6E5C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E5C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E5C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6E5CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E5D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E5D8 size=68
    let mut pc: u32 = 0x82F6E5D8;
    'dispatch: loop {
        match pc {
            0x82F6E5D8 => {
    //   block [0x82F6E5D8..0x82F6E61C)
	// 82F6E5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E5E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E5E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E5E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E5EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82F6E5F0: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82F6E5F4: 396B2CB0  addi r11, r11, 0x2cb0
	ctx.r[11].s64 = ctx.r[11].s64 + 11440;
	// 82F6E5F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82F6E5FC: 41820008  beq 0x82f6e604
	if ctx.cr[0].eq {
	pc = 0x82F6E604; continue 'dispatch;
	}
	// 82F6E600: 4BF8F2A1  bl 0x82efd8a0
	ctx.lr = 0x82F6E604;
	sub_82EFD8A0(ctx, base);
	// 82F6E604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E608: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6E60C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E614: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E618: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E620 size=16
    let mut pc: u32 = 0x82F6E620;
    'dispatch: loop {
        match pc {
            0x82F6E620 => {
    //   block [0x82F6E620..0x82F6E630)
	// 82F6E620: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E624: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6E628: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6E62C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E630 size=108
    let mut pc: u32 = 0x82F6E630;
    'dispatch: loop {
        match pc {
            0x82F6E630 => {
    //   block [0x82F6E630..0x82F6E69C)
	// 82F6E630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E638: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6E63C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E640: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E644: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6E648: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6E64C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E650: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E654: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6E658: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E65C: 4E800421  bctrl
	ctx.lr = 0x82F6E660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E660: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E664: 4182001C  beq 0x82f6e680
	if ctx.cr[0].eq {
	pc = 0x82F6E680; continue 'dispatch;
	}
	// 82F6E668: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E66C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E670: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82F6E674: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6E678: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6E67C: 48000008  b 0x82f6e684
	pc = 0x82F6E684; continue 'dispatch;
	// 82F6E680: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E684: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6E688: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E68C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E690: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6E694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E6A0 size=112
    let mut pc: u32 = 0x82F6E6A0;
    'dispatch: loop {
        match pc {
            0x82F6E6A0 => {
    //   block [0x82F6E6A0..0x82F6E710)
	// 82F6E6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E6A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E6A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6E6AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E6B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E6B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82F6E6B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82F6E6BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82F6E6C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E6C4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6E6C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E6CC: 4E800421  bctrl
	ctx.lr = 0x82F6E6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E6D0: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E6D4: 41820020  beq 0x82f6e6f4
	if ctx.cr[0].eq {
	pc = 0x82F6E6F4; continue 'dispatch;
	}
	// 82F6E6D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E6DC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E6E0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82F6E6E4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6E6E8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6E6EC: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82F6E6F0: 48000008  b 0x82f6e6f8
	pc = 0x82F6E6F8; continue 'dispatch;
	// 82F6E6F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E6F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6E6FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E704: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6E708: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E70C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E710 size=8
    let mut pc: u32 = 0x82F6E710;
    'dispatch: loop {
        match pc {
            0x82F6E710 => {
    //   block [0x82F6E710..0x82F6E718)
	// 82F6E710: 80640018  lwz r3, 0x18(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6E714: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E718 size=52
    let mut pc: u32 = 0x82F6E718;
    'dispatch: loop {
        match pc {
            0x82F6E718 => {
    //   block [0x82F6E718..0x82F6E74C)
	// 82F6E718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E71C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E720: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E724: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E728: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F6E72C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F6E730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E734: 4E800421  bctrl
	ctx.lr = 0x82F6E738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E738: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E73C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6E740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E750 size=24
    let mut pc: u32 = 0x82F6E750;
    'dispatch: loop {
        match pc {
            0x82F6E750 => {
    //   block [0x82F6E750..0x82F6E768)
	// 82F6E750: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E754: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E758: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82F6E75C: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6E760: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6E764: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E768 size=28
    let mut pc: u32 = 0x82F6E768;
    'dispatch: loop {
        match pc {
            0x82F6E768 => {
    //   block [0x82F6E768..0x82F6E784)
	// 82F6E768: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E76C: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E770: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82F6E774: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82F6E778: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82F6E77C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82F6E780: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E788 size=20
    let mut pc: u32 = 0x82F6E788;
    'dispatch: loop {
        match pc {
            0x82F6E788 => {
    //   block [0x82F6E788..0x82F6E79C)
	// 82F6E788: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E78C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E790: 409A000C  bne cr6, 0x82f6e79c
	if !ctx.cr[6].eq {
		sub_82F6E79C(ctx, base);
		return;
	}
	// 82F6E794: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E79C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E79C size=20
    let mut pc: u32 = 0x82F6E79C;
    'dispatch: loop {
        match pc {
            0x82F6E79C => {
    //   block [0x82F6E79C..0x82F6E7B0)
	// 82F6E79C: 80630030  lwz r3, 0x30(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E7A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E7A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E7A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E7AC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E7B0 size=20
    let mut pc: u32 = 0x82F6E7B0;
    'dispatch: loop {
        match pc {
            0x82F6E7B0 => {
    //   block [0x82F6E7B0..0x82F6E7C4)
	// 82F6E7B0: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E7B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E7B8: 409A000C  bne cr6, 0x82f6e7c4
	if !ctx.cr[6].eq {
		sub_82F6E7C4(ctx, base);
		return;
	}
	// 82F6E7BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E7C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E7C4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E7C4 size=20
    let mut pc: u32 = 0x82F6E7C4;
    'dispatch: loop {
        match pc {
            0x82F6E7C4 => {
    //   block [0x82F6E7C4..0x82F6E7D8)
	// 82F6E7C4: 80630030  lwz r3, 0x30(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E7C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E7CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82F6E7D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E7D4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E7D8 size=20
    let mut pc: u32 = 0x82F6E7D8;
    'dispatch: loop {
        match pc {
            0x82F6E7D8 => {
    //   block [0x82F6E7D8..0x82F6E7EC)
	// 82F6E7D8: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E7DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E7E0: 409A000C  bne cr6, 0x82f6e7ec
	if !ctx.cr[6].eq {
		sub_82F6E7EC(ctx, base);
		return;
	}
	// 82F6E7E4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E7E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E7EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E7EC size=20
    let mut pc: u32 = 0x82F6E7EC;
    'dispatch: loop {
        match pc {
            0x82F6E7EC => {
    //   block [0x82F6E7EC..0x82F6E800)
	// 82F6E7EC: 80630030  lwz r3, 0x30(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E7F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E7F4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82F6E7F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E7FC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E800 size=20
    let mut pc: u32 = 0x82F6E800;
    'dispatch: loop {
        match pc {
            0x82F6E800 => {
    //   block [0x82F6E800..0x82F6E814)
	// 82F6E800: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E808: 409A000C  bne cr6, 0x82f6e814
	if !ctx.cr[6].eq {
		sub_82F6E814(ctx, base);
		return;
	}
	// 82F6E80C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82F6E810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E814(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E814 size=20
    let mut pc: u32 = 0x82F6E814;
    'dispatch: loop {
        match pc {
            0x82F6E814 => {
    //   block [0x82F6E814..0x82F6E828)
	// 82F6E814: 80630030  lwz r3, 0x30(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82F6E818: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E81C: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82F6E820: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E824: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E828 size=92
    let mut pc: u32 = 0x82F6E828;
    'dispatch: loop {
        match pc {
            0x82F6E828 => {
    //   block [0x82F6E828..0x82F6E884)
	// 82F6E828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E82C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E83C: 54AB07BD  rlwinm. r11, r5, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E840: 98BF0008  stb r5, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u8 ) };
	// 82F6E844: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F6E848: 40820020  bne 0x82f6e868
	if !ctx.cr[0].eq {
	pc = 0x82F6E868; continue 'dispatch;
	}
	// 82F6E84C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82F6E850: 419A0018  beq cr6, 0x82f6e868
	if ctx.cr[6].eq {
	pc = 0x82F6E868; continue 'dispatch;
	}
	// 82F6E854: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E858: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82F6E85C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E860: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E864: 4E800421  bctrl
	ctx.lr = 0x82F6E868;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6E86C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6E870: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82F6E874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E87C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82F6E888 size=20
    let mut pc: u32 = 0x82F6E888;
    'dispatch: loop {
        match pc {
            0x82F6E888 => {
    //   block [0x82F6E888..0x82F6E89C)
	// 82F6E888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82F6E88C: 98A30008  stb r5, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u8 ) };
	// 82F6E890: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82F6E894: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82F6E898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E8A0 size=148
    let mut pc: u32 = 0x82F6E8A0;
    'dispatch: loop {
        match pc {
            0x82F6E8A0 => {
    //   block [0x82F6E8A0..0x82F6E934)
	// 82F6E8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E8A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6E8AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E8B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E8B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E8B8: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E8BC: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E8C0: 40820024  bne 0x82f6e8e4
	if !ctx.cr[0].eq {
	pc = 0x82F6E8E4; continue 'dispatch;
	}
	// 82F6E8C4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E8C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6E8CC: 419A0018  beq cr6, 0x82f6e8e4
	if ctx.cr[6].eq {
	pc = 0x82F6E8E4; continue 'dispatch;
	}
	// 82F6E8D0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E8D4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6E8D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E8DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E8E0: 4E800421  bctrl
	ctx.lr = 0x82F6E8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E8E4: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E8E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82F6E8EC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E8F0: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82F6E8F4: 40820024  bne 0x82f6e918
	if !ctx.cr[0].eq {
	pc = 0x82F6E918; continue 'dispatch;
	}
	// 82F6E8F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E8FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6E900: 419A0018  beq cr6, 0x82f6e918
	if ctx.cr[6].eq {
	pc = 0x82F6E918; continue 'dispatch;
	}
	// 82F6E904: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E908: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6E90C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E914: 4E800421  bctrl
	ctx.lr = 0x82F6E918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E918: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82F6E91C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6E920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6E92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82F6E938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82F6E938 size=160
    let mut pc: u32 = 0x82F6E938;
    'dispatch: loop {
        match pc {
            0x82F6E938 => {
    //   block [0x82F6E938..0x82F6E9D8)
	// 82F6E938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82F6E93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82F6E940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82F6E944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82F6E948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82F6E94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82F6E950: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82F6E954: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E958: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82F6E95C: 419A0044  beq cr6, 0x82f6e9a0
	if ctx.cr[6].eq {
	pc = 0x82F6E9A0; continue 'dispatch;
	}
	// 82F6E960: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E964: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82F6E968: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82F6E96C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82F6E970: 419A0030  beq cr6, 0x82f6e9a0
	if ctx.cr[6].eq {
	pc = 0x82F6E9A0; continue 'dispatch;
	}
	// 82F6E974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82F6E978: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E97C: 409A0018  bne cr6, 0x82f6e994
	if !ctx.cr[6].eq {
	pc = 0x82F6E994; continue 'dispatch;
	}
	// 82F6E980: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82F6E984: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82F6E988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E98C: 4E800421  bctrl
	ctx.lr = 0x82F6E990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E990: 48000010  b 0x82f6e9a0
	pc = 0x82F6E9A0; continue 'dispatch;
	// 82F6E994: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82F6E998: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82F6E99C: 4E800421  bctrl
	ctx.lr = 0x82F6E9A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82F6E9A0: 57CB063F  clrlwi. r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82F6E9A4: 41820010  beq 0x82f6e9b4
	if ctx.cr[0].eq {
	pc = 0x82F6E9B4; continue 'dispatch;
	}
	// 82F6E9A8: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E9AC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82F6E9B0: 4800000C  b 0x82f6e9bc
	pc = 0x82F6E9BC; continue 'dispatch;
	// 82F6E9B4: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82F6E9B8: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82F6E9BC: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82F6E9C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82F6E9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82F6E9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82F6E9CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82F6E9D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82F6E9D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


