pub fn sub_832B2868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2868 size=12
    let mut pc: u32 = 0x832B2868;
    'dispatch: loop {
        match pc {
            0x832B2868 => {
    //   block [0x832B2868..0x832B2874)
	// 832B2868: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 832B286C: 386B38F4  addi r3, r11, 0x38f4
	ctx.r[3].s64 = ctx.r[11].s64 + 14580;
	// 832B2870: 4B520700  b 0x827d2f70
	sub_827D2F70(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2878 size=12
    let mut pc: u32 = 0x832B2878;
    'dispatch: loop {
        match pc {
            0x832B2878 => {
    //   block [0x832B2878..0x832B2884)
	// 832B2878: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B287C: 386BE9C8  addi r3, r11, -0x1638
	ctx.r[3].s64 = ctx.r[11].s64 + -5688;
	// 832B2880: 4AF62558  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2888 size=12
    let mut pc: u32 = 0x832B2888;
    'dispatch: loop {
        match pc {
            0x832B2888 => {
    //   block [0x832B2888..0x832B2894)
	// 832B2888: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B288C: 386BE9CC  addi r3, r11, -0x1634
	ctx.r[3].s64 = ctx.r[11].s64 + -5684;
	// 832B2890: 4AF62548  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2898 size=12
    let mut pc: u32 = 0x832B2898;
    'dispatch: loop {
        match pc {
            0x832B2898 => {
    //   block [0x832B2898..0x832B28A4)
	// 832B2898: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B289C: 386BE9D0  addi r3, r11, -0x1630
	ctx.r[3].s64 = ctx.r[11].s64 + -5680;
	// 832B28A0: 4AF62538  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B28A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B28A8 size=12
    let mut pc: u32 = 0x832B28A8;
    'dispatch: loop {
        match pc {
            0x832B28A8 => {
    //   block [0x832B28A8..0x832B28B4)
	// 832B28A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B28AC: 386BE9D4  addi r3, r11, -0x162c
	ctx.r[3].s64 = ctx.r[11].s64 + -5676;
	// 832B28B0: 4AF62528  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B28B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B28B8 size=12
    let mut pc: u32 = 0x832B28B8;
    'dispatch: loop {
        match pc {
            0x832B28B8 => {
    //   block [0x832B28B8..0x832B28C4)
	// 832B28B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B28BC: 386BE9D8  addi r3, r11, -0x1628
	ctx.r[3].s64 = ctx.r[11].s64 + -5672;
	// 832B28C0: 4AF62518  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B28C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B28C8 size=12
    let mut pc: u32 = 0x832B28C8;
    'dispatch: loop {
        match pc {
            0x832B28C8 => {
    //   block [0x832B28C8..0x832B28D4)
	// 832B28C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B28CC: 386BE9DC  addi r3, r11, -0x1624
	ctx.r[3].s64 = ctx.r[11].s64 + -5668;
	// 832B28D0: 4AF62508  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B28D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B28D8 size=12
    let mut pc: u32 = 0x832B28D8;
    'dispatch: loop {
        match pc {
            0x832B28D8 => {
    //   block [0x832B28D8..0x832B28E4)
	// 832B28D8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B28DC: 386BE9E0  addi r3, r11, -0x1620
	ctx.r[3].s64 = ctx.r[11].s64 + -5664;
	// 832B28E0: 4AF624F8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B28E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B28E8 size=12
    let mut pc: u32 = 0x832B28E8;
    'dispatch: loop {
        match pc {
            0x832B28E8 => {
    //   block [0x832B28E8..0x832B28F4)
	// 832B28E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B28EC: 386BE9E4  addi r3, r11, -0x161c
	ctx.r[3].s64 = ctx.r[11].s64 + -5660;
	// 832B28F0: 4AF624E8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B28F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B28F8 size=12
    let mut pc: u32 = 0x832B28F8;
    'dispatch: loop {
        match pc {
            0x832B28F8 => {
    //   block [0x832B28F8..0x832B2904)
	// 832B28F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B28FC: 386BE9E8  addi r3, r11, -0x1618
	ctx.r[3].s64 = ctx.r[11].s64 + -5656;
	// 832B2900: 4AF624D8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2908 size=12
    let mut pc: u32 = 0x832B2908;
    'dispatch: loop {
        match pc {
            0x832B2908 => {
    //   block [0x832B2908..0x832B2914)
	// 832B2908: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B290C: 386BE9EC  addi r3, r11, -0x1614
	ctx.r[3].s64 = ctx.r[11].s64 + -5652;
	// 832B2910: 4AF05208  b 0x821b7b18
	sub_821B7B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2918 size=132
    let mut pc: u32 = 0x832B2918;
    'dispatch: loop {
        match pc {
            0x832B2918 => {
    //   block [0x832B2918..0x832B299C)
	// 832B2918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B291C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B292C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2930: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B2934: 3BEBE9F4  addi r31, r11, -0x160c
	ctx.r[31].s64 = ctx.r[11].s64 + -5644;
	// 832B2938: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B293C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B2940: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832B2944: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B2948: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 832B294C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B2950: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B2954: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 832B2958: 419A0020  beq cr6, 0x832b2978
	if ctx.cr[6].eq {
	pc = 0x832B2978; continue 'dispatch;
	}
	// 832B295C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 832B2960: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B2964: 4AF693D5  bl 0x8221bd38
	ctx.lr = 0x832B2968;
	sub_8221BD38(ctx, base);
	// 832B2968: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B296C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 832B2970: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B2974: 409AFFE8  bne cr6, 0x832b295c
	if !ctx.cr[6].eq {
	pc = 0x832B295C; continue 'dispatch;
	}
	// 832B2978: 4AF693C1  bl 0x8221bd38
	ctx.lr = 0x832B297C;
	sub_8221BD38(ctx, base);
	// 832B297C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2980: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B2984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B298C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B29A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B29A0 size=84
    let mut pc: u32 = 0x832B29A0;
    'dispatch: loop {
        match pc {
            0x832B29A0 => {
    //   block [0x832B29A0..0x832B29F4)
	// 832B29A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B29A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B29A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B29AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B29B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B29B4: 3BEBEA00  addi r31, r11, -0x1600
	ctx.r[31].s64 = ctx.r[11].s64 + -5632;
	// 832B29B8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B29BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B29C0: 419A0008  beq cr6, 0x832b29c8
	if ctx.cr[6].eq {
	pc = 0x832B29C8; continue 'dispatch;
	}
	// 832B29C4: 4AF69375  bl 0x8221bd38
	ctx.lr = 0x832B29C8;
	sub_8221BD38(ctx, base);
	// 832B29C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B29CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B29D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B29D4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B29D8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B29DC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B29E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B29E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B29E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B29EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B29F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B29F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B29F8 size=12
    let mut pc: u32 = 0x832B29F8;
    'dispatch: loop {
        match pc {
            0x832B29F8 => {
    //   block [0x832B29F8..0x832B2A04)
	// 832B29F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B29FC: 386BEA10  addi r3, r11, -0x15f0
	ctx.r[3].s64 = ctx.r[11].s64 + -5616;
	// 832B2A00: 4AF623D8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2A08 size=12
    let mut pc: u32 = 0x832B2A08;
    'dispatch: loop {
        match pc {
            0x832B2A08 => {
    //   block [0x832B2A08..0x832B2A14)
	// 832B2A08: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2A0C: 386BEA14  addi r3, r11, -0x15ec
	ctx.r[3].s64 = ctx.r[11].s64 + -5612;
	// 832B2A10: 4AF623C8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2A18 size=56
    let mut pc: u32 = 0x832B2A18;
    'dispatch: loop {
        match pc {
            0x832B2A18 => {
    //   block [0x832B2A18..0x832B2A50)
	// 832B2A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2A20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2A24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2A28: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B2A2C: 807FEA18  lwz r3, -0x15e8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-5608 as u32) ) } as u64;
	// 832B2A30: 4AF69309  bl 0x8221bd38
	ctx.lr = 0x832B2A34;
	sub_8221BD38(ctx, base);
	// 832B2A34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2A38: 917FEA18  stw r11, -0x15e8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-5608 as u32), ctx.r[11].u32 ) };
	// 832B2A3C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B2A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2A48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2A4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2A50 size=12
    let mut pc: u32 = 0x832B2A50;
    'dispatch: loop {
        match pc {
            0x832B2A50 => {
    //   block [0x832B2A50..0x832B2A5C)
	// 832B2A50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2A54: 386BEA1C  addi r3, r11, -0x15e4
	ctx.r[3].s64 = ctx.r[11].s64 + -5604;
	// 832B2A58: 4B10C5B0  b 0x823bf008
	sub_823BF008(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2A60 size=12
    let mut pc: u32 = 0x832B2A60;
    'dispatch: loop {
        match pc {
            0x832B2A60 => {
    //   block [0x832B2A60..0x832B2A6C)
	// 832B2A60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2A64: 386BEA28  addi r3, r11, -0x15d8
	ctx.r[3].s64 = ctx.r[11].s64 + -5592;
	// 832B2A68: 4B10C5A0  b 0x823bf008
	sub_823BF008(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2A70 size=12
    let mut pc: u32 = 0x832B2A70;
    'dispatch: loop {
        match pc {
            0x832B2A70 => {
    //   block [0x832B2A70..0x832B2A7C)
	// 832B2A70: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2A74: 386BEA34  addi r3, r11, -0x15cc
	ctx.r[3].s64 = ctx.r[11].s64 + -5580;
	// 832B2A78: 4AF62360  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2A80 size=12
    let mut pc: u32 = 0x832B2A80;
    'dispatch: loop {
        match pc {
            0x832B2A80 => {
    //   block [0x832B2A80..0x832B2A8C)
	// 832B2A80: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2A84: 386BEA38  addi r3, r11, -0x15c8
	ctx.r[3].s64 = ctx.r[11].s64 + -5576;
	// 832B2A88: 4AF62350  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2A90 size=12
    let mut pc: u32 = 0x832B2A90;
    'dispatch: loop {
        match pc {
            0x832B2A90 => {
    //   block [0x832B2A90..0x832B2A9C)
	// 832B2A90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2A94: 386BEA50  addi r3, r11, -0x15b0
	ctx.r[3].s64 = ctx.r[11].s64 + -5552;
	// 832B2A98: 4AF62340  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2AA0 size=12
    let mut pc: u32 = 0x832B2AA0;
    'dispatch: loop {
        match pc {
            0x832B2AA0 => {
    //   block [0x832B2AA0..0x832B2AAC)
	// 832B2AA0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2AA4: 386BEA54  addi r3, r11, -0x15ac
	ctx.r[3].s64 = ctx.r[11].s64 + -5548;
	// 832B2AA8: 4AF62330  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2AB0 size=192
    let mut pc: u32 = 0x832B2AB0;
    'dispatch: loop {
        match pc {
            0x832B2AB0 => {
    //   block [0x832B2AB0..0x832B2B70)
	// 832B2AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2AB4: 4B9F6955  bl 0x82ca9408
	ctx.lr = 0x832B2AB8;
	sub_82CA93D0(ctx, base);
	// 832B2AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2ABC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2AC0: 3BA0000E  li r29, 0xe
	ctx.r[29].s64 = 14;
	// 832B2AC4: 396BEA58  addi r11, r11, -0x15a8
	ctx.r[11].s64 = ctx.r[11].s64 + -5544;
	// 832B2AC8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832B2ACC: 3BEB00F8  addi r31, r11, 0xf8
	ctx.r[31].s64 = ctx.r[11].s64 + 248;
	// 832B2AD0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832B2AD4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 832B2AD8: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 832B2ADC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 832B2AE0: 4AF13C89  bl 0x821c6768
	ctx.lr = 0x832B2AE4;
	sub_821C6768(ctx, base);
	// 832B2AE4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 832B2AE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B2AEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2AF0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B2AF4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B2AF8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B2AFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2B00: 4082FFE8  bne 0x832b2ae8
	if !ctx.cr[0].eq {
	pc = 0x832B2AE8; continue 'dispatch;
	}
	// 832B2B04: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 832B2B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2B0C: 4AF13C5D  bl 0x821c6768
	ctx.lr = 0x832B2B10;
	sub_821C6768(ctx, base);
	// 832B2B10: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 832B2B14: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 832B2B18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2B1C: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 832B2B20: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 832B2B24: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B2B28: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2B2C: 4082FFE8  bne 0x832b2b14
	if !ctx.cr[0].eq {
	pc = 0x832B2B14; continue 'dispatch;
	}
	// 832B2B30: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832B2B34: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 832B2B38: 4AF13C31  bl 0x821c6768
	ctx.lr = 0x832B2B3C;
	sub_821C6768(ctx, base);
	// 832B2B3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B2B40: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 832B2B44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2B48: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 832B2B4C: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 832B2B50: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B2B54: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2B58: 4082FFE8  bne 0x832b2b40
	if !ctx.cr[0].eq {
	pc = 0x832B2B40; continue 'dispatch;
	}
	// 832B2B5C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832B2B60: 939FFFF8  stw r28, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[28].u32 ) };
	// 832B2B64: 4080FF74  bge 0x832b2ad8
	if !ctx.cr[0].lt {
	pc = 0x832B2AD8; continue 'dispatch;
	}
	// 832B2B68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B2B6C: 4B9F68EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2B70 size=192
    let mut pc: u32 = 0x832B2B70;
    'dispatch: loop {
        match pc {
            0x832B2B70 => {
    //   block [0x832B2B70..0x832B2C30)
	// 832B2B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2B74: 4B9F6895  bl 0x82ca9408
	ctx.lr = 0x832B2B78;
	sub_82CA93D0(ctx, base);
	// 832B2B78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2B7C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2B80: 3BA000C1  li r29, 0xc1
	ctx.r[29].s64 = 193;
	// 832B2B84: 396BEB48  addi r11, r11, -0x14b8
	ctx.r[11].s64 = ctx.r[11].s64 + -5304;
	// 832B2B88: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832B2B8C: 3BEB0C28  addi r31, r11, 0xc28
	ctx.r[31].s64 = ctx.r[11].s64 + 3112;
	// 832B2B90: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 832B2B94: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 832B2B98: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 832B2B9C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 832B2BA0: 4AF13BC9  bl 0x821c6768
	ctx.lr = 0x832B2BA4;
	sub_821C6768(ctx, base);
	// 832B2BA4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 832B2BA8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B2BAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2BB0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B2BB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B2BB8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B2BBC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2BC0: 4082FFE8  bne 0x832b2ba8
	if !ctx.cr[0].eq {
	pc = 0x832B2BA8; continue 'dispatch;
	}
	// 832B2BC4: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 832B2BC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2BCC: 4AF13B9D  bl 0x821c6768
	ctx.lr = 0x832B2BD0;
	sub_821C6768(ctx, base);
	// 832B2BD0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 832B2BD4: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 832B2BD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2BDC: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 832B2BE0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 832B2BE4: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B2BE8: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2BEC: 4082FFE8  bne 0x832b2bd4
	if !ctx.cr[0].eq {
	pc = 0x832B2BD4; continue 'dispatch;
	}
	// 832B2BF0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832B2BF4: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 832B2BF8: 4AF13B71  bl 0x821c6768
	ctx.lr = 0x832B2BFC;
	sub_821C6768(ctx, base);
	// 832B2BFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B2C00: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 832B2C04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2C08: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 832B2C0C: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 832B2C10: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B2C14: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B2C18: 4082FFE8  bne 0x832b2c00
	if !ctx.cr[0].eq {
	pc = 0x832B2C00; continue 'dispatch;
	}
	// 832B2C1C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832B2C20: 939FFFF8  stw r28, -8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[28].u32 ) };
	// 832B2C24: 4080FF74  bge 0x832b2b98
	if !ctx.cr[0].lt {
	pc = 0x832B2B98; continue 'dispatch;
	}
	// 832B2C28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B2C2C: 4B9F682C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C30 size=12
    let mut pc: u32 = 0x832B2C30;
    'dispatch: loop {
        match pc {
            0x832B2C30 => {
    //   block [0x832B2C30..0x832B2C3C)
	// 832B2C30: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2C34: 386BF768  addi r3, r11, -0x898
	ctx.r[3].s64 = ctx.r[11].s64 + -2200;
	// 832B2C38: 4AF621A0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C40 size=12
    let mut pc: u32 = 0x832B2C40;
    'dispatch: loop {
        match pc {
            0x832B2C40 => {
    //   block [0x832B2C40..0x832B2C4C)
	// 832B2C40: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2C44: 386BF76C  addi r3, r11, -0x894
	ctx.r[3].s64 = ctx.r[11].s64 + -2196;
	// 832B2C48: 4AF62190  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C50 size=4
    let mut pc: u32 = 0x832B2C50;
    'dispatch: loop {
        match pc {
            0x832B2C50 => {
    //   block [0x832B2C50..0x832B2C54)
	// 832B2C50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C58 size=4
    let mut pc: u32 = 0x832B2C58;
    'dispatch: loop {
        match pc {
            0x832B2C58 => {
    //   block [0x832B2C58..0x832B2C5C)
	// 832B2C58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C60 size=4
    let mut pc: u32 = 0x832B2C60;
    'dispatch: loop {
        match pc {
            0x832B2C60 => {
    //   block [0x832B2C60..0x832B2C64)
	// 832B2C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C68 size=4
    let mut pc: u32 = 0x832B2C68;
    'dispatch: loop {
        match pc {
            0x832B2C68 => {
    //   block [0x832B2C68..0x832B2C6C)
	// 832B2C68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C70 size=12
    let mut pc: u32 = 0x832B2C70;
    'dispatch: loop {
        match pc {
            0x832B2C70 => {
    //   block [0x832B2C70..0x832B2C7C)
	// 832B2C70: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2C74: 386BF780  addi r3, r11, -0x880
	ctx.r[3].s64 = ctx.r[11].s64 + -2176;
	// 832B2C78: 4AF62160  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C80 size=12
    let mut pc: u32 = 0x832B2C80;
    'dispatch: loop {
        match pc {
            0x832B2C80 => {
    //   block [0x832B2C80..0x832B2C8C)
	// 832B2C80: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2C84: 386BF784  addi r3, r11, -0x87c
	ctx.r[3].s64 = ctx.r[11].s64 + -2172;
	// 832B2C88: 4AF62150  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2C90 size=12
    let mut pc: u32 = 0x832B2C90;
    'dispatch: loop {
        match pc {
            0x832B2C90 => {
    //   block [0x832B2C90..0x832B2C9C)
	// 832B2C90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2C94: 386BF788  addi r3, r11, -0x878
	ctx.r[3].s64 = ctx.r[11].s64 + -2168;
	// 832B2C98: 4AF62140  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2CA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2CA0 size=12
    let mut pc: u32 = 0x832B2CA0;
    'dispatch: loop {
        match pc {
            0x832B2CA0 => {
    //   block [0x832B2CA0..0x832B2CAC)
	// 832B2CA0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2CA4: 386BF78C  addi r3, r11, -0x874
	ctx.r[3].s64 = ctx.r[11].s64 + -2164;
	// 832B2CA8: 4AF62130  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2CB0 size=12
    let mut pc: u32 = 0x832B2CB0;
    'dispatch: loop {
        match pc {
            0x832B2CB0 => {
    //   block [0x832B2CB0..0x832B2CBC)
	// 832B2CB0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2CB4: 386BF790  addi r3, r11, -0x870
	ctx.r[3].s64 = ctx.r[11].s64 + -2160;
	// 832B2CB8: 4AF62120  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2CC0 size=12
    let mut pc: u32 = 0x832B2CC0;
    'dispatch: loop {
        match pc {
            0x832B2CC0 => {
    //   block [0x832B2CC0..0x832B2CCC)
	// 832B2CC0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2CC4: 386BF794  addi r3, r11, -0x86c
	ctx.r[3].s64 = ctx.r[11].s64 + -2156;
	// 832B2CC8: 4AF62110  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2CD0 size=12
    let mut pc: u32 = 0x832B2CD0;
    'dispatch: loop {
        match pc {
            0x832B2CD0 => {
    //   block [0x832B2CD0..0x832B2CDC)
	// 832B2CD0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2CD4: 386BF798  addi r3, r11, -0x868
	ctx.r[3].s64 = ctx.r[11].s64 + -2152;
	// 832B2CD8: 4B79C9D0  b 0x82a4f6a8
	sub_82A4F6A8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2CE0 size=84
    let mut pc: u32 = 0x832B2CE0;
    'dispatch: loop {
        match pc {
            0x832B2CE0 => {
    //   block [0x832B2CE0..0x832B2D34)
	// 832B2CE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2CE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2CE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2CEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2CF0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2CF4: 3BEBF7A8  addi r31, r11, -0x858
	ctx.r[31].s64 = ctx.r[11].s64 + -2136;
	// 832B2CF8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B2CFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B2D00: 419A0008  beq cr6, 0x832b2d08
	if ctx.cr[6].eq {
	pc = 0x832B2D08; continue 'dispatch;
	}
	// 832B2D04: 4AF69035  bl 0x8221bd38
	ctx.lr = 0x832B2D08;
	sub_8221BD38(ctx, base);
	// 832B2D08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2D0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B2D10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B2D14: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B2D18: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B2D1C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B2D20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B2D24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2D28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2D2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2D30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2D38 size=12
    let mut pc: u32 = 0x832B2D38;
    'dispatch: loop {
        match pc {
            0x832B2D38 => {
    //   block [0x832B2D38..0x832B2D44)
	// 832B2D38: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2D3C: 386BF7B8  addi r3, r11, -0x848
	ctx.r[3].s64 = ctx.r[11].s64 + -2120;
	// 832B2D40: 4B067E18  b 0x8231ab58
	sub_8231AB58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2D48 size=76
    let mut pc: u32 = 0x832B2D48;
    'dispatch: loop {
        match pc {
            0x832B2D48 => {
    //   block [0x832B2D48..0x832B2D94)
	// 832B2D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2D4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2D50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2D54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2D58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2D5C: 3BEBF7C8  addi r31, r11, -0x838
	ctx.r[31].s64 = ctx.r[11].s64 + -2104;
	// 832B2D60: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 832B2D64: 4AF62075  bl 0x82214dd8
	ctx.lr = 0x832B2D68;
	sub_82214DD8(ctx, base);
	// 832B2D68: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 832B2D6C: 4AF6206D  bl 0x82214dd8
	ctx.lr = 0x832B2D70;
	sub_82214DD8(ctx, base);
	// 832B2D70: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 832B2D74: 4AF62065  bl 0x82214dd8
	ctx.lr = 0x832B2D78;
	sub_82214DD8(ctx, base);
	// 832B2D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2D7C: 4AF6205D  bl 0x82214dd8
	ctx.lr = 0x832B2D80;
	sub_82214DD8(ctx, base);
	// 832B2D80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B2D84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2D88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2D8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2D98 size=16
    let mut pc: u32 = 0x832B2D98;
    'dispatch: loop {
        match pc {
            0x832B2D98 => {
    //   block [0x832B2D98..0x832B2DA8)
	// 832B2D98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B2D9C: 806BF7D8  lwz r3, -0x828(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-2088 as u32) ) } as u64;
	// 832B2DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B2DA4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2DA8 size=16
    let mut pc: u32 = 0x832B2DA8;
    'dispatch: loop {
        match pc {
            0x832B2DA8 => {
    //   block [0x832B2DA8..0x832B2DB8)
	// 832B2DA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B2DAC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832B2DB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B2DB4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B2DB8 size=4
    let mut pc: u32 = 0x832B2DB8;
    'dispatch: loop {
        match pc {
            0x832B2DB8 => {
    //   block [0x832B2DB8..0x832B2DBC)
	// 832B2DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2DC0 size=84
    let mut pc: u32 = 0x832B2DC0;
    'dispatch: loop {
        match pc {
            0x832B2DC0 => {
    //   block [0x832B2DC0..0x832B2E14)
	// 832B2DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2DC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2DCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2DD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2DD4: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2DD8: 83FEF7DC  lwz r31, -0x824(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2084 as u32) ) } as u64;
	// 832B2DDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2DE0: 419A0014  beq cr6, 0x832b2df4
	if ctx.cr[6].eq {
	pc = 0x832B2DF4; continue 'dispatch;
	}
	// 832B2DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2DE8: 4AFC2521  bl 0x82275308
	ctx.lr = 0x832B2DEC;
	sub_82275308(ctx, base);
	// 832B2DEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2DF0: 4AF68F49  bl 0x8221bd38
	ctx.lr = 0x832B2DF4;
	sub_8221BD38(ctx, base);
	// 832B2DF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2DF8: 917EF7DC  stw r11, -0x824(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2084 as u32), ctx.r[11].u32 ) };
	// 832B2DFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2E08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2E0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2E10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2E18 size=84
    let mut pc: u32 = 0x832B2E18;
    'dispatch: loop {
        match pc {
            0x832B2E18 => {
    //   block [0x832B2E18..0x832B2E6C)
	// 832B2E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2E1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2E20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2E24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2E2C: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2E30: 83FEF7E0  lwz r31, -0x820(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2080 as u32) ) } as u64;
	// 832B2E34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2E38: 419A0014  beq cr6, 0x832b2e4c
	if ctx.cr[6].eq {
	pc = 0x832B2E4C; continue 'dispatch;
	}
	// 832B2E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2E40: 4AFEAC59  bl 0x8229da98
	ctx.lr = 0x832B2E44;
	sub_8229DA98(ctx, base);
	// 832B2E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2E48: 4AF68EF1  bl 0x8221bd38
	ctx.lr = 0x832B2E4C;
	sub_8221BD38(ctx, base);
	// 832B2E4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2E50: 917EF7E0  stw r11, -0x820(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2080 as u32), ctx.r[11].u32 ) };
	// 832B2E54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2E58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2E5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2E60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2E64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2E70 size=84
    let mut pc: u32 = 0x832B2E70;
    'dispatch: loop {
        match pc {
            0x832B2E70 => {
    //   block [0x832B2E70..0x832B2EC4)
	// 832B2E70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2E74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2E78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2E7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2E80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2E84: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2E88: 83FEF7E4  lwz r31, -0x81c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2076 as u32) ) } as u64;
	// 832B2E8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2E90: 419A0014  beq cr6, 0x832b2ea4
	if ctx.cr[6].eq {
	pc = 0x832B2EA4; continue 'dispatch;
	}
	// 832B2E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2E98: 4AFEAC01  bl 0x8229da98
	ctx.lr = 0x832B2E9C;
	sub_8229DA98(ctx, base);
	// 832B2E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2EA0: 4AF68E99  bl 0x8221bd38
	ctx.lr = 0x832B2EA4;
	sub_8221BD38(ctx, base);
	// 832B2EA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2EA8: 917EF7E4  stw r11, -0x81c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2076 as u32), ctx.r[11].u32 ) };
	// 832B2EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2EB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2EB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2EB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2EBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2EC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2EC8 size=84
    let mut pc: u32 = 0x832B2EC8;
    'dispatch: loop {
        match pc {
            0x832B2EC8 => {
    //   block [0x832B2EC8..0x832B2F1C)
	// 832B2EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2ECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2ED0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2ED4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2EDC: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2EE0: 83FEF7E8  lwz r31, -0x818(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2072 as u32) ) } as u64;
	// 832B2EE4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2EE8: 419A0014  beq cr6, 0x832b2efc
	if ctx.cr[6].eq {
	pc = 0x832B2EFC; continue 'dispatch;
	}
	// 832B2EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2EF0: 4AFEABA9  bl 0x8229da98
	ctx.lr = 0x832B2EF4;
	sub_8229DA98(ctx, base);
	// 832B2EF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2EF8: 4AF68E41  bl 0x8221bd38
	ctx.lr = 0x832B2EFC;
	sub_8221BD38(ctx, base);
	// 832B2EFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2F00: 917EF7E8  stw r11, -0x818(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2072 as u32), ctx.r[11].u32 ) };
	// 832B2F04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2F08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2F0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2F10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2F14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2F18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2F20 size=84
    let mut pc: u32 = 0x832B2F20;
    'dispatch: loop {
        match pc {
            0x832B2F20 => {
    //   block [0x832B2F20..0x832B2F74)
	// 832B2F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2F24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2F28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2F2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2F30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2F34: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2F38: 83FEF7EC  lwz r31, -0x814(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2068 as u32) ) } as u64;
	// 832B2F3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2F40: 419A0014  beq cr6, 0x832b2f54
	if ctx.cr[6].eq {
	pc = 0x832B2F54; continue 'dispatch;
	}
	// 832B2F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2F48: 4AFEAB51  bl 0x8229da98
	ctx.lr = 0x832B2F4C;
	sub_8229DA98(ctx, base);
	// 832B2F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2F50: 4AF68DE9  bl 0x8221bd38
	ctx.lr = 0x832B2F54;
	sub_8221BD38(ctx, base);
	// 832B2F54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2F58: 917EF7EC  stw r11, -0x814(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2068 as u32), ctx.r[11].u32 ) };
	// 832B2F5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2F60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2F64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2F68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2F70: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2F78 size=84
    let mut pc: u32 = 0x832B2F78;
    'dispatch: loop {
        match pc {
            0x832B2F78 => {
    //   block [0x832B2F78..0x832B2FCC)
	// 832B2F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2F7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2F80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2F84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2F88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2F8C: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2F90: 83FEF7F0  lwz r31, -0x810(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2064 as u32) ) } as u64;
	// 832B2F94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2F98: 419A0014  beq cr6, 0x832b2fac
	if ctx.cr[6].eq {
	pc = 0x832B2FAC; continue 'dispatch;
	}
	// 832B2F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2FA0: 4AFEAAF9  bl 0x8229da98
	ctx.lr = 0x832B2FA4;
	sub_8229DA98(ctx, base);
	// 832B2FA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2FA8: 4AF68D91  bl 0x8221bd38
	ctx.lr = 0x832B2FAC;
	sub_8221BD38(ctx, base);
	// 832B2FAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B2FB0: 917EF7F0  stw r11, -0x810(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2064 as u32), ctx.r[11].u32 ) };
	// 832B2FB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B2FB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B2FBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B2FC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B2FC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B2FC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B2FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B2FD0 size=84
    let mut pc: u32 = 0x832B2FD0;
    'dispatch: loop {
        match pc {
            0x832B2FD0 => {
    //   block [0x832B2FD0..0x832B3024)
	// 832B2FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B2FD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B2FD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B2FDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B2FE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B2FE4: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B2FE8: 83FEF7F4  lwz r31, -0x80c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-2060 as u32) ) } as u64;
	// 832B2FEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B2FF0: 419A0014  beq cr6, 0x832b3004
	if ctx.cr[6].eq {
	pc = 0x832B3004; continue 'dispatch;
	}
	// 832B2FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B2FF8: 4AFEAAA1  bl 0x8229da98
	ctx.lr = 0x832B2FFC;
	sub_8229DA98(ctx, base);
	// 832B2FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3000: 4AF68D39  bl 0x8221bd38
	ctx.lr = 0x832B3004;
	sub_8221BD38(ctx, base);
	// 832B3004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3008: 917EF7F4  stw r11, -0x80c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-2060 as u32), ctx.r[11].u32 ) };
	// 832B300C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3018: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B301C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3020: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3028 size=116
    let mut pc: u32 = 0x832B3028;
    'dispatch: loop {
        match pc {
            0x832B3028 => {
    //   block [0x832B3028..0x832B309C)
	// 832B3028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B302C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3030: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3034: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3038: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B303C: 807FF7F8  lwz r3, -0x808(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-2056 as u32) ) } as u64;
	// 832B3040: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3044: 419A0044  beq cr6, 0x832b3088
	if ctx.cr[6].eq {
	pc = 0x832B3088; continue 'dispatch;
	}
	// 832B3048: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B304C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B3050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B3054: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B3058: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B305C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B3060: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B3064: 4082FFE8  bne 0x832b304c
	if !ctx.cr[0].eq {
	pc = 0x832B304C; continue 'dispatch;
	}
	// 832B3068: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B306C: 409A0014  bne cr6, 0x832b3080
	if !ctx.cr[6].eq {
	pc = 0x832B3080; continue 'dispatch;
	}
	// 832B3070: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3074: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3078: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B307C: 4E800421  bctrl
	ctx.lr = 0x832B3080;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B3080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3084: 917FF7F8  stw r11, -0x808(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-2056 as u32), ctx.r[11].u32 ) };
	// 832B3088: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B308C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3090: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30A0 size=4
    let mut pc: u32 = 0x832B30A0;
    'dispatch: loop {
        match pc {
            0x832B30A0 => {
    //   block [0x832B30A0..0x832B30A4)
	// 832B30A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30A8 size=12
    let mut pc: u32 = 0x832B30A8;
    'dispatch: loop {
        match pc {
            0x832B30A8 => {
    //   block [0x832B30A8..0x832B30B4)
	// 832B30A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B30AC: 386BF818  addi r3, r11, -0x7e8
	ctx.r[3].s64 = ctx.r[11].s64 + -2024;
	// 832B30B0: 4B79D478  b 0x82a50528
	sub_82A50528(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30B8 size=12
    let mut pc: u32 = 0x832B30B8;
    'dispatch: loop {
        match pc {
            0x832B30B8 => {
    //   block [0x832B30B8..0x832B30C4)
	// 832B30B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B30BC: 386BF820  addi r3, r11, -0x7e0
	ctx.r[3].s64 = ctx.r[11].s64 + -2016;
	// 832B30C0: 4AF04A58  b 0x821b7b18
	sub_821B7B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30C8 size=12
    let mut pc: u32 = 0x832B30C8;
    'dispatch: loop {
        match pc {
            0x832B30C8 => {
    //   block [0x832B30C8..0x832B30D4)
	// 832B30C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B30CC: 386BF828  addi r3, r11, -0x7d8
	ctx.r[3].s64 = ctx.r[11].s64 + -2008;
	// 832B30D0: 4AF04A48  b 0x821b7b18
	sub_821B7B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30D8 size=12
    let mut pc: u32 = 0x832B30D8;
    'dispatch: loop {
        match pc {
            0x832B30D8 => {
    //   block [0x832B30D8..0x832B30E4)
	// 832B30D8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B30DC: 386BF830  addi r3, r11, -0x7d0
	ctx.r[3].s64 = ctx.r[11].s64 + -2000;
	// 832B30E0: 4AF04A38  b 0x821b7b18
	sub_821B7B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30E8 size=12
    let mut pc: u32 = 0x832B30E8;
    'dispatch: loop {
        match pc {
            0x832B30E8 => {
    //   block [0x832B30E8..0x832B30F4)
	// 832B30E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B30EC: 386BF838  addi r3, r11, -0x7c8
	ctx.r[3].s64 = ctx.r[11].s64 + -1992;
	// 832B30F0: 4AF04A28  b 0x821b7b18
	sub_821B7B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B30F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B30F8 size=12
    let mut pc: u32 = 0x832B30F8;
    'dispatch: loop {
        match pc {
            0x832B30F8 => {
    //   block [0x832B30F8..0x832B3104)
	// 832B30F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B30FC: 386BF840  addi r3, r11, -0x7c0
	ctx.r[3].s64 = ctx.r[11].s64 + -1984;
	// 832B3100: 4AF04A18  b 0x821b7b18
	sub_821B7B18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3108 size=84
    let mut pc: u32 = 0x832B3108;
    'dispatch: loop {
        match pc {
            0x832B3108 => {
    //   block [0x832B3108..0x832B315C)
	// 832B3108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B310C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B3114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B311C: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B3120: 83FEF848  lwz r31, -0x7b8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1976 as u32) ) } as u64;
	// 832B3124: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B3128: 419A0014  beq cr6, 0x832b313c
	if ctx.cr[6].eq {
	pc = 0x832B313C; continue 'dispatch;
	}
	// 832B312C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3130: 4B7C8B09  bl 0x82a7bc38
	ctx.lr = 0x832B3134;
	sub_82A7BC38(ctx, base);
	// 832B3134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3138: 4AF68C01  bl 0x8221bd38
	ctx.lr = 0x832B313C;
	sub_8221BD38(ctx, base);
	// 832B313C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3140: 917EF848  stw r11, -0x7b8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-1976 as u32), ctx.r[11].u32 ) };
	// 832B3144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3148: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B314C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3150: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B3154: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3158: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3160 size=92
    let mut pc: u32 = 0x832B3160;
    'dispatch: loop {
        match pc {
            0x832B3160 => {
    //   block [0x832B3160..0x832B31BC)
	// 832B3160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B316C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3170: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3174: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B3178: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B317C: 3BDFA978  addi r30, r31, -0x5688
	ctx.r[30].s64 = ctx.r[31].s64 + -22152;
	// 832B3180: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B3184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B3188: 917FA978  stw r11, -0x5688(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22152 as u32), ctx.r[11].u32 ) };
	// 832B318C: 4AF48E7D  bl 0x821fc008
	ctx.lr = 0x832B3190;
	sub_821FC008(ctx, base);
	// 832B3190: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B3194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B3198: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B319C: 917FA978  stw r11, -0x5688(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22152 as u32), ctx.r[11].u32 ) };
	// 832B31A0: 4AF48E69  bl 0x821fc008
	ctx.lr = 0x832B31A4;
	sub_821FC008(ctx, base);
	// 832B31A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B31A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B31AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B31B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B31B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B31B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B31C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B31C0 size=92
    let mut pc: u32 = 0x832B31C0;
    'dispatch: loop {
        match pc {
            0x832B31C0 => {
    //   block [0x832B31C0..0x832B321C)
	// 832B31C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B31C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B31C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B31CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B31D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B31D4: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B31D8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B31DC: 3BDFA980  addi r30, r31, -0x5680
	ctx.r[30].s64 = ctx.r[31].s64 + -22144;
	// 832B31E0: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B31E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B31E8: 917FA980  stw r11, -0x5680(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22144 as u32), ctx.r[11].u32 ) };
	// 832B31EC: 4AF48E1D  bl 0x821fc008
	ctx.lr = 0x832B31F0;
	sub_821FC008(ctx, base);
	// 832B31F0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B31F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B31F8: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B31FC: 917FA980  stw r11, -0x5680(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22144 as u32), ctx.r[11].u32 ) };
	// 832B3200: 4AF48E09  bl 0x821fc008
	ctx.lr = 0x832B3204;
	sub_821FC008(ctx, base);
	// 832B3204: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3208: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B320C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3210: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B3214: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3220 size=92
    let mut pc: u32 = 0x832B3220;
    'dispatch: loop {
        match pc {
            0x832B3220 => {
    //   block [0x832B3220..0x832B327C)
	// 832B3220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3228: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B322C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3234: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B3238: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B323C: 3BDFA988  addi r30, r31, -0x5678
	ctx.r[30].s64 = ctx.r[31].s64 + -22136;
	// 832B3240: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B3244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B3248: 917FA988  stw r11, -0x5678(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22136 as u32), ctx.r[11].u32 ) };
	// 832B324C: 4AF48DBD  bl 0x821fc008
	ctx.lr = 0x832B3250;
	sub_821FC008(ctx, base);
	// 832B3250: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B3254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B3258: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B325C: 917FA988  stw r11, -0x5678(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-22136 as u32), ctx.r[11].u32 ) };
	// 832B3260: 4AF48DA9  bl 0x821fc008
	ctx.lr = 0x832B3264;
	sub_821FC008(ctx, base);
	// 832B3264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3268: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B326C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3270: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B3274: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3278: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3280 size=88
    let mut pc: u32 = 0x832B3280;
    'dispatch: loop {
        match pc {
            0x832B3280 => {
    //   block [0x832B3280..0x832B32D8)
	// 832B3280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B328C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3290: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3294: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 832B3298: 3BEBA990  addi r31, r11, -0x5670
	ctx.r[31].s64 = ctx.r[11].s64 + -22128;
	// 832B329C: 396A2A2C  addi r11, r10, 0x2a2c
	ctx.r[11].s64 = ctx.r[10].s64 + 10796;
	// 832B32A0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B32A4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832B32A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B32AC: 419A0018  beq cr6, 0x832b32c4
	if ctx.cr[6].eq {
	pc = 0x832B32C4; continue 'dispatch;
	}
	// 832B32B0: 4AF49071  bl 0x821fc320
	ctx.lr = 0x832B32B4;
	sub_821FC320(ctx, base);
	// 832B32B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B32B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B32BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B32C0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B32C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B32C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B32CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B32D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B32D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B32D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B32D8 size=88
    let mut pc: u32 = 0x832B32D8;
    'dispatch: loop {
        match pc {
            0x832B32D8 => {
    //   block [0x832B32D8..0x832B3330)
	// 832B32D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B32DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B32E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B32E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B32E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B32EC: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 832B32F0: 3BEBA99C  addi r31, r11, -0x5664
	ctx.r[31].s64 = ctx.r[11].s64 + -22116;
	// 832B32F4: 396A2A2C  addi r11, r10, 0x2a2c
	ctx.r[11].s64 = ctx.r[10].s64 + 10796;
	// 832B32F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B32FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832B3300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3304: 419A0018  beq cr6, 0x832b331c
	if ctx.cr[6].eq {
	pc = 0x832B331C; continue 'dispatch;
	}
	// 832B3308: 4AF49019  bl 0x821fc320
	ctx.lr = 0x832B330C;
	sub_821FC320(ctx, base);
	// 832B330C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3310: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3314: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3318: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B331C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3320: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3324: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3328: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B332C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3330 size=12
    let mut pc: u32 = 0x832B3330;
    'dispatch: loop {
        match pc {
            0x832B3330 => {
    //   block [0x832B3330..0x832B333C)
	// 832B3330: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3334: 386BA9A8  addi r3, r11, -0x5658
	ctx.r[3].s64 = ctx.r[11].s64 + -22104;
	// 832B3338: 4AF48C58  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3340 size=12
    let mut pc: u32 = 0x832B3340;
    'dispatch: loop {
        match pc {
            0x832B3340 => {
    //   block [0x832B3340..0x832B334C)
	// 832B3340: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3344: 386BA9CC  addi r3, r11, -0x5634
	ctx.r[3].s64 = ctx.r[11].s64 + -22068;
	// 832B3348: 4AF48C48  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3350 size=12
    let mut pc: u32 = 0x832B3350;
    'dispatch: loop {
        match pc {
            0x832B3350 => {
    //   block [0x832B3350..0x832B335C)
	// 832B3350: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3354: 386BA9F0  addi r3, r11, -0x5610
	ctx.r[3].s64 = ctx.r[11].s64 + -22032;
	// 832B3358: 4AF48C38  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3360 size=12
    let mut pc: u32 = 0x832B3360;
    'dispatch: loop {
        match pc {
            0x832B3360 => {
    //   block [0x832B3360..0x832B336C)
	// 832B3360: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3364: 386BAA14  addi r3, r11, -0x55ec
	ctx.r[3].s64 = ctx.r[11].s64 + -21996;
	// 832B3368: 4AF48C28  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3370 size=12
    let mut pc: u32 = 0x832B3370;
    'dispatch: loop {
        match pc {
            0x832B3370 => {
    //   block [0x832B3370..0x832B337C)
	// 832B3370: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3374: 386BAA38  addi r3, r11, -0x55c8
	ctx.r[3].s64 = ctx.r[11].s64 + -21960;
	// 832B3378: 4AF48C18  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3380 size=12
    let mut pc: u32 = 0x832B3380;
    'dispatch: loop {
        match pc {
            0x832B3380 => {
    //   block [0x832B3380..0x832B338C)
	// 832B3380: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3384: 386BAA5C  addi r3, r11, -0x55a4
	ctx.r[3].s64 = ctx.r[11].s64 + -21924;
	// 832B3388: 4AF48C08  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3390 size=12
    let mut pc: u32 = 0x832B3390;
    'dispatch: loop {
        match pc {
            0x832B3390 => {
    //   block [0x832B3390..0x832B339C)
	// 832B3390: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3394: 386BF850  addi r3, r11, -0x7b0
	ctx.r[3].s64 = ctx.r[11].s64 + -1968;
	// 832B3398: 4B799890  b 0x82a4cc28
	sub_82A4CC28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B33A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B33A0 size=12
    let mut pc: u32 = 0x832B33A0;
    'dispatch: loop {
        match pc {
            0x832B33A0 => {
    //   block [0x832B33A0..0x832B33AC)
	// 832B33A0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B33A4: 386BF8E0  addi r3, r11, -0x720
	ctx.r[3].s64 = ctx.r[11].s64 + -1824;
	// 832B33A8: 4B799880  b 0x82a4cc28
	sub_82A4CC28(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B33B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B33B0 size=80
    let mut pc: u32 = 0x832B33B0;
    'dispatch: loop {
        match pc {
            0x832B33B0 => {
    //   block [0x832B33B0..0x832B3400)
	// 832B33B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B33B4: 4B9F6059  bl 0x82ca940c
	ctx.lr = 0x832B33B8;
	sub_82CA93D0(ctx, base);
	// 832B33B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B33BC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B33C0: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 832B33C4: 396BF970  addi r11, r11, -0x690
	ctx.r[11].s64 = ctx.r[11].s64 + -1680;
	// 832B33C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832B33CC: 3BEB0044  addi r31, r11, 0x44
	ctx.r[31].s64 = ctx.r[11].s64 + 68;
	// 832B33D0: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 832B33D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B33D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B33DC: 419A0008  beq cr6, 0x832b33e4
	if ctx.cr[6].eq {
	pc = 0x832B33E4; continue 'dispatch;
	}
	// 832B33E0: 4AF68959  bl 0x8221bd38
	ctx.lr = 0x832B33E4;
	sub_8221BD38(ctx, base);
	// 832B33E4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B33E8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832B33EC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 832B33F0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 832B33F4: 4080FFDC  bge 0x832b33d0
	if !ctx.cr[0].lt {
	pc = 0x832B33D0; continue 'dispatch;
	}
	// 832B33F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B33FC: 4B9F6060  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3400 size=80
    let mut pc: u32 = 0x832B3400;
    'dispatch: loop {
        match pc {
            0x832B3400 => {
    //   block [0x832B3400..0x832B3450)
	// 832B3400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B340C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3410: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B3414: 807FF84C  lwz r3, -0x7b4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1972 as u32) ) } as u64;
	// 832B3418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B341C: 419A0018  beq cr6, 0x832b3434
	if ctx.cr[6].eq {
	pc = 0x832B3434; continue 'dispatch;
	}
	// 832B3420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3424: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832B3428: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B342C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B3430: 4E800421  bctrl
	ctx.lr = 0x832B3434;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B3434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3438: 917FF84C  stw r11, -0x7b4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-1972 as u32), ctx.r[11].u32 ) };
	// 832B343C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3440: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3444: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B344C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3450 size=88
    let mut pc: u32 = 0x832B3450;
    'dispatch: loop {
        match pc {
            0x832B3450 => {
    //   block [0x832B3450..0x832B34A8)
	// 832B3450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3454: 4B9F5FB5  bl 0x82ca9408
	ctx.lr = 0x832B3458;
	sub_82CA93D0(ctx, base);
	// 832B3458: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B345C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3460: 3BA00003  li r29, 3
	ctx.r[29].s64 = 3;
	// 832B3464: 396BF9B0  addi r11, r11, -0x650
	ctx.r[11].s64 = ctx.r[11].s64 + -1616;
	// 832B3468: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832B346C: 3BCB0010  addi r30, r11, 0x10
	ctx.r[30].s64 = ctx.r[11].s64 + 16;
	// 832B3470: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 832B3474: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3478: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B347C: 419A0018  beq cr6, 0x832b3494
	if ctx.cr[6].eq {
	pc = 0x832B3494; continue 'dispatch;
	}
	// 832B3480: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3484: 4AF688B5  bl 0x8221bd38
	ctx.lr = 0x832B3488;
	sub_8221BD38(ctx, base);
	// 832B3488: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832B348C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3490: 4AF688A9  bl 0x8221bd38
	ctx.lr = 0x832B3494;
	sub_8221BD38(ctx, base);
	// 832B3494: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 832B3498: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832B349C: 4080FFD4  bge 0x832b3470
	if !ctx.cr[0].lt {
	pc = 0x832B3470; continue 'dispatch;
	}
	// 832B34A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B34A4: 4B9F5FB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B34A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B34A8 size=124
    let mut pc: u32 = 0x832B34A8;
    'dispatch: loop {
        match pc {
            0x832B34A8 => {
    //   block [0x832B34A8..0x832B3524)
	// 832B34A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B34AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B34B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B34B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B34B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B34BC: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B34C0: 83FEF9C0  lwz r31, -0x640(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 832B34C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B34C8: 419A003C  beq cr6, 0x832b3504
	if ctx.cr[6].eq {
	pc = 0x832B3504; continue 'dispatch;
	}
	// 832B34CC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832B34D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B34D4: 419A0008  beq cr6, 0x832b34dc
	if ctx.cr[6].eq {
	pc = 0x832B34DC; continue 'dispatch;
	}
	// 832B34D8: 4B88A2F1  bl 0x82b3d7c8
	ctx.lr = 0x832B34DC;
	sub_82B3D7C8(ctx, base);
	// 832B34DC: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 832B34E0: 4B3871A9  bl 0x8263a688
	ctx.lr = 0x832B34E4;
	sub_8263A688(ctx, base);
	// 832B34E4: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 832B34E8: 4B3871A1  bl 0x8263a688
	ctx.lr = 0x832B34EC;
	sub_8263A688(ctx, base);
	// 832B34EC: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 832B34F0: 4B7EE169  bl 0x82aa1658
	ctx.lr = 0x832B34F4;
	sub_82AA1658(ctx, base);
	// 832B34F4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 832B34F8: 4B7EE161  bl 0x82aa1658
	ctx.lr = 0x832B34FC;
	sub_82AA1658(ctx, base);
	// 832B34FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3500: 4AF68839  bl 0x8221bd38
	ctx.lr = 0x832B3504;
	sub_8221BD38(ctx, base);
	// 832B3504: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3508: 917EF9C0  stw r11, -0x640(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-1600 as u32), ctx.r[11].u32 ) };
	// 832B350C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3510: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3514: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3518: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B351C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3520: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3528 size=132
    let mut pc: u32 = 0x832B3528;
    'dispatch: loop {
        match pc {
            0x832B3528 => {
    //   block [0x832B3528..0x832B35AC)
	// 832B3528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B352C: 4B9F5EDD  bl 0x82ca9408
	ctx.lr = 0x832B3530;
	sub_82CA93D0(ctx, base);
	// 832B3530: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3534: 3F80834A  lis r28, -0x7cb6
	ctx.r[28].s64 = -2092302336;
	// 832B3538: 83DCF9C4  lwz r30, -0x63c(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-1596 as u32) ) } as u64;
	// 832B353C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832B3540: 419A005C  beq cr6, 0x832b359c
	if ctx.cr[6].eq {
	pc = 0x832B359C; continue 'dispatch;
	}
	// 832B3544: 809E0028  lwz r4, 0x28(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 832B3548: 3BFE0024  addi r31, r30, 0x24
	ctx.r[31].s64 = ctx.r[30].s64 + 36;
	// 832B354C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 832B3550: 419A0018  beq cr6, 0x832b3568
	if ctx.cr[6].eq {
	pc = 0x832B3568; continue 'dispatch;
	}
	// 832B3554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3558: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832B355C: 4B7EE4AD  bl 0x82aa1a08
	ctx.lr = 0x832B3560;
	sub_82AA1A08(ctx, base);
	// 832B3560: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3564: 4AF687D5  bl 0x8221bd38
	ctx.lr = 0x832B3568;
	sub_8221BD38(ctx, base);
	// 832B3568: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 832B356C: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 832B3570: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 832B3574: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 832B3578: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 832B357C: 4B7EE0DD  bl 0x82aa1658
	ctx.lr = 0x832B3580;
	sub_82AA1658(ctx, base);
	// 832B3580: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 832B3584: 4B7EDF15  bl 0x82aa1498
	ctx.lr = 0x832B3588;
	sub_82AA1498(ctx, base);
	// 832B3588: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B358C: 4AF687AD  bl 0x8221bd38
	ctx.lr = 0x832B3590;
	sub_8221BD38(ctx, base);
	// 832B3590: 93BCF9C4  stw r29, -0x63c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-1596 as u32), ctx.r[29].u32 ) };
	// 832B3594: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B3598: 4B9F5EC0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
	// 832B359C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B35A0: 917CF9C4  stw r11, -0x63c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-1596 as u32), ctx.r[11].u32 ) };
	// 832B35A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B35A8: 4B9F5EB0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B35B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B35B0 size=124
    let mut pc: u32 = 0x832B35B0;
    'dispatch: loop {
        match pc {
            0x832B35B0 => {
    //   block [0x832B35B0..0x832B362C)
	// 832B35B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B35B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B35B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B35BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B35C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B35C4: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 832B35C8: 83FEF9C8  lwz r31, -0x638(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1592 as u32) ) } as u64;
	// 832B35CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 832B35D0: 419A003C  beq cr6, 0x832b360c
	if ctx.cr[6].eq {
	pc = 0x832B360C; continue 'dispatch;
	}
	// 832B35D4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 832B35D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B35DC: 419A0008  beq cr6, 0x832b35e4
	if ctx.cr[6].eq {
	pc = 0x832B35E4; continue 'dispatch;
	}
	// 832B35E0: 4B88A1E9  bl 0x82b3d7c8
	ctx.lr = 0x832B35E4;
	sub_82B3D7C8(ctx, base);
	// 832B35E4: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 832B35E8: 4B3870A1  bl 0x8263a688
	ctx.lr = 0x832B35EC;
	sub_8263A688(ctx, base);
	// 832B35EC: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 832B35F0: 4B387099  bl 0x8263a688
	ctx.lr = 0x832B35F4;
	sub_8263A688(ctx, base);
	// 832B35F4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 832B35F8: 4B7EE061  bl 0x82aa1658
	ctx.lr = 0x832B35FC;
	sub_82AA1658(ctx, base);
	// 832B35FC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 832B3600: 4B7EE059  bl 0x82aa1658
	ctx.lr = 0x832B3604;
	sub_82AA1658(ctx, base);
	// 832B3604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3608: 4AF68731  bl 0x8221bd38
	ctx.lr = 0x832B360C;
	sub_8221BD38(ctx, base);
	// 832B360C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3610: 917EF9C8  stw r11, -0x638(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-1592 as u32), ctx.r[11].u32 ) };
	// 832B3614: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3618: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B361C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3620: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B3624: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3628: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3630 size=12
    let mut pc: u32 = 0x832B3630;
    'dispatch: loop {
        match pc {
            0x832B3630 => {
    //   block [0x832B3630..0x832B363C)
	// 832B3630: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3634: 386BF9D0  addi r3, r11, -0x630
	ctx.r[3].s64 = ctx.r[11].s64 + -1584;
	// 832B3638: 4AF617A0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3640 size=12
    let mut pc: u32 = 0x832B3640;
    'dispatch: loop {
        match pc {
            0x832B3640 => {
    //   block [0x832B3640..0x832B364C)
	// 832B3640: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3644: 386BF9D4  addi r3, r11, -0x62c
	ctx.r[3].s64 = ctx.r[11].s64 + -1580;
	// 832B3648: 4AF61790  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3650 size=132
    let mut pc: u32 = 0x832B3650;
    'dispatch: loop {
        match pc {
            0x832B3650 => {
    //   block [0x832B3650..0x832B36D4)
	// 832B3650: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3654: 4B9F5DB5  bl 0x82ca9408
	ctx.lr = 0x832B3658;
	sub_82CA93D0(ctx, base);
	// 832B3658: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B365C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3660: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 832B3664: 3BCBF9D8  addi r30, r11, -0x628
	ctx.r[30].s64 = ctx.r[11].s64 + -1576;
	// 832B3668: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 832B366C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3670: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3674: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832B3678: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B367C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3680: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3684: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B3688: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B368C: 419A0034  beq cr6, 0x832b36c0
	if ctx.cr[6].eq {
	pc = 0x832B36C0; continue 'dispatch;
	}
	// 832B3690: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 832B3694: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3698: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B369C: 419A000C  beq cr6, 0x832b36a8
	if ctx.cr[6].eq {
	pc = 0x832B36A8; continue 'dispatch;
	}
	// 832B36A0: 4B8D3F29  bl 0x82b875c8
	ctx.lr = 0x832B36A4;
	sub_82B875C8(ctx, base);
	// 832B36A4: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 832B36A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B36AC: 4AF6868D  bl 0x8221bd38
	ctx.lr = 0x832B36B0;
	sub_8221BD38(ctx, base);
	// 832B36B0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B36B4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 832B36B8: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B36BC: 409AFFD4  bne cr6, 0x832b3690
	if !ctx.cr[6].eq {
	pc = 0x832B3690; continue 'dispatch;
	}
	// 832B36C0: 4AF68679  bl 0x8221bd38
	ctx.lr = 0x832B36C4;
	sub_8221BD38(ctx, base);
	// 832B36C4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 832B36C8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B36CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B36D0: 4B9F5D88  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B36D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B36D8 size=12
    let mut pc: u32 = 0x832B36D8;
    'dispatch: loop {
        match pc {
            0x832B36D8 => {
    //   block [0x832B36D8..0x832B36E4)
	// 832B36D8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B36DC: 386BF9E4  addi r3, r11, -0x61c
	ctx.r[3].s64 = ctx.r[11].s64 + -1564;
	// 832B36E0: 4B79EF50  b 0x82a52630
	sub_82A52630(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B36E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B36E8 size=132
    let mut pc: u32 = 0x832B36E8;
    'dispatch: loop {
        match pc {
            0x832B36E8 => {
    //   block [0x832B36E8..0x832B376C)
	// 832B36E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B36EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B36F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B36F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B36F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B36FC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3700: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3704: 3BEBF9F0  addi r31, r11, -0x610
	ctx.r[31].s64 = ctx.r[11].s64 + -1552;
	// 832B3708: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B370C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3710: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 832B3714: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3718: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 832B371C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3720: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B3724: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 832B3728: 419A0020  beq cr6, 0x832b3748
	if ctx.cr[6].eq {
	pc = 0x832B3748; continue 'dispatch;
	}
	// 832B372C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 832B3730: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3734: 4AF68605  bl 0x8221bd38
	ctx.lr = 0x832B3738;
	sub_8221BD38(ctx, base);
	// 832B3738: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B373C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 832B3740: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B3744: 409AFFE8  bne cr6, 0x832b372c
	if !ctx.cr[6].eq {
	pc = 0x832B372C; continue 'dispatch;
	}
	// 832B3748: 4AF685F1  bl 0x8221bd38
	ctx.lr = 0x832B374C;
	sub_8221BD38(ctx, base);
	// 832B374C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3750: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B375C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3760: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B3764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3770 size=12
    let mut pc: u32 = 0x832B3770;
    'dispatch: loop {
        match pc {
            0x832B3770 => {
    //   block [0x832B3770..0x832B377C)
	// 832B3770: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B3774: 386BAA88  addi r3, r11, -0x5578
	ctx.r[3].s64 = ctx.r[11].s64 + -21880;
	// 832B3778: 4B770038  b 0x82a237b0
	sub_82A237B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3780 size=84
    let mut pc: u32 = 0x832B3780;
    'dispatch: loop {
        match pc {
            0x832B3780 => {
    //   block [0x832B3780..0x832B37D4)
	// 832B3780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B378C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3790: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3794: 3BEBF9FC  addi r31, r11, -0x604
	ctx.r[31].s64 = ctx.r[11].s64 + -1540;
	// 832B3798: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B379C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B37A0: 419A0008  beq cr6, 0x832b37a8
	if ctx.cr[6].eq {
	pc = 0x832B37A8; continue 'dispatch;
	}
	// 832B37A4: 4AF68595  bl 0x8221bd38
	ctx.lr = 0x832B37A8;
	sub_8221BD38(ctx, base);
	// 832B37A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B37AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B37B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B37B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B37B8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B37BC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B37C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B37C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B37C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B37CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B37D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B37D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B37D8 size=80
    let mut pc: u32 = 0x832B37D8;
    'dispatch: loop {
        match pc {
            0x832B37D8 => {
    //   block [0x832B37D8..0x832B3828)
	// 832B37D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B37DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B37E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B37E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B37E8: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B37EC: 807FFA0C  lwz r3, -0x5f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 832B37F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B37F4: 419A0018  beq cr6, 0x832b380c
	if ctx.cr[6].eq {
	pc = 0x832B380C; continue 'dispatch;
	}
	// 832B37F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B37FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 832B3800: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3804: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B3808: 4E800421  bctrl
	ctx.lr = 0x832B380C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B380C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3810: 917FFA0C  stw r11, -0x5f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-1524 as u32), ctx.r[11].u32 ) };
	// 832B3814: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3818: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B381C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3820: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3828 size=80
    let mut pc: u32 = 0x832B3828;
    'dispatch: loop {
        match pc {
            0x832B3828 => {
    //   block [0x832B3828..0x832B3878)
	// 832B3828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B382C: 4B9F5BDD  bl 0x82ca9408
	ctx.lr = 0x832B3830;
	sub_82CA93D0(ctx, base);
	// 832B3830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3834: 3F80834A  lis r28, -0x7cb6
	ctx.r[28].s64 = -2092302336;
	// 832B3838: 83BCFA10  lwz r29, -0x5f0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-1520 as u32) ) } as u64;
	// 832B383C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 832B3840: 419A0028  beq cr6, 0x832b3868
	if ctx.cr[6].eq {
	pc = 0x832B3868; continue 'dispatch;
	}
	// 832B3844: 3BFD0100  addi r31, r29, 0x100
	ctx.r[31].s64 = ctx.r[29].s64 + 256;
	// 832B3848: 3BC0001F  li r30, 0x1f
	ctx.r[30].s64 = 31;
	// 832B384C: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 832B3850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3854: 4AF042C5  bl 0x821b7b18
	ctx.lr = 0x832B3858;
	sub_821B7B18(ctx, base);
	// 832B3858: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B385C: 4080FFF0  bge 0x832b384c
	if !ctx.cr[0].lt {
	pc = 0x832B384C; continue 'dispatch;
	}
	// 832B3860: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 832B3864: 4AF684D5  bl 0x8221bd38
	ctx.lr = 0x832B3868;
	sub_8221BD38(ctx, base);
	// 832B3868: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B386C: 917CFA10  stw r11, -0x5f0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-1520 as u32), ctx.r[11].u32 ) };
	// 832B3870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B3874: 4B9F5BE4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3878 size=16
    let mut pc: u32 = 0x832B3878;
    'dispatch: loop {
        match pc {
            0x832B3878 => {
    //   block [0x832B3878..0x832B3888)
	// 832B3878: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B387C: 806BFA14  lwz r3, -0x5ec(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1516 as u32) ) } as u64;
	// 832B3880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3884: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3888 size=16
    let mut pc: u32 = 0x832B3888;
    'dispatch: loop {
        match pc {
            0x832B3888 => {
    //   block [0x832B3888..0x832B3898)
	// 832B3888: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B388C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 832B3890: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B3894: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3898 size=4
    let mut pc: u32 = 0x832B3898;
    'dispatch: loop {
        match pc {
            0x832B3898 => {
    //   block [0x832B3898..0x832B389C)
	// 832B3898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B38A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B38A0 size=164
    let mut pc: u32 = 0x832B38A0;
    'dispatch: loop {
        match pc {
            0x832B38A0 => {
    //   block [0x832B38A0..0x832B3944)
	// 832B38A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B38A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B38A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B38AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B38B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B38B4: 3BEBFA18  addi r31, r11, -0x5e8
	ctx.r[31].s64 = ctx.r[11].s64 + -1512;
	// 832B38B8: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 832B38BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B38C0: 419A0008  beq cr6, 0x832b38c8
	if ctx.cr[6].eq {
	pc = 0x832B38C8; continue 'dispatch;
	}
	// 832B38C4: 4AF68475  bl 0x8221bd38
	ctx.lr = 0x832B38C8;
	sub_8221BD38(ctx, base);
	// 832B38C8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 832B38CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B38D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B38D4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B38D8: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 832B38DC: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 832B38E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B38E4: 913F002C  stw r9, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 832B38E8: 419A0008  beq cr6, 0x832b38f0
	if ctx.cr[6].eq {
	pc = 0x832B38F0; continue 'dispatch;
	}
	// 832B38EC: 4AF6844D  bl 0x8221bd38
	ctx.lr = 0x832B38F0;
	sub_8221BD38(ctx, base);
	// 832B38F0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B38F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B38F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B38FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3900: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 832B3904: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 832B3908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B390C: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 832B3910: 419A0008  beq cr6, 0x832b3918
	if ctx.cr[6].eq {
	pc = 0x832B3918; continue 'dispatch;
	}
	// 832B3914: 4AF68425  bl 0x8221bd38
	ctx.lr = 0x832B3918;
	sub_8221BD38(ctx, base);
	// 832B3918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B391C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3920: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3924: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3928: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B392C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3930: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B393C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3948 size=4
    let mut pc: u32 = 0x832B3948;
    'dispatch: loop {
        match pc {
            0x832B3948 => {
    //   block [0x832B3948..0x832B394C)
	// 832B3948: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3950 size=12
    let mut pc: u32 = 0x832B3950;
    'dispatch: loop {
        match pc {
            0x832B3950 => {
    //   block [0x832B3950..0x832B395C)
	// 832B3950: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3954: 386BFA4C  addi r3, r11, -0x5b4
	ctx.r[3].s64 = ctx.r[11].s64 + -1460;
	// 832B3958: 4AF61480  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3960 size=12
    let mut pc: u32 = 0x832B3960;
    'dispatch: loop {
        match pc {
            0x832B3960 => {
    //   block [0x832B3960..0x832B396C)
	// 832B3960: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3964: 386BFA50  addi r3, r11, -0x5b0
	ctx.r[3].s64 = ctx.r[11].s64 + -1456;
	// 832B3968: 4AF61470  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3970 size=12
    let mut pc: u32 = 0x832B3970;
    'dispatch: loop {
        match pc {
            0x832B3970 => {
    //   block [0x832B3970..0x832B397C)
	// 832B3970: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3974: 386BFA54  addi r3, r11, -0x5ac
	ctx.r[3].s64 = ctx.r[11].s64 + -1452;
	// 832B3978: 4AF61460  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3980 size=12
    let mut pc: u32 = 0x832B3980;
    'dispatch: loop {
        match pc {
            0x832B3980 => {
    //   block [0x832B3980..0x832B398C)
	// 832B3980: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3984: 386BFA58  addi r3, r11, -0x5a8
	ctx.r[3].s64 = ctx.r[11].s64 + -1448;
	// 832B3988: 4AF61450  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3990 size=12
    let mut pc: u32 = 0x832B3990;
    'dispatch: loop {
        match pc {
            0x832B3990 => {
    //   block [0x832B3990..0x832B399C)
	// 832B3990: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3994: 386BFA5C  addi r3, r11, -0x5a4
	ctx.r[3].s64 = ctx.r[11].s64 + -1444;
	// 832B3998: 4AF61440  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B39A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B39A0 size=12
    let mut pc: u32 = 0x832B39A0;
    'dispatch: loop {
        match pc {
            0x832B39A0 => {
    //   block [0x832B39A0..0x832B39AC)
	// 832B39A0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B39A4: 386BFA70  addi r3, r11, -0x590
	ctx.r[3].s64 = ctx.r[11].s64 + -1424;
	// 832B39A8: 4AF61430  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B39B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B39B0 size=12
    let mut pc: u32 = 0x832B39B0;
    'dispatch: loop {
        match pc {
            0x832B39B0 => {
    //   block [0x832B39B0..0x832B39BC)
	// 832B39B0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B39B4: 386BFA74  addi r3, r11, -0x58c
	ctx.r[3].s64 = ctx.r[11].s64 + -1420;
	// 832B39B8: 4AF61420  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B39C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B39C0 size=12
    let mut pc: u32 = 0x832B39C0;
    'dispatch: loop {
        match pc {
            0x832B39C0 => {
    //   block [0x832B39C0..0x832B39CC)
	// 832B39C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B39C4: 386BFA78  addi r3, r11, -0x588
	ctx.r[3].s64 = ctx.r[11].s64 + -1416;
	// 832B39C8: 4AF61410  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B39D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B39D0 size=12
    let mut pc: u32 = 0x832B39D0;
    'dispatch: loop {
        match pc {
            0x832B39D0 => {
    //   block [0x832B39D0..0x832B39DC)
	// 832B39D0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B39D4: 386BFA7C  addi r3, r11, -0x584
	ctx.r[3].s64 = ctx.r[11].s64 + -1412;
	// 832B39D8: 4AF61400  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B39E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B39E0 size=84
    let mut pc: u32 = 0x832B39E0;
    'dispatch: loop {
        match pc {
            0x832B39E0 => {
    //   block [0x832B39E0..0x832B3A34)
	// 832B39E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B39E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B39E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B39EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B39F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B39F4: 3BEBFAB0  addi r31, r11, -0x550
	ctx.r[31].s64 = ctx.r[11].s64 + -1360;
	// 832B39F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B39FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3A00: 419A0008  beq cr6, 0x832b3a08
	if ctx.cr[6].eq {
	pc = 0x832B3A08; continue 'dispatch;
	}
	// 832B3A04: 4AF68335  bl 0x8221bd38
	ctx.lr = 0x832B3A08;
	sub_8221BD38(ctx, base);
	// 832B3A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3A0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3A10: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3A14: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3A18: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3A1C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3A20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3A24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3A28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3A38 size=84
    let mut pc: u32 = 0x832B3A38;
    'dispatch: loop {
        match pc {
            0x832B3A38 => {
    //   block [0x832B3A38..0x832B3A8C)
	// 832B3A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3A3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3A40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3A44: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3A48: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3A4C: 3BEBFAC0  addi r31, r11, -0x540
	ctx.r[31].s64 = ctx.r[11].s64 + -1344;
	// 832B3A50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3A54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3A58: 419A0008  beq cr6, 0x832b3a60
	if ctx.cr[6].eq {
	pc = 0x832B3A60; continue 'dispatch;
	}
	// 832B3A5C: 4AF682DD  bl 0x8221bd38
	ctx.lr = 0x832B3A60;
	sub_8221BD38(ctx, base);
	// 832B3A60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3A64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3A68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3A6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3A70: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3A74: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3A78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3A7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3A80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3A84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3A88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3A90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3A90 size=84
    let mut pc: u32 = 0x832B3A90;
    'dispatch: loop {
        match pc {
            0x832B3A90 => {
    //   block [0x832B3A90..0x832B3AE4)
	// 832B3A90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3A94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3A98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3A9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3AA0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3AA4: 3BEBFAD0  addi r31, r11, -0x530
	ctx.r[31].s64 = ctx.r[11].s64 + -1328;
	// 832B3AA8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3AB0: 419A0008  beq cr6, 0x832b3ab8
	if ctx.cr[6].eq {
	pc = 0x832B3AB8; continue 'dispatch;
	}
	// 832B3AB4: 4AF68285  bl 0x8221bd38
	ctx.lr = 0x832B3AB8;
	sub_8221BD38(ctx, base);
	// 832B3AB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3ABC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3AC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3AC4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3AC8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3ACC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3AD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3AD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3AD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3ADC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3AE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3AE8 size=84
    let mut pc: u32 = 0x832B3AE8;
    'dispatch: loop {
        match pc {
            0x832B3AE8 => {
    //   block [0x832B3AE8..0x832B3B3C)
	// 832B3AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3AEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3AF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3AF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3AF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3AFC: 3BEBFAE0  addi r31, r11, -0x520
	ctx.r[31].s64 = ctx.r[11].s64 + -1312;
	// 832B3B00: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3B04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3B08: 419A0008  beq cr6, 0x832b3b10
	if ctx.cr[6].eq {
	pc = 0x832B3B10; continue 'dispatch;
	}
	// 832B3B0C: 4AF6822D  bl 0x8221bd38
	ctx.lr = 0x832B3B10;
	sub_8221BD38(ctx, base);
	// 832B3B10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3B14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3B18: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3B1C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3B20: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3B24: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3B28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3B34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3B40 size=84
    let mut pc: u32 = 0x832B3B40;
    'dispatch: loop {
        match pc {
            0x832B3B40 => {
    //   block [0x832B3B40..0x832B3B94)
	// 832B3B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3B44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3B48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3B4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3B50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3B54: 3BEBFAF0  addi r31, r11, -0x510
	ctx.r[31].s64 = ctx.r[11].s64 + -1296;
	// 832B3B58: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3B5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3B60: 419A0008  beq cr6, 0x832b3b68
	if ctx.cr[6].eq {
	pc = 0x832B3B68; continue 'dispatch;
	}
	// 832B3B64: 4AF681D5  bl 0x8221bd38
	ctx.lr = 0x832B3B68;
	sub_8221BD38(ctx, base);
	// 832B3B68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3B6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3B70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3B74: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3B78: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3B7C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3B80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3B84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3B88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3B8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3B90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3B98 size=84
    let mut pc: u32 = 0x832B3B98;
    'dispatch: loop {
        match pc {
            0x832B3B98 => {
    //   block [0x832B3B98..0x832B3BEC)
	// 832B3B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3B9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3BA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3BA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3BA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3BAC: 3BEBFB04  addi r31, r11, -0x4fc
	ctx.r[31].s64 = ctx.r[11].s64 + -1276;
	// 832B3BB0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3BB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3BB8: 419A0008  beq cr6, 0x832b3bc0
	if ctx.cr[6].eq {
	pc = 0x832B3BC0; continue 'dispatch;
	}
	// 832B3BBC: 4AF6817D  bl 0x8221bd38
	ctx.lr = 0x832B3BC0;
	sub_8221BD38(ctx, base);
	// 832B3BC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3BC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3BC8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3BCC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3BD0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3BD4: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3BD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3BF0 size=84
    let mut pc: u32 = 0x832B3BF0;
    'dispatch: loop {
        match pc {
            0x832B3BF0 => {
    //   block [0x832B3BF0..0x832B3C44)
	// 832B3BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3BF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3BF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3BFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3C00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3C04: 3BEBFB14  addi r31, r11, -0x4ec
	ctx.r[31].s64 = ctx.r[11].s64 + -1260;
	// 832B3C08: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3C0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3C10: 419A0008  beq cr6, 0x832b3c18
	if ctx.cr[6].eq {
	pc = 0x832B3C18; continue 'dispatch;
	}
	// 832B3C14: 4AF68125  bl 0x8221bd38
	ctx.lr = 0x832B3C18;
	sub_8221BD38(ctx, base);
	// 832B3C18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3C1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3C20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3C24: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3C28: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3C2C: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3C30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3C34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3C38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3C3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3C48 size=12
    let mut pc: u32 = 0x832B3C48;
    'dispatch: loop {
        match pc {
            0x832B3C48 => {
    //   block [0x832B3C48..0x832B3C54)
	// 832B3C48: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3C4C: 386BFB24  addi r3, r11, -0x4dc
	ctx.r[3].s64 = ctx.r[11].s64 + -1244;
	// 832B3C50: 4AF61188  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3C58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3C58 size=12
    let mut pc: u32 = 0x832B3C58;
    'dispatch: loop {
        match pc {
            0x832B3C58 => {
    //   block [0x832B3C58..0x832B3C64)
	// 832B3C58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3C5C: 386BFB28  addi r3, r11, -0x4d8
	ctx.r[3].s64 = ctx.r[11].s64 + -1240;
	// 832B3C60: 4AF61178  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3C68 size=12
    let mut pc: u32 = 0x832B3C68;
    'dispatch: loop {
        match pc {
            0x832B3C68 => {
    //   block [0x832B3C68..0x832B3C74)
	// 832B3C68: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3C6C: 386BFB2C  addi r3, r11, -0x4d4
	ctx.r[3].s64 = ctx.r[11].s64 + -1236;
	// 832B3C70: 4AF61168  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3C78 size=84
    let mut pc: u32 = 0x832B3C78;
    'dispatch: loop {
        match pc {
            0x832B3C78 => {
    //   block [0x832B3C78..0x832B3CCC)
	// 832B3C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3C84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3C88: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3C8C: 3BEBFB30  addi r31, r11, -0x4d0
	ctx.r[31].s64 = ctx.r[11].s64 + -1232;
	// 832B3C90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3C94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3C98: 419A0008  beq cr6, 0x832b3ca0
	if ctx.cr[6].eq {
	pc = 0x832B3CA0; continue 'dispatch;
	}
	// 832B3C9C: 4AF6809D  bl 0x8221bd38
	ctx.lr = 0x832B3CA0;
	sub_8221BD38(ctx, base);
	// 832B3CA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3CA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3CA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B3CAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3CB0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3CB4: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 832B3CB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3CC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3CD0 size=12
    let mut pc: u32 = 0x832B3CD0;
    'dispatch: loop {
        match pc {
            0x832B3CD0 => {
    //   block [0x832B3CD0..0x832B3CDC)
	// 832B3CD0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3CD4: 386BFB40  addi r3, r11, -0x4c0
	ctx.r[3].s64 = ctx.r[11].s64 + -1216;
	// 832B3CD8: 4AF61100  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3CE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3CE0 size=12
    let mut pc: u32 = 0x832B3CE0;
    'dispatch: loop {
        match pc {
            0x832B3CE0 => {
    //   block [0x832B3CE0..0x832B3CEC)
	// 832B3CE0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3CE4: 386BFB44  addi r3, r11, -0x4bc
	ctx.r[3].s64 = ctx.r[11].s64 + -1212;
	// 832B3CE8: 4AF610F0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3CF0 size=12
    let mut pc: u32 = 0x832B3CF0;
    'dispatch: loop {
        match pc {
            0x832B3CF0 => {
    //   block [0x832B3CF0..0x832B3CFC)
	// 832B3CF0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3CF4: 386BFB48  addi r3, r11, -0x4b8
	ctx.r[3].s64 = ctx.r[11].s64 + -1208;
	// 832B3CF8: 4B7AA2A0  b 0x82a5df98
	sub_82A5DF98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3D00 size=120
    let mut pc: u32 = 0x832B3D00;
    'dispatch: loop {
        match pc {
            0x832B3D00 => {
    //   block [0x832B3D00..0x832B3D78)
	// 832B3D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3D04: 4B9F5709  bl 0x82ca940c
	ctx.lr = 0x832B3D08;
	sub_82CA93D0(ctx, base);
	// 832B3D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3D0C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3D10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B3D14: 3BEBFB54  addi r31, r11, -0x4ac
	ctx.r[31].s64 = ctx.r[11].s64 + -1196;
	// 832B3D18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3D1C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3D20: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832B3D24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3D28: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3D2C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3D30: 7F1E1840  cmplw cr6, r30, r3
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B3D34: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B3D38: 419A002C  beq cr6, 0x832b3d64
	if ctx.cr[6].eq {
	pc = 0x832B3D64; continue 'dispatch;
	}
	// 832B3D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3D40: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B3D44: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 832B3D48: 4B2B2139  bl 0x82565e80
	ctx.lr = 0x832B3D4C;
	sub_82565E80(ctx, base);
	// 832B3D4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B3D50: 4AF67FE9  bl 0x8221bd38
	ctx.lr = 0x832B3D54;
	sub_8221BD38(ctx, base);
	// 832B3D54: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3D58: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 832B3D5C: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 832B3D60: 409AFFDC  bne cr6, 0x832b3d3c
	if !ctx.cr[6].eq {
	pc = 0x832B3D3C; continue 'dispatch;
	}
	// 832B3D64: 4AF67FD5  bl 0x8221bd38
	ctx.lr = 0x832B3D68;
	sub_8221BD38(ctx, base);
	// 832B3D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3D6C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3D74: 4B9F56E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3D78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3D78 size=12
    let mut pc: u32 = 0x832B3D78;
    'dispatch: loop {
        match pc {
            0x832B3D78 => {
    //   block [0x832B3D78..0x832B3D84)
	// 832B3D78: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3D7C: 386BFB60  addi r3, r11, -0x4a0
	ctx.r[3].s64 = ctx.r[11].s64 + -1184;
	// 832B3D80: 4B7AA6B8  b 0x82a5e438
	sub_82A5E438(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3D88 size=12
    let mut pc: u32 = 0x832B3D88;
    'dispatch: loop {
        match pc {
            0x832B3D88 => {
    //   block [0x832B3D88..0x832B3D94)
	// 832B3D88: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3D8C: 386BFB70  addi r3, r11, -0x490
	ctx.r[3].s64 = ctx.r[11].s64 + -1168;
	// 832B3D90: 4AF61048  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3D98 size=12
    let mut pc: u32 = 0x832B3D98;
    'dispatch: loop {
        match pc {
            0x832B3D98 => {
    //   block [0x832B3D98..0x832B3DA4)
	// 832B3D98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3D9C: 386BFB74  addi r3, r11, -0x48c
	ctx.r[3].s64 = ctx.r[11].s64 + -1164;
	// 832B3DA0: 4AF61038  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3DA8 size=12
    let mut pc: u32 = 0x832B3DA8;
    'dispatch: loop {
        match pc {
            0x832B3DA8 => {
    //   block [0x832B3DA8..0x832B3DB4)
	// 832B3DA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3DAC: 386BFB78  addi r3, r11, -0x488
	ctx.r[3].s64 = ctx.r[11].s64 + -1160;
	// 832B3DB0: 4AF61028  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3DB8 size=12
    let mut pc: u32 = 0x832B3DB8;
    'dispatch: loop {
        match pc {
            0x832B3DB8 => {
    //   block [0x832B3DB8..0x832B3DC4)
	// 832B3DB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3DBC: 386BFB7C  addi r3, r11, -0x484
	ctx.r[3].s64 = ctx.r[11].s64 + -1156;
	// 832B3DC0: 4AF61018  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3DC8 size=16
    let mut pc: u32 = 0x832B3DC8;
    'dispatch: loop {
        match pc {
            0x832B3DC8 => {
    //   block [0x832B3DC8..0x832B3DD8)
	// 832B3DC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3DCC: 806BFB80  lwz r3, -0x480(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1152 as u32) ) } as u64;
	// 832B3DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3DD4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3DD8 size=8
    let mut pc: u32 = 0x832B3DD8;
    'dispatch: loop {
        match pc {
            0x832B3DD8 => {
    //   block [0x832B3DD8..0x832B3DE0)
	// 832B3DD8: 4AF48548  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B3DDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3DE0 size=12
    let mut pc: u32 = 0x832B3DE0;
    'dispatch: loop {
        match pc {
            0x832B3DE0 => {
    //   block [0x832B3DE0..0x832B3DEC)
	// 832B3DE0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3DE4: 386BFB94  addi r3, r11, -0x46c
	ctx.r[3].s64 = ctx.r[11].s64 + -1132;
	// 832B3DE8: 4AF60FF0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3DF0 size=12
    let mut pc: u32 = 0x832B3DF0;
    'dispatch: loop {
        match pc {
            0x832B3DF0 => {
    //   block [0x832B3DF0..0x832B3DFC)
	// 832B3DF0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3DF4: 386BFB98  addi r3, r11, -0x468
	ctx.r[3].s64 = ctx.r[11].s64 + -1128;
	// 832B3DF8: 4AF60FE0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3E00 size=68
    let mut pc: u32 = 0x832B3E00;
    'dispatch: loop {
        match pc {
            0x832B3E00 => {
    //   block [0x832B3E00..0x832B3E44)
	// 832B3E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3E04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3E08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3E0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3E10: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3E14: 3BEBFB9C  addi r31, r11, -0x464
	ctx.r[31].s64 = ctx.r[11].s64 + -1124;
	// 832B3E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3E1C: 4B7AFD95  bl 0x82a63bb0
	ctx.lr = 0x832B3E20;
	sub_82A63BB0(ctx, base);
	// 832B3E20: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B3E24: 4AF67F15  bl 0x8221bd38
	ctx.lr = 0x832B3E28;
	sub_8221BD38(ctx, base);
	// 832B3E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3E2C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B3E30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3E3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3E40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3E48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3E48 size=80
    let mut pc: u32 = 0x832B3E48;
    'dispatch: loop {
        match pc {
            0x832B3E48 => {
    //   block [0x832B3E48..0x832B3E98)
	// 832B3E48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3E4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3E50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B3E54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3E58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3E5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3E60: 3BC00031  li r30, 0x31
	ctx.r[30].s64 = 49;
	// 832B3E64: 396BFBD0  addi r11, r11, -0x430
	ctx.r[11].s64 = ctx.r[11].s64 + -1072;
	// 832B3E68: 3BEB12C0  addi r31, r11, 0x12c0
	ctx.r[31].s64 = ctx.r[11].s64 + 4800;
	// 832B3E6C: 3BFFFFA0  addi r31, r31, -0x60
	ctx.r[31].s64 = ctx.r[31].s64 + -96;
	// 832B3E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3E74: 4B7AE645  bl 0x82a624b8
	ctx.lr = 0x832B3E78;
	sub_82A624B8(ctx, base);
	// 832B3E78: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B3E7C: 4080FFF0  bge 0x832b3e6c
	if !ctx.cr[0].lt {
	pc = 0x832B3E6C; continue 'dispatch;
	}
	// 832B3E80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B3E84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3E88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3E8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B3E90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3E98 size=64
    let mut pc: u32 = 0x832B3E98;
    'dispatch: loop {
        match pc {
            0x832B3E98 => {
    //   block [0x832B3E98..0x832B3ED8)
	// 832B3E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3EA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3EA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3EA8: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B3EAC: 807F0E90  lwz r3, 0xe90(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(3728 as u32) ) } as u64;
	// 832B3EB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3EB4: 419A0010  beq cr6, 0x832b3ec4
	if ctx.cr[6].eq {
	pc = 0x832B3EC4; continue 'dispatch;
	}
	// 832B3EB8: 4B8D3711  bl 0x82b875c8
	ctx.lr = 0x832B3EBC;
	sub_82B875C8(ctx, base);
	// 832B3EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3EC0: 917F0E90  stw r11, 0xe90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(3728 as u32), ctx.r[11].u32 ) };
	// 832B3EC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3ED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3ED4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3ED8 size=64
    let mut pc: u32 = 0x832B3ED8;
    'dispatch: loop {
        match pc {
            0x832B3ED8 => {
    //   block [0x832B3ED8..0x832B3F18)
	// 832B3ED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3EDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B3EE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B3EE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3EE8: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B3EEC: 807FAB0C  lwz r3, -0x54f4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-21748 as u32) ) } as u64;
	// 832B3EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3EF4: 419A0010  beq cr6, 0x832b3f04
	if ctx.cr[6].eq {
	pc = 0x832B3F04; continue 'dispatch;
	}
	// 832B3EF8: 4B8D36D1  bl 0x82b875c8
	ctx.lr = 0x832B3EFC;
	sub_82B875C8(ctx, base);
	// 832B3EFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B3F00: 917FAB0C  stw r11, -0x54f4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21748 as u32), ctx.r[11].u32 ) };
	// 832B3F04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B3F08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B3F0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B3F10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B3F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3F18 size=16
    let mut pc: u32 = 0x832B3F18;
    'dispatch: loop {
        match pc {
            0x832B3F18 => {
    //   block [0x832B3F18..0x832B3F28)
	// 832B3F18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3F1C: 806BFBA8  lwz r3, -0x458(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1112 as u32) ) } as u64;
	// 832B3F20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3F24: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3F28 size=8
    let mut pc: u32 = 0x832B3F28;
    'dispatch: loop {
        match pc {
            0x832B3F28 => {
    //   block [0x832B3F28..0x832B3F30)
	// 832B3F28: 4AF483F8  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B3F2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3F30 size=16
    let mut pc: u32 = 0x832B3F30;
    'dispatch: loop {
        match pc {
            0x832B3F30 => {
    //   block [0x832B3F30..0x832B3F40)
	// 832B3F30: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3F34: 806BFBBC  lwz r3, -0x444(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1092 as u32) ) } as u64;
	// 832B3F38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B3F3C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3F40 size=8
    let mut pc: u32 = 0x832B3F40;
    'dispatch: loop {
        match pc {
            0x832B3F40 => {
    //   block [0x832B3F40..0x832B3F48)
	// 832B3F40: 4AF483E0  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B3F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3F48 size=12
    let mut pc: u32 = 0x832B3F48;
    'dispatch: loop {
        match pc {
            0x832B3F48 => {
    //   block [0x832B3F48..0x832B3F54)
	// 832B3F48: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3F4C: 386B0E9C  addi r3, r11, 0xe9c
	ctx.r[3].s64 = ctx.r[11].s64 + 3740;
	// 832B3F50: 4AF60E88  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B3F58 size=12
    let mut pc: u32 = 0x832B3F58;
    'dispatch: loop {
        match pc {
            0x832B3F58 => {
    //   block [0x832B3F58..0x832B3F64)
	// 832B3F58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3F5C: 386B0EA0  addi r3, r11, 0xea0
	ctx.r[3].s64 = ctx.r[11].s64 + 3744;
	// 832B3F60: 4AF60E78  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3F68 size=88
    let mut pc: u32 = 0x832B3F68;
    'dispatch: loop {
        match pc {
            0x832B3F68 => {
    //   block [0x832B3F68..0x832B3FC0)
	// 832B3F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3F6C: 4B9F549D  bl 0x82ca9408
	ctx.lr = 0x832B3F70;
	sub_82CA93D0(ctx, base);
	// 832B3F70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3F74: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3F78: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 832B3F7C: 396B0EA4  addi r11, r11, 0xea4
	ctx.r[11].s64 = ctx.r[11].s64 + 3748;
	// 832B3F80: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 832B3F84: 3BEB0018  addi r31, r11, 0x18
	ctx.r[31].s64 = ctx.r[11].s64 + 24;
	// 832B3F88: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B3F8C: 3BAA2A40  addi r29, r10, 0x2a40
	ctx.r[29].s64 = ctx.r[10].s64 + 10816;
	// 832B3F90: 3B8B2A30  addi r28, r11, 0x2a30
	ctx.r[28].s64 = ctx.r[11].s64 + 10800;
	// 832B3F94: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 832B3F98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3F9C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832B3FA0: 4AF48069  bl 0x821fc008
	ctx.lr = 0x832B3FA4;
	sub_821FC008(ctx, base);
	// 832B3FA4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832B3FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3FAC: 4AF4805D  bl 0x821fc008
	ctx.lr = 0x832B3FB0;
	sub_821FC008(ctx, base);
	// 832B3FB0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B3FB4: 4080FFE0  bge 0x832b3f94
	if !ctx.cr[0].lt {
	pc = 0x832B3F94; continue 'dispatch;
	}
	// 832B3FB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B3FBC: 4B9F549C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B3FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B3FC0 size=88
    let mut pc: u32 = 0x832B3FC0;
    'dispatch: loop {
        match pc {
            0x832B3FC0 => {
    //   block [0x832B3FC0..0x832B4018)
	// 832B3FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B3FC4: 4B9F5445  bl 0x82ca9408
	ctx.lr = 0x832B3FC8;
	sub_82CA93D0(ctx, base);
	// 832B3FC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B3FCC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B3FD0: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 832B3FD4: 396B0F60  addi r11, r11, 0xf60
	ctx.r[11].s64 = ctx.r[11].s64 + 3936;
	// 832B3FD8: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 832B3FDC: 3BEB0018  addi r31, r11, 0x18
	ctx.r[31].s64 = ctx.r[11].s64 + 24;
	// 832B3FE0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B3FE4: 3BAA2A40  addi r29, r10, 0x2a40
	ctx.r[29].s64 = ctx.r[10].s64 + 10816;
	// 832B3FE8: 3B8B2A30  addi r28, r11, 0x2a30
	ctx.r[28].s64 = ctx.r[11].s64 + 10800;
	// 832B3FEC: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 832B3FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B3FF4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 832B3FF8: 4AF48011  bl 0x821fc008
	ctx.lr = 0x832B3FFC;
	sub_821FC008(ctx, base);
	// 832B3FFC: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832B4000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B4004: 4AF48005  bl 0x821fc008
	ctx.lr = 0x832B4008;
	sub_821FC008(ctx, base);
	// 832B4008: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B400C: 4080FFE0  bge 0x832b3fec
	if !ctx.cr[0].lt {
	pc = 0x832B3FEC; continue 'dispatch;
	}
	// 832B4010: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 832B4014: 4B9F5444  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4018 size=12
    let mut pc: u32 = 0x832B4018;
    'dispatch: loop {
        match pc {
            0x832B4018 => {
    //   block [0x832B4018..0x832B4024)
	// 832B4018: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B401C: 386B0F78  addi r3, r11, 0xf78
	ctx.r[3].s64 = ctx.r[11].s64 + 3960;
	// 832B4020: 4AF60DB8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4028 size=12
    let mut pc: u32 = 0x832B4028;
    'dispatch: loop {
        match pc {
            0x832B4028 => {
    //   block [0x832B4028..0x832B4034)
	// 832B4028: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B402C: 386B0F7C  addi r3, r11, 0xf7c
	ctx.r[3].s64 = ctx.r[11].s64 + 3964;
	// 832B4030: 4AF60DA8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4038 size=12
    let mut pc: u32 = 0x832B4038;
    'dispatch: loop {
        match pc {
            0x832B4038 => {
    //   block [0x832B4038..0x832B4044)
	// 832B4038: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B403C: 386B0F80  addi r3, r11, 0xf80
	ctx.r[3].s64 = ctx.r[11].s64 + 3968;
	// 832B4040: 4AF60D98  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4048 size=12
    let mut pc: u32 = 0x832B4048;
    'dispatch: loop {
        match pc {
            0x832B4048 => {
    //   block [0x832B4048..0x832B4054)
	// 832B4048: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B404C: 386B0F84  addi r3, r11, 0xf84
	ctx.r[3].s64 = ctx.r[11].s64 + 3972;
	// 832B4050: 4AF60D88  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4058 size=12
    let mut pc: u32 = 0x832B4058;
    'dispatch: loop {
        match pc {
            0x832B4058 => {
    //   block [0x832B4058..0x832B4064)
	// 832B4058: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B405C: 386B0F88  addi r3, r11, 0xf88
	ctx.r[3].s64 = ctx.r[11].s64 + 3976;
	// 832B4060: 4AF60D78  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4068 size=12
    let mut pc: u32 = 0x832B4068;
    'dispatch: loop {
        match pc {
            0x832B4068 => {
    //   block [0x832B4068..0x832B4074)
	// 832B4068: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B406C: 386B0F8C  addi r3, r11, 0xf8c
	ctx.r[3].s64 = ctx.r[11].s64 + 3980;
	// 832B4070: 4AF60D68  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4078 size=12
    let mut pc: u32 = 0x832B4078;
    'dispatch: loop {
        match pc {
            0x832B4078 => {
    //   block [0x832B4078..0x832B4084)
	// 832B4078: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B407C: 386B0F90  addi r3, r11, 0xf90
	ctx.r[3].s64 = ctx.r[11].s64 + 3984;
	// 832B4080: 4AF60D58  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4088 size=12
    let mut pc: u32 = 0x832B4088;
    'dispatch: loop {
        match pc {
            0x832B4088 => {
    //   block [0x832B4088..0x832B4094)
	// 832B4088: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B408C: 386B0F94  addi r3, r11, 0xf94
	ctx.r[3].s64 = ctx.r[11].s64 + 3988;
	// 832B4090: 4AF60D48  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4098(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4098 size=12
    let mut pc: u32 = 0x832B4098;
    'dispatch: loop {
        match pc {
            0x832B4098 => {
    //   block [0x832B4098..0x832B40A4)
	// 832B4098: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B409C: 386B0F98  addi r3, r11, 0xf98
	ctx.r[3].s64 = ctx.r[11].s64 + 3992;
	// 832B40A0: 4AF60D38  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B40A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B40A8 size=12
    let mut pc: u32 = 0x832B40A8;
    'dispatch: loop {
        match pc {
            0x832B40A8 => {
    //   block [0x832B40A8..0x832B40B4)
	// 832B40A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B40AC: 386B0F9C  addi r3, r11, 0xf9c
	ctx.r[3].s64 = ctx.r[11].s64 + 3996;
	// 832B40B0: 4AF60D28  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B40B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B40B8 size=12
    let mut pc: u32 = 0x832B40B8;
    'dispatch: loop {
        match pc {
            0x832B40B8 => {
    //   block [0x832B40B8..0x832B40C4)
	// 832B40B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B40BC: 386B0FA0  addi r3, r11, 0xfa0
	ctx.r[3].s64 = ctx.r[11].s64 + 4000;
	// 832B40C0: 4AF60D18  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B40C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B40C8 size=12
    let mut pc: u32 = 0x832B40C8;
    'dispatch: loop {
        match pc {
            0x832B40C8 => {
    //   block [0x832B40C8..0x832B40D4)
	// 832B40C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B40CC: 386B0FA4  addi r3, r11, 0xfa4
	ctx.r[3].s64 = ctx.r[11].s64 + 4004;
	// 832B40D0: 4AF60D08  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B40D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B40D8 size=12
    let mut pc: u32 = 0x832B40D8;
    'dispatch: loop {
        match pc {
            0x832B40D8 => {
    //   block [0x832B40D8..0x832B40E4)
	// 832B40D8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B40DC: 386BAB2C  addi r3, r11, -0x54d4
	ctx.r[3].s64 = ctx.r[11].s64 + -21716;
	// 832B40E0: 4AF47EB0  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B40E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B40E8 size=88
    let mut pc: u32 = 0x832B40E8;
    'dispatch: loop {
        match pc {
            0x832B40E8 => {
    //   block [0x832B40E8..0x832B4140)
	// 832B40E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B40EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B40F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B40F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B40F8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B40FC: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 832B4100: 3BEBAB50  addi r31, r11, -0x54b0
	ctx.r[31].s64 = ctx.r[11].s64 + -21680;
	// 832B4104: 396A2A2C  addi r11, r10, 0x2a2c
	ctx.r[11].s64 = ctx.r[10].s64 + 10796;
	// 832B4108: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B410C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 832B4110: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4114: 419A0018  beq cr6, 0x832b412c
	if ctx.cr[6].eq {
	pc = 0x832B412C; continue 'dispatch;
	}
	// 832B4118: 4AF48209  bl 0x821fc320
	ctx.lr = 0x832B411C;
	sub_821FC320(ctx, base);
	// 832B411C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4120: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B4124: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B4128: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 832B412C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4130: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4134: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4138: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B413C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4140 size=68
    let mut pc: u32 = 0x832B4140;
    'dispatch: loop {
        match pc {
            0x832B4140 => {
    //   block [0x832B4140..0x832B4184)
	// 832B4140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4144: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4148: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B414C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4150: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4154: 3BEB0FF0  addi r31, r11, 0xff0
	ctx.r[31].s64 = ctx.r[11].s64 + 4080;
	// 832B4158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 832B415C: 4AEC8D1D  bl 0x8217ce78
	ctx.lr = 0x832B4160;
	sub_8217CE78(ctx, base);
	// 832B4160: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4164: 4AF67BD5  bl 0x8221bd38
	ctx.lr = 0x832B4168;
	sub_8221BD38(ctx, base);
	// 832B4168: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B416C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 832B4170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B417C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4188 size=12
    let mut pc: u32 = 0x832B4188;
    'dispatch: loop {
        match pc {
            0x832B4188 => {
    //   block [0x832B4188..0x832B4194)
	// 832B4188: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B418C: 386B0FFC  addi r3, r11, 0xffc
	ctx.r[3].s64 = ctx.r[11].s64 + 4092;
	// 832B4190: 4AFE9908  b 0x8229da98
	sub_8229DA98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4198 size=12
    let mut pc: u32 = 0x832B4198;
    'dispatch: loop {
        match pc {
            0x832B4198 => {
    //   block [0x832B4198..0x832B41A4)
	// 832B4198: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B419C: 386B1048  addi r3, r11, 0x1048
	ctx.r[3].s64 = ctx.r[11].s64 + 4168;
	// 832B41A0: 4AFE98F8  b 0x8229da98
	sub_8229DA98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B41A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B41A8 size=12
    let mut pc: u32 = 0x832B41A8;
    'dispatch: loop {
        match pc {
            0x832B41A8 => {
    //   block [0x832B41A8..0x832B41B4)
	// 832B41A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B41AC: 386B1094  addi r3, r11, 0x1094
	ctx.r[3].s64 = ctx.r[11].s64 + 4244;
	// 832B41B0: 4AF60C28  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B41B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B41B8 size=12
    let mut pc: u32 = 0x832B41B8;
    'dispatch: loop {
        match pc {
            0x832B41B8 => {
    //   block [0x832B41B8..0x832B41C4)
	// 832B41B8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B41BC: 386B1098  addi r3, r11, 0x1098
	ctx.r[3].s64 = ctx.r[11].s64 + 4248;
	// 832B41C0: 4AF60C18  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B41C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B41C8 size=12
    let mut pc: u32 = 0x832B41C8;
    'dispatch: loop {
        match pc {
            0x832B41C8 => {
    //   block [0x832B41C8..0x832B41D4)
	// 832B41C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B41CC: 386B109C  addi r3, r11, 0x109c
	ctx.r[3].s64 = ctx.r[11].s64 + 4252;
	// 832B41D0: 4AF60C08  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B41D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B41D8 size=12
    let mut pc: u32 = 0x832B41D8;
    'dispatch: loop {
        match pc {
            0x832B41D8 => {
    //   block [0x832B41D8..0x832B41E4)
	// 832B41D8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B41DC: 386B10A0  addi r3, r11, 0x10a0
	ctx.r[3].s64 = ctx.r[11].s64 + 4256;
	// 832B41E0: 4AF60BF8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B41E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B41E8 size=12
    let mut pc: u32 = 0x832B41E8;
    'dispatch: loop {
        match pc {
            0x832B41E8 => {
    //   block [0x832B41E8..0x832B41F4)
	// 832B41E8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B41EC: 386B10A4  addi r3, r11, 0x10a4
	ctx.r[3].s64 = ctx.r[11].s64 + 4260;
	// 832B41F0: 4AF60BE8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B41F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B41F8 size=12
    let mut pc: u32 = 0x832B41F8;
    'dispatch: loop {
        match pc {
            0x832B41F8 => {
    //   block [0x832B41F8..0x832B4204)
	// 832B41F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B41FC: 386B10A8  addi r3, r11, 0x10a8
	ctx.r[3].s64 = ctx.r[11].s64 + 4264;
	// 832B4200: 4AF60BD8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4208 size=16
    let mut pc: u32 = 0x832B4208;
    'dispatch: loop {
        match pc {
            0x832B4208 => {
    //   block [0x832B4208..0x832B4218)
	// 832B4208: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B420C: 806B10AC  lwz r3, 0x10ac(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4268 as u32) ) } as u64;
	// 832B4210: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4214: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4218 size=8
    let mut pc: u32 = 0x832B4218;
    'dispatch: loop {
        match pc {
            0x832B4218 => {
    //   block [0x832B4218..0x832B4220)
	// 832B4218: 4AF48108  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B421C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4220 size=16
    let mut pc: u32 = 0x832B4220;
    'dispatch: loop {
        match pc {
            0x832B4220 => {
    //   block [0x832B4220..0x832B4230)
	// 832B4220: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4224: 806B10C0  lwz r3, 0x10c0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4288 as u32) ) } as u64;
	// 832B4228: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B422C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4230 size=8
    let mut pc: u32 = 0x832B4230;
    'dispatch: loop {
        match pc {
            0x832B4230 => {
    //   block [0x832B4230..0x832B4238)
	// 832B4230: 4AF480F0  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B4234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4238 size=16
    let mut pc: u32 = 0x832B4238;
    'dispatch: loop {
        match pc {
            0x832B4238 => {
    //   block [0x832B4238..0x832B4248)
	// 832B4238: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B423C: 806B10D4  lwz r3, 0x10d4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4308 as u32) ) } as u64;
	// 832B4240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4244: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4248 size=8
    let mut pc: u32 = 0x832B4248;
    'dispatch: loop {
        match pc {
            0x832B4248 => {
    //   block [0x832B4248..0x832B4250)
	// 832B4248: 4AF480D8  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B424C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4250 size=12
    let mut pc: u32 = 0x832B4250;
    'dispatch: loop {
        match pc {
            0x832B4250 => {
    //   block [0x832B4250..0x832B425C)
	// 832B4250: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4254: 386B10E8  addi r3, r11, 0x10e8
	ctx.r[3].s64 = ctx.r[11].s64 + 4328;
	// 832B4258: 4AF60B80  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4260 size=12
    let mut pc: u32 = 0x832B4260;
    'dispatch: loop {
        match pc {
            0x832B4260 => {
    //   block [0x832B4260..0x832B426C)
	// 832B4260: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4264: 386B10EC  addi r3, r11, 0x10ec
	ctx.r[3].s64 = ctx.r[11].s64 + 4332;
	// 832B4268: 4AF60B70  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4270 size=88
    let mut pc: u32 = 0x832B4270;
    'dispatch: loop {
        match pc {
            0x832B4270 => {
    //   block [0x832B4270..0x832B42C8)
	// 832B4270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4278: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B427C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4280: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4284: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4288: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 832B428C: 396B10F0  addi r11, r11, 0x10f0
	ctx.r[11].s64 = ctx.r[11].s64 + 4336;
	// 832B4290: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 832B4294: 3BFFFFEC  addi r31, r31, -0x14
	ctx.r[31].s64 = ctx.r[31].s64 + -20;
	// 832B4298: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B429C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B42A0: 419A0008  beq cr6, 0x832b42a8
	if ctx.cr[6].eq {
	pc = 0x832B42A8; continue 'dispatch;
	}
	// 832B42A4: 4AF4807D  bl 0x821fc320
	ctx.lr = 0x832B42A8;
	sub_821FC320(ctx, base);
	// 832B42A8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B42AC: 4080FFE8  bge 0x832b4294
	if !ctx.cr[0].lt {
	pc = 0x832B4294; continue 'dispatch;
	}
	// 832B42B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B42B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B42B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B42BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B42C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B42C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B42C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B42C8 size=16
    let mut pc: u32 = 0x832B42C8;
    'dispatch: loop {
        match pc {
            0x832B42C8 => {
    //   block [0x832B42C8..0x832B42D8)
	// 832B42C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B42CC: 806B1140  lwz r3, 0x1140(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4416 as u32) ) } as u64;
	// 832B42D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B42D4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B42D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B42D8 size=8
    let mut pc: u32 = 0x832B42D8;
    'dispatch: loop {
        match pc {
            0x832B42D8 => {
    //   block [0x832B42D8..0x832B42E0)
	// 832B42D8: 4AF48048  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B42DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B42E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B42E0 size=16
    let mut pc: u32 = 0x832B42E0;
    'dispatch: loop {
        match pc {
            0x832B42E0 => {
    //   block [0x832B42E0..0x832B42F0)
	// 832B42E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B42E4: 806B1154  lwz r3, 0x1154(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4436 as u32) ) } as u64;
	// 832B42E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B42EC: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B42F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B42F0 size=8
    let mut pc: u32 = 0x832B42F0;
    'dispatch: loop {
        match pc {
            0x832B42F0 => {
    //   block [0x832B42F0..0x832B42F8)
	// 832B42F0: 4AF48030  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B42F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B42F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B42F8 size=12
    let mut pc: u32 = 0x832B42F8;
    'dispatch: loop {
        match pc {
            0x832B42F8 => {
    //   block [0x832B42F8..0x832B4304)
	// 832B42F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B42FC: 386B1190  addi r3, r11, 0x1190
	ctx.r[3].s64 = ctx.r[11].s64 + 4496;
	// 832B4300: 4AF60AD8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4308 size=12
    let mut pc: u32 = 0x832B4308;
    'dispatch: loop {
        match pc {
            0x832B4308 => {
    //   block [0x832B4308..0x832B4314)
	// 832B4308: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B430C: 386B1194  addi r3, r11, 0x1194
	ctx.r[3].s64 = ctx.r[11].s64 + 4500;
	// 832B4310: 4AF60AC8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4318 size=88
    let mut pc: u32 = 0x832B4318;
    'dispatch: loop {
        match pc {
            0x832B4318 => {
    //   block [0x832B4318..0x832B4370)
	// 832B4318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B431C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4320: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B4324: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B432C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4330: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 832B4334: 396B1198  addi r11, r11, 0x1198
	ctx.r[11].s64 = ctx.r[11].s64 + 4504;
	// 832B4338: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 832B433C: 3BFFFFEC  addi r31, r31, -0x14
	ctx.r[31].s64 = ctx.r[31].s64 + -20;
	// 832B4340: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B4344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4348: 419A0008  beq cr6, 0x832b4350
	if ctx.cr[6].eq {
	pc = 0x832B4350; continue 'dispatch;
	}
	// 832B434C: 4AF47FD5  bl 0x821fc320
	ctx.lr = 0x832B4350;
	sub_821FC320(ctx, base);
	// 832B4350: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B4354: 4080FFE8  bge 0x832b433c
	if !ctx.cr[0].lt {
	pc = 0x832B433C; continue 'dispatch;
	}
	// 832B4358: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B435C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4364: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B4368: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B436C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4370 size=16
    let mut pc: u32 = 0x832B4370;
    'dispatch: loop {
        match pc {
            0x832B4370 => {
    //   block [0x832B4370..0x832B4380)
	// 832B4370: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4374: 806B11E8  lwz r3, 0x11e8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4584 as u32) ) } as u64;
	// 832B4378: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B437C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4380 size=8
    let mut pc: u32 = 0x832B4380;
    'dispatch: loop {
        match pc {
            0x832B4380 => {
    //   block [0x832B4380..0x832B4388)
	// 832B4380: 4AF47FA0  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B4384: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4388 size=12
    let mut pc: u32 = 0x832B4388;
    'dispatch: loop {
        match pc {
            0x832B4388 => {
    //   block [0x832B4388..0x832B4394)
	// 832B4388: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B438C: 386B11FC  addi r3, r11, 0x11fc
	ctx.r[3].s64 = ctx.r[11].s64 + 4604;
	// 832B4390: 4AF60A48  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4398 size=12
    let mut pc: u32 = 0x832B4398;
    'dispatch: loop {
        match pc {
            0x832B4398 => {
    //   block [0x832B4398..0x832B43A4)
	// 832B4398: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B439C: 386B1200  addi r3, r11, 0x1200
	ctx.r[3].s64 = ctx.r[11].s64 + 4608;
	// 832B43A0: 4AF60A38  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B43A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B43A8 size=16
    let mut pc: u32 = 0x832B43A8;
    'dispatch: loop {
        match pc {
            0x832B43A8 => {
    //   block [0x832B43A8..0x832B43B8)
	// 832B43A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B43AC: 806B1204  lwz r3, 0x1204(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4612 as u32) ) } as u64;
	// 832B43B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B43B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B43B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B43B8 size=8
    let mut pc: u32 = 0x832B43B8;
    'dispatch: loop {
        match pc {
            0x832B43B8 => {
    //   block [0x832B43B8..0x832B43C0)
	// 832B43B8: 4AF47F68  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B43BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B43C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B43C0 size=12
    let mut pc: u32 = 0x832B43C0;
    'dispatch: loop {
        match pc {
            0x832B43C0 => {
    //   block [0x832B43C0..0x832B43CC)
	// 832B43C0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B43C4: 386B1280  addi r3, r11, 0x1280
	ctx.r[3].s64 = ctx.r[11].s64 + 4736;
	// 832B43C8: 4AF60A10  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B43D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B43D0 size=12
    let mut pc: u32 = 0x832B43D0;
    'dispatch: loop {
        match pc {
            0x832B43D0 => {
    //   block [0x832B43D0..0x832B43DC)
	// 832B43D0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B43D4: 386B1284  addi r3, r11, 0x1284
	ctx.r[3].s64 = ctx.r[11].s64 + 4740;
	// 832B43D8: 4AF60A00  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B43E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B43E0 size=12
    let mut pc: u32 = 0x832B43E0;
    'dispatch: loop {
        match pc {
            0x832B43E0 => {
    //   block [0x832B43E0..0x832B43EC)
	// 832B43E0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B43E4: 386B12A0  addi r3, r11, 0x12a0
	ctx.r[3].s64 = ctx.r[11].s64 + 4768;
	// 832B43E8: 4AF609F0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B43F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B43F0 size=12
    let mut pc: u32 = 0x832B43F0;
    'dispatch: loop {
        match pc {
            0x832B43F0 => {
    //   block [0x832B43F0..0x832B43FC)
	// 832B43F0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B43F4: 386B12A4  addi r3, r11, 0x12a4
	ctx.r[3].s64 = ctx.r[11].s64 + 4772;
	// 832B43F8: 4AF609E0  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4400 size=124
    let mut pc: u32 = 0x832B4400;
    'dispatch: loop {
        match pc {
            0x832B4400 => {
    //   block [0x832B4400..0x832B447C)
	// 832B4400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B440C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4410: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 832B4414: 3BEB2300  addi r31, r11, 0x2300
	ctx.r[31].s64 = ctx.r[11].s64 + 8960;
	// 832B4418: 807F0068  lwz r3, 0x68(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 832B441C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4420: 419A0008  beq cr6, 0x832b4428
	if ctx.cr[6].eq {
	pc = 0x832B4428; continue 'dispatch;
	}
	// 832B4424: 4AF67915  bl 0x8221bd38
	ctx.lr = 0x832B4428;
	sub_8221BD38(ctx, base);
	// 832B4428: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 832B442C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4430: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B4434: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B4438: 917F0068  stw r11, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 832B443C: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 832B4440: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4444: 913F0070  stw r9, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 832B4448: 419A0008  beq cr6, 0x832b4450
	if ctx.cr[6].eq {
	pc = 0x832B4450; continue 'dispatch;
	}
	// 832B444C: 4AF678ED  bl 0x8221bd38
	ctx.lr = 0x832B4450;
	sub_8221BD38(ctx, base);
	// 832B4450: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4454: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 832B4458: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 832B445C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 832B4460: 915F005C  stw r10, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 832B4464: 913F0060  stw r9, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 832B4468: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B446C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4470: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4474: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4478: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4480 size=12
    let mut pc: u32 = 0x832B4480;
    'dispatch: loop {
        match pc {
            0x832B4480 => {
    //   block [0x832B4480..0x832B448C)
	// 832B4480: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4484: 386B12A8  addi r3, r11, 0x12a8
	ctx.r[3].s64 = ctx.r[11].s64 + 4776;
	// 832B4488: 4AF60950  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4490 size=12
    let mut pc: u32 = 0x832B4490;
    'dispatch: loop {
        match pc {
            0x832B4490 => {
    //   block [0x832B4490..0x832B449C)
	// 832B4490: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4494: 386B12AC  addi r3, r11, 0x12ac
	ctx.r[3].s64 = ctx.r[11].s64 + 4780;
	// 832B4498: 4AF60940  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B44A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B44A0 size=88
    let mut pc: u32 = 0x832B44A0;
    'dispatch: loop {
        match pc {
            0x832B44A0 => {
    //   block [0x832B44A0..0x832B44F8)
	// 832B44A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B44A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B44A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B44AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B44B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B44B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B44B8: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 832B44BC: 396B12B0  addi r11, r11, 0x12b0
	ctx.r[11].s64 = ctx.r[11].s64 + 4784;
	// 832B44C0: 3BEB0050  addi r31, r11, 0x50
	ctx.r[31].s64 = ctx.r[11].s64 + 80;
	// 832B44C4: 3BFFFFEC  addi r31, r31, -0x14
	ctx.r[31].s64 = ctx.r[31].s64 + -20;
	// 832B44C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B44CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B44D0: 419A0008  beq cr6, 0x832b44d8
	if ctx.cr[6].eq {
	pc = 0x832B44D8; continue 'dispatch;
	}
	// 832B44D4: 4AF47E4D  bl 0x821fc320
	ctx.lr = 0x832B44D8;
	sub_821FC320(ctx, base);
	// 832B44D8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 832B44DC: 4080FFE8  bge 0x832b44c4
	if !ctx.cr[0].lt {
	pc = 0x832B44C4; continue 'dispatch;
	}
	// 832B44E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B44E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B44E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B44EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B44F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B44F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B44F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B44F8 size=12
    let mut pc: u32 = 0x832B44F8;
    'dispatch: loop {
        match pc {
            0x832B44F8 => {
    //   block [0x832B44F8..0x832B4504)
	// 832B44F8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B44FC: 386B1328  addi r3, r11, 0x1328
	ctx.r[3].s64 = ctx.r[11].s64 + 4904;
	// 832B4500: 4AF608D8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4508 size=12
    let mut pc: u32 = 0x832B4508;
    'dispatch: loop {
        match pc {
            0x832B4508 => {
    //   block [0x832B4508..0x832B4514)
	// 832B4508: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B450C: 386B132C  addi r3, r11, 0x132c
	ctx.r[3].s64 = ctx.r[11].s64 + 4908;
	// 832B4510: 4AF608C8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4518 size=12
    let mut pc: u32 = 0x832B4518;
    'dispatch: loop {
        match pc {
            0x832B4518 => {
    //   block [0x832B4518..0x832B4524)
	// 832B4518: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B451C: 386B4330  addi r3, r11, 0x4330
	ctx.r[3].s64 = ctx.r[11].s64 + 17200;
	// 832B4520: 4AF608B8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4528 size=12
    let mut pc: u32 = 0x832B4528;
    'dispatch: loop {
        match pc {
            0x832B4528 => {
    //   block [0x832B4528..0x832B4534)
	// 832B4528: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B452C: 386B4334  addi r3, r11, 0x4334
	ctx.r[3].s64 = ctx.r[11].s64 + 17204;
	// 832B4530: 4AF608A8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4538 size=12
    let mut pc: u32 = 0x832B4538;
    'dispatch: loop {
        match pc {
            0x832B4538 => {
    //   block [0x832B4538..0x832B4544)
	// 832B4538: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B453C: 386B4338  addi r3, r11, 0x4338
	ctx.r[3].s64 = ctx.r[11].s64 + 17208;
	// 832B4540: 4AF60898  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4548 size=12
    let mut pc: u32 = 0x832B4548;
    'dispatch: loop {
        match pc {
            0x832B4548 => {
    //   block [0x832B4548..0x832B4554)
	// 832B4548: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B454C: 386B433C  addi r3, r11, 0x433c
	ctx.r[3].s64 = ctx.r[11].s64 + 17212;
	// 832B4550: 4AF60888  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4558 size=116
    let mut pc: u32 = 0x832B4558;
    'dispatch: loop {
        match pc {
            0x832B4558 => {
    //   block [0x832B4558..0x832B45CC)
	// 832B4558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B455C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4568: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B456C: 807F4340  lwz r3, 0x4340(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17216 as u32) ) } as u64;
	// 832B4570: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4574: 419A0044  beq cr6, 0x832b45b8
	if ctx.cr[6].eq {
	pc = 0x832B45B8; continue 'dispatch;
	}
	// 832B4578: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B457C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B4580: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4584: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4588: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B458C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4590: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4594: 4082FFE8  bne 0x832b457c
	if !ctx.cr[0].eq {
	pc = 0x832B457C; continue 'dispatch;
	}
	// 832B4598: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B459C: 409A0014  bne cr6, 0x832b45b0
	if !ctx.cr[6].eq {
	pc = 0x832B45B0; continue 'dispatch;
	}
	// 832B45A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B45A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B45A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B45AC: 4E800421  bctrl
	ctx.lr = 0x832B45B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B45B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B45B4: 917F4340  stw r11, 0x4340(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17216 as u32), ctx.r[11].u32 ) };
	// 832B45B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B45BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B45C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B45C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B45C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B45D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B45D0 size=116
    let mut pc: u32 = 0x832B45D0;
    'dispatch: loop {
        match pc {
            0x832B45D0 => {
    //   block [0x832B45D0..0x832B4644)
	// 832B45D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B45D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B45D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B45DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B45E0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B45E4: 807F4344  lwz r3, 0x4344(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17220 as u32) ) } as u64;
	// 832B45E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B45EC: 419A0044  beq cr6, 0x832b4630
	if ctx.cr[6].eq {
	pc = 0x832B4630; continue 'dispatch;
	}
	// 832B45F0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B45F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B45F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B45FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4600: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B4604: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4608: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B460C: 4082FFE8  bne 0x832b45f4
	if !ctx.cr[0].eq {
	pc = 0x832B45F4; continue 'dispatch;
	}
	// 832B4610: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B4614: 409A0014  bne cr6, 0x832b4628
	if !ctx.cr[6].eq {
	pc = 0x832B4628; continue 'dispatch;
	}
	// 832B4618: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B461C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4620: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B4624: 4E800421  bctrl
	ctx.lr = 0x832B4628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4628: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B462C: 917F4344  stw r11, 0x4344(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17220 as u32), ctx.r[11].u32 ) };
	// 832B4630: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B463C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4640: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4648 size=116
    let mut pc: u32 = 0x832B4648;
    'dispatch: loop {
        match pc {
            0x832B4648 => {
    //   block [0x832B4648..0x832B46BC)
	// 832B4648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B464C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4658: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B465C: 807F4348  lwz r3, 0x4348(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17224 as u32) ) } as u64;
	// 832B4660: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4664: 419A0044  beq cr6, 0x832b46a8
	if ctx.cr[6].eq {
	pc = 0x832B46A8; continue 'dispatch;
	}
	// 832B4668: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B466C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B4670: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4674: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4678: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B467C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4680: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4684: 4082FFE8  bne 0x832b466c
	if !ctx.cr[0].eq {
	pc = 0x832B466C; continue 'dispatch;
	}
	// 832B4688: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B468C: 409A0014  bne cr6, 0x832b46a0
	if !ctx.cr[6].eq {
	pc = 0x832B46A0; continue 'dispatch;
	}
	// 832B4690: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B4694: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4698: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B469C: 4E800421  bctrl
	ctx.lr = 0x832B46A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B46A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B46A4: 917F4348  stw r11, 0x4348(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17224 as u32), ctx.r[11].u32 ) };
	// 832B46A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B46AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B46B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B46B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B46B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B46C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B46C0 size=116
    let mut pc: u32 = 0x832B46C0;
    'dispatch: loop {
        match pc {
            0x832B46C0 => {
    //   block [0x832B46C0..0x832B4734)
	// 832B46C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B46C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B46C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B46CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B46D0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B46D4: 807F434C  lwz r3, 0x434c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17228 as u32) ) } as u64;
	// 832B46D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B46DC: 419A0044  beq cr6, 0x832b4720
	if ctx.cr[6].eq {
	pc = 0x832B4720; continue 'dispatch;
	}
	// 832B46E0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B46E4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B46E8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B46EC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B46F0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B46F4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B46F8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B46FC: 4082FFE8  bne 0x832b46e4
	if !ctx.cr[0].eq {
	pc = 0x832B46E4; continue 'dispatch;
	}
	// 832B4700: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B4704: 409A0014  bne cr6, 0x832b4718
	if !ctx.cr[6].eq {
	pc = 0x832B4718; continue 'dispatch;
	}
	// 832B4708: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B470C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4710: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B4714: 4E800421  bctrl
	ctx.lr = 0x832B4718;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4718: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B471C: 917F434C  stw r11, 0x434c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17228 as u32), ctx.r[11].u32 ) };
	// 832B4720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B472C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4738 size=116
    let mut pc: u32 = 0x832B4738;
    'dispatch: loop {
        match pc {
            0x832B4738 => {
    //   block [0x832B4738..0x832B47AC)
	// 832B4738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B473C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4740: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4744: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4748: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B474C: 807F4350  lwz r3, 0x4350(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17232 as u32) ) } as u64;
	// 832B4750: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4754: 419A0044  beq cr6, 0x832b4798
	if ctx.cr[6].eq {
	pc = 0x832B4798; continue 'dispatch;
	}
	// 832B4758: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B475C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B4760: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4764: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4768: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B476C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4770: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4774: 4082FFE8  bne 0x832b475c
	if !ctx.cr[0].eq {
	pc = 0x832B475C; continue 'dispatch;
	}
	// 832B4778: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B477C: 409A0014  bne cr6, 0x832b4790
	if !ctx.cr[6].eq {
	pc = 0x832B4790; continue 'dispatch;
	}
	// 832B4780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B4784: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4788: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B478C: 4E800421  bctrl
	ctx.lr = 0x832B4790;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4790: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4794: 917F4350  stw r11, 0x4350(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17232 as u32), ctx.r[11].u32 ) };
	// 832B4798: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B479C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B47A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B47A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B47A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B47B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B47B0 size=116
    let mut pc: u32 = 0x832B47B0;
    'dispatch: loop {
        match pc {
            0x832B47B0 => {
    //   block [0x832B47B0..0x832B4824)
	// 832B47B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B47B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B47B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B47BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B47C0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B47C4: 807F4354  lwz r3, 0x4354(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17236 as u32) ) } as u64;
	// 832B47C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B47CC: 419A0044  beq cr6, 0x832b4810
	if ctx.cr[6].eq {
	pc = 0x832B4810; continue 'dispatch;
	}
	// 832B47D0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B47D4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B47D8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B47DC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B47E0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B47E4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B47E8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B47EC: 4082FFE8  bne 0x832b47d4
	if !ctx.cr[0].eq {
	pc = 0x832B47D4; continue 'dispatch;
	}
	// 832B47F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B47F4: 409A0014  bne cr6, 0x832b4808
	if !ctx.cr[6].eq {
	pc = 0x832B4808; continue 'dispatch;
	}
	// 832B47F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B47FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4800: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B4804: 4E800421  bctrl
	ctx.lr = 0x832B4808;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B480C: 917F4354  stw r11, 0x4354(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17236 as u32), ctx.r[11].u32 ) };
	// 832B4810: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4814: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4818: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B481C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4828 size=116
    let mut pc: u32 = 0x832B4828;
    'dispatch: loop {
        match pc {
            0x832B4828 => {
    //   block [0x832B4828..0x832B489C)
	// 832B4828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B482C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4838: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B483C: 807F4358  lwz r3, 0x4358(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17240 as u32) ) } as u64;
	// 832B4840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4844: 419A0044  beq cr6, 0x832b4888
	if ctx.cr[6].eq {
	pc = 0x832B4888; continue 'dispatch;
	}
	// 832B4848: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B484C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B4850: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4854: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4858: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B485C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4860: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4864: 4082FFE8  bne 0x832b484c
	if !ctx.cr[0].eq {
	pc = 0x832B484C; continue 'dispatch;
	}
	// 832B4868: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B486C: 409A0014  bne cr6, 0x832b4880
	if !ctx.cr[6].eq {
	pc = 0x832B4880; continue 'dispatch;
	}
	// 832B4870: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B4874: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4878: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B487C: 4E800421  bctrl
	ctx.lr = 0x832B4880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4880: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4884: 917F4358  stw r11, 0x4358(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17240 as u32), ctx.r[11].u32 ) };
	// 832B4888: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B488C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B48A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B48A0 size=116
    let mut pc: u32 = 0x832B48A0;
    'dispatch: loop {
        match pc {
            0x832B48A0 => {
    //   block [0x832B48A0..0x832B4914)
	// 832B48A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B48A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B48A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B48AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B48B0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B48B4: 807F435C  lwz r3, 0x435c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17244 as u32) ) } as u64;
	// 832B48B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B48BC: 419A0044  beq cr6, 0x832b4900
	if ctx.cr[6].eq {
	pc = 0x832B4900; continue 'dispatch;
	}
	// 832B48C0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B48C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B48C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B48CC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B48D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B48D4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B48D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B48DC: 4082FFE8  bne 0x832b48c4
	if !ctx.cr[0].eq {
	pc = 0x832B48C4; continue 'dispatch;
	}
	// 832B48E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B48E4: 409A0014  bne cr6, 0x832b48f8
	if !ctx.cr[6].eq {
	pc = 0x832B48F8; continue 'dispatch;
	}
	// 832B48E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B48EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B48F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B48F4: 4E800421  bctrl
	ctx.lr = 0x832B48F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B48F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B48FC: 917F435C  stw r11, 0x435c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17244 as u32), ctx.r[11].u32 ) };
	// 832B4900: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B490C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4910: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4918 size=116
    let mut pc: u32 = 0x832B4918;
    'dispatch: loop {
        match pc {
            0x832B4918 => {
    //   block [0x832B4918..0x832B498C)
	// 832B4918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B491C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4920: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4924: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4928: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B492C: 807F4360  lwz r3, 0x4360(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17248 as u32) ) } as u64;
	// 832B4930: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4934: 419A0044  beq cr6, 0x832b4978
	if ctx.cr[6].eq {
	pc = 0x832B4978; continue 'dispatch;
	}
	// 832B4938: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B493C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B4940: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4944: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4948: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B494C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4950: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4954: 4082FFE8  bne 0x832b493c
	if !ctx.cr[0].eq {
	pc = 0x832B493C; continue 'dispatch;
	}
	// 832B4958: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B495C: 409A0014  bne cr6, 0x832b4970
	if !ctx.cr[6].eq {
	pc = 0x832B4970; continue 'dispatch;
	}
	// 832B4960: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B4964: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4968: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B496C: 4E800421  bctrl
	ctx.lr = 0x832B4970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4970: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4974: 917F4360  stw r11, 0x4360(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17248 as u32), ctx.r[11].u32 ) };
	// 832B4978: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B497C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4980: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4984: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4988: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4990 size=12
    let mut pc: u32 = 0x832B4990;
    'dispatch: loop {
        match pc {
            0x832B4990 => {
    //   block [0x832B4990..0x832B499C)
	// 832B4990: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B4994: 386BAB78  addi r3, r11, -0x5488
	ctx.r[3].s64 = ctx.r[11].s64 + -21640;
	// 832B4998: 4B936CA0  b 0x82beb638
	sub_82BEB638(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B49A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B49A0 size=116
    let mut pc: u32 = 0x832B49A0;
    'dispatch: loop {
        match pc {
            0x832B49A0 => {
    //   block [0x832B49A0..0x832B4A14)
	// 832B49A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B49A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B49A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B49AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B49B0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B49B4: 807F4364  lwz r3, 0x4364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17252 as u32) ) } as u64;
	// 832B49B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B49BC: 419A0044  beq cr6, 0x832b4a00
	if ctx.cr[6].eq {
	pc = 0x832B4A00; continue 'dispatch;
	}
	// 832B49C0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B49C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B49C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B49CC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B49D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B49D4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B49D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B49DC: 4082FFE8  bne 0x832b49c4
	if !ctx.cr[0].eq {
	pc = 0x832B49C4; continue 'dispatch;
	}
	// 832B49E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B49E4: 409A0014  bne cr6, 0x832b49f8
	if !ctx.cr[6].eq {
	pc = 0x832B49F8; continue 'dispatch;
	}
	// 832B49E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B49EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B49F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B49F4: 4E800421  bctrl
	ctx.lr = 0x832B49F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B49F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B49FC: 917F4364  stw r11, 0x4364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17252 as u32), ctx.r[11].u32 ) };
	// 832B4A00: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4A18 size=12
    let mut pc: u32 = 0x832B4A18;
    'dispatch: loop {
        match pc {
            0x832B4A18 => {
    //   block [0x832B4A18..0x832B4A24)
	// 832B4A18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4A1C: 386B4380  addi r3, r11, 0x4380
	ctx.r[3].s64 = ctx.r[11].s64 + 17280;
	// 832B4A20: 4AF603B8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4A28 size=12
    let mut pc: u32 = 0x832B4A28;
    'dispatch: loop {
        match pc {
            0x832B4A28 => {
    //   block [0x832B4A28..0x832B4A34)
	// 832B4A28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4A2C: 386B4384  addi r3, r11, 0x4384
	ctx.r[3].s64 = ctx.r[11].s64 + 17284;
	// 832B4A30: 4AF603A8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4A38 size=12
    let mut pc: u32 = 0x832B4A38;
    'dispatch: loop {
        match pc {
            0x832B4A38 => {
    //   block [0x832B4A38..0x832B4A44)
	// 832B4A38: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B4A3C: 386BAB8C  addi r3, r11, -0x5474
	ctx.r[3].s64 = ctx.r[11].s64 + -21620;
	// 832B4A40: 4AF47550  b 0x821fbf90
	sub_821FBF90(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4A48 size=92
    let mut pc: u32 = 0x832B4A48;
    'dispatch: loop {
        match pc {
            0x832B4A48 => {
    //   block [0x832B4A48..0x832B4AA4)
	// 832B4A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B4A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4A5C: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B4A60: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4A64: 3BDFABB8  addi r30, r31, -0x5448
	ctx.r[30].s64 = ctx.r[31].s64 + -21576;
	// 832B4A68: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B4A6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4A70: 917FABB8  stw r11, -0x5448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21576 as u32), ctx.r[11].u32 ) };
	// 832B4A74: 4AF47595  bl 0x821fc008
	ctx.lr = 0x832B4A78;
	sub_821FC008(ctx, base);
	// 832B4A78: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4A7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4A80: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B4A84: 917FABB8  stw r11, -0x5448(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21576 as u32), ctx.r[11].u32 ) };
	// 832B4A88: 4AF47581  bl 0x821fc008
	ctx.lr = 0x832B4A8C;
	sub_821FC008(ctx, base);
	// 832B4A8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B4A90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4A94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4A98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B4A9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4AA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4AA8 size=92
    let mut pc: u32 = 0x832B4AA8;
    'dispatch: loop {
        match pc {
            0x832B4AA8 => {
    //   block [0x832B4AA8..0x832B4B04)
	// 832B4AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4AB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B4AB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4AB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4ABC: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B4AC0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4AC4: 3BDFABC0  addi r30, r31, -0x5440
	ctx.r[30].s64 = ctx.r[31].s64 + -21568;
	// 832B4AC8: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B4ACC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4AD0: 917FABC0  stw r11, -0x5440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21568 as u32), ctx.r[11].u32 ) };
	// 832B4AD4: 4AF47535  bl 0x821fc008
	ctx.lr = 0x832B4AD8;
	sub_821FC008(ctx, base);
	// 832B4AD8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4ADC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4AE0: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B4AE4: 917FABC0  stw r11, -0x5440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21568 as u32), ctx.r[11].u32 ) };
	// 832B4AE8: 4AF47521  bl 0x821fc008
	ctx.lr = 0x832B4AEC;
	sub_821FC008(ctx, base);
	// 832B4AEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B4AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4AF8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B4AFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4B00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B08 size=12
    let mut pc: u32 = 0x832B4B08;
    'dispatch: loop {
        match pc {
            0x832B4B08 => {
    //   block [0x832B4B08..0x832B4B14)
	// 832B4B08: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B0C: 386B4390  addi r3, r11, 0x4390
	ctx.r[3].s64 = ctx.r[11].s64 + 17296;
	// 832B4B10: 4AF602C8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B18 size=12
    let mut pc: u32 = 0x832B4B18;
    'dispatch: loop {
        match pc {
            0x832B4B18 => {
    //   block [0x832B4B18..0x832B4B24)
	// 832B4B18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B1C: 386B4394  addi r3, r11, 0x4394
	ctx.r[3].s64 = ctx.r[11].s64 + 17300;
	// 832B4B20: 4AF602B8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B28 size=12
    let mut pc: u32 = 0x832B4B28;
    'dispatch: loop {
        match pc {
            0x832B4B28 => {
    //   block [0x832B4B28..0x832B4B34)
	// 832B4B28: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 832B4B2C: 386B3530  addi r3, r11, 0x3530
	ctx.r[3].s64 = ctx.r[11].s64 + 13616;
	// 832B4B30: 4AF602A8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B38 size=12
    let mut pc: u32 = 0x832B4B38;
    'dispatch: loop {
        match pc {
            0x832B4B38 => {
    //   block [0x832B4B38..0x832B4B44)
	// 832B4B38: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B3C: 386B4398  addi r3, r11, 0x4398
	ctx.r[3].s64 = ctx.r[11].s64 + 17304;
	// 832B4B40: 4AF60298  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B48 size=12
    let mut pc: u32 = 0x832B4B48;
    'dispatch: loop {
        match pc {
            0x832B4B48 => {
    //   block [0x832B4B48..0x832B4B54)
	// 832B4B48: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B4C: 386B439C  addi r3, r11, 0x439c
	ctx.r[3].s64 = ctx.r[11].s64 + 17308;
	// 832B4B50: 4AF60288  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B58 size=12
    let mut pc: u32 = 0x832B4B58;
    'dispatch: loop {
        match pc {
            0x832B4B58 => {
    //   block [0x832B4B58..0x832B4B64)
	// 832B4B58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B5C: 386B43A0  addi r3, r11, 0x43a0
	ctx.r[3].s64 = ctx.r[11].s64 + 17312;
	// 832B4B60: 4AF60278  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B68 size=12
    let mut pc: u32 = 0x832B4B68;
    'dispatch: loop {
        match pc {
            0x832B4B68 => {
    //   block [0x832B4B68..0x832B4B74)
	// 832B4B68: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B6C: 386B43A4  addi r3, r11, 0x43a4
	ctx.r[3].s64 = ctx.r[11].s64 + 17316;
	// 832B4B70: 4AF60268  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B78 size=12
    let mut pc: u32 = 0x832B4B78;
    'dispatch: loop {
        match pc {
            0x832B4B78 => {
    //   block [0x832B4B78..0x832B4B84)
	// 832B4B78: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B7C: 386B43A8  addi r3, r11, 0x43a8
	ctx.r[3].s64 = ctx.r[11].s64 + 17320;
	// 832B4B80: 4AF60258  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B88 size=12
    let mut pc: u32 = 0x832B4B88;
    'dispatch: loop {
        match pc {
            0x832B4B88 => {
    //   block [0x832B4B88..0x832B4B94)
	// 832B4B88: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B8C: 386B43AC  addi r3, r11, 0x43ac
	ctx.r[3].s64 = ctx.r[11].s64 + 17324;
	// 832B4B90: 4AF60248  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4B98 size=12
    let mut pc: u32 = 0x832B4B98;
    'dispatch: loop {
        match pc {
            0x832B4B98 => {
    //   block [0x832B4B98..0x832B4BA4)
	// 832B4B98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4B9C: 386B43B0  addi r3, r11, 0x43b0
	ctx.r[3].s64 = ctx.r[11].s64 + 17328;
	// 832B4BA0: 4AF60238  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4BA8 size=12
    let mut pc: u32 = 0x832B4BA8;
    'dispatch: loop {
        match pc {
            0x832B4BA8 => {
    //   block [0x832B4BA8..0x832B4BB4)
	// 832B4BA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4BAC: 386B43B4  addi r3, r11, 0x43b4
	ctx.r[3].s64 = ctx.r[11].s64 + 17332;
	// 832B4BB0: 4AF60228  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4BB8 size=12
    let mut pc: u32 = 0x832B4BB8;
    'dispatch: loop {
        match pc {
            0x832B4BB8 => {
    //   block [0x832B4BB8..0x832B4BC4)
	// 832B4BB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4BBC: 386B43B8  addi r3, r11, 0x43b8
	ctx.r[3].s64 = ctx.r[11].s64 + 17336;
	// 832B4BC0: 4AF60218  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4BC8 size=12
    let mut pc: u32 = 0x832B4BC8;
    'dispatch: loop {
        match pc {
            0x832B4BC8 => {
    //   block [0x832B4BC8..0x832B4BD4)
	// 832B4BC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4BCC: 386B43BC  addi r3, r11, 0x43bc
	ctx.r[3].s64 = ctx.r[11].s64 + 17340;
	// 832B4BD0: 4AF60208  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4BD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4BD8 size=12
    let mut pc: u32 = 0x832B4BD8;
    'dispatch: loop {
        match pc {
            0x832B4BD8 => {
    //   block [0x832B4BD8..0x832B4BE4)
	// 832B4BD8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4BDC: 386B43C0  addi r3, r11, 0x43c0
	ctx.r[3].s64 = ctx.r[11].s64 + 17344;
	// 832B4BE0: 4AF601F8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4BE8 size=12
    let mut pc: u32 = 0x832B4BE8;
    'dispatch: loop {
        match pc {
            0x832B4BE8 => {
    //   block [0x832B4BE8..0x832B4BF4)
	// 832B4BE8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4BEC: 386B43C4  addi r3, r11, 0x43c4
	ctx.r[3].s64 = ctx.r[11].s64 + 17348;
	// 832B4BF0: 4AF601E8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4BF8 size=12
    let mut pc: u32 = 0x832B4BF8;
    'dispatch: loop {
        match pc {
            0x832B4BF8 => {
    //   block [0x832B4BF8..0x832B4C04)
	// 832B4BF8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4BFC: 386B43C8  addi r3, r11, 0x43c8
	ctx.r[3].s64 = ctx.r[11].s64 + 17352;
	// 832B4C00: 4AF601D8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C08 size=12
    let mut pc: u32 = 0x832B4C08;
    'dispatch: loop {
        match pc {
            0x832B4C08 => {
    //   block [0x832B4C08..0x832B4C14)
	// 832B4C08: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C0C: 386B43CC  addi r3, r11, 0x43cc
	ctx.r[3].s64 = ctx.r[11].s64 + 17356;
	// 832B4C10: 4AF601C8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C18 size=12
    let mut pc: u32 = 0x832B4C18;
    'dispatch: loop {
        match pc {
            0x832B4C18 => {
    //   block [0x832B4C18..0x832B4C24)
	// 832B4C18: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C1C: 386B43D0  addi r3, r11, 0x43d0
	ctx.r[3].s64 = ctx.r[11].s64 + 17360;
	// 832B4C20: 4AF601B8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C28 size=12
    let mut pc: u32 = 0x832B4C28;
    'dispatch: loop {
        match pc {
            0x832B4C28 => {
    //   block [0x832B4C28..0x832B4C34)
	// 832B4C28: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C2C: 386B43D4  addi r3, r11, 0x43d4
	ctx.r[3].s64 = ctx.r[11].s64 + 17364;
	// 832B4C30: 4AF601A8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C38 size=16
    let mut pc: u32 = 0x832B4C38;
    'dispatch: loop {
        match pc {
            0x832B4C38 => {
    //   block [0x832B4C38..0x832B4C48)
	// 832B4C38: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C3C: 806B43D8  lwz r3, 0x43d8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17368 as u32) ) } as u64;
	// 832B4C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4C44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C48 size=8
    let mut pc: u32 = 0x832B4C48;
    'dispatch: loop {
        match pc {
            0x832B4C48 => {
    //   block [0x832B4C48..0x832B4C50)
	// 832B4C48: 4AF476D8  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B4C4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C50 size=12
    let mut pc: u32 = 0x832B4C50;
    'dispatch: loop {
        match pc {
            0x832B4C50 => {
    //   block [0x832B4C50..0x832B4C5C)
	// 832B4C50: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C54: 386B43EC  addi r3, r11, 0x43ec
	ctx.r[3].s64 = ctx.r[11].s64 + 17388;
	// 832B4C58: 4AF60180  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4C60 size=12
    let mut pc: u32 = 0x832B4C60;
    'dispatch: loop {
        match pc {
            0x832B4C60 => {
    //   block [0x832B4C60..0x832B4C6C)
	// 832B4C60: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C64: 386B43F0  addi r3, r11, 0x43f0
	ctx.r[3].s64 = ctx.r[11].s64 + 17392;
	// 832B4C68: 4AF60170  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4C70 size=176
    let mut pc: u32 = 0x832B4C70;
    'dispatch: loop {
        match pc {
            0x832B4C70 => {
    //   block [0x832B4C70..0x832B4D20)
	// 832B4C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4C74: 4B9F4785  bl 0x82ca93f8
	ctx.lr = 0x832B4C78;
	sub_82CA93D0(ctx, base);
	// 832B4C78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4C7C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4C80: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 832B4C84: 396B4440  addi r11, r11, 0x4440
	ctx.r[11].s64 = ctx.r[11].s64 + 17472;
	// 832B4C88: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 832B4C8C: 3BCB08A0  addi r30, r11, 0x8a0
	ctx.r[30].s64 = ctx.r[11].s64 + 2208;
	// 832B4C90: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 832B4C94: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 832B4C98: 3B800016  li r28, 0x16
	ctx.r[28].s64 = 22;
	// 832B4C9C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 832B4CA0: 3B682A40  addi r27, r8, 0x2a40
	ctx.r[27].s64 = ctx.r[8].s64 + 10816;
	// 832B4CA4: 3B492A30  addi r26, r9, 0x2a30
	ctx.r[26].s64 = ctx.r[9].s64 + 10800;
	// 832B4CA8: 3B2A2A2C  addi r25, r10, 0x2a2c
	ctx.r[25].s64 = ctx.r[10].s64 + 10796;
	// 832B4CAC: 3BABB00C  addi r29, r11, -0x4ff4
	ctx.r[29].s64 = ctx.r[11].s64 + -20468;
	// 832B4CB0: 3BDEFFA0  addi r30, r30, -0x60
	ctx.r[30].s64 = ctx.r[30].s64 + -96;
	// 832B4CB4: 37FE0010  addic. r31, r30, 0x10
	ctx.xer.ca = (ctx.r[30].u32 > (!(16 as u32)));
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 832B4CB8: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 832B4CBC: 40820008  bne 0x832b4cc4
	if !ctx.cr[0].eq {
	pc = 0x832B4CC4; continue 'dispatch;
	}
	// 832B4CC0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 832B4CC4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832B4CC8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4CCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4CD0: 933F0000  stw r25, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 832B4CD4: 419A0010  beq cr6, 0x832b4ce4
	if ctx.cr[6].eq {
	pc = 0x832B4CE4; continue 'dispatch;
	}
	// 832B4CD8: 4AF47649  bl 0x821fc320
	ctx.lr = 0x832B4CDC;
	sub_821FC320(ctx, base);
	// 832B4CDC: 931F0004  stw r24, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 832B4CE0: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 832B4CE4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 832B4CE8: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 832B4CEC: 409A0008  bne cr6, 0x832b4cf4
	if !ctx.cr[6].eq {
	pc = 0x832B4CF4; continue 'dispatch;
	}
	// 832B4CF0: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 832B4CF4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 832B4CF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4CFC: 935E0000  stw r26, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 832B4D00: 4AF47309  bl 0x821fc008
	ctx.lr = 0x832B4D04;
	sub_821FC008(ctx, base);
	// 832B4D04: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 832B4D08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4D0C: 4AF472FD  bl 0x821fc008
	ctx.lr = 0x832B4D10;
	sub_821FC008(ctx, base);
	// 832B4D10: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 832B4D14: 4080FF9C  bge 0x832b4cb0
	if !ctx.cr[0].lt {
	pc = 0x832B4CB0; continue 'dispatch;
	}
	// 832B4D18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 832B4D1C: 4B9F472C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4D20 size=12
    let mut pc: u32 = 0x832B4D20;
    'dispatch: loop {
        match pc {
            0x832B4D20 => {
    //   block [0x832B4D20..0x832B4D2C)
	// 832B4D20: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4D24: 386B43F4  addi r3, r11, 0x43f4
	ctx.r[3].s64 = ctx.r[11].s64 + 17396;
	// 832B4D28: 4AFE8D70  b 0x8229da98
	sub_8229DA98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4D30 size=116
    let mut pc: u32 = 0x832B4D30;
    'dispatch: loop {
        match pc {
            0x832B4D30 => {
    //   block [0x832B4D30..0x832B4DA4)
	// 832B4D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4D38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4D3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4D40: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 832B4D44: 807F4CE0  lwz r3, 0x4ce0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(19680 as u32) ) } as u64;
	// 832B4D48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4D4C: 419A0044  beq cr6, 0x832b4d90
	if ctx.cr[6].eq {
	pc = 0x832B4D90; continue 'dispatch;
	}
	// 832B4D50: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 832B4D54: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 832B4D58: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4D5C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 832B4D60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 832B4D64: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 832B4D68: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 832B4D6C: 4082FFE8  bne 0x832b4d54
	if !ctx.cr[0].eq {
	pc = 0x832B4D54; continue 'dispatch;
	}
	// 832B4D70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 832B4D74: 409A0014  bne cr6, 0x832b4d88
	if !ctx.cr[6].eq {
	pc = 0x832B4D88; continue 'dispatch;
	}
	// 832B4D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 832B4D7C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 832B4D80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 832B4D84: 4E800421  bctrl
	ctx.lr = 0x832B4D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 832B4D88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 832B4D8C: 917F4CE0  stw r11, 0x4ce0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(19680 as u32), ctx.r[11].u32 ) };
	// 832B4D90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 832B4D94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4D98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4D9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4DA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4DA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4DA8 size=12
    let mut pc: u32 = 0x832B4DA8;
    'dispatch: loop {
        match pc {
            0x832B4DA8 => {
    //   block [0x832B4DA8..0x832B4DB4)
	// 832B4DA8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 832B4DAC: 386BABE8  addi r3, r11, -0x5418
	ctx.r[3].s64 = ctx.r[11].s64 + -21528;
	// 832B4DB0: 4B8692A0  b 0x82b1e050
	sub_82B1E050(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4DB8 size=12
    let mut pc: u32 = 0x832B4DB8;
    'dispatch: loop {
        match pc {
            0x832B4DB8 => {
    //   block [0x832B4DB8..0x832B4DC4)
	// 832B4DB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4DBC: 386B4D30  addi r3, r11, 0x4d30
	ctx.r[3].s64 = ctx.r[11].s64 + 19760;
	// 832B4DC0: 4AF60018  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4DC8 size=12
    let mut pc: u32 = 0x832B4DC8;
    'dispatch: loop {
        match pc {
            0x832B4DC8 => {
    //   block [0x832B4DC8..0x832B4DD4)
	// 832B4DC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4DCC: 386B4D34  addi r3, r11, 0x4d34
	ctx.r[3].s64 = ctx.r[11].s64 + 19764;
	// 832B4DD0: 4AF60008  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4DD8 size=92
    let mut pc: u32 = 0x832B4DD8;
    'dispatch: loop {
        match pc {
            0x832B4DD8 => {
    //   block [0x832B4DD8..0x832B4E34)
	// 832B4DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4DDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4DE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B4DE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4DE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4DEC: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B4DF0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4DF4: 3BDFAC08  addi r30, r31, -0x53f8
	ctx.r[30].s64 = ctx.r[31].s64 + -21496;
	// 832B4DF8: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B4DFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4E00: 917FAC08  stw r11, -0x53f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21496 as u32), ctx.r[11].u32 ) };
	// 832B4E04: 4AF47205  bl 0x821fc008
	ctx.lr = 0x832B4E08;
	sub_821FC008(ctx, base);
	// 832B4E08: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4E0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4E10: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B4E14: 917FAC08  stw r11, -0x53f8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21496 as u32), ctx.r[11].u32 ) };
	// 832B4E18: 4AF471F1  bl 0x821fc008
	ctx.lr = 0x832B4E1C;
	sub_821FC008(ctx, base);
	// 832B4E1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B4E20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4E24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B4E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x832B4E38 size=92
    let mut pc: u32 = 0x832B4E38;
    'dispatch: loop {
        match pc {
            0x832B4E38 => {
    //   block [0x832B4E38..0x832B4E94)
	// 832B4E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 832B4E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 832B4E40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 832B4E44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 832B4E48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 832B4E4C: 3FE08332  lis r31, -0x7cce
	ctx.r[31].s64 = -2093875200;
	// 832B4E50: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4E54: 3BDFAC10  addi r30, r31, -0x53f0
	ctx.r[30].s64 = ctx.r[31].s64 + -21488;
	// 832B4E58: 396B2A30  addi r11, r11, 0x2a30
	ctx.r[11].s64 = ctx.r[11].s64 + 10800;
	// 832B4E5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4E60: 917FAC10  stw r11, -0x53f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21488 as u32), ctx.r[11].u32 ) };
	// 832B4E64: 4AF471A5  bl 0x821fc008
	ctx.lr = 0x832B4E68;
	sub_821FC008(ctx, base);
	// 832B4E68: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 832B4E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 832B4E70: 396B2A40  addi r11, r11, 0x2a40
	ctx.r[11].s64 = ctx.r[11].s64 + 10816;
	// 832B4E74: 917FAC10  stw r11, -0x53f0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-21488 as u32), ctx.r[11].u32 ) };
	// 832B4E78: 4AF47191  bl 0x821fc008
	ctx.lr = 0x832B4E7C;
	sub_821FC008(ctx, base);
	// 832B4E7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 832B4E80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 832B4E84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 832B4E88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 832B4E8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 832B4E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4E98 size=12
    let mut pc: u32 = 0x832B4E98;
    'dispatch: loop {
        match pc {
            0x832B4E98 => {
    //   block [0x832B4E98..0x832B4EA4)
	// 832B4E98: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4E9C: 386B4D60  addi r3, r11, 0x4d60
	ctx.r[3].s64 = ctx.r[11].s64 + 19808;
	// 832B4EA0: 4B7D0EF8  b 0x82a85d98
	sub_82A85D98(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4EA8 size=12
    let mut pc: u32 = 0x832B4EA8;
    'dispatch: loop {
        match pc {
            0x832B4EA8 => {
    //   block [0x832B4EA8..0x832B4EB4)
	// 832B4EA8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4EAC: 386B4DAC  addi r3, r11, 0x4dac
	ctx.r[3].s64 = ctx.r[11].s64 + 19884;
	// 832B4EB0: 4AF5FF28  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4EB8 size=12
    let mut pc: u32 = 0x832B4EB8;
    'dispatch: loop {
        match pc {
            0x832B4EB8 => {
    //   block [0x832B4EB8..0x832B4EC4)
	// 832B4EB8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4EBC: 386B4DB0  addi r3, r11, 0x4db0
	ctx.r[3].s64 = ctx.r[11].s64 + 19888;
	// 832B4EC0: 4AF5FF18  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4EC8 size=12
    let mut pc: u32 = 0x832B4EC8;
    'dispatch: loop {
        match pc {
            0x832B4EC8 => {
    //   block [0x832B4EC8..0x832B4ED4)
	// 832B4EC8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4ECC: 386B4DB4  addi r3, r11, 0x4db4
	ctx.r[3].s64 = ctx.r[11].s64 + 19892;
	// 832B4ED0: 4AF5FF08  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4ED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4ED8 size=12
    let mut pc: u32 = 0x832B4ED8;
    'dispatch: loop {
        match pc {
            0x832B4ED8 => {
    //   block [0x832B4ED8..0x832B4EE4)
	// 832B4ED8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4EDC: 386B4DB8  addi r3, r11, 0x4db8
	ctx.r[3].s64 = ctx.r[11].s64 + 19896;
	// 832B4EE0: 4AF5FEF8  b 0x82214dd8
	sub_82214DD8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4EE8 size=16
    let mut pc: u32 = 0x832B4EE8;
    'dispatch: loop {
        match pc {
            0x832B4EE8 => {
    //   block [0x832B4EE8..0x832B4EF8)
	// 832B4EE8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 832B4EEC: 806B4DBC  lwz r3, 0x4dbc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(19900 as u32) ) } as u64;
	// 832B4EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 832B4EF4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_832B4EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x832B4EF8 size=8
    let mut pc: u32 = 0x832B4EF8;
    'dispatch: loop {
        match pc {
            0x832B4EF8 => {
    //   block [0x832B4EF8..0x832B4F00)
	// 832B4EF8: 4AF47428  b 0x821fc320
	sub_821FC320(ctx, base);
	return;
	// 832B4EFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


